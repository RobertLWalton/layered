% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

December 21, 2006
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A machine independent reduced instruction set architecture
	  programming language.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& Similar to the C programming language but more flexible.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& Implements standardized lists, symbols, arrays, etc. to extend
	  the M-language to something comparable to LISP and shell
	  languages.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `{\tt hello}', `{\tt +}', `{\tt ;}',
`{\tt 9.200}' are four lexemes.

The lexical scanner is written in the H-Language and can be
replaced.  This section described the standard scanner which
is C/C++ compatible and is driven by the following atom tables:

\begin{center}
\begin{tabular}{l}
lexeme atom table \\
identifier atom tables \\
number atom tables \\
string atom tables \\
comment atom tables \\
whitespace atom tables \\
\end{tabular}
\end{center}

The (standard) scanner reads left to right, and at each point
identifies the next atom in the text, where an atom is a string
of characters explicitly listed in one of the atom tables.
If there are several possibilities, the longest is choosen.
To identify atoms, the scanner looks in one of the atom tables;
which table depends on the state of the scanner.  The table entry
for an atom contains an atom type, which determines subsequent
actions of the scanner.  The table entry can also contain a
translation, which is the string of characters the atom represents,
so that, for example, the translation of the atom `{\tt \BACKSLASH t}'
can be `horizontal tab'.

Each atom table has a name, consisting of either an identifier,
or of a quoted string followed by an identifier.  For example
the lexeme atom table is named `{\tt lexeme}', and the
atom table for a `{\tt /* */}' style C comment is named
`{\tt "/*" comment}'.

The general form of an atom table entry is:

\begin{center}
\begin{tabular}{rcl}
\emkey{lexical-atom-table-entry}
	& ::= & {\em lexical-atom} {\em lexical-atom-type} \\
	& & ~~~~[{\em lexical-atom-translation}] {\tt ;} \\
\emkey{lexical-atom} & ::= & {\em quoted-string} \\
\emkey{lexical-atom-type}
	& ::= & {\em lexical-atom-type-qualifier}$^\star$ {\em identifier} \\
\emkey{lexical-atom-type-qualifier}
	& ::= & {\em quoted-string} $|$ {\em identifier} \\
\emkey{lexical-atom-translation} & ::= & {\em quoted-string} \\
\end{tabular}
\end{center}%
\label{LEXICAL-ATOM-TABLE-ENTRY}

The following are some entries in the standard lexeme atom table:

\begin{indpar}\begin{verbatim}
"a"     identifier
"++"    operator
"+"     operator
";"     separator
"L'"    wide string
"\""    quoted string
"0"     octal number
".0"    number
\end{verbatim}\end{indpar}

Because of these entries the input string `{\tt ++a}' will be
recogonized as consisting of the operator lexeme `{\tt ++}' followed
by the beginning of an identifier.  `{\tt ++}' is choosen over `{\tt +}'
because it is longer.  The input string `{\tt ++L'}', however,
would be recognized as beginning with the operator lexeme `{\tt ++}'
followed by the beginning of a `{\tt "L'" string}'.

The state of the scanner is just the name of the atom table the
scanner is using.  Given input beginning with `{\tt ++a}', and the above table,
the scanner accepts the atom `{\tt ++}' as a lexeme and removes
it from the input.  Then given input beginning with `{\tt a}', the
scanner does not accept any input, but instead just switches state to
`{\tt identifier}' and continues by scanning identifer atoms.
In certain states, such as the `{\tt identifier}' state, the
scanner accumulates all the translations of the atoms accepted in
that state, and when the scanner switches out of the state, the
scanner ejects the accumulated string as a lexeme of the type
named by the state.

The following are some entries in the
standard `{\tt quoted string}' table:

\begin{indpar}\begin{verbatim}
"a"     character
"\\t"   character    "\t"
"\\""   character    "\""
"+"     character
"\""    begin        ""
"\""    end          ""
\end{verbatim}\end{indpar}

Here the input `{\tt \BACKSLASH t}' is translated to a horizontal
tab, the input `{\tt \BACKSLASH "}' is translated to
a single double quote,
and the `{\tt "}' character that is not part of another atom
translates to the empty string.
The `{\tt "}' character appears twice in the table, once as
a begin atom, which can only be recognized
at the beginning of a quoted string, and once as an end atom,
which ends the string and cannot appear at the beginning of
a string.  Most characters, like `{\tt a}' and
`{\tt +}', translate to themselves.

In defining lexeme atom table, we say that an atom is
\ikey{accepted}{lexical atom} if it is removed from the input string, and
\ikey{rejected}{lexical atom} if it is not.  An atom is said to be
\ikey{accumulated}{lexical atom} if it is accepted and its translation
is added to the lexeme string currently being accumulated.  This string
is output as a lexeme of the type of the current lexical scanner state
when the scanner switches out of that state.

This scheme for lexical scanning is intended to give the user
control over the set of operators, punctuation, characters
that can appear in identifiers, character representatives in
quoted strings, etc.  The atom tables are quite verbose, and
are usually compiled from a more compact representation.

\subsection{The Lexeme Atom Table}

Then the scanner is in the {\tt lexeme} state, it can accept
atoms and output them as complete lexemes, or it can reject
atoms and switch to a different state.  Translations are
\underline{not} accumulated in this state.  If these is no
recognizable atom at the beginning of the input, a single
character atom is accepted and output as a

The following are the possible types in the lexeme atom table:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{3.5in}}
\ttkey{operator}	& The atom is accepted as an operator lexeme.
\\[1ex]
\ttkey{separator}	& The atom is accepted as a separator lexeme.
\\[1ex]
[{\em qualifier}]
\ttkey{identifier}	& The atom is rejected and the state becomes \\
			& `[{\em qualifier}] {\tt identifier}'.
\\[1ex]
[{\em qualifier}]
\ttkey{number}		& The atom is rejected and the state becomes \\
			& `[{\em qualifier}] {\tt number}'.
\\[1ex]
[{\em qualifier}]
\ttkey{string}		& The atom $A$ is rejected and the state becomes \\
			& `[{\em qualifier}] {\tt string}'.
\\[1ex]
[{\em qualifier}]
\ttkey{comment}		& The atom $A$ is rejected and the state becomes \\
			& `[{\em qualifier}] {\tt comment}'.
\\[1ex]
[{\em qualifier}]
\ttkey{whitespace}	& The atom is rejected and the state becomes \\
			& `[{\em qualifier}] {\tt whitespace}'.
\end{tabular}
\end{center}

\subsection{Identifier Atom Tables}

Then the scanner is in a `[{\em qualifier}] {\tt identifier}' state,
it can accumulate
atoms, or it can reject atoms and switch to a different state.
Translations of accumulated atoms are appended to the current
accumulation string, which is output as an identifier lexeme
when the scanner leaves the {\tt identifier} state.
If there is no recognizable atom at the beginning of the input,
the scanner switches to the {\tt lexeme} state without accepting
any input.

The following are the possible types in an identifier atom table:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\ttkey{character} & Accept and accumulate the atom.
\\[1ex]
\ttkey{begin}	  & Accept and accumulate the atom, but only
		    recognize the atom if it is the first atom.
\\[1ex]
\ttkey{continue}  & Accept and accumulate the atom, but only
		    recognize the atom if it is \underline{not} the first
		    atom in the {\tt identifier} state.
\\[1ex]
\ttkey{end}	  & Accept and accumulate the atom, but only
		    recognize the atom if it is \underline{not} the first
		    atom in the {\tt identifier} state.  After
		    accepting the atom, switch into the {\tt lexeme} state.
\\[1ex]
\ttkey{error}	  & Accept and discard the atom, and announce that the
		    atom is in error.
\\[1ex]
\end{tabular}
\end{center}

\subsection{Number Atom Tables}

Then the scanner is in a `[{\em qualifier}] {\tt number}' state,
it can accumulate
atoms, or it can reject atoms and switch to a different state.
Translations of accumulated atoms are appended to the current
accumulation string, which is output as a number lexeme
when the scanner leaves the `[{\em qualifier}] {\tt identifier}' state.
If there is no recognizable atom at the beginning of the input,
the scanner switches to the {\tt lexeme} state without accepting
any input.

The following are the possible types in a number atom table:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\ttkey{digit}	& Accept and accumulate the atom, but only recognize
		  the atom if it is \underline{not} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{begin digit}
		& Accept and accumulate the atom, but only
		  recognize the atom if it is the first atom.
\\[1ex]
\ttkey{continue digit}
		& Accept and accumulate the atom, but only
		  recognize the atom if it is \underline{not}
		  the first atom and \underline{not} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{point}	& Accept and accumulate the atom, but only recognize
                  the atom if it is \underline{not}
		  after either another {\tt point}
		  or a {\tt begin exponent} atom.
\\[1ex]
\ttkey{suffix}
		& Accept and accumulate the atom, but only recognize
		  the atom if it is \underline{not} the first atom.
		  After accepting the atom, the scanner switches
		  to {\tt lexeme} state.
\\[1ex]
\ttkey{floating suffix}
		& Like suffix, but \underline{must} be after a point
		  or begin exponent.
\\[1ex]
\ttkey{integer suffix}
		& Like suffix, but must \underline{not} be after a point
		  or begin exponent.
\\[1ex]
\ttkey{begin exponent}
		& Accept and accumulate the atom, but only recognize
		  the atom if it is \underline{not} the first atom
		  and is \underline{not} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{exponent digit}
		& Accept and accumulate the atom, but only recognize
		  the atom if it \underline{is} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{error}	  & Accept and discard the atom, and announce that the
		    atom is in error.

\end{tabular}
\end{center}

Some example number atom tables are:

~~{\tt hex number} atom table (for integers):

\begin{indpar}\begin{verbatim}
"0x0"   begin digit
"0x1"   begin digit
. . . . . . . . . .
"0xF"   begin digit
"0"     digit
"1"     digit
. . . . . . . . . .
"F"     digit
"l"     suffix
"u"     suffix
. . . . . . . . . .
"UL"    suffix
\end{verbatim}\end{indpar}

~~{\tt number} atom table:

\begin{indpar}\begin{verbatim}
"0"     digit
"1"     digit
. . . . . . . . . .
"9"     digit
"."     point
"E0"    begin exponent
"E1"    begin exponent
. . . . . . . . . .
"E+0"   begin exponent
"E+1"   begin exponent
. . . . . . . . . .
"e-9"   begin exponent
"0"     exponent digit
"1"     exponent digit
. . . . . . . . . .
"9"     exponent digit
"l"     suffix
"f"     suffix
"L"     suffix
"F"     suffix
\end{verbatim}\end{indpar}

\subsection{String Atom Tables}

A `[{\em qualifier}] {\tt identifier}' state behaves just like
an {\tt identifier} state, with `{\tt identifier}' replaced
by `{\tt string}', except that if the input does not begin with
a recognized atom, the first character of the input is accepted,
and the state does not change.  Thus {\tt end} atoms must be used
to end a {\tt string} scan state.

\subsection{Comment Atom Tables}

A `[{\em qualifier}] {\tt comment}' state behaves just like
an {\tt string} state, with `{\tt string}' replaced
by `{\tt comment}', except that when the scanner leaves a comment
state the accumulated string is discarded, and \underline{not}
made into a lexeme.

\subsection{Whitespace Atom Tables}

A `[{\em qualifier}] {\tt whitespace}' state behaves just like
an {\tt comment} state, with `{\tt comment}' replaced
by `{\tt whitespace}', except that when the input does not begin
with a recognized atom, no input is accepted, and the scanner
switches to {\tt lexeme} state.  When the scanner leaves a {\tt whitespace}
state the accumulated string is discarded, and \underline{not}
made into a lexeme.

\subsection{Lexeme Table Definitions}

Lexeme tables for the standard lexical scanner are written in
the \key{Lexeme Definition Language}.  This language consists
of statements placed in a separate file and written using
lexemes defined by the standard tables of the standard lexical
scanner.  Lexeme Definition Language statements have the following form:


\begin{center}
\begin{tabular}{rrl}
\emkey{lexical-units-definition} & ::= &
	{\tt begin} {\tt lexical units;} \\
	& &  ~~~~{\em lexical-unit-definition}$^\star$ \\
	& & {\tt end} {\tt lexical units;}
\\[1ex]
\emkey{lexical-atom-table-definition} & ::= &
	{\tt begin} {\em lexical-atom-type} {\tt atom table;} \\
	& &  ~~~~{\em lexical-atom-table-entry}$^\star$ \\
	& & {\tt end} {\em lexical-atom-type} {\tt atom table;}
\\[1ex]
\emkey{lexical-unit-definition} & ::= &
	{\tt "}{\em lexical-unit-name}{\tt "} {\tt ::=} \\
	& & ~~~~{\em lexical-unit} \{ {\tt |} {\em lexical-unit} \}$^\star$
	    {\tt ;}
\\[1ex]
\emkey{lexical-unit-name} & ::= & {\tt <}\{{\em letter}$|${\tt -}\}$^+${\tt >}
\\[1ex]
\emkey{lexical-unit} & ::= & {\em quoted-string}
\\[1ex]
\emkey{lexical-atom-table-entry}
	& ::= & see page \pageref{LEXICAL-ATOM-TABLE-ENTRY}
\end{tabular}
\end{center}

\begin{boxedfigure}

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<letter>" ::= "A" | "B" | "C" | "D" | "E" | "F" | "G"
                 | "H" | "I" | "J" | "K" | "L" | "M"
                 | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
                 | "U" | "V" | "W" | "X" | "Y" | "Z"
                 | "a" | "b" | "c" | "d" | "e" | "f" | "g"
                 | "h" | "i" | "j" | "k" | "l" | "m"
                 | "n" | "o" | "p" | "q" | "r" | "s" | "t"
                 | "u" | "v" | "w" | "x" | "y" | "z" ;
    "<non-zero-digit>" ::=       "1" | "2" | "3" | "4"
                        | "5" | "6" | "7" | "8" | "9" ;
    "<digit>" ::= "0" | "<non-zero-digit>"
    "<oct-digit>" ::= "0" | "1" | "2" | "3"
                    | "4" | "5" | "6" | "7";
    "<hex-digit>" ::= "A" | "B" | "C" | "D" | "E" | "F"
                    | "a" | "b" | "c" | "d" | "e" | "f"
                    | <digit>;
    "<operator>" ::= "!" | "%" | "^" | "&" | "*"
                   | "(" | ")" | "-" | "+" | "="
                   | "{" | "}" | "|" | "~" | "["
                   | "]" | ";" | ":" | "<" | ">"
                   | "?" | "," | "/" | "/" | "->"
                   | "++" | "--" | ".*" | "->*" | ">>"
                   | "<<" | "<=" | ">=" | "==" | "!="
                   | "&&" | "||" | "*=" | "/=" | "%="
                   | "+=" | "-=" | "<<=" | ">>=" | "&="
                   | "^=" | "|=" | "::";
    "<whitespace>" ::= " " | "\t" | "\n" | "\r"
                     | "\f" | "\v";
end lexical units;
    
\end{verbatim}\end{indpar}

\caption{Standard Lexical Units; Part I}
\label{STANDARD-LEXICAL-UNITS-1}
\end{boxedfigure}

\begin{boxedfigure}

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<control>" ::=          "\001" | "\002" | "\003"
                  | "\004" | "\005" | "\006" | "\007"
                  | "\010" 
                                    | "\016" | "\017"
                  | "\020" | "\021" | "\022" | "\023"
                  | "\024" | "\025" | "\026" | "\027"
                  | "\030" | "\031" | "\032" | "\033"
                  | "\034" | "\035" | "\036" | "\037"
                  | "\177";

    "<oct1>" ::= "<oct-digit>";
    "<oct2>" ::= "<oct-digit><oct1>";
    "<oct3>" ::= "<oct-digit><oct2>";
    "<oct4>" ::= "<oct-digit><oct3>";
    "<oct5>" ::= "<oct-digit><oct4>";
    "<oct6>" ::= "<oct-digit><oct5>";
    "<oct-char>" ::= "\\<oct1" | "\\<oct2>"
                   | "\\0<oct2>" | "\\1<oct2>"
                   | "\\2<oct2>" | "\\3<oct2>";
    "<bad-oct-char>" ::= "\\4<oct2>" | "\\5<oct2>"
                       | "\\6<oct2>" | "\\7<oct2>"
                       | "\\<oct3>";
    "<oct-wchar>" ::= "<oct-char>"
                    | "\\<oct3>" | "\\<oct4>"
                    | "\\<oct5>" | "\\0<oct5>"
                    | "\\1<oct5>";
    "<bad-oct-whar>" ::= | "\\2<oct5>" | "\\3<oct5>"
                         | "\\4<oct5>" | "\\5<oct5>"
                         | "\\6<oct5>" | "\\7<oct5>"
                         | "\\<oct6>";
end lexical units;
    
\end{verbatim}\end{indpar}

\caption{Standard Lexical Units; Part II}
\label{STANDARD-LEXICAL-UNITS-2}
\end{boxedfigure}

\begin{boxedfigure}

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<hex1>" ::= "<hex-digit>";
    "<hex2>" ::= "<hex-digit><hex1>";
    "<hex3>" ::= "<hex-digit><hex2>";
    "<hex4>" ::= "<hex-digit><hex3>";
    "<hex5>" ::= "<hex-digit><hex4>";
    "<hex-char>" ::= "\\x<hex1>" | "\\x<hex2>"
                   | "\\X<hex1>" | "\\X<hex2>";
    "<bad-hex-char>" ::= "\\x<hex3>" | "\\X<hex3>";
    "<hex-wchar>" ::= "<hex-char>"
                   | "\\x<hex3>" | "\\x<hex4>"
                   | "\\X<hex3>" | "\\X<hex4>";
    "<bad-hex-wchar>" ::= "\\x<hex5>" | "\\X<hex5>";

    "<backslash-char>" ::= "<oct-char>" | "<hex-char>";
    "<backslash-wchar>" ::= "<oct-wchar>" | "<hex-wchar>";
    "<bad-backslash-char>" ::= "<bad-oct-char>"
                             | "<bad-hex-char>";
    "<bad-backslash-wchar>" ::= "<bad-oct-wchar>"
                              | "<bad-hex-wchar>";

    "<integer-suffix>" ::= "u" | "U" | "l" | "L"
                         | "ul" | "Ul" | "uL" | "UL"
                         | "lu" | "Lu" | "lU" | "LU";
    "<floating-suffix>" ::= "f" | "F" | "d" | "D";

    "<backslash-control>" ::= "\\f" | "\\v" | "\\n" | "\\r"
                            | "\\t" | "\\b" | "\\a" | "\\?"
                            | "\\\'" | "\\\"" | "\\\\";
end lexical units;
    
\end{verbatim}\end{indpar}

\caption{Standard Lexical Units; Part III}
\label{STANDARD-LEXICAL-UNITS-3}
\end{boxedfigure}

\begin{boxedfigure}

\begin{indpar}\begin{verbatim}
begin lexeme atom table;
    "<operator>"        operator;
    "<separator>"       separator;
    "<letter>"          identifier;
    "0x<hex-digit>"     hex number;
    "0X<hex-digit>"     hex number;
    "0<oct-digit>"      oct number;
    "<non-zero-digit>"  number;
    "L'"                wide char string;
    "'"                 char string;
    "L\""               wide quoted string;
    "\""                quoted string;
    "//"                line comment;
    "/*"                comment;
    "<whitespace>"      whitespace;
end lexeme atom table;

// Note that C/C++ keywords are identifiers.
//
begin identifier atom table;
    "<letter>"  character
    "_"         character
    "<digit>"   continue
    "<control>" error
end identifier atom table;
    
\end{verbatim}\end{indpar}

\caption{Standard Lexeme Atom Table}
\label{STANDARD-LEXEME-ATOM-TABLE}
\end{boxedfigure}

\begin{boxedfigure}

\begin{indpar}\begin{verbatim}
begin hex number atom table;
    "<hex-digit>"       continue digit;
    "0x<hex-digit>"     begin digit;
    "0X<hex-digit>"     begin digit;
    "<integer-suffix>"  integer suffix;
    "<control>"         error
end hex number atom table;
 
begin oct number atom table;
    "<oct-digit>"       continue digit;
    "0"                 begin digit;
    "<integer-suffix>"  integer suffix;
    "<control>"         error
end oct number atom table;
 
begin number atom table;
    "<digit>"           digit;
    "."                 point;
    "e<sign><digit>"    begin exponent;
    "E<sign><digit>"    begin exponent;
    "<digit>"           exponent digit;
    "<integer-suffix>"  integer suffix;
    "<floating-suffix>" floating suffix;
    "<control>"         error
end number atom table;
\end{verbatim}\end{indpar}

\caption{Standard Number Atom Tables}
\label{STANDARD-NUMBER-ATOM-TABLES}
\end{boxedfigure}

\begin{boxedfigure}

\begin{indpar}\begin{verbatim}
 
begin quoted string atom table;
    "\""                    begin;
    "\""                    end;
    "<backslash-control>"   continue  "<char backslash-control>";
    "<backslash-char>"      continue  "<char backslash-char>";
    "<bad-backslash-char>"  error;
    "<control>"             error;
end quoted string atom table;
 
begin wide quoted string atom table;
    "L\""                   begin;
    "\""                    end;
    "<backslash-control>"   continue  "<char backslash-control>";
    "<backslash-wchar>"     continue  "<char backslash-wchar>";
    "<bad-backslash-wchar>" error;
    "<control>"             error;
end quoted string atom table;
 
begin char string atom table;
    "\'"                begin;
    "\'"                end;
    . . . rest just like quoted string table . . .
end char string atom table;
 
begin wide char string atom table;
    "L\'"               begin;
    "\'"                end;
    . . . rest just like wide quoted string table . . .
end char string atom table;

\end{verbatim}\end{indpar}

\caption{Standard Quoted String Atom Tables}
\label{STANDARD-QUOTED-STRING-ATOM-TABLES}
\end{boxedfigure}


\section{Parsing}



\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
