% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttnbakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\ttitemref}[1]{{\tt \ref{#1} ({p\pageref{#1}})}}
\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

April 22, 2010
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A machine independent reduced instruction set architecture
	  programming language.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& Similar to the C programming language but more flexible.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& Implements standardized lists, symbols, arrays, etc. to extend
	  the M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `{\tt hello}', `{\tt +}', `{\tt ;}',
`{\tt 9.200}' are four lexemes.

The lexical scanner is written in the H-Language and can be
replaced.  This section describes the standard scanner which
is driven by the atom tables and is capable scanning
lexemes of common languages such as C and C++.

The standard scanner attempts to be both machine and human
efficient.  It attempts to be machine efficient by being
deterministic\footnote{Unlike regular expression scanners}
and attempts to be human efficient by supporting algorithms
that people can readily understand and hopefully quickly
learn to mimic.\footnote{A possibly non-verifiable goal.}

The standard scanner identifies lexical atoms in the text.
A \key{lexical atom} is a single character (e.g., the letters
in an identifier or symbol) or a short string of characters
(e.g., the characters \verb|\n| in a quoted string).
Lexical atoms are read left to right and
grouped by the scanner into \skey{lexeme}s,
which are the output of the scanner.

The scanner has a state consisting of a current point 
in the input UNICODE character stream and a current atom table identifier.  An
\key{atom table} is a set of atom patterns
that match lexical atoms, and for each pattern an
instruction that determines what to do when the pattern is matched.
There is also an instruction associated with the atom table that
determines what to do when no table pattern matches the next characters
in the input stream.

An \key{atom pattern}\index{pattern!lexical atom} is a fixed
length sequence of character patterns, and matches any sequence of
UNICODE characters of the same length as the atom pattern
if each character of the sequence matches the corresponding
character pattern.  A \key{character pattern} is simply a
specification of a set of characters, e.g., letters or digits.
Thus one can construct an atom pattern that will recognize
a single letters, or one that will recognize the sequence of
characters \verb|\u<hexdigit><hexdigit><hexdigit><hexdigit>|.

The atom patterns of a single atom table may not conflict:
no character string can be recognized by two atom patterns of the
same atom table.

The scanner operates by identifying the
longest sequence of characters beginning at the current input character
stream point that matches an atom pattern of the current atom.
This sequence of characters becomes
the next atom, and an instruction associated with its matching
atom pattern is then executed.  If no atom pattern can be matched,
the instruction associated with the atom table is executed instead.

An atom pattern or atom table
instruction can optionally reduce the length of a matched atom
and optionally change the current atom table.

Atom tables have modes that are either lexeme kinds or
are the special mode `\ttmkey{master}{mode}'.  When the
current lexical atom table is changed to a new table of
`\verb|master|' mode, any non-zero length lexeme accumulated
so far is output as a lexeme whose \mkey{kind}{lexeme} equals
the mode of the previous current atom table.  Thus if an atom table of
mode `\verb|whitespace|' cannot recognized any atom and
the instruction associated with it that is executed in this
case changes the current atom table to one of `\verb|master|'
mode, any non-zero length lexeme accumulated so far will
be output as a lexeme of kind `\verb|whitespace|'.

The lexeme output consists of a sequence of characters in the
input character stream.  In addition there is a translation
of this lexeme.  Each atom is translated by the
instruction that is executed when the atom is recognized.
By default atoms are not changed by translation but merely copied to the end
of current lexeme's translation.  But any set of characters can be
included in the instruction and
copied instead.  For example, for the lexeme \verb|"a line\n"| the
\verb|"| atoms can be translated to zero length strings and the
\verb|\n| atom can be translated to a single line feed character.
If the other characters are copied as is to the translation, then
the translation will contain 5 letters, one single space character,
and one line feed character.

A \key{lexical program} is a set of character pattern definitions,
atom pattern definitions, and atom tables, with a designated atom
table to serve as initial state.  A lexical program can include
another lexical program.

\subsection{Lexical Programs}

The syntax of a lexical program is given on
\pagref{LEXEME-PROGRAM-SYNTAX-1} and
\pagref{LEXEME-PROGRAM-SYNTAX-2}.

\begin{figure*}[!p]
\begin{tabular}{p{2.2in}rl}
\emkey{name}
    & ::= & {\em word}
            \{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}$^\star$
\end{tabular}

\begin{tabular}{p{2.2in}rl}
\emkey{lexical-program} & ::= &
	{\tt begin} {\em program-name} {\tt lexical program;}\\
	& &  ~~~~{\em lexical-program-unit}$^\star$ \\
	& & {\tt end} {\em program-name} {\tt lexical program};
\\[1ex]
\emkey{program-name} & ::= & {\em name}
\\[1ex]
\emkey{lexical-program-unit}
	& ::= & {\em cpat-definition} \\
	& $|$ & {\em atom-table-definition} \\
	& $|$ & {\em program-inclusion}
\\[1ex]
\emkey{program-inclusion} & ::= & {\tt include} {\em program-name}
				  {\em remove-clause}$^\star$ {\tt ;}
\\[1ex]
\emkey{remove-clause} & ::= & {\tt remove} {\em atom-table-name} \\
                      & $|$ & {\tt remove} {\tt "}{\em cpat-name}{\tt "}
\\[1ex]
\multicolumn{3}{l}{~~~~~~~~`{\em cpat}' abbreviates `{\em character-pattern}'}
\\[1ex]
\emkey{cpat-definition} & ::= &
	{\tt "}{\em cpat-name}{\tt "} {\tt =}
		{\em cpat-expression} {\tt ;}
\\[1ex]
\emkey{cpat-name} & ::= &
	{\tt <}{\em letter}$^+$\{{\tt -}{\em letter}$^+$\}$^\star${\tt >}
\\[1ex]
\emkey{cpat-expression} & ::= &
	{\em cpat-term}
	\{ {\tt |} {\em cpat-term} \}$^\star$ \\
       & $|$ &
	{\em cpat-term}
	\{ {\tt \&} {\em cpat-term} \}$^\star$
\\[1ex]
\emkey{cpat-term} & ::= & {\em cpat-factor} $|$ \TILDE {\em cpat-factor}
\\[1ex]
\emkey{cpat-factor} & ::= & {\tt "}{\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em quotable-character}{\tt -}%
		                   {\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em cpat-name}{\tt "} \\
		    & $|$ & {\tt (} {\em cpat-expression}
		                {\tt )}
\\[1ex]
\emkey{quotable-character} & ::= & 
	any quotable UNICODE character representative
\\[1ex]
\emkey{atom-table-definition} & ::= &
	{\tt begin} {\em atom-table-name}
		    {\tt atom table} {\tt ;} \\
	& &  ~~~~{\em mode-option} \\
	& &  ~~~~{\em atom-table-entry}$^\star$ \\
	& &  ~~~~{\em goto-option} \\
	& & {\tt end} {\em atom-table-name} {\tt atom table;}
\\[1ex]
\emkey{mode-option} & ::= & {\em empty} $|$ {\tt mode} {\em mode-name}
                                        $|$ {\tt kind} {\em kind-name}
\\[1ex]
\emkey{mode-name} & ::= &  {\tt master} $|$ {\em kind-name}
\\[1ex]
\emkey{goto-option} & ::= &  {\em empty} $|$ {\tt goto} {\em atom-table-name}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-1}
\end{figure*}

\begin{figure*}[!t]
\begin{tabular}{p{2.2in}rl}
\emkey{atom-table-entry}
	& ::= & {\em atom-pattern} {\em instruction-option} {\tt ;}
\\[1ex]
\emkey{instruction-option} & ::= &
    {\em empty} $|$ {\em instruction-component}$^+$
\\[1ex]
\emkey{atom-pattern} & ::= &
	{\tt "}\{{\em quotable-character}$|${\em cpat-name}\}$^\star${\tt "}
\\[1ex]
\emkey{instruction-component}
	& ::= & {\tt keep} {\em natural-number} \\
	& $|$ & {\em translation} \\
	& $|$ & {\tt translate-hex} \begin{tabular}[t]{l}
			{\em natural-number} {\em natural-number} \\
		        {\em cpat-option}
			\end{tabular} \\
	& $|$ & {\tt translate-oct} \begin{tabular}[t]{l}
			{\em natural-number} {\em natural-number} \\
		        {\em cpat-option}
			\end{tabular} \\
	& $|$ & {\tt erroneous} {\em kind-name} \\
	& $|$ & {\tt goto} {\em atom-table-name} \\
	& $|$ & {\tt singleton} {\em kind-name}
\\[1ex]
\emkey{translation} & ::= & {\em quoted-string}
\\[1ex]
\emkey{cpat-option} & ::= & {\em empty} \\
                    & $|$ & {\tt "}{\em cpat-name}{\tt "}
		            {\tt else} {\em instruction-component}$^+$
\\[1ex]
\emkey{kind-name} & ::= & {\em name} \begin{tabular}[t]{@{}r@{~}l@{}}
                                     except & {\tt master} \\
				         or & {\tt end of file} \\
					 or & {\tt scan error} \\[1ex]
				    \end{tabular}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-2}
\end{figure*}

A \emkey{lexical-program} consists of a sequence of
{\em character-\EOL pattern-\EOL defi\-ni\-tions},
{\em atom-\EOL table-\EOL defi\-ni\-tions},
and {\em program-inclusions}.  These define character pattern sets
and atom tables, and include in the lexical program definitions from
other previously defined lexical programs.

A \emkey{program-inclusion} names a previously defined lexical program
whose definitions are to be included in the current lexical program
at the point of the {\em program-inclusion}.  Identical definitions
may be repeated without error,
as can happen when one program includes two each of
which include the same third program.
A {\em program-inclusion} can have
\emsmkey{remove-clause}s{in {\em program-inclusion}}
each of which removes a named definition from the set of included
definitions.  This is the only way to resolve conflicts between
definitions.

\subsection{The Lexeme Definition Language}

Lexeme tables for the standard lexical scanner are written in
the \key{Lexeme Definition Language}.  This language defines
a {\em lexical-groups} that are sets of lexical atom tables.
These groups can be referenced from code when the currently effective
set of lexical atom tables needs to be changed.

Lexeme Definition Language consists of {\em lexical-definitions} with
the following syntax:


{\em Lexical-units} are used to abbreviate sets of lexical atom tables.
{\em Lexical-classes} are used in {\em lexeme-types}, which name
lexical atom tables.  They are a way of setting default
{\em lexical-options} for the tables.  {\em Lexical-groups} name sets
of lexical atom tables.  Lexical atom tables are generally defined in
a separate file, and {\em lexical-groups} are used in other files
as names of sets of the tables.  The {\em lexeme-type} that names
a lexical atom table can also be used as a {\em lexical-group}
naming the set whose only element is just that table.

A \emkey{lexical-unit} names a set of quoted strings.  Definitions of
lexical units may \underline{not} be recursive.

A {\em Lexical-unit} begins with `\verb|<|' and ends with `\verb|>|'
and appears inside quoted strings.  A
{\em lexical-unit} appearing in a quoted string after a {\tt ::=} in a
{\em lexical-unit-definition}, or anywhere in a
{\em lexical-atom-table-entry}, is
\ikey{replaceable}{lexical-unit-name@{\em lexical-unit-name}}.
The replacements for such a {\em lexical-unit} are the
strings in the set it names.

Each entry or definition containing replaceable {\em lexical-unit}
is expanded to a separate copy for each replacement of the name.
If a single name appears twice, it is replaced by the same string in
each occurrence.  If two or more different names appear,
every combination of replacements generates another copy of the
entry or definition.

Thus

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<digit>" ::= "0" | "1";
    "<sign>"  ::= "+" | "-";

    "<doubled-digit>" ::= "<digit><digit>";

    "<one-digit>"  ::= "<digit>";
    "<two-digits>" ::= "<one-digit><digit>";
end lexical units;
\end{verbatim}\end{indpar}

is equivalent to

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<digit>" ::= "0" | "1";

    "<doubled-digit>" ::= "00" | "11";

    "<one-digit>"  ::= "0" | "1";
    "<two-digits>" ::= "00" | "01" | "10" | "11";
end lexical units;
\end{verbatim}\end{indpar}

and given these {\em lexical-unit-definitions},

\begin{indpar}\begin{verbatim}
begin lexeme atom table;
    "<digit>"                 number;
    "<digit><digit>"          double number "D<digit>";
    "<digit><one-digit>"      two digit number;
end lexeme atom table;
\end{verbatim}\end{indpar}

is equivalent to

\begin{indpar}\begin{verbatim}
begin lexeme atom table;
    "0"                       number;
    "1"                       number;
    "00"                      double number "D0";
    "11"                      double number "D1";
    "00"                      two digit number;
    "01"                      two digit number;
    "10"                      two digit number;
    "11"                      two digit number;
end lexeme atom table;
\end{verbatim}\end{indpar}

Lexical atoms and their translations in the lexical atom tables
are all required to be complete legal UTF-8 character strings.
As a consequence, all recognized atoms will be such, and it will
not matter whether the lexical analyzer actually uses 8-bit bytes
or 16-bit UNICODE characters in its implementation.

A \key{lexical context} consists of a stack of {\em lexical-definitions}.
If definitions in the stack have the same name,
the topmost is used.  Note that names of different kinds of definitions
do \underline{not} conflict: the same identifier can be used as a
{\em lexeme-type} that names a lexical atom
table and as a {\em lexical-class}.  Here a {\em lexical-atom-table-definition}
also serves as a {\em lexical-group-definition} defining its
{\em lexeme-type} as a {\em lexical-group} naming the set consisting of
just the table.

A file containing {\em lexical-definitions}
defines a lexical context into which is pushed each definition as it
occurs.  The lexical context used to scan such a file is different from
the lexical context being defined by the file, so the definitions themselves
are \underline{not} scanned using the context they define.
However, the definitions use the context being defined to look up
names, e.g., {\em lexical-units} in quoted strings
and {\em lexeme-types} in {\em lexical-group-definitions}.

If a {\em lexical-unit} is defined that
is equal to \ttnbakey{"\LESSTHAN remove\GREATERTHAN"}{remove},
this has the effect of removing the
{\em lexical-unit} from the set of {\em lexical-units} defined by a context.
It is as if the unit had never been defined.
If a lexical atom table with the `\ttkey{remove}' option\label{REMOVE}
is defined, it
has the effect of removing its {\em lexeme-type} name from the set of
defined {\em lexeme-types}.  Similarly for {\em lexical-classes}.
If a {\em lexical-group} is defined to be the singleton set
`\ttkey{remove}', this has the effect
of removing the {\em lexical-class} from the set of
defined {\em lexical-classes}.

The \key{default lexical context}\index{lexical context!default}%
\index{context!lexical default} is defined using standard
{\em lexical-definitions} given
in Appendix~\secref{STANDARD-LEXICAL-PROGRAM}.
This is normally used to scan files containing lexical definitions.

Other layered programming languages use lexical contexts that consist
of nothing but a stack of lexical atom tables, each table being treated
as equivalent to a definition of the table.  These are
modified by importing {\em lexical-groups} within a code block.
When a {\em lexical-group} is imported, its lexical atom tables are pushed
into the current lexical context.  At the end of the code block into which the
group is imported, the tables are popped from the context.
A table with the `{\tt remove}' option can be used to temporarily
hide all tables with the same name.

\subsubsection{Lexical Unit Translators}
\label{LEXICAL-UNIT-TRANSLATORS}

The standard {\em lexical-definitions} given in
Appendix~\secref{STANDARD-LEXICAL-PROGRAM} include
the following entries in the `{\em quoted string atom}' table:

\begin{indpar}\begin{verbatim}
    "<backslash-control>"   continue  "<char backslash-control>";
    "<backslash-char>"      continue  "<char backslash-char>";
\end{verbatim}\end{indpar}

These entries invoke the `{\tt char translator}' which does things
like translate the string {\tt "\BACKSLASH\BACKSLASH n"}
to {\tt "\BACKSLASH n"}.  Here the first
string is a backslash character followed by the letter `{\tt n}',
and the second string is just a single line feed character.
As a consequence, when `{\tt \BACKSLASH n}' (represented
by {\tt "\BACKSLASH\BACKSLASH n"}) is substituted for
`{\tt <backslash-control>}' in the first
entry above, `{\em line-feed}\,' (represented by
by {\tt "\BACKSLASH n"}) is substituted for
`{\tt <char backslash-control>}' in entry.
This produces:

\begin{indpar}\begin{verbatim}
    "\\n"   continue  "\n";
\end{verbatim}\end{indpar}

A \key{lexical translator} is a lexical atom table whose lexical
class is `\ttkey{translator}'.  It can be used in
{\em translated-lexical-units} which have names of the form:

\begin{indpar}
\end{indpar}

The strings of the translated lexical unit
    {\tt <}{\em lexical-translator} {\em lexical-unit-name}{\tt >}
are the strings of the lexical unit
    {\tt <}{\em lexical-unit-name}{\tt >}
run through a translation process that uses just the lexical atom
table named `{\em lexical-translator} {\tt translator}' (this is
the {\em lexeme-type} of the table).  To translate a string,
a lexical scan is made with the string as input and the
`{\em lexical-translator} {\tt translator}' table as the only
lexical atom table and only state.  The string accumulated in this
state is the translation.  The translation ends when the input
string ends.

The standard {\em lexical-definitions} given in
Appendix~\secref{STANDARD-LEXICAL-PROGRAM} include
a single {\tt translator} table, `{\tt char translator}' which provides
for the translations needed elsewhere in the standard definitions.
This table translates character sequences that can appear in a standard
quoted string into their UTF-8 equivalents.  For example,
\verb|"\\xFFFF"| is translated to \verb|"\xEF\xBF\xBF"|,
and \verb|"\\n"| is translated to \verb|"\n"|,
while \verb|"A"| is translated to \verb|"A"|.
In order to accommodate variants such as \verb|"\\xffff"|
and \verb|"XFFFF"| this table has several million entries.

\subsubsection{Lexical Options}

A lexical atom table has \emskey{lexical-option}s that control the behavior
of the table.  A {\em lexical-class} has {\em lexical-options} that become
the default set of options for any table whose naming {\em lexeme-type} ends
with the {\em lexical-class}.
Tables whose definitions do not give a parenthesized list
of options inherit their options from their class.

The following are the effects of the different {\em lexical-options}:

\begin{indpar}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\emkey{lexeme-type}
		& This is the \key{default exit state}\label{DEFAULT-EXIT-STATE}
		  of the table.
		  The current scanning state is change to this state
		  under various circumstances described in the following
		  options.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{continue}& By default, if no atom can be recognized by the
                  table, the state is changed to the default exit
		  state of the table.  This `{\tt continue}' option
		  causes the first legal UTF-8 character string
		  in the remaining input to be recognized as an atom
		  and accepted, instead.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{error}   & By default, if the beginning of the remaining input
		  does not hold a legal UTF-8 character string (one that
		  encodes a 16-bit UNICODE character), the state
		  is changed to the default exit state of the table.
		  This `{\tt error}' options causes characters to be
		  removed from the remaining input until the input
		  begins with a legal UTF-8 charcter string, and
		  an error to be announced concerting these characters,
		  without changing the state.  The removed characters
		  are effectively discarded and not include in any
		  lexeme.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{discard}	& By default, any string accumulated by the action of
		  the table is emitted as a lexeme when the state
		  is changed to exit the table.
		  This `{\tt discard}' option causes the
		  string to be discarded instead.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{error}	& By default, any string accumulated by the action of
		  the table is not announced as an error the state
		  is changed to exit the table.  This `{\tt error}'
		  option causes the string to be announced as an error
		  instead.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{atomic}	& This is a {\em lexical-class} option only.  It specifies
		  that there is no lexical atom table for {\em lexeme-types}
		  of this class, and instead each atom whose
		  {\em lexical-atom-type} is the given {\em lexeme-type}
		  should be emitted as a lexeme of the given {\em lexeme-type}.
		  E.g., the standard `{\tt separator}' class.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{remove}	& See \pagref{REMOVE}.
\end{tabular}

\end{indpar}

\subsubsection{Lexical Atom Types}

A \emkey{lexical-atom-type} is the part of the
{\em lexical-atom-table-entry} (\pagref{LEXICAL-ATOM-TABLE-ENTRY})
that specifies the action to take when a lexical atom appears
at the beginning of the remainder of the input.  The {\em lexical-atom-types}
normally used with the standard {\em lexical-classes} are described with
each standard class above.  However, any {\em lexical-atom-type} can
be used with any class.  The following is a complete list of
{\em lexical-atom-types} and their actions:


\begin{indpar}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
{\em lexeme-type}	& If the {\em lexeme-type}'s {\em lexical-class}
			  has the `{\tt atomic}' option,
			  emit the atom as a lexeme of the {\em lexeme-type}
			  and do not change the state.  Otherwise
			  reject the atom and change the state to that
			  named by the {\em lexeme-type}.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{accept}	& Accumulate the atom.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{begin}	  & Accumulate the atom, but only
		    recognize the atom if it is the first atom
		    in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{continue}  & Accumulate the atom, but only
		    recognize the atom if it is \underline{not} the first
		    atom of the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{end}	  & Accumulate the atom, but only
		    recognize the atom if it is \underline{not} the first
		    atom in the current state.  After
		    accumulating the atom, switch into the
		    default exit state (\pagref{DEFAULT-EXIT-STATE}).
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{begin end}
		  & Accumulate the atom, but only
		    recognize the atom if it is the first atom
		    in the current state.  After
		    accumulating the atom, switch into the
		    default exit state (\pagref{DEFAULT-EXIT-STATE}).
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{error}	  & Discard the atom, and announce that the
		    atom is in error.  Do not accumulate the atom
		    or change the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{digit}	& Accumulate the atom, but only recognize
		  the atom if it is \underline{not} after a
		  {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{continue digit}
		& Accumulate the atom, but only
		  recognize the atom if it is \underline{not}
		  the first atom of the current state
		  and \underline{not} after a
		  {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{point}	& Accumulate the atom, but only recognize
                  the atom if it is \underline{not}
		  after either another {\tt point}
		  or a {\tt begin exponent} atom recognized in the current
		  state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{begin exponent}
		& Accumulate the atom, but only recognize
		  the atom if it is \underline{not} the first atom
		  of the current state
		  and is \underline{not} after a
		  {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{exponent digit}
		& Accumulate the atom, but only recognize
		  the atom if it \underline{is} after a
		  {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{floating end}
		& Like {\tt end}, but \underline{must} be after a {\tt point}
		  or {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{integer end}
		& Like {\tt end},
		  but must \underline{not} be after a {\tt point}
		  or {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\end{indpar}

\section{Parsing}

\newpage

\appendix

\section{Standard Lexical Program}
\label{STANDARD-LEXICAL-PROGRAM}

\begin{indpar}
\begin{verbatim}
begin standard lexical program;

"<ascii-letter>" = "a-z" | "A-Z";
"<digit>" = "0-9";
"<oct-digit>" = "0-7";
"<hex-digit>" = "0-9" | "a-f" | "A-F";

"<non-digit>" = ~ "<digit>";


// The following list of language specific letters is taken
// from Annex E of the Working Paper for Draft Proposed
// International Standard for Information Systems—Programming
// Language C++, 1996.

"<latin-letter>" = "\u00c0-\n00d6" | "\u00d8-\u00f6"
                 | "\u00f8-\u01f5" | "\u01fa-\u0217"
                 | "\u0250-\u02a8" | "\u1ea0-\u1ef9";

. . . . . letter character pattern definitions omitted . . . . .

"<CJK-letter>" = "\uf900-\ufa2d" | . . .  // Details omitted

// Context sensitive character classifications, e.g.,
// classifying ' as a word character if it is followed by
// a letter, cannot be included in character pattern
// definitions, but are noted in comments.  They are
// accounted for by separate atom table entries below.

"<letter>" = "<ascii-letter>" | "<latin-letter>"
           | . . . | "<CJK-letter>";   // Details omitted

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@" | "#" | "$" | "%"
              | "^" | "&" | "=" | "|" | "<" | ">" | "_" | "!"
              | "?" | ":";
              //
              // Also \ not followed by u or U,
              //      . not followed by a digit
              //      / not surrounded by digits

"<separator-char>" = "(" | ")" | "[" | "]" | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter

"<whitespace-char>" = " " | "\n" | "\v" | "\f" | "\t" | "\r";

"<non-line-break-char>" = ~ "\n" & ~ "\v" & ~ "\f";

"<quotable-char>" = "\u0010-\u003e" & ~ "\"" & ~ "\\";

"<error-in-quote-char>" = ~ "<quotable-char>" & ~ "\"";

begin master atom table;

   // We assume that the preceding text is not a digit
   // or the current input is not / or , followed by a digit.

   "//" goto comment;

   "<whitespace-char>" goto whitespace;

   "<word-char>" goto word;
   "'<letter>" goto word;

   "<mark-char>" goto mark;
   ".<non-digit>" keep 1 goto mark;
   "/" goto mark;

   "<digit>" keep 0 goto number;
   ".<digit>" keep 1 goto number;

   "<separator-char>" singleton separator;
   "," singleton separator;
   "'<non-letter>" keep 1 singleton separator;

   "\"" "" goto quoted string;

   "<other>" singleton error;

end master atom table;

// The below tables are enterred from the master table
// with the first one or two characters scanned.

// Comments are treated as whitespace lexemes or parts
// thereof.
//
begin comment atom table;

   "<non-line-break-char>" goto comment;
   goto whitespace;
       // On line break or end-of-file goto whitespace.

end comment atom table;


begin whitespace atom table;

   "<whitespace-char>" goto whitespace;
   "//" goto comment;
   goto master;

end whitespace atom table;


begin word atom table;

   "<word-char>" goto word;
   "'<letter>" goto word;
   goto master;

end word atom table;


begin mark atom table;

   "<mark-char>" goto mark;
   ".<non-digit>" keep 1 goto mark;
   "/" goto mark;
   goto master;

end mark atom table;


begin number atom table;

   // In order to recognize , and / surrounded by digits
   // as number atoms, entries to this table upon
   // recognizing "X<digit>" must do a `keep 1' so the
   // digit will be left to be recognized by
   // <digit>/<digit> or <digit>,<digit>.

   // Alternatively we could have a separate table
   // for the state where the last atom ended with
   // a digit.

   "<digit>" goto number;
   ".<digit>" keep 1 goto number;
   "<digit>/<digit>" keep 2 goto number;
   "<digit>,<digit>" keep 2 goto number;
   goto master;

end number atom table;


begin quoted string atom table;

    "\"" "" goto master;        // End quoted string.

    "\\\"" "\"" goto quoted string;
    "\\\n" "\n" goto quoted string;
    "\\\r" "\r" goto quoted string;
    "\\\t" "\t" goto quoted string;
    "\\\b" "\b" goto quoted string;
    "\\\f" "\f" goto quoted string;
    "\\\v" "\v" goto quoted string;
    "\\\\" "\\" goto quoted string;
    "\\~"  " "  goto quoted string;
    "\\x<hex-digit><hex-digit>" translate-hex 2 0
                                goto quoted string;
    "\\<oct-digit><oct-digit><oct-digit>" translate-oct 1 0
                                goto quoted string;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
                                translate-hex 2 0
                                goto quoted string;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
                                translate-hex 2 0
                                goto quoted string;
    "<quotable-character>" goto quoted string;
    "<other>" "" erroneous atom goto quoted string;
    goto end of file in quoted string;

end quoted string atom table;



begin end of file in quoted string atom table;
    kind error;
    goto master;
end end of file in quoted string atom table;

end standard lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{C++ Lexical Program}
\label{C++-LEXICAL-PROGRAM}

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<letter>" ::= "A" | "B" | "C" | "D" | "E" | "F" | "G"
                 | "H" | "I" | "J" | "K" | "L" | "M"
                 | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
                 | "U" | "V" | "W" | "X" | "Y" | "Z"
                 | "a" | "b" | "c" | "d" | "e" | "f" | "g"
                 | "h" | "i" | "j" | "k" | "l" | "m"
                 | "n" | "o" | "p" | "q" | "r" | "s" | "t"
                 | "u" | "v" | "w" | "x" | "y" | "z" ;
    "<non-zero-digit>" ::=       "1" | "2" | "3" | "4"
                        | "5" | "6" | "7" | "8" | "9" ;
    "<digit>" ::= "0" | "<non-zero-digit>" ;
    "<oct-digit>" ::= "0" | "1" | "2" | "3"
                    | "4" | "5" | "6" | "7" ;
    "<hex-digit>" ::= "A" | "B" | "C" | "D" | "E" | "F"
                    | "a" | "b" | "c" | "d" | "e" | "f"
                    | "<digit>" ;
    "<sign>" ::= "+" | "-" ;
    "<operator>" ::= "!" | "%" | "^" | "&" | "*"
                   | "(" | ")" | "-" | "+" | "="
                   | "{" | "}" | "|" | "~" | "["
                   | "]" | ";" | ":" | "<" | ">"
                   | "?" | "," | "/" | "/" | "->"
                   | "++" | "--" | ".*" | "->*" | ">>"
                   | "<<" | "<=" | ">=" | "==" | "!="
                   | "&&" | "||" | "*=" | "/=" | "%="
                   | "+=" | "-=" | "<<=" | ">>=" | "&="
                   | "^=" | "|=" | "::" ;
    "<whitespace>" ::= " " | "\t" | "\n" | "\r"
                     | "\f" | "\v" ;
end lexical units;
    
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<control>" ::=          "\001" | "\002" | "\003"
                  | "\004" | "\005" | "\006" | "\007"
                  | "\010" 
                                    | "\016" | "\017"
                  | "\020" | "\021" | "\022" | "\023"
                  | "\024" | "\025" | "\026" | "\027"
                  | "\030" | "\031" | "\032" | "\033"
                  | "\034" | "\035" | "\036" | "\037"
                  | "\177" ;

    "<oct1>" ::= "<oct-digit>";
    "<oct2>" ::= "<oct-digit><oct1>";
    "<oct3>" ::= "<oct-digit><oct2>";
    "<oct4>" ::= "<oct-digit><oct3>";
    "<oct5>" ::= "<oct-digit><oct4>";
    "<oct6>" ::= "<oct-digit><oct5>";
    "<oct7>" ::= "<oct-digit><oct6>";
    "<oct-char>" ::= "\\<oct1>"  | "\\<oct2>"
                   | "\\0<oct2>" | "\\1<oct2>"
                   | "\\2<oct2>" | "\\3<oct2>";
    "<bad-oct-char>" ::= "\\4<oct2>" | "\\5<oct2>"
                       | "\\6<oct2>" | "\\7<oct2>"
                       | "\\<oct4>";
    "<oct-wchar>" ::= "\\<oct1>" | "\\<oct2>"
                    | "\\<oct3>" | "\\<oct4>"
                    | "\\<oct5>" | "\\0<oct5>"
                    | "\\1<oct5>";
    "<bad-oct-whar>" ::= | "\\2<oct5>" | "\\3<oct5>"
                         | "\\4<oct5>" | "\\5<oct5>"
                         | "\\6<oct5>" | "\\7<oct5>"
                         | "\\<oct7>";
end lexical units;
    
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<hex1>" ::= "<hex-digit>";
    "<hex2>" ::= "<hex-digit><hex1>";
    "<hex3>" ::= "<hex-digit><hex2>";
    "<hex4>" ::= "<hex-digit><hex3>";
    "<hex5>" ::= "<hex-digit><hex4>";
    "<hex-char>" ::= "\\x<hex1>" | "\\x<hex2>"
                   | "\\X<hex1>" | "\\X<hex2>";
    "<bad-hex-char>" ::= "\\x<hex3>" | "\\X<hex3>";
    "<hex-wchar>" ::= "<hex-char>"
                   | "\\x<hex3>" | "\\x<hex4>"
                   | "\\X<hex3>" | "\\X<hex4>";
    "<bad-hex-wchar>" ::= "\\x<hex5>" | "\\X<hex5>";

    "<backslash-char>" ::= "<oct-char>" | "<hex-char>";
    "<backslash-wchar>" ::= "<oct-wchar>" | "<hex-wchar>";
    "<bad-backslash-char>" ::= "<bad-oct-char>"
                             | "<bad-hex-char>";
    "<bad-backslash-wchar>" ::= "<bad-oct-wchar>"
                              | "<bad-hex-wchar>";

    "<integer-suffix>" ::= "u" | "U" | "l" | "L"
                         | "ul" | "Ul" | "uL" | "UL"
                         | "lu" | "Lu" | "lU" | "LU";
    "<floating-suffix>" ::= "f" | "F" | "d" | "D";

    "<backslash-control>" ::= "\\f" | "\\v" | "\\n" | "\\r"
                            | "\\t" | "\\b" | "\\a" | "\\?"
                            | "\\\'" | "\\\"" | "\\\\";
end lexical units;
    
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}

begin lexeme atom table;
    "<operator>"        operator;
    "<separator>"       separator;
    "<letter>"          identifier;
    "0x<hex-digit>"     hex number;
    "0X<hex-digit>"     hex number;
    "0<oct-digit>"      oct number;
    "<non-zero-digit>"  number;
    ".<digit>"          number;
    "L'"                wide char string;
    "'"                 char string;
    "L\""               wide quoted string;
    "\""                quoted string;
    "//"                "//" comment;
    "/*"                "/*" comment;
    "<whitespace>"      whitespace;
end lexeme atom table;

// Note that C/C++ keywords are identifiers.
//
begin identifier atom table;
    "<letter>"  accept;
    "_"         accept;
    "<digit>"   continue;
    "<control>" error;
end identifier atom table;

\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin hex number atom table;
    "<hex-digit>"       continue digit;
    "0x<hex-digit>"     begin digit;
    "0X<hex-digit>"     begin digit;
    "<integer-suffix>"  end;
    "<control>"         error
end hex number atom table;
 
begin oct number atom table;
    "<oct-digit>"       continue digit;
    "0"                 begin digit;
    "<integer-suffix>"  end;
    "<control>"         error
end oct number atom table;
 
begin number atom table;
    "<digit>"           digit;
    "."                 point;
    "e<digit>"          begin exponent;
    "E<digit>"          begin exponent;
    "e<sign><digit>"    begin exponent;
    "E<sign><digit>"    begin exponent;
    "<digit>"           exponent digit;
    "<integer-suffix>"  integer end;
    "<floating-suffix>" floating end;
    "<control>"         error
end number atom table;
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
 
begin quoted string atom table;
    "\""                    begin;
    "\""                    end;
    "<backslash-control>"   continue  "<char backslash-control>";
    "<backslash-char>"      continue  "<char backslash-char>";
    "<bad-backslash-char>"  error;
    "<control>"             error;
end quoted string atom table;
 
begin wide quoted string atom table;
    "L\""                   begin;
    "\""                    end;
    "<backslash-control>"   continue  "<char backslash-control>";
    "<backslash-wchar>"     continue  "<char backslash-wchar>";
    "<bad-backslash-wchar>" error;
    "<control>"             error;
end quoted string atom table;
 
begin char string atom table;
    "\'"                begin;
    "\'"                end;
    . . . rest just like quoted string table . . .
end char string atom table;
 
begin wide char string atom table;
    "L\'"               begin;
    "\'"                end;
    . . . rest just like wide quoted string table . . .
end char string atom table;

\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
 
begin whitespace atom table;
    " "                     accept;
    "\t"                    accept;
    "\n"                    accept;
    "\f"                    accept;
    "\v"                    accept;
    "<control>"             error;
end whitespace atom table;
 
begin "//" comment atom table;
    "//"                    begin;
    "\n"                    end;
end "//" comment atom table;
 
begin "/*" comment atom table;
    "/*"                    begin;
    "*/"                    end;
end "*/" comment atom table;

\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
