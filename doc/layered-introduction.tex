% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttnbakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\ttitemref}[1]{{\tt \ref{#1} ({p\pageref{#1}})}}
\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

April 26, 2010
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A machine independent reduced instruction set architecture
	  programming language.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& Similar to the C programming language but more flexible.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& Implements standardized lists, symbols, arrays, etc. to extend
	  the M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `{\tt hello}', `{\tt +}', `{\tt ;}',
`{\tt 9.200}' are four lexemes.

The lexical scanner is written in the H-Language and can be
replaced.  This section describes the standard scanner which
is driven by the atom tables and is capable scanning
lexemes of common languages such as C and C++.

The standard scanner attempts to be both machine and human
efficient.  It attempts to be machine efficient by being
deterministic\footnote{Unlike regular expression scanners}
and attempts to be human efficient by supporting algorithms
that people can readily understand and hopefully quickly
learn to mimic.\footnote{A possibly non-verifiable goal.}

The standard scanner operates on an input stream of 32-bit
UNICODE characters.  Each character is associated with
a position value that specifies from where the character
came.  For example, a position value may encode a file name,
line within file number, and column within line number.
When the standard scanner identifies a lexeme, it a sequence
of input stream UNICODE 32-bit characters each with a
corresponding position value.

The standard scanner also produces a translation of each
lexeme.  This may just be a copy of the 32-bit characters
in the lexeme, or it may have some changes, or `translations',
of some of these characters.  For example, the lexeme
\verb|"a line\n"| may have a translation that omits the
\verb|"|'s and converts the two characters \verb|\n| into
a single linefeed character.

When the standard scanner identifies a lexeme it also identifies
a `\mkey{kind}{of lexeme}' that serves to type the lexeme.
For example, the lexeme \verb|9.35| may have kind `{\tt number}'
while the lexeme \verb|"abc"| may have the kind `{\tt quoted string}'.

At its most fundamental level the
standard scanner identifies lexical atoms in the input text.
A \key{lexical atom} is a single character (e.g., the letters
in an identifier or symbol) or a short string of characters
(e.g., the characters \verb|\n| in a quoted string).
Lexical atoms are read left to right and
grouped by the scanner into \skey{lexeme}s.

The scanner has a state containing a current point 
in the input UNICODE character stream
and a \key{current atom table} identifier.  An
\key{atom table} is a set of atom patterns
that match lexical atoms, and for each pattern an
instruction that determines what to do when the pattern is matched.
There is also a \key{default instruction} associated with the atom table that
determines what to do when no table pattern matches the next characters
in the input stream.

An \key{atom pattern}\index{pattern!lexical atom} is a fixed
length sequence of character patterns, and matches any sequence of
input characters of the same length as the atom pattern
if each input character of the sequence matches the corresponding
character pattern.  A \key{character pattern} is simply a
specification of a set of characters, e.g., letters or digits.
Thus one can construct an atom pattern that will recognize
single letters, or one that will recognize the sequence of
characters such as the 2-character sequence \verb|\n| which matches
the atom pattern \verb|"\\n"|
or the 6-character sequence \verb|u000a| which matches the atom pattern
\begin{center}
\verb|"\\u<hex-digit><hex-digit><hex-digit><hex-digit>"|
\end{center}
where \verb|<hex-digit>| names a character pattern matching characters
in the ranges \verb|0-9|, \verb|a-f|, and \verb|A-F|.

The atom patterns of a single atom table must not conflict:
no character string can be recognized by two atom patterns of the
same atom table.

The scanner operates by identifying the
longest sequence of characters beginning at the current input character
stream point that matches an atom pattern of the current atom table.
This sequence of characters becomes
the next atom, and an instruction associated with its matching
atom pattern is then executed.  If no atom pattern can be matched,
the default instruction associated with the atom table is executed instead.

An atom table
instruction can optionally reduce the length of a matched atom
and optionally change the current atom table.  It can also do other
things described below.

Atom tables have \skey{mode}s that are either lexeme kinds or
are the special mode `\ttmkey{master}{mode}'.
Non-master mode tables, whose modes are kinds,
are typically dedicated to recognizing lexemes
of the indicate kind.  Master mode atom tables are used to
dispatch to non-master mode tables.

When the current lexical atom table is changed from a non-master mode
table to a master mode table, any non-zero length lexeme accumulated
so far is output as a lexeme whose kind\label{KIND-OUTPUT}
equals
the mode of the non-master mode table.  Thus if an atom table of
mode `\verb|whitespace|' cannot recognized any atom and
the default instruction associated with it
changes the current atom table to a master mode table,
any non-zero length lexeme accumulated so far will
be output as a lexeme of kind `\verb|whitespace|'.

When it is between lexemes that current atom table in the scanner state
is always a master mode table.  Master mode tables correspond to lexical
contexts.  A well designed language has only one main master mode
table, plus a few small master mode tables to handle error situations
such a premature new-line and premature end-of-file;
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.
Legacy languages
may have more master mode tables: C/C++ has several to handle
special lexical scanning of preprocessing lexemes;
see Appendix \itemref{C++-LEXICAL-PROGRAM}.

The standard scanner can report errors in one of two ways.  It may
simply output a lexeme with a kind that indicates an error.  For
example, the character \verb|\| appearing outside a quoted string
might be returned as a 1-character lexeme of kind `{\tt errnoneous
character}'.  Alternatively a single atom may be reported as an
error of a given kind without interrupting the normal operation
of the scanner.  For example, if \verb|\h| appears in a quoted
string, it may be reported as an erroneous atom of kind
`{\tt bad escape sequence}'.  Otherwise this atom is processed
normally; it might, for example, be omitted from the lexeme
translation or be represented in that translation by the DEL
character (\verb|\u007F|).

\ikey{Instructions}{instruction!in lexical program}
that are associated with atom patterns can optionally do any
of the following:
\begin{itemize}
\item reduce the length of the matched atom
\item translate the reduced length atom to a different
character string within the lexeme translation
\item announce the reduced length atom as an erroneous atom of a given kind
\item output the atoms accumulated so far as a lexeme of a given kind
\item change the current atom table
\end{itemize}

More details and examples are given in the next section.

A \key{lexical program} is a set of character pattern definitions
and atom tables, with a designated master-mode atom
table to serve as the initial atom table.  A lexical program can include
another lexical program.


\subsection{Lexical Programs}

The syntax of a lexical program is given on
\pagref{LEXEME-PROGRAM-SYNTAX-1} and
\pagref{LEXEME-PROGRAM-SYNTAX-2}.

\begin{figure*}[!p]
\begin{tabular}{p{2.2in}rl}
\emkey{name}
    & ::= & \{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}$^+$
\end{tabular}

\begin{tabular}{p{2.2in}rl}
\emkey{lexical-program} & ::= &
	{\tt begin} {\em program-name} {\tt lexical program;}\\
	& &  ~~~~{\em lexical-program-unit}$^\star$ \\
	& & {\tt end} {\em program-name} {\tt lexical program};
\\[1ex]
\emkey{program-name} & ::= & {\em name}
\\[1ex]
\emkey{lexical-program-unit}
	& ::= & {\em cpat-definition} \\
	& $|$ & {\em atom-table-definition} \\
	& $|$ & {\em program-inclusion}
\\[1ex]
\emkey{program-inclusion} & ::= & {\tt include} {\em program-name}
				  {\em remove-clause}$^\star$ {\tt ;}
\\[1ex]
\emkey{remove-clause} & ::= & {\tt remove} {\em atom-table-name} \\
                      & $|$ & {\tt remove} {\tt "}{\em cpat-name}{\tt "}
\\[1ex]
\multicolumn{3}{l}{~~~~~~~~`{\em cpat}\,' abbreviates `{\em character-pattern}\,'}
\\[1ex]
\emkey{cpat-definition} & ::= &
	{\tt "}{\em cpat-name}{\tt "} {\tt =}
		{\em cpat-expression} {\tt ;}
\\[1ex]
\emkey{cpat-name} & ::= &
	{\tt <}{\em letter}$^+$\{{\tt -}{\em letter}$^+$\}$^\star${\tt >}
\\[1ex]
\emkey{cpat-expression} & ::= &
	{\em cpat-term}
	\{ {\tt |} {\em cpat-term} \}$^\star$ \\
       & $|$ &
	{\em cpat-term}
	\{ {\tt \&} {\em cpat-term} \}$^\star$
\\[1ex]
\emkey{cpat-term} & ::= & {\em cpat-factor} $|$ \TILDE {\em cpat-factor}
\\[1ex]
\emkey{cpat-factor} & ::= & {\tt "}{\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em quotable-character}{\tt -}%
		                   {\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em cpat-name}{\tt "} \\
		    & $|$ & {\tt (} {\em cpat-expression}
		                {\tt )}
\\[1ex]
\emkey{quotable-character} & ::= & 
	any quotable UNICODE character representative
\\[1ex]
\emkey{atom-table-definition} & ::= &
	{\tt begin} {\em atom-table-name}
		    {\tt atom table} {\tt ;} \\
	& &  ~~~~{\em mode-option} \\
	& &  ~~~~{\em atom-table-entry}$^\star$ \\
	& &  ~~~~{\em default-instruction-option} \\
	& & {\tt end} {\em atom-table-name} {\tt atom table;}
\\[1ex]
\emkey{mode-option} & ::= & {\em empty} $|$ {\tt mode} {\em mode} {\tt ;}
                                        $|$ {\tt kind} {\em kind} {\tt ;}
\\[1ex]
\emkey{mode} & ::= &  {\tt master} $|$ {\em kind}
\\[1ex]
\emkey{default-instruction-option}
	& ::= &  {\em empty} $|$ {\em instruction}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-1}
\end{figure*}

\begin{figure*}[!t]
\begin{tabular}{p{2.2in}rl}
\emkey{atom-table-entry}
	& ::= & {\em atom-pattern} {\em instruction-group} {\tt ;}
\\[1ex]
\emkey{instruction-group}
	& ::= & {\em instruction}
	        \{ {\tt else} {\em instruction} \}$^\star$

\\[1ex]
\emkey{instruction} & ::= & {\em instruction-component}$^\star$
\\[1ex]
\emkey{atom-pattern} & ::= &
	{\tt "}\{{\em quotable-character}$|${\em cpat-name}\}$^\star${\tt "}
\\[1ex]
\emkey{instruction-component}
	& ::= & {\tt accept} \\
	& $|$ & {\tt keep} {\em natural-number} \\
	& $|$ & {\tt translate} {\em translation-string} \\
	& $|$ & {\tt translate hex} \begin{tabular}[t]{l}
			{\em natural-number} {\em natural-number} \\
		        {\em cpat-option}
			\end{tabular} \\
	& $|$ & {\tt translate oct} \begin{tabular}[t]{l}
			{\em natural-number} {\em natural-number} \\
		        {\em cpat-option}
			\end{tabular} \\
	& $|$ & {\tt error} {\em kind} \\
	& $|$ & {\tt output} {\em kind} \\
	& $|$ & {\tt goto} {\em atom-table-name} \\
	& $|$ & {\tt call} {\em atom-table-name} \\
	& $|$ & {\tt return} \\
\\[1ex]
\emkey{translation-string} & ::= & {\em quoted-string}
\\[1ex]
\emkey{cpat-option} & ::= & {\em empty} $|$ {\tt "}{\em cpat-name}{\tt "}
\\[1ex]
\emkey{kind} & ::= & {\em name} \begin{tabular}[t]{@{}r@{~}l@{}}
                                     except & {\tt master} \\
				         or & {\tt end of file} \\
					 or & {\tt scan error} \\[1ex]
				    \end{tabular}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-2}
\end{figure*}

A simple lexical program that recognizes
whitespace and quoted strings without escapes is given
at the top of \pagref{EXAMPLE-LEXEME-PROGRAM}.

\begin{figure*}[!p]
\addtolength{\baselineskip}{-0.4ex}
\begin{indpar}\begin{verbatim}
begin premature tables lexical program;
    // Stuff to include.

begin premature end of line;
    mode master;
    "\n" output premature end of line
         goto master;
end premature end of line;

begin premature end of file;
    mode master;
    output premature end of file;
end premature end of file;

end premature tables lexical program;

begin example lexical program;
    // Main program.

"<whitespace-char>" = " " | "\n" | "\t" | "\v" | "\f";

begin master atom table;
    "<whitespace-char>" goto whitespace;
    "\"" translate "" goto quoted string;
    "<other>" output bad character;
    output end of file;
end master atom table;

begin whitespace atom table;
    "<whitespace-char>" accept;
    goto master;
end whitespace atom table;

begin quoted string atom table;
    "\"" translate "" goto master;
    "\n" keep 0 goto premature end of line;
    "<other>" accept;
    goto premature end of file;
end quoted string atom table;

include premature tables;

end example lexical program;
\end{verbatim}\end{indpar}
\label{EXAMPLE-LEXEME-PROGRAM}
\end{figure*}

A \emkey{lexical-program} consists of a sequence of
{\em character-\EOL pattern-\EOL defi\-ni\-tions},
{\em atom-\EOL table-\EOL defi\-ni\-tions},
and {\em program-inclusions}.  These define character pattern sets
and atom tables, and include in the lexical program definitions from
other previously defined lexical programs.

A \emkey{program-inclusion} names a previously defined lexical program
whose definitions are to be included in the current lexical program
at the point of the {\em program-inclusion}.
There is a simple example of a program inclusion at the bottom of
\pagref{EXAMPLE-LEXEME-PROGRAM}.
Identical definitions
may be repeated without error,
as can happen when one program includes two each of
which include the same third program.
A {\em program-inclusion} can have
\emsmkey{remove-clause}s{in {\em program-inclusion}}
each of which removes a named definition from the set of included
definitions.  This is the only way to resolve conflicts between
definitions.

A \emkey{character-pattern-definition} (abbreviated as
\emkey{cpat-definition}) assigns a set of characters to a
{\em character-pattern-name}.  The latter is just a string of
letters and hyphens (\verb|-|) surrounded by angle brackets (\verb|< >|)
with hyphens occuring only between letters.  Examples:
\verb|<digit>| and \verb|<line-break>|.

The character set is denoted by a \emkey{character-pattern-expression}.
The simplest character pattern
expression is just a single {\em quotable-character} in quotes, which denotes
the character set containing only the quoted character.  Examples:
\verb|"0"| and \verb|"+"|.  The next simplest is two {\em quotable-characters}
separated by a hyphen (\verb|-|) denoting the character set consisting
of all characters in the range from the first to the second of the two
characters.  Examples: \verb|"0-9"| and \verb|"A-Z"|.  The characters
are ordered according to their 32 bit unsigned UNICODE value, and the
second of the two characters must not be smaller than the first.

A {\em quotable-character} is a representative of a single UNICODE
character that can be used inside quotes (\verb|"|).
Printable ASCII characters represent themselves.  Other characters
are represented by sequences started with backslash (\verb|\|).
For example, a line feed can be represented by any of the
following: \verb|\n|, \verb|\012|, \verb|\x0a|,
\verb|\u000a|, or \verb|\U0000000a|.

A quoted {\em character-pattern-name} denotes the character set associated
with that name by a previous {\em character-pattern-definition}.

The \verb/|/, \verb|&|, and \verb|~| operators and can be used to take
the union, intersection, and complements of character sets.  The complement
is relative to the universe of all 32 bit unsigned integer UNICODE
character codes.  Thus \verb|~ "b-y"| denotes the same character set as
\verb/"\x00-a" | "z-\Uffffffff"/.

Parentheses may be used in {\em character-pattern-expressions} as is
normal in algebraic expressions.
Note that the \verb/|/ and \verb|&| operators cannot be used together
in the same expression without intervening parentheses as neither
takes precedence over the other.  This is done to prevent ambiguity.

Some example {\em character-pattern-definitions} are:

\begin{indpar}\begin{verbatim}
"<hex-digit>" = "0-9" | "a-f" | "A-F";
"<non-line-break-char>" = ~ "\n" & ~ "\v" & ~ "\f";
"<quotable-char>" = "\u0020-\u007e" & ~ "\"" & ~ "\\";
"<whitespace-char>" = " " | "\n" | "\v" | "\f" | "\t" | "\r";
"<source-character>" =
    ( "\u0020-\u007e" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";
\end{verbatim}\end{indpar}

An {\em atom-table-definition} specifies an {\em atom-table-name},
a {\em mode} for the table, a set of {\em atom-table-entries}
each containing an {\em atom-pattern} and an {\em instruction},
and an optional default instruction for use when
no atom is recognized by any of the table entries.

The {\em mode} of an atom table can be either a {\em kind} or can be
the special `\ttmkey{master}{atom table mode}' mode.  If it is a
{\em kind} then it is used as the {\em kind} of any lexeme recognized
by the table (not all tables recognize lexemes).  See
\pagref{KIND-OUTPUT} for a description of how modes and kinds are used

The {\em mode} of an atom table is the same as the {\em atom-table-name}
unless a non-empty {\em mode-option} is given at the beginning of the
{\em atom-table-definition}.  The `{\tt premature end of line}' atom
table at the top of \pagref{EXAMPLE-LEXEME-PROGRAM} is an example
of an atom table with a {\em mode-option}.

The first atom table in a lexical program must have `{\tt master}'
mode, and will become the current atom table when the scanner
is initialized.  This table is typically named `{\tt master}',
as it is in the example on
\pagref{EXAMPLE-LEXEME-PROGRAM}.

Each \emkey{atom-table-entry} contains an {\em atom-pattern} and
an {\em instruction-group}.  The \emkey{atom-pattern} is matched against
the remaining input characters.  The pattern consists of a sequence
of {\em quotable-characters}, each of which match only themselves,
and {\em character-pattern-names}, each of which match any character
in the named set of characters.  Thus
\begin{center}
\verb|"\\x<hex-digit><hex-digit>"|
\end{center}
matches 4-character atoms consisting of a \verb|\| followed by an
\verb|x| followed by two characters each in the character set
named by \verb|<hex-digit>|.  Note that each {\em atom-pattern}
only matches atoms of a particular length.


The special character pattern
\verb|"<other>"|\index{other@{\tt \LESSTHAN other\GREATERTHAN}}
can be used in an atom pattern to match any character,
but an atom pattern containing
it will be matched only if no atom pattern in the atom table
that does not contain \verb|"<other>"| is matched.

An \emmkey{instruction}{in atom-table-entry} in an {\em atom-table-entry}
specifies actions to be taken when an atom is recognized by the
{\em atom-pattern} of the entry.  The {\em instruction} consists of
a set of {\em instruction-components} each of which controls part of the
atom processing.  If there are no components, the default actions are
performed, which consist of just skipping over the atom in the input and
copying the atom to the translation buffer.

The \ttmkey{accept}{in lexical program} {\em instruction-component}
accepts the
atom without translation or length change, skips over the atom in the
input, and copies the atom characters to the translation buffer.
It is incompatible with the {\tt keep} and translation instruction
components.

The `\ttmkey{keep}{in lexical program} $n$'
{\em instruction-component} causes the atom length
to be shortened to $n$.  For example, the atom table entry
\begin{center}
\verb|",<digit>" keep 1;|
\end{center}
will recognize a 1-character atom consisting of just a comma as long as
the comma is followed by character in the \verb|<digit>| character pattern
character set.  Atoms may not be lengthened by {\tt keep}.

There are three possible translation {\em instruction-components}, at most
one of which may be used.  These affect how the atom is placed into
the translation buffer, and are applied to the atom \underline{after}
any {\tt keep} is applied.

A `\ttmkey{translate}{in lexical program}
\emmkey{translation-string}{in lexical program}'
{\em instruction-component}
specifies a {\em quoted-string} of characters
that is copied into the translation buffer instead of the atom.
A {\em translation-string} may be empty, as in the atom table entry
\begin{center}
\verb|"\"" translate "" goto master;|
\end{center}
which can be used to recognize the last \verb|"| of a quoted string, avoid
copying anything into the translation buffer, and then switch to the
`{\tt master}' atom table.

The `\ttmkey{translate hex}{in lexical program} $m$ $n$'
{\em instruction-component} ignores the
first $m$ and last $n$ characters of the atom and viewing the rest as
hexadecimal digits, converts these into an 32 bit unsigned integer
UNICODE character code, which is placed into the translation buffer
instead of the atom.  An example is the the atom table entry
\begin{center}
\verb|"\\x<hex-digit><hex-digit>" translate hex 2 0;|
\end{center}
which might be used to accept a character representative in a quoted string
and copies the appropriate hexadecimally related character code into
the translation buffer.

The `\ttmkey{translate oct}{in lexical program} $m$ $n$'
{\em instruction-component} is identical but
views the rest of the characters as octal and not hexadecimal.
An example use would be the atom table entry
\begin{center}
\verb|"\\<oct-digit><oct-digit><oct-digit>" translate hex 1 0;|
\end{center}

The {\tt translate hex} and {\tt translate oct} components may end with
a {\em character-pattern} that tests the 32 bit unsigned character code
produced by the translation.  Such a test should only appear in an
{\em instruction} which is followed by an `{\tt else}' in an
\emmkey{instruction-group}{in lexical program}.
If the 32 bit unsigned character code is in
the character set defined by the {\em character-pattern}, the {\em instruction}
containing the {\em character-pattern} is executed and the rest of the
{\em instruction-group}, the part after the next `{\tt else}', is ignored.
But if the character code is not in the character set the instruction
containing the {\em character-pattern} is turned into a no-operation and
the first {\em instruction} after the next `{\tt else}' is executed in
its place.

An example use would be the atom table entry
\begin{center}
\verb|"\\u<hex-digit><hex-digit><hex-digit><hex-digit>" translate hex 2 0|
\verb|    "<letter>" else "" error bad character in identifier;|
\end{center}
which might be used to process an atom of the form \verb|\uXXXX| in
an identifier, accepting the atom as a legitimate representation of a
character if that character is a letter, and otherwise designating
the atom as an error and not putting anything in the translation buffer
(see below for the definition of the `{\tt error}' instruction component;
here \verb|""| is a {\em translation-string} applied if the character
is not a letter).

A `\ttmkey{error}{in lexical program} {\em kind}\,' {\em instruction-component}
outputs the current atom as an erroneous atom of the given {\em kind}.
What is put in the translation buffer is governed
independently by translation instruction components.
An erroneous atom is different from an erroneous lexeme.
An erroneous atom can occur in the middle of a lexeme and is usually announced
and otherwise ignored (it has \verb|""| as its {\em translation-string}).
It is not a lexeme.
An erroneous lexeme is simply a lexeme whose {\em kind}
indicates to the user of the lexical scanner that the lexeme is ill-formed.
As such it an erroneous lexeme is
handled by the lexical scanner just as any other lexeme would be.

A `\ttmkey{goto}{in lexical program} {\em atom-table-name}\,'
{\em instruction-component} switches the current atom table after
the current atom is processed.  If the table switches from a table
of non-{\tt master} mode to one of {\tt master} mode the current
lexeme, if it has non-zero length,
is output with the {\em kind} of the non-{\tt master} mode
table: see \pagref{KIND-OUTPUT}.

A `\ttmkey{output}{in lexical program} {\em kind}\,'
{\em instruction-component} emits the current lexeme
with the given {\em kind}.  This
{\em instruction-component} must either be used
in a master mode atom table or combined with a 
{\tt goto} transfering to a master mode atom table.

An {\em atom-table} ends with an optional {\em instruction},
called the {\em default-instruction},
that executes if no atom is recognized by any {\em atom-pattern}
in the table.

Note that if \verb|"<other>"| is an {\em atom-pattern} in an atom table
then any default instruction for the table will only be executed
if the current input consists of an end of file.

\section{Parsing}

\newpage

\appendix

\section{Standard Lexical Program}
\label{STANDARD-LEXICAL-PROGRAM}

\begin{indpar}
\begin{verbatim}
begin standard lexical program;

"<ascii-letter>" = "a-z" | "A-Z";
"<digit>" = "0-9";
"<oct-digit>" = "0-7";
"<hex-digit>" = "0-9" | "a-f" | "A-F";

"<non-digit>" = ~ "<digit>";

// The following list of language specific letters is taken
// from Annex E of the Working Paper for Draft Proposed
// International Standard for Information Systems—Programming
// Language C++, 1996.

"<latin-letter>" = "\u00c0-\n00d6" | "\u00d8-\u00f6"
                 | "\u00f8-\u01f5" | "\u01fa-\u0217"
                 | "\u0250-\u02a8" | "\u1ea0-\u1ef9";

. . . . . letter character pattern definitions omitted . . . . .

"<CJK-letter>" = "\uf900-\ufa2d" | . . .  // Details omitted

// Context sensitive character classifications, e.g.,
// classifying ' as a word character if it is followed by
// a letter, cannot be included in character pattern
// definitions, but are noted in comments.  They are
// accounted for by separate atom table entries below.

"<letter>" = "<ascii-letter>" | "<latin-letter>"
           | . . . | "<CJK-letter>";   // Details omitted

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@" | "#" | "$" | "%"
              | "^" | "&" | "=" | "|" | "<" | ">" | "_" | "!"
              | "?" | ":";
              //
              // Also \ not followed by u or U,
              //      . not followed by a digit
              //      / not surrounded by digits

"<separator-char>" = "(" | ")" | "[" | "]" | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter

"<whitespace-char>" = " " | "\n" | "\v" | "\f" | "\t" | "\r";

"<non-line-break-char>" = ~ "\n" & ~ "\v" & ~ "\f";

"<quotable-char>" = "\u0020-\u007e" & ~ "\"" & ~ "\\";

"<error-in-quote-char>" = ~ "<quotable-char>" & ~ "\"";

begin master atom table;

   // We assume that the preceding text is not a digit
   // or the current input is not / or , followed by a digit.

   "//" goto comment;

   "<whitespace-char>" goto whitespace;

   "<word-char>" goto word;
   "'<letter>" goto word;

   "<mark-char>" goto mark;
   ".<non-digit>" keep 1 goto mark;
   "/" goto mark;

   "<digit>" keep 0 goto number;
   ".<digit>" keep 1 goto number;

   "<separator-char>" output separator;
   "," output separator;
   "'<non-letter>" keep 1 output separator;

   "\"" translate "" goto quoted string;

   "<other>" output error;

end master atom table;

// The below tables are enterred from the master table
// with the first one or two characters scanned.

// Comments are treated as whitespace lexemes or parts
// thereof.
//
begin comment atom table;
   "<non-line-break-char>" accept;
   goto whitespace;
       // On line break or end-of-file goto whitespace.
end comment atom table;


begin whitespace atom table;
   "<whitespace-char>" accept;
   "//" goto comment;
   goto master;
end whitespace atom table;


begin word atom table;
   "<word-char>" accept;
   "'<letter>" accept;
   goto master;
end word atom table;


begin mark atom table;
   "<mark-char>" accept;
   ".<non-digit>" keep 1;
   "/" accept;
   goto master;
end mark atom table;


begin number atom table;

   // In order to recognize , and / surrounded by digits
   // as number atoms, entries to this table upon
   // recognizing "X<digit>" must do a `keep 1' so the
   // digit will be left to be recognized by
   // <digit>/<digit> or <digit>,<digit>.

   // Alternatively we could have a separate table
   // for the state where the last atom ended with
   // a digit.

   "<digit>" accept;
   ".<digit>" keep 1;
   "<digit>/<digit>" keep 2;
   "<digit>,<digit>" keep 2;
   goto master;

end number atom table;


begin quoted string atom table;

    "\"" translate "" goto master;   // End quoted string.

    "\\\"" "\"" goto quoted string;
    "\\\n" "\n" goto quoted string;
    "\\\r" "\r" goto quoted string;
    "\\\t" "\t" goto quoted string;
    "\\\b" "\b" goto quoted string;
    "\\\f" "\f" goto quoted string;
    "\\\v" "\v" goto quoted string;
    "\\\\" "\\" goto quoted string;
    "\\~"  " "  goto quoted string;
    "\\x<hex-digit><hex-digit>" translate hex 2 0;
    "\\<oct-digit><oct-digit><oct-digit>" translate oct 1 0;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
                                translate hex 2 0;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
                                translate hex 2 0;
    "<quotable-character>" accept;
    "<other>" translate "" erroneous atom goto quoted string;
    goto end of file in quoted string;

end quoted string atom table;

begin end of file in quoted string atom table;
    kind error;
    goto master;
end end of file in quoted string atom table;

end standard lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{C++ Lexical Program}
\label{C++-LEXICAL-PROGRAM}

\begin{indpar}\begin{verbatim}
begin c++ lexical program;

// Before this lexical program is used the input should
// be preprocessed to
//
//    (1) Replace trigraph sequences.
//    (2) Eliminate carriage returns next to newlines.
//    (3) Eliminate backslash newline pairs.
//    (4) Replace any source file character that is not
//        one of the 96 `source characters' by a univer-
//        sal character name (\uXXXX or \UXXXXXXXX).
//
// After this lexical program is used the output should
// be postprocessed to
//
//    (5) Perform C/C++ macro preprocessing (macro
//        expansion.
//    (6) Concatenate adjacent ordinary quoted strings
//        and adjacent wide quoted strings.

"<digit>" = "0-9";
"<oct-digit>" = "0-7";
"<hex-digit>" = "0-9" | "a-f" | "A-F";
"<non-digit>" = "_" | "a-z" | "A-Z";
    // I.e., in identifier.

"<ascii-letter>" = "a-z" | "A-Z";

"<space-char>" = " " | "\t" | "\v" | "\f";

"<source-character>" =
    ( "\u0020-\u007e" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";

"<sign>" = "+" | "-" ;

// The following list of language specific letters is
// taken from Annex E of the Working Paper for Draft
// Proposed International Standard for Information
// Systems—Programming Language C++, 1996.

"<latin-letter>" = "\u00c0-\n00d6" | "\u00d8-\u00f6"
                 | "\u00f8-\u01f5" | "\u01fa-\u0217"
                 | "\u0250-\u02a8" | "\u1ea0-\u1ef9";

. . . letter character pattern definitions omitted . . .

"<CJK-letter>" = "\uf900-\ufa2d" | . . .
    // Details omitted

"<letter>" = "<ascii-letter>" | "<latin-letter>"
           | . . . | "<CJK-letter>";
    // Details omitted

// Alternative operators that are not identifiers are
// translated.  E.g., <: becomes [ in the translation
// buffer.  An exc

// C/C++ preprocessing is hereafter abbreviated as `pp'.
//
// Because of pp control lines, lexical scanning is
// slightly context dependent.  There are several
// contexts, each corresponding to a different master
// atom table:
//
//    pp group master (initial master)
//        Used in line beginning situations to recognize
//        the # token that introduces a pp control line.
//    pp control line beginning master
//        Used to scan the beginning of a pp control
//        line.
//    pp include header name master
//        Used to scan the header name of an #include
//        statement.
//    pp define identifier name master
//        Used to scan the 
//        statement.
//    pp control line master
//        Used to scan the remainder of a pp control
//        line.  Recognizes the line ending line feed.
//    normal line master
//        Used to scan a non pp control line or the rest
//        of a pp control line that consists of just pp
//        tokens.
//
// The whitespace lexeme kinds are:
//
//    line feed (lexeme is "\n")
//    horizontal space
//    "/*" comment (include /* and */)
//    "//" comment (does not include ending line feed)
//    end of file (lexeme is "")
//    premature line feed (lexeme is "\n")
//    premature end of file (lexeme is "")
//
// This allows line feeds to be used to end pp control
// lines.  The `premature' lexemes are errors: the
// previous lexeme is treated as if there were no error
// (i.e., as if there were a ", ', */, etc.) and the
// next lexeme is a `premature ...' lexeme.

// Initial master is used only to start at pp group
// master.
//
begin initial master atom table;
    goto pp group master;
end initial master atom table;

begin horizontal space atom table;
    "<horizontal-space-char>" accept;
    return;
end horizontal space atom table;

begin "/*" comment atom table;
    "*/" return;
    "<other>" accept;
    goto premature end of file master;
end "/*" comment atom table;

begin "//" comment atom table;
    "\n" keep 0 return;
    "<other>" accept;
    goto premature end of file master;
end "//" comment atom table;

begin premature end of file master atom table;
    mode master;
    output premature end of file;
end premature end of file master atom table;

begin premature end of line master atom table;
    mode master;
    "\n" output premature newline
                goto pp group master;
end premature end of line master atom table;

begin pp group master atom table;
    mode master;
    "<horizontal-space-char>"
        call horizontal space;
    "/*" call "/*" comment;
    "##" output operator
         goto normal line master;
    "%:%:" translate "##" output operator
                          goto normal line master;
    "#" output punctuation
        goto pp control master;
    "%:" translate "#" output punctuation
                       goto pp control master;
    goto normal line master;
end pp group master atom table;

begin pp control master atom table;
    mode master;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "include<horizontal-space-char>" keep 7
        output identifier
        goto pp include header name master;
    "include/*" keep 7 output identifier
        goto pp include header name master;
    "define<horizontal-space-char>" keep 6
        output identifier
        goto pp define identifier master;
    "define/*" keep 6 output identifier
        goto pp define identifier master;
    goto normal line master;
end pp control master atom table;

begin include header name master atom table;
    mode master;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "<" translate "" goto bracketted header name;
    "\"" translate "" goto quoted header name;
    goto normal line master;
end include header name master atom table;

begin bracketted header name atom table;
    ">" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "'" error bad character in header name;
    "\"" error bad character in header name;
    "\\" error bad character in header name;
    "//" error bad character pair in header name;
    "/*" error bad character pair in header name;
    "<other>" accept;
    goto premature end of file master;
end bracketted header name atom table;

// Quoted header names are not the same as quoted
// strings, and cannot have escape sequences.
//
begin quoted header name atom table;
    "\"" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "'" error bad character in header name;
    "\\" error bad character in header name;
    "//" error bad character pair in header name;
    "/*" error bad character pair in header name;
    "<other>" accept;
    goto premature end of file master;
end quoted header name atom table;

begin define identifier master atom table;
    mode master;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "<nondigit>" goto defined identifier;
    goto normal line master;
end define identifier master atom table;

begin defined identifier atom table;
    kind identifier;
    "<nondigit>" accept;
    "<digit>" accept;
    "(" keep 0 goto lparen master;
    goto normal line master;
end defined identifier atom table;

begin lparen master;
    mode master;
    "(" output lparen goto normal line master;
end lparen master;

begin normal line master atom table;
    mode master;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "//" call "//" comment;

    "<non-digit>" goto identifier;

    "<digit>" goto number;
    ".<digit>" goto number;

    "'" translate "" goto character literal;
    "L'" translate "" goto wide character literal;
    "\"" translate "" goto string literal;
    "L\"" translate "" goto wide string literal;

    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
            translate hex 2 0 goto identifier
            "<letter>"
            else output non-letter UNICODE error;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
            translate hex 2 0 goto identifier
            "<letter>"
            else output non-letter UNICODE error;

    "{" output punctuation;
    "}" output punctuation;
    "[" output punctuation;
    "]" output punctuation;
    "(" output punctuation;
    ")" output punctuation;
    ")" output punctuation;
    "#" output punctuation;
    "##" output punctuation;
    "+" output operator;
    "++" output operator;
    . . . other punctuation and operators omitted . . .

    "<other>" output erroneous character;
begin normal line master atom table;

begin identifier atom table;
    "<letter>" accept;
    "<digit>" accept;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
            translate hex 2 0 "<letter>"
	    else keep 0 goto normal line master;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
            translate hex 2 0 "<letter>"
	    else keep 0 goto normal line master;
    goto normal line master;
end identifier atom table;

begin number atom table;
    "<digit>" accept;
    "<nondigit>" accept;
    "e<sign>" accept;
    "E<sign>" accept;
    "." accept;
    goto normal line master;
end number atom table;

begin character literal atom table;
    "'" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "\\" keep 0 call escape character;
    "<other>" accept;
    goto premature end of file master;
end character literal atom table;

begin wide character literal atom table;
    "'" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "\\" keep 0 call escape character;
    "<other>" accept;
    goto premature end of file master;
end wide character literal atom table;

begin string literal atom table;
    "\"" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "\\" keep 0 call escape character;
    "<other>" accept;
    goto premature end of file master;
end string literal atom table;

begin wide string literal atom table;
    "\"" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "\\" keep 0 call escape character;
    "<other>" accept;
    goto premature end of file master;
end wide string literal atom table;

// This atom table is called when the next atom
// begins with \ and is in a character or string
// literal.
//
// We allow only a maximum of 8 hexadecimal digits
// after \x; 9 digits is an error.  The C++ standard
// permits any number of hexadecimal digits.
//
begin escape character atom table;
    "\\n" translate "\n" return;
    "\\t" translate "\t" return;
    "\\v" translate "\v" return;
    "\\b" translate "\b" return;
    "\\r" translate "\r" return;
    "\\f" translate "\f" return;
    "\\a" translate "\a" return;
    "\\\\" translate "\\" return;
    "\\?" translate "\?" return;
    "\\\"" translate "\"" return;
    "\\'" translate "'" return;
    "\\<oct-digit>"
        translate-oct 1 0 return;
    "\\<oct-digit><oct-digit>"
        translate-oct 1 0 return;
    "\\<oct-digit><oct-digit><oct-digit>"
        translate-oct 1 0 return;
    "\\x<hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit>"
        error too many hex digits after "\\x" return;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\<other>" error bad escape sequence return;
end escape character atom table;

end c++ lexical program;
\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
