% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
\newcommand{\ttikey}[2]{{\tt \bf #1}\index{#2@{\tt #2}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttnbakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\ttitemref}[1]{{\tt \ref{#1} ({p\pageref{#1}})}}
\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newsavebox{\DOUBLEQUOTEBOX}
\begin{lrbox}{\DOUBLEQUOTEBOX}
\verb/"/
\end{lrbox}
\newcommand{\DOUBLEQUOTE}{\usebox{\DOUBLEQUOTEBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

April 13, 2012
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A machine independent reduced instruction set architecture
	  programming language.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& Similar to the C programming language but more flexible.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& Implements standardized lists, symbols, arrays, etc. to extend
	  the M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `{\tt hello}', `{\tt +}', `{\tt ;}',
`{\tt 9.200}' are four lexemes.

The lexical scanner is written in the M-Language and can be
replaced.  This section describes the standard scanner which
is driven by the lexical tables and is capable scanning
lexemes of common languages such as C and C++.

The standard scanner attempts to be both machine and human
efficient.  It attempts to be machine efficient by being
deterministic\footnote{Unlike regular expression scanners.}
and attempts to be human efficient by supporting algorithms
that people can readily understand and hopefully quickly
learn to mimic.\footnote{A possibly non-verifiable goal.}

The standard scanner operates on an input stream of 32-bit
UNICODE characters.  Each character is associated with
a position value that specifies from where the character
came.  For example, a position value may encode a file name,
line-within-file number, and column-within-line number.
The standard scanner identifies a lexeme as a sequence
of input stream UNICODE 32-bit characters each with a
corresponding position value.

The standard scanner also produces a translation of each
lexeme.  This may just be a copy of the 32-bit characters
in the lexeme, or it may have some changes, or `translations',
of some of these characters.  For example, the lexeme
\verb|"a line<LF>"| may have a translation that omits the
\verb|"|'s and converts the four characters \verb|<LF>| into
a single linefeed character.

When the standard scanner identifies a lexeme it also identifies
a `\mkey{type}{of lexeme}' for the lexeme.
For example, the lexeme \verb|9.35| may have type `{\tt number}'
while the lexeme \verb|"abc"| may have the type `{\tt quoted string}'.

At its most fundamental level the
standard scanner identifies lexical atoms in the input text.
A \key{lexical atom} is a single character (e.g., the letters
in an identifier or word) or a short string of characters
(e.g., the 4-character atom \verb|<LF>| in a quoted string).
Lexical atoms are read left to right and
grouped by the scanner into \skey{lexeme}s.

Lexical atoms have fixed small lengths.  Lexemes, in contrast,
can be of arbitrary length.

Each atom is translated individually to produce an
\key{atom translation}.  Just as the sequence of atoms in a lexeme
comprise the lexeme, the sequence of their atom translations
comprises the translation of the lexeme.  An atom translation
may be the empty string, in effect omitting the atom from the
lexeme translation.

The scanner has a state containing a current point 
in the input UNICODE character stream,
a \key{current lexical table} identifier, a \key{current lexeme type}
which may be `{\tt none}', and a \key{return stack}
of lexical table identifiers.  A
\key{lexical table} is a set of atom patterns
that match atoms, and for each pattern an
instruction that determines what to do when the pattern is matched.
There is also a \key{default instruction} associated with
the lexical table that
determines what to do when no table pattern matches the next characters
in the input stream.

An \key{atom pattern}\index{pattern!lexical atom} is a fixed
length sequence of character patterns, and matches any sequence of
input characters of the same length as the atom pattern
if each input character of the sequence matches the corresponding
character pattern.  A \key{character pattern} is simply a
specification of a set of characters, e.g., letters or digits.
Thus one can construct an atom pattern that will recognize
single letters, or one that will recognize the sequence of
characters such as the 4-character sequence \verb|<LF>| which matches
the atom pattern \verb|"<" "LF" ">"|
(in which the quoted string has been broken into three parts to prevent
\verb|<LF>| being treated as representing a single line feed character)
or the 4-character sequence \verb|<0a>| which matches the atom pattern
\begin{center}
\verb|"<0<hex-digit>>"|
\end{center}
where \verb|<hex-digit>| names a character pattern matching characters
in the ranges \verb|0-9|, \verb|a-f|, and \verb|A-F|.

The atom patterns of a single lexical table must not conflict:
no character string can be recognized by two atom patterns of the
same lexical table.  However, a shorter atom pattern in a
table may match the initial segment of an atom matched by a longer
atom pattern in the table, in which case the longer pattern is
used for the atom.

The scanner operates by identifying the
longest sequence of characters beginning at the current input character
stream point that matches an atom pattern of the current lexical table.
This sequence of characters becomes
the next atom, and an instruction associated with its matching
atom pattern is then executed.  If no atom pattern can be matched,
the default instruction associated with the lexical table is executed instead.

A lexical table
instruction can optionally reduce the length of a matched atom
and optionally change the current lexical table.  It can also do other
things described below.

There are four kinds of lexical tables:
\mkey{master}{lexical table} tables,
\mkey{lexeme}{lexical table} tables,
\mkey{sublexeme}{lexical table} tables, and
\mkey{atom}{lexical table} tables.
Master tables are used to dispatch to lexeme or sublexeme tables which
typically recognize lexemes.  Atom tables are used
to recognize atoms whose patterns are logically the union
of a finite set of patterns.

Thus a simple scanner might have
one master table that dispatches to different lexeme tables,
one to recognize identifiers, one to recognize numbers, one to
recognize whitespace, and one to recognize comments.

Lexeme tables have \ikey{types}{type!of lexeme table}.
When the current lexical table becomes a lexeme table,
the current lexeme type is set equal to the type of that table.
The `{\tt output} {\em type}' and `{\tt output none}'
instruction components can also be
used to change the current lexeme type.

Sublexeme tables are just like lexeme tables except they
have no associated type and do not reset the current lexeme type.

Upon finishing the execution of an instruction, if the
current lexical table is a master table,
the currently accumulated lexeme is output
with the current lexeme type, if that is not `{\tt none}', or the
currently accumulated lexeme is discarded if the current lexeme
type is `{\tt none}'.
The current lexeme type is reset to `{\tt none}' whenever
the current lexical table becomes a master table.

Thus if an lexical table of
type `\verb|whitespace|' cannot recognized any atom and
the default instruction associated with it
changes the current lexical table to a master table,
the lexeme accumulated so far will
be output as a lexeme of type `\verb|whitespace|'.

When it is between lexemes the current lexical table in the scanner state
is always a master table.  Master tables correspond to lexical
contexts.  A well designed language has only one main master
table, plus a few small master tables to handle error situations
such a premature new-line and premature end-of-file;
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.
Legacy languages
may have more master tables: C/C++ has several to handle
special lexical scanning of preprocessing lexemes;
see Appendix \itemref{C++-LEXICAL-PROGRAM}.

The standard scanner can report errors in one of two ways.  It may
simply output a lexeme with a type that indicates an error.  For
example, the character \verb|\| appearing outside a quoted string
might be returned as a 1-character lexeme of type `{\tt unrecognized
character}'.  Alternatively a single atom may be reported as an
error of a given type without interrupting the normal operation
of the scanner.  For example, if \verb|<H>| appears in a quoted
string, it may be reported as an erroneous atom of type
`{\tt unrecognized escape sequence}'.  Otherwise this atom will be processed
normally; it might, for example, be omitted from the lexeme
translation or be represented in that translation by the DEL
character (hex code \verb|7f|).

\ikey{Instructions}{instruction!in lexical program}
that are associated with atom patterns contain optional instruction
components that can do the following:
\begin{itemize}
\raggedright
\item invoke an atom table to replace the matched atom and translate it
\item reduce the length of the matched atom
\item translate the reduced length atom to a different character string
(otherwise the translation of an atom is a copy of the atom)
\item make instruction success conditional
      on the translated atom matching an atom pattern
\item announce the reduced length atom as an erroneous atom of a given type
\item change the current lexeme type
\item change the current lexical table
\item force the instruction containing atom table to fail to match any atom
\end{itemize}

An instruction can fail while invoking an atom table or making
a translation of the atom or if the translation does not match
an atom pattern.  An \key{instruction group} is a sequence of instructions
such that the first successful instruction will be the effective
instruction in the group.

Details and examples are given in the next section.


\subsection{Lexical Programs}

A \key{lexical program} is a set of character pattern definitions
and lexical tables.  A lexical program can include another lexical program.
The top level lexical program must begin with a master
table that serves as the initial lexical table.

The lexemes in a lexical program are specified on
\pagref{LEXEME-PROGRAM-LEXEMES}.

Consecutive quoted string lexemes are glued together.  Thus
\begin{center}
\tt "hello" " " "there"
\end{center}
is equivalent to {\tt "hello there"}.  This is useful for
breaking long quoted string lexemes across line boundaries.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \verb|"<" "LF" ">"| is
\underline{not} equivalent to \verb|"<LF>"|.  The former is a 4-character
quoted string, the characters being \verb|<|, \verb|L|, \verb|F|,
and \verb|>|.  The latter is a 1-character quoted string, the character
being a line feed.

The special {\em character-representatives} generally consist of
the ASCII character name surrounded by angle brackets.  Examples are
\verb|<NUL>|, \verb|<LF>|, \verb|<SP>|.  There are two other cases:
\verb|<Q>| represents the doublequote \verb|"|, and \verb|<NL>| (new line)
represents a line feed (same as \verb|<LF>|).

\begin{figure*}[!p]
\begin{tabular}{p{2.2in}rl}
\emkey{lexeme} & ::= & {\em symbol} $|$ {\em non-natural-number}
                                    $|$ {\em quoted-string}
\\[0.5ex]
\emkey{symbol} & ::= & {\em word} $|$ {\em mark} $|$ {\em separator}
	         $|$ {\em natural-number}
\\[0.5ex]
\emkey{word} & ::= & {\em word-character} {\em word-character}\,$^\star$ 
\\[0.5ex]
\emkey{mark} & ::= & {\em mark-character} {\em mark-character}\,$^\star$
\\[0.5ex]
\emkey{number} & ::= &
        {\em number-character} {\em number-character}\,$^\star$
\\[0.5ex]
\emkey{natural-number} & ::= & {\em digit} {\em digit}\,$^\star$
\\[0.5ex]
\emkey{quoted-string} & ::= &
    \verb|"| {\em character-representative}\,$^\star$ \verb|"|
\\[0.5ex]
\emkey{separator} & ::= & {\em separator-character}
\\[0.5ex]
\emkey{white-space} & ::= & {\em white-space-character}
                            {\em white-space-character}\,$^\star$
\\[2ex]
\emkey{word-character} & ::= & {\em letter} \\
		       & $|$ & \verb|'| followed by a letter \\
\emkey{letter} & ::= & {\em lower-case-letter} $|$ {\em upper-case-letter} \\
\emkey{lower-case-letter} & ::= &
                               \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\
\emkey{upper-case-letter} & ::= &
                               \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
\\[0.5ex]
\emkey{mark-character} & ::= &
                                \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|:| \\
		     & $|$ & \verb|.| not followed by a {\em digit} \\
		     & $|$ & \verb|/| not surrounded by {\em digits}
\\[0.5ex]
\emkey{separator-character} & ::= &
		        \verb|(|
	       	    $|$ \verb|)|
	       	    $|$ \verb|[|
	       	    $|$ \verb|]|
	       	    $|$ \verb|{|
	       	    $|$ \verb|}|
	       	    $|$ \verb|;|
	       	    $|$ \verb|`| \\
		& $|$ & \verb|,| not surrounded by {\em digits} \\
		& $|$ & \verb|'| not followed by a letter 
\\[0.5ex]
\emkey{number-character} & ::= & {\em digit} \\
		& $|$ & \verb|.| followed by by a {\em digit } \\
		& $|$ & \verb|,| surrounded by {\em digits} \\
		& $|$ & \verb|/| surrounded by {\em digits} \\
\emkey{digit} & ::= &
                   \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9| 
\\[2.0ex]
\emkey{character-representative}
    & ::= & {\em graphic-character} \\
    & $|$ & {\tt <}{\em upper-case-letter}$^+$%
	    \{{\tt -}{\em upper-case-letter}$^+$\}$^\star${\tt >} \\
\emkey{graphic-character} & ::= &
    {\em non-whitespace-non-control-character} \\
\emkey{angle-brackets} & ::= & \verb|<| $|$ \verb|>|
\\[2.0ex]
\emkey{white-space-character}
    & ::= & {\em horizontal-space-character} \\
    & $|$ & {\em vertical-space-character} \\
\emkey{horizontal-space-character} & ::= &
    {\em space} $|$ {\em horizontal-tab} \\
\emkey{vertical-space-character} & ::= &
    {\em line-feed} $|$ {\em vertical-tab} $|$ {\em form-feed}
\end{tabular}
\label{LEXEME-PROGRAM-LEXEMES}
\end{figure*}

The syntax of a lexical program is specified on
\pagref{LEXEME-PROGRAM-SYNTAX-1} and
\pagref{LEXEME-PROGRAM-SYNTAX-2}.

\begin{figure*}[!p]
\begin{tabular}{l}
\emkey{name} ::= 
	\{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}$^\star$
	{\em word}
	\{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}$^\star$
\end{tabular}
\\[1ex]
\begin{tabular}{p{2.2in}rl}
\emkey{lexical-program} & ::= &
	{\tt begin} {\em program-name} {\tt lexical program;}\\
	& &  ~~~~{\em lexical-program-unit}$^\star$ \\
	& & {\tt end} {\em program-name} {\tt lexical program};
\\[1ex]
\emkey{program-name} & ::= & {\em name}
\\[1ex]
\emkey{lexical-program-unit}
	& ::= & {\em cpat-definition} \\
	& $|$ & {\em lexical-table-definition} \\
	& $|$ & {\em program-inclusion}
\\[1ex]
\emkey{program-inclusion} & ::= & {\tt include} {\em program-name}
				  {\em remove-clause}$^\star$ {\tt ;}
\\[1ex]
\emkey{remove-clause} & ::= & {\tt remove} {\em lexical-table-name} \\
                      & $|$ & {\tt remove} {\tt "}{\em cpat-name}{\tt "}
\\[1ex]
\multicolumn{3}{l}{~~~~~~Note: `{\em cpat}\,' abbreviates
                               `{\em character-pattern}\,'}
\\[1ex]
\emkey{cpat-definition} & ::= &
	{\tt "}{\em cpat-name}{\tt "} {\tt =}
		{\em cpat-expression} {\tt ;}
\\[1ex]
\emkey{cpat-name} & ::= &
	{\tt <}{\em letter}$^+$\{{\tt -}{\em letter}$^+$\}$^\star${\tt >} \\
	\multicolumn{2}{r}{but not} &
	{\tt <}{\em upper-case-letter}$^+$%
	\{{\tt -}{\em upper-case-letter}$^+$\}$^\star${\tt >} \\
\\[1ex]
\emkey{cpat-expression} & ::= &
	{\em cpat-term}
	\{ {\tt |} {\em cpat-term} \}$^\star$ \\
       & $|$ &
	{\em cpat-term}
	\{ {\tt \&} {\em cpat-term} \}$^\star$
\\[1ex]
\emkey{cpat-term} & ::= & {\em cpat-factor} $|$ \TILDE {\em cpat-factor}
\\[1ex]
\emkey{cpat-factor} & ::= & {\tt "}{\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em quotable-character}{\tt -}%
		                   {\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em cpat-name}{\tt "} \\
		    & $|$ & {\tt (} {\em cpat-expression}
		                {\tt )}
\\[1ex]
\emkey{quotable-character} & ::= & {\em character-representative}
\\[1ex]
\emkey{lexical-table-definition} & ::= &
	{\tt begin} {\em lexical-table-name}
		    {\em lexical-table-kind} {\tt table} {\tt ;} \\
	& &  ~~~~{\em lexical-table-entry}$^\star$ \\
	& &  ~~~~{\em default-instruction-group} \\
	& & {\tt end} {\em lexical-table-name}
		      {\em lexical-table-kind} {\tt table} {\tt ;}
\\[1ex]
\emkey{lexical-table-kind} & ::= &
    {\tt master} $|$ {\tt lexeme} $|$ {\tt sublexeme} $|$ {\tt atom}
\\[1ex]
\emkey{lexical-table-name} & ::=
    & {\em name} except {\tt scan error} or {\tt none}
\\[1ex]
\emkey{type} & ::= & {\em name} except {\tt scan error} or {\tt none}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-1}
\end{figure*}

\begin{figure*}[!t]
\begin{tabular}{p{2.2in}rl}
\emkey{default-instruction-group}
	& ::= &  {\em empty} $|$ {\em instruction-group}
\\[1ex]
\emkey{lexical-table-entry}
	& ::= & {\em atom-pattern} {\em instruction-group} {\tt ;} \\
	& $|$ & {\em atom-pattern} {\tt ;}
\\[1ex]
\emkey{atom-pattern} & ::= &
	{\tt "}\{{\em quotable-character}$|${\em cpat-name}\}$^+${\tt "}
\\[1ex]
\emkey{instruction-group}
	& ::= & {\em instruction}
	        \{ {\tt else} {\em instruction} \}$^\star$

\\[1ex]
\emkey{instruction} & ::= & {\em instruction-component}$^+$
\\[1ex]
\emkey{instruction-component}
	& ::= & {\tt accept} \\
	& $|$ & {\tt match} {\em atom-table-name} \\
	& $|$ & {\tt keep} {\em natural-number} \\
	& $|$ & {\tt translate to} {\em translation-string} \\
	& $|$ & {\tt translate hex}
			{\em natural-number} {\em natural-number} \\
	& $|$ & {\tt translate oct}
			{\em natural-number} {\em natural-number} \\
	& $|$ & {\tt require} {\em atom-pattern} \\
	& $|$ & {\tt error} {\em type} \\
	& $|$ & {\tt output} {\em type} \\
	& $|$ & {\tt output} {\tt none} \\
	& $|$ & {\tt goto} {\em master-table-name} \\
	& $|$ & {\tt goto} {\em lexeme-table-name} \\
	& $|$ & {\tt goto} {\em sublexeme-table-name} \\
	& $|$ & {\tt call} {\em lexeme-table-name} \\
	& $|$ & {\tt call} {\em sublexeme-table-name} \\
	& $|$ & {\tt return} \\
	& $|$ & {\tt fail} \\
\\[1ex]
\emkey{atom-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{lexeme-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{sublexeme-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{master-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{translation-string} & ::= & {\em quoted-string}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-2}
\end{figure*}

An example lexical program that recognizes
whitespace and quoted strings is given
on \pagref{EXAMPLE-LEXEME-PROGRAM}.
\verb|<LF>| is the only {\em character-representative} recognized
in quoted strings by this example.

\begin{figure*}[!p]
\addtolength{\baselineskip}{-0.4ex}
\begin{indpar}\begin{verbatim}
begin example lexical program;

"<whitespace-char>" = " " | "<LF>" | "<HT>" | "<VT>" | "<FF>";

begin main master table;
    "<whitespace-char>" goto whitespace;
    "<Q>" translate to "" goto quoted string;
    "<other>" output bad character;
    output end of file;
end main master table;

begin whitespace lexeme table;
    "<whitespace-char>" accept;
    goto main;
end whitespace lexeme table;

begin quoted string lexeme table;
    "<Q>" translate to "" goto main;
    "<LF>" keep 0 goto premature end of line;
    "<" "LF" ">" translate to "<LF>";
    "<other>" accept;
    goto premature end of file;
end quoted string lexeme table;

include premature tables;

end example lexical program;

begin premature tables lexical program;
    // Stuff to include.

begin premature end of line master table;
    "<LF>" output premature end of line
           goto main;
end premature end of line master table;

begin premature end of file master table;
    output premature end of file
           goto main;
end premature end of file master table;

end premature tables lexical program;
\end{verbatim}\end{indpar}
\label{EXAMPLE-LEXEME-PROGRAM}
\end{figure*}

A \emkey{lexical-program} consists of a sequence of units that are
{\em character-\EOL pattern-\EOL defi\-ni\-tions},
{\em lexical-\EOL table-\EOL defi\-ni\-tions},
or {\em program-inclusions}.  These respectively define character pattern sets
and lexical tables, and include lexical program units of
previously defined lexical programs.

\subsubsection{Lexical Program Inclusion}

A \emkey{program-inclusion} names a previously defined lexical program
whose units are to be included in the current lexical program
at the point of the {\em program-inclusion}.
There is a simple example of a program inclusion at the end of
the {\tt example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.
Identical definitions
may be repeated without error,
as can happen when one program includes two programs each of
which include the same third program.
A {\em program-inclusion} can have
\emsmkey{remove-clause}s{in {\em program-inclusion}}
each of which removes a named definition from the set of included
definitions.  This is the only way to resolve conflicts between
definitions.

\subsubsection{Character Pattern Definitions}

A \emkey{character-pattern-definition} (abbreviated as
\emkey{cpat-definition}) assigns a set of characters to a
{\em character-pattern-name}.  The latter is just a string of
letters and hyphens (\verb|-|) surrounded by angle brackets (\verb|< >|)
with hyphens occurring only between letters.  Examples:
\verb|<digit>| and \verb|<line-break>|.  However, a {\em character-pattern-name}
cannot contain only upper case letters, as this could conflict with
some {\em character-representative}.

The character set is denoted by a \emkey{character-pattern-expression}.
The simplest character pattern
expression is just a single {\em quotable-character} in quotes, which denotes
the character set containing only the quoted character.  Examples:
\verb|"0"| and \verb|"+"|.  The next simplest is two {\em quotable-characters}
separated by a hyphen (\verb|-|) denoting the character set consisting
of all characters in the range from the first to the second of the two
characters.  Examples: \verb|"0-9"| and \verb|"A-Z"|.  The characters
are ordered according to their 32 bit unsigned UNICODE value, and the
second of the two characters must not be smaller than the first.

A {\em quotable-character} is a representative of a single UNICODE
character that can be used inside quotes (\verb|"|).
Printable ASCII characters represent themselves.  Other characters
are represented by character sequences surrounded by the angle
brackets \verb|<| and \verb|>| (which are also the less than and
greater than signs).
For example, a line feed can be represented by any of the
following: \verb|<LF>|, \verb|<0A>|,
\verb|<00A>|, \ldots, or \verb|<00000000A>|.

A quoted {\em character-pattern-name} denotes the character set associated
with that name by a \underline{previous} {\em character-pattern-definition}.

The \verb/|/, \verb|&|, and \verb|~| operators and can be used to take
the union, intersection, and complements of character sets.  The complement
is relative to the universe of all 32 bit unsigned integer UNICODE
character codes.  Thus \verb|~ "b-y"| denotes the same character set as
\verb$"<0>-a" | "z-<0FFFFFFFF>"$.

Parentheses may be used in {\em character-pattern-expressions} as is
normal in algebraic expressions.
Note that the \verb/|/ and \verb|&| operators cannot be used together
in the same expression without intervening parentheses as neither
takes precedence over the other.  This is done to prevent ambiguity.

Some example {\em character-pattern-definitions} are:

\begin{indpar}\begin{verbatim}
"<hex-digit>" = "0-9" | "a-f" | "A-F";
"<non-line-break-char>" = ~ "<LF>" & ~ "<VT>" & ~ "<FF>";
"<quotable-char>" = "<020>-<07E>" & ~ "<Q>";
"<whitespace-char>" = " " | "<LF>" | "<VT>" | "<FF>" | "<HT>";
"<source-character>" =
    ( "<020>-<07E>" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";
\end{verbatim}\end{indpar}

\subsubsection{Lexical Tables}

A {\em lexical-table-definition} specifies a {\em lexical-table-name},
the {\em lexical-table-kind} of the table,
a set of {\em lexical-table-entries}
each containing an {\em atom-pattern} and optionally an {\em instruction},
and an optional {\em default-instruction-group} that is executed when
no atom is recognized by any of the table entries.

The {\em lexical-table-kinds} are
\mkey{master}{lexical table kind},
\mkey{lexeme}{lexical table kind},
\mkey{sublexeme}{lexical table kind}, or
\mkey{atom}{lexical table kind}.
In a master table {\em atom-patterns} are typically associated
with {\tt goto} or {\tt call} instructions
that change the current table from the
master table to a lexeme or sublexeme table.
In a lexeme or sublexeme table {\em atom-patterns}
are typically associated with {\tt accept} instructions which
accept the matched atom as part of the current lexeme.  In a lexeme
or sublexeme
table the default instruction is typically a {\tt goto} or {\tt return}
back to a
master table, and because this changes the current lexical table
to a master table, it causes any accumulated lexeme
to be output with its lexeme type being the current lexeme type
if that is not `{\tt none}', or it causes any accumulated lexeme
to be discarded if the current lexeme type is `{\tt none}'.

Atom tables permit sets of atom patterns to be used in
several places without copying all the patterns.  Details are
on \pagref{ATOM-TABLE}.

The first master table in a lexical program
becomes the current lexical table when the scanner
is initialized.  This table is typically named `{\tt main}',
as it is in the {\tt example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.

A lexical table consists of {\em lexical-table-entries}%
\emindex{lexical-table-entry} each containing an {\em atom-pattern} and
an {\em instruc\-tion-group}.  The \emkey{atom-pattern} is matched against
the remaining input characters.  The pattern consists of a sequence
of {\em quotable-characters}, each of which match only themselves,
and {\em character-pattern-names}, each of which match any character
in the named set of characters.  Thus
\begin{center}
\verb|"<0<hex-digit><hex-digit>>"|
\end{center}
matches 5-character atoms consisting of a \verb|<| followed by an
\verb|0| followed by two characters each in the character set
named by \verb|<hex-digit>| followed by a \verb|>|.
Note that each {\em atom-pattern}
only matches atoms of a particular length.


The special character pattern name
{\tt \bf \LESSTHAN other\GREATERTHAN}%
\index{other@{\tt \LESSTHAN other\GREATERTHAN}}%
\label{<OTHER>}
can be used in an atom pattern to match any character not otherwise
matched.  More specifically, in the atom pattern
\verb|"|$P$\verb|<other>|$Q$\verb|"|,
the prefix \verb|<other>| matches any characters not matched by
any other character pattern $C$ that is an some atom pattern of the form
\verb|"|$PCR$\verb|"| in the same lexical table.
There are several examples of this on \pagref{EXAMPLE-LEXEME-PROGRAM}.

There must be no sequence of characters that matches the
{\em atom-patterns} of two distinct {\em lexical-table-entries}
in the same {\em lexical-table}.  Since {\em atom-patterns} can only
match atoms of a particular length, it is permissible for
a sequence of characters that matches one pattern to have a proper
initial segment that matches another pattern; in this case the
longer pattern takes precedence.  The order of {\em lexical-table-entries}
in a {\em lexical-table} is not significant.

The atom pattern \verb|""| which would recognize zero length atoms is
\underline{not} permitted, but the {\em default-instruction-group} at the
end of the lexical table executes in the equivalent case where no atom
pattern in the table matches the remaining input.  In particular
the {\em default-instruction-group} always executes if the input has reached
an end of file.  This fact is used in both the `{\tt main master table}'
and `{\tt quoted string lexeme table}'
on \pagref{EXAMPLE-LEXEME-PROGRAM}.

\subsubsection{Lexical Instructions}

A \emkey{lexical-table-entry} contains an
{\em atom-pattern} and an optional
\emkey{instruction-group} that consists of one or more {\em instructions}
separated by {\tt else}'s.  Most {\em instruction-groups} contain just
a single {\em instruction}, so we will explain this first.
{\em Instruction-groups} with more than one instruction contain
instructions that can fail, causing
the failing instruction to become a no-operation and the
next instruction in the instruction group to be executed instead.

An \emmkey{instruction}{in lexical-table-entry} in an {\em lexical-table-entry}
specifies actions to be taken when an atom is recognized by the
{\em atom-pattern} of the entry.  The {\em instruction} consists of
a set of {\em instruction-components} each of which controls part of the
atom processing.

The {\em default-instruction-group} at the end of an lexical table behaves as
if a it was associated with the {\em atom-pattern} \verb|""|
that recognizes zero length atoms.  Note that actual {\em atom-patterns}
are not allowed to be \verb|""|.

The order of processing {\em instruction-components} in an {\em instruction}
is:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{Components that may
cause their containing instruction to fail:} \\[1ex]
~~~~~~~~ & {\tt match}, {\tt translate oct}, or {\tt translate hex} \\
~~~~~~~~ & {\tt require}
\\[2ex]
\multicolumn{2}{l}{Components that only execute if their
containing instruction does not fail:} \\[1ex]
~~~~~~~~ & {\tt keep} \\
~~~~~~~~ & {\tt translate to}\\
~~~~~~~~ & {\tt error} \\
~~~~~~~~ & {\tt output} \\
~~~~~~~~ & {\tt goto}, {\tt call}, {\tt return}, or {\tt fail} \\
\end{tabular}
\end{center}

An {\em instruction} with no {\em instruction-components} simply accepts
the matched atom and copies it into the translation.  In order to
indicate this, the instruction may be written as if it had a single
`{\tt accept}' instruction component.  If this component is present
in an {\em instruction}, no other {\em instruction-components}
may be present in the {\em instruction}.

\subsubsubsection{Match Instruction Components and Atom Tables}

The `\ttmkey{match}{in lexical program} {\em atom-table-name}'
{\em instruction-component} invokes the named
\key{atom table}\label{ATOM-TABLE}
to recognize an atom and provide its translation.
Any previously matched atom and translation are ignored, and
the atom table {\em atom-patterns} are used to rematch the current atom,
provide a translation of the atom, and determine
whether the containing {\em instruction} fails.

Atom tables match only a single atom and implicitly return
to their invoking instruction after matching one atom.  The
{\tt output}, {\tt goto}, {\tt call}, and {\tt return}
{\em instruction-components} \underline{cannot} be used in an
atom table.  However, the {\tt fail} {\em instruction-component}
can only be used in an atom table, and when executed indicates
that the atom table invoking {\em instruction} has failed, so that
{\em instruction} becomes a no-operation and the next
{\em instruction} in the invoking
{\em instruction-group} (i.e., the {\em instruction}
after the `{\tt else}' following the failed {\em instruction}) is
executed.

{\tt accept}, {\tt match}, {\tt keep}, {\tt require}, and
any of the {\tt translate} {\em instruction-components} can be used in
an atom table {\em instruction}.  An atom table
instruction may invoke another atom table, but recursion
is prohibited.

If an instruction invokes an atom table and
the atom table does not fail,
the original atom match that caused the instruction
to be executed is replaced by the atom matched by the
atom table, and the atom translation is that provided by the atom table.

An instruction that invokes an atom table fails if the atom table
fails or if the instruction has a {\tt require} component that fails
when applied to the atom translation produced by the atom table.
If the instruction fails, the
original atom match is reinstated (the instruction becomes a
no-operation) before the next {\em instruction} in the {\em instruction group}
executes.

The {\tt error} instruction component can also be used in an atom
table, but if the atom table fails, or if a subsequent {\tt require}
causes a {\tt match} that invoked the atom table to fail, the
effects of the {\tt error} instruction component will \underline{not}
be undone.  Normally the only effect is to announce an error.

Atom tables may have a {\em default-instruction-group}.
However, this only makes sense if it is just a `{\tt fail}', or
if it is contains {\tt match} components.  If an atom table
is invoked and none of its {\em atom-patterns} match an atom,
and if the table has \underline{no} {\em default-instruction-group},
then a scan error is signaled (i.e., `{\tt fail}' is \underline{not}
implicit).

\subsubsubsection{Translate Hex/Oct Instruction Components}

\hfill The {\tt translate hex/\EOL oct} \\ components are applied to a matched
atom to produce a single UNICODE character translation of the atom.

An instruction can contain at most one of the following components:
\begin{center}
\tt
match \\
translate hex \\
translate oct
\end{center}
This is because all three of these components independently produce
an atom translation.

Note that if any previous instruction in an instruction group contains
a {\tt match} component, that instruction must have failed, and the
atom as it was when the instruction group started to execute must have
been reinstated, so {\tt translate hex/oct} components are always
applied to the matched atom as it was when the containing instruction
group started to execute, before any {\tt match} components in the
group executed.

Also note that any {\tt keep} component executes \underline{after}
{\tt translate hex/oct} components, and so does not affect the
matched atom used by these components.

The `\ttmkey{translate hex}{in lexical program} $m$ $n$'
{\em instruction-component} ignores the
first $m$ and last $n$ characters of the matched atom and, viewing the rest as
hexadecimal digits, converts these into an 32 bit unsigned integer
UNICODE character code, which becomes the 1-character atom translation.
An example is the the lexical table entry
\begin{center}
\verb|"<0<hex-digit><hex-digit>>" translate hex 2 1;|
\end{center}
which might be used to accept a character representative in a quoted string
and copy the appropriate hexadecimally related character code into
the lexeme translation.  If characters that
are supposed to be hexadecimal digits are not, the {\tt translate-hex}
component fails (but in our example
this cannot happen because the definition of \verb|<hex-digit>|
restricts these characters appropriately).

The `\ttmkey{translate oct}{in lexical program} $m$ $n$'
{\em instruction-component} is identical but
views the rest of the characters as octal and not hexadecimal.
An example use would be the lexical table entry
\begin{center}
\verb|"\<oct-digit><oct-digit><oct-digit>" translate oct 1 0;|
\end{center}

\subsubsubsection{Require Instruction Components}

The `\ttmkey{require}{in lexical program} {\em atom-pattern}'
{\em instruction-component} tests whether the atom translation
matches the given {\em atom-pattern},
and if \underline{no}, causes the {\em instruction} to fail.
A {\tt require} should only appear in an
{\em instruction} which is followed by an `{\tt else}' in an
{\em instruction-group}.
A {\tt require} should only appear in an instruction that also
contains a {\tt match}, {\tt translate hex}, or {\tt translate oct}
instruction component, and is only useful for testing the
translations produced by these latter components.

An example use would be the lexical table entry
\begin{indpar}
\verb|"\u<hex-digit><hex-digit><hex-digit><hex-digit>" translate hex 2 0| \\
\verb|    require "<letter>" else| \\
\verb|    translate to "" error bad character in identifier;|
\end{indpar}
which might be used to process an atom of the form \verb|\uXXXX| in
an identifier, accepting the atom as a legitimate representation of a
character if that character is a letter, and otherwise designating
the atom as an error while not putting anything in the lexeme translation
(see below for the definition of the `{\tt error}' instruction component).

The last {\em instruction} in an {\em instruction-group} must
never fail, and so cannot contain a {\tt require} {\em instruction-component}.

\subsubsubsection{Keep Instruction Components}

The `\ttmkey{keep}{in lexical program} $n$'
{\em instruction-component} causes the atom length
to be shortened to $n$.  For example, the lexical table entry
\begin{center}
\verb|",<digit>" keep 1;|
\end{center}
will recognize a 1-character atom consisting of just a comma as long as
the comma is followed by character in the \verb|<digit>| character pattern
character set.  Atoms may not be lengthened by {\tt keep}.

A {\tt keep} component in the same instruction as a {\tt match} component
applies to the atom matched by the atom table invoked by the {\tt match}
component.

\subsubsubsection{Translate To Instruction Components}

A `\ttmkey{translate to}{in lexical program} {\em translation-string}'
{\em instruction-component}
specifies a {\em quoted-string} of characters,
the {\em translation-string},
that becomes the translation of the atom.
A {\em translation-string} may be empty, as in the lexical table entry
\begin{center}
\verb|"<Q>" translate to "" goto main;|
\end{center}
which can be used to recognize the last \verb|"| of a quoted string, avoid
copying anything into the lexeme translation, and then switch to the
`{\tt main}' lexical table.
See the example on \pagref{EXAMPLE-LEXEME-PROGRAM}.

The {\tt translate to} component is executed \underline{after}
any {\tt match}, {\tt translate hex}, or {\tt translate oct}, or
{\tt require} components are executed, and overrides the translations produced
by these components.  It is therefore possible to produce a translation,
test it with {\tt require}, and if the test is successful, override the
translation with {\tt translate to}.  An example is
\begin{center}
\begin{tabular}{l}
\verb|"<"  "<digit>" match escaped char| \\
\verb|               require "<ascii-character>"| \\
\verb|               error ascii escaped character| \\
\verb|               translate to ""| \\
\end{tabular}
\end{center}
which announces that any escape sequence producing an ASCII character
is an erroneous atom and replaces that atom by the empty translation
so it is as if the atom did not exist in the input.
One could also use `{\tt translate to "?"}' to replace the atom
by a question mark.

If an instruction does not contain any {\tt match}, {\tt translate hex},
{\tt translate oct}, or {\tt translate to} components, the translation
of an atom defaults to a copy of the atom itself, \underline{after}
any {\tt keep} component has been used to change the length of the atom.

\subsubsubsection{Error Instruction Component}

A `\ttmkey{error}{in lexical program} {\em type}\,' {\em instruction-component}
announces the current atom as an erroneous atom of the given {\em type}.
The atom remains part of the current lexeme,
and its translation is governed
independently by {\tt match} and translate instruction components.
The following are some examples:
\begin{indpar}\begin{verbatim}
"\<other>" error bad escape sequence;
"\<other>" translate to "" error bad escape sequence;
"\<other>" translate to "<DEL>" error bad escape sequence;
\end{verbatim}\end{indpar}
These might be entries in an lexical table for a quoted string.
All identify an atom consisting of a backslash followed by any
character that does not match any character pattern $C$ that is in
a lexical table
atom pattern of the form \verb|"\|$C$\ldots\verb|"| where $C$ is a character
pattern other than \verb|<other>| (see \pagref{<OTHER>}).
The first entry copies the entire 2-character atom, including the
backslash, into the lexeme translation.  The second entry copies
nothing (the empty string \verb|""|) into the lexeme translation.
The third entry copies the DEL character (hex code \verb|7f|)
into the lexeme translation.  An alternative is the entry
\begin{indpar}\begin{verbatim}
"\<other>" keep 1 error bad escape;
\end{verbatim}\end{indpar}
that reduces the atom size to 1 character, just the backslash,
which is announced as an error without its following character,
and copied to the lexeme translation.  The character following
the backslash remains in the input and will part of the next
atom recognized.
Another alternative is
\begin{indpar}\begin{verbatim}
"\" match bad escape translate "" error bad escape;
. . .
<any> = <0-<0FFFFFFFF>>;      // Matches any character.
begin bad escape atom table;
"\<any><any><any>"
end bad escape atom table;
\end{verbatim}\end{indpar}
in which the lexical table entry will be invoked if the next character
in the input is \verb|\| and no longer
lexical table atom pattern of the form \verb|"\|\ldots\verb|"| is matched, 
and as a result the \verb|\| and the next three characters will be identified
as a `{\tt bad escape}'
erroneous atom and translated to the empty character sequence.


The routine that announces an error atom is given the position
of the atom in the input stream, so characters surrounding the
atom may also be included in the announcement.  For example,
the line containing the atom may be printed with marks under the
characters of the atom.  So the fact that the erroneous atom
proper in the last example might be just the backslash does not
prevent the characters after the backslash from being included
in the error announcement.

An erroneous atom is different from an erroneous lexeme.
An erroneous lexeme is simply a lexeme whose {\em type}
indicates to the user of the lexical scanner that the lexeme is erroneous.
As such an erroneous lexeme is
handled by the lexical scanner just as any other lexeme would be:
i.e., the lexical scanner has no special knowledge of erroneous lexemes
and no special operations for detecting or announcing them.

\subsubsubsection{Output Instruction Component}

\hfill A `\ttmkey{output}{in lexical program} {\em type}\,'
{\em instruction-component} sets the \key{current lexeme type}.

The {\tt output} {\em instruction-component} is
used to change the type of the lexeme to be output from
the type of the table containing the instruction.
For example, at the top of \pagref{EXAMPLE-LEXEME-PROGRAM} the
{\tt main} master table has `{\tt output end of file;}' as its
{\em default-instruction-group}, thereby outputting a zero length
lexeme with `{\tt end of file}' type whenever the input is at the
end of file.

As another example, the `{\tt main}' master table at the top of
\pagref{EXAMPLE-LEXEME-PROGRAM} contains the entry:
\begin{indpar}\begin{verbatim}
"<other>" output bad character;
\end{verbatim}\end{indpar}
which causes an unrecognized character to be treated as a 1-character
lexeme of type `{\tt bad character}'.  The translation of this lexeme is
the character itself, but if the entry:
\begin{indpar}\begin{verbatim}
"<other>" translate to "<DEL>" output bad character;
\end{verbatim}\end{indpar}
had been used instead the translation would have been the ASCII delete
(DEL) character.

Upon finishing the execution of an instruction, if the
current lexical table is a master table,
the currently accumulated lexeme is output
with the current lexeme type, if that is not `{\tt none}', or the
currently accumulated lexeme is discarded if the current lexeme
type is `{\tt none}'.
The current lexeme type is reset to `{\tt none}' whenever
the current lexical table becomes a master table.

\subsubsubsection{Goto, Call, Return, and Fail Instruction Components}

A `\ttmkey{goto}{in lexical program} {\em lexical-table-name}\,'
{\em instruction-component} switches the current lexical table after
the current atom is processed.  If the table switches
to a master table and the current lexeme type is not `{\tt none}',
then the current lexeme is output with the
current lexeme type as its type.

A `\ttmkey{call}{in lexical program} {\em lexeme-table-name}\,'
{\em instruction-component} is just like `{\tt goto}' except
that it also pushes the identifier of the lexical table in which
the `{\tt call}' occurs (the `caller') into the return stack.
The \key{return stack} is a stack of up to 16 lexical table identifiers
used by the `{\tt call}' and `{\tt return}' instruction components
and also by the `{\tt match} {\em atom-table-name}'
instruction components.  Recursive calls are prohibited.
Whenever a master table becomes the current lexical table, the
return stack is cleared.

A `\ttmkey{return}{in lexical program}'
{\em instruction-component} is just like `{\tt goto}' except
that uses the lexical table identifier at the top of the return
stack to determine the next lexical table.  This identifier is
also popped from the stack.

The return stack is set to empty whenever the current lexical table
becomes a master table.
A {\tt call} \underline{cannot} be used
to call a master or atom table.  A {\tt return} can only
appear in a lexeme or sublexeme table.
A {\tt goto} \underline{cannot} be used to go to an atom table.

The `{\tt call}' and `{\tt goto}' instruction components
can both be used in the same {\em instruction}, in 
which case the {\tt goto} lexical table identifier is pushed into the
return stack instead of the current lexical table identifier.
The `{\tt return}' instruction component cannot be used with
`{\tt call}' or `{\tt goto}' (if `{\tt return}' and `{\tt call}'
could be used together, they would have the same affect as
a simple `{\tt goto}')

The `{\tt call}' and `{\tt return}' instruction components
permit a lexeme or sublexeme table to be shared among different
master, lexeme, and sublexeme tables.  For example, a lexeme table to scan
a comment lexeme may be shared among several master tables;
see Appendix \itemref{C++-LEXICAL-PROGRAM} for examples.

The `{\tt call}' and `{\tt return}' instruction components
add nothing new to the lexical scanning language, since they
cannot be used recursively,
and they can always be eliminated by making
copies of the called tables with hard coded returns.
But for certain languages these instruction components
substantially reduce the size of the lexical program.

A `\ttmkey{fail}{in lexical program}'
{\em instruction-component} can only be used in an atom
table and causes the instruction invoking the atom table to fail.
The `{\tt goto}', `{\tt call}', and `{\tt return}' instruction components
\underline{cannot} be used in an atom table.

\section{Parsing}

The parser is a sequence of passes each of which operates on a list
of tokens.  A token is either a lexeme or an expression.
The top level parser pass, the explicit subexpression recognition pass,
recognizes subexpressions that are bounded by explicit brackets
such as `{\tt (}' and `{\tt )}' or ends of lines that are not
followed by indented lines.  The non-top-level passes
operate on the subexpressions recognized by previous passes.

Parsing reduces each recognized subexpression, including each input
line, to a single expression token.  Here input lines may be continued
by indented lines.

\subsection{Tokens}

A token has the following components:

\begin{indpar}
\begin{tabular}{p{1in}p{4.5in}}
\tt type	& One of: \hspace{0.5in}\begin{tabular}[t]{l}
        	          A lexeme type. \\
        	          \ttmnbkey{EXPRESSION}{token type} \\[1ex]
			  \end{tabular}
\\[1ex]
		& For a lexeme, the translation of the
		  lexeme may be recorded in either the token
		  {\tt value} as a MIN string or in the token {\tt string}.
\\[1ex]
		& For an {\tt EXPRESSION}, the value of the
		  expression is re\-corded as a MIN object
		  in the token {\tt value}.
\\[1ex]
		& Comment, line break, and end of file tokens have
		  neither token {\tt string} nor token {\tt value}.
\\[1ex]
		& Whitespace lexemes are
		  ignored and not translated into tokens, as the
		  the token {\tt begin} and token {\tt end}
		  (see below) record the line number, indentation and extent
		  of non-whitespace tokens.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\tt value	& For lexemes that have a token {\tt value}, this is
		  the lexeme translation string stored as a MIN string.
\\[1ex]
		& The standard parser encodes the translation
		  strings of words, marks, separators, and natural
		  numbers as token {\tt value}'s, but \underline{not}
		  the translation strings of non-natural numbers
		  or quoted strings.
\\[1ex]
		& A token in which the translation string is
		  encoded as a token {\tt value}
		  is also called a `\key{symbol token}'.
		  Note that as symbols {\tt 001}, {\tt 01}, and {\tt 1}
		  are all distinct.
\\[1ex]
		& For EXPRESSION tokens, this is a MIN object which
		  encodes a list.  This list may also have other
		  attributes, such as
		  {\tt .initiator}, {\tt .terminator}, {\tt .middle},
		  {\tt .sep\-arator}, {\tt .name}, {\tt .arguments}, and
		  {\tt .keys}.
\\[1ex]
\tt string	& For quoted string and non-natural number lexemes,
		  which do not have token {\tt value}'s,
                  this is the translation string of the lexeme,
		  stored in a manner that makes
		  garbage collection and memory reuse more
		  efficient than it would be if MIN strings
		  were used, but makes lookup less efficient.

\end{tabular} \\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\begin{tabular}[t]{l}
\tt begin \\
\tt end
\end{tabular}   & The positions of the first character of the token
		  and the first character after the token in the
		  input text.  A position records a line number
		  and the byte offset within a UTF-8 encoding
		  of the line.
\end{tabular}
\end{indpar}

Tokens are organized in a doubly threaded list.  A file is translated into
such a list that ends with a token containing a end-of-file
lexeme.  Some tokens, like end-of-file and line-break lexeme
tokens, do not have their translation strings recorded in the token.
The tokens of a file are not read in all at once, but are read in as
needed.

As the parser identifies subexpressions, the tokens in the
subexpression are replaced by a single {\tt EXPRESSION} token
which encodes the subexpression.
File input lines may also be organized into paragraphs containing
paragraph lines, and both paragraph lines and paragraphs are
treated as subexpressions.  Although at the top level an entire
input file can be considered to be a paragraph, the parser \underline{never}
forms the {\tt EXPRESSION} token that would represent it, but instead
delivers top level paragraph lines one at a time for subsequent
processing.

\subsection{Parser Symbol Table}

Sequences of lexemes encoded as tokens are looked up in
\skey{parser symbol table}s.
A parser symbol table is conceptually a stack of
\skey{parser definition}s.

In fact, there are different
symbol tables for different parser passes, as each pass
looks up only definitions of pass specific types.

Each parser definition has the following
components:

\begin{indpar}
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{label}{of symbol table entry}
		& A sequence of `symbols' that identifies the definition.
\\[1ex]
		& A \key{symbol} is a MIN string equal to the
		  lexeme translation string of a word, mark, separator,
		  or natural number lexeme.  Quoted string and non-natural
		  number lexemes are not symbols.
\\[1ex]
		& Labels are symbol table `\skey{key}s', that is, they
		  are what is looked up in a symbol table.
\\[1ex]
		& If a label has just one symbol, it is represented by
		  a MIN string.  Otherwise it is represented by
		  a MIN label whose elements are MIN strings
		  equal to the symbols.
\\[1ex]
		& Note that natural numbers are represented by MIN
		  strings equal to their lexeme translation strings,
		  and are \underline{not} represented as MIN numbers.
		  As a consequence `{\tt 01}' and `{\tt 1}' are
		  different natural number symbols.
\end{tabular}

\medskip

\begin{tabular}{p{1in}p{4.5in}}
\tt type	& The type of the definition.  Each parser pass has
		  one (or sometimes more) symbol tables containing
		  definitions of types particular to the pass.
		  For example, the explicit subexpression recognition
		  pass has {\tt opening bracket}, {\tt closing bracket},
		  {\tt indentation mark}, and {\tt indentation separator}
		  type definitions, among others.
\end{tabular}

\medskip

\begin{tabular}{p{1in}p{4.5in}}
\tt selectors	& A set of \skey{parsing selector}s that determine if
		  the definition is active.  See text.
\end{tabular}
\end{indpar}

Lookup in a parser symbol table takes as input a token sequence
that is part of a line (for the explicit subexpression recognition pass)
or subexpression (for other passes), and finds the active symbol table
entry with the longest label whose symbols match an initial segment
of the token sequence.  Only symbol tokens, whose lexeme types are word,
mark, separator, or natural number, can match label symbols.  These are just
the token types that have values which are MIN strings equal to the
translation strings of their lexemes, and it is these values that
are matched for equality with the table entry label symbols.
When a match is found,
the initial segment of tokens used in the match is called
a `\key{matched label}\,'.

Note that in the explicit
subexpression recognition pass matched labels may not span line boundaries.
In later passes, line boundary tokens are no longer present, and
matched labels can span line boundaries,
but cannot cross explicit subexpression
boundaries.

The context of a symbol table lookup includes a set of selectors.
In order to be active, a symbol table entry's set of selectors
must have some selector in common with the context set of selectors.
A selector set is represented as a 64-bit unsigned integer value
with the bit in
position 1{\tt <<}N being on if the N+1'st selector is in the set.
Thus there can be at most 64 distinct selectors used by any set of
parser definitions.

Also parser definition activity may depend upon context.  For example,
if `{\tt <}' is a named opening and `{\tt |}' is its associated named
middle (see \itemref{NAMED-BRACKETED-SUBEXPRESSIONS}
below for details), this named middle `{\tt |}'
is not active unless it is proceeded by
its associated named opening `{\tt <}' in the current explicit subexpression.

\subsection{Parser Definitions}

The syntax of a parser definitions in general and those
associated with the explicit expression recognition pass in particular
is specified on
\pagref{EXPLICIT-SUBEXPRESSION-RECOGNITION-DEFINITIONS-1}
and
\pagref{EXPLICIT-SUBEXPRESSION-RECOGNITION-DEFINITIONS-2}.

\begin{figure*}[!p]
\emkey{quoted-name-component} ::=
    {\em word} $|$ {\em mark} $|$ {\em separator} $|$ {\em natural-number}
\\[0.5ex]
\emkey{quoted-name} ::=
    {\tt "}{\em quoted-name-component}
           {\em quoted-name-component}\,$^\star${\tt "}
\\[2ex]
\emkey{simple-name-component} ::= {\em word} $|$ {\em natural-number}
\\[0.5ex]
\emkey{simple-name} ::= {\em simple-name-component}
                        {\em simple-name-component}\,$^\star$
\\[2ex]
\emkey{parsing-selectors} ::= {\em empty}
			     $|$ \verb|[| {\em parsing-selector-list} \verb|]|
\label{PARSING-SELECTORS}
\\[0.5ex]
\emkey{parsing-selector-list} ::= {\em empty}
    $|$ {\em parsing-selector} \{ \verb|,| {\em parsing-selector} \}\,$^\star$
\\[0.5ex]
\emkey{parsing-selector} ::= {\em simple-name}
\\[2ex]
\emkey{new-parsing-selectors} \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
    ::= & \underline{\tt [} {\em parsing-selector-list} \underline{\tt ]} \\
    $|$ & \underline{\tt [} {\em parsing-selector-op} {\em parsing-selector} \\
        & \hspace*{0.3in}
          \{ \verb|,| {\em parsing-selector-op} {\em parsing-selector}
	  \}$^\star$ \underline{\tt ]}
    \end{tabular}
\label{NEW-PARSING-SELECTORS}
\\[0.5ex]
\emkey{parsing-selector-op} ::= \verb|+| $|$ \verb|-| $|$ \verb|^|
\\[2ex]
\emkey{selector-definition}
    ::= \ttikey{parser define selector}{define selector}
               {\em parsing-selector}
\\[2ex]
\emkey{bracket-definition} \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttikey{parser define}{define bracket}
	  \begin{tabular}[t]{@{}l@{}}
	  {\tt \bf bracket}
	  {\em bracket-name} {\em parsing-selectors} \\
	  {}[ {\tt with parsing selectors} {\em new-parsing-selectors} ] \\
	  {}[ {\tt with full lines} ] \\
	  {}[ {\tt with reformatter} {\em reformatter-name} ] \\
	  {}[ {\tt with evaluator} {\em evaluator-name} ] \\
	  \end{tabular} \\
    $|$ & \ttikey{parser undefine bracket}{undefine bracket}
	  {\em bracket-name} {\em parsing-selectors} \\
    \end{tabular}
\\[0.5ex]
\emkey{bracket-name} ::= {\em opening-bracket-name}
			 \ttmkey{...}{in {\em bracket-name}}
			 {\em closing-bracket-name}
\label{BRACKET-NAME}
\\[0.5ex]
\emkey{opening-bracket-name} ::= {\em quoted-name}
\\[0.5ex]
\emkey{closing-bracket-name} ::= {\em quoted-name}
\\[0.5ex]
\emkey{reformatter-name} ::= {\em simple-name}
\\[0.5ex]
\emkey{evaluator-name} ::= {\em simple-name}

\label{EXPLICIT-SUBEXPRESSION-RECOGNITION-DEFINITIONS-1}
\end{figure*}

\begin{figure*}[!t]
\emkey{indentation-mark-definition} \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttikey{parser define}{define indentation mark}
	  \begin{tabular}[t]{@{}l@{}}
	  {\tt \bf indentation mark}
	  {\em indentation-name} {\em parsing-selectors} \\
	  {}[ {\tt with parsing selectors} {\em new-parsing-selectors} ] \\
	  {}[ {\tt with reformatter} {\em reformatter-name} ] \\
	  {}[ {\tt with evaluator} {\em evaluator-name} ] \\
	  \end{tabular} \\
    $|$ & \ttikey{parser define}{define gluing indentation mark}
	  \begin{tabular}[t]{@{}l@{}}
	  {\tt \bf gluing indentation mark} \\
	  \hspace*{5em} {\em gluing-indentation-name} {\em parsing-selectors} \\
	  {}[ {\tt with parsing selectors} {\em new-parsing-selectors} ] \\
	  {}[ {\tt with reformatter} {\em reformatter-name} ] \\
	  {}[ {\tt with evaluator} {\em evaluator-name} ] \\
	  \end{tabular} \\
    $|$& \ttikey{parser undefine indentation mark}{undefine indentation mark}
	 {\em indentation-name} {\em parsing-selectors} \\
    \end{tabular}
\\[0.5ex]
\emkey{indentation-name} ::= {\em indentation-mark-name}
	[ {\tt ...} {\em indentation-separator-name} ]
\\[0.5ex]
\emkey{indentation-mark-name} ::= {\em quoted-name}
\label{INDENTATION-MARK-NAME}
\\[0.5ex]
\emkey{gluing-indentation-name} \\
    \hspace*{0.2in}~
    ::= {\em gluing-indentation-mark-name}
	[ {\tt ...} {\em indentation-separator-name} ]
\\[0.5ex]
\emkey{gluing-indentation-mark-name} ::= {\tt "}{\em mark}\,{\tt "}
\\[0.5ex]
\emkey{indentation-separator-name} ::= {\em quoted-name}
\\[2ex]
\emkey{named-bracket-definition} \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttikey{parser define}{define named bracket}
	  \begin{tabular}[t]{@{}l@{}}
	  {\tt \bf named bracket}
	  {\em named-bracket-name} {\em parsing-selectors} \\
	  {}[ {\tt with reformatter} {\em reformatter-name} ] \\
	  {}[ {\tt with evaluator} {\em evaluator-name} ] \\
	  \end{tabular} \\
    $|$ & \ttikey{parser undefine named bracket}{undefine named bracket}
	  {\em named-bracket-name}
	  {\em parsing-selectors} \\
    \end{tabular}
\\[0.5ex]
\emkey{named-bracket-name} \\
    \hspace*{0.2in}
     ::= \begin{tabular}[t]{@{}l@{}}
	 {\em named-opening} [ {\tt ...} {\em named-separator} ] \\
         {}[ {\tt ...} {\em named-middle} {\tt ...} {\em named-middle} ] \\
	 {\tt ...} {\em named-closing}
	 \end{tabular}
\\[0.5ex]
\emkey{named-opening} ::= {\em quoted-name}
\\[0.5ex]
\emkey{named-separator} ::= {\em quoted-name}
\\[0.5ex]
\emkey{named-middle} ::= {\em quoted-name}
\\[0.5ex]
\emkey{named-closing} ::= {\em quoted-name}

\label{EXPLICIT-SUBEXPRESSION-RECOGNITION-DEFINITIONS-2}
\end{figure*}

A parser definition is a top level input line by itself, and is
executed by the parser itself
after the definition is read, thus affecting subsequent parsing.

Parser definitions begin with either the word
`\ttmkey{define}{in parser definition}' or
`\ttmkey{undefine}{in parser definition}'.  This is followed
by a \key{definition type} such as `{\tt bracket}' or
`{\tt indentation mark}', and this in turn is followed
by a definition name and then {\em parsing-selectors}.
The \key{definition name} consists of `{\tt ...}' separated
{\em quoted-names} that are used as labels of symbol table entries
and therefore as keys in symbol table lookups.

A \ttmkey{define}{parser definition}
parser definition makes entries in parser symbol tables.
One entry is made for each {\em quoted-name} in the definition name.
Each entry is assigned the {\em parsing-selectors} from the parsing
definition.  The selectors determine in which contexts the definition
will be active.

If a quoted string is used in a parser definition
{\em quoted-name}, the quotes are removed
before the name is installed as a symbol table entry label.  The
purpose of the quotes is merely to prevent the name from being
recognized by the parser as a special symbol.  After the quotes
are removed, the remaining characters must be a valid single lexeme
separator, mark, word, or natural number.

An example parser definition is
\begin{center}
{\tt define bracket "("~...~")" [operator text]} \ldots
\end{center}
Here `{\tt (}' is an {\em opening-bracket-name},
`{\tt )}' is a {\em closing-bracket-name},
and `{\tt operator}' and `{\tt text}' are selectors.
`{\tt operator}' is the standard selector for programming code
and algebraic expressions, and `{\tt text}' is the standard
selector for text processing expressions.

Parser symbol tables are used to look up sequences of tokens that
match names in the tables.  During lookup the parser has a context that
contains a set of {\em parsing-selectors}.
Each {\em parsing-selector}
has its own name, which is used to denote it in parser definitions.
In order to be recognized, a symbol table entry must be active, and
to be active, it must have at least one {\em parsing-selector}
in its definition that matches a {\em parsing-selector} in the
parsing context at the time of lookup.

There can be at most 64 distinct {\em parsing-selectors} in all
the parser definitions together.\footnote{
Internally a {\em parsing-selectors} set can be represented by
a 64 bit unsigned integer with one bit per possible {\em selector}.}

When a (named or unnamed)
opening bracket or indentation mark is recognized, the current set of
parser context {\em parsing-selectors} is pushed into a stack and
a new set is computed using the {\em new-parsing-selectors}
from the definition of the bracket or indentation mark.
{\em New-parsing-selectors} can either be a list of selectors,
or a list of operations that modify the previous context selectors.
In the later case the possible operations are:
\begin{center}
\begin{tabular}{l@{\,}lp{3in}}
\ttmkey{+}{new selector operation} & {\em selector}
    & Add {\em selector} if it is not in the set.
\\[0.5ex]
\ttmkey{-}{new selector operation} & {\em selector}
    & Remove {\em selector} if it is in the set.
\\[0.5ex]
\ttmkey{\CIRCUMFLEX}{new selector operation} & {\em selector}
    & Flip {\em selector}, that is,
      add {\em selector} if it is not in the set,
      and remove {\em selector} if it is in the set.
\end{tabular}
\end{center}

An \ttmkey{undefine}{parser definition}
parser definition modifies the {\em parsing-selectors}
of any entries that would be added to symbols
tables by the corresponding {\tt define} parser definition.
If the {\tt undefine} has a given {\em selector}, that selector is removed
from all these entries.  {\tt Undefine} parser definitions
have no other effect.

The parsing symbol tables act like a stack; as new parsing
definitions are encountered, their effects are `pushed' into the
symbol tables.  This virtual stack can be popped, removing
the parser definitions in reverse order.  When a definition
is popped, its effects are removed from the symbol tables.
Both {\tt define} and {\tt undefine} parser definitions can be
removed in this way.

\subsection{The Explicit Subexpression Recognition Pass}

The explicit subexpression recognition pass recognizes:
\begin{indpar}[1.0in]
\hspace*{-0.5in}unnamed brackets (e.g.~`{\tt (}' and `{\tt )}')
    and unnamed bracketed subexpressions \\
\hspace*{-0.5in}indentation marks (e.g.~`{\tt :}')
    and separators (e.g.~`{\tt ;}'),
    indented paragraphs, and indented paragraph lines \\
\hspace*{-0.5in}named brackets (e.g.~`{\tt <b|}' and `{\tt |b>}')
      and named bracketed subexpressions \\
\hspace*{-0.5in}named operators (e.g.~`{\tt <p>}')
\end{indpar}

The syntax of the parser definitions that control explicit
subexpression recognition
is specified on
\pagref{EXPLICIT-SUBEXPRESSION-RECOGNITION-DEFINITIONS-1}
and
\pagref{EXPLICIT-SUBEXPRESSION-RECOGNITION-DEFINITIONS-2}.

Unnamed brackets, indentation marks, and indentation separators are
symbol table keys.  However named brackets and operators are
not.  Instead, a named bracket or operator is formed by using
named openings (e.g.~`{\tt <}'),
named separators (e.g.~`{\tt \#}'),
named middles (e.g.~`{\tt |}'),
and named closings (e.g.~`{\tt >}'), which are all symbol table
keys, to surround or separate
sequences of words, numbers, quoted strings, and unnamed
bracketed subexpressions, and thence form named brackets
and named operators.

In explicit subexpression recognition, 
multi-lexeme symbol table keys are not recognized in the
input if their lexemes are not all on the same line.
This is different from other parser passes, which are executed
after line breaks have been removed.

Also, all explicit subexpression recognition symbol table
keys consist of only marks and separators, and have no
words or natural numbers.

The output of the parser is one {\tt EXPRESSION} token per
top level line.  The value of an {\tt EXPRESSION} token is
a MIN object that is called an \key{expression}.
Expressions are a list of
\skey{expression component}s plus values for some additional attributes,
such as the {\tt .initiator} attribute.  An expression component is
a MIN string equal to the translation string of a word, separator,
mark, or natural number, or is a (sub)expression (i.e., MIN object).
Quoted string lexemes are converted to expressions whose only list element
is a MIN string equal to the translation string of the quoted string
lexeme, and whose {\tt .initiator} attribute is equal to {\tt "}.
Non-natural number lexemes are converted similarly but their
{\tt .initiator} is {\tt \#}.

\subsubsection{Unnamed Bracketed Subexpressions}

An \key{unnamed bracketed subexpression}
\index{bracketed subexpression!unnamed}
begins with
an {\em opening-bracket-name} and ends with a matched
{\em closing-bracket-name} as defined by a \ttkey{define bracket}
parser definition.  An example of such a definition is
\begin{center}
{\tt define bracket "("~...~")" [operator text]} \ldots
\end{center}
which specifies `{\tt (}' to be an {\em opening-bracket-name}
with `{\tt )}' as its corresponding {\em closing-bracket-name}
and `{\tt operator}' and `{\tt text}' as the definition selectors.

An unnamed bracketed subexpression is converted to a
MIN object whose list elements are the components of the
subexpression except for the brackets.  The
{\em opening-bracket-name} becomes the {\tt .initiator}
attribute of this object, and the {\em closing-bracket-name}
becomes the {\tt .terminator} attribute of the object.

The {\em opening-bracket-name} and {\em closing-bracket-name} may be
any sequence of marks and separators.

If an unnamed bracketed subexpression ends pre-maturely, before
its {\em closing-bracket-name} is discovered, a parsing error is
announced and the {\em closing-bracket-name} is inserted in the input
just after the pre-maturely ended subexpression.  Such a pre-mature end can be
discovered by finding the {\em closing-bracket-name} of a containing
unnamed bracketed subexpression, the {\em named-closing-bracket}
of a containing named bracketed subexpression, the end of the paragraph line
containing the unnamed bracketed subexpression,
or an end of file.

\subsubsection{Indented Paragraph Subexpressions}

An \key{indented paragraph subexpression}
begins with an {\em indentation-mark-name} which must be at the end of
a line.  This is followed an \key{indented paragraph}
consisting of zero or more \skey{paragraph line}s,
each beginning at the same indentation which
is called the \key{paragraph indentation}.  The paragraph indentation
is defined as the indentation of the first paragraph line of the paragraph.
A paragraph line may have a continuation lines that are indented with
respect to the paragraph indentation.

The following is an example using `{\tt :}' as an {\em indentation-mark-name}:
\begin{indpar}\begin{verbatim}
the line before the outer paragraph
this is an outer paragraph:
    the first line of the outer paragraph
    the second line of the outer paragraph
    an inner paragraph:
        the first line of the inner paragraph
        the second line of the inner paragraph
    the first outer paragraph line after the inner paragraph
    another inner paragraph, but one with zero lines:
    the last line of the outer paragraph
the line after the outer paragraph
\end{verbatim}\end{indpar}


An {\em indentation-mark-name} is specified by a
\ttkey{define indentation mark} or
\ttkey{define gluing indentation mark}
parser definition, and may have
an associated {\em indentation-separator-name} supplied by that definition.
An example is
\begin{center}
{\tt define gluing indentation mark ":"~...~";" [operator]} \ldots
\end{center}
which specifies `{\tt :}' to be a {\em gluing-indentation-mark-name}
with `{\tt ;}' as its corresponding {\em indentation-separator-name}
and `{\tt operator}' as the sole definition selector.

The {\em indentation-separator-name} may be used to separator
paragraph lines, as long as it is outside subexpressions
(unnamed bracketed, named bracketed, or indented subparagraph)
in the paragraph.

Each paragraph line is converted to a MIN object whose elements are
the components of the line, treated as subexpression components, except for
any {\em indentation-separator-name} that ends the line.  This
object is given a {\tt .terminator} attribute value
equal to the line ending {\em indentation-separator-name} if this exists, or
equal to {\tt "<NL>"}
if there is no line ending {\em indentation-separator-name}.

However, an empty paragraph line with no ending
{\em indentation-separator-name} is ignored as if it did not exist.

The paragraph as a whole is converted to a MIN object whose elements
are the paragraph lines, and whose {\tt .initiator} attribute
is the {\em indentation-mark-name} that introduced the paragraph.
A paragraph may be empty (have no paragraph lines).

The {\em indentation-mark-name} and {\em indentation-separator-name}
may be any sequence of marks and separators.

An {\em gluing-indentation-mark-name} is a single mark may be glued
to a preceding mark at the end of its line.  For example, `{\tt :}'
may be glued to `{\tt =}' to make `{\tt =:}'.

After an indentation mark is split from a previous mark at the end of
a line, previous tokens are checked to see if they contain
the label of a symbol table entry used by the explicit subexpression
parser.  More explicitly, any sequence of marks and separators at the
end of the line is re-parsed, excluding any mark or separator that was
part of or before a previously recognized symbol table entry.

An anomaly may exist if the selectors that allowed a gluing indentation mark to
be recognized are changed by a closing bracket that is glued to the indentation
mark so the indentation mark is no longer recognized.
The indentation mark will be split, the closing bracket will be recognized
on rescan
and change the selectors so the indentation mark is no longer
recognizable, and then the indentation mark will be scanned and not recognized.
This situation can be avoided by not allowing
brackets to change selectors to enable gluing indentation marks if the
closing bracket ends with a mark.

No differences exist between {\em gluing-indentation-mark-names} and
{\em indentation-\EOL mark-\EOL names}
other than that the former can be
glued to a preceeding mark and that the former must be a single mark
lexeme, while the latter can be any sequence of marks and separators.

If while parsing an indented paragraph a line is encountered whose
indentation is different from the paragraph indentation,
but the difference is less than $N$ columns (default $N=2$),
an error is announced.
No corrective action is taken; the line is accepted as either ending
the paragraph if its indentation is less than the paragraph
indentation, or continuing the current paragraph line if its indentation
is greater than the paragraph indentation.  Here $N$ is called the
\key{parser indent offset}, and is a parser parameter.

\ikey{Top level parsing}{top level parsing}
of a file recognizes paragraph lines as if the whole
file were a paragraph, and forms each line into a MIN object.  However,
these are \underline{not} combined into a paragraph MIN object, but
are instead processed as they are produced.  In particular, if they
are parser definitions, they are processed by the parser to make
modifications in the parser symbol tables.  Also, the initial
\key{top level paragraph indent}
is set to zero, and an error is announced if the first non-comment,
non-line-break, non-end-of-file
lexeme in the file has non-zero indent.

Comments are ignored when determining line indentation, but may
cause errors to be announced.  A comment is considered to be in error
if it appears on a line by itself and is less indented than the first
following non-comment non-blank line.
Comments at the beginning or end of a file cannot be
in error.

\subsubsection{Named Bracketed Subexpressions}
\label{NAMED-BRACKETED-SUBEXPRESSIONS}

An \key{named bracket subexpression}
\index{bracketed subexpression!named}
begins with an {\em opening-named-bracket} and ends with
a {\em closing-named-bracket}.  These have the syntax:

\begin{indpar}[0.1in]
\emkey{opening-named-bracket} ::= \\
    \hspace*{0.4in}\begin{tabular}[t]{@{}l@{}}
	 {\em named-opening} {\em bracket-name} {\em argument}$^\star$
	      \{ {\em named-separator} {\em key} \}$^\star$
	      {\em named-middle} \\
	 \end{tabular}
\\[0.5ex]
\emkey{named-opening} ::= {\em quoted-name}
\\[0.5ex]
\emkey{bracket-name} ::= {\em word}
                         \{ {\em word} $|$ {\em natural-number} \}$^\star$
\\[0.5ex]
\emkey{argument} ::= {\em unnamed-bracketed-subexpression}
                 $|$ {\em quoted-string}
                 $|$ {\em non-natural-number}
\\[0.5ex]
\emkey{named-separator} ::= {\em quoted-name}
\\[0.5ex]
\emkey{key} ::= {\em key-component} {\em key-component}$^\star$
\\[0.5ex]
\emkey{key-component} ::= {\em word} $|$ {\em number} $|$ {\em quoted-string}
\\[0.5ex]
\emkey{named-middle} ::= {\em quoted-name}
\\[0.5ex]
\emkey{closing-named-bracket} ::= \\
	\hspace*{0.4in}\begin{tabular}[t]{@{}rl@{}}
	    & {\em named-middle} {\em bracket-name-initial-segment}
	                         {\em named-closing} \\
	$|$ & {\em named-middle} {\em named-closing}
	\end{tabular}
\\[0.5ex]
\emkey{named-closing} ::= {\em quoted-name}
\\[0.5ex]
\emkey{bracket-name-initial-segment}~~
	\begin{tabular}[t]{@{}rl@{}}
        ::= & {\em empty } \\
	$|$ & {\em word} \{ {\em word} $|$ {\em natural-number} \}$^\star$
	\end{tabular}
\end{indpar}

If the {\em named-opening}, {\em named-separator}, {\em named-middle},
and {\em named-closing} are respectively `{\tt <}', `{\tt \#}',
`{\tt |}', and `{\tt >}', then an example named bracketed subexpression is
\begin{center}
{\tt <h1(2) \# Diamond Lemma|} ~~~\ldots~~~ {\tt |h>}
\end{center}

Here the {\em named-opening-bracket} contains the {\em bracket-name}
`{\tt h1}' (note `{\tt h}' and `{\tt 1}' are separate lexemes),
the {\em argument} `{\tt (2)}', and the {\em key} `{\tt Diamond Lemma}',
while the {\em named-closing-bracket} just contains an initial
segment of the {\em bracket-name}.   The initial name segment
in the {\em named-closing-bracket} may be empty, so
{\tt |>}, {\tt |h>}, or {\tt |h1>} could all be used as closing
brackets in the above example.

The {\em named-opening}, {\em named-separator}, {\em named-middle},
and {\em named-closing} are symbol table keys
from which named opening and closing
brackets are constructed.  They are specified by a
\ttkey{defined named bracket} parser definition, an example of
which is:
\begin{center}
{\tt define named bracket "<"~...~"\#"~...~"|"~...~"|"~...~">" [text]} \ldots
\end{center}
which specifies `{\tt <}' to be a {\em named-opening-name},
`{\tt \#}' to be a {\em named-separator-name},
`{\tt |}' to be a {\em named-middle-name},
`{\tt >}' to be a {\em named-closing-name},
and `{\tt text}' to be the sole definition selector.
Recall that symbol table keys may not span multiple lines, but
{\em named-opening-brackets},
{\em named-closing-brackets},
and {\em named-operators} may span multiple lines.



A named bracketed subexpression is converted to a
MIN object whose list elements are the components of the
subexpression except for the brackets.  The
{\em named-opening} becomes the {\tt .initiator}
attribute of this object, the {\em named-middle} becomes
the {\tt .middle} attribute of this object,
the {\em named-closing} becomes the {\tt .terminator} attribute
of the object, the {\em bracket-name} (from the {\em named-opening-bracket})
becomes the
{\tt .name} attribute of the object, the {\em arguments}
become the {\tt .arguments} attribute of the object,
and the {\tt keys} become the {\tt .keys} attribute of the object.
The {\tt .arguments} attribute value is itself a MIN object
whose list elements are the argument subexpressions formatted
in the same way as they would be if they were ordinary
subexpression components.
The {\tt .keys} attribute is a MIN object whose list elements
are the individual {\em keys}, and whose {\tt .initiator} and 
{\tt .separator} attributes are both the {\em named-separator}.
Every value inside the subexpression object attributes
that is not a MIN object and not part of an {\em argument}
is a MIN string or a MIN label with 2 or more
elements that are MIN strings.
If there are no {\em arguments}, the {\tt .arguments} attribute
is not set, and similarly if there are no {\em keys}, the {\tt .keys}
attribute is not set.

In particular, quoted strings and numbers in {\em keys} are converted to
MIN strings whose values equal the translation strings of the
quoted string or number lexemes.  Thus the keys
`{\tt lemma "5.1.1"}' and `{\tt lemma 5.1.1}' become identical
when stored in the {\tt .keys} attribute of the parser result.

The {\em named-opening}, {\em named-separator}, {\em named-middle},
and {\em named-closing} may each be any sequence of marks and separators.
If the {\em named-middle} ends in a mark and the {\em named-closing}
begins with a mark, these may be glued together to make a
{\em named-closing-bracket} with empty {\em bracket-name}.  Thus
in our example the single mark `{\tt |>}' may be used in place of
the two separate marks `{\tt | >}'.

If a named bracketed subexpression ends pre-maturely, before
its {\em named-closing-bracket} is discovered, a parsing error is
announced and the {\em named-closing-bracket} is inserted in the input
just after the pre-maturely ended subexpression.  Such a pre-mature end can be
discovered by finding the {\em closing-bracket-name} of a containing
unnamed bracketed subexpression, the {\em named-closing-bracket}
of a containing named bracketed subexpression, the end of the paragraph line
containing the named bracketed subexpression,
or an end of file.

\subsubsection{Named Operators}

A \key{named operator} has the same syntax as an {\em opening-named-bracket}
except that the {\em named-operator} ends with a
{\em named-closing} instead of a {\em named-middle}:

\begin{indpar}[0.1in]
\emkey{named-operator} \\
    \hspace*{0.2in}::= \begin{tabular}[t]{@{}l@{}}
	 {\em named-opening} {\em operator-name} {\em argument}$^\star$
	      \{ {\em named-separator} {\em key} \}$^\star$
	      {\em named-closing} \\
	 \end{tabular}
\\[0.5ex]
\emkey{operator-name} ::= {\em word}
                         \{ {\em word} $|$ {\em natural-number} \}$^\star$
\end{indpar}

A {\em named-operator} is converted to a MIN object which has the
same structure as a named bracketed subexpression with an empty list
but with its {\tt .name} attribute equal to
the {\em operator-name} instead of a {\em bracket-name} and with
no {\tt .middle} attribute.  As for a named bracketed subexpression,
the {\tt .initiator} is the {\em named-opening},
the {\tt .terminator} is the {\em named-closing},
and the {\tt .arguments} and {\tt .keys} are set from the
contents of the {\em named-operator} just as they would be from the
contents of a {\em named-opening-bracket}.

\subsection{Parser Passes}

After a subexpression has been identified by the top level explicit
subexpression recognition pass, a sequence of passes are run on the
subexpression.  Which passes are run is determined by the the
parser pass stack.

The \key{parser pass stack} is a list of parsers with a set of
selectors associated with each parser.  After the top level pass
recognizes a subexpression, the active parsers in the parser pass stack
are run in the order that they appear in the stack.

The parsing selectors
computed by the opening bracket of the explicit subexpression, which
are used to scan the explicit subexpression, are also attached to that
explicit subexpression.
These are used to determine activity of the parser passes run on the explicit
subexpression and also the activity
of the parser definitions (i.e., parser symbol table entries)
used by these parser passes.
Note that only the explicit brackets surrounding an explicit subexpression
can change the parsing selectors in the parser context; the operators
that bound implicit subexpressions cannot change these parsing selectors.

The parser pass stack can be altered
by the following parser definitions:

\begin{indpar}
\emkey{parser-pass-definition} \\
    \begin{tabular}[t]{rl}
    ::= & \ttikey{define}{define parser pass}
	  \begin{tabular}[t]{@{}l@{}}
	  {\tt \bf parser pass}
	  {\em parser-pass-name} {\em parsing-selectors} \\
	  {\tt after} {\em previous-parser-pass-name}
	  \end{tabular} \\
    $|$ & \ttkey{undefine parser pass}
	  {\em parser-pass-name} {\em parsing-selectors} \\
    \end{tabular}
\\[0.5ex]
\emkey{parser-pass-name}
    ::= {\em word} \{ {\em word} $|$ {\em natural-number} \}$^\star$
\\[0.5ex]
\emkey{previous-parser-pass-name} ::= {\em pass-name}
\end{indpar}

The {\tt define parser pass} statement sets the parser pass
{\em parsing-selectors}
and installs the parser pass in the parser pass stack after the
parser pass already in that stack which has the name
{\em previous-parser-pass-name}.  If the parser pass was already
in the stack, it is removed first and reinstalled.

The {\tt undefine parser pass} statement removes the given
{\em parsing-selectors} from the parser pass if that is in the
parsing pass stack.

The set of passes that may be run is currently builtin, and
cannot be changed.  The following are permitted {\em parser-pass-names}:

\begin{indpar}
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
top & This refers to an imaginary pass at the top of the parser pass stack,
      and can only be used as a {\em previous-parser-pass-name} to place
      a pass at the top of the stack.
\\[1ex]
operator & Parses expressions with computational operators (e.g., \verb|+| and
\verb|*|).
\\[1ex]
lexeme replacement & Replaces sequences of lexemes with other
sequences of lexemes (e.g., replaces plurals by singulars).
\end{tabular} \\
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
radix number recognition & Recognizes numbers with non-decimal radixes.
\\[1ex]
scientific number recognition & Recognizes numbers with exponents.
\\[1ex]
number pair recognition & Recognizes pairs of numbers (e.g., \verb|4 1/2|).
\end{tabular} \\
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
number unit grouping & Groups numbers and numeric units
(e.g., \verb|4ft 5in|).
\\[1ex]
\begin{tabular}[t]{@{}l@{}}
unit multiplication \\
insertion 
\end{tabular} & Inserts multipliers between numbers and
numeric units (e.g., \verb|4*ft| and \verb|$*4.99|).
\end{tabular}
\end{indpar}


The input and output of a parser pass is a sublist of the list
of all tokens.  When a parser pass is called, it is provided with
a pointer to the first token of this sublist, and a pointer to the
first token after the sublist.  The pass may edit the sublist.

The explicit subexpression recognition pass calls the other passes,
in the order they appear in the parser pass stack, excluding any
that are inactive because they have no selector in common with
the current parser context selectors.  After the last pass has been
called, the explicit subexpression recognition pass replaces the
final sublist, which is the subexpression that has been recognized,
by an EXPRESSION token with a MIN object value, as described above.

\subsection{The Operator Parsing Pass}
\label{OPERATOR-PARSING-PASS}

The \key{operator parsing pass} is an expression parser pass that uses
operators to restructure expressions.  Operators
are defined by operator definitions that can be added to the
parsing definition stack.  List separators, such as `\verb|,|', are treated
as operators, and have operator definitions.

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITION}

An \key{operator definition} specifies for each operator the following:

\begin{indpar}[1in]
Name and Selectors \\
Precedence \\
Operator Flags \\
Reformatter \\
Evaluator
\end{indpar}

The syntax of operator definitions is:

\begin{indpar}
\emkey{operator-definition} \\
	\hspace*{0.5in}::= \ttkey{parser define operator}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em operator-name} {\em parsing-selectors} \\
	    {\em operator-flag} {\em operator-flag}\,$^\star$ \\
	    \verb|with precedence| {\em precedence} \\
	    {}[ \verb|with reformatter| {\em reformatter-name} ] \\
	    \end{tabular}
	    \\[1ex]
\emkey{operator-name} \begin{tabular}[t]{rl}
		    ::= & {\em simple-operator-name} \\
		    $|$ & \verb|bracket| {\em bracket-name} \\
		    $|$ & \verb|indentation mark| {\em indentation-mark-name}
		    \end{tabular}
		    \\[1ex]
{\em simple-operator-name} ::= {\em quoted-name} \\[1ex]
{\em bracket-name} ::= see \pagref{BRACKET-NAME} \\[1ex]
{\em indentation-mark-name} ::= see \pagref{INDENTATION-MARK-NAME} \\[1ex]
\emkey{operator-flag} ::= \ttmkey{prefix}{operator flag}
                    $|$ \ttmkey{infix}{operator flag}
                    $|$ \ttmkey{postfix}{operator flag}
                    $|$ \ttmkey{nofix}{operator flag}
                    $|$ \ttmkey{afix}{operator flag}
	\\[1ex]
\emkey{precedence} ::= {\em sign-option} {\em natural-number}
	\\[1ex]
\emkey{sign-option} ::= {\em empty} $|$ \verb|+| $|$ \verb|-|
	\\[1ex]
\emkey{reformatter-name} ::= {\em simple-name }
\end{indpar}

A {\em simple-operator-name} is matched to lexemes in a subexpression
in order to identify occurrences of the operator.
The other forms of {\em operator-name} permit explicit subexpressions
with particular kinds of brackets to be parsed as if they were operators.
Thus in `\verb|x[5]=0|' the explicit subexpression
`\verb|[5]|' can be a postfix operator.  A subexpression
bracketed by `\verb|{ }|' is used as an afix (see below) to the
\verb|<--| operator (as is a subexpression introduced by the `\verb|:|'
indentation mark).

By abuse of language, the term `\key{operator}' is often used
as a synonym for `{\em simple-operator-name}'.

Operators can have \skey{operator flag}s that
affect parsing of subexpressions of the operator.  The possible
flags are `{\tt infix}', `{\tt prefix}', `{\tt postfix}',
`{\tt nofix}', and `{\tt afix}'.  By default an operator is `{\tt nofix}'.

An \ttkey{infix} operator must be between two non-empty operands,
while a \ttkey{prefix} operator must precede a non-empty operand,
and a \ttkey{postfix} operator must follow a non-empty operand.
A prefix operator can only appear at the beginning of a subexpression and
has no preceding operand.
A postfix operator can only appear at then end of a subexpression and has
no following operand.

A \ttkey{nofix} operator is like an infix operator but may or may not be
preceded or followed by operands.  It may appear at the beginning or ending of
an expression, or two nofix operators may be consecutive in an expression.

An \ttkey{afix} operator is must follow
another operator that has the same precedence in a subexpression.
Explicit subexpressions bracketed by `\verb|{ }|'
are standard afix operators with the same precedence
as the \verb|<--| operator, so that an expression such as:
\begin{center}
\verb|sum from X through Y <-- integer X, integer Y { ... }|
\end{center}
is parse as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y) { ... }|
\end{center}
and \underline{not} as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y { ... })|
\end{center}

An\label{FIXITY-RULES}
operator must be prefix, infix, postfix, or nofix.
A prefix operator may also be infix or postfix, but may not be afix.
An infix operator may also be prefix or afix, but not postfix.
An postfix operator may also be prefix or afix, but not infix.
A nofix operator may afix, but not prefix, infix, or postfix.

This can be summarized in the following compatibility table:

\begin{center}
\begin{tabular}{|c|c|c|c|c|l}
\cline{1-5}
prefix & infix  & postfix & nofix & afix & \\
\hline
\multicolumn{1}{c|}{}
       & yes    & yes     & no    & yes   &  \multicolumn{1}{|l|}{prefix} \\
\cline{2-6}
\multicolumn{2}{c|}{}
                & no      & no    & yes   &  \multicolumn{1}{|l|}{infix} \\
\cline{3-6}
\multicolumn{3}{c|}{}
                          & no    & yes   &  \multicolumn{1}{|l|}{postfix} \\
\cline{4-6}
\multicolumn{4}{c|}{}
                                  & yes   &  \multicolumn{1}{|l|}{nofix} \\
\cline{5-6}
\end{tabular}
\end{center}

The {\em precedence} of an operator is an integer.  Precedence is used to
determine which operators are inside and outside implicit brackets.
Operators with higher precedence are placed inside the 
implicit brackets that surround operands of operators of lower precedence.
Implicit brackets are used to define subexpressions, so that all operators
in a subexpressions that are not in sub-subexpressions are of the same
precedence.

The {\em reformatter-name} in an {\em operator-definition} names a
function that is called after all other parsing has been done to
reformat a subexpression whose first operator is the defined operator.
For example, given the expression `\verb|-x+6*y|', the subexpression
`\verb|6*y|' is extracted, and as its first operator is `\verb|*|',
the reformatter for that operator is called and yields `\verb|* 6 y|'.
Similarly the subexpression `\verb|-x|' is extracted but the reformatter
for `\verb|-|' does not change it.
Then the reformatter for `\verb|+|' is called
with `\verb/(|-x|)+(|* 6 y|)/', since `\verb|+|' is the first operator in
this subexpression \underline{after} subexpressions have been handled.
This reformatter returns `\verb/+ (|-x|) (|* 6 y|)/'.  Here we have
use parentheses \verb/(|  |)/ to indicate implicit parentheses.


\subsubsection{Standard Operators}
\label{STANDARD-OPERATORS}

The standard operators are given on 
\pagref{STANDARD-OPERATOR-LIST}.

\begin{figure*}[!p]
\begin{center}
\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}

precedence & reformatter	& type	& operator	& meaning 
\\[2ex]
-1000	& \ttkey{separator}	& \tt nofix	& \ttkey{;}	& separator \\
+0000	& \ttkey{define}	& \tt nofix	& \ttnbkey{<--}	& define \\
	&			& \tt afix	& \ttkey{\LEFTBRACKET{}
							 ... \RIGHTBRACKET}
								& block \\
+1000	& \ttkey{assign}	& \tt infix	& \ttnbkey{=}	& assignment \\
     	&               	&          	& \ttnbkey{+=}	& increment \\
     	&               	&          	& \ttnbkey{-=}	& decrement \\
     	&               	&          	& \ttnbkey{*=}	& multiply by \\
     	&               	&          	& \ttnbkey{/=}	& divide by \\
+2000	& \ttkey{separator}	&		& \ttkey{,}	& separator \\
+3000	& \ttkey{logical}	& \tt nofix	& \ttkey{AND}	& logical and \\
	&			&		& \ttkey{OR}	& logical or \\
	&			&		& \ttkey{NOT}  & logical not \\
	&			&		& \ttkey{BUT}  & logical filler
								 \\
+4000 	& \ttkey{compare}	& \tt infix	& \ttnbkey{==}	& equal \\
	&			&		& \ttnbkey{/=}  & not equal \\
	&			&		& \ttnbkey{!=}	& ditto \\
	&		      	&		& \ttnbkey{<}	& less than \\
	&			&		& \ttnbkey{<=}	& less than or
								  equal \\
	&			&		& \ttnbkey{=<}	& ditto \\
	&		      	&		& \ttnbkey{>}	& greater than
									\\
	&			&		& \ttnbkey{>=}	& greater than
								  or equal \\
	&			&		& \ttnbkey{=>}	& ditto \\
+5000	& \ttkey{sum}		& \tt infix	&  \ttnbkey{+}	& addition \\
	&			&		& \ttnbkey{-}	& subtraction \\
+5100	& \ttkey{product}	& \tt infix	& \ttnbkey{/}	& division \\
+5200	& \ttkey{product}	& \tt infix	& \ttnbkey{*}
							& multiplication \\
+5300	& \ttkey{product}	& \tt infix	& \ttnbkey{\CIRCUMFLEX}
							& exponentiation \\
none	& none			& \tt prefix	&  \ttnbkey{-}	& minus \\
	& 			& \tt prefix	&  \ttnbkey{+}	& plus \\
	& 			& \tt prefix	&  \ttnbkey{@}	& object
	                                                          identifier \\
none	& \ttkey{subscript}	& \tt postfix	&  \ttnbkey{[...]}
								& subscript \\
\end{tabular}
\end{center}
\label{STANDARD-OPERATOR-LIST}
\end{figure*}


Below be describe the effects of standard operator reformatters.
We use notation such as

\hspace*{2em}\begin{tabular}{lcl}
\verb|x = y = z + w| & $\Longrightarrow$ & \verb|= x ( = y (+ x w))| \\
\verb|x AND AND y| & $\Longrightarrow$ & error
\end{tabular}

Here $\Longrightarrow$ means `is reformatted as'.  Furthermore, the
parentheses introduced by the rewrite are \underline{implied},
which means that the lists they bracket have \underline{no}
\verb|.initiator| or \verb|.terminator|, and the parentheses are
merely written here to indicate sublists in the expression structure.

Reformatters can detect parsing errors, such the missing operand
in `\verb|x AND AND y|'.

Sometimes \ikey{temporaries}{temporary}\label{TEMPORARY}
are introduced by reformatting.  The syntax involving temporaries is:

\begin{indpar}
\emkey{temporary-definition} ::= {\em temporary} {\em subexpression} \\[1ex]
\emkey{temporary} ::= \verb|$| {\em natural-number}
\end{indpar}

During reformatting, a subexpression may be replaced by
a {\em temporary-definition} containing the subexpression.  This
defines the {\em temporary} as a name for the value of the subexpression.
Then the {\em temporary} can be used in the reformatted
expression to refer to this value.  An example is

\begin{center}
\verb|x == y + 3 == z| ~~~ $\Longrightarrow$ ~~~
\verb|AND (== x ($ 563 (+ y 3))) (== ($ 563) z)|
\end{center}

Here the temporary has been used to avoid computing \verb|y + 3|
more than once.

The {\em decimal-naturals} in {\em temporaries} must be assigned so no
two {\em temporary-definitions} ever have the same {\em temporary}.

With these things in mind, the reformatters are:

\begin{indpar}[1em]

\newcommand{\OP}[1]{\ttmkey{#1}{reformatting}}
\newcommand{\NBOP}[1]{\ttmnbkey{#1}{reformatting}}

\bigskip

\ttmkey{separator}{reformatter} \hfill \OP{;} ~~~ \OP{,}

\begin{indpar}[0.5em]
Here `\verb|;|' or `\verb|,|' is the \key{separator}.  These have different
precedences, and so cannot appear together in the same expression.

A list of all between-separator subexpressions is made, with empty
between-separator subexpressions being represented by empty lists.
There will be at least two subexpressions: one following
the last separator and one preceding the first separator.
The list of subexpressions is given a
\ttmkey{.separator}{produced by parsing}
attribute with value of the separator (\verb|";"| or \verb|","|),
and is returned as the result of the reformatting.

The standard bracket reformatters will merge the returned list with
their brackets.  Thus given `\verb|(x,y)|', the `\verb|separator|'
reformatter will return
\begin{indpar}\begin{verbatim}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
so the input to the \verb|( )| reformatter will be
\begin{indpar}\begin{verbatim}
@2 = @1 {| .initiator = "("; .terminator = ")" |}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
and this reformatter will merge the two lists into one,
returning
\begin{indpar}\begin{verbatim}
@3 = x y :|
    .initiator = "("
    .terminator = ")"
    .separator = ","
\end{verbatim}\end{indpar}

\end{indpar}

\bigskip

\ttmkey{define}{reformatter} \hfill \NBOP{<--} ~~~
	\NBOP{\LEFTBRACKET \RIGHTBRACKET} ~~~ \OP{:}

\begin{indpar}[0.5em]

There will be a \verb|<--| operator (the other operators are afix),
and it is a parsing error
detected by the reformatter if there is more than one.
The one \verb|<--| operator is moved to the front of the expression:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x <-- y { z }| & $\Longrightarrow$ & \verb|<-- x y { z }| \\
\verb|x <-- { z }| & $\Longrightarrow$ & \verb|<-- x { z }| \\
\verb|x <--| & $\Longrightarrow$ & \verb|<-- x|
\end{tabular}

Indented subexpressions introduced by the \verb|:| indentation
mark are parsed like final \verb|{ }|
bracketed subexpressions.  Because they are afix operators with the
same precedence as \verb|<--|,
`\verb|x <-- y { z }|' does \underline{not}
end up as `\verb|<-- x ( y { z } )|', and instead we get results like:

\hspace*{2em}\begin{tabular}{lcl}

\verb|x <-- u v w { z }| & $\Longrightarrow$ & \verb|<-- x ( u v w ) { z }|
\\[1ex]
\begin{tabular}{@{}l@{}}
\verb|x <-- u v w:| \\
\verb|    z|
\end{tabular}
& $\Longrightarrow$ &
\begin{tabular}{@{}l@{}}
\verb|<-- x ( u v w ):| \\
\verb|    z|
\end{tabular}

\end{tabular}


\end{indpar}

\bigskip


\ttmkey{assign}{reformatter} \hfill \NBOP{=} ~~~ \NBOP{+=} ~~~ \NBOP{-=}
				           ~~~ \NBOP{*=} ~~~ \NBOP{/=}

\begin{indpar}[0.5em]
If there is only one operator, it is simply moved to the front.  If there
are several, they are rewritten as one operator subexpressions so the
rightmost executes first.

\hspace*{2em}\begin{tabular}{lcl}
\verb|y = z| & $\Longrightarrow$ & \verb|= y z| \\
\verb|x = y = z| & $\Longrightarrow$ & \verb|= x (= y z)| \\
\verb|x += y *= z| & $\Longrightarrow$ & \verb|+= x (*= y z)|
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{logical}{reformatter} \hfill \NBOP{AND} ~~~ \NBOP{OR} ~~~ \NBOP{NOT}
							      ~~~ \NBOP{BUT}

\begin{indpar}[0.5em]
If there is only one operator and it is at the beginning of the expression,
then the expression is not changed.  It is a reformatter detected parsing
error if this operator is \verb|BUT|, or if the operator is \verb|NOT|
and there are zero or more than one operand.

Otherwise if the expression has only \verb|AND| or only \verb|OR| operators
the expression is rewritten with the operator at the beginning.  It is
a reformatter detected error if there are missing operands, either between
operators, before the first operator, or after the last operator.  Thus:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x AND y| & $\Longrightarrow$ & \verb|AND x y| \\
\verb|x AND y AND z| & $\Longrightarrow$ & \verb|AND x y z| \\
\verb|x OR y| & $\Longrightarrow$ & \verb|OR x y| \\
\verb|x OR y OR z| & $\Longrightarrow$ & \verb|OR x y z| \\
\verb|AND y AND z| & $\Longrightarrow$ & error \\
\verb|x AND AND z| & $\Longrightarrow$ & error \\
\verb|x AND y AND| & $\Longrightarrow$ & error \\
\end{tabular}

Otherwise the expression must have the operator sequence `\ttnbkey{BUT NOT}'
and one of the forms:

\hspace*{2em}\begin{tabular}{l}
$e_1$ \verb|BUT NOT| $e_3$ \\
$e_1$ \verb|BUT NOT| $e_3$ \verb|OR| $e_4$ \verb|OR| \ldots{} \\
$e_1$ \verb|AND| $e_2$ \verb|AND| \ldots{} \verb|BUT NOT| $e_3$ \\
$e_1$ \verb|AND| $e_2$ \verb|AND| \ldots{} \verb|BUT NOT|
$e_3$ \verb|OR| $e_4$ \verb|OR| \ldots{} \\
\end{tabular}

There can be \verb|AND|'s before the \verb|BUT NOT| and \verb|OR|'s after
the \verb|BUT NOT|,
but there must be at least one operand before the \verb|BUT NOT|
and at least one after.  These expressions are rewritten using prefix
\verb|AND| and \verb|NOT| operators:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x BUT NOT v| & $\Longrightarrow$ & \verb|AND x (NOT v)| \\
\verb|x AND y BUT NOT v| & $\Longrightarrow$ & \verb|AND x y (NOT v)| \\
\verb|x BUT NOT v OR w| & $\Longrightarrow$ & \verb|AND x (NOT v) (NOT w)| \\
\verb|x AND y BUT NOT v OR w|
    & $\Longrightarrow$ & \verb|AND x y (NOT v) (NOT w)| \\
\end{tabular}

All other forms of expression are reformatter detected parsing errors.

Note that {\tt NOT} is not a classical prefix operator, which would have
higher priority than \verb|=| or \verb|<|.  Also note that {\tt AND}
and {\tt OR} may not be used in the same logical expression without using
explicit brackets, unless there is a {\tt BUT NOT}.  Thus:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x AND y OR z| & $\Longrightarrow$ & error \\
\verb|x AND NOT y| & $\Longrightarrow$ & error \\
\verb|x AND NOT v OR w| & $\Longrightarrow$ & error \\
\verb|NOT x < y| & $\Longrightarrow$ & \verb|NOT (x < y )| \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{compare}{reformatter} \hfill
	\NBOP{=} ~~~ \NBOP{<} ~~~ \NBOP{>} ~~~
	\NBOP{/=} ~~~ \NBOP{!=} ~~~
	\NBOP{=>} ~~~ \NBOP{>=} ~~~
	\NBOP{=<} ~~~ \NBOP{<=}

\begin{indpar}[0.5em]
The expression is rewritten using a multi-argument {\tt AND}
function and two-argument compare functions.  Temporaries
(\pagref{TEMPORARY})
are used to name intermediate expression values to
avoid recomputing arguments.

\hspace*{2em}\begin{tabular}{lcl}
\verb|x < y < z| & $\Longrightarrow$ &
    \verb|AND (< x ($ 56 y)) (< ($ 56) z))| \\[1ex]
\verb|w == x != y <= z| & $\Longrightarrow$
             & \begin{tabular}[t]{@{}l@{~}l@{}}
	       \verb|AND| & \verb|(== w ($ 57 x))| \\
			  & \verb|(!= ($ 57) ($ 58 y))| \\
			  & \verb|(<= ($ 58) z)| \\
	       \end{tabular}
\end{tabular}

Note that sequences of comparison operators are treated as they are
in mathematics and not as they are in classical programming languages.
E.g., \verb|x<y<z| means \verb|x<y AND y<z| and \underline{not}
\verb|(x<y)<z|.
\end{indpar}

\bigskip

\ttmkey{sum}{reformatter} \hfill \NBOP{+} ~~~ \NBOP{-}

\begin{indpar}[0.5em]
The results are rewritten using the multi-argument summation function \verb|+|
and the unary negation function \verb|-|.

\hspace*{2em}\begin{tabular}{lcl}
\verb|x - y + z - w| & $\Longrightarrow$ & \verb|+ x (- y) z (- w)|
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{product}{reformatter} \hfill \NBOP{/} ~~~ \NBOP{*}
					      ~~~ \NBOP{\CIRCUMFLEX}

\begin{indpar}[0.5em]
These different operators, \verb|/|, \verb|*|, and \verb|^|,
have different precedences and therefore
cannot be mixed in the same expression.  There may not be more than one
\verb|/| or \verb|^| operator in the expression.
The results are rewritten using
the multi-argument multiplication function \verb|*|,
the binary division function \verb|/|, 
or the binary exponentiation function \verb|^|. 
E.g.:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x * y * z| & $\Longrightarrow$ & \verb|* x y z| \\
\verb|x / y| & $\Longrightarrow$ & \verb|/ x y| \\
\verb|x ^ y| & $\Longrightarrow$ & \verb|^ x y| \\
\verb|x / y / z| & $\Longrightarrow$ & error \\
\verb|x ^ y ^ z| & $\Longrightarrow$ & error \\
\end{tabular}

\end{indpar}

\bigskip

\ttmkey{subscript}{reformatter} \hfill \NBOP{[~...~]}

\begin{indpar}[0.5em]
The expression is rewritten using the binary subscript function:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x[y]| & $\Longrightarrow$ & \verb|subscript x y| \\
\end{tabular}

\end{indpar}


\end{indpar}


\subsubsection{The Operator Parsing Algorithm}
\label{OPERATOR-PARSER-ALGORITHM}


The operator parsing pass runs an
algorithm that accepts as input a sequence of tokens
which we call an `expression'
and edits this input, changing it into a single token.
To do this it performs the following steps:
\begin{itemlist}[0.7in]
\item[Step 1:] Identify subexpressions within the expression and run the
operator parsing pass on these, converting them into a single
{\tt EXPRESSION} or lexeme token.
\item[Step 2:] Identify operators within the expression and replace them
with {\tt OPERATOR} tokens.
\item[Step 3:] Run passes subsequent to the operator parsing pass on
the expression after the above has been done.
\item[Step 4:] Run the reformatter of the first operator now in the expression
on the expression.  This replaces the expression by a single token.
If no reformatter is provided by the first operator, a default
reformatter is run.  The output of the reformatter must be
a single non-{\tt OPERATOR} token.
\end{itemlist}

The token list at the point where Step 3 is about to execute
obeys the following requirements:
\begin{itemlist}[1.3in]
\item[Requirement 1:] 
All the {\tt OPERATOR} tokens in the token list are for operators
with the same precedence.  Furthermore, this precedence is lower
than the precedence of all operators in EXPRESSION tokens of the list
that have neither {\tt .initiator} nor {\tt .terminator} attributes
(i.e., are non-explicitly-bracketed subexpressions).
\item[Requirement 2:] 
The first {\tt OPERATOR} token in the list is not afix.
\item[Requirement 3:] 
Any prefix {\tt OPERATOR} token in the list is preceded by
the beginning of the expression or by another prefix {\tt OPERATOR} token.
Any prefix {\tt OPERATOR} token in the list
is followed by another prefix {\tt OPERATOR} token or by a
non-{\tt OPERATOR} token.
\item[Requirement 4:] 
All infix {\tt OPERATOR} tokens in the list are both preceded by and
followed by non-{\tt OPERATOR} tokens.
\item[Requirement 5:] 
Any postfix {\tt OPERATOR} token in the list is followed
by the end of the expression or by another postfix {\tt OPERATOR} token.
Any postfix {\tt OPERATOR} token is preceded by another
postfix {\tt OPERATOR} token or by a non-{\tt OPERATOR} token.
\end{itemlist}

A single non-{\tt OPERATOR}, non-{\tt EXPRESSION}
lexeme token output by a operator parsing pass may be
thought of as the equivalent of
a single {\tt EXPRESSION} token whose token value is the lexeme token value,
which is a MIN string,
if the lexeme is not a quoted string or non-natural number,
or the {\tt EXPRESSION} token value
is a list of one element with the element being equal to the
token value converted to a MIN string and with
an {\tt .initiator} attribute equal to {\tt "} if
the lexeme represented is a quoted string or {\tt \#} if the
lexeme represented is a non-natural number.
When a single lexeme token output from an operator parsing pass
must be converted to an
{\tt EXPRESSION} token, it is converted to this equivalent.

The operator parsing pass scans its input token list from
left to right.  At any point in the scan the pass obeys the
following rules:
\begin{itemlist}[0.7in]
\item[Rule 1:] An afix operator is not recognized unless it
is proceeded by an operator of equal precedence with no
intervening operators of less precedence.
\item[Rule 2:] A prefix operator of precedence $P'$
must be preceded by the beginning of
the entire token list, or by an operator
of precedence less than $P'$,
or by a prefix operator of precedence equal to $P'$,
else the prefix operator is not recognized.
\item[Rule 3:] An infix operator of precedence $P'$
must be preceded by a non-operator,
or by an operator of precedence greater than $P'$,
else the infix operator is not recognized.
\item[Rule 4:] A postfix operator of precedence $P'$
must be preceded by a non-operator,
or by an operator of precedence greater than $P'$,
or by a postfix operator of precedence equal to $P'$,
else the postfix operator is not recognized.
\item[Rule 5:] A recognized prefix operator of precedence $P'$
must be followed by a non-operator or by an operator
of precedence greater than $P'$,
or by a prefix operator of precedence equal to $P'$,
else an `error operand' which is not an operator
is inserted after the prefix operator
and an error is announced.
\item[Rule 6:] A recognized infix operator of precedence $P'$
must be followed by a non-operator or by an operator
of precedence greater than $P'$,
else an `error operand' which is not an operator
is inserted after the infix operator
and an error is announced.
\item[Rule 7:] A recognized postfix operator of precedence $P'$
must be followed by the end of the entire token list,
or by an operator of precedence less than $P'$,
or by a postfix operator of precedence equal to $P'$,
else an `error nofix operator' of precedence $P'-1$
is inserted after the postfix operator and an error is announced.
\end{itemlist}

By simply by enforcing these rules the operator parser pass enforces
the requirements listed above.

During its left-to-right scan the operator parser pass maintains
the following state:
\begin{itemlist}[0.7in]
\item[$C$:] A pointer to the current token, initialized to the
first token in the input.
\item[$N$:] A pointer to the next token after the subexpression
being input, which may be an end-of-file token.  Not changed during
the scan from its initial value.  Initially $C\neq N$.
\item[$P$:] A stack of subexpression terminating precedences,
initialized to a one element stack containing a precedence less
than any legal operator precedence.  Whenever an operator is found,
the top of this stack is set to the precedence of the operator
(the stack may be pushed or popped before this is done).
\item[$F$:] A stack of pointers to the first token in a subexpression,
initialized to a one element stack containing a pointer to the first
token in the input.  Whenever an operator is found, the top of this
stack is set to point to the token after the operator (the stack
may be pushed or popped before this is done).
\item[$T$:] The type of the last operator found.  Valid only if
$C=F$ (meaning $C$ equals the top of the $F$ stack, and so $C$
points at the token after the operator).
Can equal {\em prefix}, {\em postfix}, {\em nofix}, {\em infix}, or {\em none}.
Initialized to {\em none}.
\end{itemlist}

In the following $F$ is used to denote either the stack $F$ or
the top element of this stack.  Similarly $P$ is used to denote either the
stack $P$ or the top element of this stack.

The operator parser pass algorithm simply repeats the following
steps in a loop:
\begin{itemlist}[1.2in]
\item[Loop Step 1:]
If $C\neq N$, find an operator beginning at token $C$, if there is one.

If $C=F$ (i.e., $C$ is at the beginning of the token list or just after
an operator of precedence $P$),
prefix operators of precedence less than $P$ are ignored,
prefix operators of precedence equal to $P$ are ignored unless
$T=\mbox{\em prefix}$,
infix operators of precedence greater than or equal to $P$ are ignored,
postfix operators of precedence greater than $P$ are ignored,
postfix operators of precedence equal to $P$ are ignored unless
$T=\mbox{\em postfix}$.

If $C\neq F$ (i.e., a non-operator is just before $C$),
prefix operators are ignored.

Any afix operator whose precedence is not in the $P$ stack is ignored.

Any operator whose selectors are disjoint from the current parser context
selectors is ignored.

Among all non-ignored operators, a longest
is selected, and among all the longest, the one with the most recent
operator definition is selected.

If an operator was found, replace its tokens by a single
OPERATOR token, point $C$ at that token.  Let $P'$ be the precedence
of the found operator.
\item[Loop Step 2:]
If $C=F$ and $T=\mbox{\em postfix}$
(the token before $C$ is a postfix operator),
$C\neq N$, and either no operator was find in Loop Step 1,
or an operator was found and $P'>P$,
or a non-postfix operator was found and $P=P'$,
insert the error nofix operator of precedence
equal to $P-1$ as a single
OPERATOR token before $C$, set $C$ to point at it,
set $P'=P-1$,
announce an error, and continue (as if an operator were found in
Loop Step 1).

\item[Loop Step 3:]
Else if $C\neq N$
and no operator was find in Loop Step 1 or generated by Loop Step 2,
repoint $C$ to the next token after $C$ and go to the next loop iteration.

Note that if the iteration continues after this step,
then either $C=N$ or an operator was found in Loop Step 1
or generated in Loop Step 2.
\item[Loop Step 4:]
If $C=F$ and any of the following are true:
\\[1ex]
\hspace*{0.2in}
\begin{tabular}{@{}l@{}}
$T=\mbox{\em infix}$ and $C=N$ or $P'\leq P$, \\
$T=\mbox{\em prefix}$ and $C=N$ or $P'<P$, \\
$T=\mbox{\em prefix}$ \begin{tabular}[t]{@{}l@{}}
                      and $C\not=N$ and $P'=P$ \\
		      and the found operator is not a prefix operator,
		      \end{tabular}
\end{tabular}
\\[1ex]
then insert
an error operand lexeme token before $C$,
announce an error, and then continue as if no error were found.
\item[Loop Step 5:]
If $C=N$ or $P'\leq P$, and if $C\not=F$,
apply Step 3 and Step 4 above to the list of tokens beginning with
$F$ and ending just before $C$.

Then if the $P$ and $F$ stacks are empty, terminate this loop
(can only happen if $C=N$).

Else if $C=N$, pop the $P$ and $F$ stacks and repeat this loop step.

Else if $P'<P$, pop the $P$ and $F$ stacks and repeat this loop step
(cannot happen if the $P$ and $F$ stacks have only one entry as
in that case $P$ is less than any possible $P'$).

Else if $P'>P$, push $P'$ and $C$ into the $P$ and
$F$ stacks respectively.

Else if $P'=P$, set $F$ to $C$.

\item[Loop Step 6:]
Set $T$ to the type of the found operator,
repoint $C$ to the token after $C$, and iterate the loop.
\end{itemlist}

	



TBD



\clearpage

\appendix

\section{Standard Lexical Program}
\label{STANDARD-LEXICAL-PROGRAM}

\begin{indpar}
\begin{verbatim}
// This file was automatically generated from
// ll_lexeme_standard.lexcc.


begin standard lexical program;

"<ascii-char>" = "<0>-<7F>"  [ASCII Character]

// NON_ASCII_LETTERS, NON_ASCII_COMBINING_
// CHARACTERS, NON_ASCII_CONTROL_CHARACTERS are
// defined in ll_lexeme_non_ascii_characters.h.

"<non-ascii-letter>" = NON_ASCII_LETTERS

"<non-ascii-combining-char>" =
    NON_ASCII_COMBINING_CHARACTERS

"<non-ascii-control-char>" =
    NON_ASCII_CONTROL_CHARACTERS

"<ascii-letter>" = "a-z" | "A-Z";

"<digit>" = "0-9";

"<hex-digit>" = "0-9" | "A-F";

"<non-digit>" = ~ "<digit>";

"<letter>" = "<ascii-letter>"
           | "<non-ascii-letter>"

"<non-ascii-word-char>" =
      "<non-ascii-letter>"
    | "<non-ascii-combining-char>"

// Context sensitive character classifications,
// e.g., classifying ' as a word character if it
// is followed by a letter, cannot be included
// in character pattern definitions, but are
// noted in comments.  They are accounted for
// by separate lexeme table entries below.

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@"
              | "#" | "$" | "%" | "^" | "&"
              | "=" | "|" | ">" | "_" | "!"
              | "?" | ":";
              //
              // Also . not followed by a digit
              //      / not surrounded by digits
              //        or followed by /
              //      < not beginning escaped
              //        hex character

"<non-slash-char>" = ~ "/";

"<separator-char>" = "(" | ")" | "[" | "]"
                   | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter

"<misplaced-space-char>" =
        "<CR>" | "<VT>" | "<FF>"

"<ascii-control-char>" = "<0>-<1F>" | "<7F>"

"<control-char>" = "<ascii-control-char>"
                 | "<non-ascii-control-char>"

"<control-char-except-CR-LF>" =
    "<control-char>" & ~ "<CR>" & ~ "<LF>"

"<horizontal-space-char>" = " " | "<HT>";

"<escape-char>" = "A-Z" | "0-9" | "-";


begin main master table;

   // Unrecognized characters or escapes, etc,
   // outside quoted strings are output as
   // lexemes, and can separate other lexemes.
   // If these are treated by post-processing
   // in the same manner as horizontal space,
   // they could be replaced by horizontal space
   // without changing the semantics of the
   // output.
   //
   // Inside quoted strings, unrecognized
   // escapes are treated as erroneous atoms,
   // translated to "", and ignored.  The
   // lexemes output would be the same if they
   // were removed.

   // Whitespace is separated out into 4 types
   // of lexemes:
   //
   //   `space'
   //       single spaces and horizontal tabs
   //   `line break'
   //       linefeeds, carriage returns, form
   //       feeds, and vertical tabs, with at
   //       least one line feed
   //   `misplaced space'
   //       ditto but with no line feed
   //   `comments'
   //       `//' up to just before next line
   //        break, misplaced space, or (pre-
   //        mature) end of file
   //
   "//" call comment;
   "/"  call mark;

   "<horizontal-space-char>"
        call horizontal space;

   "<LF>" call line break;
   "<misplaced-space-char>"
        call misplaced space;

   "<letter>" call word;

   "'<letter>" call word;
   "'" output separator;

  "<" "<digit>"
          match escaped hex char
          require "<non-ascii-letter>"
          call word
     else match escaped hex char
          require "<ascii-char>"
          output ascii escape seq
     else match escaped hex char
          output non letter escape seq
     else keep 1 call mark;
   "<" call mark;

   "<mark-char>" call mark;

   "<digit>" keep 0 call natural number;
             // We keep 0 so natural number can
             // recognize <digit>,<digit> etc.

   ".<digit>" keep 1 call number;
              // We keep 1 so number can recog-
              // nize <digit>,<digit> etc.
   "." call mark;

   "<separator-char>" output separator;

   "," output separator;

   "<Q>" translate to "" call quoted string;

   "<other>" output misplaced char;

   output end of file;

end main master table;


// The below tables are entered from the master
// table with the first zero, one, or two
// characters scanned.


begin comment lexeme table;

   "<LF>" keep 0 return;
   "<misplaced-space-char>" keep 0 return;

   "<other>" accept;

   goto premature end of file;

end comment lexeme table;


begin horizontal space lexeme table;

   "<horizontal-space-char>" accept;

   return;

end horizontal space lexeme table;


begin misplaced space lexeme table;

   "<LF>" goto line break;

   "<misplaced-space-char>" accept;

   return;

end misplaced space lexeme table;


begin line break lexeme table;

   "<LF>" accept;
   "<misplaced-space-char>" accept;

   return;

end line break lexeme table;


begin word lexeme table;

   "<letter>" accept;
   "<non-ascii-combining-char>" accept;

   "'<letter>" accept;

    "<" "<digit>"
              match escaped hex char
              require "<non-ascii-word-char>"
         else keep 0 return;

   return;

end word lexeme table;


begin mark lexeme table;

   "<mark-char>" accept;
   "<non-ascii-combining-char>" accept;

   ".<digit>" keep 0 return;
   "." accept;

   "//" keep 0 return;
   "/" accept;

    "<" "<digit>"
          match escaped hex char
          require "<non-ascii-combining-char>"
      else
          match escaped hex char
          keep 0 return;
      else
          keep 1;
    "<" accept;

   return;

end mark lexeme table;


begin natural number lexeme table;


   // In order to recognize , and / surrounded
   // by digits as number atoms, entries to this
   // table upon recognizing "X<digit>" must do
   // a `keep 1' so the digit will be left to be
   // recognized by <digit>/<digit> or
   // <digit>,<digit>.

   // Alternatively we could have a separate
   // table for the state where the last atom
   // ended with a digit.

   "<digit>/<digit>" keep 2 goto number;
   "<digit>,<digit>" keep 2 goto number;
   "<digit>" accept;

   ".<digit>" keep 1 goto number;

   return;

end natural number lexeme table;


begin number lexeme table;

   // See note on , and / in `natural number'
   // table above.

   "<digit>/<digit>" keep 2;
   "<digit>,<digit>" keep 2;
   "<digit>" accept;

   ".<digit>" keep 1;

   return;

end number lexeme table;


begin quoted string lexeme table;

    "<Q>" translate to "" return;
            // End quoted string.

    "<" match escaped char
        else match unrecognized escape seq
             error unrecognized escape seq
             translate to ""
        else accept;

    "<LF>"
        keep 0 goto premature end of line;

    "<CR><LF>"
        keep 0 goto premature end of line;
    "<CR>"
        error misplaced control char
        translate to "";

    "<control-char-except-CR-LF>"
        error misplaced control char
        translate to "";

    "<other>" accept;

    goto premature end of file;

end quoted string lexeme table;


begin escaped char atom table;

    "<" "ACK" ">" translate to "<ACK>";
    "<" "BEL" ">" translate to "<BEL>";
    "<" "BS" ">" translate to "<BS>";
    "<" "CAN" ">" translate to "<CAN>";
    "<" "CR" ">" translate to "<CR>";
    "<" "DC1" ">" translate to "<DC1>";
    "<" "DC2" ">" translate to "<DC2>";
    "<" "DC3" ">" translate to "<DC3>";
    "<" "DC4" ">" translate to "<DC4>";
    "<" "DEL" ">" translate to "<DEL>";
    "<" "DLE" ">" translate to "<DLE>";
    "<" "EM" ">" translate to "<EM>";
    "<" "ENQ" ">" translate to "<ENQ>";
    "<" "EOT" ">" translate to "<EOT>";
    "<" "ESC" ">" translate to "<ESC>";
    "<" "ETB" ">" translate to "<ETB>";
    "<" "ETX" ">" translate to "<ETX>";
    "<" "FF" ">" translate to "<FF>";
    "<" "FS" ">" translate to "<FS>";
    "<" "GS" ">" translate to "<GS>";
    "<" "HT" ">" translate to "<HT>";
    "<" "LF" ">" translate to "<LF>";
    "<" "NAK" ">" translate to "<NAK>";
    "<" "NL" ">" translate to "<NL>";
    "<" "NUL" ">" translate to "<NUL>";
    "<" "Q" ">" translate to "<Q>";
    "<" "RS" ">" translate to "<RS>";
    "<" "SI" ">" translate to "<SI>";
    "<" "SO" ">" translate to "<SO>";
    "<" "SOH" ">" translate to "<SOH>";
    "<" "SP" ">" translate to "<SP>";
    "<" "STX" ">" translate to "<STX>";
    "<" "SUB" ">" translate to "<SUB>";
    "<" "SYN" ">" translate to "<SYN>";
    "<" "US" ">" translate to "<US>";
    "<" "VT" ">" translate to "<VT>";

    "<" "<digit>" match escaped hex char
            else fail;

    fail;

end escaped char atom table;


begin escaped hex char atom table;

    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit>" ">" translate hex 1 1;

    fail;

end escaped hex char atom table;


begin unrecognized escape seq atom table;

    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>" ">";
    "<" "<escape-char>" ">";

    fail;

end unrecognized escape seq atom table;


begin premature end of line master table;

    output premature end of line goto main;

end premature end of line master table;


begin premature end of file master table;

    output premature end of file goto main;

end premature end of file master table;


end standard lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{C++ Lexical Program}
\label{C++-LEXICAL-PROGRAM}

\begin{indpar}\begin{verbatim}
// This file was automatically generated from
// ll_lexeme_c++.lexcc.

begin c++ lexical program;

// Before this lexical program is used the input
// should be preprocessed to
//
//    (1) Replace trigraph sequences.
//    (2) Eliminate carriage-returns next to a
//        newline (others become misplaced)
//    (3) Eliminate sequences of the form:
//        backslash newline
//
// After this lexical program is used the output
// should be post-processed to
//
//    (4) Perform C/C++ macro preprocessing
//        (macro expansion).
//    (5) Delete whitespace and newlines.
//    (6) Concatenate adjacent quoted strings
//        of the same character type (ordinary,
//        u, U, or L).

"<digit>" = "0-9";

"<non-zero-digit>" = "1-9";

"<oct-digit>" = "0-7";

"<hex-digit>" = "0-9" | "a-f" | "A-F";

"<ascii-letter>" = "a-z" | "A-Z";

"<letter>" = "<ascii-letter>"
           | "<non-ascii-letter>

// <non-ascii-letter> ::= UNICODE character in
// one of the code ranges designated in
// NON_ASCII_LETTERS in ll_lexeme_non_ascii_
// characters.h.

// <combining-char> ::= UNICODE character in
// one of the code ranges designated in
// NON_ASCII_COMBINING_CHARACTERS in ll_lexeme_
// non_ascii_characters.h.

// Universal characters are only permitted in
// identifiers, character literals, and string
// literals.  In identifiers they must represent
// non-ASCII-letters or non-ASCII combining
// characters, and the latter cannot be the
// initial character of an identifier.

"<identifier-non-digit>" = "_" | "<letter>";

"<identifier-char>" = "<identifier-non-digit>"
                    | "<digit>"
                    | "<combining_char>"

"<non-ascii-identifier-char>" =
          "<non-ascii-letter>"
        | "<combining_char>"

// Because `u', `U', or `L' can start a char-
// acter or string literal, we must define:
//
"<u_U_L>" = "u" | "U" | "L";
"<identifier-non-literal>" =
          "<identifier-non-digit>"
        & ~ "<u_U_L>";

"<whitespace-char>" =
    " " | "<HT>" | "<VT>" | "<FF>";
    // newline is treated separately


// The following can begin an operator or punc-
// tuation mark.
//
// / not followed by / or * and . not followed
// by <digit> are handled separately.
//
"<op-char>" = "#" | "<" | ">" | ":" | "%" |
            | "?" | "+" | "-" | "*" | "="
            | "^" | "&" | "|" | "~" | "!" | ","
            | "(" | ")" | "[" | "]" | "{" | "}"
            | ";";

"<sign>" = "+" | "-" ;

"<u_U>" = "u" | "U" ;

"<ascii-char>" = "<0>-<7F>"  [ASCII Character]


// C/C++ preprocessing is hereafter abbreviated
// as `pp'.

// Alternative operators that are not identi-
// fiers are translated.  E.g., <: becomes [ in
// the lexeme translation.

// C++ punctuation are treated as `operators'.

// Pp numbers are divided into 5 categories
// (note that a `suffix' is an identifier):
//
//      decimal integer
//          nothing but digits not beginning
//          with 0, with an optional suffix
//      octal integer
//          nothing but octal digits beginning
//          with 0, with an optional suffix
//      hexadecimal integer
//          nothing but hexadecimal digits
//          refaced by 0x or 0X, with an
//          optional suffix
//      float
//          legal floating point #'s, with an
//          optional suffix
//      pp number
//          all other pp numbers

// Because of pp control lines, lexical scanning
// is slightly context dependent.  There are
// several contexts, each corresponding to a
// different master table:
//
//    initial master
//        Used in line beginning situations to
//        recognize the # token that introduces
//        a pp control line.
//    pp beginning master
//        Used to scan the beginning of a pp
//        control line after the # has been
//        scanned but before anything else is
//        scanned.
//    pp include master
//        Used to scan the pp-header token in a
//        #include line after #include has been
//        scanned.
//    normal master
//        Used to scan a non pp control line or
//        the rest of a pp control line after
//        any #include header.
//
// The whitespace lexeme types are:
//
//    newline
//        a single <NL>
//    horizontal-space
//        sequence of "<whitespace-char>"s
//        (excludes <NL>'s)
//    comment
//        "/*" comment (including /* and */)
//        "//" comment (including // but not
//                      ending newline)
//
// This allows line feeds to be used to end pp
// control lines.


// Characters that are not part of legal lexemes
// and which are outside character literal ''s
// and and quoted string literal ""s are made
// into error lexemes that can separate other
// lexemes in exactly the same way that white-
// space can.
//
// Note that ## cannot be used to move charac-
// ters inside a character or string literal ''
// or "".  Also, we do NOT allow ## to append a
// combining character to another character.
// Therefore ## cannot be used to create a legal
// pp token by concatenating a legal pp token
// with a stray character that is not part of a
// legal pp token.  Thus we can treat all stay
// characters as errors, instead of making them
// into pp tokens.

// Characters that are part of erroneous atoms
// INSIDE character literal ''s or quoted string
// ""s are announced as part of an erroneous
// atom which is translated to "" and ignored as
// if it did not appear at all in the input.

begin initial master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur INSIDE
    // a pp directive line.
    //
    "/*" call "/*" comment;

    "#" output operator goto pp beginning;
    "##" output operator goto normal;

    "%:" translate to "#" output operator
         goto pp beginning;
    "%:%:" translate to "##" output operator
           goto normal;

    goto normal;

end initial master table;


begin pp beginning master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur inside
    // pp directive line.
    //
    "/*" call "/*" comment;

    // "include" identifier must be followed by
    // one of the following for a header to be
    // recognized:
    //
    //     <whitespace-char>
    //     /* comment
    //     <...> header
    //     "..." header
    //
    "include<whitespace-char>"
        keep 7 output identifier
        goto pp include;
    "include/"
        keep 7 output identifier
        goto pp include;
    "include<"
        keep 7 output identifier
        goto pp include;
    "include<Q>"
        keep 7 output identifier
        goto pp include;

    goto normal;

end pp beginning master table;

begin pp include master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur inside
    // pp directive line.
    //
    "/*" call "/*" comment;

    "<" translate to ""
        goto bracketed header name;

    "<Q>" translate to ""
        goto quoted header name;

    goto normal;

end pp include master table;


begin premature newline master table;

    output premature newline goto normal;

end premature newline master table;


begin premature end of file master table;

    output premature end of file goto initial;

end premature end of file master table;

begin whitespace lexeme table;

    "<whitespace-char>" accept;

    return;

end whitespace lexeme table;


begin "/*" comment lexeme table;

    "*/" return;
    "*" accept;

    "<other>" accept;

    translate_to "*/"
    goto premature end of file;

end "/*" comment lexeme table;


begin "//" comment lexeme table;

    "<NL>" keep 0 return;

    "<other>" accept;

    goto premature end of file;

end "//" comment lexeme table;


begin bracketed header name lexeme table;

    ">" translate to "" goto normal;

    "<NL>"
        keep 0 goto premature newline;

    "<other>" accept;

    goto premature end of file;

end bracketed header name lexeme table;


// Quoted header names are not the same as
// quoted strings, and cannot have escape
// sequences.
//
begin quoted header name lexeme table;

    "<Q>" translate to "" goto normal;

    "<NL>"
        keep 0 goto premature newline;

    "<other>" accept;

    goto premature end of file;

end quoted header name lexeme table;


begin normal master table;

    "<whitespace-char>" call whitespace;

    "/*" call "/*" comment;
    "//" call "//" comment;
    "/" match operator output operator
        // match should always succeed

    "<op-char>"
        match operator output operator
        // match should always succeed

    "<identifier-non-literal>"
        call identifier;
        // Also see "u/U/L..." etc. below.

    "u'" translate to ""
         output u char literal
         call char literal;
    "u<Q>" translate to ""
           output u string literal
           call string literal;
    "u"  call identifier;

    "U'" translate to ""
         output U char literal
         call char literal;
    "U<Q>" translate to ""
           output U string literal
           call string literal;
    "U"  call identifier;

    "L'" translate to ""
         output L char literal
         call char literal;
    "L<Q>" translate to ""
           output L string literal
           call string literal;
    "L"  call identifier;

    "\<u_U>" match universal char
             require <non-ascii-letter>
             call identifier
        else match universal char
             require "<ascii-char>"
             output ascii universal char
        else match universal char
             output misplaced universal char
        else match short universal char
             output universal char
             // Match should always succeed.
    "\" output misplaced char

    "<non-zero-digit>" call decimal integer;

    "0x" call hexadecimal integer;
    "0X" call hexadecimal integer;
    "0" call octal integer;

    ".<digit>" call fraction;
    "." match operator output operator
        // match should always succeed

    "'" translate to ""
        output char literal
        call char literal;

    "<Q>" translate to ""
          output string literal
          call string literal;

    "<NL>" output newline goto initial;

    "<other>" output misplaced char;

    output end of file;

end normal master table;


begin operator atom table;

    "("; ")"; "["; "]"; "{"; "}"; ";"; ","; "?";
    "~";

    "#";
    "##";

    "<:" translate to "[";
    "<%"; translate to "{";
    "<<="; "<<"; "<";

    ">>="; ">>"; ">";

    ":>" translate to "]";
    "::"; ":";

    "%>" translate to "}";
    "%:%:" translate to "##";
    "%:" translate to "#";
    "%="; "%";

    "..."; ".*"; ".";

    "++"; "+="; "+";

    "->*"; "->"; "--"; "-="; "-";

    "*="; "*";
    "/="; "/";
    "^="; "^";
    "!="; "!";
    "=="; "=";

    "&&"; "&="; "&";

    "||"; "|="; "|";

    fail;

end operator atom table;


begin identifier lexeme table;

    "<identifier-non-digit>" accept;
    "<digit>" accept;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
        else keep 0 return

    return;

end identifier lexeme table;

"<e_E> = "e" | "E";
"<identifier-non-digit-except-eE>" =
    "<identifier-non-digit>" & ~ "<e_E>";


begin decimal integer lexeme table;

    "<digit>" accept;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end decimal integer lexeme table;


begin octal integer lexeme table;

    "<oct-digit>" accept;

    "8" goto float integer;
    "9" goto float integer;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end octal integer lexeme table;

"<identifier-non-hex-digit>" =
    "<identifier-non-digit>" & ~ "<hex-digit>";


begin hexadecimal integer lexeme table;

    "<hex-digit>" accept;

    "<identifier-non-hex-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end hexadecimal integer lexeme table;


// integer began with 0 and then included a
// non-octal digit.
//
begin float integer lexeme table;

    "<digit>" accept;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto pp number;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto pp_number
        else keep 0 goto pp number

    goto pp number;

end float integer lexeme table;


// Come here to process suffix at end of integer
// or float lexeme.  Similar to identifier but
// changes lexeme type to pp number when certain
// character sequences are encountered.
//
begin suffix sublexeme table;

    "<identifier-non-digit-except-eE>" accept;
    "<digit>" accept;

    "<e_E><sign>" goto pp number;
    "<e_E>" accept;

    "." goto pp number;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
             else keep 0 return;

    return;

end suffix sublexeme table;

begin pp number lexeme table;

    "<identifier-non-digit-except-eE>" accept;
    "<digit>" accept;

    "<e_E><sign>" accept;
    "<e_E>" accept;

    "." accept;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
             else keep 0 return;

    return;

end pp number lexeme table;


begin fraction lexeme table;

    "<digit>" accept;

    "." goto pp number;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<identifier-non-digit>" goto suffix;

    "\<u_U>" match universal char
             require "<non-ascii-letter>"
             goto suffix
             else keep 0 return;

    return;

end fraction lexeme table;


begin exponent lexeme table;

    "<digit>" accept;

    "." goto pp number;

    "<e_E><sign>" goto pp number;
    "<identifier-non-digit>" goto suffix;

    "\<u_U>" match universal char
             require "<non-ascii-letter>"
             goto suffix
             else keep 0 return;

    return;

end exponent lexeme table;


begin char literal sublexeme table;

    "'" translate to "" return;

    "<NL>" keep 0 goto premature newline

    "\" match escaped char
        // match should always succeed

    "<other>" accept

    goto premature end of file

end char literal sublexeme table;


begin string literal sublexeme table;

    "<Q>" translate to "" return;

    "<NL>" keep 0 goto premature newline

    "\" match escaped char
        // match should always succeed

    "<other>" accept

    goto premature end of file

end string literal sublexeme table;


// This atom table is used when the next atom
// begins with \ and is in a character or string
// literal.  This atom table always succeeds,
// but may produce an erroneous atom with ""
// translation.
//
// We allow only a maximum of 8 hexadecimal
// digits after \x; 9 digits is an error.  The
// C++ standard permits any number of hexa-
// decimal digits.
//
begin escaped char atom table;

    "\n" translate to "<NL>";

    "\t" translate to "<HT>";

    "\v" translate to "<VT>";

    "\b" translate to "<BS>";

    "\r" translate to "<CR>";

    "\f" translate to "<FF>";

    "\a" translate to "<BEL>";

    "\\" translate to "\";

    "\?" translate to "?";

    "\<Q>" translate to "<Q>";

    "\'" translate to "'";

    "\<oct-digit><oct-digit><oct-digit>"
        translate oct 1 0;
    "\<oct-digit><oct-digit>"
        translate oct 1 0;
    "\<oct-digit>"
        translate oct 1 0;

    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        error too long hex escape
        translate to "";
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit>"
        translate hex 2 0;
    "\x" error ill formed escape
        translate to "";

    "\<u_U>" match universal char
        else match short universal char
             error short universal char
             translate to "";
             // This should always succeed

"\<NL>" keep 1
        error ill formed escape
        translate to "";

"\<other>" error ill formed escape
           translate to "";

"\" error ill formed escape
    translate to "";
    // In case \ followed by end of file

// This table should always succeed.

end escaped char atom table;


// This atom table is called when the next
// atom begins with \U or \u.  If the atom
// has the correct number of hexadecimal
// digits after the \U or \u, it is recognized
// and translated.
//
begin universal char atom table;

    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;

    "\u<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;

    fail;

end universal char atom table;


// This atom table is called when the next
// atom begins with \U or \u but there are too
// few hexadecimal digits following.  An atom
// is always recognized but is NOT translated.
//
begin short universal char atom table;

    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>";
    "\U<hex-digit>";
    "\U";

    "\u<hex-digit><hex-digit>"
      "<hex-digit>";
    "\u<hex-digit><hex-digit>";
    "\u<hex-digit>";
    "\u";

    // The above should always succeed.

end short universal char atom table;


end c++ lexical program;

\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
