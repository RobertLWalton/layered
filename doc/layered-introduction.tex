% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

July 4, 2007
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A machine independent reduced instruction set architecture
	  programming language.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& Similar to the C programming language but more flexible.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& Implements standardized lists, symbols, arrays, etc. to extend
	  the M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `{\tt hello}', `{\tt +}', `{\tt ;}',
`{\tt 9.200}' are four lexemes.

The lexical scanner is written in the H-Language and can be
replaced.  This section describes the standard scanner which
is C/C++ compatible and is driven by the following lexical atom tables:

\begin{center}
\begin{tabular}{l}
lexeme atom table \\
identifier atom tables \\
number atom tables \\
string atom tables \\
comment atom tables \\
whitespace atom tables \\
\end{tabular}
\end{center}

The (standard) scanner reads left to right, and at each point
identifies the next lexical atom in the text,
where a \key{lexical atom} is a string
of characters explicitly listed in one of the \skey{lexical atom table}s.
If there are several possibilities, the longest is choosen.
To identify atoms, the scanner looks in one of the atom tables;
which table depends on the state of the scanner.  The table entry
for an atom contains an atom type, which determines subsequent
actions of the scanner.  The table entry can also contain a
translation, which is the string of characters the atom represents,
so that, for example, the translation of the atom `{\tt \BACKSLASH t}'
can be `the horizontal tab character'.

Each lexical atom table has a name consisting of sequence of
identifiers and quoted strings ending with an identifier.  The table
name must be `{\tt lexeme}' or must be a \key{lexeme type}, and in the
latter case the table name is also the type name of any lexemes recognized
using the table.

More specifically, lexeme type names
are sequences of identifiers and quoted strings ending with
a \key{lexeme class} identifier, which is one of:

\begin{center}
\begin{tabular}{l}
\tt separator \\
\tt operator \\
\tt identifier \\
\tt string \\
\tt comment \\
\tt whitespace \\
\tt error \\
\end{tabular}
\end{center}

There are no actual lexemes of classes {\tt comment}, {\tt whitespace},
and {\tt error}; strings that might be lexemes of these types are
discarded.

For example, the standard lexical atom table for an identifier 
is named `{\tt identifier}', and the
lexical atom table for a `{\tt /* */}' style C comment is named
`{\tt "/*" comment}'.

The general form of an atom table entry is:

\begin{center}
\begin{tabular}{rcl}
\emkey{lexical-atom-table-entry}
	& ::= & {\em lexical-atom} {\em lexical-atom-type} \\
	& & ~~~~[{\em lexical-atom-translation}] {\tt ;} \\
\emkey{lexical-atom} & ::= & {\em quoted-string} \\
\emkey{lexical-atom-type}
	& ::= & {\em lexical-atom-type-qualifier}$^\star$ {\em lexical-class} \\
\emkey{lexical-atom-type-qualifier}
	& ::= & {\em quoted-string} $|$ {\em identifier} \\
\emkey{lexical-class} & ::= & {\em identifier} \\
\emkey{lexical-atom-translation} & ::= & {\em quoted-string} \\
\end{tabular}
\end{center}%
\label{LEXICAL-ATOM-TABLE-ENTRY}

The following are some entries in the standard {\tt lexeme} atom table:

\begin{indpar}\begin{verbatim}
"a"     identifier
"++"    operator
"+"     operator
";"     separator
"L'"    wide char string
"\""    quoted string
"0"     oct number
"1"     number
".0"    number
".1"    number
\end{verbatim}\end{indpar}

Because of these entries the input string `{\tt ++a}' will be
recogonized as consisting of the operator lexeme `{\tt ++}' followed
by the beginning of an identifier.  `{\tt ++}' is choosen over `{\tt +}'
because it is longer.  The input string `{\tt ++L'}', however,
would be recognized as beginning with the operator lexeme `{\tt ++}'
followed by the beginning of a `{\tt wide char string}'.

The state of the scanner is just the name of the atom table the
scanner is using.  The default state is `{\tt lexeme}', which uses
the {\tt lexeme} atom table.
Given input beginning with `{\tt ++a}', and the above entries in the
{\tt lexeme} atom table,
the scanner accepts the atom `{\tt ++}' as an operator lexeme and removes
it from the input.  Then given input beginning with `{\tt a}', the
scanner does not accept any input, but instead just switches state to
`{\tt identifier}' and continues by scanning identifer atoms.
In certain states, such as the `{\tt identifier}' state, the
scanner accumulates all the translations of the atoms accepted in
that state, and when the scanner switches out of the state, the
scanner ejects the accumulated string as a lexeme of the type
named by the state.

The following are some entries in the
standard `{\tt quoted string}' table:

\begin{indpar}\begin{verbatim}
"\\t"   accept       "\t"
"\\""   accept       "\""
"\""    begin        ""
"\""    end          ""
\end{verbatim}\end{indpar}

Here the input `{\tt \BACKSLASH t}' is translated to a horizontal
tab, the input `{\tt \BACKSLASH "}' is translated to
a single double quote, and
the `{\tt "}' character, if it is not part of another atom,
translates to the empty string.  By default an atom translates to itself.

The `{\tt "}' character appears twice in the table, once as
a begin atom, which can only be recognized
at the beginning of a quoted string, and once as an end atom,
which ends the string and cannot appear at the beginning of
a string.  Most characters, like `{\tt a}' and
`{\tt +}', are not listed in the table:
they become accepted atoms that translate to themselves by default.
For {\tt string} tables characters not listed become part of the string;
but for {\tt identifier} tables characters not listed terminate
the identifier.

We say that an atom is
\ikey{accepted}{lexical atom} if it is removed from the input string, and
\ikey{rejected}{lexical atom} if it is not.
An atom is said to be
\ikey{accumulated}{lexical atom} if it is accepted and its translation
is added to the lexeme string currently being accumulated.
An atom is said to be
\ikey{discarded}{lexical atom} if it is accepted and \underline{not} added
to the lexeme string currently being accumulated.
The accumulated lexeme string
may be output as a lexeme of the type of the current lexical scanner state
when the scanner switches out of that state, or the accumulated string
may be discarded when the scanner switches state.  Recall that the
scanner state is just the name of the lexical atom table the scanner
is currently using.

This scheme for lexical scanning is intended to give the user
control over the set of operators, punctuation, characters
that can appear in identifiers, character representatives in
quoted strings, etc.  The atom tables are quite verbose, and
are usually compiled from a more compact representation.

\subsection{The Lexeme Atom Table}

When the scanner is in the {\tt lexeme} state, it can accept
atoms and output their translations as complete lexemes, or it can reject
atoms and switch to a different state.  Translations are
\underline{not} accumulated in this state.  If there is no
recognizable atom at the beginning of the input, the next input UTF-8
character sequence is discarded and announced as an error.
If the next character is not part of a legal UTF-8 character sequence,
it is discarded and announced as an error.

The following are the possible lexical atom types in the lexeme atom table:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{3.5in}}
{\em qualifier}$^\star$
\ttkey{operator}	& The atom is accepted and its translation is
			  output \\
			& as a `{\em qualifier}$^\star$ {\tt operator}' lexeme.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{separator}	& The atom is accepted and its translation is
			  output \\
			& as a `{\em qualifier}$^\star$ {\tt separator}' lexeme.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{identifier}	& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt identifier}'.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{number}		& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt number}'.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{string}		& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt string}'.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{comment}		& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt comment}'.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{whitespace}	& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt whitespace}'.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{error}		& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt error}'.
\end{tabular}
\end{center}

\subsection{Identifier Atom Tables}

When the scanner is in a `{\em qualifier}$^\star$ {\tt identifier}' state,
it can accumulate
atoms, or it can reject atoms and switch to the {\tt lexeme} state.
Translations of accumulated atoms are appended to the current
accumulation string.
If at any time there is no recognizable atom at the beginning of the
remaining input,
the scanner switches to the {\tt lexeme} state without accepting
any further input, and outputs its accumulated string as a
`{\em qualifier}$^\star$ {\tt identifier}' lexeme.

The following are the possible lexical atom types in an identifier atom table:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\ttkey{accept}	  & Accumulate the atom.
\\[1ex]
\ttkey{begin}	  & Accumulate the atom, but only
		    recognize the atom if it is the first atom
		    in the {\tt identifier} state.
\\[1ex]
\ttkey{continue}  & Accumulate the atom, but only
		    recognize the atom if it is \underline{not} the first
		    atom in the {\tt identifier} state.
\\[1ex]
\ttkey{end}	  & Accumulate the atom, but only
		    recognize the atom if it is \underline{not} the first
		    atom in the {\tt identifier} state.  After
		    accepting the atom, switch into the {\tt lexeme} state.
\\[1ex]
\ttkey{error}	  & Discard the atom, and announce that the
		    atom is in error.
\\[1ex]
\end{tabular}
\end{center}

\subsection{Number Atom Tables}

Then the scanner is in a `{\em qualifier}$^\star$ {\tt number}' state,
it can accumulate
atoms, or it can reject atoms and switch to the {\tt lexeme} state.
Translations of accumulated atoms are appended to the current
accumulation string.
If at any time there is no recognizable atom at the beginning of the
remaining input,
the scanner switches to the {\tt lexeme} state without accepting
any further input, and outputs its accumulated string as a
`{\em qualifier}$^\star$ {\tt number}' lexeme.

The following are the possible lexical atom types in a number atom table:

\begin{indpar}
\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{digit}	& Accumulate the atom, but only recognize
		  the atom if it is \underline{not} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{begin digit}
		& Accumulate the atom, but only
		  recognize the atom if it is the first atom.
\\[1ex]
\ttkey{continue digit}
		& Accumulate the atom, but only
		  recognize the atom if it is \underline{not}
		  the first atom and \underline{not} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{point}	& Accumulate the atom, but only recognize
                  the atom if it is \underline{not}
		  after either another {\tt point}
		  or a {\tt begin exponent} atom.
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{end}
		& Accumulate the atom, but only recognize
		  the atom if it is \underline{not} the first atom.
		  After accepting the atom, the scanner switches
		  to {\tt lexeme} state.
\\[1ex]
\ttkey{floating end}
		& Like {\tt end}, but \underline{must} be after a {\tt point}
		  or {\tt begin exponent}.
\\[1ex]
\ttkey{integer end}
		& Like {\tt end},
		  but must \underline{not} be after a {\tt point}
		  or {\tt begin exponent}.
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{begin exponent}
		& Accumulate the atom, but only recognize
		  the atom if it is \underline{not} the first atom
		  and is \underline{not} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{exponent digit}
		& Accumulate the atom, but only recognize
		  the atom if it \underline{is} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{error}	& Discard the atom, and announce that the
		  atom is in error.
\end{tabular}
\end{indpar}

Some example number atom tables are:

~~{\tt hex number} atom table (for integers):

\begin{indpar}\begin{verbatim}
"0x0"   begin digit
"0x1"   begin digit
. . . . . . . . . .
"0xF"   begin digit
"0"     continue digit
"1"     continue digit
. . . . . . . . . .
"F"     continue digit
"l"     end
"u"     end
. . . . . . . . . .
"UL"    end
\end{verbatim}\end{indpar}

~~{\tt number} atom table:

\begin{indpar}\begin{verbatim}
"0"     digit
"1"     digit
. . . . . . . . . .
"9"     digit
"."     point
"E0"    begin exponent
"E1"    begin exponent
. . . . . . . . . .
"E+0"   begin exponent
"E+1"   begin exponent
. . . . . . . . . .
"e-9"   begin exponent
"0"     exponent digit
"1"     exponent digit
. . . . . . . . . .
"9"     exponent digit
"l"     integer end
"f"     floating end
"L"     integer end
"F"     floating end
\end{verbatim}\end{indpar}

\subsection{String Atom Tables}

A `{\em qualifier}$^\star$ {\tt string}' state behaves just like
an {\tt identifier} state, with `{\tt identifier}' replaced
by `{\tt string}', except that if the remaining input does not begin with
a recognized atom, the first UTF-8 character sequence of the remaining input
is accumulated, and the state does not change.
If the first character of the remaining input is not part of a legal
UTF-8 sequence, that character is discarded and announced as an error,
and the state does not change.
Thus {\tt end} atoms must be used
to end a {\tt string} scan state.

\subsection{Comment Atom Tables}

A `{\em qualifier}$^\star$ {\tt comment}' state behaves just like
a {\tt string} state, with `{\tt string}' replaced
by `{\tt comment}', except that when the scanner leaves a comment
state the accumulated string is discarded, and \underline{not}
made into a lexeme.

\subsection{Whitespace Atom Tables}

A `{\em qualifier}$^\star$ {\tt whitespace}' state behaves just like
a {\tt comment} state, with `{\tt comment}' replaced
by `{\tt whitespace}', except that when the remaining input does not begin
with a recognized atom, input is rejected, and the scanner
switches to {\tt lexeme} state.  When the scanner leaves a {\tt whitespace}
state the accumulated string is discarded, and \underline{not}
made into a lexeme.

\subsection{Error Atom Tables}

A `{\em qualifier}$^\star$ {\tt error}' state behaves just like
a {\tt whitespace} state, with `{\tt whitespace}' replaced
by `{\tt error}', except that 
when the scanner leaves an {\tt error}
state the accumulated string, which is discarded, is announced as an error.

\subsection{Lexeme Table Definitions}

Lexeme tables for the standard lexical scanner are written in
the \key{Lexeme Definition Language}.  This language defines
a {\em lexical-groups} that are sets of lexical atom tables.
These groups can be referenced from code when the currently effective
set of lexical atom tables needs to be changed.

Lexeme Definition Language consists of {\em lexical-definitions} with
the following syntax:

\begin{center}
\begin{tabular}{rrl}
\emkey{lexical-definition}
	& ::= & {\em lexical-units-block} \\
	& $|$ & {\em lexical-atom-table-definition} \\
	& $|$ & {\em lexical-class-definition} \\
	& $|$ & {\em lexical-group-definition}
\\[1ex]
\emkey{lexical-units-block} & ::= &
	{\tt begin lexical units;}\\
	& &  ~~~~{\em lexical-unit-definition}$^\star$ \\
	& & {\tt end lexical units;}
\\[1ex]
\emkey{lexical-unit-definition} & ::= &
	{\tt "}{\em lexical-unit-name}{\tt "} \underline{\tt ::=} \\
	& & ~~~~{\em lexical-unit} \{ {\tt |} {\em lexical-unit} \}$^\star$
	    {\tt ;}
\\[1ex]
\emkey{lexical-unit-name} & ::= & {\tt <}\{{\em letter}$|${\tt -}\}$^+${\tt >}
\\[1ex]
\emkey{lexical-unit} & ::= & {\em quoted-string}
\\[1ex]
\emkey{lexical-atom-table-block} & ::= &
	{\tt begin} {\em lexeme-type}
		    \begin{tabular}[t]{@{}l@{}}
		    {\tt atom table} \\
		    {\em lexical-options}{\tt ;}
		    \end{tabular}\\
	& &  ~~~~{\em lexical-atom-table-entry}$^\star$ \\
	& & {\tt end} {\em lexeme-type} {\tt atom table;}
\\[1ex]
\emkey{lexical-options} & ::= & {\em empty} $|$ {\tt ( )} \\
			& $|$ & {\tt (} {\em lexical-option}
				       \{ {\tt ,} {\em lexical-option} \}
			               {\tt )}
\\[1ex]
\emkey{lexical-option} & ::= & \ttkey{discard} $|$ \ttkey{continue}
					       $|$ \ttkey{announce}
					       $|$ \ttkey{atomic} \\
		       & $|$ & {\em lexical-type}
\\[1ex]
\emkey{lexical-atom-table-entry}
	& ::= & see page \pageref{LEXICAL-ATOM-TABLE-ENTRY}
\\[1ex]
\emkey{lexical-class-definition}
	& ::= & {\tt lexical} {\em lexical-class} {\tt class}
				    {\em lexical-options}{\tt ;}
\\[1ex]
\emkey{lexical-class} & ::= & {\em identifier}
\\[1ex]
\emkey{lexical-group-definition}
	& ::= & \begin{tabular}[t]{@{}l@{}}
	        {\tt lexical} {\em lexical-group} {\tt group} \\
		~~~~ {\tt (} {\em lexeme-type} \{ {\tt ,} {\em lexeme-type} \}
		         {\tt );}
		\end{tabular}
\\[1ex]
\emkey{lexical-group} & ::= & {\em lexeme-type}
				    
\end{tabular}
\end{center}

A \emkey{lexical-unit} is a set of strings.  Definitions of
lexical units may \underline{not} be recursive.

{\em Lexical-units} appear inside quoted strings.  A
{\em lexical-unit-name} appearing after a {\tt ::=} in a
{\em lexical-unit-definition}, or appearing anywhere in a
{\em lexical-atom-table-entry}, is
\ikey{replaceable}{lexical-unit-name@{\em lexical-unit-name}}.
The replacements for such a {\em lexical-unit-name} are the
strings in the set of the named {\em lexical-unit}.

Each entry or definition containing replacable {\em lexical-unit-name}
is expanded to a separate copy for each replacement of the name.
If a single name appears twice, it is replaced by the same string in
each occurrence.  If two or more different names appear,
every combination of replacements generates another copy of the
entry or definition.

Thus

\begin{indpar}\begin{verbatim}
begin lexical units;
    <digit> ::= "0" | "1";
    <sign>  ::= "+" | "-";

    <doubled-digit> ::= "<digit><digit>";

    <one-digit>  ::= "<digit>";
    <two-digits> ::= "<one-digit><digit>";
end lexical units;
\end{verbatim}\end{indpar}

is equivalent to

\begin{indpar}\begin{verbatim}
begin lexical units;
    <digit> ::= "0" | "1";

    <doubled-digit> ::= "00" | "11";

    <one-digit>  ::= "0" | "1";
    <two-digits> ::= "00" | "01" | "10" | "11";
end lexical units;
\end{verbatim}\end{indpar}

and

\begin{indpar}\begin{verbatim}
begin lexeme atom table;
    "<digit><digit>"  double number "D<digit>";
    "<digit>"         number;
end lexeme atom table;
\end{verbatim}\end{indpar}

is equivalent to

\begin{indpar}\begin{verbatim}
begin lexeme atom table;
    "00"              double number "D0";
    "11"              double number "D1";
    "0"               number;
    "1"               number;
end lexeme atom table;
\end{verbatim}\end{indpar}

Lexical atoms and their translations in the lexical atom tables
are all required to be complete legal UTF-8 character strings.
As a consequence, all recognized atoms will be such, and it will
not matter whether the lexical analyzer actually uses 8-bit bytes
or 16-bit UNICODE characters in its implementation.

A {\em lexical-definition-block} does not change lexical tables
until after it itself is completely scanned.  Then it adds to the current
tables any {\em lexical-atom-entries} it has defined.  These may replace
previous entries with the same atom.  Similarly {\em lexical-unit-names}
may be given new definitions.
The identifier `\ttkey{remove}' may be used as a {\em lexical-atom-type}
in a new {\em lexical-atom-entry} to cause an atom to be removed from
a table.  Similary a {\em lexical-unit-name} definition may be removed
by making it equal to {\tt "<remove>"}.

A {\em lexical-definition-block} changes
the processing of all lexemes scanned after it, until the end of the
program block containing the {\em lexical-definition-block}.  The
initial definition of lexical tables for any program is provided
by a {\em lexical-definition-block} in a separate file; and this
in turn is scanned using the standard lexical atom tables defined
in Appendix~\secref{STANDARD-LEXICAL-ATOM-TABLES}.

\section{Parsing}

\newpage

\appendix

\section{Standard Lexical Atom Tables}
\label{STANDARD-LEXICAL-ATOM-TABLES}

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<letter>" ::= "A" | "B" | "C" | "D" | "E" | "F" | "G"
                 | "H" | "I" | "J" | "K" | "L" | "M"
                 | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
                 | "U" | "V" | "W" | "X" | "Y" | "Z"
                 | "a" | "b" | "c" | "d" | "e" | "f" | "g"
                 | "h" | "i" | "j" | "k" | "l" | "m"
                 | "n" | "o" | "p" | "q" | "r" | "s" | "t"
                 | "u" | "v" | "w" | "x" | "y" | "z" ;
    "<non-zero-digit>" ::=       "1" | "2" | "3" | "4"
                        | "5" | "6" | "7" | "8" | "9" ;
    "<digit>" ::= "0" | "<non-zero-digit>" ;
    "<oct-digit>" ::= "0" | "1" | "2" | "3"
                    | "4" | "5" | "6" | "7" ;
    "<hex-digit>" ::= "A" | "B" | "C" | "D" | "E" | "F"
                    | "a" | "b" | "c" | "d" | "e" | "f"
                    | "<digit>" ;
    "<operator>" ::= "!" | "%" | "^" | "&" | "*"
                   | "(" | ")" | "-" | "+" | "="
                   | "{" | "}" | "|" | "~" | "["
                   | "]" | ";" | ":" | "<" | ">"
                   | "?" | "," | "/" | "/" | "->"
                   | "++" | "--" | ".*" | "->*" | ">>"
                   | "<<" | "<=" | ">=" | "==" | "!="
                   | "&&" | "||" | "*=" | "/=" | "%="
                   | "+=" | "-=" | "<<=" | ">>=" | "&="
                   | "^=" | "|=" | "::" ;
    "<whitespace>" ::= " " | "\t" | "\n" | "\r"
                     | "\f" | "\v" ;
end lexical units;
    
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<control>" ::=          "\001" | "\002" | "\003"
                  | "\004" | "\005" | "\006" | "\007"
                  | "\010" 
                                    | "\016" | "\017"
                  | "\020" | "\021" | "\022" | "\023"
                  | "\024" | "\025" | "\026" | "\027"
                  | "\030" | "\031" | "\032" | "\033"
                  | "\034" | "\035" | "\036" | "\037"
                  | "\177" ;

    "<oct1>" ::= "<oct-digit>";
    "<oct2>" ::= "<oct-digit><oct1>";
    "<oct3>" ::= "<oct-digit><oct2>";
    "<oct4>" ::= "<oct-digit><oct3>";
    "<oct5>" ::= "<oct-digit><oct4>";
    "<oct6>" ::= "<oct-digit><oct5>";
    "<oct-char>" ::= "\\<oct1" | "\\<oct2>"
                   | "\\0<oct2>" | "\\1<oct2>"
                   | "\\2<oct2>" | "\\3<oct2>";
    "<bad-oct-char>" ::= "\\4<oct2>" | "\\5<oct2>"
                       | "\\6<oct2>" | "\\7<oct2>"
                       | "\\<oct3>";
    "<oct-wchar>" ::= "<oct-char>"
                    | "\\<oct3>" | "\\<oct4>"
                    | "\\<oct5>" | "\\0<oct5>"
                    | "\\1<oct5>";
    "<bad-oct-whar>" ::= | "\\2<oct5>" | "\\3<oct5>"
                         | "\\4<oct5>" | "\\5<oct5>"
                         | "\\6<oct5>" | "\\7<oct5>"
                         | "\\<oct6>";
end lexical units;
    
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<hex1>" ::= "<hex-digit>";
    "<hex2>" ::= "<hex-digit><hex1>";
    "<hex3>" ::= "<hex-digit><hex2>";
    "<hex4>" ::= "<hex-digit><hex3>";
    "<hex5>" ::= "<hex-digit><hex4>";
    "<hex-char>" ::= "\\x<hex1>" | "\\x<hex2>"
                   | "\\X<hex1>" | "\\X<hex2>";
    "<bad-hex-char>" ::= "\\x<hex3>" | "\\X<hex3>";
    "<hex-wchar>" ::= "<hex-char>"
                   | "\\x<hex3>" | "\\x<hex4>"
                   | "\\X<hex3>" | "\\X<hex4>";
    "<bad-hex-wchar>" ::= "\\x<hex5>" | "\\X<hex5>";

    "<backslash-char>" ::= "<oct-char>" | "<hex-char>";
    "<backslash-wchar>" ::= "<oct-wchar>" | "<hex-wchar>";
    "<bad-backslash-char>" ::= "<bad-oct-char>"
                             | "<bad-hex-char>";
    "<bad-backslash-wchar>" ::= "<bad-oct-wchar>"
                              | "<bad-hex-wchar>";

    "<integer-suffix>" ::= "u" | "U" | "l" | "L"
                         | "ul" | "Ul" | "uL" | "UL"
                         | "lu" | "Lu" | "lU" | "LU";
    "<floating-suffix>" ::= "f" | "F" | "d" | "D";

    "<backslash-control>" ::= "\\f" | "\\v" | "\\n" | "\\r"
                            | "\\t" | "\\b" | "\\a" | "\\?"
                            | "\\\'" | "\\\"" | "\\\\";
end lexical units;
    
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin lexeme atom table;
    "<operator>"        operator;
    "<separator>"       separator;
    "<letter>"          identifier;
    "0x<hex-digit>"     hex number;
    "0X<hex-digit>"     hex number;
    "0<oct-digit>"      oct number;
    "<non-zero-digit>"  number;
    ".<digit>"  	number;
    "L'"                wide char string;
    "'"                 char string;
    "L\""               wide quoted string;
    "\""                quoted string;
    "//"                "//" comment;
    "/*"                "/*" comment;
    "<whitespace>"      whitespace;
end lexeme atom table;

// Note that C/C++ keywords are identifiers.
//
begin identifier atom table;
    "<letter>"  accept;
    "_"         accept;
    "<digit>"   continue;
    "<control>" error;
end identifier atom table;
    
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin hex number atom table;
    "<hex-digit>"       continue digit;
    "0x<hex-digit>"     begin digit;
    "0X<hex-digit>"     begin digit;
    "<integer-suffix>"  end;
    "<control>"         error
end hex number atom table;
 
begin oct number atom table;
    "<oct-digit>"       continue digit;
    "0"                 begin digit;
    "<integer-suffix>"  end;
    "<control>"         error
end oct number atom table;
 
begin number atom table;
    "<digit>"           digit;
    "."                 point;
    "e<sign><digit>"    begin exponent;
    "E<sign><digit>"    begin exponent;
    "<digit>"           exponent digit;
    "<integer-suffix>"  integer end;
    "<floating-suffix>" floating end;
    "<control>"         error
end number atom table;
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
 
begin quoted string atom table;
    "\""                    begin;
    "\""                    end;
    "<backslash-control>"   continue  "<char backslash-control>";
    "<backslash-char>"      continue  "<char backslash-char>";
    "<bad-backslash-char>"  error;
    "<control>"             error;
end quoted string atom table;
 
begin wide quoted string atom table;
    "L\""                   begin;
    "\""                    end;
    "<backslash-control>"   continue  "<char backslash-control>";
    "<backslash-wchar>"     continue  "<char backslash-wchar>";
    "<bad-backslash-wchar>" error;
    "<control>"             error;
end quoted string atom table;
 
begin char string atom table;
    "\'"                begin;
    "\'"                end;
    . . . rest just like quoted string table . . .
end char string atom table;
 
begin wide char string atom table;
    "L\'"               begin;
    "\'"                end;
    . . . rest just like wide quoted string table . . .
end char string atom table;

\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
 
begin whitespace atom table;
    " "                     accept;
    "\t"                    accept;
    "\n"                    accept;
    "\f"                    accept;
    "\v"                    accept;
    "<control>"             error;
end whitespace atom table;
 
begin "//" comment atom table;
    "//"                    begin;
    "\n"                    end;
end "//" comment atom table;
 
begin "/*" comment atom table;
    "/*"                    begin;
    "*/"                    end;
end "*/" comment atom table;

\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
