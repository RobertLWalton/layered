% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}
\usepackage{pictex}
\usepackage{upquote}
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newsavebox{\LAQUOTEBOX}
\begin{lrbox}{\LAQUOTEBOX}
{\tt \guillemotleft}
\end{lrbox}
\newcommand{\LAQUOTE}{\usebox{\LAQUOTEBOX}}

\newsavebox{\RAQUOTEBOX}
\begin{lrbox}{\RAQUOTEBOX}
{\tt \guillemotright}
\end{lrbox}
\newcommand{\RAQUOTE}{\usebox{\RAQUOTEBOX}}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttilkey}[3]{\TT{#1}\index{#2@{\tt #2}!#3@{\tt #3}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@{\tt [#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@{\tt [#1]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minlkey}[2]%
           {\TT{min::#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                          \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \vspace*{-15ex}
	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

June 21, 2015
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{5.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A C level language with facilities for writing
	  C++ like libraries and strongly type checking their
	  usage but not their implementation.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& The L-Language plus libraries.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& An interpreted/compiled language extending the
	  M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

There are a few fundamental principals that inform the design
of these languages:

\begin{indpar}
\key{Syntax Hypothesis}~~~~ People reason syntactically
rather than semantically, so language syntax is very important,
and the ability to extend syntax to support
new library functionality is very important.

\key{Type Checking Segregation Hypothesis}~~~~ A strongly typed
completely capable language is impossible.  What is possible is
to segregate code into small inline library functions that are not
type checkable, while code that uses these functions is
strongly type checkable.

\key{Distrubuted Modularity}~~~~ 
Enhancements made by non-communicating users can be fit together
without too much labor.
\end{indpar}

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `\TT{hello}', `\TT{+}', `\TT{;}',
`\TT{9.200}' are four lexemes.

The lexical scanner is written in the M-Language and can be
replaced.\footnote{As of 2015 the scanner is actually written
in C++.}  This section describes the standard scanner which
is driven by the lexical tables and is capable of scanning
lexemes of common languages such as C and C++.

The standard scanner attempts to be both machine and human
efficient.  It attempts to be \key{machine efficient} by being
deterministic\footnote{Unlike regular expression scanners.}
and attempts to be \key{human efficient} by supporting algorithms
that people can readily understand and hopefully quickly
learn to mimic.\footnote{A possibly non-verifiable goal.}

The standard scanner also tries to promote `\key{distrubuted modularity}',
meaning that enhancements made by non-communicating users are
more likely to fit together.

The standard scanner operates on an input stream of 32-bit
UNICODE characters.  Each character is associated with
a position value that specifies from where the character
came.  For example, a position value may encode a file name,
line-within-file number, and column-within-line number.\footnote{
Currently positions encode a byte-within-line number from which the
column-within-line number may be derived.}
The standard scanner identifies a lexeme as a consecutive sequence
of input stream UNICODE 32-bit characters with
corresponding consecutive position values.

The standard scanner also produces a translation of each
lexeme.  This may just be a copy of the 32-bit characters
in the lexeme, or it may have some changes, or `translations',
of some of these characters.  For example, the lexeme
\TT{"a line<LF>"} may have a translation that omits the
\TT{"}'s and converts the four characters \TT{<LF>} into
a single linefeed character.

When the standard scanner identifies a lexeme it also identifies
a `\mkey{type}{of lexeme}' for the lexeme.
For example, the lexeme \TT{9.35} may have type `\TT{numeric}'
while the lexeme \TT{"abc"} may have the type `\TT{quoted string}'.

At its most fundamental level the
standard scanner identifies lexical atoms in the input text.
A \key{lexical atom} is a single character (e.g., the letters
in an identifier or word), a short string of characters
(e.g., the 4-character atom \TT{<LF>} in a quoted string),
or in some cases a longer string of characters containing
a repetition of characters from some character set (e.g., an arbitrarily
long string of hexadecimal digits).

Lexical atoms are read left to right and
grouped by the scanner into \skey{lexeme}s.
Lexical atoms are the unit of backup in the scanner; recognition
of a lexical atom can fail after some number of characters, but
once it is recognized, the scanner cannot back up past a lexical atom.
This permits limited look ahead in lexical scanning.  For example,
in some application
the string \TT{<LF>X} may begin with the lexical atom \TT{<LF>},
while the string \TT{<LFX} may begin with the lexical atom \TT{<}.
However, the syntax of lexical atom patterns is simple, so such
look ahead is limited.  Also, in most cases actual
lexical atoms are very short, and actual backup is rare.

Each atom is translated individually to produce an
\key{atom translation}.  Just as the sequence of atoms in a lexeme
comprise the lexeme, the sequence of their atom translations
comprises the translation of the lexeme.  Most atoms translate
to themselves.  An atom translation
may be the empty string, in effect omitting the atom from the
lexeme translation.  For example, the lexeme \TT{"x"} might
consist of three atoms, the first and last of which are \TT{"}
and translate into the empty string, whereas the middle atom
\TT{x} translates to itself.  Similarly \TT{"<LF>"} might also
consist of three atoms, with the middle atom \TT{<LF>} translating
to a single line feed character.

The scanner has a state containing a current point 
in the input UNICODE character stream,
a \key{current lexical table} identifier, a \key{current lexeme type}
which may be `\TT{none}', a \key{return stack}
of lexical table identifiers, and a \key{translation buffer} holding
translations of atoms.  A
\key{lexical table} is a set of atom patterns
that match atoms, and for each pattern an
\ikey{instruction}{lexical}
that determines what to do when the pattern is matched.
There is also a \key{default instruction} associated with
the lexical table that
determines what to do when no table pattern matches the next characters
in the input stream.

Most \skey{atom pattern}s\index{pattern!lexical atom} are fixed
length sequences of character patterns that match any sequence of
input characters of the same length as the atom pattern
if each input character of the sequence matches the corresponding
character pattern.  A \key{character pattern} is simply a
specification of a set of characters, e.g., letters or digits.
Thus one can construct an atom pattern that will recognize
single letters, or one that will recognize the sequence of
characters such as the 4-character sequence \TT{<LF>} which matches
the atom pattern \TT{"<" "LF" ">"}
(in which the quoted string has been broken into three parts to prevent
\TT{<LF>} being treated as representing a single line feed character)
or the 4-character sequence \TT{<0a>} which matches the atom pattern
\begin{center}
\TT{"<0<hex-digit>{}>"}
\end{center}
where \TT{<hex-digit>} names a character pattern matching characters
in the ranges \TT{0-9} and \TT{A-F}.

Atom patterns can also contain the special indicator
\TT{<repeat>} that allows an immediately preceding character pattern
to be repeated zero or more times.  Thus the pattern
\begin{center}
\TT{"<hex-digit><hex-digit><repeat>"}
\end{center}
recognizes any sequence of 2 or more \TT{<hex-digit>}'s.

The atom patterns of a single lexical table must not conflict:
no character string can be recognized by two atom patterns of the
same lexical table.  However, a shorter atom pattern in a
table may match the initial segment of an atom matched by a longer
atom pattern in the table, in which case the longer pattern is
used for the atom.

The scanner operates by identifying the
longest sequence of characters beginning at the current input character
stream point that matches an atom pattern of the current lexical table.
This sequence of characters becomes
the next atom, and an instruction associated with its matching
atom pattern is then executed.  If no atom pattern can be matched,
the default instruction associated with the lexical table is executed instead.

A single lexical table instruction can do many things.
It can optionally reduce the length of a matched atom,
translated the matched atom to a different character string,
replace the matched atom and its translation,
or change the current lexical table.
An instruction can fail if the atom cannot be replaced or the
translated atom does not match a given pattern.
An \key{instruction group} is a sequence of instructions
such that the first successful instruction will be the effective
instruction in the group.  An instruction group, instead of a single
instruction, may be associated with an atom pattern or be the default
instruction of a lexical table.


There are four kinds of lexical tables:
\mkey{master}{lexical table} tables,
\mkey{lexeme}{lexical table} tables,
\mkey{sublexeme}{lexical table} tables, and
\mkey{atom}{lexical table} tables.
Master tables are used to dispatch to lexeme or sublexeme tables which
typically recognize lexemes.  Atom tables are used
to recognize atoms whose patterns are logically the union
of a finite set of patterns.

Thus a simple scanner might have
one master table that dispatches to different lexeme tables,
one to recognize identifiers, one to recognize numbers, one to
recognize whitespace, and one to recognize comments.

Lexeme tables have \ikey{types}{type!of lexeme table}.
When the current lexical table becomes a lexeme table,
the current lexeme type is set equal to the type of that table.
The `\TT{output} {\em type}' and `\TT{output none}'
instruction components can also be
used to change the current lexeme type.

Sublexeme tables are just like lexeme tables except they
have no associated type and do not reset the current lexeme type.

Upon finishing the execution of an instruction, if the
current lexical table is a master table,
the currently accumulated lexeme is output
with the current lexeme type, if that is not `\TT{none}', or the
currently accumulated lexeme is discarded if the current lexeme
type is `\TT{none}'.
The current lexeme type is reset to `\TT{none}' whenever
the current lexical table becomes a master table.

Thus if a lexeme table of
type `\TT{whitespace}' cannot recognized any atom and
the default instruction associated with it
changes the current lexical table to a master table,
the lexeme accumulated so far will
be output as a lexeme of type `\TT{whitespace}'.

When it is between lexemes the current lexical table in the scanner state
is always a master table.  Master tables correspond to lexical
contexts.  A well designed language has only one main master
table, plus a few small master tables to handle error situations
such as premature end-of-file;
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.
Legacy languages
may have more master tables: C/C++ has several to handle
special lexical scanning of preprocessing lexemes;
see Appendix \itemref{C++-LEXICAL-PROGRAM}.

The standard scanner can report errors in one of two ways.  It may
simply output a lexeme with a type that indicates an error.  For
example, the character \TT{\textbackslash} appearing outside a quoted string
might be returned as a 1-character lexeme of type `\TT{misplaced
character}'.  Alternatively a single atom may be reported as an
error of a given type without interrupting the normal operation
of the scanner.  For example, if \TT{<H>} appears in a quoted
string, it may be reported as an erroneous atom of type
`\TT{unrecognized escape}'.  Otherwise this atom will be processed
normally; it might, for example, be omitted from the lexeme
translation or be represented in that translation by the Unicode
Replacement Character (hex code \TT{FFFD}).

The algorithm for scanning a lexeme is given on page
\pageref{LEXICAL-SCANNING-ALGORITHM}.

\begin{figure*}[!p]
\begin{center}
\begin{tabular}{l}
To scan a lexeme: \\
~~~~\begin{tabular}[t]{l}
    input: \begin{tabular}[t]{l}
           \TT{current} \TT{lexical} \TT{table} which must be a
	       \TT{MASTER} table \\
           \TT{input position} in input UNICODE character stream \\
           \end{tabular} \\
    set \TT{current} \TT{lexeme} \TT{type} = \TT{NONE} \\
    make \TT{return} \TT{stack} empty \\
    make \TT{translation} \TT{buffer} empty \\
    loop: \\
    ~~~~\begin{tabular}[t]{l}
        if \begin{tabular}[t]{l}
	   \TT{current} \TT{lexical} \TT{table} is a \TT{MASTER} table and  \\
           ~~~~~~~~\TT{current} \TT{lexeme} \TT{type} is \underline{not}
	       \TT{NONE}: \\
	   \end{tabular} \\
        ~~~~~~~~terminate loop \\
        if \TT{current} \TT{lexical} \TT{table} is a lexeme table: \\
        ~~~~~~~~set \TT{current} \TT{lexical} \TT{lexeme} \TT{type} to the
	        lexeme table type \\
        find the longest atom beginning at the \TT{input} \TT{position} \\
        ~~~~~~~~that matches an atom pattern in the \TT{current} \TT{lexical}
	        {table}, if any \\
        if an atom was found: \\
        ~~~~\begin{tabular}[t]{l}
            copy the atom to the end of the \TT{translation} \TT{buffer} \\
	    ~~~~and update the \TT{input position} to point after the atom \\
            execute the \TT{instruction} associated with the atom
	        pattern used \\
	    ~~~~(the simplest \TT{instruction} is `\TT{accept}' which does
	        nothing) \\
            \end{tabular} \\
	else: \\
	~~~~\begin{tabular}[t]{l}
	    execute the \TT{default instruction} associated with \\
	    ~~~~the \TT{current} \TT{lexical} \TT{table} \\
	    ~~~~(the simplest of these just change the
	     \TT{current} \TT{lexical} \TT{table})
            \end{tabular} \\
        \end{tabular} \\
    output: \begin{tabular}[t]{l}
            a lexeme consisting of the \TT{translation} \TT{buffer} contents \\
	    ~~~~(which may be empty) \\
	    ~~~~with the \TT{current} \TT{lexeme} \TT{type} as its type \\
	    ~~~~(which may \underline{not} be \TT{NONE}) \\
            the \TT{current} \TT{lexical} \TT{table}
	        (which is a \TT{MASTER} table) \\
            the \TT{input} \TT{position} (which has moved to just after
	        the lexeme) \\
            \end{tabular}
    \end{tabular}
\end{tabular}
\end{center}
\label{LEXICAL-SCANNING-ALGORITHM}
\end{figure*}


A single \mkey{instruction}{in lexical program} can do the following:
\begin{itemize}
\raggedright
\item invoke an atom table to replace the matched atom and translate it
\item reduce the length of the matched atom (before it is copied to the
      \TT{translation} \TT{buffer}) (the length can be reduced to \TT{0})
\item translate the reduced length atom in the \TT{translation} \TT{buffer}
to a different character string
(otherwise the translation of an atom is a copy of the atom)
\item make instruction success conditional
      on the translated atom matching an atom pattern
\item announce the reduced length (untranslated) atom
      as an erroneous atom of a given type
\item change the \TT{current} \TT{lexeme} \TT{type} (the type can be changed
      to \TT{NONE})
\item change the \TT{current} \TT{lexical} \TT{table} - optionally the previous
      table ID can be pushed into the \TT{return} \TT{stack},
      or optionally the
      new table ID can be popped from this stack
\item force the atom table that contains the instruction
      to fail to match any atom
\end{itemize}

Details and examples are given in the next section.


\subsection{Lexical Programs}

A \key{lexical program} is a set of character pattern definitions
and lexical tables.  A lexical program can include another lexical program.
The top level lexical program must begin with a master
table that serves as the initial lexical table.

The lexemes of a lexical program
are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes single space) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::=
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe}, \\
    and \TT{Pf}; includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{ASCII-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em ASCII-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of white-space characters (single space, horizontal tab, form
feed, etc.), but is not itself a lexeme:
\begin{indpar}
\emkey{white-space} ::= {\em horizontal-space} $|$ {\em vertical-space}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal.
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::=
    \begin{tabular}[t]{l}
    {\em horizontal-space-character}, other than \\ single space
    \end{tabular}
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= {\em vertical-space-character}
	other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::=
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} \\
    or {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::=
    \begin{tabular}[t]{l}
    UNICODE character with no UNICODE category or \\
    with a category not mentioned above
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} is only illegal inside a {\em quoted-string},
but the other three sequences are illegal everywhere.  When illegal
these strings generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing special, aside from generating
warning messages.  If the warning messages are turned off, these
sequences can be included in {\em quoted-strings} and {\em comments}
just like other characters can be included.

The line number and beginning column of each input character is
recorded for use in error messages.  The line number is 1 plus the
number of {\em line-feeds} preceeding the character.  The column
number of a character is the sum of the columns taken by all the
characters between the first {\em vertical-space} preceeding the
character (or beginning of input if there is no {\em vertical-space})
and the character.
Characters in UNICODE subcategories \TT{Mn} (combining marks)
and \TT{Me} (enclosing marks),
and {\em control-characters} that are not
{\em horizontal-space-characters} take zero columns.  All other characters
take one column, except for horizontal tab, which takes from
1 to 7 columns, with tabs being set every 8 columns in the line,
so the column number of the character after a horizontal tab
is always divisible by 8.

Lexemes are tagged with the line number and column of their first
character and of the first character after the lexeme (which may be
an imaginary end-of-file character after the end of the input).

Note that line numbers begin at 1 while column numbers begin at 0.

The beginning column of the first
lexeme on a line is also used syntactically to determine
indentation.  Line numbers are used syntactically to identify line ends
and blank lines.

The lexemes in a lexical program are specified on page
\pageref{LEXEME-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see page \pageref{ILLEGAL-CHARACTERS}
above to account for such characters.

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.
{\em Comments} are treated as lexemes, but are discarded before the
lexeme stream is transmitted to the parser.

Consecutive quoted string lexemes are glued together if they are in the
same (possibly continued) line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence"
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" "LF" ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

A special {\em character-representative} can consist of
the UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{NBSP}.  There are three other cases:
\TT{<Q>} represents the doublequote \TT{"}, \TT{<NL>} (new line)
represents a line feed (same as \TT{<LF>}), and \TT{<UUC>} represents
the `unknown UNICODE character' which in turn is used to represent
illegal UTF-8 character encodings.

A special {\em character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

\begin{figure*}[!p]
\begin{indpar}

\emkey{lexeme}
	::= {\em word} $|$ {\em mark} $|$ {\em number}
	$|$ {\em separator}
	$|$ {\em quoted-string}
	$|$ {\em comment}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::=
	\begin{tabular}[t]{l}
	{\em lexical-item} \\
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme} containing a {\em letter} before any
                  {\em digit}
\\[0.5ex]
\emkey{natural} :::= {\em ASCII-digit}\PLUS{} not beginning with \TT{0}
                     $|$ \TT{0}
\\[0.5ex]
\emkey{numeric} :::= {\em middle-lexeme} containing a {\em digit}
                     before any {\em letter}, but \underline{not} a
		     {\em natural}
\\[0.5ex]
\emkey{number} :::= {\em natural} $|$ {\em numeric}
\\[0.5ex]
\emkey{mark} :::= {\em middle-lexeme} that is not a {\em word},
		  {\em natural}, or {\em numeric}
\\[1ex]
\emkey{comment} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\label{COMMENT}

\end{indpar}
\label{LEXEME-PROGRAM-LEXEMES}
\end{figure*}

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item} `\TT{\$\$4,987,,::}' yields the
{\em leading-separator} `\TT{\$\$}', the {\em middle-lexeme} `\TT{4,987}',
and the three {\em trailing-separators} `\TT{,}' `\TT{,}' and `\TT{::}'.%
\footnote{It is possible to use a strictly left to right scan with
backup over lexical atoms to perform
the right to left removal of {\em trailing-separators} from a
{\em lexical-item}, by recoginzing a sequence of
{\em trailing-separator-characters}
as an atom that is backed up over and rescanned:
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.}

The syntax of a lexical program is specified on
\pagref{LEXEME-PROGRAM-SYNTAX-1} and
\pagref{LEXEME-PROGRAM-SYNTAX-2}.

\begin{figure*}[!p]
\begin{indpar}
\emkey{name} ::= 
	\{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}\STAR{}
	{\em word}
	\{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}\STAR{}
\\[0.3ex]
\emkey{lexical-program} ::=
        \begin{tabular}[t]{@{}l@{}}
	\TT{begin} {\em program-name} \TT{lexical program;}\\
	~~~~{\em lexical-program-unit}\STAR{} \\
	\TT{end} {\em program-name} \TT{lexical program};
	\end{tabular}
\\[0.3ex]
\emkey{program-name} ::= {\em name}
\\[0.3ex]
\emkey{lexical-program-unit}
        \begin{tabular}[t]{@{}rl@{}}
	::= & {\em cpat-definition} \\
	$|$ & {\em lexical-table-definition} \\
	$|$ & {\em program-inclusion}
	\end{tabular}
\\[0.3ex]
\emkey{program-inclusion} ::= \TT{include} {\em program-name}
				  {\em remove-clause}\STAR{} \TT{;}
\\[0.3ex]
\emkey{remove-clause}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{remove} {\em lexical-table-name} \\
	$|$ & \TT{remove} \TT{"}{\em cpat-name}\TT{"}
	\end{tabular}
\\[2.0ex]
\hspace*{0.2in}
    {\bf Note:} `{\em cpat}\,' abbreviates `{\em character-pattern}\,'
\\[2.0ex]
\emkey{cpat-definition} ::=
	\TT{"}{\em cpat-name}\TT{"} \TT{=}
		{\em cpat-expression} \TT{;}
\\[0.3ex]
\emkey{cpat-name}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{<}{\em letter}\PLUS{}\{\TT{-}{\em letter}\PLUS{}\}\STAR{}%
	       \TT{>} \\
	    & but not \TT{<}{\em upper-case-ASCII-letter}\PLUS{}\TT{>}
	\end{tabular}
\\[0.3ex]
\emkey{special-cpat-name}
        \begin{tabular}[t]{@{}rl@{}}
	:::= & \TT{<UNICODE-}{\em category}\TT{>} \\
	 $|$ & \TT{<UNICODE-}{\em subcategory}\TT{>} \\
	 $|$ & \TT{<others>} \\
	\end{tabular}
\\[0.3ex]
\emkey{category} :::= UNICODE category, e.g., \TT{L} \\
\emkey{subcategory} :::= UNICODE subcategory, e.g., \TT{Lu}
\\[0.3ex]
\emkey{cpat-expression}
        \begin{tabular}[t]{@{}rl@{}}
	::= & {\em cpat-term} \{ \TT{|} {\em cpat-term} \}\STAR{} \\
        $|$ & {\em cpat-term} \{ \TT{\&} {\em cpat-term} \}\STAR{}
	\end{tabular}
\\[0.3ex]
\emkey{cpat-term} ::= {\em cpat-factor}
                  $|$ \TT{\textasciitilde} {\em cpat-factor}
\\[0.3ex]
\emkey{cpat-factor}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{"}{\em character-representative}\TT{"} \\
	$|$ & \TT{"}{\em character-representative}\TT{-}%
		    {\em character-representative}\TT{"} \\
	$|$ & \TT{"}{\em cpat-name}\TT{"} \\
	$|$ & \TT{(} {\em cpat-expression} \TT{)}
	\end{tabular}
\\[2.0ex]
\emkey{lexical-table-definition} ::=
        \begin{tabular}[t]{@{}l@{}}
	\TT{begin} {\em lexical-table-name}
		    {\em lexical-table-kind} \TT{table} \TT{;} \\
	~~~~{\em lexical-table-entry}\STAR{} \\
	~~~~{\em default-instruction-group} \\
	\TT{end} {\em lexical-table-name}
		 {\em lexical-table-kind} \TT{table} \TT{;}
	\end{tabular}
\\[0.3ex]
\emkey{lexical-table-kind} ::=
    \TT{master} $|$ \TT{lexeme} $|$ \TT{sublexeme} $|$ \TT{atom}
\\[0.3ex]
\emkey{lexical-table-name} ::=
    {\em name} except \TT{scan error} or \TT{none}
\end{indpar}
\label{LEXEME-PROGRAM-SYNTAX-1}
\end{figure*}

\begin{figure*}[!t]
\begin{indpar}
\emkey{default-instruction-group}
	::= {\em empty} $|$ {\em instruction-group}
\\[0.3ex]
\emkey{lexical-table-entry}
        \begin{tabular}[t]{@{}rl@{}}
	::= & {\em atom-pattern} {\em instruction-group} \TT{;} \\
	$|$ & {\em atom-pattern} \TT{;}
	\end{tabular}
\\[0.3ex]
\emkey{atom-pattern} ::= \TT{"}{\em atom-factor}\PLUS{}\TT{"}
\\[0.3ex]
\emkey{atom-factor} ::= {\em atom-primary} {\em repeat}\QMARK{}
\\[0.3ex]
\emkey{atom-primary} ::= {\em character-representative} $|$
                             {\em cpat-name} except {\em repeat}
\\[0.3ex]
\emkey{repeat} ::= \TT{<repeat>} $|$ \TT{<repeat-}{\em ASCII-digit}\PLUS{}\TT{>}
\\[0.3ex]
\emkey{instruction-group}
	::= {\em instruction}
	        \{ \TT{else} {\em instruction} \}\STAR{}
\\[0.3ex]
\emkey{instruction} ::= {\em instruction-component}\PLUS{}
\\[0.3ex]
\emkey{instruction-component}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{accept} \\
	$|$ & \TT{match} {\em atom-table-name} \\
	$|$ & \TT{keep} {\em natural-number} \\
	$|$ & \TT{translate to} {\em translation-string} \\
	$|$ & \TT{translate hex}
			{\em natural-number} {\em natural-number} \\
	$|$ & \TT{translate oct}
			{\em natural-number} {\em natural-number} \\
	$|$ & \TT{translate name}
			{\em natural-number} {\em natural-number} \\
	$|$ & \TT{require} {\em atom-pattern} \\
	$|$ & \TT{error} {\em type-name} \\
	$|$ & \TT{output} {\em type-name} \\
	$|$ & \TT{output} \TT{none} \\
	$|$ & \TT{goto} {\em master-table-name} \\
	$|$ & \TT{goto} {\em lexeme-table-name} \\
	$|$ & \TT{goto} {\em sublexeme-table-name} \\
	$|$ & \TT{call} {\em lexeme-table-name} \\
	$|$ & \TT{call} {\em sublexeme-table-name} \\
	$|$ & \TT{return} \\
	$|$ & \TT{fail} \\
	\end{tabular}
\\[0.3ex]
\emkey{type-name} ::= {\em name} except \TT{scan error} or \TT{none}
\\[0.3ex]
\emkey{atom-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{lexeme-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{sublexeme-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{master-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{translation-string} ::= {\em quoted-string}
\end{indpar}
\label{LEXEME-PROGRAM-SYNTAX-2}
\end{figure*}

An example lexical program that recognizes
whitespace and quoted strings is given
on \pagref{EXAMPLE-LEXEME-PROGRAM}.
\TT{<LF>} is the only {\em character-representative} recognized
in quoted strings by this example.

\begin{figure*}[!p]
\addtolength{\baselineskip}{-0.4ex}
\begin{indpar}\begin{verbatim}
begin example lexical program;

"<whitespace-char>" = " " | "<HT>"
                    | "<LF>" | "<VT>" | "<FF>";

begin main master table;
    "<whitespace-char>" goto whitespace;
    "<Q>" translate to "" goto quoted string;
    "<others>" output misplaced character;
    output end of file;
end main master table;

begin whitespace lexeme table;
    "<whitespace-char>" accept;
    goto main;
end whitespace lexeme table;

begin quoted string lexeme table;
    "<Q>" translate to "" goto main;
    "<LF>" keep 0 goto premature end of line;
    "<" "LF" ">" translate to "<LF>";
    "<others>" accept;
    goto premature end of file;
end quoted string lexeme table;

include premature tables;

end example lexical program;

begin premature tables lexical program;
    // Stuff to include.

begin premature end of line master table;
    "<LF>" output premature end of line
           goto main;
end premature end of line master table;

begin premature end of file master table;
    output premature end of file
           goto main;
end premature end of file master table;

end premature tables lexical program;
\end{verbatim}\end{indpar}
\label{EXAMPLE-LEXEME-PROGRAM}
\end{figure*}

A \emkey{lexical-program} consists of a sequence of units that are
{\em character-\EOL pattern-\EOL defi\-ni\-tions},
{\em lexical-\EOL table-\EOL defi\-ni\-tions},
or {\em program-inclusions}.  These respectively define character pattern sets
and lexical tables, and include lexical program units of
previously defined lexical programs.

\subsubsection{Lexical Program Inclusion}

A \emkey{program-inclusion} names a previously defined lexical program
whose units are to be included in the current lexical program
at the point of the {\em program-inclusion}.
There is a simple example of a program inclusion at the end of
the \TT{example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.
Identical definitions
may be repeated without error,
as can happen when one program includes two programs each of
which include the same third program.
A {\em program-inclusion} can have
\emsmkey{remove-clause}s{in {\em program-inclusion}}
each of which removes a named definition from the set of included
definitions.  This is the only way to resolve conflicts between
definitions.

\subsubsection{Character Pattern Definitions}

A \emkey{character-pattern-definition} (abbreviated as
\emkey{cpat-definition}) assigns a set of characters to a
{\em character-pattern-name}.  The latter is just a string of
letters and hyphens (\TT{-}) surrounded by angle brackets (\TT{< >})
with hyphens occurring only between letters.  Examples:
\TT{<digit>} and \TT{<line-break>}.  However, the
{\em character-pattern-name} defined by a {\em character-pattern-definition}
cannot contain only upper case letters, as this could conflict with
some {\em character-representative}
(some {\em special-character-pattern-names} which have builtin definitions do contain only upper case letters).

The character set is denoted by a \emkey{character-pattern-expression}.
The simplest character pattern
expression is just a single {\em character-representative} in quotes,
which denotes
the character set containing only the quoted character.  Examples:
\TT{"0"} and \TT{"+"}.
The next simplest is two {\em character-representatives}
separated by a hyphen (\TT{-}) denoting the character set consisting
of all characters in the range from the first to the second of the two
characters.  Examples: \TT{"0-9"} and \TT{"A-Z"}.  The characters
are ordered according to their 32 bit unsigned UNICODE value, and the
second of the two characters must not be smaller than the first.

A {\em character-representative} is a representative of a single UNICODE
character that can be used inside quotes (\TT{"}).
Most graphic UNICODE characters represent themselves.  Other characters
are represented by character sequences surrounded by the angle
brackets \TT{<} and \TT{>} (which are also the less than and
greater than signs).
For example, a line feed can be represented by any of the
following: \TT{<LF>}, \TT{<0A>},
\TT{<00A>}, \ldots, or \TT{<00000000A>}.

A quoted {\em character-pattern-name} denotes the character set associated
with that name by a \underline{previous} {\em character-pattern-definition},
or in the case of {\em special-character-pattern-names}, by one of the
following rules:
\begin{center}
\begin{tabular}{ll}
\TT{<UNICODE-$C$>} & all characters in UNICODE category $C$ \\
\TT{<UNICODE-$SC$>} & all characters in UNICODE subcategory $SC$ \\
\TT{<others>} & see page \pageref{<OTHERS>} \\
\end{tabular}
\end{center}

The \TT{|}, \TT{\&}, and \TT{\textasciitilde} operators and can be used to take
the union, intersection, and complements of character sets.  The complement
is relative to the universe of all 32 bit unsigned integer UNICODE
character codes.  Thus \TT{\textasciitilde "b-y"}
denotes the same character set as
\TT{"<0>-a"\,|\,"z-<0FFFFFFFF>"}.

Parentheses may be used in {\em character-pattern-expressions} as is
normal in algebraic expressions.
Note that the \TT{|} and \TT{\&} operators cannot be used together
in the same expression without intervening parentheses as neither
takes precedence over the other.  This is done to prevent ambiguity.

Some example {\em character-pattern-definitions} are:

\begin{indpar}[0.05in]\begin{verbatim}
"<hex-digit>" = "0-9" | "a-f" | "A-F";
"<non-line-break-char>" = ~ "<LF>" & ~ "<VT>" & ~ "<FF>";
"<quotable-char>" = "<020>-<07E>" & ~ "<Q>";
"<whitespace-char>" = " " | "<LF>" | "<VT>" | "<FF>" | "<HT>";
"<source-character>" =
    ( "<020>-<07E>" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";
\end{verbatim}\end{indpar}

Current implementations require that any two non-LATIN1 UNICODE
characters that have the same UNICODE subcategory, UNICODE name
(a.k.a. `abbreviation alias',
e.g., \TT{HT} or \TT{SOH} or \TT{NBSP}, or may be `missing'),
and UNICODE numeric value (e.g., \TT{3} or \TT{1/3}, or may be `missing'),
must be treated identically: that is, one is in a character pattern's set
if and only if the other is in the set.  This means that the
character pattern expression \TT{"<0FFFF>-<0FFFFFF>"} is not implemented,
for example, although \TT{"<0F>-<0FF>"} is implemented because it
involves only LATIN1 characters.

\subsubsection{Lexical Tables}

A {\em lexical-table-definition} specifies a {\em lexical-table-name},
the {\em lexical-table-kind} of the table,
a set of {\em lexical-table-entries}
each containing an {\em atom-pattern} and optionally an {\em instruction},
and an optional {\em default-instruction-group} that is executed when
no atom is recognized by any of the table entries.

The {\em lexical-table-kinds} are
\mkey{master}{lexical table kind},
\mkey{lexeme}{lexical table kind},
\mkey{sublexeme}{lexical table kind}, or
\mkey{atom}{lexical table kind}.
In a master table {\em atom-patterns} are typically associated
with \TT{goto} or \TT{call} instructions
that change the current table from the
master table to a lexeme or sublexeme table.
In a lexeme or sublexeme table {\em atom-patterns}
are typically associated with \TT{accept} instructions which
accept the matched atom as part of the current lexeme.  In a lexeme
or sublexeme
table the default instruction is typically a \TT{goto} or \TT{return}
back to a
master table, and because this changes the current lexical table
to a master table, it causes any accumulated lexeme
to be output with its lexeme type being the current lexeme type
if that is not `\TT{none}', or it causes any accumulated lexeme
to be discarded if the current lexeme type is `\TT{none}'.

Atom tables permit sets of atom patterns to be used in
several places without copying all the patterns.  Details are
on \pagref{ATOM-TABLE}.

The first master table in a lexical program
becomes the current lexical table when the scanner
is initialized.  This table is typically named `\TT{main}',
as it is in the \TT{example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.

A lexical table consists of {\em lexical-table-entries}%
\emindex{lexical-table-entry} each containing an {\em atom-pattern} and
an {\em instruc\-tion-group}.  The \emkey{atom-pattern} is matched against
the remaining input characters.  The pattern consists of a sequence
of {\em character-representatives}, each of which match only themselves,
and {\em character-pattern-names}, each of which match any character
in the named set of characters.  Thus
\begin{center}
\verb|"<0<hex-digit><hex-digit>>"|
\end{center}
matches 5-character atoms consisting of a \TT{<} followed by an
\TT{0} followed by two characters each in the character set
named by \TT{<hex-digit>} followed by a \TT{>}.
Note that this {\em atom-pattern}
only matches atoms that are 5 characters long.


The special character pattern name
\TT{<{others}>}%
\index{others@{\tt <others>}}%
\label{<OTHERS>}
can be used in an atom pattern to match any character not otherwise
matched.  More specifically, in the atom pattern
\TT{"}$P$\TT{<others>}$Q$\TT{"},
the pattern name \TT{<others>} matches any characters not matched by
any other character pattern $C$ that is in some atom pattern of the form
\TT{"}$PCR$\TT{"} in the same lexical table.
There are several examples of this on \pagref{EXAMPLE-LEXEME-PROGRAM}.

The special character pattern name
\TT{<{repeat}>}%
\index{repeat@{\tt <repeat>}}%
\label{<REPEAT>}
can be used in an atom pattern to match zero or more occurences of
the previous character pattern.  There must be a previous character
pattern.  That pattern can be \TT{<others>}.
The number of repetitions is the maximum number of characters in
the input that match the previous character pattern.
As an example use, the atom pattern \TT{"\textbackslash x<hex-digit><repeat>"}
will recognize an atom consisting of the characters \TT{\textbackslash x}
followed by one or more characters matching the character pattern
\TT{<hex-digit>}.  This particular atom pattern will match a C++
hexadecimal escape sequence.

The special character pattern name
\TT{<{repeat-$N$}>}%
\index{repeat-N@{\tt <repeat-$N$>}}%
is similar but matches zero through $N$ occurences of the previous
character pattern, where $N$ is a sequence of {\em ASCII-digits}
not beginning with \TT{0}.

Note that if \TT{$C_1$<repeat>$C_2$} is part of an atom pattern where
$C_1$ and $C_2$ are character patterns or representatives, then
any atom recognized by the pattern must contain some number of
$C_1$ characters followed by a $C_2$ character that is \underline{not} also
a $C_1$ character.
For example, the pattern
\TT{"X<repeat>X"} cannot recognize the atom \TT{XXX} because the
string \TT{XXX} will match \TT{X<repeat>} leaving nothing to match
the final \TT{X} in the pattern.

If {\em atom-patterns} of two distinct {\em lexical-table-entries}
in the same {\em lexical-table} have the forms 
\TT{"}$PC_1Q_1$\TT{"} and \TT{"}$PC_2Q_2$\TT{"} with a common
prefix $P$ where
$C_1$ and $C_2$ are both character patterns or representatives
optionally followed
by \TT{<repeat>} or \TT{<repeat-$N$>} and
$Q_1$ and $Q_2$ are either both empty or both non-empty,
then the character sets of $C_1$ and $C_2$ \underline{must}
be disjoint.  This permits a deterministic finite automaton that
recognizes the atoms of the lexical table to be constructed.

It is permissible for
a sequence of characters that matches one pattern to have a proper
initial segment that matches another pattern; in this case the
longer pattern takes precedence.  This is why either $Q_1$ or $Q_2$
in the previous paragraph can be empty, but not both.

The order of {\em lexical-table-entries}
in a {\em lexical-table} is not significant.

The atom pattern \TT{""} which would recognize zero length atoms is
\underline{not} permitted, but the {\em default-instruction-group} at the
end of the lexical table executes in the equivalent case where no atom
pattern in the table matches the remaining input.  In particular
the {\em default-instruction-group} always executes if the input has reached
its end.  This fact is used in both the `\TT{main master table}'
and `\TT{quoted string lexeme table}'
on \pagref{EXAMPLE-LEXEME-PROGRAM}.

\subsubsection{Lexical Instructions}

A \emkey{lexical-table-entry} contains an
{\em atom-pattern} and an optional
\emkey{instruction-group} that consists of one or more {\em instructions}
separated by \TT{else}'s.  Most {\em instruction-groups} contain just
a single {\em instruction}, so we will explain this first.
{\em Instruction-groups} with more than one instruction contain
instructions that can fail, causing
the failing instruction to become a no-operation and the
next instruction in the instruction group to be executed instead.

An \emmkey{instruction}{in lexical-table-entry} in an {\em lexical-table-entry}
specifies actions to be taken when an atom is recognized by the
{\em atom-pattern} of the entry.  The {\em instruction} consists of
a set of {\em instruction-components} each of which controls part of the
atom processing.

The {\em default-instruction-group} at the end of an lexical table behaves as
if a it was associated with the {\em atom-pattern} \TT{""}
that recognizes zero length atoms.  Note that actual {\em atom-patterns}
are not allowed to be \TT{""}.

The order of processing {\em instruction-components} in an {\em instruction}
is:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{Components that may
cause their containing instruction to fail:} \\[1ex]
~~~~~~~~ & \TT{match}, \TT{translate oct}, \TT{translate hex},
                                       or \TT{translate name}\\
~~~~~~~~ & \TT{require}
\\[2ex]
\multicolumn{2}{l}{Components that only execute if their
containing instruction does not fail:} \\[1ex]
~~~~~~~~ & \TT{keep} \\
~~~~~~~~ & \TT{translate to}\\
~~~~~~~~ & \TT{error} \\
~~~~~~~~ & \TT{output} \\
~~~~~~~~ & \TT{goto}, \TT{call}, \TT{return}, or \TT{fail} \\
\end{tabular}
\end{center}

An {\em instruction} with no {\em instruction-components} simply accepts
the matched atom and copies it into the translation.  In order to
indicate this, the instruction may be written as if it had a single
`\TT{accept}' instruction component.  If this component is present
in an {\em instruction}, no other {\em instruction-components}
may be present in the {\em instruction}.

\subsubsubsection{Match Instruction Components and Atom Tables}

The `\ttmkey{match}{in lexical program} {\em atom-table-name}'
{\em instruction-component} invokes the named
\key{atom table}\label{ATOM-TABLE}
to recognize an atom and provide its translation.
Any previously matched atom and translation are ignored, and
the atom table {\em atom-patterns} are used to rematch the current atom,
provide a translation of the atom, and determine
whether the containing {\em instruction} fails.

Atom tables match only a single atom and implicitly return
to their invoking instruction after matching one atom.  The
\TT{output}, \TT{goto}, \TT{call}, and \TT{return}
{\em instruction-components} \underline{cannot} be used in an
atom table.  However, the \TT{fail} {\em instruction-component}
can only be used in an atom table, and when executed indicates
that the atom table invoking {\em instruction} has failed, so that
{\em instruction} becomes a no-operation and the next
{\em instruction} in the invoking
{\em instruction-group} (i.e., the {\em instruction}
after the `\TT{else}' following the failed {\em instruction}) is
executed.

\TT{accept}, \TT{match}, \TT{keep}, \TT{require}, and
any of the \TT{translate} {\em instruction-components} can be used in
an atom table {\em instruction}.  An atom table
instruction may contain a \TT{match} that invokes another atom table,
but recursion is prohibited, and as \TT{match} uses the
\TT{return stack}, a very deep nesting of \TT{match}'es may
exceed the stack limit (which is at least \TT{32}).

If an instruction invokes an atom table and
the atom table does not fail,
the original atom match that caused the instruction
to be executed is replaced by the atom matched by the
atom table, and the atom translation is that provided by the atom table.

An instruction that invokes an atom table fails if the atom table
fails or if the instruction has a \TT{require} component that fails
when applied to the atom translation produced by the atom table.
If the instruction fails, the
original atom match is reinstated (the instruction becomes a
no-operation) before the next {\em instruction} in the {\em instruction group}
executes.

The \TT{error} instruction component can also be used in an atom
table, but if the atom table fails, or if a subsequent \TT{require}
causes a \TT{match} that invoked the atom table to fail, the
effects of the \TT{error} instruction component will \underline{not}
be undone.  Normally the only effect is to announce an error.

Atom tables may have a {\em default-instruction-group}.
However, this only makes sense if it is just a `\TT{fail}', or
if it is contains \TT{match} components.  If an atom table
is invoked and none of its {\em atom-patterns} match an atom,
and if the table has \underline{no} {\em default-instruction-group},
then a scan error is signaled (i.e., `\TT{fail}' is \underline{not}
implicit).

\subsubsubsection{Translate Hex/Oct/Name Instruction Components}

The \TT{translate hex/\EOL oct/\EOL name} components are applied to a matched
atom to produce a single UNICODE character translation of the atom.

An instruction can contain at most one of the following components:
\begin{center}
\tt
match \\
translate hex \\
translate oct \\
translate name
\end{center}
This is because all four of these components independently produce
an atom translation.

Note that if any previous instruction in an instruction group contains
a \TT{match} component, that instruction must have failed, and the
atom as it was when the instruction group started to execute will have
been reinstated, so \TT{translate hex/oct/name} components are always
applied to the matched atom as it was when the containing instruction
group started to execute, before any \TT{match} components in the
group executed.

Also note that any \TT{keep} component executes \underline{after}
\TT{translate hex/oct/name} components, and so does not affect the
matched atom used by these components.

The `\ttmkey{translate hex}{in lexical program} $m$ $n$'
{\em instruction-component} ignores the
first $m$ and last $n$ characters of the matched atom and, viewing the rest as
hexadecimal digits, converts these into an 32 bit unsigned integer
UNICODE character code, which becomes the 1-character atom translation.
An example is the lexical table entry
\begin{center}
\verb|"<0<hex-digit><hex-digit>>" translate hex 2 1;|
\end{center}
which might be used to accept a character representative in a quoted string
and copy the appropriate hexadecimally represented character code into
the lexeme translation.  If characters that
are supposed to be hexadecimal digits are not, the \TT{translate-hex}
component fails (but in our example
this cannot happen because the definition of \TT{<hex-digit>}
restricts these characters appropriately).  The `\TT{translate hex}
instruction component accepts the characters \TT{a-f}, \TT{A-F},
and \TT{0-9} as hexadecimal digits (but \TT{<hex-digit>} in the
example might not accept all these).

The `\ttmkey{translate oct}{in lexical program} $m$ $n$'
{\em instruction-component} is identical but
views the rest of the characters as octal and not hexadecimal.
An example use would be the lexical table entry
\begin{center}
\verb|"\<oct-digit><oct-digit><oct-digit>" translate oct 1 0;|
\end{center}

The `\ttmkey{translate name}{in lexical program} $m$ $n$'
{\em instruction-component} is similar but
views the rest of the characters as the UNICODE name
(a.k.a., UNICODE abbreviation alias)
of a character.
An example use would be the lexical table entry
\begin{center}
\verb|"<<upper-case-ASCII-letter><repeat>>" translate name 1 1;|
\end{center}
which would translate the atom `\TT{<LF>}' to a line feed.
Note that UNICODE names consist of ASCII upper case letters and
digits, with a letter being first.
In addition to standard UNICODE character names, \TT{NL} is
recoginized as the name of the line feed character,
\TT{Q} is recognized as the name of the \TT{"} character,
and \TT{UUC} is recognized as the name of the
`\key{Unknown UNICODE Character}' that replaces erroneous
UTF-8 character encodings on input.

\subsubsubsection{Require Instruction Components}

The `\ttmkey{require}{in lexical program} {\em atom-pattern}'
{\em instruction-com\-po\-nent} tests whether the atom translation
matches the given {\em atom-pattern},
and if \underline{no}, causes the {\em instruction} to fail.
A \TT{require} should only appear in an
{\em instruction} which is followed by an `\TT{else}' in an
{\em instruction-group}.
A \TT{require} should only appear in an instruction that also
contains a \TT{match}, \TT{translate hex}, or \TT{translate oct}
instruction component, and is only useful for testing the
translations produced by these latter components.

An example use would be the lexical table entry
\begin{indpar}
\verb|"\u<hex-digit><hex-digit><hex-digit><hex-digit>"| \\
\verb|    translate hex 2 0| \\
\verb|    require "<letter>" else| \\
\verb|    translate to "" error misplaced character in identifier;|
\end{indpar}
which might be used to process an atom of the form \TT{\textbackslash uXXXX} in
an identifier, accepting the atom as a legitimate representation of a
character if that character is a letter, and otherwise designating
the atom as an error while not putting anything in the lexeme translation
(see below for the definition of the `\TT{error}' instruction component).

The last {\em instruction} in an {\em instruction-group} must
never fail, and so cannot contain a \TT{require} {\em instruction-component}.

A \TT{require} component executes before any \TT{translate to}
component (\pagref{TRANSLATE-TO-INSTRUCTION-COMPONENTS} below),
so the translation tested by \TT{require} can be replaced by
\TT{translate to}.

\subsubsubsection{Keep Instruction Components}

The `\ttmkey{keep}{in lexical program} $n$'
{\em instruction-component} causes the atom length
to be shortened to $n$ UNICODE characters.
For example, the lexical table entry
\begin{center}
\verb|",<digit>" keep 1;|
\end{center}
will recognize a 1-character atom consisting of just a comma as long as
the comma is followed by character in the \TT{<digit>} character pattern
character set.  Atoms may not be lengthened by \TT{keep}.

A \TT{keep} component in the same instruction as a \TT{match} component
applies to the atom matched by the atom table invoked by the \TT{match}
component.

\subsubsubsection{Translate To Instruction Components}
\label{TRANSLATE-TO-INSTRUCTION-COMPONENTS}

A `\ttmkey{translate to}{in lexical program}~~{\em translation-string}'
{\em in\-struc\-tion-com\-po\-nent}
specifies a {\em quoted-string} of characters,
the {\em translation-string},
that becomes the translation of the atom.
A {\em translation-string} may be empty, as in the lexical table entry
\begin{center}
\verb|"<Q>" translate to "" goto main;|
\end{center}
which can be used to recognize the last \TT{"} of a quoted string, avoid
copying anything into the lexeme translation, and then switch to the
`\TT{main}' lexical table.
See the example on \pagref{EXAMPLE-LEXEME-PROGRAM}.

The \TT{translate to} component is executed \underline{after}
any \TT{match}, \TT{translate hex}, \TT{tran\-slate oct},
\TT{translate name}, or
\TT{require} components are executed, and overrides the translations produced
by these components.  It is therefore possible to produce a translation,
test it with \TT{require}, and if the test is successful, override the
translation with \TT{translate to}.  An example is
\begin{center}
\begin{tabular}{l}
\verb|"<"  "<digit>" match escaped char| \\
\verb|               require "<ascii-character>"| \\
\verb|               error ascii escaped character| \\
\verb|               translate to ""| \\
\end{tabular}
\end{center}
which announces that any escape sequence producing an ASCII character
is an erroneous atom and replaces that atom by the empty translation
so it is as if the atom did not exist in the input.
One could also use `\TT{translate to "?"}' to replace the atom
by a question mark.

If an instruction does not contain any of the components \TT{match},
\TT{translate hex}, \TT{tran\-s\-late oct},
\TT{trans\-late name}, or \TT{trans\-late to},
the translation
of an atom defaults to a copy of the atom itself, \underline{after}
any \TT{keep} component has been used to change the length of the atom.

\subsubsubsection{Error Instruction Component}

~~~~ An `\ttmkey{error}{in lexical program} {\em type-name}\,'
{\em instruction-component}
an\-noun\-ces the current atom as an erroneous atom of the given {\em type}.
The atom remains part of the current lexeme,
and its translation is governed
independently by \TT{match} and \TT{translate} instruction components
(or the absence of such).
The following are some examples:
\begin{indpar}\begin{verbatim}
"\<others>" error bad escape sequence;
"\<others>" translate to "" error bad escape sequence;
"\<others>" translate to "<DEL>" error bad escape sequence;
\end{verbatim}\end{indpar}
These might be entries in an lexical table for a quoted string.
All identify an atom consisting of a backslash followed by any
character that does not match any character pattern $C$ that is in
a lexical table
atom pattern of the form \TT{"\textbackslash}$C$\ldots\TT{"} where $C$ is a character
pattern other than \TT{<others>} (see \pagref{<OTHERS>}).
The first entry copies the entire 2-character atom, including the
backslash, into the lexeme translation.  The second entry copies
nothing (the empty string \TT{""}) into the lexeme translation.
The third entry copies the DEL character (hex code \TT{7f})
into the lexeme translation.  An alternative is the entry
\begin{indpar}\begin{verbatim}
"\<others>" keep 1 error bad escape;
\end{verbatim}\end{indpar}
that reduces the atom size to 1 character, just the backslash,
which is announced as an error without its following character,
and copied to the lexeme translation.  The character following
the backslash remains in the input and will part of the next
atom recognized.
Another alternative is
\begin{indpar}\begin{verbatim}
"\" match bad escape translate "" error bad escape;
. . .
<any> = <0-<0FFFFFFFF>>;      // Matches any character.
begin bad escape atom table;
"\<any><any><any>"
end bad escape atom table;
\end{verbatim}\end{indpar}
in which the lexical table entry will be invoked if the next character
in the input is \TT{\textbackslash} and no longer
lexical table atom pattern of the form \TT{"\textbackslash}\ldots\TT{"} is matched, 
and as a result the \TT{\textbackslash} and the next three characters will be identified
as a `\TT{bad escape}'
erroneous atom and translated to the empty character sequence.


The routine that announces an error atom is given the position
of the atom in the input stream, so characters surrounding the
atom may also be included in the announcement.  For example,
the line containing the atom may be printed with marks under the
characters of the atom.

An erroneous atom is different from an erroneous lexeme.
An erroneous lexeme is simply a lexeme whose {\em type}
indicates to the user of the lexical scanner that the lexeme is erroneous.
As such an erroneous lexeme is
handled by the lexical scanner just as any other lexeme would be:
i.e., the lexical scanner has no special knowledge of erroneous lexemes
and no special operations for detecting or announcing them.

\subsubsubsection{Output Instruction Component}

\hfill An `\ttmkey{output}{in lexical program} {\em type-name}\,'
{\em instruction-component} sets the \key{current lexeme type}.

The \TT{output} {\em instruction-component} is
used to change the type of the lexeme to be output from
the type of the table containing the instruction.
For example, at the top of \pagref{EXAMPLE-LEXEME-PROGRAM} the
\TT{main} master table has `\TT{output end of file;}' as its
{\em default-instruction-group}, thereby outputting a zero length
lexeme with `\TT{end of file}' type whenever the input is at the
end of file.

As another example, the `\TT{main}' master table at the top of
\pagref{EXAMPLE-LEXEME-PROGRAM} contains the entry:
\begin{indpar}\begin{verbatim}
"<others>" output misplaced character;
\end{verbatim}\end{indpar}
which causes an unrecognized character to be treated as a 1-character
lexeme of type `\TT{misplaced char\-ac\-ter}'.
The translation of this lexeme is
the character itself, but if the entry:
\begin{indpar}\begin{verbatim}
"<others>" translate to "<DEL>" output misplaced character;
\end{verbatim}\end{indpar}
had been used instead the translation would have been the ASCII delete
(DEL) character.

Upon finishing the execution of an instruction, if the
current lexical table is a master table,
the currently accumulated lexeme is output
with the current lexeme type, if that is not `\TT{none}', or the
currently accumulated lexeme is discarded if the current lexeme
type is `\TT{none}'.
The current lexeme type is reset to `\TT{none}' whenever
the current lexical table becomes a master table.

The `\TT{output none}' instruction can be used to reset the current
lexeme type to `\TT{none}' in order to discard the currently
accumulated lexeme.

\subsubsubsection{Goto, Call, Return, and Fail Instruction Components}

A `\ttmkey{goto}{in lexical program} {\em lexical-table-name}\,'
{\em instruction-component} switches the current lexical table after
the current atom is processed.  If the table switches
to a master table and the current lexeme type is not `\TT{none}',
then the current lexeme translation is output with the
current lexeme type as its type.

A `\ttmkey{call}{in lexical program} {\em lexeme-table-name}\,'
{\em instruction-component} is just like `\TT{goto}' except
that it also pushes the identifier of the lexical table in which
the `\TT{call}' occurs (the `caller') into the return stack.
The \key{return stack} is a stack of up to 32 lexical table identifiers
used by the `\TT{call}' and `\TT{return}' instruction components
and also by the `\TT{match} {\em atom-table-name}'
instruction components.  Recursive calls are prohibited.
Whenever a master table becomes the current lexical table, the
return stack is cleared.

A `\ttmkey{return}{in lexical program}'
{\em instruction-component} is just like `\TT{goto}' except
that uses the lexical table identifier at the top of the return
stack to determine the next lexical table.  This identifier is
also popped from the stack.

The return stack is set to empty whenever the current lexical table
becomes a master table.
A \TT{call} \underline{cannot} be used
to call a master or atom table.  A \TT{return} can only
appear in a lexeme or sublexeme table.
A \TT{goto} \underline{cannot} be used to go to an atom table.

The `\TT{call}' and `\TT{goto}' instruction components
can both be used in the same {\em instruction}, in 
which case the \TT{goto} lexical table identifier is pushed into the
return stack instead of the current lexical table identifier.
The `\TT{return}' instruction component cannot be used with
`\TT{call}' or `\TT{goto}' (if `\TT{return}' and `\TT{call}'
could be used together, they would have the same affect as
a simple `\TT{goto}')

The `\TT{call}' and `\TT{return}' instruction components
permit a lexeme or sublexeme table to be shared among different
master, lexeme, and sublexeme tables.  For example, a lexeme table to scan
a comment lexeme may be shared among several master tables;
see Appendix \itemref{C++-LEXICAL-PROGRAM} for examples.

The `\TT{call}' and `\TT{return}' instruction components
add nothing new to the lexical scanning language, since they
cannot be used recursively,
and they can always be eliminated by making
copies of the called tables with hard coded returns.
But for certain languages these instruction components
substantially reduce the size of the lexical program.

A `\ttmkey{fail}{in lexical program}'
{\em instruction-component} can only be used in an atom
table and cannot be used with any other instruction components.
It causes the instruction invoking the atom table to fail, but
the instruction containing the `\TT{fail}' succeeds.

The `\TT{goto}', `\TT{call}', and `\TT{return}' instruction components
\underline{cannot} be used in an atom table.

\section{Parsing}

The layered languages parser attempts to promote human efficiency
both by standardizing many aspects of syntax and my permitting
substantial additions to syntax.  Humans reason
syntactically, and therefore new types of data and algorithm often
need to be supported by new syntax.  But this new syntax needs to
integrate with the old syntax, so the goal of the parser is to make
possible syntactic additions that integrate well with existing syntax.

The parser is a sequence of passes each of which operates on a list
of tokens.  A token is either a lexeme, a subexpression, or an operator.

The top level parser pass, the bracketed subexpression recognition pass,
recognizes:
\begin{itemize}
\item Top level paragraphs, bounded by blank lines, and optionally
introduced by `typed prefix separators' such as
`\TT{\{p\}}' and `\TT{\{code\}}'.
\item Typed separated subexpressions that are introduced by 
`typed prefix separators' such as
`\TT{\{s\}}' but which are not top level paragraphs.
\item Bracketed subexpressions bounded by brackets
such as `\TT{(}' and `\TT{)}'.
\item Typed bracketed subexpressions bounded by typed brackets
such as `\TT{\{b|}' and `\TT{|b\}}'.
\item Indented paragraphs, introduced by line-ending
indentation marks such as `\TT{:}', and terminated by the end of indentation.
\item
Lines in paragraphs which have line elements, such as indented paragraphs.
These may be continued
with indented lines, and are terminated by the next non-indented line,
or by a line separator such as `\TT{;}'.
\end{itemize}

The non-top-level passes
operate on the subexpressions recognized by previous passes;
for example, the operator pass operates on bracketed subexpressions
and recognizes
subexpressions bounded by operators.

Prefix separators and brackets can be used to change syntax, so, for example,
the syntax within a \TT{\{p\}} paragraph may differ from the
the syntax within a \TT{\{code\}} paragraph, and
the syntax within a \TT{[ ]} bracketed subexpression may differ from
the syntax within a \TT{` '} bracketed subexpression.

Parsing reduces each recognized subexpression, including each paragraph,
to a single expression token.

\subsection{Tokens}

A token has the following components:

\begin{indpar}
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{type}{of token}
		& One of: \hspace{0.5in}\begin{tabular}[t]{l}
        	          A lexeme type. \\
        	          \ttmkey{OPERATOR}{token type} \\
        	          \ttmkey{BRACKETED}{token type} \\
        	          \ttmkey{BRACKETABLE}{token type} \\[1ex]
			  \end{tabular}
\\[1ex]
		& For a lexeme, the translation of the
		  lexeme may be recorded in either the token
		  \TT{value} as a MIN string or in the token \TT{string}.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& Standardly the token lexeme types are word, mark, separator,
		  and natural whose tokens have a \TT{value} that is
		  a MIN string equal to the lexeme characters,
		  quoted string and numeric whose tokens
		  have a \TT{string} equal
		  to the lexeme translation string,
		  and line break and end of file whose tokens have neither
		  \TT{value} nor \TT{string}.
		  Standardly whitespace and comment lexemes are
		  not translated into tokens, and erroneous lexemes are
		  announced when input but not translated into tokens.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& For an \TT{OPERATOR}, the token \TT{value}
		  is the operator name recorded as
		  a MIN string or a MIN label, or in the case
		  where a bracketed subexpression is an operator,
		  the \TT{value} is the MIN object as described
		  for \TT{BRACKETED} tokens below.
		  \TT{OPERATOR} tokens are
		  produced inside the operator pass and consumed by
		  expression reformatters invoked by that pass.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& \TT{BRACKETED} and \TT{BRACKETABLE} tokens
		  are used to represent subexpressions.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& The value of a \TT{BRACKETED} token
		  is a MIN object which may have
		  attributes such as \TT{.initiator} or \TT{.terminator}.
		  The following attributes of a \TT{BRACKETED} token
		  \TT{value} are directly related to syntax and are called 
		  `\key{syntax attribute}s':
		  \begin{center}
		  \tt
		  \begin{tabular}{l}
		  .type \\
		  .initiator \\
		  .terminator \\
		  .separator \\
		  \end{tabular}
		  \end{center}
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& A \TT{BRACKETABLE} token
		  is equivalent to (and an optimization of) a \TT{BRACKETED}
		  token whose MIN object value has no syntax attributes other
		  than possibly the \TT{.separator} attribute.  If such a token
		  is to become the only element of a containing bracketed
		  subexpression, instead of creating a new
		  \TT{BRACKETED} token, the bracketed subexpression's
		  syntax attributes (which do not include a \TT{.separator}
		  attribute) are added to the \TT{BRACKETABLE} token (which
		  has no syntax attributes other than a possible
		  \TT{.separator} attribute),
		  the type of that token is changed to \TT{BRACKETED}, and
		  the \TT{.position} attribute of that token
		  is changed to include the added syntax attributes.
		  The non-syntax attributes of the
		  \TT{BRACKETABLE} token are left as is.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& Empty subexpressions are recorded as \TT{BRACKETABLE}
		  subexpressions whose MIN object has no elements and
		  no syntax attri\-butes.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& \TT{BRACKETED} and \TT{BRACKETABLE} tokens are called
		  \skey{expression token}s and \TT{OPERATOR} and lexeme
		  tokens are called non-expression tokens.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{value}{of token}
		& The token \TT{value}, as described above.  This is
		  a MIN string, label, or object.  Naturals are encoded
		  as MIN strings.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{string}{of token}
		& For quoted string and numeric lexemes,
		  which do not have token \TT{value}'s,
                  this is the translation string of the lexeme,
		  stored in a manner that makes
		  garbage collection and memory reuse more
		  efficient than it would be if MIN strings
		  were used, but makes lookup less efficient.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{position}{of token}
		& The positions in the input file of
                  the first character of the token
		  and the first character after the token in the
		  input text.  A character position records a line number
		  and the byte offset within a UTF-8 encoding
		  of the line.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{indent}{of token}
	        & The indentation of the token from the beginning
                  of the line, for the first token of a line only.
		  Calculated assuming a single space character is
		  1 column and horizontal tabs are every 8 columns.
		  A special missing value if the token is not the
		  first token on a line.
		\\[1ex]
		& Used by the bracketed subexpression recognizer
		  to recognize indentation.
\end{tabular}
\end{indpar}

Tokens are organized in a doubly threaded list.  A file is translated into
such a list that ends with a token containing an end-of-file
lexeme.
The tokens of a file are not read in all at once, but are read in as
needed.

As the parser identifies subexpressions, the tokens in the
subexpression are replaced by a single expression token (of
type \TT{BRACKETED} or \TT{BRACKETABLE})
that encodes the subexpression.
Although at the top level an entire
input file can be considered to be a list of paragraphs,
the parser \underline{never}
forms a single token that would represent it, but instead
delivers either top level paragraph tokens or top level line tokens
one at a time for subsequent
processing.  These top level tokens are placed at the
beginning of the token stream, and as they are never again accessed
by the parser, they may be removed from the token stream at any time
by post-parser processing.

\subsection{Parser Symbol Table}

Sequences of lexemes encoded as tokens are looked up in
\skey{parser symbol table}s.
A parser symbol table is conceptually a stack of
\skey{parser definition}s.

In fact, there are different
symbol tables for different parser passes, as each pass
looks up only pass specific definitions.

Each parser definition has the following
components:

\begin{indpar}
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{label}{of symbol table entry}
		& A non-empty
		  sequence of `symbols' that identifies the definition.
\\[1ex]
		& A \key{symbol} is a MIN string equal to the
		  lexeme string of a word, mark, separator,
		  or natural lexeme.  Quoted string
		  lexemes are not symbols.
\\[1ex]
		& Labels are symbol table `\skey{key}s', that is, they
		  are what is looked up in a symbol table.
\\[1ex]
		& If a label has just one symbol, it is represented by
		  a MIN string.  Otherwise it is represented by
		  a MIN label whose elements are MIN strings
		  equal to the symbols.
\\[1ex]
		& Note that naturals are represented by MIN
		  strings equal to their lexeme translation strings,
		  and are \underline{not} represented as MIN numbers.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{type}{of symbol table entry}
		& The type of the definition.  Each parser pass has
		  one (or sometimes more) symbol tables containing
		  definitions of types particular to the pass.
		  For example, the bracketed subexpression recognition
		  pass has \TT{opening bracket}, \TT{closing bracket},
		  \TT{indentation mark}, and \TT{indentation separator}
		  type definitions, among others.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{selectors}{of symbol table entry}
		& A set of \skey{parsing selector}s that determine if
		  the definition is active.  See text.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{level}{of symbol table entry}
		& Block nesting level, 0, 1, 2, \ldots, of the parser block
		  containing the definition that made this symbol
		  table entry.  When the parser block ends, this entry
		  will be removed from the symbol table stack.  The top level is
		  level 0, which outside all parser blocks.
\end{tabular}
\end{indpar}

Lookup in a parser symbol table takes as input a token sequence
that is part of a line (for the bracketed subexpression recognition pass)
or subexpression (for other passes), and finds an active symbol table
entry with a label whose symbols match an initial segment of the
token sequence.  Only symbol tokens, whose lexeme types are word,
mark, separator, or natural, can match label symbols.  These are just
the token types that have values which are MIN strings equal to the
translation strings of their lexemes, and it is these values that
are matched for equality with the table entry label symbols.
When a match is found,
the initial segment of tokens used in the match is called
a `\key{matched label}\,'.

At any point the longest active match is chosen.  Entries may
not be active because they have the wrong type or wrong selectors (see below)
for the current parser pass or context.
Entries may be activated only when other entries are recognized
in the current context, as when afix operators become active
only after an associated non-afix operator is recognized in
the same subexpression (see \pagref{AFIX-OPERATOR}).

In the bracketed
subexpression recognition pass matched labels may not span line boundaries.
In later passes, line boundary tokens are no longer present, and
matched labels can span line boundaries,
but cannot cross bracketed subexpression
boundaries.

The context of a symbol table lookup includes a set of \skey{parsing selector}s.
In order to be active, a symbol table entry's set of selectors
must have some selector in common with the parsing selectors.
A selector set is represented as a 64-bit unsigned integer value
with the bit in
position 1\TT{<{}<}N being on if the N+1'st selector is in the set.
Thus there can be at most 64 distinct selectors used by any set of
parser definitions.  For convenience, the selectors that can be
currently used are given names that are sequences of symbols.

The parsing selectors may change when an explicit opening bracket
is recognized, and remain changed until the associated explicit closing
bracket is recognized.  The initial parsing selectors used to scan a
top level line are determined by a context key at the beginning of
the line, or by the absence of any such key.
There are no other mechanisms for setting or changing the
parsing selectors.

The parser symbol tables act like stacks; as new parsing
definitions are encountered, their effects are `pushed' into the
symbol tables.  These stacks can be popped, removing
the parser definitions in reverse order.  When a definition
is popped, its effects are removed from the symbol tables.
Definitions are popped by the ends of parser blocks: see
\pagref{PARSER-BLOCKS}.

It is also possible to `\mkey{undefine}{parser symbol table entry}'
parser symbol table entries by clearing some or all of their selectors.
One can also think of `undefine's as being pushed into and popped
from symbol tables,
where pushing corresponds to clearing selectors from some entries
and popping corresponds to restoring those selectors to their
previous state.

\subsection{Parser Commands}

A parser command is a top level line that changes parser tables.
The syntax of a parser commands in general and in particular those
associated parser block definition, parser testing, selector definition,
and parser contexts is specified on \pagref{PARSER-COMMANDS}.

\begin{boxedfigure}[!p]
\emkey{parser-command}
    \begin{tabular}[t]{@{}rlrl@{}}
    ::= & {\em parser-block-command} &
    $|$ & {\em parser-test-command} \\
    $|$ & {\em parser-selector-command} &
    $|$ & {\em parser-context-command} \\
    $|$ & {\em parser-bracketed-command} &
    $|$ & {\em parser-pass-command} \\
    $|$ & {\em parser-operator-command}
    \end{tabular}
\label{PARSER-COMMAND}
\\[0.6ex]
\emkey{simple-name} ::= {\em word} \{ {\em word} $|$ {\em number} \}\STAR{}
\\[0.0ex]
\emkey{quoted-name-component} ::=
    {\em word} $|$ {\em mark} $|$ {\em separator} $|$ {\em number}
\\[0.0ex]
\emkey{quoted-name} ::=
    \TT{"}{\em quoted-name-component}
           {\em quoted-name-component}\,\STAR{}\TT{"}
\\[0.0ex]
\emkey{partial-name} ::= {\em quoted-name}
\\[0.6ex]
\emkey{parser-flag} ::= {\em simple-name}
\\[0.0ex]
\emkey{parser-flag-list}
    ::= \TT{[ ]}  $|$ \TT{[} {\em parser-flag}
          \{ \TT{,} {\em parser-flag} \}\,\STAR{} \TT{]}
\\[0.0ex]
\emkey{parser-flag-modifier-list}
    \begin{tabular}[t]{@{}r@{~}l@{~}l@{}}
    ::= & \TT{[} & {\em parser-flag-op} {\em parser-flag} \\
        &         & \{ \TT{,} {\em parser-flag-op}
	                        {\em parser-flag} \}\,\STAR{} \TT{]} \\
    \end{tabular}
\\[0.0ex]
\emkey{parser-flag-op} ::= \TT{+} $|$ \TT{-} $|$ \TT{\^{ }}
\\[0.0ex]
\emkey{parser-flag-spec} ::= {\em parser-flag-list} $|$
                              {\em parser-flag-modifier-list}
\\[0.6ex]
\emkey{parser-block-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttikey{parser begin}{begin!parser block} {\em block-name} \\
    $|$ & \ttikey{parser end}{end!parser block} {\em block-name} \\
    $|$ & \ttikey{parser print blocks}{print!parser blocks} \\
    \end{tabular}
\label{PARSER-BLOCK-COMMAND}
\\[0.0ex]
\emkey{block-name} ::= {\em simple-name}
\\[0.6ex]
\emkey{parser-test-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttikey{parser trace}{trace!parser} {\em parser-flag-spec} \\
    $|$ & \ttikey{parser print trace}{trace!parser print} \\
    $|$ & \ttikey{parser test}{test!parser} \ldots \\
    \end{tabular}
\label{PARSER-TEST-COMMAND}
\\[0.6ex]
\emkey{parser-trace-flag} ::= see page \pageref{PARSER-TRACE-FLAGS}
\\[0.6ex]
\emkey{parser-selector-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttikey{parser define selector}{selector!define} {\em selector} \\
    $|$ & \ttikey{parser print selector}{selector!print} {\em partial-name} \\
    \end{tabular}
\label{PARSER-SELECTOR-COMMAND}
\\[0.0ex]
\emkey{selector} ::= {\em parser-flag}
\\[0.0ex]
\emkey{selectors} ::= {\em parser-flag-list}
\\[0.6ex]
\emkey{parser-context-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttikey{parser define context}{context!define} {\em context-name} \\
        & ~~~ [ \TT{with parsing selectors} {\em parser-flag-spec} ] \\
    $|$ & \ttkey{parser print context} {\em partial-name} \\
    \end{tabular}
\\[0.0ex]
\emkey{context-name} ::= {\em quoted-name}
\label{PARSER-CONTEXT-COMMAND}

\medskip

\centerline{\bf Parser Command Syntax}

\label{PARSER-COMMANDS}
\end{boxedfigure}

A parser command is a top level input line by itself, and is
executed by the parser itself after the command is read,
thus affecting subsequent parsing.  Parser commands are
themselves parsed before they are executed.

Parser commands begin with the word `\ttmkey{parser}{in parser command}'.
Parser commands make use of {\em simple-names} that are just a {\em word}
optionally followed by a sequence of {\em words} and/or {\em numbers}, and
{\em quoted-names}, that are arbitrary sequences of {\em word},
{\em mark}, {\em separator}, and {\em number} lexemes enclosed
in quotation marks to form a {\em quoted-string} lexeme.
This embedding of lexemes in a {\em quoted-string} lexeme
serves to keep the embedded lexemes from being given a special
interpretation by the parser when the parser command is parsed.

Parser commands may be organized into \skey{parser-block}s of the form:%
\label{PARSER-BLOCKS}
\begin{center}
\begin{tabular}{l}
\ttmkey{parser begin}{block} {\em block-name} \\
{\em parser-command} \\
.~.~.~.~.~.~.~.~.~. \\
\ttmkey{parser end}{block} {\em block-name} \\
\end{tabular}
\end{center}

When a parser block ends, all changes to the parser tables made in
the block are erased, so subsequent parsing is as if the block
had never existed.
The {\em block-name} merely serves as an error check; it is
not possible to have one `\TT{parser end}' command end more than
one parser block.

The parser has two sets of \emkey{parser-flags}\index{flags!parser}:
the parser trace flags and the
selectors.  Each set has up to 64 named flags.  A set of parser flags can be
specified by giving a {\em parser-flag-list} or a
{\em parser-flag-modifier-list}.

When a \emkey{parser-flag-modifier-list}\label{FLAG-MODIFIER-LIST}
is used, the flag set is made by modifying the current
flag set (trace flags or selectors) according to the
instructions `{\em parser-flag-op} {\em parser-flag}' pairs.
These pairs are interpreted as follows:
\begin{center}
\begin{tabular}{ll}
\TT{+} {\em parser-flag} & set the named flag \\
\TT{-} {\em parser-flag} & clear the named flag \\
\TT{\^{ }}{\em parser-flag} & complement (flip) the named flag \\
\end{tabular}
\end{center}

In either the case of a {\em parser-flag-list} or
{\em parser-flag-modifier-list} no flag may be named more than once.
 
The current set of
\skey{parser trace flag}s\index{trace flag!parser}\index{flag!parser trace}
may be given or modified by the `\ttkey{parser trace}' command.
The trace flags cause trace printouts to the printer the parser uses
for error messages.  The trace flag names are builtin and are listed
in on page \pageref{PARSER-TRACE-FLAGS}.

The `\ttkey{parser print trace}' command prints the current set of
parser trace flags.

\begin{boxedfigure}[!p]

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttmkey{parser input}{parser trace flag} ~
    When the parser reads a token from the input,
    a description of the token is printed.

\hspace*{-0.2in}\ttmkey{parser output}{parser trace flag}
    When the parser produces a output line token, the token value
    is printed.

\hspace*{-0.2in}\ttmkey{parser commands}{parser trace flag}
    Upon successfully finishing the execution of a parser command,
    the command is printed (if the command is in error the error
    printout will print the command).

\hspace*{-0.2in}\ttmkey{bracketed subexpressions}{parser trace flag}
    Enables tracing for the parser bracketed subexpression recognition pass.

\hspace*{-0.2in}\ttmkey{operator subexpressions}{parser trace flag}
    Enables tracing for the parser operator recognition pass.

\hspace*{-0.2in}\ttmkey{subexpression lines}{parser trace flag}
    The printing of a value by the `\TT{parser output}' or
    `\ldots{} \TT{subexpressions}' trace flags, or the
    \TT{parser test} command, includes
    the lines containing the value with the value producing subexpression
    within these lines underlined.

\hspace*{-0.2in}\ttmkey{subexpression elements}{parser trace flag}
    The printing of a value by the `\TT{parser output}' or
    `\ldots{} \TT{subexpressions}' trace flags, or the
    \TT{parser test} command, includes
    a direct rendition of the value with implicit brackets and
    graphic representations of non-graphic characters
    shown.  This is the default.

\hspace*{-0.2in}\ttmkey{subexpression details}{parser trace flag}
    The printing of a value by the `\TT{parser output}' or
    `\ldots{} \TT{subexpressions}' trace flags, or the
    \TT{parser test} command, includes
    a detailed rendition of the value with all attributes shown.

\hspace*{-0.2in}\ttmkey{keys}{parser trace flag}
    During execution of a subexpression by a trace-enabled parser 
    pass, the keys found in the pass symbol tables are printed.
    If a key is rejected after being found, a rejection message
    is also printed.

\end{indpar}

\bigskip

\centerline{\bf Parser Trace Flags}
\label{PARSER-TRACE-FLAGS}
\end{boxedfigure}

The `\ttkey{parser test}' command just causes the parse of itself
to be printed in detail.  Since parser commands are parsed before they
are executed, any text placed after the words `\TT{parser test}' will
be parsed and the resulting printout will indicate the details of that
parse.

The only builtin selector name is `\ttikey{parser}{selector name}'.
Other selector names must be defined by the {\em parser-selector-command}:
\begin{center}
    \TT{parser define selector} {\em selector}
\end{center}
When the parser block containing a selector name definition
command ends, the selector name is erased.
There may be at most 64 selectors defined at any one time.

The \key{standard parser} creates a single initial parsing block
named `\ttikey{standard}{parsing block}' and defines in it the selectors
\begin{center}
\ttkey{code} ~~~ \ttkey{text} ~~~ \ttkey{math}
\end{center}
The standard parser also sets the top level selector set to
`\TT{[code]}'.  Note that the actions of the standard parser can be
canceled by a `\TT{parser end standard}' command.

If a top level line begins with a \emkey{context-name}, the top level
selector set is modified according to a {\em parser-flag-spec}
associated with the {\em context-name}.  There are two builtin
{\em context-names} used by parser commands:
\begin{center}
\begin{tabular}{ll}
\em Context-Name & \em Parser-Flag-Spec \\
\hline
\ttkey{parser}  & \tt [parser] \\
\ttkey{parser test}  & none; equivalent to an empty
                      {\em parser-flag-modifier-list}
\end{tabular}
\end{center}

So most {\em parser-commands} are parsed with just the parser selector
set `\TT{[parser]}',
as {\em parser-commands} begin with the {\em context-name}
`\TT{parser}', but the `\TT{parser test}' command is parsed with whatever
top level selectors are normally in effect, as the longest
{\em context-name} at the beginning of a top level line is the one that
is recognized.  Note that these two {\em context-names} are builtin, and
\underline{not} defined within the `\TT{standard}' parser block.  Also a
{\em context-name} beginning a top level line is \underline{not} skipped
by the parser, and \underline{is} included in the parser output for the line.

New {\em context-names} can be defined by the {\em parser-context-command}:
\begin{center}
    \TT{parser define context} {\em context-name}
        [ \TT{with parsing selectors} {\em parser-flag-spec} ]
\end{center}
If no {\em parser-flag-spec} is given, the {\em context-name} does
not modify the top level selectors, as if the {\em parser-flag-spec}
were an empty {\em parser-flag-modifier-list}.  An example of this
is the builtin `\TT{parser test}' {\em context-name}.

The `\ttikey{default}{context-name}' {\em context-name} is special
and refers to the top level selectors in effect when a top level
line does \underline{not} begin with any {\em context-name}.
When it is given as the {\em context-name}, the
{\em parser-flag-spec} must be given and must be a
{\em parser-flag-list}.

Thus the standard parser specified above begins by executing the
equivalent of
\begin{indpar}\begin{verbatim}
parser begin standard
parser define selector code
parser define selector math
parser define selector text
parser define context "default" with parsing selectors [code]
\end{verbatim}\end{indpar}

The end of a parser block erases the effects of any
{\em parser-selector-commands} and {\em parser-context-commands}
executed during the block.

In the following sections various `\ttkey{parser define}' commands
are described.  These push entries in to the parser symbol tables.
The general syntax of these is
\begin{center}
\TT{parser define} {\em type} {\em name} {\em selectors} \ldots 
\end{center}
and an example is
\begin{center}
\TT{parser define bracket "("~...~")" [operator, text]} \ldots
\end{center}
The {\em type}, `\TT{bracket}' in the example, identifies the parser pass into
whose symbol tables entries are to be pushed.  The {\em name},
`\TT{"("~...~")"}' in the example, gives {\em quoted-names} that become
the entry labels.  The {\em selectors},
`\TT{[operator, text]}' in the example, specify the selector set of
the entries to be pushed.

The end of a parser block pops all entries pushed into parser
symbol tables during the block.

For `\TT{parser define}' commands defined in the following sections
there is a companion
`\ttkey{par\-ser undefine}' command that effectively undoes
the \TT{parser define} command by clearing selector bits in
the designated symbol table entries.  Its syntax is
\begin{center}
\TT{parser undefine} {\em type} {\em name} {\em selectors}
\end{center}
and it clears the specified selector bits from \underline{all} symbol table
entries with the same {\em type} and {\em name}.  When the
block containing a \TT{parser undefine} command ends, the
effects of that command are undone by restoring the cleared
selector bits to their previous state.

For `\TT{parser define}' commands defined in the following sections,
and also for the `\TT{parser define selector}' and
`\TT{parser define context}' commands defined above,
there is a companion
`\ttkey{parser print}' command that prints the contents of the
parser symbol table entries with the designated {\em type} and any
{\em name} containing within it
the {\em partial-name} supplied by the print command.
Its syntax is
\begin{center}
\TT{parser print} {\em type} {\em partial-name}
\end{center}
The {\em partial-name} and {\em name} are both treated as sequences
of complete lexemes, and the former can be any subsequence of the
latter, not just an initial subsequence.

\subsection{The Bracketed Subexpression Recognition Pass}

The bracketed subexpression recognition pass recognizes:
\begin{indpar}[1.0in]
\hspace*{-0.5in}brackets (e.g.~`\TT{(}' and `\TT{)}')
    and bracketed subexpressions \\
\hspace*{-0.5in}indentation marks (e.g.~`\TT{:}')
    and line separators (e.g.~`\TT{;}'),
    indented paragraphs, and indented paragraph lines \\
\hspace*{-0.5in}typed brackets (e.g.~`\TT{\{b|}' and `\TT{|b\}}')
      and typed bracketed subexpressions \\
\hspace*{-0.5in}typed prefix separators (e.g.~`\TT{\{p\}}')
\end{indpar}

The bracketed subexpression recognition pass also merges
consecutive quoted strings if they are on the same
(possibly continued) line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence"
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line boundaries.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" "LF" ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

Brackets, indentation marks, and line separators are
symbol table keys.  However typed brackets and typed prefix separators are
not.  Instead, a typed bracket or typed prefix separator is formed by using
typed openings (e.g.~`\TT{\{}'),
typed property introducers (e.g.~`\TT{:}'),
typed property equators (e.g.~`\TT{=}'),
typed property separators (e.g.~`\TT{,}'),
typed middles (e.g.~`\TT{|}'),
and typed closings (e.g.~`\TT{\}}'), which are all symbol table
keys, to surround or separate
sequences of words, numbers, quoted strings, and
bracketed subexpressions, and thence form typed brackets
and typed prefix separators.

TBD
In bracketed subexpression recognition, 
multi-lexeme symbol table keys are not recognized in the
input if their lexemes are not all on the same line.
This is different from other parser passes, which are executed
after line breaks have been removed.

TBD
The output of the parser is a sequence of \TT{BRACKETED} tokens,
one per top level line.  The value of one of these tokens is a
MIN object with a \TT{.type} equal to the MIN string
\TT{"<NL>"} and optionally a \TT{.terminator} equal
to the line separator at the top level (e.g., \TT{";"}),
but with no other syntax attributes.

In general, the bracketed subexpression recognizer converts
subexpressions to single \TT{BRACK\-ET\-ED} tokens whose \TT{value}'s
are MIN objects with attributes determined by the brackets
and elements dermined by tokens between the brackets.
For untyped brackets that only
attributes are the syntax attributes \TT{.initiator} and \TT{.terminator}
plus a \TT{.type} attribute derived from these.  For typed brackets
the only syntax attribute is the \TT{.type} attribute, but arbitrary
non-syntax attributes may be encoded in the typed brackets.

Subexpressions may occur among the list of tokens that determine the
object elements or the value of a non-syntax attribute.
These are reduced by the parser to \TT{BACKETTED} tokens
with a \TT{value} before the MIN object is formed.
Quoted string lexemes must be handled
differently because they have no token \TT{value}.  These are
represented by MIN objects
that have the \TT{.type} attribute \TT{"<Q>"}
and that have a single
element which is a MIN string equal as a character string to the
\TT{string} of the quoted string token being represented.

For example, the line
\begin{indpar}\begin{verbatim}
parser test (x 5 "foo")
\end{verbatim}\end{indpar}
causes the parser to output a \TT{BRACKETED} token whose \TT{value} is
\begin{indpar}\begin{verbatim}
{"<LF>"| parser test
         {"": .initiator "(", .terminator = ")"|
              x 5 {"<Q>"|foo|} |} |}
\end{verbatim}\end{indpar}
where a MIN object is represented by
\begin{center}
\TT{\{} {\em type}\TT{:}
        {\em attribute-name} \TT{=} {\em attribute-value}\TT{,} \ldots \TT{|}
	{\em element} \ldots \TT{|\}}
\end{center}

and a MIN string is represented by its character sequence, optionally
quoted with \TT{"}'s.

The MIN object that is the value of a \TT{BRACKETED} token and
represents a subexpression may have the following `\skey{syntax attribute}s':

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttdmkey{initiator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals
    \begin{center}
    \begin{tabular}{ll}
       & the {\em opening-bracket-name} of a bracketed subexpression, \\
    or & the {\em indentation-mark-name} of an indented subexpression, \\
    or & the {\em typed-opening} of a typed bracketed subexpression, \\
    or & the {\em typed-opening} of a typed operator, \\
    or & \TT{"<Q>"} if the MIN object represents a quoted string lexeme.
    \end{tabular}
    \end{center}
\medskip
\hspace*{-0.2in}\ttdmkey{terminator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals
    \begin{center}
    \begin{tabular}{ll}
       & the {\em closing-bracket-name} of a bracketed subexpression, \\
    or & \TT{"<NL>"} if the subexpression is an new-line terminated
         indented line \\
       & in an indented paragraph, \\
    or & the {\em line-separator-name} used to separate lines of an
         indented paragraph, \\
    or & the {\em typed-closing} of a typed bracketed subexpression, \\
    or & the {\em typed-closing} of a typed operator. \\
    \end{tabular}
    \end{center}
\medskip
\hspace*{-0.2in}\ttdmkey{separator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals an operator, such as `\TT{,}' that acts as a
    separator in a subexpression.
\\[2ex]
\hspace*{-0.2in}\ttdmkey{middle}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals the {\em typed-middle} of a typed bracketed subexpression.
\\[2ex]
\hspace*{-0.2in}\ttdmkey{name}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals the {\em bracket-name} of a typed bracketed subexpression
    or the {\em operator-name} of a {\em typed-operator}.
\\[2ex]
\hspace*{-0.2in}\ttdmkey{arguments}{subexpression attribute}\\
    A MIN object whose elements are the arguments of the
    {\em opening-typed-bracket} of a typed bracketed subexpression,
    or of a {\em typed-operator}.  The object is formatted like the
    \TT{value} of a \TT{BRACKETED} token, except that it has no syntax
    attributes.  Each argument is either a bracketed subexpression
    or a quoted string.
\\[2ex]
\hspace*{-0.2in}\ttdmkey{keys}{subexpression attribute}\\
    A MIN object whose elements are the keys of the
    {\em opening-typed-bracket} of a typed bracketed subexpression,
    or of a {\em typed-operator}.  The keys are the elements of
    the object, and the object's only syntax attributes are
    \TT{.initiator} and \TT{.separator} both of which equal the
    {\em typed-key-separator} of the {\em opening-typed-bracket}
    or {\em typed-operator}.
    The keys and attributes
    are all either MIN strings or MIN labels with MIN string
    elements.

\end{indpar}

In addition to the attributes just given, a MIN object may have
a \ttdmkey{position}{of MIN object} attribute that is a
\TT{min::\EOL phrase\_\EOL position\_\EOL vec} giving the positions
of the lexemes which the MIN object and its elements represent.
This is not considered to be a syntax attribute.

The parser commands specific to the bracketed subexpression recognizer
are further divided into those specific to the different kinds of subexpression
recognized by this recognizer:

\begin{indpar}[0.1in]
\emkey{parser-bracketed-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em parser-untyped-bracket-command} \\
    $|$ & {\em parser-indentation-mark-command} \\
    $|$ & {\em parser-typed-bracket-command} \\
    $|$ & {\em parser-print-bracket-command} \\
    \end{tabular}
\label{PARSER-BRACKETED-COMMAND}
\end{indpar}

The following subsections describe these different kinds of commands
and the subexpressions they control.

\subsubsection{Bracketed Subexpressions}

The following are examples of
\ikey{untyped bracketed expressions}{bracketed expressions!untyped},
where \ldots{} denotes a list of elements:
\begin{center}
\TT{(} ~~~\ldots~~~ \TT{)} \\
\TT{(|} ~~~\ldots~~~ \TT{|)} \\
\TT{[} ~~~\ldots~~~ \TT{]} \\
\TT{[<} ~~~\ldots~~~ \TT{>]} \\
\end{center}

The general syntax is:

\begin{indpar}[0.1in]
\emkey{untyped-bracketed-expression} ::=
	{\em opening-bracket} {\em element-list} {\em closing-bracket}
\\[0.5ex]
\emkey{opening-bracket} ::=
   \begin{tabular}[t]{@{}l}
   \{ {\em mark} $|$ {\em separator} \}\PLUS{}
    ~~~~~ [e.g., `\TT{(}' or `\TT{[<}'] \\
    as defined by a
    {\em parser-untyped-bracket-command}
    (\pagref{PARSER-UNTYPED-BRACKET-COMMAND})
    \end{tabular}
\\[0.5ex]
\emkey{closing-bracket} ::= ditto
    ~~~~~ [e.g., `\TT{)}' or `\TT{>]}']
\\[0.5ex]
\emkey{element-list} ::= {\em prefix-0-list}
\label{ELEMENT-LIST}
\\[0.5ex]
\emkey{prefix-0-list}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em simple-element-list} \\
    $|$ & see \pagref{PREFIX-0-LIST}
    \end{tabular}
\\[0.5ex]
\emkey{simple-element-list} ::= {\em element}\STAR{}
\\[0.5ex]
\emkey{element} ::= {\em word} $|$ {\em number} $|$ {\em mark} $|$
                    {\em separator} $|$ {\em quoted-string} $|$
		    {\em bracketed-expression}
\\[0.5ex]
Note: \begin{minipage}[t]{5.8in}
      An {\em untyped-bracketed-expression} {\em element-list}
      is normally terminated by the expression's {\em closing-bracket}.
      It may be abnormally terminated by an outer {\em bracketed-expression's}
      {\em closing-bracket}, {\em typed-middle}, {\em typed-closing},
      or {\em non-continuation-line-break}, but \underline{not}
      by a {\em line-separator}.
      \end{minipage}
\end{indpar}

A \key{bracketed subexpression}\index{bracketed subexpression!untyped}
begins with
an {\em opening-bracket} and ends with a match\-ed
{\em clos\-ing-bracket} as defined by a
\TT{parser define bracket} command, an example of which is
\begin{center}
\TT{parser define bracket "("~...~")" [operator, text]} \ldots
\end{center}
which specifies `\TT{(}' to be an {\em opening-bracket}
with `\TT{)}' as its corresponding {\em closing-bracket}
and `\TT{operator}' and `\TT{text}' as the definition selectors.

The general syntax of {\em parser-untyped-bracket-commands} is:

\begin{indpar}[0.1in]
\emkey{parser-untyped-bracket-command}%
\label{PARSER-UNTYPED-BRACKET-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rll}
    ::= & \multicolumn{2}{l}{\ttikey{parser define bracket}%
                                    {bracket!parser define}
		    {\em bracket-name} {\em selectors}} \\
	& \hspace*{3em} & [ \TT{with parsing selectors}
	                    {\em new-selectors} ] \\
        &               & [ \TT{with full lines} ] \\
    $|$ & \multicolumn{2}{l}{\ttikey{parser undefine bracket}%
                                    {bracket!parser undefine}
		    {\em bracket-name} {\em selectors}} \\
    \end{tabular}
\\[0.5ex]
\emkey{bracket-name} ::= {\em opening-bracket}
			 \ttmkey{...}{in {\em bracket-name}}
			 {\em closing-bracket}
\label{BRACKET-NAME}
\\[0.5ex]
\emkey{opening-bracket} ::= {\em quoted-name}
\\[0.5ex]
\emkey{closing-bracket} ::= {\em quoted-name}
\\[0.5ex]
\emkey{new-selectors} ::= {\em parser-flag-modifier-list}

\end{indpar}

Brackets such as `\TT{(}' and `\TT{)}'
are sometimes called `\key{untyped brackets}'
to distinguish them from typed brackets
such as `\TT{\{b|}' and `\TT{|b\}}'
in which the type, in this case `\TT{b}',
is arbitrary.  See Section~\itemref{TYPED-BRACKETED-SUBEXPRESSIONS}
for a description of typed brackets.

A bracketed subexpression is converted to a \TT{BRACKETED}
token whose \TT{value} is a
MIN object whose list elements are the components of the
subexpression except for the brackets.  The
{\em opening-bracket} becomes the \TT{.initiator}
attribute of this object, and the {\em closing-bracket}
becomes the \TT{.terminator} attribute of the object.

If a bracketed subexpression ends pre-maturely, before
its {\em closing-bracket} is discovered, a parsing error is
announced and the {\em closing-bracket} is inserted in the input
just after the pre-maturely ended subexpression.  Such a pre-mature end can be
discovered by finding the {\em closing-bracket} of a containing
bracketed subexpression, the {\em typed-closing-bracket}
of a containing typed bracketed subexpression, the end of the paragraph line
containing the bracketed subexpression,
or an end of file.

An exception to this is made if the bracket definition has the
\ttmkey{full lines}{in bracket definition} property.  In this case
it is expected that the subexpression will consist of one or
more full input lines.  While the subexpression is being scanned,
use of indentation is turned off, and only the {\em closing-bracket}
associated with the full lines {\em opening-bracket}, or an
end-of-file,
can terminate the subexpression.  During parsing of a
`\TT{full lines}' subexpression, the parser only knows about
subexpressions and paragraphs that are included completely inside the
`\TT{full lines}' subexpression.

When an {\em opening-bracket} is recognized, the current parser
selector set is saved in a stack and
a new set is computed by modifying the saved set
according to the {\em new-selectors} in the bracket definition.
The saved selector set is restored after the {\em closing-bracket}
is recognized.  However {\em closing-bracket}
recognition does not depend
upon the current parser selectors, but only on previous recognition
of an associated {\em opening-bracket}.

The definition
\begin{indpar}\begin{verbatim}
parser define bracket "[" ... "]" [parser]
\end{verbatim}\end{indpar}
is builtin.

The definitions
\begin{indpar}\begin{verbatim}
parser define bracket "(" ... ")" [code,math,text]
parser define bracket "[" ... "]" [code,math,text]
parser define bracket "{" ... "}" [code,math,text]
       with parsing selectors [ + math, - code, - text]
parser define bracket "`" ... "'" [code,math,text]
       with parsing selectors [ + text, - code, - math]
\end{verbatim}\end{indpar}
are included by the standard parser at the beginning of
its `\TT{standard}' parser block.

\subsubsection{Indented Paragraph Subexpressions}

The following is an example
\key{indented paragraph subexpression}
using `\TT{:}' as an {\em indentation-mark}:
\begin{indpar}\begin{verbatim}
the line before the outer paragraph
this is an outer paragraph:
    the first line of the outer paragraph
    the second line of the outer paragraph which
        is continued on this indented line
    an inner paragraph:
        the first line of the inner paragraph
        the second line of the inner paragraph which
            is continued on this indented line
    the first outer paragraph line after the inner paragraph
    another inner paragraph, but one with zero lines:
    the last line of the outer paragraph
the line after the outer paragraph
\end{verbatim}\end{indpar}

An \key{indented paragraph subexpression}
begins with an {\em indentation-mark} (e.g. `\TT{:}')
which must be at the end of
a line.  This is followed by an \key{indented paragraph}
consisting of zero or more \skey{paragraph line}s,
each beginning at the same indentation which
is called the \key{paragraph indentation}.  The paragraph indentation
is defined as the indentation of the first paragraph line of the paragraph,
and must be greater than the indentation of the line containing the
{\em indentation-mark}.
A paragraph line may have a continuation lines that are indented with
respect to the paragraph indentation.

The general syntax is:

\begin{indpar}[0.1in]
\emkey{indented-paragraph-expression} ::=
	\begin{tabular}[t]{@{}l}
	{\em indentation-mark} {\em line-break} \\
	~~~~ {\em paragraph-line-group}\STAR{} \\
	{\em paragraph-end}
	\end{tabular}
\\[0.5ex]
\emkey{paragraph-line-group}
	\begin{tabular}[t]{@{}rl}
	::= & {\em separated-paragraph-line}\STAR{}
	      {\em non-separated-paragraph-line} \\
	$|$ & {\em separated-paragraph-line}\PLUS{} \\
	\end{tabular}
\\[0.5ex]
Note: \begin{minipage}[t]{5.8in}
      A {\em paragraph-line-group} must begin at the paragraph indent
      and may contain continuation lines: see text.
      \end{minipage}
\\[0.5ex]
\emkey{paragraph-end} ::= beginning of a line whose indent is less than
			  the paragraph indent
\\[0.5ex]
\emkey{separated-paragraph-line} ::= {\em element-list} {\em line-separator}
\\[0.5ex]
\emkey{non-separated-paragraph-line} ::=
    {\em element-list} {\em non-continuation-line-break}
\\[0.5ex]
\emkey{non-continuation-line-break} ::= {\em line-break} not followed by a
				   continuation line
\\[0.5ex]
\emkey{indentation-mark} ::=
   \begin{tabular}[t]{@{}l}
   \{ {\em mark} $|$ {\em separator} \}\PLUS{}
    ~~~~~ [e.g., `\TT{:}'] \\
    as defined by a
    {\em parser-indentation-mark-command}
    (\pagref{PARSER-INDENTATION-MARK-COMMAND})
    \end{tabular}
\\[0.5ex]
\emkey{line-separator} ::= ditto
    ~~~~~ [e.g., `\TT{;}']
\\[0.5ex]
\emkey{element-list} ::= see \pagref{ELEMENT-LIST}
\\[0.5ex]
Note: \begin{minipage}[t]{5.6in}
      A {\em paragraph-line} {\em element-list} is terminated by the
      first {\em line-separator} or {\em non-continuation-line-break}.
      \end{minipage}
\end{indpar}

A {\em paragraph-line-group} may be continued by continuation lines
which a lines indented more than the indentation of the beginning
of the {\em paragraph-line-group}.  Another way of putting it is
that {\em line-breaks} before a continuation line are deleted before
parsing is done.

An {\em indentation-mark} is specified by a
\ttikey{parser define indentation mark}{indentation mark!parser define}
parser command, and may have
an associated {\em line-separator} supplied by that definition.
An example is
\begin{center}
\TT{define indentation mark ":"~...~";" [operator]} \ldots
\end{center}
which specifies `\TT{:}' to be an {\em indentation-mark}
with `\TT{;}' as its corresponding {\em line-separator}
and `\TT{operator}' as the sole definition selector.

The general syntax of {\em parser-indentation-mark-commands} is:

\begin{indpar}[0.1in]
\emkey{parser-indentation-mark-command}%
\label{PARSER-INDENTATION-MARK-COMMAND} \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttikey{parser define}{define indentation mark}
	  \begin{tabular}[t]{@{}l@{}}
	  \TT{indentation mark}
	  {\em indentation-name} {\em parsing-selectors} \\
	  {}[ \TT{with parsing selectors} {\em new-selectors} ] \\
	  \end{tabular} \\
    $|$ & \ttikey{parser undefine indentation mark}{undefine indentation mark}
	  \begin{tabular}[t]{@{}l@{}}
	  {\em indentation-name} \\
	  {\em parsing-selectors} \\
	  \end{tabular} \\
    $|$ & \ttikey{parser define indentation offset}{define indentation offset}
	  {\em indentation-offset}  \\
    $|$ & \ttikey{parser print indentation offset}{define indentation offset} \\
    \end{tabular}
\label{INDENTATION-MARK-DEFINITION}
\\[0.5ex]
\emkey{indentation-name} ::= {\em indentation-mark}
	[ \TT{...} {\em line-separator} ]
\\[0.5ex]
\emkey{indentation-mark} ::= {\em quoted-name}
\label{INDENTATION-MARK-NAME}
\\[0.5ex]
\emkey{line-separator} ::= {\em quoted-name}
\\[0.5ex]
\emkey{new-selectors} ::= {\em parser-flag-modifier-list}
\\[0.5ex]
\emkey{indentation-offset} ::= unsigned integer
\end{indpar}

The {\em line-separator} may be used to separate
paragraph lines, as long as it is outside subexpressions
(untyped bracketed, typed bracketed, or indented subparagraph)
in the paragraph.

Each paragraph line is converted to a MIN object whose elements are
the components of the line, treated as subexpression components, except for
any {\em line-separator} that ends the line.  This
object is given a \TT{.type} attribute value
equal to \TT{"<NL>"}, and if it ends with a {\em line-separator},
it is also given a \TT{.terminator} attribute equal to the
{\em line-separator}.

However, an empty paragraph line with no ending
{\em line-separator} is ignored as if it did not exist.

The paragraph as a whole is converted to a MIN object whose elements
are the paragraph lines, and whose \TT{.type} attribute
is the {\em indentation-mark} that introduced the paragraph.
A paragraph may be empty (have no paragraph lines).

If while parsing an indented paragraph a line is encountered whose
indentation is different from the paragraph indentation,
but the difference is less than $N$ columns (default $N=2$),
an error is announced.
No corrective action is taken; the line is accepted as either ending
the paragraph if its indentation is less than the paragraph
indentation, or continuing the current paragraph line if its indentation
is greater than the paragraph indentation.  Here $N$ is called the
\key{parser indentation offset}, and is a parser parameter that can be
changed with the \TT{parser define indentation offset} command.
If changed in a parser block, the original value is reinstated at the
end of the block.  The indentation offsets of the current blocks
can be printed by the \TT{parser print indentation offset} command.

When an {\em indentation-mark} is recognized, the current parser
selector set is saved in a stack and
a new set is computed by modifying the saved set
according to the {\em new-selectors} in the indentation mark definition.
The saved selector set is restored after the end of paragraph
is recognized.  However {\em line-separator}
recognition does not depend
upon the current parser selectors, but only on previous recognition
of an associated {\em indentation-mark}.

\ikey{Top level parsing}{top level parsing}
of a file recognizes paragraph lines as if the whole
file were a paragraph, and forms each line into a MIN object.  However,
these are \underline{not} combined into a paragraph MIN object, but
are instead processed as they are produced.  In particular, if they
are parser commands, they are processed by the parser to make
modifications in the parser tables.  Also, the initial
\key{top level paragraph indent}
is set to zero, and an error is announced if the first non-comment,
non-line-break, non-end-of-file
lexeme in the file has non-zero indent.

Comments are ignored when determining line indentation, but may
cause errors to be announced.  A comment is considered to be in error
if it appears on a line by itself and is less indented than the first
following non-comment non-blank line.
Comments at the beginning or end of a file cannot be
in error.

\subsubsection{Typed Bracketed Subexpressions}
\label{TYPED-BRACKETED-SUBEXPRESSIONS}

The following are examples of
\skey{typed bracketed subexpression}s\index{bracketed subexpression!typed},
where \ldots{} denotes a list of elements:
\begin{center}
\TT{\{my type|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{|} ~~~\ldots~~~ \TT{|my type\}} \\
\TT{\{my type|} ~~~\ldots~~~ \TT{|my type\}} \\
\TT{\{my type||\}} \\
\TT{\{||my type\}} \\
\TT{\{my type: my attribute = 5, my option = TRUE|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{my type: my attribute = 5, my option = FALSE|} ~~~\ldots~~~
    \TT{|my type\}} \\
\TT{\{my type|} ~~~\ldots~~~
    \TT{|my type: my attribute = 5, my option\}} \\
\TT{\{|} ~~~\ldots~~~ \TT{|my type: my attribute = 5, my option\}} \\
\TT{\{|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{||\}} \\
\TT{\{\}} \\
\TT{\{"": my attribute = 5, not my option|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{*} ~~~\ldots~~~ \TT{*\}} \\
\end{center}

The basic form is
\begin{center}
\TT{\{my type: my attribute = 5, my option = TRUE|} ~~~\ldots~~~
    \TT{|my type\}} \\
\end{center}
from which various parts can be omitted.  The attributes can be moved to
the end (but may not be at both beginning and end).
The attribute value `\TT{= TRUE}' can be omitted (as in
`\TT{my option}'), and the attribute value `\TT{= FALSE}' can be represented
by omitting it and prefacing the attribute label with `\TT{no}'
(as in `\TT{no my option}').
The type can be omitted from either beginning or end if there are no attributes
after it.  If there are no elements, `\TT{|~|}' can be collapsed into
a single lexeme `\TT{||}'.  A missing type is denoted
by \TT{""} and may be omitted if there are no attributes.
`\TT{\{||\}}' can be collapsed into `\TT{\{\}}'.  If the type is
a single {\em mark} lexeme and there are no attributes,
the `\TT{|}'s surrounding
the elements are always omitted.  Note that type and attribute labels
cannot contain separators or marks unless these are quoted.

The general syntax is:

\begin{indpar}[0.1in]
\emkey{typed-bracketed-subexpression} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
	::= & {\em typed-opening} {\em type-label} {\em attributes}\QMARK{}
	      {\em typed-elements}
	      {\em type-label}\QMARK{}
	      {\em typed-closing} \\
	$|$ & {\em typed-opening} {\em type-label}\QMARK{}
	      {\em typed-elements}
	      {\em type-label} {\em attributes}\QMARK{}
	      {\em typed-closing} \\
	$|$ & {\em typed-opening} {\em typed-elements}\QMARK{}
	      {\em typed-closing} \\
	$|$ & {\em typed-opening} {\em type-mark}
	      {\em element-list}
	      {\em type-mark} {\em typed-closing} \\
	\end{tabular}
\\[0.5ex]
\emkey{typed-elements}
	\begin{tabular}[t]{@{}rl}
	::= & {\em typed-middle} {\em element-list} {\em typed-middle} \\
	$|$ & {\em doubled-typed-middle}
	\end{tabular}
\\[0.5ex]
\emkey{element-list} ::= see \pagref{ELEMENT-LIST}
\\[0.5ex]
\emkey{attributes} ::= {\em typed-attribute-begin}
		       {\em attribute-list}\QMARK{}
\\[0.5ex]
\emkey{attribute-list} ::= {\em attribute}
	\{ {\em typed-attribute-separator} {\em attribute} \}\STAR{}
\\[0.5ex]
\emkey{attribute} \begin{tabular}[t]{@{}rl}
                  ::= & {\em attribute-label}
	                {\em typed-attribute-equal}
			{\em single-attribute-value} \\
                  ::= & {\em attribute-label}
		        \begin{tabular}[t]{@{}l}
	                {\em typed-attribute-equal}
			{\em double-attribute-value} \\
	                {\em typed-attribute-equal}
			{\em attribute-label} \\
			\end{tabular} \\
                  ::= & {\em attribute-label} \\
                  ::= & {\em typed-attribute-negative} {\em attribute-label} \\
		  \end{tabular}
\\[0.5ex]
\emkey{label} ::= {\em label-component}\PLUS{}
\\[0.5ex]
\emkey{label-component} ::=
    \begin{tabular}[t]{@{}l}
    {\em word} $|$ {\em natural} $|$ {\em numeric} $|$ {\em quoted-string} \\
    but \underline{not} {\em mark} or {\em separator} \\
    \end{tabular}
\\[0.5ex]
\emkey{type-label} ::= {\em label}
\\[0.5ex]
\emkey{attribute-label} ::= {\em label} {\em attribute-flags}\QMARK{}
\\[0.5ex]
\emkey{attribute-flags}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em typed-attribute-flags-opening} {\em attribute-flags} \\
        & \{ {\em typed-attribute-flags-separator}
	  {\em attribute-flag-index} \}\STAR{} \\
	& {\em typed-attribute-flags-closing} \\
    \end{tabular}
\\[0.5ex]
\emkey{attribute-flags}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} or {\em mark} containing only letters
			    and/or \TT{@\#\$\%\&*-+=<>/} \\
    $|$ & {\em attribute-flags-index} \\
    \end{tabular}
\\[0.5ex]
\emkey{attribute-flag-index} ::= {\em natural}
\\[0.5ex]
\emkey{single-attribute-value}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em value} \\
    $|$ & {\em attribute-multivalue-opening} {\em value} \\
        & \{ {\em attribute-multivalue-separator} {\em value} \}\STAR{} \\
	& {\em attribute-multivalue-closing} \\
    \end{tabular}
\\[0.5ex]
\emkey{value} ::= {\em label} $|$ {\em bracketed-expression}
\\[0.5ex]
\emkey{typed-opening} ::=
   \begin{tabular}[t]{@{}l}
   \{ {\em mark} $|$ {\em separator} \}\PLUS{}
    ~~~~~ [e.g., `\TT{\{}'] \\
    as defined by a {\em parser-typed-bracket-command}
    (\pagref{PARSER-TYPED-BRACKET-COMMAND})
    \end{tabular}
\\[0.5ex]
\emkey{typed-middle} ::= ditto
    ~~~~~ [e.g., `\TT{|}']
\\[0.5ex]
\emkey{doubled-typed-middle} :::=
    \begin{tabular}[t]{@{}l}
    {\em typed-middle} {\em typed-middle} ~~~~~ [e.g., `\TT{||}'] \\
    as a single lexeme (when possible): see text
    \end{tabular}
\\[0.5ex]
\emkey{typed-closing} ::= ditto
    ~~~~~ [e.g., `\TT{\}}']
\\[0.5ex]
\emkey{typed-attribute-begin} ::= ditto
    ~~~~~ [e.g., `\TT{:}']
\\[0.5ex]
\emkey{typed-attribute-separator} ::= ditto
    ~~~~~ [e.g., `\TT{,}']
\\[0.5ex]
\emkey{typed-attribute-equal} ::= ditto
    ~~~~~ [e.g., `\TT{=}']
\\[0.5ex]
\emkey{typed-attribute-negative} ::= ditto
    ~~~~~ [e.g., `\TT{no}']
\\[0.5ex]
\emkey{typed-attribute-flags-opening} ::= ditto
    ~~~~~ [e.g., `\TT{[}']
\\[0.5ex]
\emkey{typed-attribute-flags-separator} ::= ditto
    ~~~~~ [e.g., `\TT{,}']
\\[0.5ex]
\emkey{typed-attribute-flags-closing} ::= ditto
    ~~~~~ [e.g., `\TT{]}']
\\[0.5ex]
\emkey{attribute-multivalue-opening} ::= ditto
    ~~~~~ [e.g., `\TT{\{*}']
\\[0.5ex]
\emkey{attribute-multivalue-separator} ::= ditto
    ~~~~~ [e.g., `\TT{,}']
\\[0.5ex]
\emkey{attribute-multivalue-closing} ::= ditto
    ~~~~~ [e.g., `\TT{*\}}']
\\[0.5ex]
\emkey{type-mark} ::= {\em mark}
\end{indpar}

The {\em typed-opening/middle/closing} and
{\em typed-attribute-begin/separator/equal/negative} 
are symbol table keys
from which typed opening and closing
brackets are constructed.  They are specified by a
\ttkey{parser defined typed bracket} parser definition, an example of
which is:
\begin{center}
\begin{tabular}{l}
\TT{parser define typed bracket "\{"~...~"|"~...~"|"~...~"\}"} \\
\TT{~~~~[text]~} \\
\TT{~~~~with attributes ":"~...~"="~...~","} \\
\TT{~~~~with attribute negative "no"} \\
\TT{~~~~with attribute flags "["~...~","~...~"]"} \\
\TT{~~~~with attribute multivalue "{*"~...~","~...~"*}"} \\
\TT{~~~~}\ldots
\end{tabular}
\end{center}
which specifies
\begin{center}
\begin{tabular}{l}
`\TT{\{}' to be a {\em typed-opening} \\
`\TT{|}' to be a {\em typed-middle} \\
`\TT{\}}' to be a {\em typed-closing} \\
`\TT{text}' to be the sole definition selector \\
`\TT{:}' to be the {\em typed-attribute-begin} \\
`\TT{=}' to be the {\em typed-attribute-equal} \\
`\TT{,}' to be the {\em typed-attribute-separator} \\
`\TT{no}' to be the {\em typed-attribute-negative} \\
`\TT{[}' to be the {\em typed-attribute-flags-opening} \\
`\TT{,}' to be the {\em typed-attribute-flags-separator} \\
`\TT{]}' to be the {\em typed-attribute-flags-closing} \\
`\TT{\{*}' to be the {\em typed-attribute-multivalue-opening} \\
`\TT{,}' to be the {\em typed-attribute-multivalue-separator} \\
`\TT{*\}}' to be the {\em typed-attribute-multivalue-closing} \\
\end{tabular}
\end{center}

The general syntax of {\em parser-typed-bracket-commands} is:

\begin{indpar}
\emkey{parser-typed-bracket-command}%
\label{PARSER-TYPED-BRACKET-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \TT{parser}%
          \ttindex{parser define typed bracket}%
	  \ttindex{typed bracket!parser define}
	  \begin{tabular}[t]{@{}l@{}}
	  \TT{define typed bracket} {\em typed-bracket-name} \\
	  {\em parsing-selectors} \\
	  {}[ \TT{with attribute negative} {\em typed-attribute-negative} ] \\
	  \end{tabular} \\
    $|$ & \ttikey{parser undefine typed bracket}{typed bracket!parser undefine}
	  \begin{tabular}[t]{@{}l@{}}
	  {\em typed-bracket-name} \\
	  {\em parsing-selectors} \\
	  \end{tabular} \\
    \end{tabular}
\\[0.5ex]
\emkey{typed-bracket-name} \\
    \hspace*{0.2in}
     ::= \begin{tabular}[t]{@{}l@{}}
	 {\em typed-opening} \TT{...} {\em typed-attribute-begin} \\
	 \TT{...} {\em typed-attribute-equal}
	 \TT{...} {\em typed-attribute-separator} \\
         \TT{...} {\em typed-middle} \TT{...} {\em typed-middle} \\
	 \TT{...} {\em typed-closing}
	 \end{tabular}
\\[0.5ex]
\emkey{typed-opening} ::= {\em quoted-name}
\\[0.5ex]
\emkey{typed-attribute-begin} ::= {\em quoted-name}
\\[0.5ex]
\emkey{typed-attribute-equal} ::= {\em quoted-name}
\\[0.5ex]
\emkey{typed-attribute-separator} ::= {\em quoted-name}
\\[0.5ex]
\emkey{typed-middle} ::= {\em quoted-name}
\\[0.5ex]
\emkey{typed-closing} ::= {\em quoted-name}
\\[0.5ex]
\emkey{typed-attribute-negative} ::= {\em quoted-name}

\label{TYPED-BRACKET-DEFINITIONS}
\end{indpar}

Note that if a {\em typed-middle} is given in a {\em typed-bracket-name},
the {\em typed-middle} must be repeated twice and both copies must
be identical.

A typed bracketed expression is converted to a
MIN object whose list elements are the components of the
subexpression between {\em typed-middles}.  The
{\em type-label} or {\em type-mark} becomes the \TT{.type}
attribute of this object.  Any attributes given in the
typed bracketed expression become attributes of the object.

If two {\em typed-middle} lexemes with no intervening space
are lexically scanned as a single lexeme, then this new
{\em doubled-typed-middle} lexeme can be used in place of
two {\em typed-middle} lexemes with an intervening space
(representing an empty list).

If a typed bracketed subexpression ends pre-maturely,
its {\em typed-closing} is discovered, a parsing error is
announced and missing but required {\em typed-middle}'s and {\em typed-closings}
are inserted in the input
just after the pre-maturely ended subexpression.  Such a pre-mature end can be
discovered by finding the {\em closing-bracket} of a containing
untyped bracketed subexpression, the {\em typed-closing}
of a containing typed bracketed subexpression, the end of the paragraph line
containing the typed bracketed subexpression,
or an end of file.

\subsubsection{Typed Prefix Separators}
\label{TYPED-PREFIX-SEPARATORS}

A \key{typed prefix separator}
has the same syntax as an {\em typed-bracketed-expression}
but without the {\em element-list}, meaning there are no
{\em typed-middles} (e.g., `\TT{|}'s) or {\em elements}.
Some examples are:
\begin{center}
\TT{\{my type\}} \\
\TT{\{my type: my attribute = 5, my option = TRUE\}} \\
\TT{\{my type: my attribute = 5, my option = FALSE\}} \\
\TT{\{my type: my attribute = 5, my option\}} \\
\TT{\{"": my attribute = 5, not my option\}} \\
\TT{\{*\}} \\
\end{center}

The general syntax is:

\begin{indpar}[0.1in]
\emkey{typed-prefix-separator}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em typed-opening} {\em type-label} {\em attributes}\QMARK{}
	                      {\em typed-closing} \\
    $|$ & {\em typed-opening} {\em type-mark} {\em typed-closing} \\
    \end{tabular}
\end{indpar}

A {\em typed-prefix-separator} is converted to a MIN object which has the
same structure as a typed bracketed subexpression with an empty list.

{\em Typed-prefix-separators} are used to form {\em prefix-N-lists}.%
\label{PREFIX-0-LIST}
The following is an example in which {\em line-breaks} are ignored:


\begin{tabular}{lll}
Text	& Separator &  Syntactic Category
\\\hline
\tt \{p\} \{s\} This is a sentence.	& \tt \{p\} & \em prefix-0-list \\
\tt ~~~ \{s\} And another. \\
\tt \{p\} \{s\} And a new \{foo\} paragraph.
\\\hline
\tt \{s\} This is a sentence.	& \tt \{s\} & \em prefix-1-list \\
\tt \{s\} And another.
\\\hline
\tt This is a sentence.	& (none) & \em prefix-2-list
\\\hline
\tt And another. & (none) & \em prefix-2-list
\\\hline
\tt \{s\} And a new \{foo\} paragraph. & \tt \{s\} & \em prefix-1-list
\\\hline
\tt And a new \{foo\} paragraph. & (none) & \em prefix-2-list \\
			       &        & \TT{\{foo\}} is in error \\
			       &        & and is ignored (deleted).
\end{tabular}

The {\em prefix-0-list} in this example is equivalent to:
\begin{indpar}\begin{verbatim}
{|  {p|  {s| This is a sentence . |}
         {s| And another . |} |}
    {p|  {s| And a new paragraph . |} |} |}
             // `{foo}' deleted
\end{verbatim}\end{indpar}

The general syntax is:

\begin{indpar}[0.1in]
\emkey{prefix-n-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \{ {\em prefix-n} {\em prefix-(n+1)-list} \}\PLUS{} \\
    $|$ & {\em simple-element-list} \\
    \end{tabular}
\\[0.5ex]
\emkey{prefix-n} ::= {\em typed-prefix-separator}
\\[0.5ex]
Note: \begin{minipage}[t]{5.8in}
      All the {\em prefix-n}'s in a given {\em prefix-n-list} must
      have the same type (i.e., \TT{.type} attribute).
      \end{minipage}
\end{indpar}

The elements of a {\em prefix-n-list} are modified by taking
each `{\em prefix-n} {\em prefix-(n+1)-list}' component and
moving the {\em prefix-(n+1)-list} elements to the
the MIN object represented by {\em prefix-n}.  So, for example,
\begin{center}
\TT{\{T\} X Y Z}
\end{center}
is just alternate syntax for
\begin{center}
\TT{\{T| X Y Z |\}}
\end{center}



\subsubsection{The Print Bracket Command}

A {\em parser-print-bracket-command} has the syntax:

\begin{indpar}
\emkey{parser-print-bracket-command}%
\label{PARSER-PRINT-BRACKET-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttikey{parser print bracket}{parser print bracket}
	  {\em partial-name} \\
    \end{tabular}
\end{indpar}

All bracket symbol table entries are printed whose first name
component includes the {\em partial-name}, where the first name
component is one of
\begin{indpar}
\em
opening-bracket-name \\
indentation-mark-name \\
gluing-indentation-mark-name \\
typed-opening
\end{indpar}


\subsection{Parser Passes}

After a subexpression has been identified by the top level bracketed
subexpression recognition pass, a sequence of passes is run on the
subexpression.  Which passes are in the sequence is determined by the
parser pass stack and parser selectors.

The \key{parser pass stack} is a list of parser passes with a set of
selectors associated with each pass.  A pass in this list is active
if it has a selector in common with the parsing selectors computed
by the bracketed subexpression recognition pass.  After the top level pass
recognizes a subexpression, the active passes in the parser pass stack
are run in the order that they appear in the stack.

The parsing selectors
computed by the opening bracket of the bracketed subexpression
are attached to that bracketed subexpression.
These are used to determine activity of the parser passes run on the bracketed
subexpression and also the activity
of the parser definitions (i.e., parser symbol table entries)
used by these parser passes.
Note that only the brackets surrounding a bracketed subexpression
can change the parsing selectors in the parser context; the operators
that bound implicit subexpressions cannot change these parsing selectors.

The parser pass stack can be altered and inspected
by the following parser definitions:

\begin{indpar}
\emkey{parser-pass-command} \\
    \begin{tabular}[t]{rl}
    ::= & \ttikey{parser define pass}{pass!parser define}
	  \begin{tabular}[t]{@{}l@{}}
	  {\em parser-pass-name} {\em parsing-selectors} \\
	  {\em parser-pass-stack-location} \\
	  \end{tabular} \\
    $|$ & \ttikey{parser undefine pass}{pass!parser undefine}
	  {\em parser-pass-name} \\
    $|$ & \ttikey{parser print pass}{pass!parser print}
    \end{tabular}
\\[0.5ex]
\emkey{parser-pass-stack-location}
    \begin{tabular}[t]{rl}
    ::= & \TT{after} {\em previous-parser-pass-name} \\
    $|$ & \TT{before} {\em next-parser-pass-name} \\
    $|$ & \TT{at end} \\
    \end{tabular}
\\[0.5ex]
\emkey{parser-pass-name} ::= {\em simple-name}
\\[0.5ex]
\emkey{previous-parser-pass-name} ::= {\em parser-pass-name}
\\[0.5ex]
\emkey{next-parser-pass-name} ::= {\em parser-pass-name}
\end{indpar}

The set of passes that may be run is builtin, and
cannot be changed.  The following are permitted {\em parser-pass-names}:

\begin{indpar}
\hspace*{-0.2in}\ttmkey{top}{parser pass name}\\
    This refers to the bracketed subexpression recognition pass which is
    always at the top of the parser pass stack,
    and can only be used as a {\em previous-parser-pass-name} to place
    a pass just below it on the stack.
\\[2ex]
\hspace*{-0.2in}\ttmkey{operator}{parser pass name}\\
    Parses expressions with computational operators (e.g., \TT{+} and
    \TT{*}).
\\[2ex]
\hspace*{-0.2in}\ttmkey{lexeme replacement}{parser pass name}\\
    Replaces sequences of lexemes with other
    sequences of lexemes (e.g., replaces plurals by singulars).
\\[2ex]
\hspace*{-0.2in}\ttmkey{radix number recognition}{parser pass name}\\
    Recognizes numbers with non-decimal radixes.
\\[2ex]
\hspace*{-0.2in}\ttmkey{scientific number recognition}{parser pass name}\\
    Recognizes numbers with exponents.
\\[2ex]
\hspace*{-0.2in}\ttmkey{number pair recognition}{parser pass name}\\
    Recognizes pairs of numbers (e.g., \TT{4 1/2}).
\\[2ex]
\hspace*{-0.2in}\ttmkey{number unit grouping}{parser pass name}\\
    Groups numbers and numeric units (e.g., \TT{4ft 5in}).
\\[2ex]
\hspace*{-0.2in}\ttmkey{unit multiplication insertion}{parser pass name}\\
    Inserts multipliers between numbers and
    numeric units (e.g., \TT{4*ft} and \TT{\$*4.99}).
\end{indpar}

The \TT{parser define pass} statement sets the
{\em parsing-selectors} of the named parser pass
and installs that pass in the parser pass stack at the
location specified.
If the pass was previously on the stack, it is removed first
and then re-installed.  The {\em parser-pass-name} and
{\em next-parser-pass-name} cannot be `\TT{top}'.
Any {\em previous-parser-pass-name} or {\em next-parser-pass-name}
given must name a pass already in the stack that is different from
the pass being installed.

The \TT{parser undefine pass} statement removes the named
parser pass from the stack, if it is in the stack, and does
nothing otherwise.  The `\TT{top}' pass cannot be undefined.

The \TT{parser undefine pass} statement destroys any symbol
table associated with the pass being undefined.  First undefining and then
redefining a pass effectively clears this symbol table.  Thus
first undefining and then redefining the `\TT{operator}' pass
clears the symbol table set by `\TT{parser define operator \ldots}'
commands.  On the other hand,
a `\TT{parser define pass operator \ldots}' statement 
may be used to change the `\TT{operator}' pass selectors or
position in the pass stack without clearing the operator symbol
table.

The \TT{parser print pass} statement prints the parser pass stack passes
with their associated selectors.

The input and output of a parser pass is a sublist of the list
of all tokens.  When a parser pass is called, it is provided with
a pointer to the first token of this sublist, and a pointer to the
first token after the sublist.  The pass may edit the sublist.
The pass is responsible for calling the next pass down in the parser
pass stack, and may edit the sublist before and/or after calling
this next pass.

The bracketed subexpression pass, also known as the `\TT{top}' pass,
is the first pass called for each
top level input line, recognizes bracketed subexpressions,
calls the next active lower pass for each bracketed subexpression,
and then replaces the bracketed subexpression by a single MIN object.

\subsection{The Operator Parsing Pass}
\label{OPERATOR-PARSING-PASS}

The \key{operator parsing pass} is an expression parser pass that uses
operators to restructure expressions.  Operators
are defined by operator definitions that can be added to the
parsing definition stack.  List separators, such as `\TT{,}', are treated
as operators, and have operator definitions.

{\em Parser-operator-commands} modify and print
the parsing definition stack:

\begin{indpar}[0.1in]
\emkey{parser-operator-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em parser-operator-definition} \\
    $|$ & {\em parser-print-operator-command} \\
    \end{tabular}
\label{PARSER-OPERATOR-COMMAND}
\end{indpar}

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITION}

An \key{operator definition} specifies for each operator the following:

\begin{indpar}[1in]
Name and Selectors \\
Precedence \\
Operator Flags \\
Reformatter
\end{indpar}

The syntax of operator definitions is:

\begin{indpar}
\emkey{parser-operator-definition} \\
    \hspace*{0.5in}\begin{tabular}{rl}
    ::= & \ttkey{parser define operator}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em operator-name} {\em parsing-selectors} \\
	    {\em operator-flag} {\em operator-flag}\,\STAR{} \\
	    \TT{with precedence} {\em precedence} \\
	    {}[ \TT{with}
	                   \begin{tabular}[t]{l}
			   \tt reformatter \\
			   ~~~~ {\em reformatter-name} \\
			   ~~~~~~~~ {\em reformatter-arguments} ] \\
	                   \end{tabular} \\
	    \end{tabular} \\
    $|$ & \ttkey{parser undefine operator}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em operator-name} {\em parsing-selectors} \\
	    {\em operator-flag} {\em operator-flag}\,\STAR{} \\
	    \TT{with precedence} {\em precedence} \\
	    \end{tabular} \\
    \end{tabular}
\\[1ex]
\emkey{operator-name} \begin{tabular}[t]{rl}
		    ::= & {\em simple-operator-name} \\
		    $|$ & \TT{bracket} {\em bracket-name} \\
		    $|$ & \TT{indentation mark} {\em indentation-mark-name}
		    \end{tabular}
\\[1ex]
{\em simple-operator-name} ::= {\em quoted-name} \\[1ex]
{\em bracket-name} ::= see \pagref{BRACKET-NAME} \\[1ex]
{\em indentation-mark-name} ::= see \pagref{INDENTATION-MARK-NAME} \\[1ex]
\emkey{operator-flag} ::= \ttmkey{prefix}{operator flag}
                    $|$ \ttmkey{infix}{operator flag}
                    $|$ \ttmkey{postfix}{operator flag}
                    $|$ \ttmkey{nofix}{operator flag}
                    $|$ \ttmkey{afix}{operator flag}
	\\[1ex]
\emkey{precedence} ::= {\em sign-option} {\em natural-number}
	\\[1ex]
\emkey{sign-option} ::= {\em empty} $|$ \TT{+} $|$ \TT{-}
	\\[1ex]
\emkey{reformatter-name} ::= {\em simple-name } \\
\emkey{reformatter-arguments} \begin{tabular}[t]{@{}rl}
			      ::= & {\em empty} $|$ \TT{()} \\
			      $|$ & \TT{(} {\em reformatter-argument} \\
			          & ~~~~ \{ \TT{,} {\em reformatter-argument}
				         \}\STAR{} \TT{)} \\
			      \end{tabular} \\
\emkey{reformatter-argument} ::= {\em quoted-name}
\end{indpar}

A {\em simple-operator-name} is matched to lexemes in a subexpression
in order to identify occurrences of the operator.
The other forms of {\em operator-name} permit bracketed subexpressions
with particular kinds of brackets to be parsed as if they were operators.
Thus in `\TT{x[5]=0}' the bracketed subexpression
`\TT{[5]}' can be a postfix operator.  A subexpression
bracketed by `\TT{\{ \}}' is used as an afix (see below) to the
\TT{<-{}-} operator (as is a subexpression introduced by the `\TT{:}'
indentation mark).

By abuse of language, the term `\key{operator}' is often used
as a synonym for `{\em simple-operator-name}'.

Operators have \skey{operator flag}s that
affect parsing of subexpressions of the operator.  The possible
flags are `\TT{infix}', `\TT{prefix}', `\TT{postfix}',
`\TT{nofix}', and `\TT{afix}'.  An operator must have at least
one of these flags.

An \ttkey{infix} operator must be between two non-empty operands,
while a \ttkey{prefix} operator must precede a non-empty operand,
and a \ttkey{postfix} operator must follow a non-empty operand.
A prefix operator can only appear at the beginning of a subexpression and
has no preceding operand.
A postfix operator can only appear at then end of a subexpression and has
no following operand.

A \ttkey{nofix} operator is like an infix operator but may or may not be
preceded or followed by operands.  It may appear at the beginning or ending of
an expression, or two nofix operators may be consecutive in an expression.

An \ttkey{afix} operator\label{AFIX-OPERATOR} must follow
another operator that has the same precedence in a subexpression.
Subexpressions bracketed by `\TT{\{ \}}'
are standard afix operators with the same precedence
as the \TT{<-{}-} operator, so that an expression such as:
\begin{center}
\verb|sum from X through Y <-- integer X, integer Y { ... }|
\end{center}
is parse as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y) { ... }|
\end{center}
and \underline{not} as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y { ... })|
\end{center}

An\label{FIXITY-RULES}
operator must be prefix, infix, postfix, nofix, or afix.
A prefix operator may also be infix or postfix, but may not be afix.
An infix operator may also be prefix or afix, but not postfix.
An postfix operator may also be prefix or afix, but not infix.
A nofix operator may afix, but not prefix, infix, or postfix.

This can be summarized in the following compatibility table:

\begin{center}
\begin{tabular}{|c|c|c|c|l}
\cline{1-4}
infix  & postfix & nofix & afix & \\
\hline
yes    & yes     & no    & yes   &  \multicolumn{1}{|l|}{prefix} \\
\cline{1-5}
\multicolumn{1}{c|}{}
       & no      & no    & yes   &  \multicolumn{1}{|l|}{infix} \\
\cline{2-5}
\multicolumn{2}{c|}{}
                 & no    & yes   &  \multicolumn{1}{|l|}{postfix} \\
\cline{3-5}
\multicolumn{3}{c|}{}
                         & yes   &  \multicolumn{1}{|l|}{nofix} \\
\cline{4-5}
\end{tabular}
\end{center}

The {\em precedence} of an operator is an integer.  Precedence is used to
determine which operators are inside and outside implicit brackets.
Operators with higher precedence are placed inside the 
implicit brackets that surround operands of operators of lower precedence.
Implicit brackets are used to define subexpressions, so that all operators
in a subexpression that are not in sub-subexpressions are of the same
precedence.

The {\em reformatter-name} in an {\em operator-definition} names a
function that is called after all other parsing has been done to
reformat a subexpression whose first operator is the defined operator.
For example, given the expression `\TT{-x+6*y}', the subexpression
`\TT{6*y}' is extracted, and as its first operator is `\TT{*}',
the reformatter for that operator is called and yields `\TT{* 6 y}'.
Similarly the subexpression `\TT{-x}' is extracted but the reformatter
for `\TT{-}' does not change `\TT{-x}'.
Then the reformatter for `\TT{+}' is called
with `\TT{[. -x .]+[. * 6 y .]}', since `\TT{+}' is the first operator in
this subexpression \underline{after} subexpressions have been handled.
This reformatter returns `\TT{+ [. -x .] [. * 6 y .]}'.  Here we have
use parentheses \TT{[. .]} to indicate implicit parentheses.

The optional {\em reformatter-arguments} are arguments to the reformatter
function.  For example, the `\TT{summation}' reformatter takes two
arguments, `\TT{(} {\em plus-op}\TT{,} {\em minus-op} \TT{)}', which
are usually `\TT{("+","-")}'.

\subsubsection{The Print Operator Command}

A {\em parser-print-operator-command} has the syntax:

\begin{indpar}
\emkey{parser-print-operator-command}%
\label{PARSER-PRINT-OPERATOR-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttikey{parser print operator}{parser print operator}
	  {\em partial-name} \\
    \end{tabular}
\end{indpar}

All operator symbol table entries are printed whose first name
component includes the {\em partial-name}, where the first name
component is one of
\begin{indpar}
\em
simple-operator-name \\
opening-bracket-name \\
indentation-mark-name \\
gluing-indentation-mark-name
\end{indpar}


\subsubsection{Standard Operators}
\label{STANDARD-OPERATORS}

The standard operators are given on 
\pagref{STANDARD-OPERATOR-LIST}.

\begin{figure*}[!p]
\begin{center}
\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}

precedence & reformatter	& type	& operator	& meaning 
\\[2ex]
0000	& \ttkey{declare}	& \TT{nofix}	& \ttkey{<-{}-}	& define \\
	&			& \TT{afix}	& \ttkey{\{ ... \}} & block \\
1000	& \TT{right}		& \TT{infix}	& \ttkey{=}	& assignment \\
     	& \TT{associative\ttindex{right associative}}
				&          	& \ttkey{+=}	& increment \\
     	&               	&          	& \ttkey{-=}	& decrement \\
     	&               	&          	& \ttkey{*=}	& multiply by \\
     	&               	&          	& \ttkey{/=}	& divide by \\
2000	& \ttkey{separator}	& \TT{nofix}	& \ttkey{,}	& separator \\
3000	& \ttkey{binary}	& \TT{nofix}	& \ttkey{BUT NOT}
								& logical and
								  not \\
3100	& \ttkey{infix}		& \TT{infix}	& \ttkey{AND}	& logical and \\
	&			&		& \ttkey{OR}	& logical or \\
3100	& \ttkey{unary}		& \TT{prefix}	& \ttkey{NOT}	& logical not \\
4000 	& \ttkey{infix and}	& \TT{infix}	& \ttkey{==}	& equal \\
	&			&		& \ttkey{/=}  & not equal \\
	&			&		& \ttkey{!=}	& ditto \\
	&		      	&		& \ttkey{<}	& less than \\
	&			&		& \ttkey{<=}	& less than or
								  equal \\
	&			&		& \TT{=<}	& ditto \\
	&		      	&		& \TT{>}	& greater than
									\\
	&			&		& \TT{>=}	& greater than
								  or equal \\
	&			&		& \TT{=>}	& ditto \\
5000	& \ttkey{sum}		& \TT{infix}	&  \TT{+}	& addition \\
	&			&		& \TT{-}	& subtraction \\
5100	& \ttkey{binary}	& \TT{infix}	& \TT{/}	& division \\
5200	& \ttkey{infix}		& \TT{infix}	& \TT{*}
							& multiplication \\
5300	& \ttkey{binary}	& \TT{infix}	& \TT{\^{ }}
							& exponentiation \\
10000	& 			& \TT{prefix}	&  \TT{-}	& minus \\
	& 			& \TT{prefix}	&  \TT{+}	& plus \\
	& 			& \TT{prefix}	&  \TT{@}	& object
	                                                          identifier \\
\end{tabular}
\end{center}
\label{STANDARD-OPERATOR-LIST}
\end{figure*}


Below we describe the effects of standard operator reformatters.
We use notation such as

\hspace*{2em}\begin{tabular}{lcl}
\TT{x = y = z + w} & $\Longrightarrow$ & \TT{= x ( = y (+ x w))} \\
\TT{x AND y OR z} & $\Longrightarrow$ & error
\end{tabular}

Here $\Longrightarrow$ means `is reformatted as'.  Furthermore, the
parentheses introduced by the rewrite are \underline{implied},
which means that the lists they bracket have \underline{no}
\TT{.initiator} or \TT{.terminator}, and the parentheses are
merely written here to indicate sublists in the expression structure.

Reformatters can detect parsing errors, such the fact that both
operators in `\TT{x AND y OR z}' are not identical (when both are
infix operators with the same precedence).

Note that what would be parsing errors in some other parsing systems
are not in this system.  For example,

\hspace*{2em}\begin{tabular}{lcl}
\TT{x AND AND y} & $\Longrightarrow$ & \TT{AND x (AND y)} \\
\end{tabular}

because the second \TT{AND} is not considered to be an operator and
`\TT{AND y}' is considered to be a valid subexpression that might be
a variable name.  If this does not name anything, a naming error should
be detected, but this is not a parsing error.

In some circumstances 
the bracketed subexpression recognition pass merges the brackets
it finds into a list returned by a reformatter.
If the bracketed subexpression recognition pass
would otherwise
return a list (with \TT{.initiator} or \TT{.terminator}) that has a single
element which is a list without an \TT{.initiator} or
\TT{.terminator}, then instead of forming the outer list,
the bracketed subexpression recognition
pass copies its attributes to the inner list.

Thus given `\TT{(x,y)}', the `\TT{separator}'
reformatter will return
\begin{indpar}\begin{verbatim}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
so without this merging the bracketed subexpression recognition
pass would produce
\begin{indpar}\begin{verbatim}
@2 = @1 {| .initiator = "("; .terminator = ")" |}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
but instead it produces
\begin{indpar}\begin{verbatim}
@3 = x y :|
    .initiator = "("
    .terminator = ")"
    .separator = ","
\end{verbatim}\end{indpar}

Sometimes \ikey{temporaries}{temporary}\label{TEMPORARY}
are introduced by reformatting.  The syntax involving temporaries is:

\begin{indpar}
\emkey{temporary-definition} ::= {\em temporary} {\em subexpression} \\[1ex]
\emkey{temporary} ::= \TT{\$} {\em natural-number}
\end{indpar}

During reformatting, a subexpression may be replaced by
a {\em temporary-definition} containing the subexpression.  This
defines the {\em temporary} as a name for the value of the subexpression.
Then the {\em temporary} can be used in the reformatted
expression to refer to this value.  An example is

\begin{center}
\TT{x == y + 3 == z} ~~~ $\Longrightarrow$ ~~~
\TT{AND (== x (\$ 563 (+ y 3))) (== (\$ 563) z)}
\end{center}

Here the temporary has been used to avoid computing \TT{y + 3}
more than once.

The {\em decimal-naturals} in {\em temporaries} must be assigned so no
two {\em temporary-definitions} ever have the same {\em temporary}.

With these things in mind, the reformatters are:

\begin{indpar}[1em]

\newcommand{\OP}[1]{\ttmkey{#1}{reformatting}}
\newcommand{\NBOP}[1]{\ttmkey{#1}{reformatting}}

\bigskip

\ttmkey{separator}{reformatter} \hfill \OP{;} ~~~ \OP{,}

\begin{indpar}[0.5em]
May only be used with \TT{nofix} operators.

There must be at least one operator, and all operator values must
be identical.  Necessarily any two operands are separated by an operator,
but operators my be consecutive and may begin or end the subexpression.

Empty list operands are inserted to make all operators
infix.  Then the operators are deleted, the resulting list of
operands is given a \ttmkey{.separator}{produced by parsing}
attribute with value of the operator token,
and this is returned as the result of the reformatting.  Examples
with `\TT{,}' as the operator are:

\hspace*{2em}\begin{tabular}{lcl@{~~~~~}l}
\TT{x , y} & $\Longrightarrow$ & \TT{x y}
					& with \TT{.separator} \TT{","} \\
\TT{, y} & $\Longrightarrow$ & \TT{() y}
					& with \TT{.separator} \TT{","} \\
\TT{x ,} & $\Longrightarrow$ & \TT{x ()}
					& with \TT{.separator} \TT{","} \\
\TT{x ,, y} & $\Longrightarrow$ & \TT{x () y}
					& with \TT{.separator} \TT{","} \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{declare}{reformatter} \hfill \NBOP{<-{}-} ~~~ \NBOP{\{\}} ~~~ \OP{:}

\begin{indpar}[0.5em]
May only be used with \TT{nofix}, \TT{prefix}, or \TT{infix} operators.


All operators but the first must be bracketed subexpressions,
and any operands must be just before or just after the first operator.
If the first operator is not preceded by an operand,
an empty list is inserted as the preceding operand.
Similarly if first operator is not followed by an operand, an empty
list is inserted as the following operand.
Then the first operator is moved to the
beginning of the expression and the remaining
bracketed operators are converted to operands.
Indented subexpressions are treated as bracketed subexpressions and
may be bracketed operators.

For example, if \TT{<-{}-} is a nofix operator with this reformatter, and
\TT{\{ \}} bracketed subexpressions and \TT{:} indented subexpressions
are afix operators of the same precedence:

\hspace*{2em}\begin{tabular}{lcl}
\TT{x <-{}- y \{ z \}} & $\Longrightarrow$ & \TT{<-{}- x y \{ z \}} \\
\TT{x <-{}- \{ z \}} & $\Longrightarrow$ & \TT{<-{}- x () \{ z \}} \\
\TT{<-{}- y \{ z \}} & $\Longrightarrow$ & \TT{<-{}- () y \{ z \}} \\
\TT{x <-{}-} & $\Longrightarrow$ & \TT{<-{}- x ()}
\\[1ex]
\begin{tabular}{@{}l@{}}
\TT{x~<-{}-~u v w:} \\
\TT{~~~~~~z}
\end{tabular}
& $\Longrightarrow$ &
\begin{tabular}{@{}l@{}}
\TT{<-{}- x ( u v w ):} \\
\TT{~~~~z}
\end{tabular}
\end{tabular}

Note that because \TT{\{ \}} bracketed subexpressions are afix operators
with same precedence as \TT{<-{}-},
`\TT{x <-{}- y \{ z \}}' does \underline{not}
end up as `\TT{<-{}- x ( y \{ z \} )}'.

\end{indpar}

\bigskip


\ttmkey{right associative}{reformatter}
    \hfill \NBOP{=} ~~~ \NBOP{+=} ~~~ \NBOP{-=} ~~~ \NBOP{*=} ~~~ \NBOP{/=}

\begin{indpar}[0.5em]
May only be used with \TT{infix} operators.

Therefore operands and operators alternate,
with the first and last subexpression
elements being operands, and there is at least one operator.

If there is only one operator, it is simply moved to the front.  If there
are several, they are rewritten as one operator subexpressions so the
rightmost executes first.  Thus if \TT{=}, \TT{+=}, and \TT{*=}
are all infix operators of the same precedence with this reformatter:

\hspace*{2em}\begin{tabular}{lcl}
\TT{y = z} & $\Longrightarrow$ & \TT{= y z} \\
\TT{x = y = z} & $\Longrightarrow$ & \TT{= x (= y z)} \\
\TT{x += y *= z} & $\Longrightarrow$ & \TT{+= x (*= y z)} \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{unary}{reformatter}
    \hfill \NBOP{NOT} ~~~ \NBOP{+} ~~~ \NBOP{-} ~~~ \NBOP{@}

\begin{indpar}[0.5em]
May only be used with \TT{nofix} or \TT{prefix} operators.

The subexpression must have exactly two elements, an operator followed
by an operand.  The subexpression is left unchanged.  Examples:

\hspace*{2em}\begin{tabular}{lcl}
\TT{NOT x} & $\Longrightarrow$ & \TT{NOT x} \\
\TT{x NOT} & $\Longrightarrow$ & error \\
\TT{x NOT y} & $\Longrightarrow$ & error \\
\TT{NOT NOT x} & $\Longrightarrow$ & error \\
\TT{- x y} & $\Longrightarrow$ & error \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{binary}{reformatter} \hfill \NBOP{BUT NOT} ~~~ \NBOP{/}
					           ~~~ \NBOP{\^{ }}

\begin{indpar}[0.5em]
May only be used with \TT{nofix} or \TT{infix} operators.

The subexpression must have exactly three elements, an operand
followed by an operator followed by an operand.  The operator is moved
to the beginning of the expression.  Examples:

\hspace*{2em}\begin{tabular}{lcl}
\TT{x BUT NOT y} & $\Longrightarrow$ & \TT{BUT NOT x y} \\
\TT{x / y} & $\Longrightarrow$ & \TT{/ x y} \\
\TT{x \^{ } y} & $\Longrightarrow$ & \TT{\^{ } x y} \\
\TT{x / y / z} & $\Longrightarrow$ & error \\
\TT{/ y} & $\Longrightarrow$ & error \\
\TT{x /} & $\Longrightarrow$ & error \\
\end{tabular}

Note that in these examples `\TT{BUT NOT}' is a single label element
of the resulting subexpression,
and \underline{not} two word elements of the subexpression.
\end{indpar}

\bigskip

\ttmkey{infix}{reformatter} \hfill \NBOP{AND} ~~~ \NBOP{OR} ~~~ \NBOP{*}

\begin{indpar}[0.5em]
May only be used with \TT{infix} operators.

Operands and operators must alternate, with the first and last subexpression
elements being operands, there must be at least one operator, and all
operators must be the same.  The first operator is moved to the
front of the subexpression, and the other operators are removed.
Examples:

\hspace*{2em}\begin{tabular}{lcl}
\TT{x AND y} & $\Longrightarrow$ & \TT{AND x y} \\
\TT{x AND y AND z} & $\Longrightarrow$ & \TT{AND x y z} \\
\TT{x OR y} & $\Longrightarrow$ & \TT{OR x y} \\
\TT{x OR y OR z} & $\Longrightarrow$ & \TT{OR x y z} \\
\TT{x * y} & $\Longrightarrow$ & \TT{* x y} \\
\TT{x * y * z} & $\Longrightarrow$ & \TT{* x y z} \\
\TT{AND y AND z} & $\Longrightarrow$ & error \\
\TT{x AND AND z} & $\Longrightarrow$ & error \\
\TT{x AND y AND} & $\Longrightarrow$ & error \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{infix and}{reformatter} \TT{(} {\em and\_op} \TT{)} \hfill
	\NBOP{==} ~~~ \NBOP{<} ~~~ \NBOP{>} ~~~
	\NBOP{/=} ~~~ \NBOP{!=} ~~~
	\NBOP{=>} ~~~ \NBOP{>=} ~~~
	\NBOP{=<} ~~~ \NBOP{<=}

\begin{indpar}[0.5em]
May only be used with \TT{infix} operators.

Operands and operators must alternate, with the first and last subexpression
elements being operands, and there must be at least one operator.
If there is only one operator, it is simply moved to the front.  Otherwise
the expression is rewritten so the operators become two-argument functions
whose values are combined by a multi-argument {\em and\_op} and whose
shared operands are represented by temporaries (\pagref{TEMPORARY})
to avoid computing an operand twice. 
Examples in which \TT{<}, \TT{==}, \TT{!=}, and \TT{<=} all have
the same precedence and this reformatter with {\em and\_op} being `\TT{AND}':

\hspace*{2em}\begin{tabular}{lcl}
\TT{x < y < z} & $\Longrightarrow$ &
    \TT{AND (< x (\$ 56 y)) (< (\$ 56) z))} \\[1ex]
\TT{w == x != y <= z} & $\Longrightarrow$
             & \begin{tabular}[t]{@{}l@{~}l@{}}
	       \TT{AND} & \TT{(== w (\$ 57 x))} \\
			  & \TT{(!= (\$ 57) (\$ 58 y))} \\
			  & \TT{(<= (\$ 58) z)} \\
	       \end{tabular}
\end{tabular}

Note that sequences of comparison operators are treated as they are
in mathematics and not as they are in classical programming languages.
E.g., \TT{x<y<z} means \TT{x<y AND y<z} and \underline{not}
\TT{(x<y)<z}.
\end{indpar}

\bigskip

\ttmkey{sum}{reformatter} \TT{(} {\em plus\_op} {\em minus\_op} \TT{)}
			  \hfill \NBOP{+} ~~~ \NBOP{-}

\begin{indpar}[0.5em]
May only be used with \TT{infix} operators.

Operands and operators must alternate, with the last subexpression
element being an oper\-and, and there must be at least one operator.
The operators must be either {\em plus\_op} or {\em minus\_op}.

Every `{\em minus\_op} {\em operand}' is rewritten as
`{\em plus\_op} \TT{(} {\em minus\_op} {\em operand} \TT{)}'.
Then the first {\em plus\_op} is moved to the front and the other
{\em plus\_op}'s are removed.

For example, if {\em plus\_op} is `\TT{+}' and {\em minus\_op} is
`\TT{-}' and both these operators are infix with the same precedence
and this reformatter:

\hspace*{2em}\begin{tabular}{lcl}
\TT{x + y} & $\Longrightarrow$ & \TT{+ x y} \\
\TT{x - y} & $\Longrightarrow$ & \TT{+ x (- y)} \\
\TT{x - y + z - w} & $\Longrightarrow$ & \TT{+ x (- y) z (- w)} \\
\end{tabular}

\end{indpar}

\bigskip

\end{indpar}


\subsubsection{The Operator Parsing Algorithm}
\label{OPERATOR-PARSER-ALGORITHM}


The operator parsing pass runs an
algorithm that accepts as input a sequence of tokens
which we call an `expression'
and edits this input, changing it into a single token.
To do this it performs the following steps:
\begin{itemlist}[0.7in]
\item[Step 1:] Identify subexpressions within the expression and run the
operator parsing pass on these, converting them into a single
\TT{BRACKETABLE} or lexeme token.
\item[Step 2:] Identify operators within the expression and replace them
with \TT{OPERATOR} tokens.
\item[Step 3:] If no operators were found in the expression,
run any passes subsequent to the operator parsing pass on the expression,
and then if the expression (after running the subsequent passes)
has zero or more than one
token, replace the expression by a single \TT{BRACKETABLE} token listing the
tokens of the expression.

If operators were found in the expression,
run the reformatter of the first operator
in the expression.  This replaces the expression by a single
\TT{BRACKETABLE} or lexeme token.
If no reformatter is provided by the first operator, a default
reformatter is run that replaces the expression by a single \TT{BRACKETABLE}
token whose value has the operator label as its \TT{.operator} attribute.

After this step the expression is always a single \TT{BRACKETABLE} or
lexeme token.
\end{itemlist}

The token list at the point where Step 3 is about to execute
obeys the following requirements:
\begin{itemlist}[1.3in]
\item[Requirement 1:] 
All the \TT{OPERATOR} tokens in the token list are for operators
with the same precedence.  Furthermore, if $P$ is this precedence, and
$P'$ is the precedence of operators in an \TT{BRACKETABLE} token of the list,
then either $P<P'$ or all of the following are true:
\begin{itemize}
\item[(a)] $P=P'$
\item[(b)] The token list contains only two members, an operator and
a \TT{BRACK\-ET\-ABLE} token operand.
\item[(c)] Either the token list and the operand both begin with a prefix
operator, or both end with a postfix operator.
\end{itemize}
\item[Requirement 2:] 
The list does \underline{not} contain two consecutive non-\TT{OPERATOR} tokens.
\item[Requirement 3:] 
The first \TT{OPERATOR} token in the list is not afix.
\item[Requirement 4:] 
If the list contains a prefix \TT{OPERATOR} token, that is the first
token in the list, and it is followed in the list by a
non-\TT{OPERATOR} token.
\item[Requirement 5:] 
All infix \TT{OPERATOR} tokens in the list are both preceded by and
followed by non-\TT{OPERATOR} tokens.
\item[Requirement 6:] 
If the list contains a postfix \TT{OPERATOR} token, that is the last
token in the list, and it is preceded in the list by a
non-\TT{OPERATOR} token.
\end{itemlist}

A single
lexeme token output by a operator parsing pass may be
thought of as the equivalent of one of the following:
\begin{itemize}
\item[(a)] If the token is not a quoted string, and therefore
has a token value that is a MIN string, the token is equivalent to
a single \TT{BRACKETABLE} token whose token value is a MIN object
with no \TT{.separator} attribute whose only element is this MIN string.
\item[(b)] If the token is a quoted string, the token is equivalent to
a single \TT{BRACKETED} token whose token value
is a MIN object with one element equal to the
token value converted to a MIN string and with
an \TT{.initiator} attribute equal to \TT{"}.
\end{itemize}
When a single lexeme token output from an operator parsing pass
must be converted to an expression token, it is converted according
to this equivalence.

The operator parsing pass scans its input token list from
left to right, recognizing operators, beginning non-explicitly
bracketed subexpressions, and ending such subexpressions.
At any point in the scan the pass obeys the
following rules:
\begin{itemlist}[0.7in]
\item[Rule 1:] An afix operator is not recognized unless it
is proceeded by an operator of equal precedence with no
intervening operators of less precedence.
\item[Rule 2:] A prefix operator of precedence $P'$
must be preceded by the beginning of
the entire token list, or by an operator
of precedence less than $P'$,
or by a prefix operator of precedence equal to $P'$,
else the prefix operator is not recognized.
\item[Rule 3:] An infix operator of precedence $P'$
must be preceded by a non-operator,
or by an operator of precedence greater than $P'$,
else the infix operator is not recognized.
\item[Rule 4:] A postfix operator of precedence $P'$
must be preceded by a non-operator,
or by an operator of precedence greater than $P'$,
or by a postfix operator of precedence equal to $P'$,
else the postfix operator is not recognized.
\item[Rule 5:] A recognized prefix operator of precedence $P'$
must be followed by a non-operator or by an operator
of precedence greater than $P'$,
or by a prefix operator of precedence equal to $P'$,
else an `error operand' which is not an operator
is inserted after the prefix operator
and an error is announced.
\item[Rule 6:] A recognized infix operator of precedence $P'$
must be followed by a non-operator or by an operator
of precedence greater than $P'$,
else an `error operand' which is not an operator
is inserted after the infix operator
and an error is announced.
\item[Rule 7:] A recognized postfix operator of precedence $P'$
must be followed by the end of the entire token list,
or by an operator of precedence less than $P'$,
or by a postfix operator of precedence equal to $P'$,
else an `error nofix operator' of precedence $P'-1$
is inserted after the postfix operator and an error is announced.
\item[Rule 8:] When an operator is found, a new subexpression
with the precedence of the found operator is begin if one of
the following is true:
\begin{itemize}
\item[(a)] There is no previous operator outside all ended subexpressions.
\item[(b)] The found operator has higher precedence than the nearest
previous operator outside all ended subexpressions.
\item[(c)] The found operator is immediately preceded by a prefix
operator of equal precedence to the found operator.
\end{itemize}
The new subexpression begins just after the nearest previous operator
that is outside all ended subexpressions, if there is such an operator,
or at the beginning of the entire list, otherwise.
\item[Rule 9:] A subexpression is ended just before an operator
which has precedence lower than the precedence of the subexpression,
just before the end of the list, or just before an operator which
has precedence equal to the precedence of the subexpression if that
operator immediately follows a postfix operator.
\item[Rule 10:] A subexpression 
is replaced when it ends by a single BRACKETABLE whose
elements are the values of the tokens in the subexpression, unless
the subexpression contains just a single non-operator token.
\end{itemlist}

By simply by enforcing these rules the operator parser pass enforces
the requirements listed above.

During its left-to-right scan the operator parser pass maintains
the following state:
\begin{itemlist}[0.7in]
\item[$C$:] A pointer to the current token, initialized to the
first token in the input.
\item[$N$:] A pointer to the next token after the subexpression
being input, which may be an end-of-file token.  Not changed during
the scan from its initial value.  Initially $C\neq N$.
\item[$P$:] A stack of subexpression terminating precedences,
initialized to a one element stack containing a precedence less
than any legal operator precedence.  Whenever an operator is found,
the top of this stack is set to the precedence of the operator
(the stack may be pushed or popped before this is done).
\item[$F$:] A stack of pointers to the first token in a subexpression,
initialized to a one element stack containing a pointer to the first
token in the input.  Whenever an operator is found, the top of this
stack is set to point to the token after the operator (the stack
may be pushed or popped before this is done).
\item[$T$:] The type of the last operator found.  Valid only if
$C=F$ (meaning $C$ equals the top of the $F$ stack, and so $C$
points at the token after the operator).
Can equal {\em prefix}, {\em postfix}, {\em nofix}, {\em infix}, or {\em none}.
Initialized to {\em none}.
\end{itemlist}

In the following $F$ is used to denote either the stack $F$ or
the top element of this stack.  Similarly $P$ is used to denote either the
stack $P$ or the top element of this stack.

The operator parser pass algorithm simply repeats the following
steps in a loop:
\begin{itemlist}[1.2in]
\item[Loop Step 1:]
If $C\neq N$, find an operator beginning at token $C$, if there is one.

If $C=F$ (i.e., $C$ is at the beginning of the token list or just after
an operator of precedence $P$),
prefix operators of precedence less than $P$ are ignored,
prefix operators of precedence equal to $P$ are ignored unless
$T=\mbox{\em prefix}$,
infix operators of precedence greater than or equal to $P$ are ignored,
postfix operators of precedence greater than $P$ are ignored,
postfix operators of precedence equal to $P$ are ignored unless
$T=\mbox{\em postfix}$.

If $C\neq F$ (i.e., a non-operator is just before $C$),
prefix operators are ignored.

Any afix operator whose precedence is not in the $P$ stack is ignored.

Any operator whose selectors are disjoint from the current parser context
selectors is ignored.

Among all non-ignored operators, a longest
is selected, and among all the longest, the one with the most recent
operator definition is selected.

If an operator was found, replace its tokens by a single
OPERATOR token, point $C$ at that token.  Let $P'$ be the precedence
of the found operator and $T'$ be its type.
\item[Loop Step 2:]
If $C=F$ and $T=\mbox{\em postfix}$
(the token before $C$ is a postfix operator),
$C\neq N$, and either no operator was find in Loop Step 1,
or an operator was found and either $P'>P$
or both $P'=P$ and $T'\not=\mbox{\em postfix}$,
insert the error nofix operator of precedence
equal to $P-1$ as a single
OPERATOR token before $C$, set $C$ to point at it,
set $P'=P-1$,
announce an error, and continue (as if an operator were found in
Loop Step 1).

\item[Loop Step 3:]
Else if $C\neq N$
and no operator was find in Loop Step 1 or generated by Loop Step 2,
re-point $C$ to the next token after $C$ and go to the next loop iteration.

Note that if the iteration continues after this step,
then either $C=N$ or an operator was found in Loop Step 1
or generated in Loop Step 2.
\item[Loop Step 4:]
If $C=F$ and any of the following are true:
\\[1ex]
\hspace*{0.2in}
\begin{tabular}{@{}l@{}}
$T=\mbox{\em infix}$ and $C=N$ or $P'\leq P$, \\
$T=\mbox{\em prefix}$ and $C=N$ or $P'<P$
    or both $P'=P$ and $T'\not=\mbox{\em prefix}$
\end{tabular}
\\[1ex]
then insert
an new error operand lexeme token before $C$,
set $F$ to this new token,
announce an error, and then continue as if no error were found.
\item[Loop Step 5:]
If $C\not=F$,
apply Step 3 above to the list of tokens beginning with
$F$ and ending just before $C$.  This replaces this list of tokens
by a single non-operator token.

If $C=N$, pop the $P$ and $F$ stacks.  If these stacks are now
empty, terminate the operator parser pass algorithm.  Otherwise
repeat this loop step.

Else if $P'<P$ or both $P'=P$ and $T=\mbox{\em postfix}$,
pop the $P$ and $F$ stacks and repeat this loop step
(cannot happen if the $P$ and $F$ stacks have only one entry as
in that case $P$ is less than any possible $P'$).

Else if $P'>P$ or both $P'=P$ and $T=\mbox{\em prefix}$,
push $P'$ into the $P$ stack, and push a pointer to the
next token after $C$ into the $F$ stack.

Else if $P'=P$, set $F$ to point at the next token after $C$.

\item[Loop Step 6:]
Set $T=T'$,
re-point $C$ to the token after $C$, and iterate the loop.
\end{itemlist}

\clearpage

\appendix

\section{Standard Lexical Program}
\label{STANDARD-LEXICAL-PROGRAM}

\begin{indpar}
\begin{verbatim}
// This file was automatically generated from
// ll_lexeme_standard.lexcc.


begin standard lexical program;

"<ascii-char>" = "<0>-<7F>"  [ASCII Character]

// NON_ASCII_LETTERS, NON_ASCII_COMBINING_
// CHARACTERS, NON_ASCII_CONTROL_CHARACTERS are
// defined in ll_lexeme_non_ascii_characters.h.

"<non-ascii-letter>" = NON_ASCII_LETTERS

"<non-ascii-combining-char>" =
    NON_ASCII_COMBINING_CHARACTERS

"<non-ascii-control-char>" =
    NON_ASCII_CONTROL_CHARACTERS

"<ascii-letter>" = "a-z" | "A-Z";

"<digit>" = "0-9";

"<hex-digit>" = "0-9" | "A-F";

"<non-digit>" = ~ "<digit>";

"<letter>" = "<ascii-letter>"
           | "<non-ascii-letter>"

"<non-ascii-word-char>" =
      "<non-ascii-letter>"
    | "<non-ascii-combining-char>"

// Context sensitive character classifications,
// e.g., classifying ' as a word character if it
// is followed by a letter, cannot be included
// in character pattern definitions, but are
// noted in comments.  They are accounted for
// by separate lexeme table entries below.

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@"
              | "#" | "$" | "%" | "^" | "&"
              | "=" | "|" | ">" | "_" | "!"
              | "?" | ":";
              //
              // Also . not followed by a digit
              //      / not surrounded by digits
              //        or followed by /
              //      < not beginning escaped
              //        hex character

"<non-slash-char>" = ~ "/";

"<separator-char>" = "(" | ")" | "[" | "]"
                   | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter

"<misplaced-space-char>" =
        "<CR>" | "<VT>" | "<FF>"

"<ascii-control-char>" = "<0>-<1F>" | "<7F>"

"<control-char>" = "<ascii-control-char>"
                 | "<non-ascii-control-char>"

"<control-char-except-CR-LF>" =
    "<control-char>" & ~ "<CR>" & ~ "<LF>"

"<horizontal-space-char>" = " " | "<HT>";

"<escape-char>" = "A-Z" | "0-9" | "-";


begin main master table;

   // Unrecognized characters or escapes, etc,
   // outside quoted strings are output as
   // lexemes, and can separate other lexemes.
   // If these are treated by post-processing
   // in the same manner as horizontal space,
   // they could be replaced by horizontal space
   // without changing the semantics of the
   // output.
   //
   // Inside quoted strings, unrecognized
   // escapes are treated as erroneous atoms,
   // translated to "", and ignored.  The
   // lexemes output would be the same if they
   // were removed.

   // Whitespace is separated out into 4 types
   // of lexemes:
   //
   //   `space'
   //       single spaces and horizontal tabs
   //   `line break'
   //       linefeeds, carriage returns, form
   //       feeds, and vertical tabs, with at
   //       least one line feed
   //   `misplaced space'
   //       ditto but with no line feed
   //   `comments'
   //       `//' up to just before next line
   //        break, misplaced space, or (pre-
   //        mature) end of file
   //
   "//" call comment;
   "/"  call mark;

   "<horizontal-space-char>"
        call horizontal space;

   "<LF>" call line break;
   "<misplaced-space-char>"
        call misplaced space;

   "<letter>" call word;

   "'<letter>" call word;
   "'" output separator;

  "<" "<digit>"
          match escaped hex char
          require "<non-ascii-letter>"
          call word
     else match escaped hex char
          require "<ascii-char>"
          output ascii escape seq
     else match escaped hex char
          output non letter escape seq
     else keep 1 call mark;
   "<" call mark;

   "<mark-char>" call mark;

   "<digit>" keep 0 call natural number;
             // We keep 0 so natural number can
             // recognize <digit>,<digit> etc.

   ".<digit>" keep 1 call number;
              // We keep 1 so number can recog-
              // nize <digit>,<digit> etc.
   "." call mark;

   "<separator-char>" output separator;

   "," output separator;

   "<Q>" translate to "" call quoted string;

   "<others>" output misplaced char;

   output end of file;

end main master table;


// The below tables are entered from the master
// table with the first zero, one, or two
// characters scanned.


begin comment lexeme table;

   "<LF>" keep 0 return;
   "<misplaced-space-char>" keep 0 return;

   "<others>" accept;

   goto premature end of file;

end comment lexeme table;


begin horizontal space lexeme table;

   "<horizontal-space-char>" accept;

   return;

end horizontal space lexeme table;


begin misplaced space lexeme table;

   "<LF>" goto line break;

   "<misplaced-space-char>" accept;

   return;

end misplaced space lexeme table;


begin line break lexeme table;

   "<LF>" accept;
   "<misplaced-space-char>" accept;

   return;

end line break lexeme table;


begin word lexeme table;

   "<letter>" accept;
   "<non-ascii-combining-char>" accept;

   "'<letter>" accept;

    "<" "<digit>"
              match escaped hex char
              require "<non-ascii-word-char>"
         else keep 0 return;

   return;

end word lexeme table;


begin mark lexeme table;

   "<mark-char>" accept;
   "<non-ascii-combining-char>" accept;

   ".<digit>" keep 0 return;
   "." accept;

   "//" keep 0 return;
   "/" accept;

    "<" "<digit>"
          match escaped hex char
          require "<non-ascii-combining-char>"
      else
          match escaped hex char
          keep 0 return;
      else
          keep 1;
    "<" accept;

   return;

end mark lexeme table;


begin natural number lexeme table;


   // In order to recognize , and / surrounded
   // by digits as number atoms, entries to this
   // table upon recognizing "X<digit>" must do
   // a `keep 1' so the digit will be left to be
   // recognized by <digit>/<digit> etc.

   // Alternatively we could have a separate
   // table for the state where the last atom
   // ended with a digit.

   "<digit>:<digit>" keep 2 goto number;
   "<digit>/<digit>" keep 2 goto number;
   "<digit>,<digit>" keep 2 goto number;
   "<digit>" accept;

   ".<digit>" keep 1 goto number;

   return;

end natural number lexeme table;


begin number lexeme table;

   // See note on , and / in `natural number'
   // table above.

   "<digit>:<digit>" keep 2;
   "<digit>/<digit>" keep 2;
   "<digit>,<digit>" keep 2;
   "<digit>" accept;

   ".<digit>" keep 1;

   return;

end number lexeme table;


begin quoted string lexeme table;

    "<Q>" translate to "" return;
            // End quoted string.

    "<" match escaped char
        else match unrecognized escape seq
             error unrecognized escape seq
             translate to ""
        else accept;

    "<LF>"
        keep 0 goto premature end of line;

    "<CR><LF>"
        keep 0 goto premature end of line;
    "<CR>"
        error misplaced control char
        translate to "";

    "<control-char-except-CR-LF>"
        error misplaced control char
        translate to "";

    "<others>" accept;

    goto premature end of file;

end quoted string lexeme table;


begin escaped char atom table;

    "<" "ACK" ">" translate to "<ACK>";
    "<" "BEL" ">" translate to "<BEL>";
    "<" "BS" ">" translate to "<BS>";
    "<" "CAN" ">" translate to "<CAN>";
    "<" "CR" ">" translate to "<CR>";
    "<" "DC1" ">" translate to "<DC1>";
    "<" "DC2" ">" translate to "<DC2>";
    "<" "DC3" ">" translate to "<DC3>";
    "<" "DC4" ">" translate to "<DC4>";
    "<" "DEL" ">" translate to "<DEL>";
    "<" "DLE" ">" translate to "<DLE>";
    "<" "EM" ">" translate to "<EM>";
    "<" "ENQ" ">" translate to "<ENQ>";
    "<" "EOT" ">" translate to "<EOT>";
    "<" "ESC" ">" translate to "<ESC>";
    "<" "ETB" ">" translate to "<ETB>";
    "<" "ETX" ">" translate to "<ETX>";
    "<" "FF" ">" translate to "<FF>";
    "<" "FS" ">" translate to "<FS>";
    "<" "GS" ">" translate to "<GS>";
    "<" "HT" ">" translate to "<HT>";
    "<" "LF" ">" translate to "<LF>";
    "<" "NAK" ">" translate to "<NAK>";
    "<" "NL" ">" translate to "<NL>";
    "<" "NUL" ">" translate to "<NUL>";
    "<" "Q" ">" translate to "<Q>";
    "<" "RS" ">" translate to "<RS>";
    "<" "SI" ">" translate to "<SI>";
    "<" "SO" ">" translate to "<SO>";
    "<" "SOH" ">" translate to "<SOH>";
    "<" "SP" ">" translate to "<SP>";
    "<" "STX" ">" translate to "<STX>";
    "<" "SUB" ">" translate to "<SUB>";
    "<" "SYN" ">" translate to "<SYN>";
    "<" "US" ">" translate to "<US>";
    "<" "VT" ">" translate to "<VT>";

    "<" "<digit>" match escaped hex char
            else fail;

    fail;

end escaped char atom table;


begin escaped hex char atom table;

    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit>" ">" translate hex 1 1;

    fail;

end escaped hex char atom table;


begin unrecognized escape seq atom table;

    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>" ">";
    "<" "<escape-char>" ">";

    fail;

end unrecognized escape seq atom table;


begin premature end of line master table;

    output premature end of line goto main;

end premature end of line master table;


begin premature end of file master table;

    output premature end of file goto main;

end premature end of file master table;


end standard lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{Alternate Lexical Program}
\label{ALTERNATE-LEXICAL-PROGRAM}

This \key{alternate lexical scheme} is the original version
of the standard lexical scheme defined on
\pagref{LEXEME-PROGRAM-LEXEMES}.  The main difference is
that the character sequence
\begin{center}
\TT{(AB,CD+E,)}
\end{center}
scans as the 4 lexemes
\begin{center}
\TT{( AB,CD+E , )}
\end{center}
in the standard scheme, and as the 8 lexemes
\begin{center}
\TT{( AB , CD + E , )}
\end{center}
in this alternate scheme.  That is, in the alternate scheme
word lexemes can only contain letters, mark lexemes can only
contain marks, separator lexemes can only contain separators,
and so forth.  Special exceptions are made for period followed
by a digit, comma surrounded by digits, and so forth.

The syntax equations for the alternative lexical scheme and
the lexical program for that scheme are:

\begin{indpar}
\emkey{lexeme} ::= {\em word}
               $|$ {\em numeric}
               $|$ {\em mark}
	       $|$ {\em separator}
	       $|$ {\em quoted-string}
	       $|$ {\em comment}
\\[0.3ex]
\emkey{word} :::= {\em word-prefix-character}\QMARK{}
                 {\em word-character}\PLUS{}
\\[0.3ex]
\emkey{numeric} :::= {\em numeric-character}\PLUS{}
\\[0.3ex]
\emkey{natural-number} :::= {\em digit}\PLUS{}
\\[0.3ex]
\emkey{non-natural-numeric} ::= {\em numeric} except {\em natural-number}
\\[0.3ex]
\emkey{mark} :::= {\em mark-character}\PLUS{}
\\[0.3ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{comment} :::= \TT{//}{\em comment-character}\STAR{}
\\[0.3ex]
\emkey{separator} ::= {\em separator-character} except \TT{|} or \TT{:}
                  $|$ \TT{|}\PLUS{}
                  $|$ \TT{:}\PLUS{}
\\[1ex]
\emkey{word-prefix-character} ::= \TT{.}
	\begin{tabular}[t]{@{}l@{}}
	followed by a {\em letter} \\
	and \underline{not} preceded by a {\em mark-character}
	\end{tabular}
\\[0.3ex]
\emkey{word-character}
	::= {\em letter}
	$|$ \TT{'} followed by a letter
\\[0.3ex]
\emkey{letter} ::= {\em lower-case-letter} $|$ {\em upper-case-letter}
\\[0.3ex]
\emkey{lower-case-letter} ::=
                               \TT{a}%
			    $|$\TT{b}%
			    $|$\TT{c}%
			    $|$\TT{d}%
			    $|$\TT{e}%
			    $|$\TT{f}%
			    $|$\TT{g}%
			    $|$\TT{h}%
			    $|$\TT{i}%
			    $|$\TT{j}%
			    $|$\TT{k}%
			    $|$\TT{l}%
			    $|$\TT{m}%
			    $|$\TT{n}%
			    $|$\TT{o}%
			    $|$\TT{p}%
			    $|$\TT{q}%
			    $|$\TT{r}%
			    $|$\TT{s}%
			    $|$\TT{t}%
			    $|$\TT{u}%
			    $|$\TT{v}%
			    $|$\TT{w}%
			    $|$\TT{x}%
			    $|$\TT{y}%
			    $|$\TT{z}
\\[0.3ex]
\emkey{upper-case-letter} ::=
                               \TT{A}%
			    $|$\TT{B}%
			    $|$\TT{C}%
			    $|$\TT{D}%
			    $|$\TT{E}%
			    $|$\TT{F}%
			    $|$\TT{G}%
			    $|$\TT{H}%
			    $|$\TT{I}%
			    $|$\TT{J}%
			    $|$\TT{K}%
			    $|$\TT{L}%
			    $|$\TT{M}%
			    $|$\TT{N}%
			    $|$\TT{O}%
			    $|$\TT{P}%
			    $|$\TT{Q}%
			    $|$\TT{R}%
			    $|$\TT{S}%
			    $|$\TT{T}%
			    $|$\TT{U}%
			    $|$\TT{V}%
			    $|$\TT{W}%
			    $|$\TT{X}%
			    $|$\TT{Y}%
			    $|$\TT{Z}
\\[0.3ex]
\emkey{mark-character}
	\begin{tabular}[t]{@{}rl@{}}
	::= & \TT{+}%
        $|$\TT{-}%
        $|$\TT{*}%
        $|$\TT{/}%
        $|$\TT{\textbackslash}%
        $|$\TT{\textasciitilde}%
        $|$\TT{@}%
        $|$\TT{\#}%
        $|$\TT{\$}%
        $|$\TT{\%}%
        $|$\TT{\^{ }}%
        $|$\TT{\&}%
        $|$\TT{=}%
        $|$\TT{|}%
        $|$\TT{<}%
        $|$\TT{>}%
        $|$\TT{\_}%
        $|$\TT{!}%
        $|$\TT{?} \\
        $|$ & \TT{.} \begin{tabular}[t]{@{}l@{}}
	             not surrounded by {\em digits} \\
		     and either preceded by a {\em mark-character} \\
		     or \underline{not} followed by a {\em letter} \\
		     \end{tabular} \\
        $|$ & \TT{/} \begin{tabular}[t]{@{}l@{}}
	             not surrounded by {\em digits} \\
		     or followed by a \TT{/} \\
		     \end{tabular} \\
	\end{tabular}
\\[0.3ex]
\emkey{separator-character}
	\begin{tabular}[t]{@{}rl@{}}
	::= & \TT{(}
	$|$ \TT{)}
	$|$ \TT{[}
	$|$ \TT{]}
	$|$ \TT{\{}
	$|$ \TT{\}}
	$|$ \TT{;}
	$|$ \TT{`}
	$|$ \TT{|} \\
	$|$ & \TT{,} not surrounded by {\em digits} \\
	$|$ & \TT{:} not surrounded by {\em digits} \\
	$|$ & \TT{'} not followed by a letter \\
	\end{tabular}
\\[0.3ex]
\emkey{numeric-character}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em digit} \\
	$|$ & \TT{.} surrounded by {\em digits} \\
	$|$ & \TT{,} surrounded by {\em digits} \\
	$|$ & \TT{:} surrounded by {\em digits} \\
	$|$ & \TT{/} surrounded by {\em digits} \\
	\end{tabular}
\\[0.3ex]
\emkey{digit} ::= \TT{0}%
	      $|$\TT{1}%
	      $|$\TT{2}%
	      $|$\TT{3}%
	      $|$\TT{4}%
	      $|$\TT{5}%
	      $|$\TT{6}%
	      $|$\TT{7}%
	      $|$\TT{8}%
	      $|$\TT{9} 
\\[0.3ex]
\emkey{character-representative}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{graphic-character} ::= character than makes a mark on paper
\\[0.3ex]
\emkey{special-character-representative} ::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[0.3ex]
\emkey{comment-character}
    ::= {\em graphic-character}
    $|$ {\em single-space-character}
    $|$ {\em horizontal-tab}

\end{indpar}

\begin{indpar}
\begin{verbatim}
// This lexical analyzer was the original
// layered lanugage standard lexical analyzer,
// but was replaced in that role.

// This file was automatically generated from
// ll_lexeme_alternate.lexcc.


begin alternate lexical program;

"<ascii-char>" = "<0>-<7F>"  [ASCII Character]

// NON_ASCII_LETTERS, NON_ASCII_COMBINING_
// CHARACTERS, NON_ASCII_CONTROL_CHARACTERS are
// defined in ll_lexeme_non_ascii_characters.h.

"<non-ascii-letter>" = NON_ASCII_LETTERS

"<non-ascii-combining-char>" =
    NON_ASCII_COMBINING_CHARACTERS

"<non-ascii-control-char>" =
    NON_ASCII_CONTROL_CHARACTERS

"<ascii-letter>" = "a-z" | "A-Z";

"<digit>" = "0-9";

"<hex-digit>" = "0-9" | "A-F";

"<non-digit>" = ~ "<digit>";

"<letter>" = "<ascii-letter>"
           | "<non-ascii-letter>"

"<non-ascii-word-char>" =
      "<non-ascii-letter>"
    | "<non-ascii-combining-char>"

// Context sensitive character classifications,
// e.g., classifying ' as a word character if it
// is followed by a letter, cannot be included
// in character pattern definitions, but are
// noted in comments.  They are accounted for
// by separate lexeme table entries below.

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@"
              | "#" | "$" | "%" | "^" | "&"
              | "=" | "<" | ">" | "_" | "!"
	      | "?" ;
              //
              // Also . not surrounded by digits
	      //        and not both followed by
	      //        a letter and preceeded
	      //        by a non-mark character
              //      / not surrounded by digits
              //        or followed by /

"<non-slash-char>" = ~ "/";

"<separator-char>" = "(" | ")" | "[" | "]"
                   | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter
	      //        or a digit
	      //      | (possibly repeated)
	      //      : (possibly repeated)

"<misplaced-space-char>" =
        "<CR>" | "<VT>" | "<FF>"

"<ascii-control-char>" = "<0>-<1F>" | "<7F>"

"<control-char>" = "<ascii-control-char>"
                 | "<non-ascii-control-char>"

"<control-char-except-CR-LF>" =
    "<control-char>" & ~ "<CR>" & ~ "<LF>"

"<horizontal-space-char>" = " " | "<HT>";

"<escape-char>" = "A-Z" | "0-9" | "-";


begin main master table;

   // Unrecognized characters or escapes, etc,
   // outside quoted strings are output as
   // lexemes, and can separate other lexemes.
   // If these are treated by post-processing
   // in the same manner as horizontal space,
   // they could be replaced by horizontal space
   // without changing the semantics of the
   // output.
   //
   // Inside quoted strings, unrecognized char-
   // acter representatives, such as unrecog-
   // nized escapes, are treated as erroneous
   // atoms and translated to "<UUC>".

   // Whitespace is separated out into 4 types
   // of lexemes:
   //
   //   `space'
   //       single spaces and horizontal tabs
   //   `line break'
   //       linefeeds, carriage returns, form
   //       feeds, and vertical tabs, with at
   //       least one line feed
   //   `misplaced space'
   //       ditto but with no line feed
   //   `comments'
   //       `//' up to just before next line
   //        break, misplaced space, or (pre-
   //        mature) end of file
   //
   "//" call comment;
   "/"  call mark;

   "<horizontal-space-char>"
        call horizontal space;

   "<LF>" call line break;
   "<misplaced-space-char>"
        call misplaced space;

   "<letter>" call word;

   "'<letter>" call word;
   "'<digit>" keep 1 call number;
   "'" output separator;

   "<mark-char>" call mark;

   "<digit>" keep 0 call natural number;
             // We keep 0 so natural number can
             // recognize <digit>,<digit> etc.

   ".<letter>" call word;
   "." call mark;

   "<separator-char>" output separator;

   ":<repeat>" output separator;
   "|<repeat>" output separator;

   "," output separator;

   "<Q>" translate to "" call quoted string;

   "<others>" output misplaced char;

   output end of file;

end main master table;


// The below tables are entered from the master
// table with the first zero, one, or two
// characters scanned.


begin comment lexeme table;

   "<LF>" keep 0 return;
   "<misplaced-space-char>" keep 0 return;

   "<others>" accept;

   goto premature end of file;

end comment lexeme table;


begin horizontal space lexeme table;

   "<horizontal-space-char>" accept;

   return;

end horizontal space lexeme table;


begin misplaced space lexeme table;

   "<LF>" goto line break;

   "<misplaced-space-char>" accept;

   return;

end misplaced space lexeme table;


begin line break lexeme table;

   "<LF>" accept;
   "<misplaced-space-char>" accept;

   return;

end line break lexeme table;


begin word lexeme table;

   "<letter>" accept;
   "<non-ascii-combining-char>" accept;

   "'<letter>" accept;

   return;

end word lexeme table;


begin mark lexeme table;

   "<mark-char>" accept;
   "." accept;
   "<non-ascii-combining-char>" accept;

   "//" keep 0 return;
   "/" accept;

   return;

end mark lexeme table;


begin natural number lexeme table;


   // In order to recognize X (e.g., : or /)
   // surrounded by digits as number atoms,
   // entries to this table upon recognizing
   // "<digit>X<digit>" must do a `keep 2' so
   // the last digit will be left to be
   // recognized by <digit>Y<digit> etc.

   // Alternatively we could have a separate
   // table for the state where the last atom
   // ended with a digit.

   "<digit>.<digit>" keep 2 goto number;
   "<digit>:<digit>" keep 2 goto number;
   "<digit>/<digit>" keep 2 goto number;
   "<digit>,<digit>" keep 2 goto number;
   "<digit>" accept;

   "'<digit>" keep 1 goto number;

   return;

end natural number lexeme table;


begin number lexeme table;

   // See note about `keep 2' in natural number
   // table above.

   "<digit>.<digit>" keep 2;
   "<digit>:<digit>" keep 2;
   "<digit>/<digit>" keep 2;
   "<digit>,<digit>" keep 2;
   "<digit>" accept;

   "'<digit>" keep 1;

   return;

end number lexeme table;


begin quoted string lexeme table;

    "<Q>" translate to "" return;
            // End quoted string.

    "<" match escaped char
        else match unrecognized escape seq
             error unrecognized escape seq
             translate to "<UUC>"
        else accept;

    "<LF>"
        keep 0 goto premature end of line;

    "<CR><LF>"
        keep 0 goto premature end of line;
    "<CR>"
        error misplaced control char
        translate to "<UUC>";

    "<control-char-except-CR-LF>"
        error misplaced control char
        translate to "<UUC>";

    "<others>" accept;

    goto premature end of file;

end quoted string lexeme table;


begin escaped char atom table;

    "<" "ACK" ">" translate to "<ACK>";
    "<" "BEL" ">" translate to "<BEL>";
    "<" "BS" ">" translate to "<BS>";
    "<" "CAN" ">" translate to "<CAN>";
    "<" "CR" ">" translate to "<CR>";
    "<" "DC1" ">" translate to "<DC1>";
    "<" "DC2" ">" translate to "<DC2>";
    "<" "DC3" ">" translate to "<DC3>";
    "<" "DC4" ">" translate to "<DC4>";
    "<" "DEL" ">" translate to "<DEL>";
    "<" "DLE" ">" translate to "<DLE>";
    "<" "EM" ">" translate to "<EM>";
    "<" "ENQ" ">" translate to "<ENQ>";
    "<" "EOT" ">" translate to "<EOT>";
    "<" "ESC" ">" translate to "<ESC>";
    "<" "ETB" ">" translate to "<ETB>";
    "<" "ETX" ">" translate to "<ETX>";
    "<" "FF" ">" translate to "<FF>";
    "<" "FS" ">" translate to "<FS>";
    "<" "GS" ">" translate to "<GS>";
    "<" "HT" ">" translate to "<HT>";
    "<" "LF" ">" translate to "<LF>";
    "<" "NAK" ">" translate to "<NAK>";
    "<" "NL" ">" translate to "<NL>";
    "<" "NUL" ">" translate to "<NUL>";
    "<" "Q" ">" translate to "<Q>";
    "<" "RS" ">" translate to "<RS>";
    "<" "SI" ">" translate to "<SI>";
    "<" "SO" ">" translate to "<SO>";
    "<" "SOH" ">" translate to "<SOH>";
    "<" "SP" ">" translate to "<SP>";
    "<" "STX" ">" translate to "<STX>";
    "<" "SUB" ">" translate to "<SUB>";
    "<" "SYN" ">" translate to "<SYN>";
    "<" "US" ">" translate to "<US>";
    "<" "VT" ">" translate to "<VT>";

    "<" "<digit>" match escaped hex char
            else fail;

    fail;

end escaped char atom table;


begin escaped hex char atom table;

    "<" "<digit>" ">" translate hex 1 1;
    "<" "<digit><hex-digit><repeat>" ">"
              translate hex 1 1;

    fail;

end escaped hex char atom table;


begin unrecognized escape seq atom table;

    "<" "<escape-char><repeat>" ">";

    fail;

end unrecognized escape seq atom table;


begin premature end of line master table;

    output premature end of line goto main;

end premature end of line master table;


begin premature end of file master table;

    output premature end of file goto main;

end premature end of file master table;


end alternate lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{C++ Lexical Program}
\label{C++-LEXICAL-PROGRAM}

\begin{indpar}\begin{verbatim}
// This file was automatically generated from
// ll_lexeme_c++.lexcc.

begin c++ lexical program;

// Before this lexical program is used the input
// should be preprocessed to
//
//    (1) Replace trigraph sequences.
//    (2) Eliminate carriage-returns next to a
//        newline (others become misplaced)
//    (3) Eliminate sequences of the form:
//        backslash newline
//
// After this lexical program is used the output
// should be post-processed to
//
//    (4) Perform C/C++ macro preprocessing
//        (macro expansion).
//    (5) Delete whitespace and newlines.
//    (6) Concatenate adjacent quoted strings
//        of the same character type (ordinary,
//        u, U, or L).

"<digit>" = "0-9";

"<non-zero-digit>" = "1-9";

"<oct-digit>" = "0-7";

"<hex-digit>" = "0-9" | "a-f" | "A-F";

"<ascii-letter>" = "a-z" | "A-Z";

"<letter>" = "<ascii-letter>"
           | "<non-ascii-letter>

// <non-ascii-letter> ::= UNICODE character in
// one of the code ranges designated in
// NON_ASCII_LETTERS in ll_lexeme_non_ascii_
// characters.h.

// <combining-char> ::= UNICODE character in
// one of the code ranges designated in
// NON_ASCII_COMBINING_CHARACTERS in ll_lexeme_
// non_ascii_characters.h.

// Universal characters are only permitted in
// identifiers, character literals, and string
// literals.  In identifiers they must represent
// non-ASCII-letters or non-ASCII combining
// characters, and the latter cannot be the
// initial character of an identifier.

"<identifier-non-digit>" = "_" | "<letter>";

"<identifier-char>" = "<identifier-non-digit>"
                    | "<digit>"
                    | "<combining_char>"

"<non-ascii-identifier-char>" =
          "<non-ascii-letter>"
        | "<combining_char>"

// Because `u', `U', or `L' can start a char-
// acter or string literal, we must define:
//
"<u_U_L>" = "u" | "U" | "L";
"<identifier-non-literal>" =
          "<identifier-non-digit>"
        & ~ "<u_U_L>";

"<whitespace-char>" =
    " " | "<HT>" | "<VT>" | "<FF>";
    // newline is treated separately


// The following can begin an operator or punc-
// tuation mark.
//
// / not followed by / or * and . not followed
// by <digit> are handled separately.
//
"<op-char>" = "#" | "<" | ">" | ":" | "%" |
            | "?" | "+" | "-" | "*" | "="
            | "^" | "&" | "|" | "~" | "!" | ","
            | "(" | ")" | "[" | "]" | "{" | "}"
            | ";";

"<sign>" = "+" | "-" ;

"<u_U>" = "u" | "U" ;

"<ascii-char>" = "<0>-<7F>"  [ASCII Character]


// C/C++ preprocessing is hereafter abbreviated
// as `pp'.

// Alternative operators that are not identi-
// fiers are translated.  E.g., <: becomes [ in
// the lexeme translation.

// C++ punctuation are treated as `operators'.

// Pp numbers are divided into 5 categories
// (note that a `suffix' is an identifier):
//
//      decimal integer
//          nothing but digits not beginning
//          with 0, with an optional suffix
//      octal integer
//          nothing but octal digits beginning
//          with 0, with an optional suffix
//      hexadecimal integer
//          nothing but hexadecimal digits
//          refaced by 0x or 0X, with an
//          optional suffix
//      float
//          legal floating point #'s, with an
//          optional suffix
//      pp number
//          all other pp numbers

// Because of pp control lines, lexical scanning
// is slightly context dependent.  There are
// several contexts, each corresponding to a
// different master table:
//
//    initial master
//        Used in line beginning situations to
//        recognize the # token that introduces
//        a pp control line.
//    pp beginning master
//        Used to scan the beginning of a pp
//        control line after the # has been
//        scanned but before anything else is
//        scanned.
//    pp include master
//        Used to scan the pp-header token in a
//        #include line after #include has been
//        scanned.
//    normal master
//        Used to scan a non pp control line or
//        the rest of a pp control line after
//        any #include header.
//
// The whitespace lexeme types are:
//
//    newline
//        a single <NL>
//    horizontal-space
//        sequence of "<whitespace-char>"s
//        (excludes <NL>'s)
//    comment
//        "/*" comment (including /* and */)
//        "//" comment (including // but not
//                      ending newline)
//
// This allows line feeds to be used to end pp
// control lines.


// Characters that are not part of legal lexemes
// and which are outside character literal ''s
// and and quoted string literal ""s are made
// into error lexemes that can separate other
// lexemes in exactly the same way that white-
// space can.
//
// Note that ## cannot be used to move charac-
// ters inside a character or string literal ''
// or "".  Also, we do NOT allow ## to append a
// combining character to another character.
// Therefore ## cannot be used to create a legal
// pp token by concatenating a legal pp token
// with a stray character that is not part of a
// legal pp token.  Thus we can treat all stay
// characters as errors, instead of making them
// into pp tokens.

// Characters that are part of erroneous atoms
// INSIDE character literal ''s or quoted string
// ""s are announced as part of an erroneous
// atom which is translated to "" and ignored as
// if it did not appear at all in the input.

begin initial master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur INSIDE
    // a pp directive line.
    //
    "/*" call "/*" comment;

    "#" output operator goto pp beginning;
    "##" output operator goto normal;

    "%:" translate to "#" output operator
         goto pp beginning;
    "%:%:" translate to "##" output operator
           goto normal;

    goto normal;

end initial master table;


begin pp beginning master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur inside
    // pp directive line.
    //
    "/*" call "/*" comment;

    // "include" identifier must be followed by
    // one of the following for a header to be
    // recognized:
    //
    //     <whitespace-char>
    //     /* comment
    //     <...> header
    //     "..." header
    //
    "include<whitespace-char>"
        keep 7 output identifier
        goto pp include;
    "include/"
        keep 7 output identifier
        goto pp include;
    "include<"
        keep 7 output identifier
        goto pp include;
    "include<Q>"
        keep 7 output identifier
        goto pp include;

    goto normal;

end pp beginning master table;

begin pp include master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur inside
    // pp directive line.
    //
    "/*" call "/*" comment;

    "<" translate to ""
        goto bracketed header name;

    "<Q>" translate to ""
        goto quoted header name;

    goto normal;

end pp include master table;


begin premature newline master table;

    output premature newline goto normal;

end premature newline master table;


begin premature end of file master table;

    output premature end of file goto initial;

end premature end of file master table;

begin whitespace lexeme table;

    "<whitespace-char>" accept;

    return;

end whitespace lexeme table;


begin "/*" comment lexeme table;

    "*/" return;
    "*" accept;

    "<others>" accept;

    translate_to "*/"
    goto premature end of file;

end "/*" comment lexeme table;


begin "//" comment lexeme table;

    "<NL>" keep 0 return;

    "<others>" accept;

    goto premature end of file;

end "//" comment lexeme table;


begin bracketed header name lexeme table;

    ">" translate to "" goto normal;

    "<NL>"
        keep 0 goto premature newline;

    "<others>" accept;

    goto premature end of file;

end bracketed header name lexeme table;


// Quoted header names are not the same as
// quoted strings, and cannot have escape
// sequences.
//
begin quoted header name lexeme table;

    "<Q>" translate to "" goto normal;

    "<NL>"
        keep 0 goto premature newline;

    "<others>" accept;

    goto premature end of file;

end quoted header name lexeme table;


begin normal master table;

    "<whitespace-char>" call whitespace;

    "/*" call "/*" comment;
    "//" call "//" comment;
    "/" match operator output operator
        // match should always succeed

    "<op-char>"
        match operator output operator
        // match should always succeed

    "<identifier-non-literal>"
        call identifier;
        // Also see "u/U/L..." etc. below.

    "u'" translate to ""
         output u char literal
         call char literal;
    "u<Q>" translate to ""
           output u string literal
           call string literal;
    "u"  call identifier;

    "U'" translate to ""
         output U char literal
         call char literal;
    "U<Q>" translate to ""
           output U string literal
           call string literal;
    "U"  call identifier;

    "L'" translate to ""
         output L char literal
         call char literal;
    "L<Q>" translate to ""
           output L string literal
           call string literal;
    "L"  call identifier;

    "\<u_U>" match universal char
             require <non-ascii-letter>
             call identifier
        else match universal char
             require "<ascii-char>"
             output ascii universal char
        else match universal char
             output misplaced universal char
        else match short universal char
             output universal char
             // Match should always succeed.
    "\" output misplaced char

    "<non-zero-digit>" call decimal integer;

    "0x" call hexadecimal integer;
    "0X" call hexadecimal integer;
    "0" call octal integer;

    ".<digit>" call fraction;
    "." match operator output operator
        // match should always succeed

    "'" translate to ""
        output char literal
        call char literal;

    "<Q>" translate to ""
          output string literal
          call string literal;

    "<NL>" output newline goto initial;

    "<others>" output misplaced char;

    output end of file;

end normal master table;


begin operator atom table;

    "("; ")"; "["; "]"; "{"; "}"; ";"; ","; "?";
    "~";

    "#";
    "##";

    "<:" translate to "[";
    "<%"; translate to "{";
    "<<="; "<<"; "<";

    ">>="; ">>"; ">";

    ":>" translate to "]";
    "::"; ":";

    "%>" translate to "}";
    "%:%:" translate to "##";
    "%:" translate to "#";
    "%="; "%";

    "..."; ".*"; ".";

    "++"; "+="; "+";

    "->*"; "->"; "--"; "-="; "-";

    "*="; "*";
    "/="; "/";
    "^="; "^";
    "!="; "!";
    "=="; "=";

    "&&"; "&="; "&";

    "||"; "|="; "|";

    fail;

end operator atom table;


begin identifier lexeme table;

    "<identifier-non-digit>" accept;
    "<digit>" accept;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
        else keep 0 return

    return;

end identifier lexeme table;

"<e_E> = "e" | "E";
"<identifier-non-digit-except-eE>" =
    "<identifier-non-digit>" & ~ "<e_E>";


begin decimal integer lexeme table;

    "<digit>" accept;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end decimal integer lexeme table;


begin octal integer lexeme table;

    "<oct-digit>" accept;

    "8" goto float integer;
    "9" goto float integer;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end octal integer lexeme table;

"<identifier-non-hex-digit>" =
    "<identifier-non-digit>" & ~ "<hex-digit>";


begin hexadecimal integer lexeme table;

    "<hex-digit>" accept;

    "<identifier-non-hex-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end hexadecimal integer lexeme table;


// integer began with 0 and then included a
// non-octal digit.
//
begin float integer lexeme table;

    "<digit>" accept;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto pp number;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto pp_number
        else keep 0 goto pp number

    goto pp number;

end float integer lexeme table;


// Come here to process suffix at end of integer
// or float lexeme.  Similar to identifier but
// changes lexeme type to pp number when certain
// character sequences are encountered.
//
begin suffix sublexeme table;

    "<identifier-non-digit-except-eE>" accept;
    "<digit>" accept;

    "<e_E><sign>" goto pp number;
    "<e_E>" accept;

    "." goto pp number;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
             else keep 0 return;

    return;

end suffix sublexeme table;

begin pp number lexeme table;

    "<identifier-non-digit-except-eE>" accept;
    "<digit>" accept;

    "<e_E><sign>" accept;
    "<e_E>" accept;

    "." accept;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
             else keep 0 return;

    return;

end pp number lexeme table;


begin fraction lexeme table;

    "<digit>" accept;

    "." goto pp number;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<identifier-non-digit>" goto suffix;

    "\<u_U>" match universal char
             require "<non-ascii-letter>"
             goto suffix
             else keep 0 return;

    return;

end fraction lexeme table;


begin exponent lexeme table;

    "<digit>" accept;

    "." goto pp number;

    "<e_E><sign>" goto pp number;
    "<identifier-non-digit>" goto suffix;

    "\<u_U>" match universal char
             require "<non-ascii-letter>"
             goto suffix
             else keep 0 return;

    return;

end exponent lexeme table;


begin char literal sublexeme table;

    "'" translate to "" return;

    "<NL>" keep 0 goto premature newline

    "\" match escaped char
        // match should always succeed

    "<others>" accept

    goto premature end of file

end char literal sublexeme table;


begin string literal sublexeme table;

    "<Q>" translate to "" return;

    "<NL>" keep 0 goto premature newline

    "\" match escaped char
        // match should always succeed

    "<others>" accept

    goto premature end of file

end string literal sublexeme table;


// This atom table is used when the next atom
// begins with \ and is in a character or string
// literal.  This atom table always succeeds,
// but may produce an erroneous atom with ""
// translation.
//
// We allow only a maximum of 8 hexadecimal
// digits after \x; 9 digits is an error.  The
// C++ standard permits any number of hexa-
// decimal digits.
//
begin escaped char atom table;

    "\n" translate to "<NL>";

    "\t" translate to "<HT>";

    "\v" translate to "<VT>";

    "\b" translate to "<BS>";

    "\r" translate to "<CR>";

    "\f" translate to "<FF>";

    "\a" translate to "<BEL>";

    "\\" translate to "\";

    "\?" translate to "?";

    "\<Q>" translate to "<Q>";

    "\'" translate to "'";

    "\<oct-digit><oct-digit><oct-digit>"
        translate oct 1 0;
    "\<oct-digit><oct-digit>"
        translate oct 1 0;
    "\<oct-digit>"
        translate oct 1 0;

    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        error too long hex escape
        translate to "";
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit>"
        translate hex 2 0;
    "\x" error ill formed escape
        translate to "";

    "\<u_U>" match universal char
        else match short universal char
             error short universal char
             translate to "";
             // This should always succeed

"\<NL>" keep 1
        error ill formed escape
        translate to "";

"\<others>" error ill formed escape
           translate to "";

"\" error ill formed escape
    translate to "";
    // In case \ followed by end of file

// This table should always succeed.

end escaped char atom table;


// This atom table is called when the next
// atom begins with \U or \u.  If the atom
// has the correct number of hexadecimal
// digits after the \U or \u, it is recognized
// and translated.
//
begin universal char atom table;

    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;

    "\u<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;

    fail;

end universal char atom table;


// This atom table is called when the next
// atom begins with \U or \u but there are too
// few hexadecimal digits following.  An atom
// is always recognized but is NOT translated.
//
begin short universal char atom table;

    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>";
    "\U<hex-digit>";
    "\U";

    "\u<hex-digit><hex-digit>"
      "<hex-digit>";
    "\u<hex-digit><hex-digit>";
    "\u<hex-digit>";
    "\u";

    // The above should always succeed.

end short universal char atom table;


end c++ lexical program;

\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
