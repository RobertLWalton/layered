% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttnbakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\ttitemref}[1]{{\tt \ref{#1} ({p\pageref{#1}})}}
\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

April 24, 2010
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A machine independent reduced instruction set architecture
	  programming language.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& Similar to the C programming language but more flexible.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& Implements standardized lists, symbols, arrays, etc. to extend
	  the M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `{\tt hello}', `{\tt +}', `{\tt ;}',
`{\tt 9.200}' are four lexemes.

The lexical scanner is written in the H-Language and can be
replaced.  This section describes the standard scanner which
is driven by the atom tables and is capable scanning
lexemes of common languages such as C and C++.

The standard scanner attempts to be both machine and human
efficient.  It attempts to be machine efficient by being
deterministic\footnote{Unlike regular expression scanners}
and attempts to be human efficient by supporting algorithms
that people can readily understand and hopefully quickly
learn to mimic.\footnote{A possibly non-verifiable goal.}

The standard scanner identifies lexical atoms in the text.
A \key{lexical atom} is a single character (e.g., the letters
in an identifier or symbol) or a short string of characters
(e.g., the characters \verb|\n| in a quoted string).
Lexical atoms are read left to right and
grouped by the scanner into \skey{lexeme}s,
which are the output of the scanner.

The scanner has a state consisting of a current point 
in the input UNICODE character stream and a current atom table identifier.  An
\key{atom table} is a set of atom patterns
that match lexical atoms, and for each pattern an
instruction that determines what to do when the pattern is matched.
There is also an instruction associated with the atom table that
determines what to do when no table pattern matches the next characters
in the input stream.

An \key{atom pattern}\index{pattern!lexical atom} is a fixed
length sequence of character patterns, and matches any sequence of
UNICODE characters of the same length as the atom pattern
if each character of the sequence matches the corresponding
character pattern.  A \key{character pattern} is simply a
specification of a set of characters, e.g., letters or digits.
Thus one can construct an atom pattern that will recognize
a single letters, or one that will recognize the sequence of
characters \verb|\u<hexdigit><hexdigit><hexdigit><hexdigit>|.

The atom patterns of a single atom table may not conflict:
no character string can be recognized by two atom patterns of the
same atom table.

The scanner operates by identifying the
longest sequence of characters beginning at the current input character
stream point that matches an atom pattern of the current atom.
This sequence of characters becomes
the next atom, and an instruction associated with its matching
atom pattern is then executed.  If no atom pattern can be matched,
the instruction associated with the atom table is executed instead.

An atom pattern or atom table
instruction can optionally reduce the length of a matched atom
and optionally change the current atom table.

Atom tables have modes that are either lexeme kinds or
are the special mode `\ttmkey{master}{mode}'.  When the
current lexical atom table is changed to a new table of
`\verb|master|' mode, any non-zero length lexeme accumulated
so far is output as a lexeme whose \mkey{kind}{lexeme}\label{KIND-OUTPUT}
equals
the mode of the previous current atom table.  Thus if an atom table of
mode `\verb|whitespace|' cannot recognized any atom and
the instruction associated with it that is executed in this
case changes the current atom table to one of `\verb|master|'
mode, any non-zero length lexeme accumulated so far will
be output as a lexeme of kind `\verb|whitespace|'.

The lexeme output consists of a sequence of characters in the
input character stream.  In addition there is a translation
of this lexeme.  Each atom is translated by the
instruction that is executed when the atom is recognized.
By default atoms are not changed by translation but merely copied to the end
of current lexeme's translation.  But any set of characters can be
included in the instruction and
copied instead.  For example, for the lexeme \verb|"a line\n"| the
\verb|"| atoms can be translated to zero length strings and the
\verb|\n| atom can be translated to a single line feed character.
If the other characters are copied as is to the translation, then
the translation will contain 5 letters, one single space character,
and one line feed character.

A \key{lexical program} is a set of character pattern definitions,
atom pattern definitions, and atom tables, with a designated atom
table to serve as initial state.  A lexical program can include
another lexical program.

\subsection{Lexical Programs}

The syntax of a lexical program is given on
\pagref{LEXEME-PROGRAM-SYNTAX-1} and
\pagref{LEXEME-PROGRAM-SYNTAX-2}.

\begin{figure*}[!p]
\begin{tabular}{p{2.2in}rl}
\emkey{name}
    & ::= & {\em word}
            \{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}$^\star$
\end{tabular}

\begin{tabular}{p{2.2in}rl}
\emkey{lexical-program} & ::= &
	{\tt begin} {\em program-name} {\tt lexical program;}\\
	& &  ~~~~{\em lexical-program-unit}$^\star$ \\
	& & {\tt end} {\em program-name} {\tt lexical program};
\\[1ex]
\emkey{program-name} & ::= & {\em name}
\\[1ex]
\emkey{lexical-program-unit}
	& ::= & {\em cpat-definition} \\
	& $|$ & {\em atom-table-definition} \\
	& $|$ & {\em program-inclusion}
\\[1ex]
\emkey{program-inclusion} & ::= & {\tt include} {\em program-name}
				  {\em remove-clause}$^\star$ {\tt ;}
\\[1ex]
\emkey{remove-clause} & ::= & {\tt remove} {\em atom-table-name} \\
                      & $|$ & {\tt remove} {\tt "}{\em cpat-name}{\tt "}
\\[1ex]
\multicolumn{3}{l}{~~~~~~~~`{\em cpat}\,' abbreviates `{\em character-pattern}\,'}
\\[1ex]
\emkey{cpat-definition} & ::= &
	{\tt "}{\em cpat-name}{\tt "} {\tt =}
		{\em cpat-expression} {\tt ;}
\\[1ex]
\emkey{cpat-name} & ::= &
	{\tt <}{\em letter}$^+$\{{\tt -}{\em letter}$^+$\}$^\star${\tt >}
\\[1ex]
\emkey{cpat-expression} & ::= &
	{\em cpat-term}
	\{ {\tt |} {\em cpat-term} \}$^\star$ \\
       & $|$ &
	{\em cpat-term}
	\{ {\tt \&} {\em cpat-term} \}$^\star$
\\[1ex]
\emkey{cpat-term} & ::= & {\em cpat-factor} $|$ \TILDE {\em cpat-factor}
\\[1ex]
\emkey{cpat-factor} & ::= & {\tt "}{\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em quotable-character}{\tt -}%
		                   {\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em cpat-name}{\tt "} \\
		    & $|$ & {\tt (} {\em cpat-expression}
		                {\tt )}
\\[1ex]
\emkey{quotable-character} & ::= & 
	any quotable UNICODE character representative
\\[1ex]
\emkey{atom-table-definition} & ::= &
	{\tt begin} {\em atom-table-name}
		    {\tt atom table} {\tt ;} \\
	& &  ~~~~{\em mode-option} \\
	& &  ~~~~{\em atom-table-entry}$^\star$ \\
	& &  ~~~~{\em goto-instruction-option} \\
	& & {\tt end} {\em atom-table-name} {\tt atom table;}
\\[1ex]
\emkey{mode-option} & ::= & {\em empty} $|$ {\tt mode} {\em mode} {\tt ;}
                                        $|$ {\tt kind} {\em kind} {\tt ;}
\\[1ex]
\emkey{mode} & ::= &  {\tt master} $|$ {\em kind}
\\[1ex]
\emkey{goto-instruction-option}
	& ::= &  {\em empty} $|$ {\tt goto} {\em atom-table-name}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-1}
\end{figure*}

\begin{figure*}[!t]
\begin{tabular}{p{2.2in}rl}
\emkey{atom-table-entry}
	& ::= & {\em atom-pattern} {\em instruction-group} {\tt ;}
\\[1ex]
\emkey{instruction-group}
	& ::= & {\em instruction}
	        \{ {\tt else} {\em instruction} \}$^\star$

\\[1ex]
\emkey{instruction} & ::= & {\em instruction-component}$^\star$
\\[1ex]
\emkey{atom-pattern} & ::= &
	{\tt "}\{{\em quotable-character}$|${\em cpat-name}\}$^\star${\tt "}
\\[1ex]
\emkey{instruction-component}
	& ::= & {\tt accept} \\
	& $|$ & {\tt keep} {\em natural-number} \\
	& $|$ & {\em translation-string} \\
	& $|$ & {\tt translate hex} \begin{tabular}[t]{l}
			{\em natural-number} {\em natural-number} \\
		        {\em cpat-option}
			\end{tabular} \\
	& $|$ & {\tt translate oct} \begin{tabular}[t]{l}
			{\em natural-number} {\em natural-number} \\
		        {\em cpat-option}
			\end{tabular} \\
	& $|$ & {\tt error} {\em kind} \\
	& $|$ & {\tt goto} {\em atom-table-name} \\
	& $|$ & {\tt singleton} {\em kind}
\\[1ex]
\emkey{translation-string} & ::= & {\em quoted-string}
\\[1ex]
\emkey{cpat-option} & ::= & {\em empty} $|$ {\tt "}{\em cpat-name}{\tt "}
\\[1ex]
\emkey{kind} & ::= & {\em name} \begin{tabular}[t]{@{}r@{~}l@{}}
                                     except & {\tt master} \\
				         or & {\tt end of file} \\
					 or & {\tt scan error} \\[1ex]
				    \end{tabular}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-2}
\end{figure*}

A \emkey{lexical-program} consists of a sequence of
{\em character-\EOL pattern-\EOL defi\-ni\-tions},
{\em atom-\EOL table-\EOL defi\-ni\-tions},
and {\em program-inclusions}.  These define character pattern sets
and atom tables, and include in the lexical program definitions from
other previously defined lexical programs.

A \emkey{program-inclusion} names a previously defined lexical program
whose definitions are to be included in the current lexical program
at the point of the {\em program-inclusion}.  Identical definitions
may be repeated without error,
as can happen when one program includes two each of
which include the same third program.
A {\em program-inclusion} can have
\emsmkey{remove-clause}s{in {\em program-inclusion}}
each of which removes a named definition from the set of included
definitions.  This is the only way to resolve conflicts between
definitions.

A \emkey{character-pattern-definition} (abbreviated as
\emkey{cpat-definition}) assigns a set of characters to a
{\em character-pattern-name}.  The latter is just a string of
letters and hyphens (\verb|-|) surrounded by angle brackets (\verb|< >|)
with hyphens occuring only between letters.  Examples:
\verb|<digit>| and \verb|<line-break>|.

The character set is denoted by a \emkey{character-pattern-expression}.
The simplest character pattern
expression is just a single {\em quotable-character} in quotes, which denotes
the character set containing only the quoted character.  Examples:
\verb|"0"| and \verb|"+"|.  The next simplest is two {\em quotable-characters}
separated by a hyphen (\verb|-|) denoting the character set consisting
of all characters in the range from the first to the second of the two
characters.  Examples: \verb|"0-9"| and \verb|"A-Z"|.  The characters
are ordered according to their 32 bit unsigned UNICODE value, and the
second of the two characters must not be smaller than the first.

A {\em quotable-character} is a representative of a single UNICODE
character that can be used inside quotes (\verb|"|).
Printable ASCII characters represent themselves.  Other characters
are represented by sequences started with backslash (\verb|\|).
For example, a line feed can be represented by any of the
following: \verb|\n|, \verb|\012|, \verb|\x0a|,
\verb|\u000a|, or \verb|\U0000000a|.

A quoted {\em character-pattern-name} denotes the character set associated
with that name by a previous {\em character-pattern-definition}.

The \verb/|/, \verb|&|, and \verb|~| operators and can be used to take
the union, intersection, and complements of character sets.  The complement
is relative to the universe of all 32 bit unsigned integer UNICODE
character codes.  Thus \verb|~ "b-y"| denotes the same character set as
\verb/"\x00-a" | "z-\Uffffffff"/.

Parentheses may be used in {\em character-pattern-expressions} as is
normal in algebraic expressions.
Note that the \verb/|/ and \verb|&| operators cannot be used together
in the same expression without intervening parentheses as neither
takes precedence over the other.  This is done to prevent ambiguity.

An {\em atom-table-definition} specifies an {\em atom-table-name},
a {\em mode} for the table, a set of {\em atom-table-entries}
each containing an {\em atom-pattern} and an {\em instruction},
and an optional default {\tt goto} instruction for use when
no atom is recognized by any of the table entries.

The {\em mode} of an atom table can be either a {\em kind} or can be
the special `\ttmkey{master}{atom table mode}' mode.  If it is a
{\em kind} then it is used as the {\em kind} of any lexeme recognized
by the table (not all tables recognize lexemes).  See
\pagref{KIND-OUTPUT} for a description of how modes and kinds are used

The {\em mode} of an atom table is the same as the {\em atom-table-name}
unless a non-empty {\em mode-option} is given at the beginning of the
{\em atom-table-definition}.

Each \emkey{atom-table-entry} contains an {\em atom-pattern} and
an {\em instruction-group}.  The \emkey{atom-pattern} is matched against
the remaining input characters.  The pattern consists of a sequence
of {\em quotable-characters}, each of which match only themselves,
and {\em character-pattern-names}, each of which match any character
in the named set of characters.  Thus
\begin{center}
\verb|"\\x<hex-digit><hex-digit>"|
\end{center}
matches 4-character atoms consisting of a \verb|\| followed by an
\verb|x| followed by two characters each in the character set
named by \verb|<hex-digit>|.  Note that each {\em atom-pattern}
only matches atoms of a particular length.

An \emmkey{instruction}{in atom-table-entry} in an {\em atom-table-entry}
specifies actions to be taken when an atom is recognized by the
{\em atom-pattern} of the entry.  The {\em instruction} consists of
a set of {\em instruction-components} each of which controls part of the
atom processing.  If there are no components, the default actions are
performed, which consist of just skipping over the atom in the input and
copying the atom to the translation buffer.

The \ttmkey{accept}{in lexical program} {\em instruction-component}
accepts the
atom without translation or length change, skips over the atom in the
input, and copies the atom characters to the translation buffer.
It is incompatible with the {\tt keep} and translation instruction
components.

The `\ttmkey{keep}{in lexical program} $n$'
{\em instruction-component} causes the atom length
to be shortened to $n$.  For example, the atom table entry
\begin{center}
\verb|",<digit>" keep 1;|
\end{center}
will recognize a 1-character atom consisting of just a comma as long as
the comma is followed by character in the \verb|<digit>| character pattern
character set.  Atoms may not be lengthened by {\tt keep}.

There are three possible translation {\em instruction-components}, at most
one of which may be used.  These affect how the atom is placed into
the translation buffer, and are applied to the atom \underline{after}
any {\tt keep} is applied.

A \emmkey{translation-string}{in lexical program}
{\em instruction-component}
is just a {\em quoted-string} of characters
that is copied into the translation buffer instead of the atom.
A {\em translation-string} may be empty, as in the atom table entry
\begin{center}
\verb|"\"" "" goto master;|
\end{center}
which can be used to recognize the last \verb|"| of a quoted string, avoid
copying anything into the translation buffer, and then switch to the
`{\tt master}' atom table.

The `\ttmkey{translate hex}{in lexical program} $m$ $n$'
{\em instruction-component} ignores the
first $m$ and last $n$ characters of the atom and viewing the rest as
hexadecimal digits, converts these into an 32 bit unsigned integer
UNICODE character code, which is placed into the translation buffer
instead of the atom.  An example is the the atom table entry
\begin{center}
\verb|"\\x<hex-digit><hex-digit>" translate hex 2 0;|
\end{center}
which might be used to accept a character representative in a quoted string
and copies the appropriate hexadecimally related character code into
the translation buffer.

The `\ttmkey{translate oct}{in lexical program} $m$ $n$'
{\em instruction-component} is identical but
views the rest of the characters as octal and not hexadecimal.
An example use would be the atom table entry
\begin{center}
\verb|"\\<oct-digit><oct-digit><oct-digit>" translate hex 1 0;|
\end{center}

The {\tt translate hex} and {\tt translate oct} components may end with
a {\em character-pattern} that tests the 32 bit unsigned character code
produced by the translation.  Such a test should only appear in an
{\em instruction} which is followed by an `{\tt else}' in an
\emmkey{instruction-group}{in lexical program}.
If the 32 bit unsigned character code is in
the character set defined by the {\em character-pattern}, the {\em instruction}
containing the {\em character-pattern} is executed and the rest of the
{\em instruction-group}, the part after the next `{\tt else}', is ignored.
But if the character code is not in the character set the instruction
containing the {\em character-pattern} is turned into a no-operation and
the first {\em instruction} after the next `{\tt else}' is executed in
its place.

An example use would be the atom table entry
\begin{center}
\verb|"\\u<hex-digit><hex-digit><hex-digit><hex-digit>" translate hex 2 0|
\verb|    "<letter>" else "" error bad character in identifier;|
\end{center}
which might be used to process an atom of the form \verb|\uXXXX| in
an identifier, accepting the atom as a legitimate representation of a
character if that character is a letter, and otherwise designating
the atom as an error and not putting anything in the translation buffer
(see below for the definition of the `{\tt error}' instruction component;
here \verb|""| is a {\em translation-string} applied if the character
is not a letter).

A `\ttmkey{error}{in lexical program} {\em kind}\,' {\em instruction-component}
outputs the current atom as an erroneous atom of the given {\em kind}.
What is put in the translation buffer is governed
independently by translation instruction components.
An erroneous atom is different from an erroneous lexeme.
An erroneous atom can occur in the middle of a lexeme and is usually announced
and otherwise ignored (it has \verb|""| as its {\em translation-string}).
It is not a lexeme.
An erroneous lexeme is simply a lexeme whose {\em kind}
indicates to the user of the lexical scanner that the lexeme is ill-formed.
As such it an erroneous lexeme is
handled by the lexical scanner just as any other lexeme would be.

A `\ttmkey{goto}{in lexical program} {\em atom-table-name}\,'
{\em instruction-component} switches the current atom table after
the current atom is processed.  If the table switches from a table
of non-{\tt master} mode to one of {\tt master} mode the current
lexeme, if it has non-zero length,
is output with the {\em kind} of the non-{\tt master} mode
table: see \pagref{KIND-OUTPUT}.

A `\ttmkey{shortcut}{in lexical program} {\em kind}\,'
{\em instruction-component} emits the current atom as a lexeme
of the given {\em kind}.  It can only be used if the current atom
table has `{\tt master}' mode.  It does what `{\tt goto} {\em kind}\,'
would do were there an atom table defined as
\begin{indpar}
\verb|begin |{\em kind}\verb| atom table;| \\
\verb|      goto |{\em current-atom-table-name}{\tt ;} \\
\verb|end |{\em kind}\verb| atom table;|
\end{indpar}
The {\tt shortcut} {\em instruction-component} is useful for
one atom lexemes that can be recognized in a master mode atom table.

\section{Parsing}

\newpage

\appendix

\section{Standard Lexical Program}
\label{STANDARD-LEXICAL-PROGRAM}

\begin{indpar}
\begin{verbatim}
begin standard lexical program;

"<ascii-letter>" = "a-z" | "A-Z";
"<digit>" = "0-9";
"<oct-digit>" = "0-7";
"<hex-digit>" = "0-9" | "a-f" | "A-F";

"<non-digit>" = ~ "<digit>";

// The following list of language specific letters is taken
// from Annex E of the Working Paper for Draft Proposed
// International Standard for Information Systems—Programming
// Language C++, 1996.

"<latin-letter>" = "\u00c0-\n00d6" | "\u00d8-\u00f6"
                 | "\u00f8-\u01f5" | "\u01fa-\u0217"
                 | "\u0250-\u02a8" | "\u1ea0-\u1ef9";

. . . . . letter character pattern definitions omitted . . . . .

"<CJK-letter>" = "\uf900-\ufa2d" | . . .  // Details omitted

// Context sensitive character classifications, e.g.,
// classifying ' as a word character if it is followed by
// a letter, cannot be included in character pattern
// definitions, but are noted in comments.  They are
// accounted for by separate atom table entries below.

"<letter>" = "<ascii-letter>" | "<latin-letter>"
           | . . . | "<CJK-letter>";   // Details omitted

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@" | "#" | "$" | "%"
              | "^" | "&" | "=" | "|" | "<" | ">" | "_" | "!"
              | "?" | ":";
              //
              // Also \ not followed by u or U,
              //      . not followed by a digit
              //      / not surrounded by digits

"<separator-char>" = "(" | ")" | "[" | "]" | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter

"<whitespace-char>" = " " | "\n" | "\v" | "\f" | "\t" | "\r";

"<non-line-break-char>" = ~ "\n" & ~ "\v" & ~ "\f";

"<quotable-char>" = "\u0020-\u007e" & ~ "\"" & ~ "\\";

"<error-in-quote-char>" = ~ "<quotable-char>" & ~ "\"";

begin master atom table;

   // We assume that the preceding text is not a digit
   // or the current input is not / or , followed by a digit.

   "//" goto comment;

   "<whitespace-char>" goto whitespace;

   "<word-char>" goto word;
   "'<letter>" goto word;

   "<mark-char>" goto mark;
   ".<non-digit>" keep 1 goto mark;
   "/" goto mark;

   "<digit>" keep 0 goto number;
   ".<digit>" keep 1 goto number;

   "<separator-char>" singleton separator;
   "," singleton separator;
   "'<non-letter>" keep 1 singleton separator;

   "\"" "" goto quoted string;

   "<other>" singleton error;

end master atom table;

// The below tables are enterred from the master table
// with the first one or two characters scanned.

// Comments are treated as whitespace lexemes or parts
// thereof.
//
begin comment atom table;

   "<non-line-break-char>" goto comment;
   goto whitespace;
       // On line break or end-of-file goto whitespace.

end comment atom table;


begin whitespace atom table;

   "<whitespace-char>" goto whitespace;
   "//" goto comment;
   goto master;

end whitespace atom table;


begin word atom table;

   "<word-char>" goto word;
   "'<letter>" goto word;
   goto master;

end word atom table;


begin mark atom table;

   "<mark-char>" goto mark;
   ".<non-digit>" keep 1 goto mark;
   "/" goto mark;
   goto master;

end mark atom table;


begin number atom table;

   // In order to recognize , and / surrounded by digits
   // as number atoms, entries to this table upon
   // recognizing "X<digit>" must do a `keep 1' so the
   // digit will be left to be recognized by
   // <digit>/<digit> or <digit>,<digit>.

   // Alternatively we could have a separate table
   // for the state where the last atom ended with
   // a digit.

   "<digit>" goto number;
   ".<digit>" keep 1 goto number;
   "<digit>/<digit>" keep 2 goto number;
   "<digit>,<digit>" keep 2 goto number;
   goto master;

end number atom table;


begin quoted string atom table;

    "\"" "" goto master;        // End quoted string.

    "\\\"" "\"" goto quoted string;
    "\\\n" "\n" goto quoted string;
    "\\\r" "\r" goto quoted string;
    "\\\t" "\t" goto quoted string;
    "\\\b" "\b" goto quoted string;
    "\\\f" "\f" goto quoted string;
    "\\\v" "\v" goto quoted string;
    "\\\\" "\\" goto quoted string;
    "\\~"  " "  goto quoted string;
    "\\x<hex-digit><hex-digit>" translate hex 2 0
                                goto quoted string;
    "\\<oct-digit><oct-digit><oct-digit>" translate oct 1 0
                                goto quoted string;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
                                translate hex 2 0
                                goto quoted string;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
                                translate hex 2 0
                                goto quoted string;
    "<quotable-character>" goto quoted string;
    "<other>" "" erroneous atom goto quoted string;
    goto end of file in quoted string;

end quoted string atom table;



begin end of file in quoted string atom table;
    kind error;
    goto master;
end end of file in quoted string atom table;

end standard lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{C++ Lexical Program}
\label{C++-LEXICAL-PROGRAM}

\begin{indpar}\begin{verbatim}
begin c++ lexical program;

"<ascii-letter>" = "a-z" | "A-Z";
"<digit>" = "0-9";
"<oct-digit>" = "0-7";
"<hex-digit>" = "0-9" | "a-f" | "A-F";

"<non-digit>" = ~ "<digit>";
"<non-zero-digit>" = "1-9";

// The following list of language specific letters is taken
// from Annex E of the Working Paper for Draft Proposed
// International Standard for Information Systems—Programming
// Language C++, 1996.

"<latin-letter>" = "\u00c0-\n00d6" | "\u00d8-\u00f6"
                 | "\u00f8-\u01f5" | "\u01fa-\u0217"
                 | "\u0250-\u02a8" | "\u1ea0-\u1ef9";

. . . . . letter character pattern definitions omitted . . . . .

"<CJK-letter>" = "\uf900-\ufa2d" | . . .  // Details omitted

"<letter>" = "<ascii-letter>" | "<latin-letter>"
           | . . . | "<CJK-letter>";   // Details omitted

"<sign>" ::= "+" | "-" ;

begin master atom table;
    "0" goto octal literal;
    "<non-zero-digit>" goto decimal literal;
    "0x" goto hexadecimal literal;
    "0X" goto hexadecimal literal;
    "'" "" goto character literal;
    "L'" "" goto wide character literal;
    "\"" "" goto string literal;
    "L\"" "" goto wide string literal;
    "<letter>" goto identifier;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
	    translate hex 2 0 goto identifier
	    "<letter>" else shortcut non-letter UNICODE error;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
	    translate hex 2 0 goto identifier
	    "<letter>" else shortcut non-letter UNICODE error;
    "{" shortcut punctuation;
    "}" shortcut punctuation;
end master atom table;

begin identifier atom table;
    "<letter>" accept;
    "<digit>" accept;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
	    translate hex 2 0
	    "<letter>" else keep 0 goto master;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
	    translate hex 2 0
	    "<letter>" else keep 0 goto master;
end identifier atom table;

end c++ lexical program;
\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
