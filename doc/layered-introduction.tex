% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttnbakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\ttitemref}[1]{{\tt \ref{#1} ({p\pageref{#1}})}}
\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

July 10, 2007
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A machine independent reduced instruction set architecture
	  programming language.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& Similar to the C programming language but more flexible.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& Implements standardized lists, symbols, arrays, etc. to extend
	  the M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `{\tt hello}', `{\tt +}', `{\tt ;}',
`{\tt 9.200}' are four lexemes.

The lexical scanner is written in the H-Language and can be
replaced.  This section describes the standard scanner which
is C/C++ compatible and is driven by the following lexical atom tables:

\begin{center}
\begin{tabular}{l}
lexeme atom table \\
identifier atom tables \\
number atom tables \\
string atom tables \\
comment atom tables \\
whitespace atom tables \\
\end{tabular}
\end{center}

The (standard) scanner reads left to right, and at each point
identifies the next lexical atom in the text,
where a \key{lexical atom} is a string
of characters explicitly listed in one of the \skey{lexical atom table}s.
If there are several possibilities, the longest is chosen.
To identify atoms, the scanner looks in one of the atom tables;
which table depends on the state of the scanner.  The table entry
for an atom contains an atom type, which determines subsequent
actions of the scanner.  The table entry can also contain a
translation, which is the string of characters the atom represents,
so that, for example, the translation of the atom `{\tt \BACKSLASH t}'
can be `the horizontal tab character'.

Each lexical atom table has a name consisting of sequence of
identifiers and quoted strings ending with an identifier.  The table
name must be `{\tt lexeme}' or must be a \key{lexeme type}, and in the
latter case the table name is also the type name of any lexemes recognized
using the table.

More specifically, lexeme type names
are sequences of identifiers and quoted strings ending with
a \key{lexeme class} identifier, which is one of:

\begin{center}
\begin{tabular}{l}
\tt separator \\
\tt operator \\
\tt identifier \\
\tt string \\
\tt comment \\
\tt whitespace \\
\tt error \\
\end{tabular}
\end{center}

There are no actual lexemes of classes {\tt comment}, {\tt whitespace},
and {\tt error}; strings that might be lexemes of these types are
discarded.

For example, the standard lexical atom table for an identifier 
is named `{\tt identifier}', and the
lexical atom table for a `{\tt /* */}' style C comment is named
`{\tt "/*" comment}'.

The general form of an atom table entry is:

\begin{center}
\begin{tabular}{rcl}
\emkey{lexical-atom-table-entry}
	& ::= & {\em lexical-atom} {\em lexical-atom-type} \\
	& & ~~~~[{\em lexical-atom-translation}] {\tt ;} \\
\emkey{lexical-atom} & ::= & {\em quoted-string} \\
\emkey{lexical-atom-type}
	& ::= & {\em lexical-atom-type-qualifier}$^\star$ {\em lexical-class} \\
\emkey{lexical-atom-type-qualifier}
	& ::= & {\em quoted-string} $|$ {\em identifier} \\
\emkey{lexical-class} & ::= & {\em identifier} \\
\emkey{lexical-atom-translation} & ::= & {\em quoted-string} \\
\end{tabular}
\end{center}%
\label{LEXICAL-ATOM-TABLE-ENTRY}

The following are some entries in the standard {\tt lexeme} atom table:

\begin{indpar}\begin{verbatim}
"a"     identifier
"++"    operator
"+"     operator
";"     separator
"L'"    wide char string
"\""    quoted string
"0"     oct number
"1"     number
".0"    number
".1"    number
\end{verbatim}\end{indpar}

Because of these entries the input string `{\tt ++a}' will be
recognized as consisting of the operator lexeme `{\tt ++}' followed
by the beginning of an identifier.  `{\tt ++}' is chosen over `{\tt +}'
because it is longer.  The input string `{\tt ++L'}', however,
would be recognized as beginning with the operator lexeme `{\tt ++}'
followed by the beginning of a `{\tt wide char string}'.

The state of the scanner is just the name of the atom table the
scanner is using.  The default state is `{\tt lexeme}', which uses
the {\tt lexeme} atom table.
Given input beginning with `{\tt ++a}', and the above entries in the
{\tt lexeme} atom table,
the scanner accepts the atom `{\tt ++}' as an operator lexeme and removes
it from the input.  Then given input beginning with `{\tt a}', the
scanner does not accept any input, but instead just switches state to
`{\tt identifier}' and continues by scanning identifier atoms.
In certain states, such as the `{\tt identifier}' state, the
scanner accumulates all the translations of the atoms accepted in
that state, and when the scanner switches out of the state, the
scanner ejects the accumulated string as a lexeme of the type
named by the state.

The following are some entries in the
standard `{\tt quoted string}' table:

\begin{indpar}\begin{verbatim}
"\\t"   accept       "\t"
"\\""   accept       "\""
"\""    begin        ""
"\""    end          ""
\end{verbatim}\end{indpar}

Here the input `{\tt \BACKSLASH t}' is translated to a horizontal
tab, the input `{\tt \BACKSLASH "}' is translated to
a single double quote, and
the `{\tt "}' character, if it is not part of another atom,
translates to the empty string.  By default an atom translates to itself.

The `{\tt "}' character appears twice in the table, once as
a begin atom, which can only be recognized
at the beginning of a quoted string, and once as an end atom,
which ends the string and cannot appear at the beginning of
a string.  Most characters, like `{\tt a}' and
`{\tt +}', are not listed in the table:
they become accepted atoms that translate to themselves by default.
For {\tt string} tables characters not listed become part of the string;
but for {\tt identifier} tables characters not listed terminate
the identifier.

We say that an atom is
\ikey{accepted}{lexical atom} if it is removed from the input string, and
\ikey{rejected}{lexical atom} if it is not.
An atom is said to be
\ikey{accumulated}{lexical atom} if it is accepted and its translation
is added to the lexeme string currently being accumulated.
An atom is said to be
\ikey{discarded}{lexical atom} if it is accepted and \underline{not} added
to the lexeme string currently being accumulated.
The accumulated lexeme string
may be output as a lexeme of the type of the current lexical scanner state
when the scanner switches out of that state, or the accumulated string
may be discarded when the scanner switches state.  Recall that the
scanner state is just the name of the lexical atom table the scanner
is currently using.

This scheme for lexical scanning is intended to give the user
control over the set of operators, punctuation, characters
that can appear in identifiers, character representatives in
quoted strings, etc.  The atom tables are quite verbose, and
are usually compiled from a more compact representation.

\subsection{The Lexeme Atom Table}

When the scanner is in the {\tt lexeme} state, it can accept
atoms and output their translations as complete lexemes, or it can reject
atoms and switch to a different state.  Translations are
\underline{not} accumulated in this state.  If there is no
recognizable atom at the beginning of the input, the next input UTF-8
character sequence is discarded and announced as an error.
If the next character is not part of a legal UTF-8 character sequence,
it is discarded and announced as an error.

The following are the possible lexical atom types in the lexeme atom table:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{3.5in}}
{\em qualifier}$^\star$
\ttkey{operator}	& The atom is accepted and its translation is
			  output \\
			& as a `{\em qualifier}$^\star$ {\tt operator}' lexeme.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{separator}	& The atom is accepted and its translation is
			  output \\
			& as a `{\em qualifier}$^\star$ {\tt separator}' lexeme.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{identifier}	& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt identifier}'.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{number}		& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt number}'.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{string}		& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt string}'.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{comment}		& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt comment}'.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{whitespace}	& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt whitespace}'.
\\[1ex]
{\em qualifier}$^\star$
\ttkey{error}		& The atom is rejected and the state becomes \\
			& `{\em qualifier}$^\star$ {\tt error}'.
\end{tabular}
\end{center}

\subsection{Identifier Atom Tables}

When the scanner is in a `{\em qualifier}$^\star$ {\tt identifier}' state,
it can accumulate
atoms, or it can reject atoms and switch to the {\tt lexeme} state.
Translations of accumulated atoms are appended to the current
accumulation string.
If at any time there is no recognizable atom at the beginning of the
remaining input,
the scanner switches to the {\tt lexeme} state without accepting
any further input, and outputs its accumulated string as a
`{\em qualifier}$^\star$ {\tt identifier}' lexeme.

The following are the possible lexical atom types in an identifier atom table:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\ttkey{accept}	  & Accumulate the atom.
\\[1ex]
\ttkey{begin}	  & Accumulate the atom, but only
		    recognize the atom if it is the first atom
		    in the {\tt identifier} state.
\\[1ex]
\ttkey{continue}  & Accumulate the atom, but only
		    recognize the atom if it is \underline{not} the first
		    atom in the {\tt identifier} state.
\\[1ex]
\ttkey{end}	  & Accumulate the atom, but only
		    recognize the atom if it is \underline{not} the first
		    atom in the {\tt identifier} state.  After
		    accumulating the atom, switch into the {\tt lexeme} state.
\\[1ex]
\ttkey{error}	  & Discard the atom, and announce that the
		    atom is in error.
\\[1ex]
\end{tabular}
\end{center}

\subsection{Number Atom Tables}

Then the scanner is in a `{\em qualifier}$^\star$ {\tt number}' state,
it can accumulate
atoms, or it can reject atoms and switch to the {\tt lexeme} state.
Translations of accumulated atoms are appended to the current
accumulation string.
If at any time there is no recognizable atom at the beginning of the
remaining input,
the scanner switches to the {\tt lexeme} state without accepting
any further input, and outputs its accumulated string as a
`{\em qualifier}$^\star$ {\tt number}' lexeme.

The following are the possible lexical atom types in a number atom table:

\begin{indpar}
\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{digit}	& Accumulate the atom, but only recognize
		  the atom if it is \underline{not} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{begin digit}
		& Accumulate the atom, but only
		  recognize the atom if it is the first atom.
\\[1ex]
\ttkey{continue digit}
		& Accumulate the atom, but only
		  recognize the atom if it is \underline{not}
		  the first atom and \underline{not} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{point}	& Accumulate the atom, but only recognize
                  the atom if it is \underline{not}
		  after either another {\tt point}
		  or a {\tt begin exponent} atom.
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{end}
		& Accumulate the atom, but only recognize
		  the atom if it is \underline{not} the first atom.
		  After accumulating the atom, the scanner switches
		  to {\tt lexeme} state.
\\[1ex]
\ttkey{floating end}
		& Like {\tt end}, but \underline{must} be after a {\tt point}
		  or {\tt begin exponent}.
\\[1ex]
\ttkey{integer end}
		& Like {\tt end},
		  but must \underline{not} be after a {\tt point}
		  or {\tt begin exponent}.
\end{tabular}
\end{indpar}
\begin{indpar}
\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{begin exponent}
		& Accumulate the atom, but only recognize
		  the atom if it is \underline{not} the first atom
		  and is \underline{not} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{exponent digit}
		& Accumulate the atom, but only recognize
		  the atom if it \underline{is} after a
		  {\tt begin exponent} atom.
\\[1ex]
\ttkey{error}	& Discard the atom, and announce that the
		  atom is in error.
\end{tabular}
\end{indpar}

Some example number atom tables are:

~~{\tt hex number} atom table (for integers):

\begin{indpar}\begin{verbatim}
"0x0"   begin digit
"0x1"   begin digit
. . . . . . . . . .
"0xF"   begin digit
"0"     continue digit
"1"     continue digit
. . . . . . . . . .
"F"     continue digit
"l"     end
"u"     end
. . . . . . . . . .
"UL"    end
\end{verbatim}\end{indpar}

~~{\tt number} atom table:

\begin{indpar}\begin{verbatim}
"0"     digit
"1"     digit
. . . . . . . . . .
"9"     digit
"."     point
"E0"    begin exponent
"E1"    begin exponent
. . . . . . . . . .
"E+0"   begin exponent
"E+1"   begin exponent
. . . . . . . . . .
"e-9"   begin exponent
"0"     exponent digit
"1"     exponent digit
. . . . . . . . . .
"9"     exponent digit
"l"     integer end
"f"     floating end
"L"     integer end
"F"     floating end
\end{verbatim}\end{indpar}

\subsection{String Atom Tables}

A `{\em qualifier}$^\star$ {\tt string}' state behaves just like
an {\tt identifier} state, with `{\tt identifier}' replaced
by `{\tt string}', except that if the remaining input does not begin with
a recognized atom, the first UTF-8 character sequence of the remaining input
is accumulated, and the state does not change.
If the first character of the remaining input is not part of a legal
UTF-8 sequence, that character is discarded and announced as an error,
and the state does not change.
Thus {\tt end} atoms must be used
to end a {\tt string} scan state.

\subsection{Comment Atom Tables}

A `{\em qualifier}$^\star$ {\tt comment}' state behaves just like
a {\tt string} state, with `{\tt string}' replaced
by `{\tt comment}', except that when the scanner leaves a comment
state the accumulated string is discarded, and \underline{not}
made into a lexeme.

\subsection{Whitespace Atom Tables}

A `{\em qualifier}$^\star$ {\tt whitespace}' state behaves just like
a {\tt comment} state, with `{\tt comment}' replaced
by `{\tt whitespace}', except that when the remaining input does not begin
with a recognized atom, input is rejected, and the scanner
switches to {\tt lexeme} state.  When the scanner leaves a {\tt whitespace}
state the accumulated string is discarded, and \underline{not}
made into a lexeme.

\subsection{Error Atom Tables}

A `{\em qualifier}$^\star$ {\tt error}' state behaves just like
a {\tt whitespace} state, with `{\tt whitespace}' replaced
by `{\tt error}', except that 
when the scanner leaves an {\tt error}
state the accumulated string, which is discarded, is announced as an error.

\subsection{The Lexeme Definition Language}

Lexeme tables for the standard lexical scanner are written in
the \key{Lexeme Definition Language}.  This language defines
a {\em lexical-groups} that are sets of lexical atom tables.
These groups can be referenced from code when the currently effective
set of lexical atom tables needs to be changed.

Lexeme Definition Language consists of {\em lexical-definitions} with
the following syntax:

\begin{tabular}{p{2.5in}rl}
\emkey{lexical-definition}
	& ::= & {\em lexical-units-block} \\
	& $|$ & {\em lexical-atom-table-definition} \\
	& $|$ & {\em lexical-class-definition} \\
	& $|$ & {\em lexical-group-definition}
\end{tabular} \\
\begin{tabular}{p{2.5in}rl}
\emkey{lexical-units-block} & ::= &
	{\tt begin lexical units;}\\
	& &  ~~~~{\em lexical-unit-definition}$^\star$ \\
	& & {\tt end lexical units;}
\\[1ex]
\emkey{lexical-unit-definition} & ::= &
	{\tt "}{\em lexical-unit}{\tt "} \underline{\tt ::=} \\
	& & ~~~~{\em quoted-string} \{ {\tt |} {\em quoted-string} \}$^\star$
	    {\tt ;}
\\[1ex]
\emkey{lexical-unit} & ::= & {\tt <}\{{\em letter}$|${\tt -}\}$^+${\tt >}
\end{tabular} \\
\begin{tabular}{p{2.5in}rl}
\emkey{lexical-atom-table-definition} & ::= &
	{\tt begin} {\em lexeme-type}
		    \begin{tabular}[t]{@{}l@{}}
		    {\tt atom table} \\
		    {\em lexical-options}{\tt ;}
		    \end{tabular}\\
	& &  ~~~~{\em lexical-atom-table-entry}$^\star$ \\
	& & {\tt end} {\em lexeme-type} {\tt atom table;}
\\[1ex]
\emkey{lexical-options} & ::= & {\em empty} $|$ {\tt ( )} \\
			& $|$ & {\tt (} {\em lexical-option}
				       \{ {\tt ,} {\em lexical-option} \}
			               {\tt )}
\\[1ex]
\emkey{lexical-option} & ::= & \ttkey{discard} $|$ \ttkey{continue}
					       $|$ \ttkey{error}
					       $|$ \ttkey{atomic} \\
		       & $|$ & \ttkey{announce} $|$ \ttkey{remove}
		                                $|$ {\em lexeme-type}
\\[1ex]
\emkey{lexical-atom-table-entry}
	& ::= & see page \pageref{LEXICAL-ATOM-TABLE-ENTRY}
\end{tabular} \\
\begin{tabular}{p{2.5in}rl}
\emkey{lexical-class-definition}
	& ::= & {\tt lexical} {\em lexical-class} {\tt class}
				    {\em lexical-options}{\tt ;}
\\[1ex]
\emkey{lexical-class} & ::= & {\em identifier}
\end{tabular} \\
\begin{tabular}{p{2.5in}rl}
\emkey{lexical-group-definition}
	& ::= & \begin{tabular}[t]{@{}l@{}}
	        {\tt lexical} {\em new-lexical-group} {\tt group} \\
		~~~~ {\tt (} {\em lexical-group} \{ {\tt ,}
				{\em lexical-group} \} {\tt );}
		\end{tabular}
\\[1ex]
\emkey{new-lexical-group}
    & ::= & \{ {\em identifier} $|$ {\em quoted-string} \}$^\star$
             {\em identifier}
\\[1ex]
\emkey{lexical-group} & ::= & {\em new-lexical-group} $|$ {\em lexeme-type}
\\[1ex]
\emkey{lexeme-type}
	& ::= & see page \pageref{LEXICAL-ATOM-TABLE-ENTRY}
				    
\end{tabular}

{\em Lexical-units} are used to abbreviate sets of lexical atom tables.
{\em Lexical-classes} are used in {\em lexeme-types}, which name
lexical atom tables.  They are a way of setting default
{\em lexical-options} for the tables.  {\em Lexical-groups} name sets
of lexical atom tables.  Lexical atom tables are generally defined in
a separate file, and {\em lexical-groups} are used in other files
as names of sets of the tables.  The {\em lexeme-type} that names
a lexical atom table can also be used as a {\em lexical-group}
naming the set whose only element is just that table.

A \emkey{lexical-unit} names a set of quoted strings.  Definitions of
lexical units may \underline{not} be recursive.

A {\em Lexical-unit} begins with `\verb|<|' and ends with `\verb|>|'
and appears inside quoted strings.  A
{\em lexical-unit} appearing in a quoted string after a {\tt ::=} in a
{\em lexical-unit-definition}, or anywhere in a
{\em lexical-atom-table-entry}, is
\ikey{replaceable}{lexical-unit-name@{\em lexical-unit-name}}.
The replacements for such a {\em lexical-unit} are the
strings in the set it names.

Each entry or definition containing replaceable {\em lexical-unit}
is expanded to a separate copy for each replacement of the name.
If a single name appears twice, it is replaced by the same string in
each occurrence.  If two or more different names appear,
every combination of replacements generates another copy of the
entry or definition.

Thus

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<digit>" ::= "0" | "1";
    "<sign>"  ::= "+" | "-";

    "<doubled-digit>" ::= "<digit><digit>";

    "<one-digit>"  ::= "<digit>";
    "<two-digits>" ::= "<one-digit><digit>";
end lexical units;
\end{verbatim}\end{indpar}

is equivalent to

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<digit>" ::= "0" | "1";

    "<doubled-digit>" ::= "00" | "11";

    "<one-digit>"  ::= "0" | "1";
    "<two-digits>" ::= "00" | "01" | "10" | "11";
end lexical units;
\end{verbatim}\end{indpar}

and given these {\em lexical-unit-definitions},

\begin{indpar}\begin{verbatim}
begin lexeme atom table;
    "<digit>"                 number;
    "<digit><digit>"          double number "D<digit>";
    "<digit><one-digit>"      two digit number;
end lexeme atom table;
\end{verbatim}\end{indpar}

is equivalent to

\begin{indpar}\begin{verbatim}
begin lexeme atom table;
    "0"                       number;
    "1"                       number;
    "00"                      double number "D0";
    "11"                      double number "D1";
    "00"                      two digit number;
    "01"                      two digit number;
    "10"                      two digit number;
    "11"                      two digit number;
end lexeme atom table;
\end{verbatim}\end{indpar}

Lexical atoms and their translations in the lexical atom tables
are all required to be complete legal UTF-8 character strings.
As a consequence, all recognized atoms will be such, and it will
not matter whether the lexical analyzer actually uses 8-bit bytes
or 16-bit UNICODE characters in its implementation.

A \key{lexical context} consists of a stack of {\em lexical-definitions}.
If definitions in the stack have the same name,
the topmost is used.  Note that names of different kinds of definitions
do \underline{not} conflict: the same identifier can be used as a
{\em lexeme-type} that names a lexical atom
table and as a {\em lexical-class}.  Here a {\em lexical-atom-table-definition}
also serves as a {\em lexical-group-definition} defining its
{\em lexeme-type} as a {\em lexical-group} naming the set consisting of
just the table.

A file containing {\em lexical-definitions}
defines a lexical context into which is pushed each definition as it
occurs.  The lexical context used to scan such a file is different from
the lexical context being defined by the file, so the definitions themselves
are \underline{not} scanned using the context they define.
However, the definitions use the context being defined to look up
names, e.g., {\em lexical-units} in quoted strings
and {\em lexeme-types} in {\em lexical-group-definitions}.

If a {\em lexical-unit} is defined that
is equal to \ttnbakey{"\LESSTHAN remove\GREATERTHAN"}{remove},
this has the effect of removing the
{\em lexical-unit} from the set of {\em lexical-units} defined by a context.
It is as if the unit had never been defined.
If a lexical atom table with the `\ttkey{remove}' option\label{REMOVE}
is defined, it
has the effect of removing its {\em lexeme-type} name from the set of
defined {\em lexeme-types}.  Similarly for {\em lexical-classes}.
If a {\em lexical-group} is defined to be the singleton set
`\ttkey{remove}', this has the effect
of removing the {\em lexical-class} from the set of
defined {\em lexical-classes}.

The \key{default lexical context}\index{lexical context!default}%
\index{context!lexical default} is defined using standard
{\em lexical-definitions} given
in Appendix~\secref{STANDARD-LEXICAL-ATOM-TABLES}.
This is normally used to scan files containing lexical definitions.

Other layered programming languages use lexical contexts that consist
of nothing but a stack of lexical atom tables, each table being treated
as equivalent to a definition of the table.  These are
modified by importing {\em lexical-groups} within a code block.
When a {\em lexical-group} is imported, its lexical atom tables are pushed
into the current lexical context.  At the end of the code block into which the
group is imported, the tables are popped from the context.
A table with the `{\tt remove}' option can be used to temporarily
hide all tables with the same name.

\subsubsection{Lexical Unit Translators}
\label{LEXICAL-UNIT-TRANSLATORS}

The standard {\em lexical-definitions} given in
Appendix~\secref{STANDARD-LEXICAL-ATOM-TABLES} include
the following entries in the `{\em quoted string atom}' table:

\begin{indpar}\begin{verbatim}
    "<backslash-control>"   continue  "<char backslash-control>";
    "<backslash-char>"      continue  "<char backslash-char>";
\end{verbatim}\end{indpar}

These entries invoke the `{\tt char translator}' which does things
like translate the string {\tt "\BACKSLASH\BACKSLASH n"}
to {\tt "\BACKSLASH n"}.  Here the first
string is a backslash character followed by the letter `{\tt n}',
and the second string is just a single line feed character.
As a consequence, when `{\tt \BACKSLASH n}' (represented
by {\tt "\BACKSLASH\BACKSLASH n"}) is substituted for
`{\tt <backslash-control>}' in the first
entry above, `{\em line-feed}\,' (represented by
by {\tt "\BACKSLASH n"}) is substituted for
`{\tt <char backslash-control>}' in entry.
This produces:

\begin{indpar}\begin{verbatim}
    "\\n"   continue  "\n";
\end{verbatim}\end{indpar}

A \key{lexical translator} is a lexical atom table whose lexical
class is `\ttkey{translator}'.  It can be used in
{\em translated-lexical-units} which have names of the form:

\begin{indpar}
\begin{tabular}{p{2.0in}rl}
\emkey{translated-lexical-unit}
	& ::= & {\tt <}{\em lexical-translator}
		{\em lexical-unit-name}{\tt >}
\\[1ex]
\emkey{lexical-translator} & ::= & \{{\em letter}$|${\tt -}\}$^+$
\\[1ex]
\emkey{lexical-unit-name} & ::= & \{{\em letter}$|${\tt -}\}$^+$
\end{tabular}
\end{indpar}

The strings of the translated lexical unit
    {\tt <}{\em lexical-translator} {\em lexical-unit-name}{\tt >}
are the strings of the lexical unit
    {\tt <}{\em lexical-unit-name}{\tt >}
run through a translation process that uses just the lexical atom
table named `{\em lexical-translator} {\tt translator}' (this is
the {\em lexeme-type} of the table).  To translate a string,
a lexical scan is made with the string as input and the
`{\em lexical-translator} {\tt translator}' table as the only
lexical atom table and only state.  The string accumulated in this
state is the translation.  The translation ends when the input
string ends.

The standard {\em lexical-definitions} given in
Appendix~\secref{STANDARD-LEXICAL-ATOM-TABLES} include
a single {\tt translator} table, `{\tt char translator}' which provides
for the translations needed elsewhere in the standard definitions.
This table translates character sequences that can appear in a standard
quoted string into their UTF-8 equivalents.  For example,
\verb|"\\xFFFF"| is translated to \verb|"\xEF\xBF\xBF"|,
and \verb|"\\n"| is translated to \verb|"\n"|,
while \verb|"A"| is translated to \verb|"A"|.
In order to accommodate variants such as \verb|"\\xffff"|
and \verb|"XFFFF"| this table has several million entries.

\subsubsection{Lexical Options}

A lexical atom table has \emskey{lexical-option}s that control the behavior
of the table.  A {\em lexical-class} has {\em lexical-options} that become
the default set of options for any table whose naming {\em lexeme-type} ends
with the {\em lexical-class}.
Tables whose definitions do not give a parenthesized list
of options inherit their options from their class.

The following are the effects of the different {\em lexical-options}:

\begin{indpar}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\emkey{lexeme-type}
		& This is the \key{default exit state}\label{DEFAULT-EXIT-STATE}
		  of the table.
		  The current scanning state is change to this state
		  under various circumstances described in the following
		  options.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{continue}& By default, if no atom can be recognized by the
                  table, the state is changed to the default exit
		  state of the table.  This `{\tt continue}' option
		  causes the first legal UTF-8 character string
		  in the remaining input to be recognized as an atom
		  and accepted, instead.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{error}   & By default, if the beginning of the remaining input
		  does not hold a legal UTF-8 character string (one that
		  encodes a 16-bit UNICODE character), the state
		  is changed to the default exit state of the table.
		  This `{\tt error}' options causes characters to be
		  removed from the remaining input until the input
		  begins with a legal UTF-8 charcter string, and
		  an error to be announced concerting these characters,
		  without changing the state.  The removed characters
		  are effectively discarded and not include in any
		  lexeme.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{discard}	& By default, any string accumulated by the action of
		  the table is emitted as a lexeme when the state
		  is changed to exit the table.
		  This `{\tt discard}' option causes the
		  string to be discarded instead.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{error}	& By default, any string accumulated by the action of
		  the table is not announced as an error the state
		  is changed to exit the table.  This `{\tt error}'
		  option causes the string to be announced as an error
		  instead.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{atomic}	& This is a {\em lexical-class} option only.  It specifies
		  that there is no lexical atom table for {\em lexeme-types}
		  of this class, and instead each atom whose
		  {\em lexical-atom-type} is the given {\em lexeme-type}
		  should be emitted as a lexeme of the given {\em lexeme-type}.
		  E.g., the standard `{\tt separator}' class.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{remove}	& See \pagref{REMOVE}.
\end{tabular}

\end{indpar}

\subsubsection{Lexical Atom Types}

A \emkey{lexical-atom-type} is the part of the
{\em lexical-atom-table-entry} (\pagref{LEXICAL-ATOM-TABLE-ENTRY})
that specifies the action to take when a lexical atom appears
at the beginning of the remainder of the input.  The {\em lexical-atom-types}
normally used with the standard {\em lexical-classes} are described with
each standard class above.  However, any {\em lexical-atom-type} can
be used with any class.  The following is a complete list of
{\em lexical-atom-types} and their actions:


\begin{indpar}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
{\em lexeme-type}	& If the {\em lexeme-type}'s {\em lexical-class}
			  has the `{\tt atomic}' option,
			  emit the atom as a lexeme of the {\em lexeme-type}
			  and do not change the state.  Otherwise
			  reject the atom and change the state to that
			  named by the {\em lexeme-type}.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{accept}	& Accumulate the atom.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{begin}	  & Accumulate the atom, but only
		    recognize the atom if it is the first atom
		    in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{continue}  & Accumulate the atom, but only
		    recognize the atom if it is \underline{not} the first
		    atom of the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{end}	  & Accumulate the atom, but only
		    recognize the atom if it is \underline{not} the first
		    atom in the current state.  After
		    accumulating the atom, switch into the
		    default exit state (\pagref{DEFAULT-EXIT-STATE}).
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{begin end}
		  & Accumulate the atom, but only
		    recognize the atom if it is the first atom
		    in the current state.  After
		    accumulating the atom, switch into the
		    default exit state (\pagref{DEFAULT-EXIT-STATE}).
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{error}	  & Discard the atom, and announce that the
		    atom is in error.  Do not accumulate the atom
		    or change the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{digit}	& Accumulate the atom, but only recognize
		  the atom if it is \underline{not} after a
		  {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{continue digit}
		& Accumulate the atom, but only
		  recognize the atom if it is \underline{not}
		  the first atom of the current state
		  and \underline{not} after a
		  {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{point}	& Accumulate the atom, but only recognize
                  the atom if it is \underline{not}
		  after either another {\tt point}
		  or a {\tt begin exponent} atom recognized in the current
		  state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{begin exponent}
		& Accumulate the atom, but only recognize
		  the atom if it is \underline{not} the first atom
		  of the current state
		  and is \underline{not} after a
		  {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{exponent digit}
		& Accumulate the atom, but only recognize
		  the atom if it \underline{is} after a
		  {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{floating end}
		& Like {\tt end}, but \underline{must} be after a {\tt point}
		  or {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\begin{tabular}{p{1.3in}@{~~~~~~~~~~}p{4.0in}}
\ttkey{integer end}
		& Like {\tt end},
		  but must \underline{not} be after a {\tt point}
		  or {\tt begin exponent} atom recognized in the current state.
\end{tabular}

\end{indpar}

\section{Parsing}

\newpage

\appendix

\section{Standard Lexical Atom Tables}
\label{STANDARD-LEXICAL-ATOM-TABLES}

\begin{indpar}\begin{verbatim}
lexical lexeme class ( announce );
lexical operator class ( atomic );
lexical separator class ( atomic );
lexical identifier class ( announce, lexeme );
lexical number class ( error, lexeme );
lexical string class ( continue, error, lexeme );
lexical comment class ( discard, continue, error, lexeme );
lexical whitespace class ( discard, error, lexeme );
lexical error class ( announce, discard, lexeme );
\end{verbatim}

\verb|// The following is described in |%
\ttitemref{LEXICAL-UNIT-TRANSLATORS}{\tt .}
\begin{verbatim}
begin char translator atom table;

    // Accept all ASCII characters except \.
    "\x0000"	accept;
    "\x0001"	accept;
    . . . entries omitted . . .
    "\x005B"	accept;
    // Skip \x005C which is backslash
    "\x005D"	accept;
    . . . entries omitted . . .
    "\x007F"	accept;

    // Decode all \x Unicode characters to UTF-8.
    "\\x0000"	accept	"\x00";
    . . . entries omitted . . .
    "\\x007f"	accept	"\x7F";
    "\\x007F"	accept	"\x7F";
    "\\x0080"	accept	"\xC1\x80";
    . . . entries omitted . . .
    "\\xffff"	accept	"\xEF\xBF\xBF";
    "\\xfffF"	accept	"\xEF\xBF\xBF";
    "\\xffFf"	accept	"\xEF\xBF\xBF";
    "\\xffFF"	accept	"\xEF\xBF\xBF";
    . . . entries omitted . . .
    "\\xFFFf"	accept	"\xEF\xBF\xBF";
    "\\xFFFF"	accept	"\xEF\xBF\xBF";
    "\\x000"	accept	"\x00";
    . . . entries omitted . . .
    "\\x07f"	accept	"\x7F";
    "\\x07F"	accept	"\x7F";
    "\\x080"	accept	"\xC1\x80";
    . . . entries omitted . . .
    "\\xFFF"	accept	"\xE0\xBF\xBF";
    "\\x00"	accept	"\x00";
    . . . entries omitted . . .
    "\\x7f"	accept	"\x7F";
    "\\x7F"	accept	"\x7F";
    "\\x80"	accept	"\xC1\x80";
    . . . entries omitted . . .
    "\\xFF"	accept	"\xC3\xBF";
    "\\x0"	accept	"\x00";
    . . . entries omitted . . .
    "\\xf"	accept	"\x0F";

    // Ditto for \X.
    "\\X0000"	accept	"\x00";
    . . . entries omitted . . .
    "\\XFF"	accept	"\xC3\xBF";

    // Ditto for \0.
    "\\000000"	accept	"\x00";
    . . . entries omitted . . .
    "\\177777"	accept	"\xEF\xBF\xBF";
    . . . entries omitted . . .
    "\\00000"	accept	"\x00";
    . . . entries omitted . . .
    "\\77777"	accept	"\xE7\xBF\xBF";
    . . . entries omitted . . .
    "\\0"	accept	"\x00";
    . . . entries omitted . . .
    "\\7"	accept	"\x07";

    // Standard abbreviations.
    "\\n"	accept "\n";
    "\\f"	accept "\f";
    "\\v"	accept "\v";
    "\\t"	accept "\t";
    "\\r"	accept "\r";
    "\\b"	accept "\b";
    "\\a"	accept "\a";
    "\\?"	accept "\?";
    "\\'"	accept "\'";
    "\\\""	accept "\"";
    "\\r"	accept "\r";
    "\\\\"	accept "\\";

end char translator atom table;
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<letter>" ::= "A" | "B" | "C" | "D" | "E" | "F" | "G"
                 | "H" | "I" | "J" | "K" | "L" | "M"
                 | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
                 | "U" | "V" | "W" | "X" | "Y" | "Z"
                 | "a" | "b" | "c" | "d" | "e" | "f" | "g"
                 | "h" | "i" | "j" | "k" | "l" | "m"
                 | "n" | "o" | "p" | "q" | "r" | "s" | "t"
                 | "u" | "v" | "w" | "x" | "y" | "z" ;
    "<non-zero-digit>" ::=       "1" | "2" | "3" | "4"
                        | "5" | "6" | "7" | "8" | "9" ;
    "<digit>" ::= "0" | "<non-zero-digit>" ;
    "<oct-digit>" ::= "0" | "1" | "2" | "3"
                    | "4" | "5" | "6" | "7" ;
    "<hex-digit>" ::= "A" | "B" | "C" | "D" | "E" | "F"
                    | "a" | "b" | "c" | "d" | "e" | "f"
                    | "<digit>" ;
    "<sign>" ::= "+" | "-" ;
    "<operator>" ::= "!" | "%" | "^" | "&" | "*"
                   | "(" | ")" | "-" | "+" | "="
                   | "{" | "}" | "|" | "~" | "["
                   | "]" | ";" | ":" | "<" | ">"
                   | "?" | "," | "/" | "/" | "->"
                   | "++" | "--" | ".*" | "->*" | ">>"
                   | "<<" | "<=" | ">=" | "==" | "!="
                   | "&&" | "||" | "*=" | "/=" | "%="
                   | "+=" | "-=" | "<<=" | ">>=" | "&="
                   | "^=" | "|=" | "::" ;
    "<whitespace>" ::= " " | "\t" | "\n" | "\r"
                     | "\f" | "\v" ;
end lexical units;
    
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<control>" ::=          "\001" | "\002" | "\003"
                  | "\004" | "\005" | "\006" | "\007"
                  | "\010" 
                                    | "\016" | "\017"
                  | "\020" | "\021" | "\022" | "\023"
                  | "\024" | "\025" | "\026" | "\027"
                  | "\030" | "\031" | "\032" | "\033"
                  | "\034" | "\035" | "\036" | "\037"
                  | "\177" ;

    "<oct1>" ::= "<oct-digit>";
    "<oct2>" ::= "<oct-digit><oct1>";
    "<oct3>" ::= "<oct-digit><oct2>";
    "<oct4>" ::= "<oct-digit><oct3>";
    "<oct5>" ::= "<oct-digit><oct4>";
    "<oct6>" ::= "<oct-digit><oct5>";
    "<oct7>" ::= "<oct-digit><oct6>";
    "<oct-char>" ::= "\\<oct1>"  | "\\<oct2>"
                   | "\\0<oct2>" | "\\1<oct2>"
                   | "\\2<oct2>" | "\\3<oct2>";
    "<bad-oct-char>" ::= "\\4<oct2>" | "\\5<oct2>"
                       | "\\6<oct2>" | "\\7<oct2>"
                       | "\\<oct4>";
    "<oct-wchar>" ::= "\\<oct1>" | "\\<oct2>"
                    | "\\<oct3>" | "\\<oct4>"
                    | "\\<oct5>" | "\\0<oct5>"
                    | "\\1<oct5>";
    "<bad-oct-whar>" ::= | "\\2<oct5>" | "\\3<oct5>"
                         | "\\4<oct5>" | "\\5<oct5>"
                         | "\\6<oct5>" | "\\7<oct5>"
                         | "\\<oct7>";
end lexical units;
    
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin lexical units;
    "<hex1>" ::= "<hex-digit>";
    "<hex2>" ::= "<hex-digit><hex1>";
    "<hex3>" ::= "<hex-digit><hex2>";
    "<hex4>" ::= "<hex-digit><hex3>";
    "<hex5>" ::= "<hex-digit><hex4>";
    "<hex-char>" ::= "\\x<hex1>" | "\\x<hex2>"
                   | "\\X<hex1>" | "\\X<hex2>";
    "<bad-hex-char>" ::= "\\x<hex3>" | "\\X<hex3>";
    "<hex-wchar>" ::= "<hex-char>"
                   | "\\x<hex3>" | "\\x<hex4>"
                   | "\\X<hex3>" | "\\X<hex4>";
    "<bad-hex-wchar>" ::= "\\x<hex5>" | "\\X<hex5>";

    "<backslash-char>" ::= "<oct-char>" | "<hex-char>";
    "<backslash-wchar>" ::= "<oct-wchar>" | "<hex-wchar>";
    "<bad-backslash-char>" ::= "<bad-oct-char>"
                             | "<bad-hex-char>";
    "<bad-backslash-wchar>" ::= "<bad-oct-wchar>"
                              | "<bad-hex-wchar>";

    "<integer-suffix>" ::= "u" | "U" | "l" | "L"
                         | "ul" | "Ul" | "uL" | "UL"
                         | "lu" | "Lu" | "lU" | "LU";
    "<floating-suffix>" ::= "f" | "F" | "d" | "D";

    "<backslash-control>" ::= "\\f" | "\\v" | "\\n" | "\\r"
                            | "\\t" | "\\b" | "\\a" | "\\?"
                            | "\\\'" | "\\\"" | "\\\\";
end lexical units;
    
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}

begin lexeme atom table;
    "<operator>"        operator;
    "<separator>"       separator;
    "<letter>"          identifier;
    "0x<hex-digit>"     hex number;
    "0X<hex-digit>"     hex number;
    "0<oct-digit>"      oct number;
    "<non-zero-digit>"  number;
    ".<digit>"          number;
    "L'"                wide char string;
    "'"                 char string;
    "L\""               wide quoted string;
    "\""                quoted string;
    "//"                "//" comment;
    "/*"                "/*" comment;
    "<whitespace>"      whitespace;
end lexeme atom table;

// Note that C/C++ keywords are identifiers.
//
begin identifier atom table;
    "<letter>"  accept;
    "_"         accept;
    "<digit>"   continue;
    "<control>" error;
end identifier atom table;

\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
begin hex number atom table;
    "<hex-digit>"       continue digit;
    "0x<hex-digit>"     begin digit;
    "0X<hex-digit>"     begin digit;
    "<integer-suffix>"  end;
    "<control>"         error
end hex number atom table;
 
begin oct number atom table;
    "<oct-digit>"       continue digit;
    "0"                 begin digit;
    "<integer-suffix>"  end;
    "<control>"         error
end oct number atom table;
 
begin number atom table;
    "<digit>"           digit;
    "."                 point;
    "e<digit>"          begin exponent;
    "E<digit>"          begin exponent;
    "e<sign><digit>"    begin exponent;
    "E<sign><digit>"    begin exponent;
    "<digit>"           exponent digit;
    "<integer-suffix>"  integer end;
    "<floating-suffix>" floating end;
    "<control>"         error
end number atom table;
\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
 
begin quoted string atom table;
    "\""                    begin;
    "\""                    end;
    "<backslash-control>"   continue  "<char backslash-control>";
    "<backslash-char>"      continue  "<char backslash-char>";
    "<bad-backslash-char>"  error;
    "<control>"             error;
end quoted string atom table;
 
begin wide quoted string atom table;
    "L\""                   begin;
    "\""                    end;
    "<backslash-control>"   continue  "<char backslash-control>";
    "<backslash-wchar>"     continue  "<char backslash-wchar>";
    "<bad-backslash-wchar>" error;
    "<control>"             error;
end quoted string atom table;
 
begin char string atom table;
    "\'"                begin;
    "\'"                end;
    . . . rest just like quoted string table . . .
end char string atom table;
 
begin wide char string atom table;
    "L\'"               begin;
    "\'"                end;
    . . . rest just like wide quoted string table . . .
end char string atom table;

\end{verbatim}\end{indpar}

\newpage

\begin{indpar}\begin{verbatim}
 
begin whitespace atom table;
    " "                     accept;
    "\t"                    accept;
    "\n"                    accept;
    "\f"                    accept;
    "\v"                    accept;
    "<control>"             error;
end whitespace atom table;
 
begin "//" comment atom table;
    "//"                    begin;
    "\n"                    end;
end "//" comment atom table;
 
begin "/*" comment atom table;
    "/*"                    begin;
    "*/"                    end;
end "*/" comment atom table;

\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
