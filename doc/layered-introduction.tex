% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttnbakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\ttitemref}[1]{{\tt \ref{#1} ({p\pageref{#1}})}}
\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newsavebox{\DOUBLEQUOTEBOX}
\begin{lrbox}{\DOUBLEQUOTEBOX}
\verb/"/
\end{lrbox}
\newcommand{\DOUBLEQUOTE}{\usebox{\DOUBLEQUOTEBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

November 18, 2010
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A machine independent reduced instruction set architecture
	  programming language.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& Similar to the C programming language but more flexible.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& Implements standardized lists, symbols, arrays, etc. to extend
	  the M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `{\tt hello}', `{\tt +}', `{\tt ;}',
`{\tt 9.200}' are four lexemes.

The lexical scanner is written in the M-Language and can be
replaced.  This section describes the standard scanner which
is driven by the lexical tables and is capable scanning
lexemes of common languages such as C and C++.

The standard scanner attempts to be both machine and human
efficient.  It attempts to be machine efficient by being
deterministic\footnote{Unlike regular expression scanners.}
and attempts to be human efficient by supporting algorithms
that people can readily understand and hopefully quickly
learn to mimic.\footnote{A possibly non-verifiable goal.}

The standard scanner operates on an input stream of 32-bit
UNICODE characters.  Each character is associated with
a position value that specifies from where the character
came.  For example, a position value may encode a file name,
line-within-file number, and column-within-line number.
The standard scanner identifies a lexeme as a sequence
of input stream UNICODE 32-bit characters each with a
corresponding position value.

The standard scanner also produces a translation of each
lexeme.  This may just be a copy of the 32-bit characters
in the lexeme, or it may have some changes, or `translations',
of some of these characters.  For example, the lexeme
\verb|"a line\lf/"| may have a translation that omits the
\verb|"|'s and converts the four characters \verb|\lf/| into
a single linefeed character.

When the standard scanner identifies a lexeme it also identifies
a `\mkey{type}{of lexeme}' for the lexeme.
For example, the lexeme \verb|9.35| may have type `{\tt number}'
while the lexeme \verb|"abc"| may have the type `{\tt quoted string}'.

At its most fundamental level the
standard scanner identifies lexical atoms in the input text.
A \key{lexical atom} is a single character (e.g., the letters
in an identifier or symbol) or a short string of characters
(e.g., the characters \verb|\lf/| in a quoted string).
Lexical atoms are read left to right and
grouped by the scanner into \skey{lexeme}s.

Lexical atoms have fixed small lengths.  Lexemes, in contrast,
can be of arbitrary length.

The scanner has a state containing a current point 
in the input UNICODE character stream
and a \key{current lexical table} identifier.  A
\key{lexical table} is a set of atom patterns
that match atoms, and for each pattern an
instruction that determines what to do when the pattern is matched.
There is also a \key{default instruction} associated with
the lexical table that
determines what to do when no table pattern matches the next characters
in the input stream.

An \key{atom pattern}\index{pattern!lexical atom} is a fixed
length sequence of character patterns, and matches any sequence of
input characters of the same length as the atom pattern
if each input character of the sequence matches the corresponding
character pattern.  A \key{character pattern} is simply a
specification of a set of characters, e.g., letters or digits.
Thus one can construct an atom pattern that will recognize
single letters, or one that will recognize the sequence of
characters such as the 4-character sequence \verb|\lf/| which matches
the atom pattern \verb|"\\/lf/"|
or the 7-character sequence \verb|\0a/| which matches the atom pattern
\begin{center}
\verb|"\\/0<hex-digit>/"|
\end{center}
where \verb|<hex-digit>| names a character pattern matching characters
in the ranges \verb|0-9|, \verb|a-f|, and \verb|A-F|.

The atom patterns of a single lexical table must not conflict:
no character string can be recognized by two atom patterns of the
same lexical table.  However, a shorter atom pattern in a
table may match the initial segment of an atom matched by a longer
atom pattern in the table, in which case the longer pattern is
used for the atom.

The scanner operates by identifying the
longest sequence of characters beginning at the current input character
stream point that matches an atom pattern of the current lexical table.
This sequence of characters becomes
the next atom, and an instruction associated with its matching
atom pattern is then executed.  If no atom pattern can be matched,
the default instruction associated with the lexical table is executed instead.

A lexical table
instruction can optionally reduce the length of a matched atom
and optionally change the current lexical table.  It can also do other
things described below.

There are three kinds of lexical tables:
\mkey{master}{lexical table} tables,
\mkey{lexeme}{lexical table} tables, and
\mkey{translation}{lexical table} tables.
Master tables are used to dispatch to lexeme tables which
typically recognize lexemes.  Translation tables are used
to recognize atoms whose patterns are logically the union
of a finite set of patterns.

Thus a simple scanner might have
one master table that dispatches to different lexeme tables,
one to recognize identifiers, one to recognize numbers, one to
recognize whitespace, and one to recognize comments.

Lexeme tables have \ikey{types}{type!of lexeme table}.
When the current lexical table is changed from a lexeme
table to a master table, any non-zero length lexeme accumulated
so far is output as a lexeme whose type\label{KIND-OUTPUT}
is the type of the lexeme table.  Thus if an lexical table of
type `\verb|whitespace|' cannot recognized any atom and
the default instruction associated with it
changes the current lexical table to a master table,
any non-zero length lexeme accumulated so far will
be output as a lexeme of type `\verb|whitespace|'.

When it is between lexemes that current lexical table in the scanner state
is always a master table.  Master tables correspond to lexical
contexts.  A well designed language has only one main master
table, plus a few small master tables to handle error situations
such a premature new-line and premature end-of-file;
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.
Legacy languages
may have more master mode tables: C/C++ has several to handle
special lexical scanning of preprocessing lexemes;
see Appendix \itemref{C++-LEXICAL-PROGRAM}.

The standard scanner can report errors in one of two ways.  It may
simply output a lexeme with a type that indicates an error.  For
example, the character \verb|\| appearing outside a quoted string
might be returned as a 1-character lexeme of type `{\tt unrecognized
character}'.  Alternatively a single atom may be reported as an
error of a given type without interrupting the normal operation
of the scanner.  For example, if \verb|\h/| appears in a quoted
string, it may be reported as an erroneous atom of type
`{\tt unrecognized escape sequence}'.  Otherwise this atom is processed
normally; it might, for example, be omitted from the lexeme
translation or be represented in that translation by the DEL
character (\verb|\u007F|).

\ikey{Instructions}{instruction!in lexical program}
that are associated with atom patterns contain optional instruction
components that can do the following:
\begin{itemize}
\raggedright
\item invoke a translation table to replace the matched atom
\item reduce the length of the matched atom
\item translate the reduced length atom to a different
character string within the lexeme translation
\item announce the reduced length atom as an erroneous atom of a given type
\item output the atoms accumulated so far as a lexeme of a given type
\item change the current lexical table
\item make non-translating instruction components conditional
      on the translated atom matching an atom pattern
\end{itemize}

Details and examples are given in the next section.

A \key{lexical program} is a set of character pattern definitions
and lexical tables.  A lexical program can include another lexical program.
The top level lexical program must begin with a master
table that serves as the initial lexical table.


\subsection{Lexical Programs}

The lexemes in a lexical program are specified on
\pagref{LEXEME-PROGRAM-LEXEMES} and
and the syntax of a lexical program is specified on
\pagref{LEXEME-PROGRAM-SYNTAX-1} and
\pagref{LEXEME-PROGRAM-SYNTAX-2}.

\begin{figure*}[!p]
\begin{tabular}{p{2.2in}rl}
\emkey{lexeme} & ::= & {\em symbol} $|$ {\em number}
\\[0.5ex]
\emkey{symbol} & ::= & {\em word} $|$ {\em mark} $|$ {\em quoted-string}
	         $|$ {\em separator}
\\[0.5ex]
\emkey{word} & ::= & {\em word-character} {\em word-character}\,$^\star$ 
\\[0.5ex]
\emkey{mark} & ::= & {\em mark-character} {\em mark-character}\,$^\star$
\\[0.5ex]
\emkey{number-lexeme} & ::= &
        {\em number-character} {\em number-character}\,$^\star$
\\[0.5ex]
\emkey{quoted-string} & ::= &
    \verb|"| {\em character-representative}\,$^\star$ \verb|"|
\\[0.5ex]
\emkey{separator} & ::= & {\em separator-character}
\\[0.5ex]
\emkey{white-space} & ::= & {\em white-space-character}
                            {\em white-space-character}\,$^\star$
\\[2ex]
\emkey{word-character} & ::= & {\em letter} \\
		       & $|$ & \verb|'| followed by a letter \\
\emkey{letter} & ::= & {\em lower-case-letter} $|$ {\em upper-case-letter} \\
\emkey{lower-case-letter} & ::= &
                               \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\
\emkey{upper-case-letter} & ::= &
                               \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
\\[0.5ex]
\emkey{mark-character} & ::= &
                                \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|:| \\
		     & $|$ & \verb|.| not followed by a {\em digit} \\
		     & $|$ & \verb|/| not surrounded by {\em digits}
\\[0.5ex]
\emkey{separator-character} & ::= &
		        \verb|(|
	       	    $|$ \verb|)|
	       	    $|$ \verb|[|
	       	    $|$ \verb|]|
	       	    $|$ \verb|{|
	       	    $|$ \verb|}|
	       	    $|$ \verb|;|
	       	    $|$ \verb|`| \\
		& $|$ & \verb|,| not surrounded by {\em digits} \\
		& $|$ & \verb|'| not followed by a letter 
\\[0.5ex]
\emkey{number-character} & ::= & {\em digit} \\
		& $|$ & \verb|.| followed by by a {\em digit } \\
		& $|$ & \verb|,| surrounded by {\em digits} \\
		& $|$ & \verb|/| surrounded by {\em digits} \\
\emkey{digit} & ::= &
                   \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9| 
\\[0.5ex]
\emkey{character-representative}
    & ::= & {\em graphic-character-other-than-backslash} \\
    & ::= & \verb|\| {\em graphic-character-other-than-slash}$^\star$
            \verb|/| \\
\emkey{graphic-character} & ::= &
    {\em non-whitespace-non-control-character} \\
\emkey{backslash} & ::= & \verb|\| \\
\emkey{slash} & ::= & \verb|/|
\\[0.5ex]
\emkey{white-space-character}
    & ::= & {\em horizontal-space-character} \\
    & $|$ & {\em vertical-space-character} \\
\emkey{horizontal-space-character} & ::= &
    {\em space} $|$ {\em horizontal-tab} \\
\emkey{vertical-space-character} & ::= &
    {\em line-feed} $|$ {\em vertical-tab} $|$ {\em form-feed}
\end{tabular}
\label{LEXEME-PROGRAM-LEXEMES}
\end{figure*}

\begin{figure*}[!p]
\begin{tabular}{p{2.2in}rl}
\emkey{name}
    & ::= & \{ {\em word} $|$ {\em quoted-string} \} \\
    &     & \{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}$^\star$
\end{tabular}

\begin{tabular}{p{2.2in}rl}
\emkey{lexical-program} & ::= &
	{\tt begin} {\em program-name} {\tt lexical program;}\\
	& &  ~~~~{\em lexical-program-unit}$^\star$ \\
	& & {\tt end} {\em program-name} {\tt lexical program};
\\[1ex]
\emkey{program-name} & ::= & {\em name}
\\[1ex]
\emkey{lexical-program-unit}
	& ::= & {\em cpat-definition} \\
	& $|$ & {\em lexical-table-definition} \\
	& $|$ & {\em program-inclusion}
\\[1ex]
\emkey{program-inclusion} & ::= & {\tt include} {\em program-name}
				  {\em remove-clause}$^\star$ {\tt ;}
\\[1ex]
\emkey{remove-clause} & ::= & {\tt remove} {\em lexical-table-name} \\
                      & $|$ & {\tt remove} {\tt "}{\em cpat-name}{\tt "}
\\[1ex]
\multicolumn{3}{l}{~~~~~~Note: `{\em cpat}\,' abbreviates
                               `{\em character-pattern}\,'}
\\[1ex]
\emkey{cpat-definition} & ::= &
	{\tt "}{\em cpat-name}{\tt "} {\tt =}
		{\em cpat-expression} {\tt ;}
\\[1ex]
\emkey{cpat-name} & ::= &
	{\tt <}{\em letter}$^+$\{{\tt -}{\em letter}$^+$\}$^\star${\tt >}
\\[1ex]
\emkey{cpat-expression} & ::= &
	{\em cpat-term}
	\{ {\tt |} {\em cpat-term} \}$^\star$ \\
       & $|$ &
	{\em cpat-term}
	\{ {\tt \&} {\em cpat-term} \}$^\star$
\\[1ex]
\emkey{cpat-term} & ::= & {\em cpat-factor} $|$ \TILDE {\em cpat-factor}
\\[1ex]
\emkey{cpat-factor} & ::= & {\tt "}{\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em quotable-character}{\tt -}%
		                   {\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em cpat-name}{\tt "} \\
		    & $|$ & {\tt (} {\em cpat-expression}
		                {\tt )}
\\[1ex]
\emkey{quotable-character} & ::= & 
	any quotable UNICODE character representative
\\[1ex]
\emkey{lexical-table-definition} & ::= &
	{\tt begin} {\em lexical-table-name}
		    {\em lexical-table-kind} {\tt table} {\tt ;} \\
	& &  ~~~~{\em lexical-table-entry}$^\star$ \\
	& &  ~~~~{\em default-instruction-group} \\
	& & {\tt end} {\em lexical-table-name}
		      {\em lexical-table-kind} {\tt table} {\tt ;}
\\[1ex]
\emkey{lexical-table-kind} & ::= &
    {\tt master} $|$ {\tt lexeme} $|$ {\tt translation}
\\[1ex]
\emkey{lexical-table-name} & ::= & {\em type}
\\[1ex]
\emkey{type} & ::= & {\em name} except {\tt scan error}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-1}
\end{figure*}

\begin{figure*}[!t]
\begin{tabular}{p{2.2in}rl}
\emkey{default-instruction-group}
	& ::= &  {\em empty} $|$ {\em instruction-group}
\\[1ex]
\emkey{lexical-table-entry}
	& ::= & {\em atom-pattern} {\em instruction-group} {\tt ;} \\
	& $|$ & {\em atom-pattern} {\tt ;}
\\[1ex]
\emkey{atom-pattern} & ::= &
	{\tt "}\{{\em quotable-character}$|${\em cpat-name}\}$^\star${\tt "}
\\[1ex]
\emkey{instruction-group}
	& ::= & {\em instruction}
	        \{ {\tt else} {\em instruction} \}$^\star$

\\[1ex]
\emkey{instruction} & ::= & {\em instruction-component}$^+$
\\[1ex]
\emkey{instruction-component}
	& ::= & {\tt accept} \\
	& $|$ & {\tt keep} {\em natural-number} \\
	& $|$ & {\tt translate} {\em translation-table-name} \\
	& $|$ & {\tt translate to} {\em translation-string} \\
	& $|$ & {\tt translate hex}
			{\em natural-number} {\em natural-number} \\
	& $|$ & {\tt translate oct}
			{\em natural-number} {\em natural-number} \\
	& $|$ & {\tt require} {\em atom-pattern} \\
	& $|$ & {\tt error} {\em type} \\
	& $|$ & {\tt output} {\em type} \\
	& $|$ & {\tt goto} {\em master-table-name} \\
	& $|$ & {\tt goto} {\em lexeme-table-name} \\
	& $|$ & {\tt call} {\em lexeme-table-name} \\
	& $|$ & {\tt return} \\
	& $|$ & {\tt fail} \\
\\[1ex]
\emkey{translation-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{lexeme-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{master-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{translation-string} & ::= & {\em quoted-string}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-2}
\end{figure*}

An example lexical program that recognizes
whitespace and quoted strings without escapes is given
on \pagref{EXAMPLE-LEXEME-PROGRAM}.

\begin{figure*}[!p]
\addtolength{\baselineskip}{-0.4ex}
\begin{indpar}\begin{verbatim}
begin example lexical program;

"<whitespace-char>" = " " | "\lf/" | "\ht/" | "\vt/" | "\ff/";

begin main master table;
    "<whitespace-char>" goto whitespace;
    "\"/" translate "" goto quoted string;
    "<other>" output bad character;
    output end of file;
end main master table;

begin whitespace lexeme table;
    "<whitespace-char>" accept;
    goto main;
end whitespace lexeme table;

begin quoted string lexeme table;
    "\"/" translate "" goto main;
    "\lf/" keep 0 goto premature end of line;
    "<other>" accept;
    goto premature end of file;
end quoted string lexeme table;

include premature tables;

end example lexical program;

begin premature tables lexical program;
    // Stuff to include.

begin premature end of line master table;
    "\lf/" output premature end of line
         goto main;
end premature end of line master table;

begin premature end of file master table;
    output premature end of file;
end premature end of file master table;

end premature tables lexical program;
\end{verbatim}\end{indpar}
\label{EXAMPLE-LEXEME-PROGRAM}
\end{figure*}

A \emkey{lexical-program} consists of a sequence of units that are
{\em character-\EOL pattern-\EOL defi\-ni\-tions},
{\em lexical-\EOL table-\EOL defi\-ni\-tions},
or {\em program-inclusions}.  These respectively define character pattern sets
and lexical tables, and include lexical program units of
previously defined lexical programs.

\subsubsection{Lexical Program Inclusion}

A \emkey{program-inclusion} names a previously defined lexical program
whose units are to be included in the current lexical program
at the point of the {\em program-inclusion}.
There is a simple example of a program inclusion at the end of
the {\tt example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.
Identical definitions
may be repeated without error,
as can happen when one program includes two each of
which include the same third program.
A {\em program-inclusion} can have
\emsmkey{remove-clause}s{in {\em program-inclusion}}
each of which removes a named definition from the set of included
definitions.  This is the only way to resolve conflicts between
definitions.

\subsubsection{Character Pattern Definitions}

A \emkey{character-pattern-definition} (abbreviated as
\emkey{cpat-definition}) assigns a set of characters to a
{\em character-pattern-name}.  The latter is just a string of
letters and hyphens (\verb|-|) surrounded by angle brackets (\verb|< >|)
with hyphens occurring only between letters.  Examples:
\verb|<digit>| and \verb|<line-break>|.

The character set is denoted by a \emkey{character-pattern-expression}.
The simplest character pattern
expression is just a single {\em quotable-character} in quotes, which denotes
the character set containing only the quoted character.  Examples:
\verb|"0"| and \verb|"+"|.  The next simplest is two {\em quotable-characters}
separated by a hyphen (\verb|-|) denoting the character set consisting
of all characters in the range from the first to the second of the two
characters.  Examples: \verb|"0-9"| and \verb|"A-Z"|.  The characters
are ordered according to their 32 bit unsigned UNICODE value, and the
second of the two characters must not be smaller than the first.

A {\em quotable-character} is a representative of a single UNICODE
character that can be used inside quotes (\verb|"|).
Printable ASCII characters represent themselves.  Other characters
are represented by character sequences surrounded by backslash (\verb|\|)
and slash (\verb|/|).
For example, a line feed can be represented by any of the
following: \verb|\lf/|, \verb|\0a/|,
\verb|\00a/|, \ldots, or \verb|\00000000a/|.

A quoted {\em character-pattern-name} denotes the character set associated
with that name by a \underline{previous} {\em character-pattern-definition}.

The \verb/|/, \verb|&|, and \verb|~| operators and can be used to take
the union, intersection, and complements of character sets.  The complement
is relative to the universe of all 32 bit unsigned integer UNICODE
character codes.  Thus \verb|~ "b-y"| denotes the same character set as
\verb$"\0/-a" | "z-\0ffffffff/"$.

Parentheses may be used in {\em character-pattern-expressions} as is
normal in algebraic expressions.
Note that the \verb/|/ and \verb|&| operators cannot be used together
in the same expression without intervening parentheses as neither
takes precedence over the other.  This is done to prevent ambiguity.

Some example {\em character-pattern-definitions} are:

\begin{indpar}\begin{verbatim}
"<hex-digit>" = "0-9" | "a-f" | "A-F";
"<non-line-break-char>" = ~ "\lf/" & ~ "\vt/" & ~ "\ff/";
"<quotable-char>" = "\020/-\07e/" & ~ "\"/" & ~ "\\/";
"<whitespace-char>" = " " | "\lf/" | "\vt/" | "\ff/" | "\ht/";
"<source-character>" =
    ( "\020/-\07e/" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";
\end{verbatim}\end{indpar}

\subsubsection{Lexical Tables}

An {\em lexical-table-definition} specifies a {\em lexical-table-name},
the {\em lexical-table-kind} of the table,
a set of {\em lexical-table-entries}
each containing an {\em atom-pattern} and optionally an {\em instruction},
and an optional {\em default-instruction-group} that is executed when
no atom is recognized by any of the table entries.

The {\em lexical-table-kinds} are
\mkey{master}{lexical table kind},
\mkey{lexeme}{lexical table kind}, or
\mkey{translation}{lexical table kind}.
In a master table {\em atom-patterns} are typically associated
with {\tt goto} instructions that change the current table from the
master table to a lexeme table.  In a lexeme table {\em atom-patterns}
are typically associated with {\tt accept} instructions which
accept the matched atom as part of the current lexeme.  In a lexeme
table the default instruction is typically a {\tt goto} back to a
master table, and because this changes the current lexical table
from a lexeme table to a master table, it causes any non-zero length
accumulated lexeme to be output with its lexeme type being determined
by the lexeme table.

Translation tables permit sets of atom patterns to be used in
several places without copying all the patterns.  Details are
on \pagref{TRANSLATION-TABLE}.

The first lexical table in a lexical program must have `{\tt master}'
mode, and will become the current lexical table when the scanner
is initialized.  This table is typically named `{\tt main}',
as it is in the {\tt example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.

A lexical table consists of {\em lexical-table-entries}%
\emindex{lexical-table-entry} each containing an {\em atom-pattern} and
an {\em instruc\-tion-group}.  The \emkey{atom-pattern} is matched against
the remaining input characters.  The pattern consists of a sequence
of {\em quotable-characters}, each of which match only themselves,
and {\em character-pattern-names}, each of which match any character
in the named set of characters.  Thus
\begin{center}
\verb|"\\/0<hex-digit><hex-digit>/"|
\end{center}
matches 5-character atoms consisting of a \verb|\| followed by an
\verb|0| followed by two characters each in the character set
named by \verb|<hex-digit>| followed by a \verb|/|.
Note that each {\em atom-pattern}
only matches atoms of a particular length.


The special character pattern
{\tt \bf \LESSTHAN other\GREATERTHAN}%
\index{other@{\tt \LESSTHAN other\GREATERTHAN}}%
\label{<OTHER>}
can be used in an atom pattern to match any character not otherwise
matched.  More explicitly, in the atom pattern
\verb|"|$P$\verb|<other>|$Q$\verb|"|,
the prefix $P$\verb|<other>| matches any sequence of characters not matched by
any atom pattern of the form
\verb|"|$PCQ$\verb|"| in the same lexical table,
where $C$ is a character pattern other than
\verb|<other>|.
There are several examples of this on \pagref{EXAMPLE-LEXEME-PROGRAM}.

There must be no sequence of characters that matches the
{\em atom-patterns} of two distinct {\em lexical-table-entries}
in the same {\em atom} table.  Since {\em atom-patterns} can only
match atoms of a particular length, it is permissible for
a sequence of characters that matches one pattern to have a proper
initial segment that matches another pattern; in this case the
longer pattern takes precedence.  The order of {\em lexical-table-entries}
in a {\em lexical-table} is not significant.

The atom pattern \verb|""| which would recognize zero length atoms is
\underline{not} permitted, but the {\em default-instruction-group} at the
end of the lexical table executes in the equivalent case where no atom
pattern in the table matches the remaining input.  In particular
the {\em default-instruction-group} always executes if the input has reached
an end of file.  This fact is used in the `{\tt quoted string lexical table}'
on \pagref{EXAMPLE-LEXEME-PROGRAM}.

\subsubsection{Lexical Instructions}

A \emkey{lexical-table-entry} contains an
{\em atom-pattern} and an optional
\emkey{instruction-group} that consists of one or more {\em instructions}
separated by {\tt else}'s.  Most {\em instruction-groups} contain just
a single {\em instruction}, so we will explain this first.
{\em Instruction-groups} with more than one instruction are associated
{\tt translate} instruction components, which can fail, causing
the instruction containing them to become a no-operation and the
next instruction in the instruction group to be executed instead.

An \emmkey{instruction}{in lexical-table-entry} in an {\em lexical-table-entry}
specifies actions to be taken when an atom is recognized by the
{\em atom-pattern} of the entry.  The {\em instruction} consists of
a set of {\em instruction-components} each of which controls part of the
atom processing.

The {\em default-instruction-group} at the end of an lexical table behaves as
if a it was associated with the {\em atom-pattern} \verb|""|
that recognizes zero length atoms.  Note that actual {\em atom-patterns}
are not allowed to be \verb|""|.

The order of processing instruction components in an instruction is:
\begin{center}
{\tt accept} or {\tt keep} \\
{\tt translate}\\
{\tt require} \\
{\tt error} or {\tt output} \\
{\tt goto}, {\tt call}, {\tt return}, or {\tt fail} \\
\end{center}

\subsubsubsection{Accept and Keep Instruction Components}

The \ttmkey{accept}{in lexical program} {\em instruction-com\-po\-nent}
accepts the
atom without translation or length change, skips over the atom in the
input, and copies the atom characters to the translation buffer.
It is incompatible with the {\tt keep} and {\tt translate} instruction
components, but it is actually equivalent to `{\tt keep} $n$' where
$n$ is the length of the matched atom.

If none of {\tt accept}, {\tt keep}, or {\tt translate}
are given, {\tt accept} is implied.  If no {\em instruction-group}
is given in a {\em lexical-table-entry}, {\tt accept} is the implied
{\em instruction}.

The `\ttmkey{keep}{in lexical program} $n$'
{\em instruction-component} causes the atom length
to be shortened to $n$.  For example, the lexical table entry
\begin{center}
\verb|",<digit>" keep 1;|
\end{center}
will recognize a 1-character atom consisting of just a comma as long as
the comma is followed by character in the \verb|<digit>| character pattern
character set.  Atoms may not be lengthened by {\tt keep}.

\subsubsubsection{Translate Instruction Components}

There are four possible translate {\em in\-struc\-tion-com\-po\-nents}, at most
one of which may be used.  These affect how the atom is placed into
the translation buffer, and they may also fail, in which case the
{\em instruction} containing them becomes a no-operation and the next
{\em instruction} in the {\em instruction-group} (i.e., the {\em instruction}
after the `{\tt else}' following the failed {\em instruction}) is
executed.

In the absence of any of translate component,
the atom is copied `as-is' to the translation buffer.

The `{\tt translate to}', `{\tt translate hex}', and `{\tt translate oct}'
{\em instruction-components} are applied \underline{after}
any {\tt keep} is applied.
The other possible translate component invokes a translation table and
is described separately below.

A `\ttmkey{translate to}{in lexical program} {\em translation-string}'
{\em instruction-component}
specifies a {\em quoted-string} of characters,
the {\em translation-string},
that is copied into the translation buffer instead of the atom.
A {\em translation-string} may be empty, as in the lexical table entry
\begin{center}
\verb|"\"/" translate "" goto main;|
\end{center}
which can be used to recognize the last \verb|"| of a quoted string, avoid
copying anything into the translation buffer, and then switch to the
`{\tt main}' lexical table.
See the example on \pagref{EXAMPLE-LEXEME-PROGRAM}.

The `\ttmkey{translate hex}{in lexical program} $m$ $n$'
{\em instruction-component} ignores the
first $m$ and last $n$ characters of the atom and viewing the rest as
hexadecimal digits, converts these into an 32 bit unsigned integer
UNICODE character code, which is placed into the translation buffer
instead of the atom.  An example is the the lexical table entry
\begin{center}
\verb|"\\/0<hex-digit><hex-digit>/" translate hex 2 1;|
\end{center}
which might be used to accept a character representative in a quoted string
and copy the appropriate hexadecimally related character code into
the translation buffer.  It is a scanner error if characters that
are supposed to be hexadecimal digits are not (but in our example
this cannot happen because the definition of \verb|<hex-digit>|
restricts these characters appropriately).

The `\ttmkey{translate oct}{in lexical program} $m$ $n$'
{\em instruction-component} is identical but
views the rest of the characters as octal and not hexadecimal.
An example use would be the lexical table entry
\begin{center}
\verb|"\\/<oct-digit><oct-digit><oct-digit>" translate oct 2 0;|
\end{center}

The `\ttmkey{translate}{in lexical program} {\em translation-table-name}'
{\em instruction-component} invokes the named
\key{translation table}\label{TRANSLATION-TABLE}
to recognize an atom.  The previously matched atom is ignored, and
the translation table patterns are used to rematch the current atom,
provide a translation of the atom in the atom buffer, and determine
whether the containing {\em instruction} fails.

Translation tables match only a single atom and implicitly return
to their invoking instruction after matching one atom.  The
{\tt error}, {\tt output}, {\tt goto}, {\tt call}, and {\tt return}
{\em instruction-components} \underline{cannot} be used in a
translation table.  However, the {\tt fail} {\em instruction-component}
may only be used in a translation table, and when executed indicates
that the invoking {\em instruction} has failed.

{\tt accept}, {\tt keep}, {\tt require}, and
any of the {\tt translate} {\em instruction-components} can be used in
a translation table {\em instruction}.  A translation table
instruction may invoke another translation table, but recursion
is prohibited.
Note that if an instruction invokes a translation table and
the instruction does not fail,
the original atom match that caused the instruction
to be executed is discarded, but if the instruction fails, this
original atom match is reinstated (the instruction becomes a
no-operation) before the next {\em instruction} in the {\em instruction group}
executes.

Translation tables may have a {\em default-instruction-group}.

\subsubsubsection{Require Instruction Component}

The `\ttmkey{require}{in lexical program} {\em atom-pattern}'
{\em instruction-component} tests whether the atom in the
\underline{translation buffer} matches the given {\em atom-pattern},
and if \underline{no}, causes the {\em instruction} to fail.
A {\tt require} should only appear in an
{\em instruction} which is followed by an `{\tt else}' in an
{\em instruction-group}.

An example use would be the lexical table entry
\begin{indpar}
\verb|"\\/u<hex-digit><hex-digit><hex-digit><hex-digit>" translate hex 2 0| \\
\verb|    require "<letter>" else| \\
\verb|    translate "" error bad character in identifier;|
\end{indpar}
which might be used to process an atom of the form \verb|\uXXXX| in
an identifier, accepting the atom as a legitimate representation of a
character if that character is a letter, and otherwise designating
the atom as an error and not putting anything in the translation buffer
(see below for the definition of the `{\tt error}' instruction component).

A {\tt require} {\em instruction-component} is redundant unless
there is a {\tt translate hex}, {\tt translate oct}, or
`{\tt translate} {\em translation-table-name}' instruction component.

The last {\em instruction} in an {\em instruction-group} must
never fail, and so cannot contain a {\tt require} {\em instruction-component}.

\subsubsubsection{Error and Output Instruction Components}

A `\ttmkey{error}{in lexical program} {\em type}\,' {\em instruction-component}
announces the current atom as an erroneous atom of the given {\em type}.
The atom remains part of the current lexeme,
and what is put in the translation buffer is governed
independently by {\tt translate} instruction components.
The following are some examples:
\begin{indpar}\begin{verbatim}
"\\<other>" error bad escape sequence;
"\\<other>" translate "" error bad escape sequence;
"\\<other>" translate "\del/" error bad escape sequence;
\end{verbatim}\end{indpar}
These might be entries in an lexical table for a quoted string.
All identify an atom consisting of a backslash followed by any
character, as long as the atom is not recognized by another entry
that does not have the \verb|<other>| character pattern (see
\pagref{<OTHER>}).
The first entry copies the entire 2-character atom, including the
backslash, into the translation buffer.  The second entry copies
nothing (the empty string \verb|""|) into the translation buffer.
The third entry copies the DEL character (hex code \verb|7f|)
into the translation buffer.  An alternative is the entry
\begin{indpar}\begin{verbatim}
"\\<other>" keep 1 error bad escape;
\end{verbatim}\end{indpar}
that reduces the atom size to 1 character, just the backslash,
which is announced as an error without its following character,
and copied to the translation buffer.  The character following
the backslash remains in the input and will part of the next
atom recognized.

The routine that announces an error atom is given the position
of the atom in the input stream, so characters surrounding the
atom may also be included in the announcement.  For example,
the line containing the atom may be printed with marks on the
characters of the atom.  So the fact that the erroneous atom
proper in the last example is just the backslash does not
prevent the character after the backslash from being included
in the error announcement.

An erroneous atom is different from an erroneous lexeme.
An erroneous lexeme is simply a lexeme whose {\em type}
indicates to the user of the lexical scanner that the lexeme is erroneous.
As such an erroneous lexeme is
handled by the lexical scanner just as any other lexeme would be:
i.e., the lexical scanner has no special knowledge of erroneous lexemes
and no special operations for detecting or announcing them.

A `\ttmkey{output}{in lexical program} {\em type}\,'
{\em instruction-component} emits the current lexeme
with the given {\em type}.  This
{\em instruction-component} may only be used if the next
current lexical table is a master table.

The {\tt output} {\em instruction-component}
works even if the current lexeme is of zero length,
and may be used in the {\em default-instruction-group} of an lexical table;
for example, at the top of \pagref{EXAMPLE-LEXEME-PROGRAM} the
{\tt master} lexical table has `{\tt output end of file;}' as its
{\em default-instruction-group}, thereby outputting a zero length
lexeme with `{\tt end of file}' type whenever the input is at the
end of file.

As an example, the `{\tt main}' master table at the top of
\pagref{EXAMPLE-LEXEME-PROGRAM} contains the entry:
\begin{indpar}\begin{verbatim}
"<other>" output bad character;
\end{verbatim}\end{indpar}
which causes an unrecognized character to be treated as a 1-character
lexeme of type `{\tt bad character}'.  The translation of this lexeme is
the character itself, but if the entry:
\begin{indpar}\begin{verbatim}
"<other>" translate "\del/" output bad character;
\end{verbatim}\end{indpar}
had been used instead the translation would have been the DEL character.

Whenever the current lexical table is changed from a lexeme table
to a master table, if no {\tt output} {\em instruction-component}
is present in the {\em instruction} that made the change, and if
the current lexeme is not of zero length, then
an implicit {\tt output} is executed with the name of the lexeme
table as its type.

\subsubsubsection{Goto, Call, Return, and Fail Instruction Components}

A `\ttmkey{goto}{in lexical program} {\em lexical-table-name}\,'
{\em instruction-component} switches the current lexical table after
the current atom is processed.  If the table switches from a lexeme table
to a master table,
if the instruction contains no `{\tt output}' component,
and if the current lexeme is of non-zero length, then the current
lexeme is output with the {\em type} of the lexeme table.

A `\ttmkey{call}{in lexical program} {\em lexeme-table-name}\,'
{\em instruction-component} is just like `{\tt goto}' except
that it also pushes the identifier of the lexical table in which
the `{\tt call}' occurs (the `caller') into the return stack.
The \key{return stack} is a stack of up to 64 lexical table identifiers
used by the `{\tt call}' and `{\tt return}' instruction components
and also by the `{\tt translate} {\em translation-table-name}'
instruction components.  Recursive calls are prohibited.

A `\ttmkey{return}{in lexical program}'
{\em instruction-component} is just like `{\tt goto}' except
that uses the lexical table identifier at the top of the return
stack to determine the next lexical table.  This identifier is
also popped from the stack.

The return stack is emptied whenever the current lexical table
becomes a master mode table.  A {\tt call} \underline{cannot} be used
to call a master or translation table.  A {\tt return} can only
appear in a lexeme table.

The `{\tt call}' and `{\tt return}' instruction components
permit a lexeme table to be shared among different
master and lexeme tables.  For example, a lexeme table to scan
a comment lexeme may be shared among several master tables;
see Appendix \itemref{C++-LEXICAL-PROGRAM} for examples.

The `{\tt call}' and `{\tt return}' instruction components
add nothing new to the lexical scanning language, since they
cannot be used recursively,
and they can always be eliminated by making
copies of the called tables with hard coded returns.
But for certain languages these instruction components
substantially reduce the size of the lexical program.

A `\ttmkey{fail}{in lexical program}'
{\em instruction-component} can only be used in a translation
table and causes the instruction invoking the translation table to fail.
The `{\tt goto}', `{\tt call}', and `{\tt return}' instruction components
\underline{cannot} be used in a translation table.

\section{Parsing}

The parser is a sequence of passes each of which takes an input
stream and produces and output stream.  The components of the
streams can be lexemes, subexpressions, or expression components
such as numbers, operators, and punctuation.  For better
modularity all stream components are called \skey{token}s,
and the data is organized as streams of tokens.

\subsection{Token Streams}

A token can have any of the following components.

\begin{indpar}
\begin{tabular}{p{1in}p{4in}}
\tt kind	& One of: \\
        	& ~~~~{\tt lexeme} \\
        	& ~~~~{\tt name} \\
        	& ~~~~{\tt expression}
\\[1ex]
		& A {\tt name} is a symbol such as `{\tt x}'
		  or `{\tt +}', or a natural number, or a
		  list of names (called a label).
\\[1ex]
		& An {\tt expression} is a list of names and
		  expressions and in addition a map from names
		  to values that are names or expressions.
\\[1ex]
\tt type	& For lexemes, the type of the lexeme. \\[0.3ex]
		& For names, one of: \\
		& ~~~~{\tt symbol} \\
		& ~~~~{\tt natural\_number} \\
		& ~~~~{\tt label} \\
\end{tabular} \\[1ex]
\begin{tabular}{p{1in}p{4in}}
\tt string	& For lexemes, the character string of the lexeme.
\\[1ex]
\tt ident	& For names and expressions,
                  a 32 or 64 bit numeric or pointer
		  value that denotes the name or expression.
		  Two names are different if and only if they
		  have different idents, so
		  names can be compared by comparing their idents.
		  No name can have the same ident as an expression.
\\[1ex]
		& It is possible to recover from the ident of
		  a name the character string of a symbol, the value of
		  a natural number, or the name list of a label.
		  It is possible to recover from the ident of
		  an expression the list elements and the name/value map
		  of the expression.
		  But these things are rarely done by the parser.
\\[1ex]
\tt hash	& A 32 bit unsigned integer that is a randomized hash of
          	  the character string of a symbol, a hash of the value of a
		  natural number, or a hash of the names of a label.  Usable to
		  make hash tables in which names are keys.
\end{tabular} \\[1ex]
\begin{tabular}{p{1in}p{4in}}
\tt positions	& The positions of the first and last character of the
	          token in the input text.  It is possible to recover
		  from a position the column number within a line
		  and a line ident, where two line idents are equal
		  if and only if the file lines they denote are the same.
		  A printed representation of a line ident may also
		  be obtained for error messages.
\end{tabular}
\end{indpar}

Tokens of `name' kind are called \skey{name token}s, or
just plain `names'.
Tokens of `expression' kind are called \skey{subexpression token}s, or
just plain `subexpressions'.  The parser passes may take a sequence of tokens
and replace it by a name or subexpression token, but once this is done,
the parser passes never break the name or subexpression tokens apart to
look at their components.  Name and subexpression tokens may be be broken
apart in error messages, however.

\subsection{Token Streams}

Tokens are organized into bidirectional \skey{token list}s and
into `\skey{token stream}s' that are segments of token lists.

Tokens are linked together bidirectionally into token lists.  It is
actually possible to design a parser that is a set of passes all of
which put tokens in the same token list.

A token stream has the following components:

\begin{indpar}
\begin{tabular}{p{1in}p{4in}}
\tt first	& Pointer at the first token in the stream.
\\[1ex]
\tt last	& Pointer at the current last token in the stream.
\\[1ex]
\tt eos		& True if the last token is really the last token
		  of the stream, and false if there may be more
		  tokens.
\\[1ex]
\tt get		& Function to call to get more tokens and add them
		  to the end of the stream, if {\tt eos} is false.
		  A parser pass provides this function to users of
		  streams the pass produces, and much of the execution
		  of the parser pass actually occurs inside this function.
\end{tabular}
\end{indpar}

At any given time a token must be in exactly one token stream.

All the tokens in one token stream are in the same token list.

A parser pass receives a stream as input produces a stream as output.
If the parser pass decides to use its input stream token list as its
output stream token list, it may move tokens from input to output
by merely adjusting the `{\tt first}' and `{\tt last}' components
of the streams.

Because streams are highly tailored by the parser passes that produce
them, the token stream class is an abstract base class ith the `{\tt get}'
function as a virtual function.

\subsection{Parser Passes}

A \key{parser pass} is a function that takes as input a stream (i.e., a
sequence) of tokens and produces as output a stream of tokens.
Parser passes call other parser passes to process streams of tokens.

The LL standard parser passes are:

\begin{indpar}
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
operator & Parses expressions with computational operators (e.g., \verb|+| and
\verb|*|).
\\[1ex]
text & Parses text expressions containing named brackets
and \verb|<>| operators (e.g.
\verb/<b|/\ldots\verb/|b>/ and \verb/<p>/).
\end{tabular} \\
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
explicit subexpression & Identifies explicitly bracketed subexpressions.
\\[1ex]
lexeme replacement & Replaces sequences of lexemes with other
sequences of lexemes (e.g., replaces plurals by singulars).
\end{tabular} \\
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
radix number recognition & Recognizes numbers with non-decimal radixes.
\\[1ex]
scientific number recognition & Recognizes numbers with exponents.
\\[1ex]
number pair recognition & Recognizes pairs of numbers (e.g., \verb|4 1/2|).
\end{tabular} \\
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
number unit grouping & Groups numbers and numeric units
(e.g., \verb|4ft 5in|).
\\[1ex]
\begin{tabular}[t]{@{}l@{}}
unit multiplication \\
insertion 
\end{tabular} & Inserts multipliers between numbers and
numeric units (e.g., \verb|4*ft| and \verb|$*4.99|).
\end{tabular}
\end{indpar}


A parser pass can call another parser pass.  For example,
the explicit subexpression parser recursively calls itself when
it recognizes an explicit subexpression beginning bracket.

The input and output of a parser pass is a stream of tokens.
When a parser pass P1 calls another parser pass P2, P1 provides the P2
with an input stream that holds tokens at the beginning
of the stream and provides a `{\tt get}' function that can be called by P2
to add tokens to the end of its input stream.  This `{\tt get}' function
is actually a continuation function for pass P1.

\subsection{Parser Symbol Table}

The \key{parser symbol table} is conceptually a stack of
\skey{parser definition}s.  Each parser definition has the following
components:

\begin{indpar}
\begin{tabular}{p{1in}p{4in}}
\tt key		& A sequence of names that identifies the definition.
\\[1ex]
\tt type	& The type of the definition.
\\[1ex]
\tt selectors	& A set of \skey{parsing selector}s that determine if
		  the definition is active.
\\[1ex]
\tt next	& Pointer to the next definition in the stack that
                  has the same key.
\end{tabular}
\end{indpar}

Tokens that are lexemes are converted to names if possible before the
first parser pass.  To use definitions, in most cases
a parser pass simply takes the sequence of name tokens
beginning at the current point the pass's input token stream
and looks it up in the symbol table.  The parser pass also has
at any given time a selector set, and it checks a definition to
see if the parser pass and the definition share a selector.  If yes,
the definition is used by the pass, and is said to be
\mkey{active}{definition}.
If no, the definition is said to be \mkey{inactive}{definition},
and the next definition
in the definition stack with the same key is examined.

If there are several sequences of name tokens that match active definitions
at the current point in the token stream, the longest is used.  If the
token at the current point in the token stream is not a name, then
\underline{no} definition can be referenced.

A hash table is maintained to permit passes to quickly look up
parsing definitions given the named tokens at the pass's current
token stream position.

A Parser pass also generally ignores definitions that are not of
a type appropriate to the pass.
Some parser passes do not use the current tokens as a key to look up in
the symbol table, but look up all definitions of a particular type.
An example is the lexeme replacement pass, that uses lexeme
replacement definitions, which
provide their own
mechanisms for determining whether or not the tokens beginning
at the current token stream position should be replaced.
For efficiency this pass
keeps a separate hash table that memoizes the results
for tokens that have been recently seen.  One consequence of this is
that making changes to lexeme replacement definitions is less efficient
than making changes to other kinds of definitions.

\newpage

\appendix

\section{Standard Lexical Program}
\label{STANDARD-LEXICAL-PROGRAM}

\begin{indpar}
\begin{verbatim}
begin standard lexical program;

"<ascii-letter>" = "a-z" | "A-Z";
"<digit>" = "0-9";
"<oct-digit>" = "0-7";
"<hex-digit>" = "0-9" | "a-f" | "A-F";

"<non-digit>" = ~ "<digit>";

// The following list of language specific letters is taken
// from Annex E of the Working Paper for Draft Proposed
// International Standard for Information Systems—Programming
// Language C++, 1996.

"<latin-letter>" = "\00c0/-\00d6/" | "\00d8/-\00f6/"
                 | "\00f8/-\01f5/" | "\01fa/-\0217/"
                 | "\0250/-\02a8/" | "\01ea0/-\01ef9/";

. . . . . letter character pattern definitions omitted . . . . .

"<CJK-letter>" = "\0f900/-\0fa2d/" | . . .  // Details omitted

// Context sensitive character classifications, e.g.,
// classifying ' as a word character if it is followed by
// a letter, cannot be included in character pattern
// definitions, but are noted in comments.  They are
// accounted for by separate lexeme table entries below.

"<letter>" = "<ascii-letter>" | "<latin-letter>"
           | . . . | "<CJK-letter>";   // Details omitted

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@" | "#" | "$" | "%"
              | "^" | "&" | "=" | "|" | "<" | ">" | "_" | "!"
              | "?" | ":";
              //
              // Also . not followed by a digit
              //      / not surrounded by digits

"<non-slash-char>" = ~ "/";

"<separator-char>" = "(" | ")" | "[" | "]" | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter

"<line-break-char>" = "\lf/" | "\vt/" | "\ff/" | "\cr/";

"<non-line-break-char>" = ~ "<line-break-character>";

"<horizontal-space-char>" = " " | "\ht/";

begin main master table;

   // Whitespace is separated out into 3 types of lexeme:
   //
   //   `horizontal space'  spaces and horizontal tabs
   //   `line break'        linefeeds, carriage returns,
   //                       form feeds, and vertical
   //                       tabs
   //   `comments'          `//' up to just before next
   //                       line break
   //
   "//" call comment;
   "<horizontal-space-char>" call horizontal space;
   "<line-break-char>" call line break;

   "<letter>" call word;
   "'<letter>" call word;
    "\\/" translate escaped character
          require "<letter>" call word
          else translate bad escape sequence
	       output unrecognized escape sequence
          else output unrecognized escape character;

   "<mark-char>" call mark;
   "." call mark;  // ".<non-digit>"
   "/" call mark;  // "/<non-slash-char>"

   // We assume that the preceding text is not a digit
   // or the current input is not / or , followed by a digit.
   //
   "<digit>" keep 0 call natural number;
   ".<digit>" keep 1 call number;

   "<separator-char>" output separator;
   "," output separator;	// "<non-digit>,"
   "'" output separator;        // "'<non-letter>"

   "\"/" translate "" call quoted string;

   "<other>" output unrecognized character;
   output end of file;

end main master table;


// The below tables are entered from the master table
// with the first one or two characters scanned.


begin comment lexeme table;
   "<non-line-break-char>" accept;
   return;
end comment lexeme table;


begin horizontal space lexeme table;
   "<horizontal-space-char>" accept;
   return;
end horizontal space lexeme table;


begin line break lexeme table;
   "<line-break-char>" accept;
   return;
end line break lexeme table;


begin word lexeme table;

   "<letter>" accept;
   "'<letter>" accept;
    "\\/" translate escaped character
          require "<letter>"
          else keep 0 return;
   return;

end word lexeme table;

begin mark lexeme table;
   "<mark-char>" accept;
   ".<non-digit>" keep 1;
   "/<non-slash-char>" keep 1;
   return;
end mark lexeme table;

begin natural number lexeme table;
   "<digit>" accept;
   ".<digit>" keep 1 goto number;
   "<digit>/<digit>" keep 2 goto number;
   "<digit>,<digit>" keep 2 goto number;
   return;
end natural number lexeme table;

begin number lexeme table;

   // In order to recognize , and / surrounded by digits
   // as number atoms, entries to this table upon
   // recognizing "X<digit>" must do a `keep 1' so the
   // digit will be left to be recognized by
   // <digit>/<digit> or <digit>,<digit>.

   // Alternatively we could have a separate table
   // for the state where the last atom ended with
   // a digit.

   "<digit>" accept;
   ".<digit>" keep 1;
   "<digit>/<digit>" keep 2;
   "<digit>,<digit>" keep 2;
   return;

end number lexeme table;


begin quoted string lexeme table;

    "\"/" translate "" return;   // End quoted string.

    "\\/" translate escaped character
          else translate bad escape sequence
	       error unrecognized escape sequence
          else error unrecognized character;

    "<line-break-char>"
        goto bad end of line;

    "<other>" accept;

    goto bad end of file;

end quoted string lexeme table;

begin escaped character translation table;

    "\\/\"/" translate "\"/";
    "\\/\lf/" translate "\lf/";
    "\\/\cr/" translate "\cr/";
    "\\/\ht/" translate "\ht/";
    "\\/\bs/" translate "\bs/";
    "\\/\ff/" translate "\ff/";
    "\\/\vt/" translate "\vt/";
    "\\/\\//" translate "\\/";
    "\\/~"  translate " " ;
    "\\/0/" translate "\0/";
    "\\/0<hex-digit>/"
              translate hex 2 1;
    "\\/0<hex-digit><hex-digit>/"
              translate hex 2 1;
    "\\/0<hex-digit><hex-digit><hex-digit>/"
              translate hex 2 1;
    "\\/0<hex-digit><hex-digit><hex-digit><hex-digit>/"
              translate hex 2 1;
    "\\/0<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit>/"
              translate hex 2 1;
    "\\/0<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit><hex-digit>/"
              translate hex 2 1;
    "\\/0<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit><hex-digit><hex-digit>/"
              translate hex 2 1;
    "\\/0<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit><hex-digit><hex-digit><hex-digit>/"
              translate hex 2 1;
    fail;
end escaped character translation table;

"<escaped-char>" = ~ "/" & ~ "<line-break-char>";

begin bad escape sequence translation table;

    "\\//";
    "\\/<escaped-char>/";
    "\\/<escaped-char><escaped-char>/";
    "\\/<escaped-char><escaped-char>"
       "<escaped-char>/";
    "\\/<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>/";
    "\\/<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char>/";
    "\\/<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>/";
    "\\/<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char>/";
    "\\/<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>/";
    "\\/<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char>/";
    "\\/<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>"
       "<escaped-char><escaped-char>/";
    fail;
end bad escape sequence translation table;

begin bad end of line master table;
    output bad end of line goto main;
end bad end of line master table;


begin bad end of file master table;
    output bad end of file goto main;
end bad end of file master table;


end standard lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{C++ Lexical Program}
\label{C++-LEXICAL-PROGRAM}

\begin{indpar}\begin{verbatim}
begin c++ lexical program;

// Before this lexical program is used the input should
// be preprocessed to
//
//    (1) Replace trigraph sequences.
//    (2) Replace any source file character that is not
//        one of the 96 `source characters' by a univer-
//        sal character name (\uXXXX or \UXXXXXXXX).
//    (3) Eliminate carriage returns next to newlines.
//    (4) Eliminate backslash newline pairs.
//
// After this lexical program is used the output should
// be post-processed to
//
//    (5) Perform C/C++ macro preprocessing (macro
//        expansion.
//    (6) Concatenate adjacent ordinary quoted strings
//        and adjacent wide quoted strings.

"<digit>" = "0-9";
"<oct-digit>" = "0-7";
"<hex-digit>" = "0-9" | "a-f" | "A-F";
"<non-digit>" = "_" | "a-z" | "A-Z";
    // I.e., in identifier.

"<ascii-letter>" = "a-z" | "A-Z";

"<space-char>" = " " | "\t" | "\v" | "\f";

"<source-char>" =
    ( "\0020/-\007e/" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";

"<sign>" = "+" | "-" ;

// The following can begin an operator, a separator,
// or either.
//
"<op-char>" = "#" | "<" | ">" | ":" | "%" |
            | "." | "?" | "+" | "-" | "*" | "/"
	    | "^" | "&" | "|" | "~" | "!" | ","
            | "(" | ")" | "[" | "]" | "{" | "}"
	    | ";";

// The following list of language specific letters is
// taken from Annex E of the Working Paper for Draft
// Proposed International Standard for Information
// Systems—Programming Language C++, 1996.

"<latin-letter>" = "\00c0/-\00d6/" | "\00d8/-\00f6/"
                 | "\00f8/-\01f5/" | "\01fa/-\0217/"
                 | "\0250/-\02a8/" | "\01ea0/-\01ef9/";

. . . letter character pattern definitions omitted . . .

"<CJK-letter>" = "\0f900/-\0fa2d/" | . . .
    // Details omitted

"<letter>" = "<ascii-letter>" | "<latin-letter>"
           | . . . | "<CJK-letter>";
    // Details omitted

// Alternative operators that are not identifiers are
// translated.  E.g., <: becomes [ in the translation
// buffer.

// C/C++ preprocessing is hereafter abbreviated as `pp'.
//
// Because of pp control lines, lexical scanning is
// slightly context dependent.  There are several
// contexts, each corresponding to a different master
// table:
//
//    initial master
//        Used in line beginning situations to recognize
//        the # token that introduces a pp control line.
//    pp beginning master
//        Used to scan the beginning of a pp control
//        line after the # has been scanned but before
//	  anything else is scanned.
//    pp include master
//        Used to scan tokens in a #include line after
//	  #include has been scanned.  Recognizes
//	  `header' pp-tokens.
//    normal master
//        Used to scan a non pp control line or the rest
//        of a non-#include pp control line.
//
// The whitespace lexeme types are:
//
//    line feed (lexeme is "\lf/")
//    horizontal space
//    "/*" comment (include /* and */)
//    "//" comment (does not include ending line feed)
//    end of file (lexeme is "")
//    premature line feed (lexeme is "\lf/")
//    premature end of file (lexeme is "")
//
// This allows line feeds to be used to end pp control
// lines.  The `premature' lexemes are errors: the
// previous lexeme is treated as if there were no error
// (i.e., as if there were a ", ', */, etc.) and the
// next lexeme is a `premature ...' lexeme.
//
// Characters that are not part of any C++ lexeme and
// universal characters that are not part of any C++
// lexeme are made into 1-character lexemes of the types:
//
//    unrecognized character
//    unrecognized universal character
//
// The character in question is the translation of these
// lexemes.

begin initial master table;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "##" output operator goto normal;
    "%:%:" translate "##" output operator goto normal;
    "#" output punctuation goto pp beginning;
    "%:" translate "#" output punctuation goto pp beginning;
    goto normal;
end initial master table;

begin horizontal space lexeme table;
    "<horizontal-space-char>" accept;
    return;
end horizontal space lexeme table;

begin "/*" comment lexeme table;
    "*/" return;
    "<other>" accept;
    goto premature end of file;
end "/*" comment lexeme table;

begin "//" comment lexeme table;
    "\lf/" keep 0 return;
    "<other>" accept;
    goto premature end of file;
end "//" comment lexeme table;

begin premature end of file master table;
    output premature end of file goto initial;
end premature end of file master table;

begin premature end of line master table;
    "\lf/" output premature newline goto initial;
end premature end of line master table;

begin pp beginning master table;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "include<non-digit>" keep 0 goto normal;
    "include" output identifier goto pp include;
    goto normal;
end pp beginning master table;

"<op-char-except-<>" = "<op-char>" & ~ "<";

begin pp include master table;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "//" call "//" comment;

    "<" translate "" call bracketed header name;
    "\"/" translate "" call quoted header name;

    "<non-digit>" call identifier;
    "\\/" translate escaped letter call identifier
          else translate universal character
	       output unrecognized universal character
          else output unrecognized character;

    "<digit>" call integer;
    ".<digit>" call fraction;

    "'" translate "" call character literal;
    "L'" translate "" call wide character literal;
    "\"/" translate "" call string literal;
    "L\"/" translate "" call wide string literal;

    "<op-char-except-<>" translate operator
    			 output operator
          else output unrecognized character;

    "\lf/" output line feed goto initial;
    "<other>" output unrecognized character goto initial;
    output end of file goto initial;
pp end include master table;

begin bracketed header name lexeme table;
    ">" translate "" goto normal;
    "\lf/" keep 0 goto premature end of line;
    "<other>" accept;
    goto premature end of file;
end bracketed header name lexeme table;

// Quoted header names are not the same as quoted
// strings, and cannot have escape sequences.
//
begin quoted header name lexeme table;
    "\"/" translate "" goto normal;
    "\lf/" keep 0 goto premature end of line;
    "<other>" accept;
    goto premature end of file;
end quoted header name lexeme table;

begin normal master table;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "//" call "//" comment;

    "<non-digit>" call identifier;
    "\\/<u-or-U>" translate escaped character
                  require "<letter>" call identifier
                  else translate escaped character
	               output unrecognized universal character
                  else output unrecognized character;

    "<digit>" call integer;
    ".<digit>" call fraction;

    "'" translate "" call character literal;
    "L'" translate "" call wide character literal;
    "\"/" translate "" call string literal;
    "L\"/" translate "" call wide string literal;

    "<op-char>" translate operator output operator
                else output unrecognized character;

    "\lf/" output line feed goto initial;
    "<other>" output unrecognized character goto initial;
    output end of file goto initial;
end normal master table;

begin operator translation table;
    "(";
    ")";
    "[";
    "]";
    "{";
    "}";
    "#";
    "##";
    "<:";
    ":>";
    "<%";
    "%>";
    "%:";
    "%:%:";
    ";";
    ":";
    "...";
    "?";
    "::";
    ".";
    ".*";
    "+";
    "-";
    "*";
    "/";
    "%";
    "^";
    "&";
    "|";
    "~";
    "!";
    "=";
    "<";
    ">";
    "+=";
    "-=";
    // etc.

    fail;
end operator translation table;


"<u-or-U>" = "u" | "U";

begin identifier lexeme table;
    "<non-digit>" accept;
    "\\/<u-or-U>" translate escaped character
                  require "<letter>"
                  else keep 0 return;
    goto normal;
end identifier lexeme table;

"<non-digit-except-lLuU> =
    <non-digit> & ~ "l" & ~ "u" & ~ "L" & ~ "U";

begin integer lexeme table;
    "<digit>" accept;
    "." goto fraction;
    "e<sign><digit>" goto exponent;
    "E<sign>"<digit> goto exponent;
    "ul" goto done integer;
    "uL" goto done integer;
    "Ul" goto done integer;
    "UL" goto done integer;
    "lu" goto done integer;
    "lU" goto done integer;
    "Lu" goto done integer;
    "LU" goto done integer;
    "u"  goto done integer;
    "U"  goto done integer;
    "l"  goto done integer;
    "L"  goto done integer;
    "e<sign>" goto pp number;
    "E<sign>" goto pp number;
    "<non-digit-except-lLuU>" goto pp number;
    output integer return;
end integer lexeme table;

begin done integer lexeme table;
    "<digit>" goto pp number;
    "e<sign>" goto pp number;
    "E<sign>" goto pp number;
    "<non-digit>" goto pp number;
    "." goto pp number;
    output integer return;
end done integer lexeme table;

"<non-digit-except-lLfF> =
    <non-digit> & ~ "l" & ~ "f" & ~ "L" & ~ "F";

begin fraction lexeme table;
    "<digit>" accept;
    "." goto pp number;
    "e<sign><digit>" goto exponent;
    "E<sign>"<digit> goto exponent;
    "f"  goto done floating point;
    "F"  goto done floating point;
    "l"  goto done floating point;
    "L"  goto done floating point;
    "e<sign><digit>" goto exponent;
    "E<sign><digit>" goto exponent;
    "e<sign>" goto pp number;
    "E<sign>" goto pp number;
    "<non-digit-except-lLfF>" goto pp number;
    output floating point return;
end fraction lexeme table;

begin exponent lexeme table;
    "<digit>" accept;
    "." goto pp number;
    "f"  goto done floating point;
    "F"  goto done floating point;
    "l"  goto done floating point;
    "L"  goto done floating point;
    "e<sign>" goto pp number;
    "E<sign>" goto pp number;
    "<non-digit-except-lLfF>" goto pp number;
    output floating point return;
end exponent lexeme table;

begin floating point done lexeme table;
    "<digit>" goto pp number;
    "e<sign>" goto pp number;
    "E<sign>" goto pp number;
    "<non-digit>" goto pp number;
    "." goto pp number;
    output floating point return;
end floating point done lexeme table;

begin pp number lexeme table;
    "<digit>" goto pp number;
    "e<sign>" goto pp number;
    "E<sign>" goto pp number;
    "<non-digit>" goto pp number;
    "." goto pp number;
    output pp number return;
end pp number lexeme table;

"<character-literal-char>" =
    "<source-char>" & ~ "'" & ~ "\\/" & ~ "\lf/";

begin character literal lexeme table;
    "'" translate "" goto normal;
    "\lf/" keep 0 goto premature end of line;
    "\\/" translate escaped character
          else error bad escape character;
    "<character-literal-char>" accept;
    "<other>" error bad character literal character;
    goto premature end of file;
end character literal lexeme table;

begin wide character literal lexeme table;
    "'" translate "" goto normal;
    "\lf/" keep 0 goto premature end of line;
    "\\/" translate escaped character
          else error bad escape character;
    "<character-literal-char>" accept;
    "<other>" error bad character literal character;
    goto premature end of file;
end wide character literal lexeme table;

"<string-literal-char>" =
    "<source-char>" & ~ "\"/" & ~ "\\/" & ~ "\lf/";

begin string literal lexeme table;
    "\"/" translate "" goto normal;
    "\lf/" keep 0 goto premature end of line;
    "\\/" translate escaped character
          else error bad escape character;
    "<string-literal-char>" accept;
    "<other>" error bad character literal character;
    goto premature end of file;
end string literal lexeme table;

begin wide string literal lexeme table;
    "\"/" translate "" goto normal line master;
    "\lf/" keep 0 goto premature end of line master;
    "\\/" translate escaped character
          else error bad escape character;
    "<string-literal-char>" accept;
    "<other>" error bad character literal character;
    goto premature end of file;
end wide string literal lexeme table;

// This translation table is used when the next atom
// begins with \ and is in a character or string
// literal.
//
// We allow only a maximum of 8 hexadecimal digits
// after \x; 9 digits is an error.  The C++ standard
// permits any number of hexadecimal digits.
//
begin escaped character translation table;
    "\\/n" translate "\lf/";
    "\\/t" translate "\ht/";
    "\\/v" translate "\vt/";
    "\\/b" translate "\bs/";
    "\\/r" translate "\cr/";
    "\\/f" translate "\ff/";
    "\\/a" translate "\bel/";
    "\\/\\/" translate "\\/";
    "\\/?" translate "?";
    "\\/\"/" translate "\"/";
    "\\/'" translate "'";
    "\\/<oct-digit>"
        translate-oct 1 0;
    "\\/<oct-digit><oct-digit>"
        translate-oct 1 0;
    "\\/<oct-digit><oct-digit><oct-digit>"
        translate-oct 1 0;
    "\\/x<hex-digit>"
        translate-hex 2 0;
    "\\/x<hex-digit><hex-digit>"
        translate-hex 2 0;
    "\\/x<hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0;
    "\\/x<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0;
    "\\/x<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit>"
        translate-hex 2 0;
    "\\/x<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit><hex-digit>"
        translate-hex 2 0;
    "\\/x<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0;
    "\\/x<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0;
    "\\/x<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit>" fail;
    "\\/u<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0;
    "\\/U<hex-digit><hex-digit><hex-digit><hex-digit>"
        "<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0;
    fail;
end escaped character translation table;

end c++ lexical program;
\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
