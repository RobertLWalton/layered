% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}
\usepackage{listings}
\lstset{
    basicstyle=\ttfamily
}
% \usepackage{pictex} (obsolete? not available under CentOS 7)
\usepackage{upquote} % (imported to local directory
                     % ; not available under CentOS 7)
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.
\usepackage{enumitem}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

\newcommand{\RULE}[2]{\item[#1]\newcommand{#2}{#1}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\RESERVE}[1][0.3in]%
    {\par\rule[-#1]{0in}{#1}\vspace*{-#1}\vspace*{-\parsep}\par}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@\TT{#1}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@\TT{#2}}}
\newcommand{\ttimkey}[3]{\TT{#1}\index{#2@\TT{#1}!#3}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@\TT{#1}!#2@\TT{#2}}}
\newcommand{\ttilkey}[3]{\TT{#1}\index{#2@\TT{#2}!#3@\TT{#3}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@\TT{#1}!#2}}
\newcommand{\ttmlkey}[3]{\TT{#1 #2}\index{#1@\TT{#1}!#2@\TT{#2}!#3}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@\TT{.#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@\TT{.#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@\TT{[#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@\TT{[#1]}!#2}}

\newcommand{\ttsvkey}[1]{\TT{[\$~#1~\$]}\index{#1@\TT{[\$~#1~\$]}}}
\newcommand{\ttsvmkey}[2]{\TT{[\$~#1~\$]}\index{#1@\TT{[\$~#1~\$]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@\TT{<#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@\TT{<#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@\TT{#1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@\TT{#1}}}
\newcommand{\ttmindex}[2]{\index{#1@\TT{#1}!#2}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minlkey}[2]%
           {\TT{min::#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                          \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Layered Programming Languages \\[0.5ex]
(Draft 1)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

January 20, 2022
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Motivation}

The layered languages are ideally a set of compatible computer languages.
Some guiding principals are:

\begin{indpar}
\key{Syntax Hypothesis}~~~~ People reason syntactically
rather than semantically, so language syntax is very important,
and the ability to extend syntax to support
new library functionality is very important.

\key{Distributed Modularity}~~~~ 
Enhancements made by non-communicating users should fit together
without too much labor.\footnote{Solutions like using regular
expressions for lexical analysis and LL parsers do not appear to
meet this criteria.}
\end{indpar}

Another idea, from which the term `Layered' originally derives,
is to create a compatible set of three programming languages,
low level, middle level, and high level, based on the principals:

\key{Type Checking Segregation Hypothesis}~~~~ A strongly typed-checked
general-purpose computer-efficient language is impossible.
What is possible is
to segregate code non-type-checkable code into small inline library functions
with code that uses these functions being
strongly type-checked.

\key{Interpreted Language Efficiency Hypothesis}~~~~ An interpreted
programming language is more efficient for the programmer than a
compiled language, perhaps because of quicker testing turnaround and 
more capable logging features.  The majority of code in a typical
computer system can be written in a interpretive language if it is
integrated with a compiled language.

So given this the low level language would segregate code into
small inline library functions that are not type-checkable, while
code that uses these functions would be type-checked.  The middle
level language would add an extensive library to this low level
language and integrate parts of this library into the syntax.
The high level language would add an interpretive language
integrated with the middle level language.

However there are other agendas for the layered languages.  One
is to build an interpretive language that integrates the tools
a non-professional programmer might used in daily life.  This
means integrating a classic programming language with a text
processing language, a spreadsheet-like language, a mathematics
language, etc.

Given all this, this manual describes the lexical scanner,
parser, symbol table, etc. shared by the various `\skey{layered language}s'.


\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `\TT{hello}', `\TT{+}', `\TT{;}',
`\TT{9.200}' are four lexemes.

The lexical scanner is written in the M-Language and can be
replaced.\footnote{Currently the scanner is actually written
in C++.}  This section describes the standard scanner which
is driven by the lexical tables and is capable of scanning
lexemes of common languages such as C and C++.

The standard scanner attempts to be both machine and human
efficient.  It attempts to be \key{machine efficient} by being
deterministic\footnote{Unlike regular expression scanners.}
and attempts to be \key{human efficient} by supporting algorithms
that people can readily understand and hopefully quickly
learn to mimic.\footnote{A possibly non-verifiable goal.}

The standard scanner also tries to promote `\key{distributed modularity}',
meaning that enhancements made by non-communicating users are
more likely to fit together.\footnote{Regular expression grammars seem
too unruly to meet this criterion.}

The standard scanner operates on an input stream of 32-bit
UNICODE characters.  Each character is associated with
a \mkey{position}{of character}\label{POSITION-OF-CHARACTER}
that specifies the location of the
character within its file.  Specifically, a position encodes
a line-within-file number and byte-within-line offset.
The standard scanner identifies a lexeme as a consecutive sequence
of input stream UNICODE 32-bit characters with
corresponding consecutive position values.

The \mkey{line number}{of input character} of a character is 1 plus the
number of {\em line-feeds} preceding the character.
The \mkey{byte offset}{of input character} of a character is the number
of bytes before the character but after the first {\em line-feed}
preceding the character, or after the beginning of input if there
is no such {\em line-feed}.  The first line in a file has line number \TT{1}
and the first character in a line has byte offset \TT{0}.

The standard scanner also computes an
\mkey{indent}{of input character}\label{INDENT-OF-CHARACTER}
for each input character.  This
is the sum of the columns taken by all the
characters before the character and after
the first {\em line-feed} preceding the
character, or after the beginning of input if there is no such {\em line-feed}.
The first character in a line has indent \TT{0}.

For the purpose of computing indents,
characters in UNICODE subcategories \TT{Mn} (combining marks)
and \TT{Me} (enclosing marks),
and {\em control-characters} that are not
{\em horizontal-space-characters}, take zero columns.  All other characters
take one column, except for horizontal tab, which takes from
1 to 7 columns, with tabs being set every 8 columns in the line,
so the indent of the character after a horizontal tab
is always divisible by 8.

However for the purposes of printing a line,
the column in which a character is printed
depends upon both the position of the character
and the format in which the line is printed, and may not be the
same as the character's indent.  For example,
horizontal tab may be printed as 1 to 7 blank columns or
in a single column as
{\tiny $\stackrel{\textstyle H~~~}{~~~T}$}.

The standard scanner also produces a translation of each
lexeme.  This may just be a copy of the 32-bit characters
in the lexeme, or it may have some changes, or `translations',
of some of these characters.  For example, the lexeme
\TT{"a line<LF>"} may have a translation that omits the
\TT{"}'s and converts the four characters \TT{<LF>} into
a single linefeed character.

When the standard scanner identifies a lexeme it also identifies
a `\mkey{type}{of lexeme}' for the lexeme.
For example, the lexeme \TT{9.35} may have type `\TT{numeric}'
while the lexeme \TT{"abc"} may have the type `\TT{quoted string}'.

At its most fundamental level the
standard scanner identifies lexical atoms in the input text.
A \key{lexical atom} is a single character (e.g., the letters
in an identifier or word), a short string of characters
(e.g., the 4-character atom \TT{<LF>} in a quoted string),
or in some cases a longer string of characters containing
a repetition of characters from some character set (e.g., an arbitrarily
long string of hexadecimal digits).

Lexical atoms are read left to right and
grouped by the scanner into \skey{lexeme}s.
Lexical atoms are the unit of backup in the scanner; recognition
of a lexical atom can fail after some number of characters, but
once it is recognized, the scanner cannot back up past a lexical atom.
This permits limited look ahead in lexical scanning.  For example,
in some application
the string \TT{<LF>X} may begin with the lexical atom \TT{<LF>},
while the string \TT{<LFX} may begin with the lexical atom \TT{<}.
However, the syntax of lexical atom patterns is simple, so such
look ahead is limited.  Also, in most cases actual
lexical atoms are very short, and actual backup is rare.

Each atom is translated individually to produce an
\key{atom translation}.  Just as the sequence of atoms in a lexeme
comprise the lexeme, the sequence of their atom translations
comprises the translation of the lexeme.  Most atoms translate
to themselves.  An atom translation
may be the empty string, in effect omitting the atom from the
lexeme translation.  For example, the lexeme \TT{"x"} might
consist of three atoms, the first and last of which are \TT{"}
and translate into the empty string, whereas the middle atom
\TT{x} translates to itself.  Similarly \TT{"<LF>"} might also
consist of three atoms, with the middle atom \TT{<LF>} translating
to a single line feed character.

The scanner has a state containing a current point 
in the input UNICODE character stream,
a \key{current lexical table} identifier, a \key{current lexeme type}
which may be `\TT{NONE}', a \key{return stack}
of lexical table identifiers, and a \key{translation buffer} holding
translations of atoms.  A
\key{lexical table} is a set of atom patterns
that match atoms, and for each pattern an
\ikey{instruction}{lexical}
that determines what to do when the pattern is matched.
There is also a \key{default instruction} associated with
the lexical table that
determines what to do when no table pattern matches the next characters
in the input stream.

Most \skey{atom pattern}s\index{pattern!lexical atom} are fixed
length sequences of character patterns that match any sequence of
input characters of the same length as the atom pattern
if each input character of the sequence matches the corresponding
character pattern.  A \key{character pattern} is simply a
specification of a set of characters, e.g., letters or digits.
Thus one can construct an atom pattern that will recognize
single letters, or one that will recognize the sequence of
characters such as the 4-character sequence \TT{<LF>} which matches
the atom pattern \TT{"<" "LF" ">"}
(in which the quoted string has been broken into three parts to prevent
\TT{<LF>} being treated as representing a single line feed character)
or the 4-character sequence \TT{<0A>} which matches the atom pattern
\begin{center}
\TT{"<0<hex-digit>{}>"}
\end{center}
where \TT{<hex-digit>} names a character pattern matching characters
in the ranges \TT{0-9} and \TT{A-F}.

Atom patterns can also contain the special indicator
\TT{<repeat>} that allows an immediately preceding character pattern
to be repeated zero or more times.  Thus the pattern
\begin{center}
\TT{"<hex-digit><repeat>"}
\end{center}
recognizes any sequence of 1 or more \TT{<hex-digit>}'s (a single
\TT{<hex-digit>} followed by zero or more repetitions).

The atom patterns of a single lexical table must not conflict:
no character string can be recognized by two atom patterns of the
same lexical table.  However, a shorter atom pattern in a
table may match the initial segment of an atom matched by a longer
atom pattern in the table, in which case the longer pattern is
used for the atom.

The scanner operates by identifying the
longest sequence of characters beginning at the current input character
stream point that matches an atom pattern of the current lexical table.
This sequence of characters becomes
the next atom, and an instruction associated with its matching
atom pattern is then executed.  If no atom pattern can be matched,
the default instruction associated with the lexical table is executed instead.

A single lexical table instruction can do many things.
It can optionally reduce the length of a matched atom,
translated the matched atom to a different character string,
replace the matched atom and its translation with a match from an atom table,
and change the current lexical table.
An instruction can fail if the atom translation does not match a given pattern
or if an atom table fails to match any atom in the input.
An \key{instruction group} is a sequence of instructions
such that the first successful instruction will be the effective
instruction in the group.  An instruction group, instead of a single
instruction, may be associated with an atom pattern or be the default
instruction of a lexical table.


There are four kinds of lexical tables:
\mkey{master}{lexical table} tables,
\mkey{lexeme}{lexical table} tables,
\mkey{sublexeme}{lexical table} tables, and
\mkey{atom}{lexical table} tables.
\ikey{Master tables}{master table}\label{MASTER-TABLE}
are used to dispatch to lexeme or sublexeme tables which
typically recognize lexemes.  Atom tables are used
to recognize atoms whose patterns are logically the union
of a finite set of patterns.

Thus a simple scanner might have
one master table that dispatches to different lexeme tables,
one to recognize identifiers, one to recognize numbers, one to
recognize whitespace, and one to recognize comments.

Lexeme tables have \ikey{types}{type!of lexeme table}.
When the current lexical table becomes a lexeme table,
the current lexeme type is set equal to the type of that table.
The `\TT{output} {\em type}' and `\TT{output NONE}'
instruction components can also be
used to change the current lexeme type.

Sublexeme tables are just like lexeme tables except they
have no associated type and do not reset the current lexeme type.

Upon finishing the execution of an instruction, if the
current lexical table is a master table,
the currently accumulated lexeme is output
with the current lexeme type, if that is not `\TT{NONE}', or the
currently accumulated lexeme is discarded if the current lexeme
type is `\TT{NONE}'.
The current lexeme type is reset to `\TT{NONE}' whenever
the current lexical table becomes a master table.

Thus if a lexeme table of
type `\TT{whitespace}' cannot recognized any atom and
the default instruction associated with it
changes the current lexical table to a master table,
the lexeme accumulated so far will
be output as a lexeme of type `\TT{whitespace}'.

When it is between lexemes the current lexical table in the scanner state
is always a master table.  Master tables correspond to lexical
contexts.  A well designed language has only one main master
table, plus a few small master tables to handle error situations
such as premature end-of-file;
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.
Legacy languages
may have more master tables: C/C++ has several to handle
special lexical scanning of preprocessing lexemes;
see Appendix \itemref{C++-LEXICAL-PROGRAM}.

The standard scanner can report errors in one of two ways.  It may
simply output a lexeme with a type that indicates an error.  For
example, the character \TT{\textbackslash} appearing outside a quoted string
might be returned as a 1-character lexeme of type `\TT{misplaced
character}'.  Alternatively a single atom may be reported as an
error of a given type without interrupting the normal operation
of the scanner.  For example, if \TT{<H>} appears in a quoted
string, it may be reported as an erroneous atom of type
`\TT{unrecognized escape}'.  Aside from error reporting,
this atom will be processed
normally; it might, for example, be omitted from the lexeme
translation or be represented in that translation by the Unicode
Replacement Character (hex code \TT{FFFD}).

The algorithm for scanning a lexeme is given on in
Figure~\itemref{LEXICAL-SCANNING-ALGORITHM}.

\begin{boxedfigure}[!p]
\begin{center}
\begin{tabular}{l}
To scan a lexeme: \\
~~~~\begin{tabular}[t]{l}
    input: \begin{tabular}[t]{l}
           \TT{current} \TT{lexical} \TT{table} which must be a
	       \TT{MASTER} table \\
           \TT{input position} in input UNICODE character stream \\
           \end{tabular} \\
    set \TT{current} \TT{lexeme} \TT{type} = \TT{NONE} \\
    make \TT{return} \TT{stack} empty \\
    make \TT{translation} \TT{buffer} empty \\
    loop: \\
    ~~~~\begin{tabular}[t]{l}
        if \begin{tabular}[t]{l}
	   \TT{current} \TT{lexical} \TT{table} is a \TT{MASTER} table and  \\
           ~~~~~~~~\TT{current} \TT{lexeme} \TT{type} is \underline{not}
	       \TT{NONE}: \\
	   \end{tabular} \\
        ~~~~~~~~terminate loop \\
        if \TT{current} \TT{lexical} \TT{table} is a lexeme table: \\
        ~~~~~~~~set \TT{current} \TT{lexeme} \TT{type} to the
	        lexeme table type \\
        find the longest atom beginning at the \TT{input} \TT{position} \\
        ~~~~~~~~that matches an atom pattern in the \TT{current} \TT{lexical}
	        {table}, if any \\
        if an atom was found: \\
        ~~~~\begin{tabular}[t]{l}
            copy the atom to the end of the \TT{translation} \TT{buffer} \\
	    ~~~~and update the \TT{input position} to point after the atom \\
            execute the \TT{instruction} associated with the atom
	        pattern used \\
	    ~~~~(the simplest \TT{instruction} is `\TT{accept}' which does
	        nothing) \\
            \end{tabular} \\
	else: \\
	~~~~\begin{tabular}[t]{l}
	    execute the \TT{default instruction} associated with \\
	    ~~~~the \TT{current} \TT{lexical} \TT{table} \\
	    ~~~~(the simplest of these just change the
	     \TT{current} \TT{lexical} \TT{table})
            \end{tabular} \\
        \end{tabular} \\
    output: \begin{tabular}[t]{l}
            a lexeme consisting of the \TT{translation} \TT{buffer} contents \\
	    ~~~~(which may be empty) \\
	    ~~~~with the \TT{current} \TT{lexeme} \TT{type} as its type \\
	    ~~~~(which may \underline{not} be \TT{NONE}) \\
            the \TT{current} \TT{lexical} \TT{table}
	        (which is a \TT{MASTER} table) \\
            the \TT{input} \TT{position} (which has moved to just after
	        the lexeme) \\
            \end{tabular}
    \end{tabular}
\end{tabular}
\end{center}
\caption{Algorithm for Scanning a Lexeme}
\label{LEXICAL-SCANNING-ALGORITHM}
\end{boxedfigure}


A single \mkey{instruction}{in lexical program} can do the following:
\begin{itemize}
\raggedright
\item invoke an atom table to replace the matched atom and translate it
\item reduce the length of the matched atom (before it is copied to the
      \TT{translation} \TT{buffer}) (the length can be reduced to \TT{0})
\item translate the reduced length atom in the \TT{translation} \TT{buffer}
to a different character string
(otherwise the translation of an atom is a copy of the atom)
\item make instruction success conditional
      on the translated atom matching an atom pattern
\item announce the reduced length (untranslated) atom
      as an erroneous atom of a given type
\item change the \TT{current} \TT{lexeme} \TT{type} (the type can be changed
      to \TT{NONE})
\item change the \TT{current} \TT{lexical} \TT{table} - optionally the previous
      table ID can be pushed into the \TT{return} \TT{stack},
      or optionally the
      new table ID can be popped from this stack
\item force the atom table that contains the instruction
      to fail to match any atom
\end{itemize}

Details and examples are given in the next section.


\subsection{Lexical Programs}

A \key{lexical program} is a set of character pattern definitions
and lexical tables.  A lexical program can include another lexical program.
The top level lexical program must begin with a master
table that serves as the initial lexical table.

The lexemes of a lexical program
are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & character in UNICODE category \TT{Zs} \\
         & (includes single space) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} ::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= character in UNICODE category
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, or \TT{S}
\\
\emkey{control-character} :::=
	character in UNICODE category \TT{C} or \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::=
    \begin{tabular}[t]{l}
    character in UNICODE category \TT{Ps}, \TT{Pi}, \TT{Pe}, \\
    or \TT{Pf}; includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    character in UNICODE category \TT{L}
\\
\emkey{decimal-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                       $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    character in UNICODE category \TT{Nd}
    (includes {\em decimal-digits})
\\
\emkey{lexical-item-character}\label{LEXICAL-ITEM-CHARACTER} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment}\label{COMMENT} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

The following is a special virtual lexeme:
\begin{indpar}
\emkey{indent}\label{INDENT} ::=
        virtual lexeme inserted just before the first
	{\em graphic} character on a line
\end{indpar}

\ikey{Indent lexemes}{indent lexeme} have no characters, but
do have an \mkey{indent}{of indent lexeme}, which is the indent of
the graphic character after the indent lexeme.
The \mkey{indent}{of character} of a character is the number
of columns that precede the character in the character's physical line.
{\em Control-characters} other than {\em horizontal-space-characters}
take zero columns, as do characters of classes \TT{Mn} (combining-marks)
and \TT{Me} (ending marks).  All other characters take one column,
except for tabs, that are set every 8 columns.
Indent lexemes are used to form logical lines and blocks
(\pagref{LOGICAL-LINE} and \itemref{LOGICAL-LINES}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break}\label{LINE-BREAK} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

Non-{\em indent}, non-{\em line-break} {\em white-space}, such as occurs
in the middle of text or code outside comments, is discarded and not treated
as a lexeme.  Such {\em white-space} may be used to separate lexemes.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::=
    \begin{tabular}[t]{l}
    {\em horizontal-space-character}, other than \\
    ASCII single space
    \end{tabular}
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= {\em vertical-space-character}
	other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::=
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} \\
    or {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::=
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these sequences generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

Lexemes are tagged with the position
(\pagref{POSITION-OF-CHARACTER})
and indent (\pagref{INDENT-OF-CHARACTER})
of their first character
and of the first character after the lexeme.  The second
or both of these characters
may be an imaginary end-of-file character after the end of the input.

The lexemes in a lexical program are specified in
Figure~\itemref{LEXEME-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see text
above to account for such characters.

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file}\label{END-OF-FILE}
lexeme that occurs only at the end of a file.

The lexemes of a file are organized into \skey{logical line}s.%
\label{LOGICAL-LINE}
Most of these
consist of a single non-indented input line.  Indented lines continue
the current logical line.  A `\TT{;}' outside parentheses
ends a logical line, as does
an {\em indent} lexeme with zero indent or an
an {\em end-of-file} lexeme.  Since indented lines continue the
current logical line, {\em indent} lexemes with non-zero indent
do \underline{not} end the current logical line.

After each logical line is formed,
{\em indent}, {\em comment},
{\em line-break}, {\em end-of-file}, and logical line ending
`\TT{;}' lexemes are deleted from the logical line.
If the result is non-empty, it becomes a `\key{program statement}'.
In syntax equations such as
those of Figure~\itemref{LEXEME-PROGRAM-LEXEMES},
the end of a logical line is denoted by `\TT{;}', but in examples
it is usually denoted by line indentation or the end of file.

A `\key{comment line}' is a logical line that consists of
a single {\em comment} that is followed by a {\em line-break} and either
an {\em indent} or {\em end-of-file}, or is followed by just an
{\em end-of-file}.  It is an error for a logical line
that is \underline{not} a comment line to begin with a {\em comment}.
{\em Comments} can otherwise be included at any non-beginning position in any
logical line.

A special {\em character-representative} can consist of
a UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.

A special {\em character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

The Bracketed Subexpression Recognition Pass merges
\ikey{quoted string lexemes}{quoted strings!concatenated}
separated by one or two `\TT{\#}' marks
if they are in the same logical line
(see \pagref{QUOTED-STRING-CONCATENATION} for more details).
Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence"#
    #" than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
Quoted string concatenation is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the merged and unmerged versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.


\begin{boxedfigure}[!p]
\begin{indpar}

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em numeric-word} $|$ {\em word} $|$
	      {\em natural} $|$ {\em number} $|$ {\em numeric} \\
	$|$ & {\em mark} $|$ {\em separator} $|$ {\em quoted-string} \\
	$|$ & {\em indent} $|${\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em ASCII-single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{numeric-word} :::= {\em sign}\QMARK{} \ttkey{nan}
                      $|$ {\em sign}\QMARK{} \ttkey{inf}
		      ~~~~~
		      [where {\em letters} are \underline{case insensitive}]
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme}
                  \begin{tabular}[t]{@{}l@{}}
		  that contains a {\em letter} before any {\em digit} \\
		  and is not a {\em numeric-word}
		  \end{tabular}
\\[0.5ex]
\emkey{natural}\label{NATURAL}
	\begin{tabular}[t]{@{}rl@{}}
	:::= & {\em decimal-digit}\PLUS{} not beginning with \TT{0} $|$
	       \TT{0} \\
	\multicolumn{2}{l}{[but lexical type may be changed;
	                    see \pagref{NUMBER-LEXEME-RETYPING}]} \\
	\end{tabular}
\\[0.5ex]
\emkey{number}\label{NUMBER}
	\begin{tabular}[t]{@{}rl@{}}
	:::= & {\em sign}\QMARK{} {\em integer-part}
	                          {\em exponent-part}\QMARK{}
	     [that is not a {\em natural}] \\
	 $|$ & {\em sign}\QMARK{} {\em integer-part}\QMARK{}
	                          {\em fraction-part}
				  {\em exponent-part}\QMARK{} \\
	\multicolumn{2}{l}{[but lexical type may be changed;
	                    see \pagref{NUMBER-LEXEME-RETYPING}]} \\
	\end{tabular}
\\[0.5ex]
\emkey{numeric} :::= {\em middle-lexeme}
                  \begin{tabular}[t]{@{}l@{}}
		  that contains a {\em digit} before any {\em letter} \\
		  and is not a {\em natural} or {\em number}
		  \end{tabular}
\\[0.5ex]
\emkey{integer-part} :::= {\em decimal-digit}\PLUS{}
\\[0.5ex]
\emkey{fraction-part} :::= \TT{.} {\em decimal-digit}\PLUS{}
\\[0.5ex]
\emkey{exponent-part} :::= {\em exponent-indicator} {\em sign}\QMARK{}
                           {\em decimal-digit}\PLUS{}
\\[0.5ex]
\begin{tabular}[t]{@{}l@{\hspace{1in}}l@{}}
\emkey{sign} :::= \TT{+} $|$ \TT{-}
&
\emkey{exponent-indicator} :::= \TT{e} $|$ \TT{E}
\end{tabular}
\\[0.5ex]
\emkey{mark}\label{MARK} :::= {\em middle-lexeme} not containing a
                              {\em letter} or a {\em digit}
\\[0.5ex]
\begin{tabular}[t]{@{}l@{\hspace{1in}}l@{}}
{\em indent} ::= see \pagref{INDENT}
&
{\em line-break} ::= see \pagref{LINE-BREAK}
\\[0.5ex]
{\em comment} ::= see \pagref{COMMENT}
&
{\em end-of-file} ::= see \pagref{END-OF-FILE}
\end{tabular}


\end{indpar}
\caption{Lexeme Program Lexemes}
\label{LEXEME-PROGRAM-LEXEMES}
\end{boxedfigure}

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.%
\footnote{It is possible to use a strictly left to right scan with
backup over lexical atoms to perform
the right to left removal of {\em trailing-separators} from a
{\em lexical-item}, by recognizing a sequence of
{\em trailing-separator-characters} not followed by a
{\em lexical-item-character} that is not a
{\em trailing-separator-character}
as an atom that is backed up over and rescanned:
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.}

It is possible to break {\em words}, {\em numerics}, and {\em marks}
across lines by
adding \TT{\#} to the end of the first part and separately
to the beginning of the second part.  The two parts will be
concatenated after deleting these \TT{\#}'s.  Thus
\begin{indpar}\begin{verbatim}
This is a continued-middle-#
    #lexeme.
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
This is a continued-middle-lexeme.
\end{verbatim}\end{indpar}
However, {\em naturals}, {\em numbers}, and {\em numeric-words}
cannot be broken into parts.

A {\em numeric-word}, {\em natural}, or {\em number} lexeme
is a C/C++ constant, and 
conversely a C/C++ constant representing decimal number
and not ending in a {\em decimal-point} or representing an
IEEE floating point special value (e.g., {\tt NaN} or {\tt Inf})
is a {\em numeric-word}, {\em natural}, or {\em number} lexeme.
All these lexemes are given an IEEE double precision number value
after the manner of C/C++.

{\em Numeric} lexemes
that would be {\em number} lexemes except that they have commas
every 3 digits from the decimal point position may be translated into
{\em number} lexemes by removing the commas.  Whether this is
enabled is controlled by parser input flags as described in
\itemref{PARSER-INPUT-COMMANDS}.

Lexemes that are given IEEE double precision number values may
be retyped as {\em numbers}, or may be retyped as {\em numeric-words}
or {\em naturals}.  This is controlled by parser input flags
as described in \itemref{PARSER-INPUT-COMMANDS}.

The parser input flag defaults do \underline{not} allow commas
in IEEE double precision number valued lexemes and retype these
lexemes as follows:
\begin{itemize}
\item If the value is a NaN or infinite, the
new type is {\em numeric-word}.  For example, this applies to {\tt 1e500}
which converts to the same value as {\tt +inf}.
\item If the value is an integer in the range $[0,10^{15})$ the new
type is {\em natural}.
For example, this applies to {\tt 1e3}
which converts to the same value as {\tt 1000}.
\item Otherwise the new type is {\em number}.
For example, this applies to {\tt 1000000000000000}
which converts to the same value as {\tt 1e15}.
\end{itemize}

{\em Numerics} that are \underline{not} converted to {\em numbers}
represent character strings and in this are like {\em words}.

The syntax of a lexical program is specified in
Figures~\itemref{LEXEME-PROGRAM-SYNTAX-1}
and~\itemref{LEXEME-PROGRAM-SYNTAX-2}.

\begin{boxedfigure}[!p]
\begin{indpar}
\emkey{name} ::= 
        \begin{tabular}[t]{l}
	\{ {\em word} $|$ {\em natural}
	              $|$ {\em quoted-string} \}\STAR{} \\
	{\em word} \\
	\{ {\em word} $|$ {\em natural} $|$ {\em quoted-string} \}\STAR{}
	\end{tabular}
\\[0.3ex]
\emkey{lexical-program} ::=
        \begin{tabular}[t]{@{}l@{}}
	\TT{begin} {\em program-name} \TT{lexical program;}\\
	~~~~{\em lexical-program-unit}\STAR{} \\
	\TT{end} {\em program-name} \TT{lexical program};
	\end{tabular}
\\[0.3ex]
\emkey{program-name} ::= {\em quoted-string}
\\[0.3ex]
\emkey{lexical-program-unit}
        \begin{tabular}[t]{@{}rl@{}}
	::= & {\em cpat-definition} \\
	$|$ & {\em lexical-table-definition} \\
	$|$ & {\em program-inclusion}
	\end{tabular}
\\[0.3ex]
\emkey{program-inclusion} ::= \TT{include} {\em program-name}
				  {\em remove-clause}\STAR{} \TT{;}
\\[0.3ex]
\emkey{remove-clause}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{remove} {\em lexical-table-name} \\
	$|$ & \TT{remove} \TT{"}{\em cpat-name}\TT{"}
	\end{tabular}
\\[1.0ex]
\hspace*{0.2in}
    {\bf Note:} `{\em cpat}\,' abbreviates `{\em character-pattern}\,'
\\[1.0ex]
\emkey{cpat-definition} ::=
	\TT{"}{\em cpat-name}\TT{"} \TT{=}
		{\em cpat-expression} \TT{;}
\\[0.3ex]
\emkey{cpat-name}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{<}{\em letter}\PLUS{}\{\TT{-}{\em letter}\PLUS{}\}\STAR{}%
	       \TT{>} \\
	    & but not \TT{<}{\em upper-case-ASCII-letter}\PLUS{}\TT{>}
	\end{tabular}
\\[0.3ex]
\emkey{special-cpat-name}
        \begin{tabular}[t]{@{}rl@{}}
	:::= & \TT{<UNICODE-}{\em category}\TT{>} \\
	 $|$ & \TT{<UNICODE-}{\em subcategory}\TT{>} \\
	 $|$ & \TT{<others>} \\
	\end{tabular}
\\[0.3ex]
\emkey{category} :::= UNICODE category, e.g.~\TT{L} \\
\emkey{subcategory} :::= UNICODE subcategory, e.g.~\TT{Lu}
\\[0.3ex]
\emkey{cpat-expression}
        \begin{tabular}[t]{@{}rl@{}}
	::= & {\em cpat-term} \{ \TT{|} {\em cpat-term} \}\STAR{} \\
        $|$ & {\em cpat-term} \{ \TT{\&} {\em cpat-term} \}\STAR{}
	\end{tabular}
\\[0.3ex]
\emkey{cpat-term} ::= {\em cpat-factor}
                  $|$ \TT{\textasciitilde} {\em cpat-factor}
\\[0.3ex]
\emkey{cpat-factor}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{"}{\em character-representative}\TT{"} \\
	$|$ & \TT{"}{\em character-representative}\TT{-}%
		    {\em character-representative}\TT{"} \\
	$|$ & \TT{"}{\em cpat-name}\TT{"} \\
	$|$ & \TT{(} {\em cpat-expression} \TT{)}
	\end{tabular}
\\[1.0ex]
\emkey{lexical-table-definition} ::=
        \begin{tabular}[t]{@{}l@{}}
	\TT{begin} {\em lexical-table-name}
		    {\em lexical-table-kind} \TT{table} \TT{;} \\
	~~~~{\em lexical-table-entry}\STAR{} \\
	~~~~{\em default-instruction-group} \\
	\TT{end} {\em lexical-table-name}
		 {\em lexical-table-kind} \TT{table} \TT{;}
	\end{tabular}
\\[0.3ex]
\emkey{lexical-table-kind} ::=
    \TT{master} $|$ \TT{lexeme} $|$ \TT{sublexeme} $|$ \TT{atom}
\\[0.3ex]
\emkey{lexical-table-name} ::=
    {\em name} except \TT{SCAN ERROR} or \TT{NONE}
\end{indpar}
\caption{Lexeme Program Syntax: Part I}
\label{LEXEME-PROGRAM-SYNTAX-1}
\end{boxedfigure}

\begin{boxedfigure}[!p]
\begin{indpar}
\emkey{default-instruction-group}
	::= {\em empty} $|$ {\em instruction-group}
\\[0.3ex]
\emkey{lexical-table-entry}
        \begin{tabular}[t]{@{}rl@{}}
	::= & {\em atom-pattern} {\em instruction-group} \TT{;} \\
	$|$ & {\em atom-pattern} \TT{;}
	\end{tabular}
\\[0.3ex]
\emkey{atom-pattern} ::= {\em atom-term}\PLUS{}
\\[0.3ex]
\emkey{atom-term} ::= \TT{"}{\em atom-factor}\PLUS{}\TT{"}
\\[0.3ex]
\emkey{atom-factor} ::= {\em atom-primary} {\em repeat}\QMARK{}
\\[0.3ex]
\emkey{atom-primary} ::= {\em character-representative} $|$
                             {\em cpat-name} except {\em repeat}
\\[0.3ex]
\emkey{repeat} ::=
    \TT{<repeat>} $|$ \TT{<repeat-}{\em decimal-digit}\PLUS{}\TT{>}
\\[0.3ex]
\emkey{instruction-group}
	::= {\em instruction}
	        \{ \TT{else} {\em instruction} \}\STAR{}
\\[0.3ex]
\emkey{instruction} ::= {\em instruction-component}\PLUS{}
\\[0.3ex]
\emkey{instruction-component}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{accept} \\
	$|$ & \TT{match} ~ {\em atom-table-name} \\
	$|$ & \TT{keep} ~ {\em natural} \\
	$|$ & \TT{translate to} ~ {\em translation-string} \\
	$|$ & \TT{translate hex} ~
			{\em natural} ~ {\em natural} \\
	$|$ & \TT{translate oct} ~
			{\em natural} ~ {\em natural} \\
	$|$ & \TT{translate name} ~
			{\em natural} ~ {\em natural} \\
	$|$ & \TT{require} ~ {\em atom-pattern} \\
	$|$ & \TT{error} ~ {\em type-name} \\
	$|$ & \TT{output} ~ {\em type-name} \\
	$|$ & \TT{output} ~ \TT{NONE} \\
	$|$ & \TT{goto} ~ {\em master-table-name} \\
	$|$ & \TT{goto} ~ {\em lexeme-table-name} \\
	$|$ & \TT{goto} ~ {\em sublexeme-table-name} \\
	$|$ & \TT{call} ~ {\em lexeme-table-name} \\
	$|$ & \TT{call} ~ {\em sublexeme-table-name} \\
	$|$ & \TT{return} \\
	$|$ & \TT{fail} \\
	\end{tabular}
\\[0.3ex]
\emkey{type-name} ::= {\em name} except ~ \TT{SCAN ERROR} ~ or ~ \TT{NONE}
\\[0.3ex]
\emkey{atom-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{lexeme-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{sublexeme-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{master-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{translation-string} ::= {\em quoted-string}
\end{indpar}
\caption{Lexeme Program Syntax: Part II}
\label{LEXEME-PROGRAM-SYNTAX-2}
\end{boxedfigure}

Note that {\em atom-patterns} are written as if consecutive
{\em quoted-strings} had \TT{\#} marks between them.  As a
convenience, the \TT{\#}'s can be omitted in the context of
an {\em atom-pattern}.

An example lexical program that recognizes
whitespace and quoted strings is given
in Figure~\itemref{EXAMPLE-LEXEME-PROGRAM}.
\TT{<LF>} is the only {\em character-representative} recognized
in quoted strings by this example.

\begin{boxedfigure}[!p]
\addtolength{\baselineskip}{-0.4ex}
\begin{indpar}\begin{verbatim}
begin example lexical program;

"<whitespace-char>" = " " | "<HT>"
                    | "<LF>" | "<VT>" | "<FF>";

begin main master table;
    "<whitespace-char>" goto whitespace;
    "<Q>" translate to "" goto quoted string;
    "<others>" output misplaced character;
    output end of file;
end main master table;

begin whitespace lexeme table;
    "<whitespace-char>" accept;
    goto main;
end whitespace lexeme table;

begin quoted string lexeme table;
    "<Q>" translate to "" goto main;
    "<LF>" keep 0 goto premature end of line;
    "<" "LF" ">" translate to "<LF>";
    "<others>" accept;
    goto premature end of file;
end quoted string lexeme table;

include premature tables;

end example lexical program;

begin premature tables lexical program;
    // Stuff to include.

begin premature end of line master table;
    "<LF>" output premature end of line
           goto main;
end premature end of line master table;

begin premature end of file master table;
    output premature end of file
           goto main;
end premature end of file master table;

end premature tables lexical program;
\end{verbatim}\end{indpar}
\caption{Example Lexeme Program}
\label{EXAMPLE-LEXEME-PROGRAM}
\end{boxedfigure}

A \emkey{lexical-program} is a file consisting of a sequence of
{\em character-\EOL pattern-\EOL defi\-ni\-tions},
{\em lexical-\EOL table-\EOL defi\-ni\-tions},
and {\em program-inclusions}.  These respectively define character pattern sets
and lexical tables, and include lexical program units of
previously defined lexical programs.
Programs have {\em program-names} that are {\em quoted-strings} representing
file names relative to one of several directories input separately to
the lexical scanner.

\subsubsection{Lexical Program Inclusion}

A \emkey{program-inclusion} names a previously defined lexical program
whose units are to be included in the current lexical program
at the point of the {\em program-inclusion}.
There is a simple example of a program inclusion at the end of
the \TT{example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.
Identical definitions
may be repeated without error,
as can happen when one program includes two programs each of
which include the same third program.
A {\em program-inclusion} can have
\emsmkey{remove-clause}s{in {\em program-inclusion}}
each of which removes a named definition from the set of included
definitions.  This is the only way to resolve conflicts between
definitions.

\subsubsection{Character Pattern Definitions}

A \emkey{character-pattern-definition} (abbreviated as
\emkey{cpat-definition}) assigns a set of characters to a
{\em character-pattern-name}.  The latter is just a string of
letters and hyphens (\TT{-}) surrounded by angle brackets (\TT{< >})
with hyphens occurring only between letters.  Examples:
\TT{<digit>} and \TT{<line-break>}.  However, the
{\em character-pattern-name} defined by a {\em character-pattern-definition}
cannot contain only upper case letters, as this could conflict with
some {\em character-representative}
(some {\em special-character-pattern-names} which have builtin definitions do contain only upper case letters).

The character set is denoted by a \emkey{character-pattern-expression}.
The simplest character pattern
expression is just a single {\em character-representative} in quotes,
which denotes
the character set containing only the quoted character.  Examples:
\TT{"0"} and \TT{"+"}.
The next simplest is a list of {\em character-representatives}
in \TT{[~]} brackets.  This represents the character set consisting
of the characters represented in the list.  Examples each representing
a set of 2 characters:
\TT{"[+-]"}, \TT{"[eE]"}, \TT{"[<LF><CR>]"}.
Within the list the
hyphen (\TT{-}) is special when it is between two
{\em character-representatives}.  In this case it represents all
the characters whose character codes are between those of the
two characters represented on either side of the hyphen.
Examples: \TT{"[0-9]"} and \TT{"[A-Z]"}.  The characters
are ordered according to their 32 bit unsigned UNICODE value, and when
a hyphen is used between two characters, the first must have a smaller
code than the second.

A {\em character-representative} is a representative of a single UNICODE
character that can be used inside quotes (\TT{"}).
Most graphic UNICODE characters represent themselves.  Other characters
are represented by character sequences surrounded by the angle
brackets \TT{<} and \TT{>} (which are also the less than and
greater than signs).
For example, a line feed can be represented by any of the
following: \TT{<LF>}, \TT{<0A>},
\TT{<00A>}, \ldots, or \TT{<00000000A>}.

A quoted {\em character-pattern-name} denotes the character set associated
with that name by a \underline{previous} {\em character-pattern-definition},
or in the case of {\em special-character-pattern-names}, by one of the
following rules:
\begin{center}
\begin{tabular}{ll}
\TT{<UNICODE-$C$>} & all characters in UNICODE category $C$ \\
\TT{<UNICODE-$SC$>} & all characters in UNICODE subcategory $SC$ \\
\TT{<others>} & see page \pageref{<OTHERS>} \\
\end{tabular}
\end{center}

The \TT{|}, \TT{\&}, and \TT{\textasciitilde} operators and can be used to take
unions, intersections, and complements of character sets.  The complement
is relative to the universe of all 32 bit unsigned integer UNICODE
character codes.  Thus: \\
\centerline{\TT{\textasciitilde "[b-y]"}
denotes the same character set as
\TT{"[<0>-a]"\,|\,"[z-<0FFFFFFFF>]"}.}

Parentheses may be used in {\em character-pattern-expressions} as is
normal in algebraic expressions.
Note that the \TT{|} and \TT{\&} operators cannot be used together
in the same expression without intervening parentheses as neither
takes precedence over the other.  This is done to prevent ambiguity.

Some example {\em character-pattern-definitions} are:

\begin{indpar}[0.05in]\begin{verbatim}
"<hex-digit>" = "[0-9a-fA-F]";
"<letter>" = "<UNICODE-L>";
"<non-line-break-char>" = ~ "<LF>" & ~ "<VT>" & ~ "<FF>";
"<quotable-char>" = "[<020>-<07E>]" & ~ "<Q>";
"<whitespace-char>" = " " | "<LF>" | "<VT>" | "<FF>" | "<HT>";
"<source-character>" =
    ( "[<020>-<07E>]" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";
\end{verbatim}\end{indpar}

\subsubsection{Lexical Tables}

A {\em lexical-table-definition} specifies a {\em lexical-table-name},
the {\em lexical-table-kind} of the table,
a set of {\em lexical-table-entries}
each containing an {\em atom-pattern} and optionally
an {\em instruction-group},
and an optional {\em default-instruction-group} that is executed when
no atom is recognized by any of the table entries.

The {\em lexical-table-kinds} are
\mkey{master}{lexical table kind},
\mkey{lexeme}{lexical table kind},
\mkey{sublexeme}{lexical table kind}, or
\mkey{atom}{lexical table kind}.
In a master table {\em atom-patterns} are typically associated
with \TT{goto} or \TT{call} instructions
that change the current table from the
master table to a lexeme or sublexeme table.
In a lexeme or sublexeme table {\em atom-patterns}
are typically associated with \TT{accept} instructions which
accept the matched atom as part of the current lexeme.  In a lexeme
or sublexeme
table the default instruction is typically a \TT{goto} or \TT{return}
back to a
master table, and because this changes the current lexical table
to a master table, it causes any accumulated lexeme
to be output with its lexeme type being the current lexeme type
if that is not `\TT{NONE}', or it causes any accumulated lexeme
to be discarded if the current lexeme type is `\TT{NONE}'.

Atom tables permit sets of atom patterns to be used in
several places without copying all the patterns.  Details are
on \pagref{ATOM-TABLE}.

The lexical scanner is called by another program (e.g., a parser)
to scan a single lexeme.  The state of the scanner between calls is
the current position in the input character sequence and
the identifier of the master table to be used to scan the
first atom of the next lexeme.  This state can be changed
between calls by the caller, and in particular, the master
table can be changed.  If it is not change, the master table
for the first lexeme scan is the first master table in the lexical program,
and for subsequent scans it is the last master table of the previous
scan.  The first master table in a lexical program
is typically named `\TT{main}',
as it is in the \TT{example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.

A lexical table consists of {\em lexical-table-entries}%
\emindex{lexical-table-entry} each containing an {\em atom-pattern} and
an {\em instruc\-tion-group}.  The \emkey{atom-pattern} is matched against
the remaining input characters.  The pattern consists of a sequence
of {\em character-representatives}, each of which match only themselves,
and {\em character-pattern-names}, each of which match any character
in the named set of characters.  Thus
\begin{center}
\verb|"<0<hex-digit><hex-digit>>"|
\end{center}
matches 5-character atoms consisting of a \TT{<} followed by an
\TT{0} followed by two characters each in the character set
named by \TT{<hex-digit>} followed by a \TT{>}.
Note that this {\em atom-pattern}
only matches atoms that are 5 characters long.

An {\em atom-pattern} can be broken up into separate parts
each of which match consecutive segments of the atom.  For
example, the above atom pattern could be written as
\begin{center}
\verb|"<" "<" "<hex-digit>" "<hex-digit>" ">"|
\end{center}
This can be of more than cosmetic use, as in the case of the two atom patterns
\begin{center}
\verb|"<" "LF" ">"| ~~~~~~~~~~~~~~~~~~ \verb|"<LF>"|
\end{center}
The first of these patterns matches the 4 characters `\TT{<}', `\TT{L}',
`\TT{F}', and `\TT{>}', while the second pattern
matches a single line-feed character.
Similarly \TT{"[<digit>]"} represents a single character whereas
\TT{"["} \TT{"<digit>"} \TT{"]"} represents a sequence of three
characters.

The special character pattern name
\TT{<{repeat}>}%
\index{repeat@{\tt <repeat>}}%
\label{<REPEAT>}
can be used in an atom pattern to match zero or more occurrences of
the previous character pattern.  There must be a previous character
pattern.  That pattern can be \TT{<others>}.
The number of repetitions is the maximum number of characters in
the input that match the previous character pattern.
As an example use, the atom pattern \TT{"\textbackslash x<hex-digit><repeat>"}
will recognize an atom consisting of the characters \TT{\textbackslash x}
followed by one or more characters matching the character pattern
\TT{<hex-digit>}.  This particular atom pattern will match a C++
hexadecimal escape sequence.

The special character pattern name
\TT{<{repeat-$N$}>}%
\index{repeat-N@{\tt <repeat-$N$>}}%
is similar but matches zero through $N$ occurrences of the previous
character pattern, where $N$ is a sequence of {\em decimal-digits}
not beginning with \TT{0}.

Note that if \TT{$C_1$<repeat>$C_2$} is part of an atom pattern where
$C_1$ and $C_2$ are character pattern names or character representatives, then
any atom recognized by the pattern must contain some number of
$C_1$ characters followed by a $C_2$ character that is \underline{not} also
a $C_1$ character.
For example, the pattern
\TT{"X<repeat>X"} cannot recognize the atom \TT{XXX} because the
string \TT{XXX} will match \TT{X<repeat>} leaving nothing to match
the final \TT{X} in the pattern.

The order of {\em atom-patterns}
in a {\em lexical-table} is significant.  If the pattern
\TT{"}$PC_1Q_1$\TT{"} is followed in the table by
\TT{"}$PC_2Q_2$\TT{"} and $C_1$ and $C_2$ are not syntactically
identical as {\em character-patterns}, then $C_2$ is effectively
replaced by $C_2$ \TT{\&} \TT{\textasciitilde} $C_1$.
That is, the characters in the set denoted by $C_1$ are in effect removed
from the characters in the set $C_2$.  Here $P$, $Q_1$, and $Q_2$
are arbitrary and may be empty.


The special character pattern name
\TT{<{others}>}%
\index{others@{\tt <others>}}%
\label{<OTHERS>}
can be used in an atom pattern to match any character, which by
the previous paragraph means any character not previously matched.
For example, if \TT{"}$P$\TT{<others>}$Q$\TT{"} follows
\TT{"}$PC_1Q_1$\TT{"},
\TT{"}$PC_2Q_2$\TT{"},
and \TT{"}$PC_3Q_3$\TT{"},
in a {\em lexical-table}, \TT{<others>} will
match any character not matched by $C_1$, $C_2$, or $C_3$.
There are several examples of this on \pagref{EXAMPLE-LEXEME-PROGRAM}.

The atom pattern \TT{""} which would recognize zero length atoms is
\underline{not} permitted, but the {\em default-instruction-group} at the
end of the lexical table executes in the equivalent case where no atom
pattern in the table matches the remaining input.  In particular
the {\em default-instruction-group} always executes if the input has reached
its end.  This fact is used in both the `\TT{main master table}'
and `\TT{quoted string lexeme table}'
on \pagref{EXAMPLE-LEXEME-PROGRAM}.

\subsubsection{Lexical Instructions}

A \emkey{lexical-table-entry} contains an
{\em atom-pattern} and an optional
\emkey{instruction-group} that consists of one or more {\em instructions}
separated by \TT{else}'s.  Most {\em instruction-groups} contain just
a single {\em instruction}, so we will explain this first.
{\em Instruction-groups} with more than one instruction contain
instructions that can fail, causing
the failing instruction to become a no-operation and the
next instruction in the instruction group to be executed instead.

An \emmkey{instruction}{in lexical-table-entry} in an {\em lexical-table-entry}
specifies actions to be taken when an atom is recognized by the
{\em atom-pattern} of the entry.  The {\em instruction} consists of
a set of {\em instruction-components} each of which controls part of the
atom processing.

The {\em default-instruction-group} at the end of an lexical table behaves as
if a it was associated with the {\em atom-pattern} \TT{""}
that recognizes zero length atoms.  Note that actual {\em atom-patterns}
are not allowed to be \TT{""}.

The order of processing {\em instruction-components} in an {\em instruction}
is:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{Components that may
cause their containing instruction to fail:} \\[1ex]
~~~~~~~~ & \TT{match}, \TT{translate oct}, \TT{translate hex},
                                       or \TT{translate name}\\
~~~~~~~~ & \TT{require}
\\[2ex]
\multicolumn{2}{l}{Components that only execute if their
containing instruction does not fail:} \\[1ex]
~~~~~~~~ & \TT{keep} \\
~~~~~~~~ & \TT{translate to}\\
~~~~~~~~ & \TT{error} \\
~~~~~~~~ & \TT{output} \\
~~~~~~~~ & \TT{goto}, \TT{call}, \TT{return}, or \TT{fail} \\
\end{tabular}
\end{center}

An {\em instruction} with no {\em instruction-components} simply accepts
the matched atom and copies it into the translation.  In order to
indicate this, the instruction may be written as if it had a single
`\TT{accept}' instruction component.  If this component is present
in an {\em instruction}, no other {\em instruction-components}
may be present in the {\em instruction}.  Omitting the {\em instruction-group}
of a {\em lexical-table-entry} is the same as writing `\TT{accept}' for
the {\em instruction-group}.

\subsubsubsection{Match Instruction Components and Atom Tables}

The `\ttmkey{match}{in lexical program} {\em atom-table-name}'
{\em instruction-component} invokes the named
\key{atom table}\label{ATOM-TABLE}
to recognize an atom and provide its translation.
Any previously matched atom and translation are ignored, and
the atom table {\em atom-patterns} are used to rematch the current atom,
provide a translation of the atom, and determine
whether the containing {\em instruction} fails.

Atom tables match only a single atom and implicitly return
to their invoking {\em instruction} after matching one atom.  The
\TT{output}, \TT{goto}, \TT{call}, and \TT{return}
{\em instruction-components} \underline{cannot} be used in an
atom table.  However, the \TT{fail} {\em instruction-component}
can only be used in an atom table, and when executed indicates
that the atom table invoking {\em instruction} has failed, so that
{\em instruction} becomes a no-operation and the next
{\em instruction} in the invoking
{\em instruction-group} (i.e., the {\em instruction}
after the `\TT{else}' following the failed {\em instruction}) is
executed.

\TT{accept}, \TT{match}, \TT{keep}, \TT{require}, and
any of the \TT{translate} {\em instruction-components} can be used in
an atom table {\em instruction}.  An atom table
instruction may contain a \TT{match} that invokes another atom table,
but recursion is prohibited, and as \TT{match} uses the
\TT{return stack}, a very deep nesting of \TT{match}'es may
exceed the stack limit (which is at least \TT{32}).

If an instruction invokes an atom table and
the atom table does not fail,
the original atom match that caused the instruction
to be executed is replaced by the atom matched by the
atom table, and the atom translation is that provided by the atom table.

An instruction that invokes an atom table fails if the atom table
fails or if the instruction has a \TT{require} component that fails
when applied to the atom translation produced by the atom table.
If the instruction fails, the
original atom match is reinstated (the instruction becomes a
no-operation) before the next {\em instruction} in the {\em instruction group}
executes.

The \TT{error} instruction component can also be used in an atom
table, but if the atom table fails, or if a subsequent \TT{require}
causes a \TT{match} that invoked the atom table to fail, the
effects of the \TT{error} instruction component will \underline{not}
be undone.  Normally the only effect is to announce an error.

Atom tables may have a {\em default-instruction-group}.
However, this only makes sense if it is just a `\TT{fail}', or
if it is contains \TT{match} components.  If an atom table
is invoked and none of its {\em atom-patterns} match an atom,
and if the table has \underline{no} {\em default-instruction-group},
then a scan error is signaled (i.e., `\TT{fail}' is \underline{not}
implicit).

\subsubsubsection{Translate Hex/Oct/Name Instruction Components}

The \TT{translate hex/\EOL oct/\EOL name} components are applied to a matched
atom to produce a single UNICODE character translation of the atom.

An instruction can contain at most one of the following components:
\begin{center}
\tt
match \\
translate hex \\
translate oct \\
translate name
\end{center}
This is because all four of these components independently produce
an atom translation.

Note that if any previous instruction in an instruction group contains
a \TT{match} component, that instruction must have failed, and the
atom as it was when the instruction group started to execute will have
been reinstated, so \TT{translate hex/oct/name} components are always
applied to the matched atom as it was when the containing instruction
group started to execute, before any \TT{match} components in the
group executed.

Also note that any \TT{keep} component executes \underline{after}
\TT{translate hex/oct/name} components, and so does not affect the
matched atom used by these components.

The `\ttmkey{translate hex}{in lexical program} $m$ $n$'
{\em instruction-component} ignores the
first $m$ and last $n$ characters of the matched atom and, viewing the rest as
hexadecimal digits, converts these into an 32 bit unsigned integer
UNICODE character code, which becomes the 1-character atom translation.
An example is the lexical table entry
\begin{center}
\verb|"<0<hex-digit><hex-digit>>" translate hex 2 1;|
\end{center}
which might be used to accept a character representative in a quoted string
and copy the appropriate hexadecimally represented character code into
the lexeme translation.  If characters that
are supposed to be hexadecimal digits are not, the \TT{translate-hex}
component fails (but in our example
this cannot happen because the definition of \TT{<hex-digit>}
restricts these characters appropriately).  The `\TT{translate hex}
instruction component accepts the characters \TT{a-f}, \TT{A-F},
and \TT{0-9} as hexadecimal digits (but \TT{<hex-digit>} in the
example might not accept all these).

The `\ttmkey{translate oct}{in lexical program} $m$ $n$'
{\em instruction-component} is identical but
views the rest of the characters as octal and not hexadecimal.
An example use would be the lexical table entry
\begin{center}
\verb|"\<oct-digit><oct-digit><oct-digit>" translate oct 1 0;|
\end{center}

The `\ttmkey{translate name}{in lexical program} $m$ $n$'
{\em instruction-component} is similar but
views the rest of the characters as the UNICODE name
(a.k.a., UNICODE abbreviation alias)
of a character.
An example use would be the lexical table entry
\begin{center}
\verb|"<<upper-case-ASCII-letter><repeat>>" translate name 1 1;|
\end{center}
which would translate the atom `\TT{<LF>}' to a line feed.
Note that UNICODE names consist of ASCII upper case letters and
digits, with a letter being first.
In addition to standard UNICODE character names, \TT{NL} is
recognized as the name of the line feed character,
\TT{Q} is recognized as the name of the \TT{"} character,
and \TT{UUC} is recognized as the name of the
`\key{Unknown UNICODE Character}' that replaces erroneous
UTF-8 character encodings on input.

\subsubsubsection{Require Instruction Components}

The `\ttmkey{require}{in lexical program} {\em atom-pattern}'
{\em instruction-com\-po\-nent} tests whether the atom translation
matches the given {\em atom-pattern},
and if \underline{no}, causes the {\em instruction} to fail.
A \TT{require} should only appear in an
{\em instruction} which is followed by an `\TT{else}' in an
{\em instruction-group}.
A \TT{require} should only appear in an instruction that also
contains a \TT{match}, \TT{translate hex}, \TT{translate oct},
or \TT{translate name}
instruction component, and is only useful for testing the
translations produced by these latter components.

An example use would be the lexical table entry
\begin{indpar}
\verb|"\u<hex-digit><hex-digit><hex-digit><hex-digit>"| \\
\verb|    translate hex 2 0| \\
\verb|    require "<letter>" else| \\
\verb|    translate to "" error misplaced character in identifier;|
\end{indpar}
which might be used to process an atom of the form \TT{\textbackslash uXXXX} in
an identifier, accepting the atom as a legitimate representation of a
character if that character is a letter, and otherwise designating
the atom as an error while not putting anything in the lexeme translation
(see below for the definition of the `\TT{error}' instruction component).

The last {\em instruction} in an {\em instruction-group} must
never fail, and so cannot contain a \TT{require} {\em instruction-component}.

A \TT{require} component executes before any \TT{translate to}
component (\pagref{TRANSLATE-TO-INSTRUCTION-COMPONENTS} below),
so the translation tested by \TT{require} can be replaced by
\TT{translate to}.

\subsubsubsection{Keep Instruction Components}

The `\ttmkey{keep}{in lexical program} $n$'
{\em instruction-component} causes the atom length
to be shortened to $n$ UNICODE characters.
For example, the lexical table entry
\begin{center}
\verb|",<digit>" keep 1;|
\end{center}
will recognize a 1-character atom consisting of just a comma as long as
the comma is followed by character in the \TT{<digit>} character pattern
character set.  Atoms may not be lengthened by \TT{keep}.

A \TT{keep} component in the same instruction as a \TT{match} component
applies to the atom matched by the atom table invoked by the \TT{match}
component.

\subsubsubsection{Translate To Instruction Components}
\label{TRANSLATE-TO-INSTRUCTION-COMPONENTS}

A `\ttmkey{translate to}{in lexical program}~~{\em translation-string}'
{\em in\-struc\-tion-com\-po\-nent}
specifies a {\em quoted-string} of characters,
the {\em translation-string},
that becomes the translation of the atom.
A {\em translation-string} may be empty, as in the lexical table entry
\begin{center}
\verb|"<Q>" translate to "" goto main;|
\end{center}
which can be used to recognize the last \TT{"} of a quoted string, avoid
copying anything into the lexeme translation, and then switch to the
`\TT{main}' lexical table.
See the example on \pagref{EXAMPLE-LEXEME-PROGRAM}.

The \TT{translate to} component is executed \underline{after}
any \TT{match}, \TT{translate hex}, \TT{tran\-slate oct},
\TT{translate name}, or
\TT{require} components are executed, and overrides the translations produced
by these components.  It is therefore possible to produce a translation,
test it with \TT{require}, and if the test is successful, override the
translation with \TT{translate to}.  An example is
\begin{center}
\begin{tabular}{l}
\verb|"<"  "<digit>" match escaped char| \\
\verb|               require "<ascii-character>"| \\
\verb|               error ascii escaped character| \\
\verb|               translate to ""| \\
\end{tabular}
\end{center}
which announces that any escape sequence producing an ASCII character
is an erroneous atom and replaces that atom by the empty translation
so it is as if the atom did not exist in the input.
One could also use `\TT{translate to "?"}' to replace the atom
by a question mark.

If an instruction does not contain any of the components \TT{match},
\TT{translate hex}, \TT{tran\-s\-late oct},
\TT{trans\-late name}, or \TT{trans\-late to},
the translation
of an atom defaults to a copy of the atom itself, \underline{after}
any \TT{keep} component has been used to change the length of the atom.

\subsubsubsection{Error Instruction Component}

~~~~ An `\ttmkey{error}{in lexical program} {\em type-name}\,'
{\em instruction-component}
an\-noun\-ces the current atom as an erroneous atom of the given {\em type}.
The atom remains part of the current lexeme,
and its translation is governed
independently by \TT{match} and \TT{translate} instruction components
(or the absence of such).
The following are some examples:
\begin{indpar}\begin{verbatim}
"\<others>" error bad escape sequence;
"\<others>" translate to "" error bad escape sequence;
"\<others>" translate to "<DEL>" error bad escape sequence;
\end{verbatim}\end{indpar}
These might be entries in an lexical table for a quoted string.
All identify an atom consisting of a backslash followed by any
character that does not match any character pattern $C$ that is in
a lexical table
atom pattern of the form \TT{"\textbackslash}$C$\ldots\TT{"} where $C$ is a character
pattern other than \TT{<others>} (see \pagref{<OTHERS>}).
The first entry copies the entire 2-character atom, including the
backslash, into the lexeme translation.  The second entry copies
nothing (the empty string \TT{""}) into the lexeme translation.
The third entry copies the DEL character (hex code \TT{7f})
into the lexeme translation.  An alternative is the entry
\begin{indpar}\begin{verbatim}
"\<others>" keep 1 error bad escape;
\end{verbatim}\end{indpar}
that reduces the atom size to 1 character, just the backslash,
which is announced as an error without its following character,
and copied to the lexeme translation.  The character following
the backslash remains in the input and will part of the next
atom recognized.
Another alternative is
\begin{indpar}\begin{verbatim}
"\" match bad escape translate "" error bad escape;
. . .
<any> = <0-<0FFFFFFFF>>;      // Matches any character.
begin bad escape atom table;
"\<any><any><any>"
end bad escape atom table;
\end{verbatim}\end{indpar}
in which the lexical table entry will be invoked if the next character
in the input is \TT{\textbackslash} and no longer
lexical table atom pattern of the form \TT{"\textbackslash}\ldots\TT{"} is matched, 
and as a result the \TT{\textbackslash} and the next three characters will be identified
as a `\TT{bad escape}'
erroneous atom and translated to the empty character sequence.


The routine that announces an error atom is given the position
of the atom in the input stream, so characters surrounding the
atom may also be included in the announcement.  For example,
the line containing the atom may be printed with marks under the
characters of the atom.

An erroneous atom is different from an erroneous lexeme.
An erroneous lexeme is simply a lexeme whose {\em type}
indicates to the user of the lexical scanner that the lexeme is erroneous.
As such an erroneous lexeme is
handled by the lexical scanner just as any other lexeme would be:
i.e., the lexical scanner has no special knowledge of erroneous lexemes
and no special operations for detecting or announcing them.

\subsubsubsection{Output Instruction Component}

\hfill An `\ttmkey{output}{in lexical program} {\em type-name}\,'
{\em instruction-component} sets the \key{current lexeme type}.

The \TT{output} {\em instruction-component} is
used to change the type of the lexeme to be output from
the type of the table containing the instruction.
For example, at the top of \pagref{EXAMPLE-LEXEME-PROGRAM} the
\TT{main} master table has `\TT{output end of file;}' as its
{\em default-instruction-group}, thereby outputting a zero length
lexeme with `\TT{end of file}' type whenever the input is at the
end of file.

As another example, the `\TT{main}' master table at the top of
\pagref{EXAMPLE-LEXEME-PROGRAM} contains the entry:
\begin{indpar}\begin{verbatim}
"<others>" output misplaced character;
\end{verbatim}\end{indpar}
which causes an unrecognized character to be treated as a 1-character
lexeme of type `\TT{misplaced char\-ac\-ter}'.
The translation of this lexeme is
the character itself, but if the entry:
\begin{indpar}\begin{verbatim}
"<others>" translate to "<DEL>" output misplaced character;
\end{verbatim}\end{indpar}
had been used instead the translation would have been the ASCII delete
(DEL) character.

Upon finishing the execution of an instruction, if the
current lexical table is a master table,
the currently accumulated lexeme is output
with the current lexeme type, if that is not `\TT{NONE}', or the
currently accumulated lexeme is discarded if the current lexeme
type is `\TT{NONE}'.
The current lexeme type is reset to `\TT{NONE}' whenever
the current lexical table becomes a master table.

The `\TT{output NONE}' instruction can be used to reset the current
lexeme type to `\TT{NONE}' in order to discard the currently
accumulated lexeme.

\subsubsubsection{Goto, Call, Return, and Fail Instruction Components}

A `\ttmkey{goto}{in lexical program} {\em lexical-table-name}\,'
{\em instruction-component} switches the current lexical table after
the current atom is processed.  If the table switches
to a master table and the current lexeme type is not `\TT{NONE}',
then the current lexeme translation is output with the
current lexeme type as its type.

A `\ttmkey{call}{in lexical program} {\em lexeme-table-name}\,'
{\em instruction-component} is just like `\TT{goto}' except
that it also pushes the identifier of the lexical table in which
the `\TT{call}' occurs (the `caller') into the return stack.
The \key{return stack} is a stack of up to 32 lexical table identifiers
used by the `\TT{call}' and `\TT{return}' instruction components
and also by the `\TT{match} {\em atom-table-name}'
instruction components.  Recursive calls are prohibited.
Whenever a master table becomes the current lexical table, the
return stack is cleared.

A `\ttmkey{return}{in lexical program}'
{\em instruction-component} is just like `\TT{goto}' except
that uses the lexical table identifier at the top of the return
stack to determine the next lexical table.  This identifier is
also popped from the stack.

The return stack is set to empty whenever the current lexical table
becomes a master table.
A \TT{call} \underline{cannot} be used
to call a master or atom table.  A \TT{return} can only
appear in a lexeme or sublexeme table.
A \TT{goto} \underline{cannot} be used to go to an atom table.

The `\TT{call}' and `\TT{goto}' instruction components
can both be used in the same {\em instruction}, in 
which case the \TT{goto} lexical table identifier is pushed into the
return stack instead of the current lexical table identifier.
The `\TT{return}' instruction component cannot be used with
`\TT{call}' or `\TT{goto}' (if `\TT{return}' and `\TT{call}'
could be used together, they would have the same affect as
a simple `\TT{goto}')

The `\TT{call}' and `\TT{return}' instruction components
permit a lexeme or sublexeme table to be shared among different
master, lexeme, and sublexeme tables.  For example, a lexeme table to scan
a comment lexeme may be shared among several master tables;
see Appendix \itemref{C++-LEXICAL-PROGRAM} for examples.

The `\TT{call}' and `\TT{return}' instruction components
add nothing new to the lexical scanning language, since they
cannot be used recursively,
and they can always be eliminated by making
copies of the called tables with hard coded returns.
But for certain languages these instruction components
substantially reduce the size of the lexical program.

A `\ttmkey{fail}{in lexical program}'
{\em instruction-component} can only be used in an atom
table and cannot be used with any other instruction components.
It causes the instruction invoking the atom table to fail, but
the instruction containing the `\TT{fail}' succeeds.

The `\TT{goto}', `\TT{call}', and `\TT{return}' instruction components
\underline{cannot} be used in an atom table.

\section{Parsing}

The layered languages parser attempts to promote human efficiency
both by standardizing many aspects of syntax and by permitting
substantial additions to syntax.  Humans reason
syntactically, and therefore new types of data and algorithm
need to be supported by new syntax.  But this new syntax needs to
integrate with the old syntax, so the goal of the parser is to make
possible syntactic additions that integrate well with existing syntax.%
\footnote{General LL parsers are too unruly to meet his criterion.}

The parser is a sequence of passes each of which operates on a list
of tokens.  A token is either a lexeme, a subexpression, or an operator.

The top level parser pass, the bracketed subexpression recognition pass,
recognizes:
\begin{itemize}

\item Logical lines, terminated either by line breaks with or without
possible indented or non-indented
continuation lines, or by logical line separators
(e.g.~`\TT{;}'), or by blank lines.  Note that logical
lines with non-indented continuation lines that are
terminated by blank lines are typically headed paragraphs.

\item Indented paragraphs, introduced by line-ending
indentation marks such as `\TT{:}', and terminated by the end of indentation.
An indented paragraph is a part of a logical
line, typically at the end of its containing logical line,
and in turn contains logical lines of its own.

The top level is considered to be its own indented paragraph whose
indentation mark is the file beginning and which ends at the file end.

\item Bracketed subexpressions bounded by brackets
such as `\TT{(}' and `\TT{)}'.

\item Typed bracketed subexpressions bounded by typed brackets
such as `\TT{\{b|}' and `\TT{|b\}}'.

\item Typed separated subexpressions that are introduced by 
`typed prefix separators' such as `\TT{\{s\}}'.
These are converted to typed bracketed subexpressions.

\item Headed lines, that are logical lines which begin with
a `line header' that is
a typed prefix separator that has the `\TT{line}' prefix group.
The line header may be implied.
Headed lines are converted to typed bracketed subexpressions.

\item Headed paragraphs, that are groups of logical lines
that begin with a `paragraph header' that is
a typed prefix separator that has the `\TT{paragraph}' prefix group.
The paragraph header may be implied.
These are converted to typed bracketed subexpressions.

\end{itemize}

The non-top-level passes
operate on the subexpressions recognized by previous passes;
for example, the operator pass operates on bracketed subexpressions
and recognizes
subexpressions bounded by operators.

Prefix separators, brackets, and indentation marks
can be used to change syntax, so, for example,
the syntax within a \TT{\{p\}} paragraph may differ from the
the syntax within a \TT{\{code\}} paragraph,
the syntax within a \TT{[ ]} bracketed subexpression may differ from
the syntax within a \TT{` '} bracketed subexpression, and
the syntax within a `\TT{:}' introduced indented paragraph may differ
from the syntax of its containing logical line.
This is an important feature of the multi-pass organization of
the parser.

Parsing reduces each recognized subexpression, including each top level
logical line, to a single expression token.

\subsection{Tokens}
\label{TOKENS}

A token has the following components:

\begin{indpar}
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{type}{of token}
		& One of: \hspace{0.5in}\begin{tabular}[t]{l}
        	          A lexeme type. \\
        	          \ttmkey{BRACKETED}{token type} \\
        	          \ttmkey{BRACKETABLE}{token type} \\
        	          \ttmkey{PURELIST}{token type} \\
        	          \ttmkey{PREFIX}{token type} \\
        	          \ttmkey{MAPPED\_PREFIX}{token type} \\
        	          \ttmkey{IMPLIED\_PREFIX}{token type} \\
        	          \ttmkey{IMPLIED\_HEADER}{token type} \\
        	          \ttmkey{DERIVED}{token type} \\
        	          \ttmkey{OPERATOR}{token type} \\
			  \end{tabular}
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& For a lexeme, a translation of the
		  lexeme may be recorded in the token
		  \TT{value} as a MIN string or MIN number.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& Standardly word, mark, separator, and numeric lexeme type
		  tokens have a \TT{value} that is
		  the MIN string equal to the lexeme characters;
		  numeric-word, natural, and number lexeme type
		  tokens have a \TT{value} that is the lexeme
		  characters converted by {\tt strtod}
		  to a MIN number (which is an IEEE double precision number);
		  quoted string lexeme type tokens
		  have a \TT{value} that is the MIN string equal
		  to the lexeme translation string;
		  and comment, indent, line break, start of file,
		  and end of file lexeme type tokens have
		  \underline{no} \TT{value}.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& Numeric lexemes that are number lexemes with the
		  addition of commas every 3 digits from the decimal
		  point position may be converted to number lexemes.
		  Lexemes that have an IEEE double precision floating
		  point value may be retyped as number lexemes, or
		  as numeric-word or natural lexemes.  These actions
		  are controlled by parser input flags: see
		  \pagref{NUMBER-LEXEME-RETYPING}.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& Standardly a quoted string token value is converted
		  from a MIN string to an object having the MIN string
		  as its only element and \TT{<Q>} as its \TT{.type}.
		  This conversion is delayed until
		  the converted version of the token value is
		  needed, as when it must be copied to into
		  an object representing an expression.
		  Usually the quoted string token itself is discarded
		  immediately after its value has been used.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}

		& Standardly non-indent, non-line-break
		  whitespace lexemes and erroneous lexemes
		  (which are announced when read)
		  are not translated into tokens.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& For an \TT{OPERATOR}, the token \TT{value}
		  is the operator name recorded as
		  a MIN string or a MIN label, or in the case
		  where a bracketed subexpression is an operator,
		  the \TT{value} is the MIN object as described
		  for \TT{BRACKETED} tokens below.
		  \TT{OPERATOR} tokens are
		  produced inside the operator pass and consumed by
		  expression reformatters invoked by that pass.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& \TT{BRACKETED}, \TT{BRACKETABLE}, and \TT{PURELIST} tokens
		  are used to represent subexpressions, and have
		  MIN objects as their \TT{value}.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& The \TT{value} of a \TT{BRACKETED} token may have
		  any attributes, including \TT{.type},
		  \TT{.initiator}, and \TT{.terminator}.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& A \TT{PURELIST} token
		  is equivalent to (and an optimization of) a \TT{BRACKETED}
		  token whose \TT{value} is a MIN object
		  that does \underline{not} have \underline{any}
		  attributes (other than \TT{.position}).
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& A \TT{BRACKETABLE} token
		  is equivalent to (and an optimization of) a \TT{BRACKETED}
		  token whose \TT{value} is a MIN object
		  that does \underline{not} have
		  a \TT{.type}, \TT{.initiator}, or \TT{.terminator}
		  attribute, but may have other attributes
		  (besides \TT{.position}).
		  The \TT{BRACKETABLE} type is given to tokens primarily
		  by the operator parser pass.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& If a \TT{BRACKETABLE} or \TT{PURELIST} token
		  is to become the \underline{only} element of a
		  containing subexpression that will have no attributes other
		  than \TT{.type}, \TT{.initiator}, or \TT{.terminator}, 
		  then instead of creating a new
		  \TT{BRACKETED} token, any \TT{.type}, \TT{.initiator},
		  or \TT{.terminator} from the containing subexpression
		  is added to the \TT{BRACKETABLE} or \TT{PURELIST} token,
		  the token type of this token is then
		  changed to \TT{BRACKETED}, and
		  its token position and \TT{.position} attribute are
		  updated to the position of its containing subexpression.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
		& A \TT{PREFIX} token is a
		  \TT{BRACKETED} token that has
		  been identified as a prefix separator.  It can be
		  converted to a \TT{BRACKETED} token when its identity
		  as a prefix separator is no longer useful.
		  A \TT{PREFIX} token necessarily has a \TT{.type},
		  which is recorded in
		  the \TT{value\_type} component of the token,
		  but the token does \underline{not} have an \TT{.initiator}
		  or \TT{.terminator}.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
		& A \TT{MAPPED\_PREFIX} token is a
		  token that was created when when a mapped lexeme
		  (see \itemref{MAPPED-LEXEMES})
		  was mapped to a token that is a prefix.  I differs
		  from a \TT{PREFIX} token only in that it cannot
		  become an isolated header (see \itemref{ISOLATED-HEADERS}).
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
		& An \TT{IMPLIED\_PREFIX} token is a prefix token that
		  was inserted after another prefix token whose
		  {\em bracket-\EOL type} bracket type table entry has an
		  {\em implied-\EOL prefix}: see
		  \pagref{IMPLIED-PREFIX}.
		  It is just like
		  a \TT{PREFIX} token except that it is deleted and
		  ignored if it heads a {\em prefix-n-list} with zero
		  elements, and otherwise its value is replaced by a
		  copy of its value before being used, as its value is
		  shared with the bracket type table entry.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
		& An \TT{IMPLIED\_HEADER} token is a prefix token like an
		  \TT{IMPLIED\_\EOL PREFIX} but is a header token
		  and appears at the beginning of a logical line,
		  possibly after other header tokens.  A header
		  is a prefix whose {\em bracket-\EOL type-\EOL group}
		  (a.k.a., prefix group) is
		  either `\TT{paragraph}' or `\TT{line}.
                  See \itemref{LINE-VARIABLES} and
		  \itemref{BRACKET-TYPE-DEFINITIONS}.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
		& A \TT{DERIVED} token is a non-lexeme that which has
		  a token \TT{value} that is \underline{not} a MIN object.
		  For example, a bracketed
		  subexpression reformatter may
		  produce a \TT{DERIVED} token with a \TT{value} that is
		  a MIN special value or a MIN label.  In certain circumstances
		  the type of a lexeme token may be changed to
		  \TT{DERIVED} (e.g., when the token is a quoted string
		  or numeric used as a
		  component of an attribute label or value).
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& \TT{BRACKETED}, \TT{BRACKETABLE}, \TT{PURELIST}, \TT{PREFIX},
		  \TT{IMPLIED\_\EOL PREFIX}, \TT{IMPLIED\_\EOL HEADER}
		  and \TT{DERIVED}
		  tokens are called
		  \skey{expression token}s and \TT{OPERATOR} and lexeme
		  tokens are called non-expression tokens.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{value}{of token}
		& The token \TT{value}, as described above.  This is
		  a MIN string, number, label, special value, or object.
		  For tokens that do not have \TT{value}'s, this is \TT{MISSING}
		  (but for \TT{DERIVED} type tokens the token my have
		  a \TT{value} that equals \TT{MISSING}).
\\[1ex]
		& For quoted strings,
                  this is the translation string of the lexeme,
		  i.e., the string represented by the lexeme,
		  and not the lexeme itself.

\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{value\_type}{of token}
		& This token component can be computed from other
		  token components, and exists purely to optimize finding
		  the \TT{.initiator}, \TT{.type}, or header group
		  of the token \TT{value}.
\\[1ex]
		& For a \TT{BRACKETED} token whose
		  token \TT{value} has an \TT{.ini\-tiator},
		  the value of this \TT{.initiator}.  For a
		  \TT{BRACKETED} token whose \TT{value} was derived
		  from a headed line or headed paragraph
		  (\itemref{HEADED-LINES} and \itemref{HEADED-PARAGRAPHS})
		  and has a \TT{.type}
		  with either the `\TT{paragraph}' or `\TT{line}'
		  prefix group, the value of this prefix group.
		  For a \TT{PREFIX} token, the \TT{.type} of the token
		  \TT{value} if there is one.  Otherwise \TT{MISSING}.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{position}{of token}
		& The positions in the input file of
                  the first character of the token
		  and the first character after the token in the
		  input text.  A character position records a line number
		  and the byte offset within a UTF-8 encoding
		  of the line.  The column containing the character
		  can then be computed from the line itself, the format
		  in which the line is being printed, and the
		  byte offset of the character.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{indent}{of token}
	        & For an indent lexeme only,
		  the indent of the first character after the lexeme.  See
		  \pagref{INDENT-OF-CHARACTER}.
\end{tabular}
\end{indpar}

Tokens are organized in a doubly threaded list.  A file is translated into
such a list of lexeme tokens that begins with a beginning-of-file lexeme token
and ends with an end-of-file lexeme token.
The lexeme tokens of a file are not read in all at once.  When more tokens
are needed, they are read from the file until an indent or end of file
token has been read.

Lexemes are read by a lexical scanner which can be controlled by
resetting the master table from which the scan of the next lexeme
starts (see \pagref{MASTER-TABLE}).  In the parser, the master
can be reset at the beginning of a logical line (see \itemref{LOGICAL-LINES}).

As the parser identifies subexpressions, the tokens in the
subexpression are replaced by a single expression token (of
type \TT{BRACKETED}, \TT{BRACKETABLE}, \TT{PREFIX},
\TT{IMPLIED\_PREFIX}, or \TT{DERIVED})
that encodes the subexpression.
Although at the top level an entire
input file can be considered to be a list of logical lines (see below),
the parser \underline{never}
forms a single token that would represent this list, but instead
delivers top level logical line tokens
one at a time for subsequent
processing.  These top level tokens appear in the
the token stream as they are created,
and never again accessed by the parser.
They are just after the file beginning
lexeme token, and may be removed from the token stream at any time
by post-parser processing.

\subsection{Logical Lines}
\label{LOGICAL-LINES}

Input is parsed into a sequence of \skey{logical line}s, each of which is
a sequence of tokens.  Once parsed, logical lines may be grouped into
paragraphs.  A paragraph with its logical lines may be nested inside
a larger logical line.

In the input, non-blank
physical lines begin with an indent lexeme token that
contains an \mkey{indent}{of indent lexeme token}
parameter that is the number of columns before the first
graphic character in the physical line.  All physical lines end with a
line-break or end-of-file token.  Blank physical lines have
only this ending token, and do not have an indent token.

The \mkey{indent}{of physical line} of a non-blank physical line is the
indent of its indent token.

A logical line can end with an indent token (see below for specific
requirements), a line separator token outside parentheses
(most commonly `\TT{;}'), or an end-of-file token.
The first logical line begins with the first
token of the file.  For logical lines at top level, or for all the
logical lines in the same indented paragraph (see \itemref{PARAGRAPHS}),
a logical line other than the first begins with the first token after the
previous logical line.

Logical lines consisting of nothing but comment lexeme tokens and not
ended by a line separator are
called `\skey{comment line}s'.  Comment lines are discarded,
as are empty logical lines not ended by a line separator.

After a logical
line has been scanned, any indent, line-break, end-of-file, terminating
line separator, or comment tokens
are removed.  The logical line is then compacted to form
a MIN object to which an \TT{.initiator}
attribute is added that equals
the special value \TT{min::\EOL LOGICAL\_\EOL LINE()} and a
\TT{.terminator} attribute is added that is either the terminating 
line separator or equals \TT{"<LF>"}.  The vector part of the MIN
object can only be empty if the \TT{.terminator} is a line separator.

More specifically, a logical line ends with one
of the following as controlled by parser options defined in
Figures~\itemref{OPTION-NAMES-1}, \itemref{OPTION-NAMES-2},
and~\itemref{OPTION-NAMES-3}:

\begin{itemize}
\item An indent token with indent equal to or less than the current indent.
\item An indent token with indent less than the current indent.
\item Any indent token.
\item The first indent token after any completely blank (non-comment) line.
This is called a `\key{paragraph break}'.
\item A \key{line separator}, e.g.~`\TT{;}'.\label{LINE-SEPARATOR}
\item The end of file.  An end of file always terminates a logical line,
regardless of option settings.
\end{itemize}

\begin{boxedfigure}[!p]

End-At Options:\label{END-AT-OPTIONS}

\begin{indpar}[0.5in]
    

\vspace*{-0.05in}
\hspace*{-0.2in}\ttmkey{end at le indent}{parser option} \\
    This parser option causes an indent token with indent less than
    \underline{or equal to} the current indent to end a logical line.
    This means that logical lines can be continued by input lines
    with indent greater than the current indent, assuming other
    options permit.

\vspace*{-0.05in}
\hspace*{-0.2in}\ttmkey{end at lt indent}{parser option} \\
    This parser option causes an indent token with indent less than
    the current indent to end a logical line.
    This means that logical lines can be continued by input lines
    with indent \underline{equal to} or greater
    than the current indent, assuming other
    options permit.

\hspace*{-0.2in}\ttmkey{end at indent}{parser option} \\
    This parser option causes any indent to end a logical line.
    In this case continuation lines are not possible.

\vspace*{-0.05in}
\hspace*{-0.2in}\ttmkey{end at paragraph break}{parser option} \\
    This parser option causes a blank line to end a logical line.
    If this option is not present, blank lines have no affect
    on parsed input.

    This option is most often used with an implied paragraph header
    (\itemref{LINE-VARIABLES})
    to turn sequences of lines between blank lines into headed paragraphs
    (\itemref{HEADED-PARAGRAPHS}).

\vspace*{-0.05in}
\hspace*{-0.2in}\ttmkey{end at line separator}{parser option}
\label{END-AT-LINE-SEPARATOR} \\
    This parser option allows a line separator to end a logical line.
    The line separator controlled is that of either the top level
    when not inside an indented paragraph (default is `\TT{;}'),
    or of the smallest containing indented paragraph when inside
    an indented paragraph.

    If this option is off or is turned off by an opening bracket
    or indentation mark or prefix separator,
    the controlled line separator will not
    be recognized anywhere in the the bracketed subexpression,
    indented paragraph, or prefix list.

\vspace*{-0.05in}
\hspace*{-0.2in}\ttmkey{end at outer closing}{parser option} \\
    This parser option allows a bracketed subexpression or
    indented paragraph to be
    ended by the closing bracket of a containing bracketed subexpression
    in the same logical line.
    E.g., in `\TT{[x(y]}' the `\TT{]}' is permitted to end the
    subexpression `\TT{(y}' by automatically inserting a `\TT{)}'
    before the `\TT{]}', while also announcing an error.

    If this option is off, the only closing bracket that will be
    recognized is that of the innermost open bracketed expression.

\end{indpar}

\medskip

\caption{\bf Parsing Options: Part I}
\label{OPTION-NAMES-1}
\label{OPTION-NAMES}

\end{boxedfigure}

\begin{boxedfigure}[!p]

Enable Options:\label{ENABLE-OPTIONS}

\begin{indpar}

\hspace*{-0.2in}\ttmkey{enable indented paragraph}{parser option}%
	\label{ENABLE-INDENTED-PARAGRAPH} \\
    This parser option allows indentation marks beginning an indented
    paragraph to be recognized (if they end a physical line).

    This option is on by default at top level (else parser commands
    could not be recognized).
    The option is automatically turned off inside a bracketed
    subexpression.

\hspace*{-0.2in}\ttmkey{enable header}{parser option} \\
    This parser option allows {\em typed-prefix-separators} that
    have the \TT{paragraph} or \TT{line} group, and therefore
    can be line or paragraph headers (see \itemref{HEADED-LINES}
    and \itemref{HEADED-PARAGRAPHS}).

    This option is on by default at top level, but is
    automatically turned off inside a bracketed subexpression.

\hspace*{-0.2in}\ttmkey{enable table prefix}{parser option} \\
    This parser option allows {\em typed-prefix-separators} whose
    {\em bracket-type} has a selected bracket table entry.
    This option is off by default at top level.

\hspace*{-0.2in}\ttmkey{enable prefix}{parser option} \\
    This parser option allows all {\em typed-prefix-subexpressions}
    with no {\em elements} to be {\em typed-prefix-separators}.
    This option is off by default at top level.

\hspace*{-0.2in}Note:
    \begin{tabular}[t]{p{5in}}
    \raggedright
    Unless \TT{enable header} or an \TT{enable \ldots{} prefix} option is on,
    `\TT{@\ldots~=~\ldots}' lines cannot be recognized.
    \end{tabular}

\end{indpar}

\bigskip

Paragraph Options:\label{PARAGRAPH-OPTIONS}

\bigskip

The following options apply only to bracket type table entries with
the `\TT{paragraph}' group.

\begin{indpar}

\hspace*{-0.2in}\ttmkey{sticky}{parser option} \\
    An explicit paragraph header wit the `\TT{sticky}' option
    replaces the paragraph implied header with a copy of itself.
    An explicit paragraph header without the `\TT{sticky}' option
    replaces the paragraph implied header with the missing value at
    top level, or with the value from the \TT{define indentation mark}
    command within an indented paragraph.  See \ref{STICKY-RULE},
    \pagref{STICKY-RULE}.

\hspace*{-0.2in}\ttmkey{continuing}{parser option} \\
    A blank line ends a headed paragraph unless the paragraph header
    has the `\TT{con\-tin\-u\-ing}' option \underline{and}
    the first logical line after the blank line does
    \underline{not} begin with an explicit paragraph header.
    See \ref{CONTINUING-RULE}, \pagref{CONTINUING-RULE}.

\end{indpar}

\medskip

\caption{\bf Parsing Options: Part II}
\label{OPTION-NAMES-2}

\end{boxedfigure}

\begin{boxedfigure}[!t]

Option groups:

\begin{center}
\begin{tabular}{ll}
\ttmkey{default options}{parser option group}
				& \TT{end at le indent} \\
				& \TT{end at line separator} \\
				& \TT{end at outer closing} \\
				& \TT{enable indented paragraph} \\
				& \TT{enable header}
\\[2ex]
\ttmkey{other end at options}{parser option group}
				& all `\TT{end at \ldots}' options
\\[2ex]
\ttmkey{default end at options}{parser option group}
				& \TT{end at le indent} \\
				& \TT{end at line separator} \\
				& \TT{end at outer closing}
\\[2ex]
\ttmkey{non-default end at options}{parser option group}
				& all `\TT{end at}' options except those in \\
				& `\TT{default end at options}'
\\[2ex]
\ttmkey{other enable options}{parser option group}
				& all `\TT{enable \ldots}' options
\\[2ex]
\ttmkey{default enable options}{parser option group}
				& \TT{enable indented paragraph} \\
				& \TT{enable header}
\\[2ex]
\ttmkey{non-default enable options}{parser option group}
				& all `\TT{enable}' options except those in \\
				& `\TT{default enable options}'
\end{tabular}
\end{center}

\TT{Default options}\label{DEFAULT-OPTIONS}
are also the parser options set when the
a parser is initialized.

\medskip

\caption{\bf Parsing Options: Part III}
\label{OPTION-NAMES-3}

\end{boxedfigure}

The above makes use of the notion of a \key{current indent}.  At top
level this is just \TT{0}.  An indented paragraph changes the current
indent to the indent of the first indent token within the indented
paragraph.  See \itemref{PARAGRAPHS} for more detail.

A logical line that begins after an indent (i.e., does not begin
after a line separator) must begin at the current indent,
else a warning message is produced.
Since outside indented paragraphs the current indent is \TT{0},
logical lines outside indented paragraphs must begin at indent \TT{0},
unless they begin after a line separator.  In particular, the first
logical line of a file must begin at indent \TT{0}.

Note that in applying the above comment lexeme indentation
is \underline{not} ignored
and the indent before a comment may end a logical line (or set the
current indent of an indented paragraph, or end an indented paragraph:
see \itemref{PARAGRAPHS}).
However a warning message is issued if a comment lexeme that is not
inside a comment line (and therefore is in a non-comment logical line)
is not indented \underline{more} than the current indent.

Prefix separators, brackets, and indentation marks, all of which
can be used to change syntax, can change the options that control
what terminates a logical line.  Thus if at top level logical
lines end with a line break followed by a non-indented line
(i.e., an indent token with \TT{0} indent),
but the opening bracket \TT{`{}`{}`} changes the parser options so that
the current logical line is continued by any physical line regardless of
indent (and the corresponding closing bracket \TT{'{}'{}'} restores
the top level options), then the input:
\begin{indpar}\begin{verbatim}
This logical line contains ```
This quoted
paragraph is inside a logical
line!''',
    which is a subexpression.
\end{verbatim}\end{indpar}

is parsed to the logical line
\begin{indpar}\begin{verbatim}
This logical line contains @ which is a subexpression.
\end{verbatim}\end{indpar}

where \TT{@} represents the subexpression

\begin{indpar}\begin{verbatim}
```This quoted paragraph is inside a logical line!'''
\end{verbatim}\end{indpar}

As another example, if the indentation mark `\TT{:}' does not
change the top level line ending options, but
the prefix separator \TT{\{p\}} changes these
options so that only a blank line, the beginning of a
line indented less than the current indent, or an end of file
terminate a logical line,
then:
\begin{indpar}\begin{verbatim}
This logical line contains:
    {p} This is a headed paragraph
    in the indented paragraph.

    {p}
    And this is a second
    headed paragraph.
This is the next logical line.
\end{verbatim}\end{indpar}

is parsed to two logical lines, the first containing an indented paragraph
whose sole elements are:
\begin{indpar}\small\begin{verbatim}
{p|This is a headed paragraph in the indented paragraph "."|p}
\end{verbatim}\end{indpar}

and

\begin{indpar}\begin{verbatim}
{p|This is a second headed paragraph "."|p}
\end{verbatim}\end{indpar}

Note that a closing bracket or a prefix separator can \underline{not}
force the end of a logical line.  Subexpressions bracketed by opening
and closing brackets must be inside a logical line.  Similarly subexpressions
delimited by prefix separators must be inside a logical line, with the
exception that paragraphs headed by certain prefix separators can
consist of a sequence of logical lines.

The master table (\pagref{MASTER-TABLE})
used to scan the lexemes of a logical line
is called the `\key{lexical master}'\label{LEXICAL-MASTER} of the line.
This can be reset at the beginning of the logical line,
and will be effective for all lexemes in the logical line after the indent token
preceding the logical line and through and including any indent token
that follows the logical line.
See \itemref{LINE-VARIABLES} for more details.

\subsection{Paragraphs}
\label{PARAGRAPHS}

There are two kinds of \skey{paragraph}s: indented and headed.
Paragraphs consist of sequences of logical lines, or in the case
of some headed paragraphs, of a single logical line.

An \key{indented paragraph} begins with an indentation mark at the
end of a physical line or just before a comment that ends a physical
line, and is most frequently the last thing in the
logical line to which this physical line belongs.  The indentation
mark resets the \key{current indent}\label{CURRENT-INDENT}
for the duration of the indented
paragraph to the indent of the next indent token (the indent of
the next non-blank, non-comment line), if this indent
is greater than the current indent at the time the indentation mark
is encountered.  If the indent is not greater, or if there is an
end of file before any indent token, the indented paragraph is
empty and contains no logical lines.

The current indent during the duration of an indented paragraph is
also referred to as the
\key{paragraph indent}\label{PARAGRAPH-INDENT}
of that indented paragraph.
The paragraph ends with the first indent token that has a smaller
indent (first non-blank, non-comment line with smaller indent),
or with an end of file.

Top level parsing behaves as if input were in an indented paragraph
with \TT{0} paragraph indent and a fictitious indentation mark named
`\TT{TOP LEVEL}'.

A logical line that begins after an indent (i.e., does not begin
after a line separator) must begin at the paragraph indent,
else a warning message is produced.  In particular, the first
logical line of a file must begin at indent \TT{0}.

Details on indented paragraphs are given
in \itemref{INDENTED-PARAGRAPH-SUBEXPRESSIONS}.

A \key{headed paragraph}
begins with explicit or implicit \skey{paragraph header},
which is a prefix separator such as the `\TT{\{p\}}'s in
\begin{indpar}\begin{verbatim}
{p} This is a
paragraph.

{p}
And another
paragraph.
\end{verbatim}\end{indpar}

The type of the paragraph header, \TT{p} in this example, must 
appear in the parser's \key{bracket type table}
(\itemref{BRACKET-TYPE-DEFINITIONS}),
and be marked there as a paragraph header (i.e., must have the `\TT{paragraph}'
group).

A paragraph header must appear at the
beginning of a logical line that is 
in `\key{paragraph beginning position}', which means that the logical
line is at the beginning of a file, at the beginning of an indented
paragraph, or immediately after a blank line, with intervening
comment lines ignored.
A headed paragraph ends with the next blank line that
follows a logical line (there is an exception if the paragraph
bracket type table entry has the
`\TT{continuing}' option), or when the indented paragraph that
contains the headed paragraph ends (this can be at an
end of file).


Details on headed paragraphs are given in
\itemref{HEADED-PARAGRAPHS}.

While an indented paragraph is being scanned, there is a
`\mkey{implied header}{in line variables}' that if not \TT{MISSING}
is inserted at the beginning of each logical line in the indented paragraph
that does not have its own beginning header.  This implied header
may be a paragraph header (\itemref{HEADED-PARAGRAPHS})
or a line header (\itemref{HEADED-LINES}).

There are also two `\mkey{lexical master}{in line variables}'
parameters, which when not missing specify the
lexical master used to scan logical line lexemes
(see \pagref{LEXICAL-MASTER}).
This scan can introduce \skey{special lexeme}s\label{SPECIAL-LEXEME}
at the beginning of the
logical line that are based on
the first characters in the logical line,
and these lexemes can be mapped to paragraph or line headers
(see \itemref{MAPPED-LEXEMES}).

The two lexical master parameters\label{LEXICAL-MASTER-PARAMETERS}
are the `\key{paragraph lexical master}'
which is used for logical lines in paragraph beginning position
and the `\key{line lexical master}' which is used for other logical lines.

The default lexical master is named `\ttmkey{DEFAULT}{lexical master}'.
It is assumed that all lexical masters check for special lexemes at
the beginning of a logical line, and after reporting any, transfer to
this default lexical master to scan the rest of the line and any
subsequent lines for which lexical master names are not provided.

A paragraph header changes both the implied header and lexical masters
temporarily while the logical lines of the headed paragraph are being
scanned (\itemref{LINE-VARIABLES}).

\subsection{Parser Symbol Tables}
\label{PARSER-SYMBOL-TABLES}

Sequences of lexemes encoded as tokens are looked up in
\skey{parser symbol table}s.
A parser symbol table is conceptually a stack of
\skey{parser definition}s.

There are different symbol tables for different parser passes, as each pass
looks up only pass specific definitions.  Some passes have more than
one symbol table.

Each parser definition has the following
components:

\begin{indpar}
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{label}{of symbol table entry}
		& A non-empty
		  sequence of `symbols' that identifies the definition.
\\[1ex]
		& A \key{symbol} is a MIN string representing
		  a work, mark, or separator; or the MIN number
		  representing a natural or number.   MIN values
		  representing quoted string or numeric-word lexemes
		  are not symbols.
\\[1ex]
		& Labels are symbol table `\skey{key}s', that is, they
		  are what is looked up in a symbol table.
\\[1ex]
		& If a label has just one symbol, it is represented by
		  the symbol.  Otherwise it is represented by
		  a MIN label whose elements are the symbols.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{type}{of symbol table entry}
		& The type of the definition.  Each parser pass has
		  one (or sometimes more) symbol tables containing
		  definitions of types particular to the pass.
		  For example, the bracketed subexpression recognition
		  pass has a symbol table containing symbols of type
		  \TT{opening bracket}, \TT{indentation mark},
		  and \TT{line separator}, among others.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{selectors}{of symbol table entry}
		& A set of \skey{parsing selector}s that determine if
		  the definition is active.  See text.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{level}{of symbol table entry}
		& Block nesting level, 0, 1, 2, \ldots, of the parser block
		  containing the definition that made this symbol
		  table entry.  When the parser block ends, this entry
		  will be removed from the symbol table stack.  The top level is
		  level 0, which is outside all parser blocks.
\end{tabular}
\end{indpar}

Lookup in a parser symbol table takes as input a token sequence
that is part of a line (for the bracketed subexpression recognition pass)
or subexpression (for other passes), and finds an active symbol table
entry with a label whose symbols match an initial segment of the
token sequence.  Only symbol tokens, with lexeme types word, numeric,
mark, separator, natural, or number, can match label symbols.
These symbols
are matched for equality with the table entry label symbols.
When a match is found,
the initial segment of tokens used in the match is called
a `\key{matched label}\,'.

At any point the longest active match is chosen.  Entries may
not be active because they have the wrong type or wrong selectors (see below)
for the current parser pass or context.
Entries may be activated only when other entries are recognized
in the current context, as when afix operators become active
only after an associated non-afix operator is recognized in
the same subexpression (see \pagref{AFIX-FLAG}).

In the bracketed
subexpression recognition pass matched labels may not span physical
line boundaries.
In later passes, physical line boundary tokens are no longer present, and
matched labels can span physical line boundaries,
but cannot cross bracketed subexpression
boundaries.

The context of a symbol table lookup includes a set of
\skey{parsing selector}s.\label{PARSING-SELECTORS}
In order to be active, a symbol table entry's set of selectors
must have some selector in common with the parsing selectors.
A selector set is represented as a 43-bit unsigned integer value
with the bit in
position 1\TT{<{}<}N being on if the N+1'st selector is in the set.
Thus there can be at most 43 distinct selectors used by any set of
parser definitions.  The selectors that can be
currently used are given names that are sequences of symbols,
and must be referenced by these names.

The parsing selectors may change when an explicit opening bracket,
indentation mark, or prefix separator
is recognized, and remain changed until the associated explicit closing
bracket, end of indented paragraph, or end of prefix separator list
is recognized.  The parser also has top level set of selectors
used to begin parsing a top level logical line, and these top level
selectors can be changed by parser commands.

There are no other mechanisms for setting or changing the
parsing selectors.

The following parsing selectors are builtin:

\begin{indpar}[0.5in]

\hspace*{-0.2in}\ttmkey{TOP LEVEL}{top level selector} \\
    This is always on when a top level logical line is parsed, and off
    by default when indented paragraph logical lines or a bracketed
    subexpression is parsed.  While the default may be overridden,
    great care should be used in doing so.

\hspace*{-0.2in}\ttmkey{LINE LEVEL}{line level selector} \\
    This is always on when a logical line is parsed, and off
    by default when a bracketed subexpression is parsed.
    While the default may be overridden, great care should
    be used in doing so.

\hspace*{-0.2in}\ttmkey{data}{parser selector} \\
    This selects symbol table entries that parse raw data.
    It is used to enable symbol table entries that parse prefix
    separators and the type/attribute parts of typed
    brackets.

\hspace*{-0.2in}\ttmkey{atom}{parser selector} \\
    This selects only the symbol table entries that parse
    labels and special values (e.g., \TT{[<~>]} and \TT{[\$~\$]}).
    It is used to enable labels and special values to appear in
    a list of lexemes.

\end{indpar}

One selector group is also defined:

\begin{center}
\begin{tabular}{ll}
\ttmkey{other selectors}{parser selector group}
				& all selectors
\end{tabular}
\end{center}

For a few parser symbol tables lookup does not use a sequence
of tokens, but instead uses a pre-scanned sequence of symbols,
such as the type of a prefix separator.  An example of such
a symbol table is the bracket type table
(\itemref{BRACKET-TYPE-DEFINITIONS}).

The parser symbol tables act like stacks; as new parsing
definitions are encountered, they are are `pushed' into the
symbol tables.  These stacks can be popped, removing
the parser definitions in reverse order.  When a definition
is popped, its effects are removed from the symbol tables.
Definitions are popped by the ends of parser blocks: see
\pagref{PARSER-BLOCKS}.

It is also possible to `\mkey{undefine}{parser symbol table entry}'
parser symbol table entries by clearing some or all of their selectors.
One can also think of `undefine's as being pushed into and popped
from symbol tables,
where pushing corresponds to clearing selectors from some entries
and popping corresponds to restoring those selectors to their
previous state.


\subsection{Parser Commands}
\label{PARSER-COMMANDS}

Parser commands are logical lines within a {\em parser-command-paragraph}
that change parser tables.
The syntax of a parser commands in general and in particular those
associated block definition, parser trace flags, and parser selectors
is specified in Figures~\itemref{PARSER-COMMAND-SYNTAX-1}
and \itemref{PARSER-COMMAND-SYNTAX-2}.

A {\em parser-command-paragraph} is an indented paragraph on a line by itself
that has the indentation mark `\TT{*PARSER*:}',
Thus `\TT{*PARSER*:}' must appear by itself in a top level
physical line, and the indented logical lines that follow are
{\em parser-commands}.

\begin{boxedfigure}[!t]
\emkey{parser-command-paragraph}
    \begin{tabular}[t]{@{}rlrl@{}}
    ::= & \TT{*PARSER*:}\index{PARSER@{\tt *PARSER*:}} \\
    	& ~~~~{\em parser-command}\STAR{}
    \end{tabular}
\label{PARSER-COMMAND-PARAGRAPH}
\\[0.3ex]
\emkey{parser-test-paragraph}
    \begin{tabular}[t]{@{}rlrl@{}}
    ::= & \TT{*PARSER* *TEST:}\index{parser test@{\tt *PARSER* *TEST:}} \\
    	& ~~~~{\em logical-line}\STAR{}
    \end{tabular}
\\[0.3ex]
\emkey{parser-command}
    \begin{tabular}[t]{@{}rlrl@{}}
    ::= & {\em parser-block-command} &
    $|$ & {\em parser-input-command} \\
    $|$ & {\em parser-top-level-command} &
    $|$ & {\em parser-trace-command} \\
    $|$ & {\em parser-bracketed-command} &
    $|$ & {\em parser-pass-command} \\
    $|$ & {\em parser-operator-command} &
    $|$ & {\em parser-standard-command} \\
    $|$ & {\em parser-selector-command} \\
    \end{tabular}
\label{PARSER-COMMAND}
\\[0.3ex]
\emkey{simple-name} ::= {\em word} \{ {\em word} $|$ {\em natural}
            \}\STAR{}
\\[0.0ex]
\emkey{key}\label{KEY} ::= {\em symbol}\PLUS{}
\\[0.0ex]
\emkey{symbol}\label{SYMBOL}
    ::= {\em separator} $|$ {\em mark} $|$ {\em word}
                        $|$ {\em natural} $|$ {\em number}
			$|$ {\em numeric}
\\[0.0ex]
\emkey{quoted-key}\label{QUOTED-KEY}
    :::= \TT{"}{\em key}\TT{"}
\\[0.0ex]
\emkey{partial-name} ::= \TT{""} | {\em quoted-key}
\\[0.3ex]
\emkey{parser-flag} ::= {\em simple-name}
\\[0.0ex]
\emkey{parser-flag-list}\label{PARSER-FLAG-LIST}
    ::= \TT{[ ]}  $|$ \TT{[} {\em parser-flag}
          \{ \TT{,} {\em parser-flag} \}\,\STAR{} \TT{]}
\\[0.0ex]
\emkey{parser-flag-modifier-list}
    \begin{tabular}[t]{@{}r@{~}l@{~}l@{}}
    ::= & \TT{[} & {\em parser-flag-op} {\em parser-flag} \\
        &         & \{ \TT{,} {\em parser-flag-op}
	                        {\em parser-flag} \}\,\STAR{} \TT{]} \\
    \end{tabular}
\\[0.0ex]
\emkey{parser-flag-op} ::= \TT{+} $|$ \TT{-} $|$ \TT{\textasciicircum}
\\[0.0ex]
\emkey{parser-flag-spec} ::= {\em parser-flag-list} $|$
                              {\em parser-flag-modifier-list}
\\[0.3ex]
\emkey{selector} ::= {\em parser-flag} as per \pagref{SELECTOR-NAMES}
\\[0.0ex]
\emkey{selectors} ::= {\em parser-flag-list}
                      with only selector names (\pagref{SELECTOR-NAMES})
\\[0.0ex]
\emkey{selector-spec} ::= {\em parser-flag-spec}
                          with only selector names (\pagref{SELECTOR-NAMES})
			  \label{SELECTOR-SPEC}
\\[0.0ex]
\emkey{selector-flags} ::= {\em parser-flag-list}
                          with only selector names (\pagref{SELECTOR-NAMES})
			  \label{SELECTOR-FLAGS}
\\[0.0ex]
\emkey{option} ::= {\em parser-flag} as per \pagref{OPTION-NAMES}
\\[0.0ex]
\emkey{option-spec} ::= {\em parser-flag-spec}
                          with only option names (\pagref{OPTION-NAMES})
			  \label{OPTION-SPEC}
\\[0.0ex]
\emkey{option-flags} ::= {\em parser-flag-list}
                          with only option names (\pagref{OPTION-NAMES})
			  \label{OPTION-FLAGS}

\caption{\bf Parser Command Syntax: Part I}
\label{PARSER-COMMAND-SYNTAX-1}

\end{boxedfigure}

\begin{boxedfigure}[!t]
\emkey{parser-block-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttmkey{begin block}{parser command} ~ {\em block-name} \\
    $|$ & \ttmkey{end block}{parser command} ~ {\em block-name} \\
    \end{tabular}
\label{PARSER-BLOCK-COMMAND}
\\[0.0ex]
\emkey{block-name} ::= {\em simple-name}
\\[0.3ex]
\emkey{parser-selector-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttmkey{define selector}{parser command} ~ {\em selector} \\
    $|$ & \ttmkey{print selector}{parser command} ~ {\em partial-name} \\
    \end{tabular}
\label{PARSER-SELECTOR-COMMAND}
\\[0.3ex]
\emkey{parser-top-level-command} ::= \\
\hspace*{0.3in}\begin{tabular}{rl}
    & \ttmkey{define top level}{parser command}
      \label{DEFINE-TOP-LEVEL}
       \TT{parsing selectors} ~ {\em top-level-selectors} \\
$|$ & \TT{define top level parsing options} ~ {\em top-level-options} \\
$|$ & \TT{define top level line separator} ~ {\em top-level-line-separator} \\
$|$ & \TT{define top level} ~ 
      \begin{tabular}[t]{@{}l@{}}
      \{ \TT{paragraph} | \TT{line} \}\QMARK{} ~ \TT{lexical master} \\
      {\em lexical-master-name} \\
      \end{tabular} \\
$|$ & \ttmkey{print top level}{parser command} \\
   \end{tabular}
\label{PARSER-TOP-LEVEL-COMMAND}
\\[0.3ex]
\emkey{top-level-selectors} ::=
    \begin{tabular}[t]{l}
    {\em selector-spec} without any `\TT{TOP LEVEL}'  \\
        or `\TT{LINE LEVEL}' selector
	~~~ [\pagref{SELECTOR-SPEC}]
    \end{tabular}
\\[0.3ex]
\emkey{top-level-options} ::=
    \begin{tabular}[t]{l}
    {\em option-spec} with only `\TT{end at \ldots}' \\
    and `\TT{enable \ldots}' options
	~~~ [\pagref{OPTION-SPEC}]
    \end{tabular}
\\[0.3ex]
\emkey{top-level-line-separator} ::= {\em quoted-key} $|$ \TT{NONE}
\\[0.3ex]
\emkey{lexical-master-name}\label{LEXICAL-MASTER-NAME} ::= {\em quoted-key}
                    $|$ {\em simple-name} not containing `\TT{with}'
\\[0.3ex]
\emkey{parser-input-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttmkey{input}{parser command} ~ {\em input-flag-spec} \\
    $|$ & \ttmkey{print input}{parser print} \\
    \end{tabular}
\label{PARSER-INPUT-COMMAND}
\\[0.0ex]
\emkey{input-flag} ::= {\em parser-flag} as per \pagref{INPUT-FLAGS}
\\[0.0ex]
\emkey{input-flag-spec} ::=
    {\em parser-flag-spec} with only {\em input-flag} names
\\[0.3ex]
\emkey{parser-trace-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttmkey{trace}{parser command} ~ {\em trace-flag-spec} \\
    $|$ & \ttmkey{print trace}{parser print} \\
    \end{tabular}
\label{PARSER-TRACE-COMMAND}
\\[0.0ex]
\emkey{trace-flag} ::= {\em parser-flag} as per \pagref{TRACE-FLAGS}
\\[0.0ex]
\emkey{trace-flag-spec} ::=
    {\em parser-flag-spec} with only {\em trace-flag} names
\\[0.3ex]
\emkey{parser-standard-command}
    ::= \ttmkey{define standard} ~~ {\em standard-flag-spec}\QMARK{}
\\[0.0ex]
\emkey{standard-flag} ::= {\em parser-flag} as per \pagref{STANDARD-FLAGS}
\\[0.0ex]
\emkey{standard-flag-spec} ::=
    \begin{tabular}[t]{@{}l}
    {\em parser-flag-spec} with only {\em standard-flag} names \\
    and no \TT{\textasciicircum} {\em parser-flag-op}
    \end{tabular}

\caption{\bf Parser Command Syntax: Part II}
\label{PARSER-COMMAND-SYNTAX-2}

\end{boxedfigure}

A {\em parser-command-paragraph} is first completely parsed, and then
the commands it contains are executed in order.
The \TT{*PARSER*:}' indentation mark sets the parser selectors
to `\TT{[data]}', so only the `\TT{data}' selector is present when
parser commands are parsed.  It is possible, but not advisable, to
use parser commands to alter the way that input is parsed if only
the `\TT{data}' selector is present.

Parser commands make use of {\em simple-names} that are just a {\em word}
optionally followed by a sequence of {\em words} and/or {\em naturals}.
Parser commands also make use of
{\em quoted-keys}, that are arbitrary sequences of {\em word},
{\em mark}, {\em separator}, and {\em natural} lexemes enclosed
in quotation marks to form a {\em quoted-string} lexeme.
This embedding of lexemes in a {\em quoted-string} lexeme
serves to keep the embedded lexemes from being given a special
interpretation by the parser when the parser command is parsed.

Parser commands may be organized into \skey{parser-block}s of the form:%
\label{PARSER-BLOCKS}
\begin{center}
\begin{tabular}{l}
\TT{*PARSER*:} \\
\TT{~~~~}\TT{begin block} {\em block-name} \\
\TT{~~~~}{\em parser-command} \\
.~.~.~.~.~.~.~.~.~. \\
\TT{*PARSER*:} \\
\TT{~~~~}\TT{end block} {\em block-name} \\
\end{tabular}
\end{center}

When a parser block ends, all changes to the parser tables made in
the block are erased, so subsequent parsing is as if the block
had never existed.
The {\em block-name} merely serves as an error check; it is
not possible to have one `\TT{end block}' command end more than
one parser block.

The parser has several sets of \emkey{parser-flags}\index{flags!parser}:
\begin{center}
\begin{tabular}{lll}
parsing selectors 	& 43 bits	& \pagref{PARSING-SELECTORS} \\
parsing end at options	& 6 bits	& \pagref{END-AT-OPTIONS} \\
parsing enable options
			& 4 bits	& \pagref{ENABLE-OPTIONS} \\
parsing paragraph options
			& 3 bits	& \pagref{PARAGRAPH-OPTIONS} \\
parsing trace flags	& 64 bits	& \pagref{TRACE-FLAGS} \\
\end{tabular}
\end{center}
A set of parser flags can be
specified by giving a {\em parser-flag-list} or a
{\em parser-flag-modifier-list}.

When a \emkey{parser-flag-modifier-list}\label{FLAG-MODIFIER-LIST}
is used, the flag set is made by modifying the current
flag set (trace flags, selectors, or options) according to the
instruction's `{\em parser-flag-op} {\em parser-flag}' pairs.
These pairs are interpreted as follows:
\begin{center}
\begin{tabular}{ll}
\TT{+}~~{\em parser-flag} & set the named flag \\
\TT{-}~~{\em parser-flag} & clear the named flag \\
\TT{\textasciicircum}~~{\em parser-flag} & complement (flip) the named flag \\
\end{tabular}
\end{center}

In either the case of a {\em parser-flag-list} or
{\em parser-flag-modifier-list} no flag may be named more than once.

Each particular kind of flag can also have flag groups, which are names
of sets of flags.  If a flag group name is used, it is effectively
replaced by the names of all the flags in the group, \underline{except}
those flags explicitly named in the {\em parser-flag-list} or
{\em parser-flag-modifier-list} in which the flag group name appears.
So for example, the flag modifier list
\begin{center}
\TT{[+ other end at options, - end at paragraph break]}
\end{center}
is equivalent to a {\em parser-flag-list} setting all end-at options
except \TT{end at paragraph break} which is cleared.
This is because the group name
\TT{other end at options} denotes the set of all end-at options, but
since \TT{end at paragraph break} is explicitly mentioned in this
{\em parser-flag-modifier-list}, it is deleted from the set in this
context.

\subsubsection{Parser Standard Commands}
\label{PARSER-STANDARD-COMMANDS}

The {\em parser-standard-command}:
\begin{center}
\TT{define standard} ~~ {\em standard-flag-spec}\QMARK{}
\end{center}
executes builtin parser commands that together define the
\key{standard parser}.  If the {\em standard-flag-spec}
is omitted, all such commands are executed.  Otherwise
only those selected by the {\em standard-flag-spec}
are executed.

The flags specified by the {\em standard-flag-spec}
are called {\em standard-flags} and are defined in
Figure~\ref{STANDARD-FLAGS}.  There are two kinds of
flags: \smkey{component}s{standard} which execute
parser commands, and \smkey{qualifier}s{standard} which
modify the components.  In the Figure, the qualifiers
that modify a component are listed in [] brackets after
the component definition.  E.g., the {\tt math} qualifier
modifies the actions of the {\tt brackets} component
which defines standard untyped brackets.

\begin{center}
\begin{tabular}{c}
{\bf Standard `\ttkey{block}'\label{STANDARD-BLOCK} Component
     Parser Command}
\\[1ex]
\tt begin block standard
\end{tabular}
\end{center}

If this is executed, standard parser definitions can be
canceled by an `\TT{end block standard}' parser command.

\begin{boxedfigure}[!t]

\begin{center}

{\bf \large Standard Qualifiers}

\medskip

\begin{tabular}{rp{4.2in}}

\ttmkey{code}{parser standard flag} &
    Enables definitions using the `\TT{code}' selector.
    (\pagref{STANDARD-SELECTORS}).
\\
\ttmkey{text}{parser standard flag} &
    Enables definitions using the `\TT{text}' selector.
    (\pagref{STANDARD-SELECTORS}).
\\
\ttmkey{math}{parser standard flag} &
    Enables definitions using the `\TT{math}' selector.
    (\pagref{STANDARD-SELECTORS}).
\\
\ttmkey{id}{parser standard flag} &
    Enables identifier definitions (e.g., `\TT{@}').
\\
\ttmkey{table}{parser standard flag} &
    Enables table definitions (e.g., `\TT{\{table\}}').

\end{tabular}

\medskip

{\bf \large Standard Components}

\medskip

\begin{tabular}{rp{3.6in}}

\ttmkey{block}{parser standard flag} &
    Executes a `\TT{begin block standard}' command \\
    & (\pagref{STANDARD-BLOCK}).
\\
\ttmkey{top level}{parser standard flag} &
    Executes top level definitions
    (\pagref{STANDARD-TOP-LEVEL-1})
    and ID character definitions (\pagref{STANDARD-TOP-LEVEL-2}).
    [code,text,math,id,table]
\\
\ttmkey{concatenator}{parser standard flag} &
    Executes concatenator definitions
    (\pagref{STANDARD-CONCATENATOR-1}) and
    middle break definitions
    (\pagref{STANDARD-CONCATENATOR-2}).
\\
\ttmkey{lexeme map}{parser standard flag} &
    Executes lexeme map definitions
    (\pagref{STANDARD-LEXEME-MAP}).  [id,table]
\\
\ttmkey{brackets}{parser standard flag} &
    Executes untyped bracket definitions
    (\pagref{STANDARD-BRACKETS-1}) and
    typed bracket definitions
    (\pagref{STANDARD-BRACKETS-2}) [code,text,math]
\\
\ttmkey{indentation marks}{parser standard flag} &
    Executes indentation mark definitions
    (\pagref{STANDARD-INDENTATION-MARKS}).
\\
\ttmkey{bracket types}{parser standard flag} &
    Executes bracket type definitions
    (\pagref{STANDARD-BRACKET-TYPES}).
\\
\ttmkey{control operators}{parser standard flag} &
    Executes control operator definitions
    (\pagref{STANDARD-CONTROL-OPERATORS}).  [code]
\\
\ttmkey{iteration operators}{parser standard flag} &
    Executes iteration operator definitions
    (\pagref{STANDARD-ITERATION-OPERATORS}).  [code]
\\
\ttmkey{assignment operators}{parser standard flag} &
    Executes assignment operator definitions
    (\pagref{STANDARD-ASSIGNMENT-OPERATORS}). \\
    & [code,math]
\\
\ttmkey{logical operators}{parser standard flag} &
    Executes logical operator definitions
    (\pagref{STANDARD-LOGICAL-OPERATORS}). \\
    & [code,math]
\\
\ttmkey{comparison operators}{parser standard flag} &
    Executes comparison operator definitions
    (\pagref{STANDARD-COMPARISON-OPERATORS}). \\
    & [code,math]
\\
\ttmkey{arithmetic operators}{parser standard flag} &
    Executes arithmetic operator definitions
    (\pagref{STANDARD-ARITHMETIC-OPERATORS}). \\
    & [code,math]
\\
\ttmkey{bitwise operators}{parser standard flag} &
    Executes bitwise operator definitions
    (\pagref{STANDARD-BITWISE-OPERATORS}).  [code]
\\
\end{tabular}

\end{center}

\caption{\bf Parser Standard Flags}
\label{STANDARD-FLAGS}
\end{boxedfigure}


\subsubsection{Parser Selector Commands}
\label{PARSER-SELECTOR-COMMANDS}

The only builtin selector names\label{SELECTOR-NAMES}
are `\ttkey{TOP LEVEL}', `\ttkey{LINE LEVEL}',
`\ttkey{data}', and `\ttkey{atom}'.
Other selector names must be defined by the {\em parser-selector-command}:
\begin{center}
    \ttmkey{define selector}{parser command} ~ {\em selector}
\end{center}
When the parser block containing a selector name definition
command ends, the selector name is erased.
There may be at most 43 selectors, including the builtin selectors,
defined at any one time.

The selector print command:
\begin{center}
    \ttmkey{print selector}{parser command} ~ {\em partial-name}
\end{center}
prints all selectors whose names contain the {\em partial-name}.
In particular,
\begin{center}
    \TT{print selector ""}
\end{center}
prints all selectors.
The block in which each selector is defined is also printed.
Here a {\em partial-name} is a sequence of lexemes that is matched
to any subsequence of lexemes in a selector name, not just an initial
subsequence.  There is \underline{no} matching of partial lexemes.

\begin{center}
\begin{tabular}{l}
\multicolumn{1}{c}
{\bf Initial Parser Selector Commands}
\\[1ex]
\tt define selector TOP LEVEL \\
\tt define selector LINE LEVEL \\
\tt define selector data \\
\tt define selector atom \\
\end{tabular}
\\[2ex]
\begin{tabular}{l@{\hspace*{0.5in}}l}
\multicolumn{2}{c}
{\bf Standard Parser Selector Commands\label{STANDARD-SELECTORS}}
\\[1ex]
Parser Command				& Given
\\\hline
\tt define selector code & {\tt + code} qualifier and
                           `\TT{code}' selector is used \\
\tt define selector text & {\tt + text} qualifier and
                           `\TT{text}' selector is used \\
\tt define selector math & {\tt + math} qualifier and
                           `\TT{math}' selector is used \\
\end{tabular}
\end{center}

If a selector qualifier is given, but the selector is not used
in any executed standard parser command, the selector will not
be created.

If a selector qualifier (e.g. `{\tt + math}') is not given,
the corresponding selector (e.g. `{\tt math}') will be automatically deleted
from every standard parser command containing it, and if this makes
the command meaningless, the command will be automatically ignored
and not executed.  E.g., the command
\begin{indpar}[0.1in]\begin{verbatim}
define bracket "{{" ... "}}" [code, text, math]
      with parsing selectors [ + math, - code, - text ]
\end{verbatim}\end{indpar}
will be ignored if the `{\tt + math}' standard qualifier was not given.


\subsubsection{Parser Top Level Commands}
\label{PARSER-TOP-LEVEL-COMMANDS}

\ikey{Top level parsing}{top level parsing}
of a file recognizes top level logical lines and headed paragraphs
as if they were in
an indented paragraph, called the \key{top level indented paragraph}.
Each logical line or headed paragraph is formed into a MIN object
which is processed as it is produced, and is not combined into a
bigger object by the parser.

In particular, a top level logical
line that contains parser commands is parsed first, and then executed
to change parser tables.  These changes are then in effect for
parsing subsequent logical lines or headed paragraphs.
Each \TT{begin block} command effectively creates a new top level
indented paragraph and the corresponding \TT{end block} command terminates
this paragraph.  After each logical line that contains parser commands,
the top level indented paragraph of the innermost parsing block that
has not ended is resumed.

The parameters of the current top level indented paragraph can be modified
by \ttkey{define top level} commands
and printed by the \ttkey{print top level}
command.

Note that logical lines containing parser commands must be top level,
and parameters of indented paragraphs that are not top level cannot
be modified.

The parsing selectors and parsing options
in effect at the beginning of a top level logical line not inside
a headed paragraph are those of the
current top level indented paragraph, and can be modified or set by:
\begin{center}
    \begin{tabular}[t]{l}
    \ttmkey{define top level}{parser command} ~
    \TT{parsing selectors} {\em selector-spec} \\
    \TT{define top level parsing options} ~ {\em top-level-options} \\
    \end{tabular}
\end{center}
as per Figure~\itemref{PARSER-COMMAND-SYNTAX-2}.
Note that the selectors \TT{TOP LEVEL}\label{TOP-LEVEL-SELECTOR}
and \TT{LINE LEVEL} are automatically set at the beginning of
every such top level logical line, and cannot be set or modified
by \TT{define top level} commands.

By default the \TT{TOP LEVEL} selector is cleared
when indented paragraphs or bracketed subexpressions are being parsed,
and the \TT{LINE LEVEL} selector is cleared by default when
bracketed subexpressions are being parsed.  While these defaults
may be overridden, great care must be taken in doing so.

Either of the two lexical master parameters (\pagref{LEXICAL-MASTER-PARAMETERS})
can be set by the commands:
\begin{center}
    \begin{tabular}[t]{l}
    \TT{define top level paragraph lexical master} ~
        {\em lexical-master-name} \\
    \TT{define top level line lexical master} ~
        {\em lexical-master-name} \\
    \TT{define top level lexical master} ~
        {\em lexical-master-name} \\
    \end{tabular}
\end{center}
The first command sets the paragraph lexical master,
the second command sets the line lexical master, and
and the third command
sets both lexical master parameters to the same value.

Indented paragraphs have optional line separators (\pagref{LINE-SEPARATOR}),
and the line separator of the current top level indented paragraph can be
set by:
\begin{center}
    \begin{tabular}[t]{l}
    \ttmkey{define top level line separator}{parser command} ~
           {\em quoted-key} \\
    \TT{define top level line separator NONE} \\
    \end{tabular}
\end{center}
The first command sets the line separator, and the second disables
it.

Top level implied headers are always missing and cannot be set.

The top level print command:

\begin{center}
\ttmkey{print top level}{parser command}
\end{center}

prints the top level indented paragraph parameters for the
the innermost current parsing block.  However, each extant
parsing block has its own set of top level indented paragraph
parameters, and these are stored in virtual indentation mark
data definitions that can be printed by:

\begin{center}
\ttmkey{print indentation mark "*TOP* *LEVEL*"}{parser command}
\end{center}


See \itemref{INDENTED-PARAGRAPH-SUBEXPRESSIONS} for more
indented paragraph parameter details.

When the parser is initialized the top level
indented paragraph has no parsing selectors
or lexical masters and has the
`\TT{default}' parsing options (\pagref{DEFAULT-OPTIONS}).

\begin{center}
\begin{tabular}{l}
\multicolumn{1}{c}
{\bf Initial Top Level Parser Commands}
\\[1ex]
\tt define top level parsing selectors [data] \\
\tt define top level parsing options [default end at options] \\
\tt define top level line separator NONE \\
\tt define top level lexical master DEFAULT \\
\end{tabular}
\\[2ex]
\begin{tabular}{l@{\hspace*{0.5in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{top level}'\label{STANDARD-TOP-LEVEL-1} Component
     Parser Commands}
\\[1ex]
Parser Command				& Given Qualifiers
\\\hline
\tt define top level parsing selectors  & \tt + code \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~[+ code] \\
\tt define top level parsing selectors  & \tt - code, + text \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~[+ text] \\
\tt define top level parsing selectors  & \tt - code, - text, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~[+ math]   & \tt ~~~~~~~~+ math \\
\tt define top level parsing selectors  & \tt - code, - text, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~[+ data]   & \tt ~~~~~~~~- math \\
\tt define top level line separator ";" & \tt + code \\
\tt define top level paragraph lexical & \tt + id, + table \\
\tt ~~~~~~~master PARAGRAPH-CHECK \\
\tt define top level paragraph lexical & \tt - id, + table \\
\tt ~~~~~~~master TABLE-CHECK \\
\tt define top level paragraph lexical & \tt + id, - table \\
\tt ~~~~~~~master DATA-CHECK \\
\tt define top level line lexical & \tt + id \\
\tt ~~~~~~~master DATA-CHECK \\
\end{tabular}
\end{center}



\subsubsection{Parser Input Commands}
\label{PARSER-INPUT-COMMANDS}

The current set of
\skey{parsing input flag}s\index{input flag!parser}\index{flag!parsing input}
may be given or modified by the {\em parser-input-command}:
\begin{center}
    \ttmkey{input}{parser command} ~ {\em input-flag-spec}
\end{center}
Input flags modify how the parser inputs lexemes.
The input flag names are builtin and are listed
in Figure~\itemref{INPUT-FLAGS}.

\begin{boxedfigure}[!t]

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttmkey{enable numeric words}{parsing input flag} ~
    Any {\em numeric-word}, {\em natural}, or {\em number} lexeme
    whose value is a \TT{NaN} or infinity is retyped as a
    {\em numeric word} if this flag is set.  If cleared, the lexeme
    is retyped as a {\em number}.

\hspace*{-0.2in}\ttmkey{enable naturals}{parsing input flag} ~
    Any {\em numeric-word}, {\em natural}, or {\em number} lexeme
    whose value is an integer in the range $[0,10^9)$  is retyped as a
    {\em natural} if this flag is set.  If cleared, the lexeme
    is retyped as a {\em number}.

\hspace*{-0.2in}\ttmkey{enable integer commas}{parsing input flag}
    If set, commas are allowed every 3 digits in the integer part
    of a numeric lexeme formatted as a C++ number not ending in `\TT{.}'.
    See \pagref{COMMAS-IN-NUMERICS}.

\hspace*{-0.2in}\ttmkey{enable fraction commas}{parsing input flag}
    If set, commas are allowed every 3 digits in the fraction part
    of a numeric lexeme formatted as a C++ number not ending in `\TT{.}'.
    See \pagref{COMMAS-IN-NUMERICS}.

\end{indpar}

\bigskip

\caption{\bf Parsing Input Flags}
\label{INPUT-FLAGS}
\end{boxedfigure}

A {\em numeric} lexeme containing commas\label{COMMAS-IN-NUMERICS}
that has the format of a C++ number
not ending in `\TT{.}' is made into a {\em number} lexeme by removing the
commas provided the commas are allowed as per the \TT{enable integer commas}
and \TT{enable fraction commas} input flags.

Lexemes\label{NUMBER-LEXEME-RETYPING}
whose values are IEEE double precision floating point numbers
are retyped according to the \TT{enable numeric words} and
\TT{enable naturals} input flags.

When a parser is initialized, its \TT{enable numeric words} 
and \TT{enable naturals} flags are set, and
all the other input flags are cleared.

The print command:
\begin{center}
    \ttmkey{print input}{parser command}
\end{center}
prints the state of the current parser input flags.

The end of a parser block erases the effects of any
{\em parser-input-commands} executed during the block.

\newpage


\subsubsection{Parser Trace Commands}
\label{PARSER-TRACE-COMMANDS}

The current set of
\skey{parsing trace flag}s\index{trace flag!parser}\index{flag!parsing trace}
may be given or modified by the {\em parser-trace-command}:
\begin{center}
    \ttmkey{trace}{parser command} ~ {\em trace-flag-spec}
\end{center}
Trace flags cause trace printouts to the printer the parser uses
for error messages.  The trace flag names are builtin and are listed
in Figure~\itemref{TRACE-FLAGS}.

When a parser is initialized, its \TT{warnings} flag is set, and
all its other trace flags are cleared.

\begin{boxedfigure}[!b]

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttmkey{warnings}{parsing trace flag} ~
    Print warning messages when the parser detects a parse error.
    A warning message also indicates what action the parser took
    to `fix' the error.  This flag is set when the
    parser is initialized.

\hspace*{-0.2in}\ttmkey{parser input}{parsing trace flag} ~
    When the parser reads a token from the input,
    a description of the token is printed.

\hspace*{-0.2in}\ttmkey{parser output}{parsing trace flag}
    When the parser produces a output line token, the token value
    is printed.

\hspace*{-0.2in}\ttmkey{parser commands}{parsing trace flag}
    Upon successfully finishing the execution of a parser command,
    the command is printed (if the command is in error the error
    printout will print the command).

\hspace*{-0.2in}\ttmkey{bracketed subexpressions}{parsing trace flag}
    Enables tracing for the parser bracketed subexpression recognition pass.

\hspace*{-0.2in}\ttmkey{operator subexpressions}{parsing trace flag}
    Enables tracing for the parser operator recognition pass.

\hspace*{-0.2in}\ttmkey{subexpression elements}{parsing trace flag}
    The printing of a value by the `\TT{parser output}' or
    `\ldots{} \TT{subexpressions}' trace flags, or of a logical line
    in a {\em parser-test-paragraph}, includes
    a direct rendition of the value with implicit brackets and
    graphic representations of non-graphic characters
    shown.  This is the default.

\hspace*{-0.2in}\ttmkey{subexpression details}{parsing trace flag}
    The printing of a value by the `\TT{parser output}' or
    `\ldots{} \TT{subexpressions}' trace flags, or of a logical line
    in a {\em parser-test-paragraph}, includes
    a detailed rendition of the value with all attributes shown.

\hspace*{-0.2in}\ttmkey{subexpression lines}{parsing trace flag}
    The printing of a value by the `\TT{parser output}' or
    `\ldots{} \TT{subexpressions}' trace flags, or of a logical line
    in a {\em parser-test-paragraph}, includes
    the lines containing the value with the value producing subexpression
    within these lines underlined.

\hspace*{-0.2in}\ttmkey{keys}{parsing trace flag}
    During parsing of a subexpression by a trace-enabled parser 
    pass, the keys found in the pass symbol tables are printed.
    If a key is rejected after being found, a rejection message
    is also printed.

\end{indpar}

\bigskip

\caption{\bf Parsing Trace Flags}
\label{TRACE-FLAGS}
\end{boxedfigure}


The print command:
\begin{center}
    \ttmkey{print trace}{parser command}
\end{center}
prints the state of the current parser trace flags.

The end of a parser block erases the effects of any
{\em parser-trace-commands} executed during the block.

\subsubsection{Parser Define/Undefine Commands}
\label{PARSER-DEFINE/UNDEFINE-COMMANDS}

In the following sections various parser symbol table `\ttkey{define}' commands
are described.  These push entries into the parser symbol tables.
The general syntax of these is
\begin{center}
\TT{define} {\em type} {\em name} {\em selectors} \ldots 
\end{center}
and an example is
\begin{center}
\TT{define bracket "("~...~")" [operator, text]} \ldots
\end{center}
The {\em type}, `\TT{bracket}' in the example, identifies the parser pass into
whose symbol tables entries are to be pushed.  The {\em name},
`\TT{"("~...~")"}' in the example, gives {\em quoted-keys} that become
the entry labels.  The {\em selectors},
`\TT{[operator, text]}' in the example, specify the selector set of
the entries to be pushed.

The end of a parser block pops all entries pushed into parser
symbol tables during the block.

For each parser symbol table \TT{define} command
there is a companion parser
\ttkey{undefine} command that effectively undoes
the parser \TT{define} command by clearing selector bits in
the designated symbol table entries.  Its syntax is
\begin{center}
\ttmkey{undefine}{parser-command} ~ {\em type} ~ {\em name} ~ {\em selectors}
\end{center}
and it clears the specified selector bits from \underline{all} symbol table
entries with the same {\em type} and {\em name}.  When the
block containing a parser \TT{undefine} command ends, the
effects of that command are undone by restoring the cleared
selector bits to their previous state.

Thus the end of a parser block erases the effects of any
parser \TT{define} and \TT{undefine} commands executed during the block.

\subsubsection{Parser Test Paragraph}
\label{PARSER-TEST-PARAGRAPH}

A {\em parser-test-paragraph} may be used to test the parser.
It is an indented paragraph on a top level logical line by itself
that has the indentation mark `\TT{*PARSER* *TEST:}'.
Thus `\TT{*PARSER* *TEST:}' must appear by itself in a top level
physical line, and the indented logical lines that follow are the
lines whose parsing is to be tested.

A {\em parser-test-paragraph} is first parsed using the current top
level selectors, and then information about the each logical line
of the paragraph is printed according to the setting of the
trace flags:
\begin{center}
\TT{subexpression elements} \\
\TT{subexpression details} \\
\TT{subexpression lines} \\
\end{center}

A {\em parser-test-paragraph} has no effect other than to produce
the indicated printout.

\subsection{Token Mapping}

When a token is created, it may be mapped by the parser input
routine in two ways.  An {\em ID} token is mapped to a preallocated
stub, and a mapped lexeme may be mapped to a MIN object.

\subsubsection{IDs}
\label{IDS}

An \key{ID} is a kind of variable with a \TT{min::gen} value.
The syntax of an ID is:

\begin{indpar}

\emkey{ID}\label{ID} ::= {\em numeric-ID} $|$ {\em symbolic-ID}
\\[0.5ex]
\emkey{numeric-ID} :::= {\em ID-character} ~ {\em ID-number}
\\[0.5ex]
\emkey{symbolic-ID} :::= {\em ID-character} ~ {\em ID-symbol}
\\[0.5ex]
\emkey{ID-character}\label{ID-CHARACTER} ::=
    \begin{tabular}[t]{l}
    a unicode character that is a parser parameter (see below); \\
    it must be a non-digit, non-letter that can begin a numeric
    or word \\
    should be `\TT{@}' unless the lexical analyzer is changed:
    see \pagref{SPECIAL-LEXEME}
    \end{tabular}
\\[0.5ex]
\emkey{ID-number} :::= {\em non-zero-ASCII-digit} ~ {\em ASCII-digit}\STAR{}
\\[0.5ex]
\emkey{ID-symbol} :::= ~ \TT{<} ~ {\em ASCII-letter} ~
                       {\em ASCII-letter-or-digit}\STAR{} ~ \TT{>}

\end{indpar}

An ID can be used before it is defined if it refers to
an object or a long string.  When this is done, the ID
is given a value that is a `\key{preallocated stub}'
that will be filled in later.  If an ID is given a \TT{min::gen}
value that is \underline{not} an object or long string,
the ID must be defined before it is used (otherwise any use
before the definition will become \key{dangling}).

The \TT{data} reformatter (\pagref{DATA-REFORMATTER}) is
used to define input IDs.  Printer formatting is used to
define output IDs.  The same format is used for input and
output definitions.  {\em Numeric-IDs} can be used for either input
or output, but {\em symbolic-IDs} can only be used for input.

When {\em numeric-IDs} are being used for output, their {\em ID-numbers}
are assigned automatically by the printer being used (each parser
has an associated printer).  You can
just output an object with a format that allows the object to
be represented by a {\em numeric-ID}, and if the object has
been previously assigned as the value of a {\em numeric-ID}, that will
be output instead of the object, whereas if the object has never
been assigned as the value of a {\em numeric-ID}, a new
{\em numeric-ID} will be created to point
to the object and output that instead of the object.  Separately
you can command the printer to output definitions of all the
{\em numeric-IDs} which it has created in this manner.

For each printer there is a one-to-one correspondence between
objects whose {\em numeric-IDs} have been output and the objects,
so no object is ever referenced by two distinct {\em numeric-IDs}.
Each printer has an \key{ID map} which maintains this one-to-one
correspondence.

When {\em numeric-IDs} are being used for input, they are
defined relative to the lexeme scanner being used, and their
definitions must be in the input
(these definitions will be processed
by the \TT{data} reformatter: \pagref{DATA-REFORMATTER}).
However a {\em numeric-ID}
may be used in the input before its definition is input if
the {\em numeric-ID} references an object or long string.
An input {\em numeric-ID}
may be defined to have the same value as another input
{\em numeric-ID}.

{\em Numeric-IDs} once defined cannot be redefined.

{\em Symbolic-IDs} can be used for input after the same manner
that {\em numeric-IDs} are used for input.  But unlike
{\em numeric-IDs}, the symbolic ID table for a scanner can
be completely cleared, e.g., by inputting the mark `\TT{@@@@}'
at the beginning of line as per
\pagref{DATA-SPECIAL-LEXEME}\label{CLEAR-SYMBOLIC-TABLE}.
This allows {\em symbolic-IDs} to be
reused.

On input there are two separate ID maps, one for {\em numeric-IDs} and
one for {\em symbolic-IDs}.  Only the latter may be cleared.

An {\em ID} is recognized on input when its token is being constructed,
and its token value, which would normally be its lexeme string,
is replaced by its ID value, which is looked up in the parser's scanner's
ID map.  If there is no previous value, a preallocated
stub (see above) is created and assigned as the value.

The {\em ID-character} is a parser parameter that
can be defined
or printed by:
\begin{indpar}[0.1in]
\emkey{parser-ID-character-command}%
\label{PARSER-ID-CHARACTER-COMMAND} \\
\hspace*{3em} \begin{tabular}{rl}
              ::= & \ttmkey{define ID character}{parser command}
			  ~ {\em ID-character-representative} \\
              $|$ & \ttmkey{print ID}{parser command} \\
	      \end{tabular}
\\[0.5ex]
\emkey{ID-character-representative} ::=
     {\em quoted-character} $|$ \TT{disabled}
\\[0.5ex]
\emkey{quoted-character} ::=
    {\em quoted-string} with exactly one {\em character-representative}.
\end{indpar}

\begin{center}
\begin{tabular}{l}
\multicolumn{1}{c}{\bf Initial ID Character Parser Command}
\\[1ex]
\tt define ID character disabled \\
\end{tabular}
\\[2ex]
\begin{tabular}{l@{\hspace*{0.5in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{top level}'\label{STANDARD-TOP-LEVEL-2} Component
     ID Character Parser Command}
\\[1ex]
Parser Command				& Given Qualifiers
\\\hline
\tt define ID character "@"             & \tt + id \\
\end{tabular}
\end{center}

However, the {\em ID-character} `\TT{@}' is also built into the part of the
input lexical scanner that generates the special lexemes
\TT{DATA} and \TT{RAW-DATA}, which in turn are mapped
(\itemref{MAPPED-LEXEMES}) to prefixes that invoke the
\TT{data} reformatter (\pagref{DATA-REFORMATTER}),
so changing the {\em ID-character} will not work well for input unless
the lexical scanner is also changed.

\subsubsection{Mapped Lexemes}
\label{MAPPED-LEXEMES}

A `\key{mapped-lexeme}' is a special kind of lexeme that has its
own special lexeme type which allows a token with this type to be
mapped by the `\key{mapped lexeme symbol table}' to a token with
a different type and value.  For example, a token with special
lexeme type \TT{DATA} can be mapped to a \TT{PREFIX} type token
with value `\TT{\{data\}}'.

Entries in the mapped lexeme symbol table are managed by
{\em parser-mapped-lexeme-commands}:

\begin{indpar}[0.1in]
\emkey{parser-mapped-lexeme-command}%
\label{PARSER-MAPPED-LEXEME-COMMAND} \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define}%
          \ttmindex{define mapped lexeme}{parser command}
	  \begin{tabular}[t]{@{}l@{}}
	  \TT{~mapped lexeme} ~ {\em lexeme-type-name} ~
	                       {\em parsing-selectors} \\
	  {}[ \TT{with token value} ~ {\em token-value} ] \\
	  {}[ \TT{with lexical master} ~ {\em lexical-master-name} ] \\
	  \end{tabular} \\
    $|$ & \ttmkey{undefine mapped lexeme}{parser command} ~
	  {\em lexeme-type-name} ~ {\em parsing-selectors} \\
    $|$ & \ttmkey{print mapped lexeme}{parser command} ~
	  {\em partial-lexeme-type-name}  \\
    \end{tabular} \\[1ex]
    \hspace*{0.2in}
     NOTE: The \TT{with \ldots} clauses can appear in any order.
\label{MAPPED-LEXEME-DEFINITION}
\\[0.5ex]
\emkey{lexeme-type-name} ::= {\em quoted-key}
\\[0.5ex]
\emkey{partial-lexeme-type-name} ::= {\em quoted-key}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\\[0.5ex]
\emkey{token-value}
    \begin{tabular}[t]{rl}
    ::= & {\em typed-bracketed-subexpression} \\
    $|$ & {\em typed-prefix-separator} \\
    $|$ & {\em untyped-bracketed-subexpression} \\
    \end{tabular}
\\[0.5ex]
\emkey{lexical-master-name} ::= {\em quoted-key}
                    $|$ {\em simple-name} not containing `\TT{with}'
\end{indpar}

Special lexemes do not (usually) have any associated character string,
but they do have their own unique lexeme type.  Although special
lexemes indicate the presence of particular characters in the input,
scanning a special lexeme (usually) will not consume most of these characters,
which will then appear in the non-special lexeme that follows the
special lexeme.

The standard special lexeme types:

\begin{indpar}

\ttmkey{DATA}{special lexeme}\label{DATA-SPECIAL-LEXEME}
\begin{indpar}
Output by the \TT{DATA-\EOL CHECK} and \TT{PARAGRAPH-\EOL CHECK}
lexical masters when the next input characters are
`\TT{@{\em D}}', `\TT{@<}', or `\TT{@@@@}', where {\em D}
is a non-zero ASCII digit.
The recognized input characters become the first characters of the next lexeme.
Typically mapped to the `\TT{\{data\}}' prefix separator.
\end{indpar}

\ttmkey{RAW-DATA}{special lexeme}
\begin{indpar}
Output by the \TT{DATA-\EOL CHECK} and \TT{PARAGRAPH-\EOL CHECK}
lexical masters when the next input characters are
`\TT{!@{\em D}}' or `\TT{!@<}'.
The `\TT{!}' is discarded and the other recognized input
characters become the
first characters of the next lexeme.
Typically mapped to the `\TT{\{raw data\}}' prefix separator.
\end{indpar}

\ttmkey{TABLE}{special lexeme}
\begin{indpar}
Output by the \TT{PARAGRAPH-\EOL CHECK} and \TT{TABLE-\EOL CHECK}
lexical masters
when the next 5 input characters are either `\TT{-{}-{}-{}-{}-}' or
`\TT{=====}'.
The next input character becomes the first character of the next lexeme.
Typically mapped to the `\TT{\{table\}}' prefix separator.
\end{indpar}

\ttmkey{ROW}{special lexeme}
\begin{indpar}
Output by the \TT{ROW-\EOL CHECK} lexical master when the next
input character is `\TT{|}', `\TT{-}', or `\TT{=}'.
This next input character becomes the first character of the next lexeme.
Typically mapped to the `\TT{\{row\}}' prefix separator.
\end{indpar}

\end{indpar}

The standard lexical masters that recognize special lexemes all
branch to the standard \TT{DEFAULT} lexical master after finding a
single special lexeme, or if there is no special lexeme in the
input.  The standard lexical masters are as follows, where
{\em D} is a non-zero ASCII digit:

\begin{center}
\begin{tabular}{l@{\hspace{0.4in}}lll}
			& Special Lexeme	& Special Lexeme & Characters \\
Lexical Master Name	& Trigger Characters	& Lexical Type   & Discarded
\\\hline
\\[0.5ex]
\TT{PARAGRAPH-CHECK}	& \TT{@{\em D}} ~~~ \TT{@<} ~~~ \TT{@@@}
						& \TT{DATA}	& none \\
			& \TT{!@{\em D}} ~~~ \TT{!@<}
						& \TT{RAW-DATA} & \TT{!} \\
			& \TT{-{}-{}-{}-{}-}	& \TT{TABLE}	& none \\
			& \TT{=====}		& \TT{TABLE}	& none
\\[2ex]
\TT{DATA-CHECK}		& \TT{@{\em D}} ~~~ \TT{@<} ~~~ \TT{@@@}
						& \TT{DATA}	& none \\
			& \TT{!@{\em D}} ~~~ \TT{!@<}
						& \TT{RAW-DATA} & \TT{!} \\
\\[2ex]
\TT{TABLE-CHECK}	& \TT{-{}-{}-{}-{}-}	& \TT{TABLE}	& none \\
			& \TT{=====}		& \TT{TABLE}	& none
\\[2ex]
\TT{ROW-CHECK}		& \TT{|}		& \TT{ROW}	& none \\
			& \TT{-}		& \TT{ROW}	& none \\
			& \TT{=}		& \TT{ROW}	& none
\\[2ex]
\TT{DEFAULT}		& \multicolumn{2}{@{}l}{does not recognize any special lexemes}
\end{tabular}
\end{center}


When the bracketed subexpression parser first sees a lexeme it
creates a token for that lexeme, setting the token type to the
lexical type of the lexeme.  The parser then looks this type
up in the mapped lexeme symbol table, selecting entries active
according to the top level parser selectors as set by
\TT{define top level parsing selectors} (\pagref{DEFINE-TOP-LEVEL}) (these are
\underline{not} the current parser selectors as modified by
brackets and indentations).  If an entry is found,
it is used to replace the token's type and value, and optionally
to change the lexical master that will scan the next lexeme.

If the mapped lexeme symbol table entry
has no {\em lexical-master-name}, the lexical master
is not changed, which for standard lexical masters means the
next lexeme will be scanned by the default lexical master.
If the entry has no {\em token-value}
(i.e., the entry's `{\tt define mapped lexeme ...}' command
has no `{\tt with token value ...}' modifier),
the token which selected the entry is deleted, though the
lexical master may still be changed.

When a token value is changed by this process, the token is
given a new token type computed from the new token value.%
\label{MAPPED-LEXEME-TOKEN-TYPE}
If the {\em token-value} is an object with a \TT{.type} but
no elements, no \TT{.initiator}, and no \TT{.terminator},
the token is given the \TT{PREFIX} token type.
If the {\em token-value} is an object with no \TT{.type},
 no \TT{.initiator}, and no \TT{.terminator},
the token is given the \TT{BRACKETABLE} token type.
Otherwise if the {\em token-value} is an object it is given
the \TT{BRACKETED} token type.
If the {\em token-value} is not an object, it is given the token
type \TT{DERIVED}.

A mapped lexeme is called a `\key{header lexeme}' if the parser
symbol tables are configured so that the lexeme is only
produced by looking
at the first non-whitespace characters of a logical line and does
not actually consume any of the characters it looks at.
So for example, if the line begins with `\TT{========}',
a \TT{TABLE} header lexeme indicating
a table paragraph might be produced, followed by a \TT{ROW} header lexeme
indicating a table row line, but none of the line beginning `\TT{=}'
characters will be skipped over while producing these header lexemes.
In short, the scanner will peek ahead but not read ahead when
producing header lexemes, as is normal for all mapped lexemes.
Header lexemes are used to introduce
headed paragraphs (\itemref{HEADED-PARAGRAPHS})
and headed lines (\itemref{HEADED-LINES}).


When a parser is initialized, no lexemes are mapped,
and the parser's paragraph and
line top level lexical masters (\pagref{LEXICAL-MASTER-PARAMETERS})
are both set to the \TT{DEFAULT} lexical master
which does \underline{not} recognize special lexemes.

\begin{center}
\begin{tabular}{l@{\hspace*{0.5in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{lexeme map}'\label{STANDARD-LEXEME-MAP} Component
     Mapped Lexeme Parser Commands}
\\[1ex]
Parser Command				& Given Qualifiers
\\\hline
\tt define mapped lexeme "DATA" [TOP LEVEL]		& \tt + id \\
\tt ~~~~~~~with token value \{data\} \\
\tt define mapped lexeme "RAW-DATA" [TOP LEVEL]		& \tt + id \\
\tt ~~~~~~~with token value \{raw data\} \\
\tt define mapped lexeme "TABLE" [TOP LEVEL]		& \tt + table \\
\tt ~~~~~~~with token value \{table\} \\
\tt define mapped lexeme "ROW" [TOP LEVEL]		& \tt + table \\
\tt ~~~~~~~with token value \{row\} \\
\end{tabular}
\\[2ex]
\begin{tabular}{l@{\hspace*{0.5in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{top level}' Component
     Parser Commands (as per \pagref{STANDARD-TOP-LEVEL-1} and
                          \pagref{STANDARD-TOP-LEVEL-2})}
\\[1ex]
Parser Command				& Given Qualifiers
\\\hline
\tt define top level paragraph lexical & \tt + id, + table \\
\tt ~~~~~~~master PARAGRAPH-CHECK \\
\tt define top level paragraph lexical & \tt - id, + table \\
\tt ~~~~~~~master TABLE-CHECK \\
\tt define top level paragraph lexical & \tt + id, - table \\
\tt ~~~~~~~master DATA-CHECK \\
\tt define top level line lexical & \tt + id \\
\tt ~~~~~~~master DATA-CHECK \\
\tt define ID character "@" 		& \tt + id \\
\end{tabular}
\end{center}

\subsection{The Bracketed Subexpression Recognition Pass}
\label{BRACKETED-SUBEXPRESSION-RECOGNITION-PASS}

The bracketed subexpression recognition pass recognizes:
\begin{indpar}[0.5in]
\hspace*{-0.2in}indented paragraphs, consisting of a line-ending
    indentation mark (e.g.~`\TT{:}') followed by a sequence of
    indented logical lines, ended by a non-indented line or end
    of file: \itemref{INDENTED-PARAGRAPH-SUBEXPRESSIONS}
\\[0.5ex]
\hspace*{-0.2in}logical lines, which may end with any line break,
    or with a line break not followed by an indented line,
    or with a line break followed by a counter-indented line,
    or with a line separator (e.g.~`\TT{;}'),
    or with any blank line, or with an end of file:
    \itemref{LOGICAL-LINES}
\\[0.5ex]
\hspace*{-0.2in}brackets (e.g.~`\TT{(}' and `\TT{)}')
    and bracketed subexpressions, which must be inside logical lines:
    \itemref{UNTYPED-BRACKETED-SUBEXPRESSIONS}
\\[0.5ex]
\hspace*{-0.2in}typed brackets (e.g.~`\TT{\{b|}' and `\TT{|b\}}')
    and typed bracketed subexpressions, which must be inside logical lines:
    \itemref{TYPED-BRACKETED-SUBEXPRESSIONS}
\\[0.5ex]
\hspace*{-0.2in}typed prefix separators (e.g.~`\TT{\{p\}}')
    and prefix lists that are lists of subexpressions between
    typed prefix separators, which must be inside logical lines:
    \itemref{TYPED-PREFIX-SEPARATORS}
\\[0.5ex]
\hspace*{-0.2in}paragraph and line headers, which are specials kinds of
    typed prefix separators:
    \itemref{HEADED-PARAGRAPHS} and \itemref{HEADED-LINES}
\\[0.5ex]
\hspace*{-0.2in}mapped lexemes, which are special lexemes typically
    produced at the beginning of a logical line that are mapped onto
    paragraph or line headers or other typed prefix separators:
    \itemref{MAPPED-LEXEMES}
\\[0.5ex]
\hspace*{-0.2in}headed lines, which are logical lines beginning with
    a line header:
    \itemref{HEADED-LINES}
\\[0.5ex]
\hspace*{-0.2in}headed paragraphs,
    which are sequences of logical lines
    ended by a blank line, by the next headed paragraph,
    or by the end of a containing indented paragraph,
    where the whole headed paragraph begins with a paragraph
    header:
    \itemref{HEADED-PARAGRAPHS}
\\[0.5ex]
\hspace*{-0.2in}broken middle lexemes,
    whose parts need to be merged together:
    \itemref{MIDDLE-LEXEME-BREAKS}
\\[0.5ex]
\hspace*{-0.2in}split quoted strings,
    whose parts need to be merged together:
    \itemref{QUOTED-STRING-CONCATENATION}
\end{indpar}

The bracketed parser pass has three symbol tables:
\begin{indpar}[0.3in]
Bracketed Symbol Table.\label{BRACKETED-SYMBOL-TABLE}
Contains multi-lexeme keys found in
the input: \\
\hspace*{0.2in}opening brackets (e.g.~`\TT{(}') and
    corresponding closing brackets (e.g.~`\TT{)}'):
    \itemref{UNTYPED-BRACKETED-SUBEXPRESSIONS}
\\[0.5ex]
\hspace*{0.2in}indentation marks (e.g.~`\TT{:}')
    and corresponding line separators (e.g.~`\TT{;}'):
    \itemref{INDENTED-PARAGRAPH-SUBEXPRESSIONS}
\\[0.5ex]
\hspace*{0.2in}typed
      \begin{tabular}[t]{@{}ll}
      openings (e.g.~`\TT{\{}') &
      corresponding closings (e.g.~`\TT{\}}') \\
      middles (e.g.~`\TT{|}') &
      attribute begins (e.g.~`\TT{:}') \\
      attribute separators (e.g.~`\TT{,}') &
      attribute equals (e.g.~`\TT{=}') \\
      attribute negators (e.g.~`\TT{not}'): &
      \itemref{TYPED-BRACKETED-SUBEXPRESSIONS}
      \end{tabular}
\\[1ex]
Bracket Type Symbol Table. Contains information about bracket types:
\itemref{BRACKET-TYPE-DEFINITIONS}
\\[1ex]
Mapped Lexeme Symbol Table.  Maps some lexeme types to
bracketed subexpressions that replace the lexemes: \itemref{MAPPED-LEXEMES}
\end{indpar}

In bracketed subexpression recognition, 
multi-lexeme keys in the bracketed symbol table
are not recognized in the
input if their lexemes are not all on the same physical line.
This is different from other parser passes, which are executed
after line breaks have been removed.

Also bracketed symbol table entries should avoid keys
that contain multi-character lexemes that end with {\em middle-break-begin}
or begin with {\em middle-break-end} (see \itemref{MIDDLE-LEXEME-BREAKS}).
If such keys are used, they may
not be recognized, or broken {\em middle-lexeme} parts may be misrecognized
as parts of keys.

Like other parser passes, the bracketed subexpression recognition pass uses
parsing selectors and parsing options.
However, the bracketed subexpression recognition pass
is the only pass that can change these selectors and options.  Details are in
the following subsections.

In addition the bracketed subexpression recognition pass maintains
the parser current paragraph indent, which indicates how much
lines in the current paragraph should be indented.  This indent
may be changed by an indentation mark
(see \itemref{INDENTED-PARAGRAPH-SUBEXPRESSIONS}).

Syntactically a {\em bracketed-subexpression} may take many forms:

\begin{indpar}[0.1in]
\emkey{bracketed-subexpression}
    \begin{tabular}[t]{@{}rll@{}}
    ::= & {\em untyped-bracketed-subexpression}
        & see \itemref{UNTYPED-BRACKETED-SUBEXPRESSIONS} \\
    $|$ & {\em indented-paragraph-subexpression}
	& see \itemref{INDENTED-PARAGRAPH-SUBEXPRESSIONS} \\
    $|$ & {\em typed-bracketed-subexpression}
        & see \itemref{TYPED-BRACKETED-SUBEXPRESSIONS} \\
    $|$ & {\em typed-prefix-separator}
	& see \itemref{TYPED-PREFIX-SEPARATORS} \\
    $|$ & {\em prefix-n-list}
	& see \pagref{PREFIX-N-LIST} in \itemref{TYPED-PREFIX-SEPARATORS} \\
    $|$ & implied paragraph and line headers
	& see \itemref{HEADED-PARAGRAPHS} \\
    $|$ & mapped lexemes
	& see \itemref{MAPPED-LEXEMES} \\
    $|$ & {\em headed-lines}
	& see \itemref{HEADED-LINES} \\
    $|$ & {\em headed-paragraphs}
	& see \itemref{HEADED-PARAGRAPHS} \\
    \end{tabular}
\end{indpar}

However, some of these forms can only be recognized in particular
contexts, e.g., {\em indented-para\-graph-subexpressions} can only be
recognized if their beginning indentation mark is at the end of a physical line
or just before a comment that ends a physical line.
See the indicated sections for details.

The parser commands specific to the bracketed subexpression recognizer
are similarly divided:

\begin{indpar}[0.1in]
\emkey{parser-bracketed-command}
    \begin{tabular}[t]{@{}rll@{}}
    ::= & {\em parser-quoted-string-concatenator-command}
        & see \pagref{PARSER-QUOTED-STRING-CONCATENATOR-COMMAND} \\
    $|$ & {\em parser-middle-break-command}
        & see \pagref{PARSER-MIDDLE-BREAK-COMMAND} \\
    $|$ & {\em parser-untyped-bracket-command}
        & see \pagref{PARSER-UNTYPED-BRACKET-COMMAND} \\
    $|$ & {\em parser-indentation-mark-command}
        & see \pagref{PARSER-INDENTATION-MARK-COMMAND} \\
    $|$ & {\em parser-typed-bracket-command}
        & see \pagref{PARSER-TYPED-BRACKET-COMMAND} \\
    $|$ & {\em parser-bracket-type-command}
        & see \pagref{PARSER-BRACKET-TYPE-COMMAND} \\
    $|$ & {\em parser-ID-character-command}
        & see \pagref{PARSER-ID-CHARACTER-COMMAND} \\
    $|$ & {\em parser-mapped-lexeme-command}
        & see \pagref{PARSER-MAPPED-LEXEME-COMMAND} \\
    \end{tabular}
\label{PARSER-BRACKETED-COMMAND}
\end{indpar}

The following subsections describe middle lexeme breaks,
quoted string concatenation, the output of the
bracketed subexpression parser pass, and
each different kind of
{\em brac\-keted-subexpression} and its related
{\em parser-bracketed-commands}.

\subsubsection{Middle Lexeme Breaks}
\label{MIDDLE-LEXEME-BREAKS}

The bracketed subexpression recognition pass merges middle lexemes%
\label{MIDDLE-LEXEME-MERGE}
if they are consecutive within a logical line,
the first ends with
a \key{middle break begin} (e.g., `\TT{\#}'), and the second begins with
a \key{middle break end} (e.g., `\TT{\#}').
The middle break begin and end are deleted from the concatenation.
Thus if logical lines end with a line break
but permit indented continuation lines, then
\begin{indpar}\begin{verbatim}
This is a continued-middle-#
    #lexeme.
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
This is a continued-middle-lexeme.
\end{verbatim}\end{indpar}

The middle break begin and end can be changed, or middle breaks can
be disabled, by the \TT{define middle break} command.  Middle breaks
of all current parser blocks can be printed by the \TT{print middle break}
command.  The syntax of these commands is:
\begin{indpar}[0.1in]
\emlkey{parser-middle-break}{-command}%
\label{PARSER-MIDDLE-BREAK-COMMAND} ::= \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{define middle break}{parser command}
		    ~ {\em middle-break-name} \\
    $|$ & \ttmkey{print middle break}{parser command} \\
    \end{tabular}
\\[0.5ex]
\emkey{middle-break-name} ::= \TT{"}{\em middle-break-begin}\TT{"}
			      \TT{...}{}
                              \TT{"}{\em middle-break-end}\TT{"}
		     $|$ \TT{disabled}
\\[0.5ex]
\emkey{middle-break-begin} :::=
    {\em mark} with at least 1 and at most 31 UTF-8 bytes
\\[0.5ex]
\emkey{middle-break-end} :::=
    {\em mark} with at least 1 and at most 31 UTF-8 bytes
\\[0.5ex]
{\em mark} ::= see \pagref{MARK}
\begin{indpar}
WARNING: {\em middle-break-begin} and {\em middle-break-end} must
be chosen so bracketed symbol table entries (\pagref{BRACKETED-SYMBOL-TABLE})
do not end with a {\em middle-break-begin} or begin with a
{\em middle-break-end}.
\end{indpar}
\end{indpar}

If {\em middle-break-name} is `\TT{disabled}', middle lexemes
are never merged.

The end of a parser block erases the effects of any
{\em define-middle-break-commands} executed during the block.

\begin{center}
\begin{tabular}{c}
\bf Initial Middle Break Parser Command
\\[1ex]
\tt define middle break disabled \\
\end{tabular}
\\[2ex]
\begin{tabular}{l@{\hspace*{0.5in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{concatenator}'\label{STANDARD-CONCATENATOR-1} Component
     Middle Break Parser Command}
\\[1ex]
Parser Command				& Given Qualifiers
\\\hline
\tt define middle break "\#" ... "\#'			& \tt + concatenator
\end{tabular}
\end{center}

\subsubsection{Quoted String Concatenation}
\label{QUOTED-STRING-CONCATENATION}

The bracketed subexpression recognition pass merges
quoted strings if they are in the same logical line and are
separated by one or two \skey{quoted string concatenator}s (e.g., `\TT{\#}').
Thus if logical lines permit indented continuation lines, then
\begin{indpar}\begin{verbatim}
"This is a longer sentence"#
    #" than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across physical line boundaries.
But there is an important case where there is not an exact equivalence
between the merged and unmerged versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

The quoted string concatenator can be changed or disabled by the
\TT{define quoted string concatenator} command.  Quoted string concatenators
of all current parser blocks can be printed by the
\TT{print quoted string concatenator} command.
The syntax of these commands is:
\begin{indpar}[0.1in]
\emlkey{parser-quoted-string}{-concatenator-command}%
\label{PARSER-QUOTED-STRING-CONCATENATOR-COMMAND} ::= \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttmlkey{define quoted string}{concatenator}{parser command}
		    ~ {\em quoted-string-concatenator} \\
    $|$ & \ttmlkey{print quoted string}{concatenator}{parser command} \\
    \end{tabular}
\\[0.5ex]
\emkey{quoted-string-concatenator} ::= {\em quoted-key} with a single component
		     $|$ \TT{disabled} $|$ \TT{enabled}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\end{indpar}

If {\em quoted-string-concatenator} is `\TT{disabled}', quoted strings
are never concatenated.  If it is `\TT{enabled}', consecutive
quoted strings are concatenated; that is, no concatenator lexeme
needs to be placed between the strings.

The end of a parser block erases the effects of any
{\em define-quoted-string-concatenator-commands} executed during the block.

\begin{center}
\begin{tabular}{c}
\bf Initial Quoted String Concatenator Parser Command
\\[1ex]
\tt define quoted-string-concatenator disabled \\
\end{tabular}
\\[2ex]
\begin{tabular}{l@{\hspace*{0.5in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{concatenator}'\label{STANDARD-CONCATENATOR-2} Component
     Quoted String Concatenator Parser Command}
\\[1ex]
Parser Command				& Given Qualifiers
\\\hline
\tt define quoted-string-concatenator "\#"	& \tt + concatenator
\end{tabular}
\end{center}

\subsubsection{Bracketed Subexpression Parser Pass Input}
\label{BRACKETED-SUBEXPRESSION-PARSER-PASS-INPUT}

The bracketed subexpression recognizer takes as input a stream
of tokens most of which are lexemes.  The exception are the
tokens generated by mapping lexemes, as per
\pagref{MAPPED-LEXEME-TOKEN-TYPE} in \itemref{MAPPED-LEXEMES}.

When the bracketed subexpression recognizer calls another pass,
e.g., the operator pass, to parse a sequence of tokens, that
other pass may return one or more \TT{BRACKETED},
\TT{BRACKETABLE}, \TT{PURELIST}, or \TT{DERIVED} tokens.
Similarly bracketed pass reformatters may return such tokens.

\subsubsection{Bracketed Subexpression Parser Pass Output}
\label{BRACKETED-SUBEXPRESSION-PARSER-PASS-OUTPUT}

The bracketed subexpression recognizer converts
subexpressions to single \TT{BRACK\-ET\-ED} or \TT{PURE\-LIST}
tokens whose \TT{value}'s
are MIN objects, or into \TT{DERIVED} tokens whose values are
not MIN objects (e.g., they are labels or special values).

The final output of the parser is a sequence of \TT{BRACKETED} tokens,
one per top level logical line or headed paragraph.
For each of these tokens,
its `\TT{value}' is a MIN object that encodes its logical line or
headed paragraph.

For {\em untyped-bracketed-subexpressions} that are \underline{not}
reformatted, the brackets become the
\TT{.ini\-ti\-ator} (e.g.~`\TT{(}') and \TT{.terminator} (e.g., `\TT{)}').
{\em Indented-paragraph-subexpressions} are similar, with the
{\em indentation-mark} (e.g., `\TT{:}') being the \TT{.ini\-ti\-ator} and
the special value
\begin{center}
\ttsvkey{IN\-DEN\-TED\_\EOL PARAGRAPH}
\end{center}
being the
\TT{.term\-i\-na\-tor}.  The elements of an indented paragraph are
logical lines, whose \TT{.in\-i\-ti\-a\-tor}
is the special value
\begin{center}
\ttsvkey{LOGICAL\_LINE}
\end{center}
and whose \TT{.term\-i\-na\-tor}
is the line separator (e.g., `\TT{;}') if there is one,
or \TT{"<LF>"} otherwise.

For {\em typed-bracketed-subexpressions} there is \underline{no}
implied \TT{.initiator} or \TT{.terminator}, though these may
be given as explicit attributes.  There is a \TT{.type}
attribute unless the type is represented by \TT{""}.
{\em Prefix-n-lists} are just an alternate form of
{\em typed-bracketed-sub\-ex\-pres\-sions}, and headed paragraphs
are just a particular kind of {\em prefix-n-lists}.

The elements of a MIN object are the values of sub-subexpressions and
may themselves the MIN objects, as when brackets are nested.  The
elements of indented paragraphs are always logical lines or
headed subparagraphs.

If MIN object X has just one element that is a MIN object Y,
X has no attributes other than \TT{.type}, \TT{.initiator},
and \TT{.terminator}, and Y does not have any of these three
attributes, then X and Y are merged to get a new object with
the attributes of both X and Y and the elements of Y.  This is implemented
by giving the token type
\TT{BRACKETABLE} or \TT{PURELIST}
to Y as a temporary token type indicating that Y
does not have any \TT{.type}, \TT{.initiator}, or \TT{.terminator}
attribute.  Then when X is formed, the knowledge of the structure
of X and the \TT{BRACKETABLE} or \TT{PURELIST} type of Y permit the two objects
to be merged.%
\label{MERGING-BRACKETABLE-TOKENS}

Consider the example:
\begin{center}
\tt ( x, y 5, 8, w, p )
\end{center}

The token sequence
\begin{center}
\tt x "," y 5 "," 8 "," w "," p
\end{center}
is converted by the standard operator pass
(see \itemref{OPERATOR-PARSING-PASS})
to a \TT{BRACKETABLE} token with value
\begin{center}
\tt \{"": .separator = "," | x  \{| y 5 |\} 8 w p |\}
\end{center}
where \TT{""} denotes a missing \TT{.type}.
If we denote this token value by Y,
then the full expression is
\begin{center}
\tt \{"": .initiator = "(", .terminator = ")" | Y |\}
\end{center}
and the above rule merges the attributes into Y to get
\begin{center}
\tt
\{"": \begin{tabular}[t]{l}
      .initiator = "(", .terminator = ")", .separator = "," \\
      | x  \{| y 5 |\} 8 w p |\}
      \end{tabular}
\end{center}
as the \TT{value} of a \TT{BRACKETED} token.

In the process of forming a MIN object, some tokens must be converted to
object elements.  The MIN values of these tokens become the object elements,
except for quoted string and numeric lexemes.
Quoted string and numeric lexemes
are first converted to a MIN object
whose \TT{.type} is \TT{"<Q>"} for a quoted string or \TT{\#} for
a numeric, and whose single element is a MIN string equal to the
the token \TT{value}.

Note that natural token values are MIN numbers that
are conversions of their lexeme string and not identical
to this string.

Thus for example, the parser input
\begin{center}
\tt \{| 005 "HELLO" 3.4 |\}
\end{center}
produces a \TT{BRACKETED} token whose \TT{value} is a MIN object with
\underline{no} attributes and with the three elements that
can be represented as:
\begin{center}
\begin{tabular}{lll}
\TT{5}	                        & MIN number	& from natural token \\
\TT{\{"<Q>"| HELLO |\}}		& MIN object	& from quoted string token \\
\TT{\{\# 3.4 \#\}} or \TT{\{"\#"| 3.4 |\}}
				& MIN object	& from numeric token \\
\end{tabular}
\end{center}

{\em Untyped-bracketed-subexpressions} may be reformatted to
produce tokens of \TT{DERIVED} type with \TT{value}'s that may be
MIN labels or special values.  Examples are:
\begin{center}
\begin{tabular}{ll}
\TT{[\$ LOGICAL\_LINE \$]}	& MIN special \TT{LOGICAL\_LINE} value \\
\TT{[< A B 5 >]}	& MIN label with three components, \TT{A}, \TT{B},
			  and \TT{"5"} \\
			& (this last a MIN string and not a MIN number) \\
\end{tabular}
\end{center}

The following is a review of the standard MIN object attributes
mentioned above:

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttdmkey{type}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals
    \begin{center}
    \begin{tabular}{ll}
       & the {\em bracket-type} of a typed bracketed subexpression
         (\itemref{TYPED-BRACKETED-SUBEXPRESSIONS}), \\
    or & \TT{"<Q>"} if the MIN object represents a quoted string lexeme. \\
    or & \TT{\#} if the MIN object represents a numeric lexeme. \\[1ex]
       & The {\em bracket-type} \TT{""} represents
         the absence of a \TT{.type} attribute. \\
    \end{tabular} \\
    \end{center}
\medskip
\hspace*{-0.2in}\ttdmkey{initiator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    or a MIN special value,
    that equals
    \begin{center}
    \begin{tabular}{ll}
       & the {\em opening-bracket-name} of
         an untyped bracketed subexpression, \\
    or & the {\em indentation-mark-name} of an indented paragraph, \\
    or & \TT{min::LOGICAL\_LINE()} for a logical line \\
    \end{tabular}
    \end{center}
\medskip
\hspace*{-0.2in}\ttdmkey{terminator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    or a MIN special value,
    that equals
    \begin{center}
    \begin{tabular}{ll}
       & the {\em closing-bracket-name} of
         an untyped bracketed subexpression, \\
    or & \TT{min::INDENTED\_PARAGRAPH()} for an indented paragraph \\
    or & the terminator of a logical line: \\
       & ~~~ either \TT{"<LF>"}, \\
       & ~~~ or a {\em line-separator-name} (e.g.~\TT{";"}) \\
    or & the terminator of sentence (e.g.~\TT{"."}) \\
    \end{tabular}
    \end{center}
\medskip
\hspace*{-0.2in}\ttdmkey{separator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals
    the operator (e.g.~\TT{","}) that acts as a
    separator in a subexpression.  Separators are \underline{not} recognized
    by the bracketed subexpression parser pass, but by other passes
    (.e.g., the standard operator pass).

\end{indpar}

In addition to the attributes just given, a MIN object that is
the value of a \TT{BRACKETED} or \TT{PURE\-LIST} token will have
a \ttdmkey{position}{of MIN object} attribute that is a
\TT{min::\EOL phrase\_\EOL position\_\EOL vec} giving the within file positions
of the lexemes which the MIN object and its elements represent.
This is a hidden attribute that is not (normally) printed.

\subsubsection{Untyped Bracketed Subexpressions}
\label{UNTYPED-BRACKETED-SUBEXPRESSIONS}

The following are examples of
\ikey{untyped bracketed expressions}{bracketed expressions!untyped},
where \ldots{} denotes a list of elements:
\begin{center}
\TT{(} ~~~\ldots~~~ \TT{)} \\
\TT{(|} ~~~\ldots~~~ \TT{|)} \\
\TT{[} ~~~\ldots~~~ \TT{]} \\
\TT{[<} ~~~\ldots~~~ \TT{>]} \\
\end{center}

The general syntax is:

\begin{indpar}[0.1in]
\emkey{untyped-bracketed-subexpression} ::=
	{\em opening-bracket} ~ {\em element-list} ~ {\em closing-bracket}
\label{UNTYPED-BRACKETED-SUBEXPRESSION}
\\[0.5ex]
\emkey{opening-bracket} ::=
   {\em key} ~~~ [e.g., `\TT{(}' or `\TT{[<}', ~
    as per
    {\em parser-untyped-bracket-command}
    \pagref{PARSER-UNTYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{closing-bracket} ::=
   {\em key} ~~~ [e.g., `\TT{)}' or `\TT{>]}', ~
    as per
    {\em parser-untyped-bracket-command}
    \pagref{PARSER-UNTYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{key} ::= see \pagref{KEY}
\\[0.5ex]
\emkey{element-list} ::= {\em prefix-0-list}
\label{ELEMENT-LIST}
\\[0.5ex]
\emkey{prefix-0-list}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em simple-element-list} \\
    $|$ & see \pagref{PREFIX-0-LIST}
    \end{tabular}
\\[0.5ex]
\emkey{simple-element-list} ::= {\em element}\STAR{}
\label{SIMPLE-ELEMENT-LIST}
\\[0.5ex]
\emkey{element}
    \begin{tabular}[t]{rl}
    ::= & {\em word} $|$ {\em numeric} $|$ {\em number} $|$ {\em natural} $|$
          {\em numeric-word} \\
    $|$ & {\em mark} $|$ {\em separator} $|$ {\em quoted-string} \\
    $|$ & {\em untyped-bracketed-subexpression} \\
    $|$ & {\em typed-bracketed-subexpression} \\
    $|$ & {\em typed-prefix-separator} that is not a prefix:
          see \pagref{PREFIX-0-LIST} \\
    \end{tabular}
\\[0.5ex]
\emkey{typed-bracketed-subexpression} ::=
    see \pagref{TYPED-BRACKETED-SUBEXPRESSION}
\\[0.5ex]
\emkey{typed-prefix-separator} ::=
    see \pagref{TYPED-PREFIX-SEPARATOR}
\\[0.5ex]
Note: \begin{minipage}[t]{5.8in}
      \raggedright
      An {\em untyped-bracketed-subexpression} {\em element-list}
      is normally terminated by the expression's {\em closing-bracket}.
      It may be abnormally terminated by an outer
      {\em bracketed-subexpression's}
      {\em closing-bracket} (e.g.~`\TT{)}'),
      {\em typed-closing} (e.g.~`\TT{\}}'),
      or {\em non-continuation-line-break}, but \underline{not}
      by a {\em line-separator} (e.g.~`\TT{;}')
      or {\em typed-middle} (e.g.~`\TT{|}').
      \end{minipage}
\end{indpar}

An \key{untyped bracketed subexpression}\index{bracketed subexpression!untyped}
begins with
an {\em opening-bracket} and ends with a match\-ed
{\em clos\-ing-bracket} as defined by a
\TT{parser define bracket} command, an example of which is
\begin{center}
\TT{parser define bracket "("~...~")" [math, text]} \ldots
\end{center}
which specifies `\TT{(}' to be an {\em opening-bracket}
with `\TT{)}' as its corresponding {\em closing-bracket}
and `\TT{math}' and `\TT{text}' as the definition selectors.

The general syntax of {\em parser-untyped-bracket-commands} is:

\begin{indpar}[0.1in]
\emkey{parser-untyped-bracket-command}%
\label{PARSER-UNTYPED-BRACKET-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rll}
    ::= & \multicolumn{2}{l}{\ttmkey{define bracket}{parser command}
		    ~ {\em bracket-name} ~ {\em selectors}} \\
	& \hspace*{3em} & [ \TT{with parsing selectors}
	                    ~ {\em bracket-selectors} ] \\
        &               & [ \TT{with parsing options}
	                    ~ {\em bracket-options} ] \\
        &               & [ \TT{with}
			    ~ {\em reformatter-name}
			    ~ \TT{reformatter}
			    ~ {\em reformatter-arguments}\QMARK{} ] \\
    $|$ & \multicolumn{2}{l}{\ttmkey{undefine bracket}{parser command}
		    ~ {\em bracket-name} ~ {\em selectors}} \\
    $|$ & \multicolumn{2}{l}{\ttmkey{print bracket}{parser command}
		    ~ {\em partial-opening-bracket} }\\
    \end{tabular} \\[1ex]
    \hspace*{0.2in}
     NOTE: The \TT{with \ldots} clauses can appear in any order.
\\[0.5ex]
\emkey{bracket-name} ::= {\em opening-bracket}
			 ~ \ttmkey{...}{in {\em bracket-name}}
			 ~ {\em closing-bracket}
\label{BRACKET-NAME}
\\[0.5ex]
\emkey{opening-bracket} ::= {\em quoted-key}
\\[0.5ex]
\emkey{closing-bracket} ::= {\em quoted-key}
\\[0.5ex]
\emkey{partial-opening-bracket} ::= {\em quoted-key}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\\[0.5ex]
\emkey{bracket-selectors}\label{BRACKET-SELECTORS} ::=
    \begin{tabular}[t]{p{4.5in}}
    {\em selector-spec} ~~~~~~~ [\pagref{SELECTOR-SPEC}] \\
    {}[Unless explicitly mentioned in {\em selector-spec},
       `\TT{TOP LEVEL}'
       and `\TT{LINE LEVEL}' are
       automatically added as `\TT{-}' selectors]
    \end{tabular}
\\[0.5ex]
\emkey{bracket-options}\label{BRACKET-OPTIONS} ::=
    \begin{tabular}[t]{p{4.5in}}
    \raggedright
    {\em option-spec} ~~~~~~~ [\pagref{OPTION-SPEC}] \\
    with only `\TT{end at \ldots}' options and
    `\TT{enable \ldots}' options \\
    {}[Unless explicitly mentioned in {\em option-spec},
    `\TT{end at line separator}', `\TT{enable indented paragraph},
    and `\TT{enable header}' are
       automatically added as `\TT{-}' options]
    \end{tabular}
\\[0.5ex]
\emkey{reformatter-name}\label{REFORMATTER-NAME} ::=
    {\em simple-name} not containing `\TT{reformatter}'
\\[0.5ex]
\emkey{reformatter-arguments}\label{REFORMATTER-ARGUMENTS}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{()} \\
    $|$ & \TT{(} {\em reformatter-argument}
          \{ \TT{,} {\em reformatter-argument} \}\STAR{} \TT{)} \\
    \end{tabular} \\
\emkey{reformatter-argument} ::= {\em quoted-key} $|$ {\em simple-name}
			     $|$ {\em argument-sublist} \\
\emkey{argument-sublist} ::= {\em reformatter-arguments}

\end{indpar}

Brackets such as `\TT{(}' and `\TT{)}'
are called `\key{untyped brackets}'
to distinguish them from typed brackets
such as `\TT{\{b|}' and `\TT{|b\}}'
in which the type, in this case `\TT{b}',
is fairly arbitrary.  See \itemref{TYPED-BRACKETED-SUBEXPRESSIONS}
for a description of typed brackets.

The `\TT{print bracket} {\em partial-opening-bracket}' command
prints all untyped bracket symbol table entries whose
{\em opening-bracket} contains the {\em partial-opening-bracket}
as a (not necessarily initial) subsequence of lexemes.  Using \TT{""} as
a {\em partial-opening-bracket} will print all untyped bracket
symbol table entries.

In the absence of a reformatter,
an untyped bracketed subexpression is converted to a \TT{BRACKETED}
token whose \TT{value} is a
MIN object whose list elements are the components of the
subexpression except for the brackets.  The
{\em opening-bracket} becomes the \TT{.initiator}
attribute of this object, and the {\em closing-bracket}
becomes the \TT{.terminator} attribute of the object.
See below for {\em untyped-bracketed-subexpression} reformatters.

If a bracketed subexpression ends pre-maturely, before
its {\em closing-bracket} is discovered, a parsing error is
announced and the {\em closing-bracket} is inserted in the input
just after the pre-maturely ended subexpression.  Such a pre-mature end can be
discovered by finding the {\em closing-bracket} of a containing
{\em untyped-bracketed-subexpression} or {\em typed-bracketed-subexpression},
or the end of the logical line
containing the {\em untyped-bracketed-subexpression}.

When an {\em opening-bracket} is recognized, the current parser
selector set and options are saved in a stack.  Then if the
bracket definition contains {\em bracket-selectors},
a new selector set is computed by modifying the saved set
according to the {\em bracket-selectors}.
The `\TT{TOP LEVEL}' and `\TT{LINE LEVEL}' selectors are turned off
by default.
Similarly if the bracket definition contains {\em bracket-options},
these are used to compute a new set of end-at options.
By default the `\TT{end at line separator}',
`\TT{enable indented paragraph}', and `\TT{enable header}' options
are turned off.
The saved selector set and options are restored after the {\em closing-bracket}
is recognized.  However {\em closing-bracket}
recognition does not depend
upon the current parser selectors, but only on previous recognition
of an associated {\em opening-bracket}.

An example using {\em bracket-options} to permit
\TT{`{}`{}`\ldots'{}'{}'}
to bracket arbitrary text with arbitrary indentation is:
\begin{indpar}\begin{verbatim}
parser define bracket "```" ... "'''" [code]
       with parsing options []
( An indented paragraph:
    ```This logical line continues on no
matter what, even with a spurious ), until
  the following is encountered- '''
    Second logical line of indented paragraph.
    ) // End of () bracketed subexpression
\end{verbatim}\end{indpar}

Several reformatters are provided that change the MIN value
represented by an {\em untyped-bracketed-subexpression}:

\begin{indpar}

\ttmkey{label}{reformatter} \hfill e.g.:~\ttmkey{[<~>]}{reformatting}

\begin{indpar}[0.5em]
Requires that the subexpression elements be {\em words},
{\em naturals}, {\em numbers}, {\em numerics}, {\em quoted-strings},
or MIN label values.
The value of an element is taken to be the MIN string equal to the lexeme
string, the MIN number converted from the lexeme's string
(for {\em naturals} and {\em numbers}),
or the MIN label value of a non-lexeme element.

The subexpression is converted to a \TT{DERIVED}
token whose \TT{value} is the value of the single element
of the subexpression if the subexpression has exactly one
element, and whose value is otherwise the MIN label made from the
subexpression element values (an empty label is possible).
\end{indpar}

\ttmkey{special}{reformatter} \hfill e.g.:~\ttmkey{[\$~\$]}{reformatting}

\begin{indpar}[0.5em]
Requires that the expression consist of a single element with a string
value that names a MIN special value (e.g., `\TT{MISSING}' or
`\TT{INDENTED\_PARAGRAPH}').

The subexpression is converted to a \TT{DERIVED}
token whose \TT{value} is the special value named.
\end{indpar}

\ttmkey{multivalue}{reformatter} \TT{(} {\em separator} \TT{)}
	\hfill e.g.:~\ttmkey{\{*~*\}}{reformatting}%
	\label{MULTIVALUE-REFORMATTER}

\begin{indpar}[0.5em]
Requires that the subexpression elements be {\em words},
{\em naturals}, {\em numbers}, {\em numerics}, {\em quoted-strings},
or equal to the
{\em separator} argument (e.g.~\TT{","}).

The subexpression is divided into components by {\em separator}
tokens and is converted to a \TT{BRACKETED}
token whose \TT{value} is a list with one element for each
non-missing component.  A component that is a single element
becomes the MIN string of the lexeme of that element, and a component with
more than one element becomes a MIN label whose elements are the
MIN strings of the component elements.
The \TT{BRACKETED} result token gets the {\em separator} as its
\TT{.separator} attribute, and the opening and closing brackets
(e.g.~\TT{\{*~*\}})
as its \TT{.initiator} and \TT{.terminator} attributes.

The {\em separator} argument (e.g.~\TT{","}) must denote
a single MIN string, and
cannot denote a multi-component MIN label (this is purely a current
implementation limitation).
\end{indpar}

\ttmkey{text}{reformatter} ~ \TT{(} {\em prefix}
                                 \{ \TT{,} {\em quoted-terminator} \}\PLUS{}
				 \TT{)}
	\hfill e.g.:~\ttmkey{`{}`~'{}'}{reformatting}%
	\label{TEXT-REFORMATTER}

\begin{indpar}[0.5em]
where 

\begin{indpar}
\emkey{prefix} ::= {\em simple-name} $|$ {\em quoted-key}
	\hfill e.g.:~\ttmkey{s}{reformatting}
\\[0.5ex]
\emkey{quoted-terminator} :::= \TT{"}{\em terminator}\TT{"}
\\[0.5ex]
\emkey{terminator} :::= {\em mark} $|$ {\em separator}
\end{indpar}

If the {\em prefix-n-list} does not contain a {\em terminator} lexeme,
nothing is done.  Note that if the {\em prefix-n-list} previously
began with an explicit \TT{\{}{\em prefix}\TT{\}}, any {\em terminators}
in that previous {\em prefix-n-list} would now be inside subexpressions,
so this rule would apply and nothing would be done.

\TT{\{}{\em prefix}\TT{\}} is
pre-pended to the {\em prefix-n-list} and the new {\em prefix-n-list}
is processed as if it had just been read.  In particular, any
reformatter for {\em prefix} is called and if there is none
the elements following the \TT{\{}{\em prefix}\TT{\}}
are collected into a typed bracketted subexpression with
\TT{.type} equal to {\em prefix}.

\end{indpar}

\end{indpar}


\begin{center}\label{UNTYPED-BRACKET-BUILTINS}
\begin{tabular}{l}
\multicolumn{1}{c}{\bf Initial Bracket Parser Commands}
\\\hline
\tt define bracket "(" \ldots~")" [data] \\
\tt define bracket "[" \ldots~"]" [data] \\
\tt define bracket "{{" \ldots~"}}" [data] \\
\tt define bracket "`" \ldots~"'" [data] \\
\tt ~~~~~~~with parsing selectors [atom] \\
\tt define bracket "``" \ldots~"''" [data] \\
\tt define bracket "[<" \ldots~">]" [data, atom] \\
\tt ~~~~~~~with parsing selectors [atom] \\
\tt ~~~~~~~with label reformatter \\
\tt define bracket "[\$" \ldots~"\$]" [data, atom] \\
\tt ~~~~~~~with parsing selectors [atom] \\
\tt ~~~~~~~with special reformatter \\
\tt define bracket "{*" \ldots~"*}" [data] \\
\tt ~~~~~~~with multivalue reformatter ( "," ) \\
\end{tabular}
\\[2ex]
\begin{tabular}{l@{\hspace*{0.5in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{brackets}'\label{STANDARD-BRACKETS-1} Component
     Bracket Parser Commands}
\\[1ex]
\multicolumn{2}{c}
{All Commands Require at Least One of {\tt + code, + text, + math}} \\
\multicolumn{2}{c}
{Selectors with Missing Standard Qualifiers are Deleted from Commands}
\\[1ex]
Parser Command				& \shortstack{
                                          Given\\Qualifiers}
\\\hline
\tt define bracket "(" \ldots~")" [code, text, math] \\
\tt define bracket "[" \ldots~"]" [code, text, math] \\
\tt define bracket "`" \ldots~"'" [code, text, math] \\
\tt define bracket "[<" \ldots~">]" [code, text, math] \\
\tt ~~~~~~~with parsing selectors [atom] \\
\tt ~~~~~~~with label reformatter \\
\tt define bracket "[\$" \ldots~"\$]" [code, text, math] \\
\tt ~~~~~~~with parsing selectors [atom] \\
\tt ~~~~~~~with special reformatter \\
\tt define bracket "\{\{" \ldots~"\}\}" [code, text, math]   & \tt + math \\
\tt ~~~~~~~with parsing selectors \\
\tt ~~~~~~~~~~~~[+ math, - code, - text] \\
\tt define bracket "`{}`" \ldots~"'{}'" [code, text, math]   & \tt + text \\
\tt ~~~~~~~with parsing selectors \\
\tt ~~~~~~~~~~~~[+ text, - code, - math] \\
\tt ~~~~~~~with text reformatter \\
\tt ~~~~~~~~~~~~( "s", ".", "?", "!", ":", ";" ) \\
\end{tabular}
\end{center}

\subsubsection{Indented Paragraph Subexpressions}
\label{INDENTED-PARAGRAPH-SUBEXPRESSIONS}

Indented paragraph subexpressions
are recognized if the `\TT{enable indented paragraph}'
option is on (\pagref{ENABLE-INDENTED-PARAGRAPH}; this
option is always off inside a bracketed subexpression).
The following is an example
\key{indented paragraph subexpression}
using `\TT{:}' as the {\em indentation-mark}:
\begin{indpar}\begin{verbatim}
the first logical line
the second logical line that ends with
           an outer indented paragraph:
    the first logical line of this outer paragraph
    the second logical line of the outer paragraph which
        is continued on this indented line
    the third logical line which ends with
              an inner indented paragraph:
        the first logical line of the inner paragraph
        the second logical line of the inner paragraph
            which is continued on this indented line
    the first outer paragraph logical line after
        the inner paragraph
    the next logical line, which ends with another
        inner paragraph, but one with zero lines:
    the last logical line of the outer paragraph
the logical after the outer paragraph
\end{verbatim}\end{indpar}

An \key{indented paragraph subexpression}
begins with an {\em indentation-mark} (e.g.~`\TT{:}')
which must be at the end of a physical line or just before
a comment that ends a physical line.
This is followed by an \key{indented paragraph}
consisting of zero or more non-empty
(see \pagref{NON-EMPTY-PARAGRAPH-LINE-RULE})
logical lines called \skey{paragraph line}s.
The paragraph has a \key{paragraph indent},
which is the indent of the
first non-blank physical line after the
line containing the indentation mark, if this indent
is greater than the current indent.
But if this indent is less than or equal
to the current indent, or if there is no non-blank
physical line before an end of file,
the paragraph is empty, and has no paragraph lines.

Comment lines (lines containing only comment lexemes)
are `logical lines' for the purposes of setting the
paragraph indent and terminating an indented paragraph.
Thus the following example:
\begin{indpar}\begin{verbatim}
a logical line ending with an indented paragraph:
    // comment line setting the paragraph indent
    the first logical line in the paragraph
// comment line terminating the paragraph
the first logical line after the paragraph
\end{verbatim}\end{indpar}

At the beginning of the paragraph,
the \key{current indent} is set to the paragraph indent,
and at the end of the paragraph, the current indent is
restored to its previous value.  The top level
current indent is \TT{0}.

The general syntax is:

\begin{indpar}[0.1in]
\emkey{indented-paragraph-subexpression} ::=
	\begin{tabular}[t]{@{}l}
	{\em indentation-mark} {\em line-break} \\
	~~~~ {\em paragraph-line}\STAR{} \\
	{\em paragraph-end}
	\end{tabular}%
\label{INDENTED-PARAGRAPH-SUBEXPRESSION}
\\[0.5ex]
\emkey{paragraph-line} ::=
    \begin{tabular}[t]{l}
    {\em logical-line}, possibly ended by a {\em line-separator} \\{}
    [May be grouped into headed paragraphs: see \itemref{HEADED-PARAGRAPHS}] \\
    \end{tabular}
\\[0.5ex]
{\em logical-line} ::= see \itemref{LOGICAL-LINES}
	~~ [Includes headed lines: see \itemref{HEADED-LINES}]
\\[0.5ex]
\emkey{paragraph-end}
    \begin{tabular}[t]{rl}
    ::= & indent lexeme with indent that is less than
			  the paragraph indent \\
    $|$ & end of file
    \end{tabular}
\\[0.5ex]
\emkey{indentation-mark} ::=
   {\em key} ~~~ [e.g., `\TT{:}', ~ as per
    {\em parser-indentation-mark-command}
    \pagref{PARSER-INDENTATION-MARK-COMMAND}]
\\[0.5ex]
\emkey{line-separator} ::=
   {\em key} ~~~ [e.g., `\TT{;}', ~ as per
    {\em parser-indentation-mark-command}
    \pagref{PARSER-INDENTATION-MARK-COMMAND}]
\end{indpar}

{\em Paragraph-lines} are logical lines that end according to
the setting of the end-at options;
See~\pagref{OPTION-NAMES}.  The setting of these options can be
controlled by the specification of the {\em indentation-mark}.

{\em Paragraph-lines} may be headed lines (see \itemref{HEADED-LINES})
or may be grouped into headed paragraphs (see \itemref{HEADED-PARAGRAPHS}).

An indented paragraph subexpression is converted to a \TT{BRACKETED}
token whose \TT{value} is a
MIN object with list elements derived from the {\em paragraph-lines}
of the paragraph.  In the absence of a line header, a {\em paragraph-line}
becomes a logical line object, which is a MIN object with
\TT{min::\EOL LOGICAL\_\EOL LINE()} as its \TT{.initiator} and either the
indented paragraph {\em line-separator} (see below) or \TT{"<LF>"}
as its \TT{.terminator}.  Headed lines (\itemref{HEADED-LINES})
have a \TT{.type} instead of an \TT{.initiator}, and either have
no \TT{.terminator} or have a {\em line-separator} as \TT{.terminator}.
After lines are parsed, a sequence of lines may be
made into a headed paragraph which replaces the
sequence of lines in the indented paragraph MIN object.  A headed paragraph
has a \TT{.type} but
no \TT{.initiator} or \TT{.terminator}.  The indented paragraph MIN
object itself has its {\em indentation-mark} (see below) as its
\TT{.initiator} and \TT{min::\EOL INDENTED\_\EOL PARAGRAPH()} as its
\TT{.terminator}.

\ikey{Empty logical lines}{empty logical line} with no ending
{\em line-separator} are always ignored as if they did not exist%
\label{NON-EMPTY-PARAGRAPH-LINE-RULE}.
This rule allows physical lines such as
\begin{center}
\tt This logical line is followed by an empty logical line;
\end{center}
to represent a single logical line, instead of two logical lines
the second of which is empty.  All retained logical lines
are non-empty.

An {\em indentation-mark} is specified by a
\ttmkey{define indentation mark}{parser command}
parser command, and may have
an associated {\em line-separator} supplied by that definition.
An example is
\begin{center}
\TT{define indentation mark ":"~...~";" [code]} \ldots
\end{center}
which specifies `\TT{:}' to be an {\em indentation-mark}
with `\TT{;}' as its corresponding {\em line-separator}
and `\TT{code}' as the sole definition selector.

The general syntax of {\em parser-indentation-mark-commands} is:

\begin{indpar}[0.1in]
\emkey{parser-indentation-mark-command}%
\label{PARSER-INDENTATION-MARK-COMMAND} \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define}\ttmindex{define indentation mark}{parser command} ~
	  \begin{tabular}[t]{@{}l@{}}
	  \TT{indentation mark} ~
	  {\em indentation-name} ~ {\em parsing-selectors} \\
	  {}[ \TT{with parsing selectors}
	       ~ {\em indentation-mark-selectors} ] \\
	  {}[ \TT{with parsing options} ~ {\em indentation-mark-options} ] \\
	  {}[ \TT{with implied header} ~ {\em header} ] \\
          {}[ \TT{with~}\{ \TT{paragraph} | \TT{line} \}\QMARK{} \TT{~}%
	                  \begin{tabular}[t]{@{}l@{}}
			  \TT{lexical master} \\
			  {\em lexical-master-name} ] \\
			  \end{tabular} \\
	  \end{tabular} \\
    $|$ & \ttmkey{undefine indentation mark}{parser command} ~
	  {\em indentation-mark} ~ {\em parsing-selectors} \\
    $|$ & \ttmkey{print indentation mark}{parser command} ~
	  {\em partial-indentation-mark} \\
    $|$ & \ttmkey{define indentation offset}{parser command} ~
	  {\em indentation-offset}  \\
    $|$ & \ttmkey{print indentation offset}{parser command} \\
    \end{tabular} \\[1ex]
    \hspace*{0.2in}
    NOTE: The \TT{with \ldots} clauses can appear in any order.
\label{INDENTATION-MARK-DEFINITION}
\\[0.5ex]
\emkey{indentation-name} ::= {\em indentation-mark}
	[ \TT{...} {\em line-separator} ]
\\[0.5ex]
\emkey{indentation-mark} ::= {\em quoted-key}
\label{INDENTATION-MARK-NAME}
\\[0.5ex]
\emkey{line-separator} ::= {\em quoted-key}
\\[0.5ex]
\emkey{partial-indentation-mark} ::= {\em quoted-key}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\\[0.5ex]
\emkey{indentation-mark-selectors} ::=
    {\em selector-spec} ~~~~~~~ [\pagref{SELECTOR-SPEC}] \\
\hspace*{0.5in}
    \begin{tabular}[t]{p{5.0in}}
    {}[Unless they are explicitly mentioned in {\em selector-spec},
       `\TT{LINE LEVEL}' is
       automatically added as a `\TT{+}' selector
       and `\TT{TOP LEVEL}' is
       automatically added as a `\TT{-}' selector]
    \end{tabular}
\\[0.5ex]
\emkey{indentation-mark-options} ::=
    \begin{tabular}[t]{p{4in}}
    \raggedright
    {\em option-spec} with only `\TT{end at \ldots}'
    and `\TT{enable \ldots}' options
	~~~ [\pagref{OPTION-SPEC}]
    \end{tabular}
\\[0.5ex]
\emkey{header} ::= \begin{tabular}[t]{l}
                   {\em typed-prefix-separator}
                       (\pagref{TYPED-PREFIX-SEPARATOR}) \\
		   with `\TT{paragraph}' or `\TT{line}' group
		       (\itemref{HEADED-LINES}, \itemref{HEADED-PARAGRAPHS}) \\
		   \end{tabular}
\\[0.5ex]
\emkey{lexical-master-name} ::= {\em quoted-key}
                    $|$ {\em simple-name} not containing `\TT{with}'
\\[0.5ex]
\emkey{indentation-offset} ::= unsigned integer
\end{indpar}

The {\em line-separator} may be used to end
paragraph lines, as long as the \TT{end at line sepa\-ra\-tor}
(\pagref{END-AT-LINE-SEPARATOR}) option permits.
Line separators are only recognized outside explicitly
bracketed subexpressions (untyped bracketed or typed bracketed)
in the paragraph.

The `\TT{print indentation mark} {\em partial-indentation-mark}' command
prints all indentation mark symbol table entries whose
{\em indentation-mark} contains the {\em partial-indentation-mark}
as a (not necessarily initial) subsequence of lexemes.  Using \TT{""} as
a {\em partial-indentation-mark} will print all indentation mark
symbol table entries.

Indentation offsets of all current parser blocks can be printed by the
\TT{print indentation offset} command.

The \TT{implied paragraph header} and \TT{lexical master} parameters
can be used to initialize line variables
that affect the parsing of indented paragraphs: see \itemref{LINE-VARIABLES}.
If they are not explicitly included in the indentation mark definition command,
they are treated as missing.  If a lexical master is missing,
the lexical master in effect at the beginning of a {\em paragraph-line}
in an indented paragraph
is the lexical master in effect at the end of the previous
{\em paragraph-line}, or if there is no previous {\em paragraph-line},
the lexical master in effect when the paragraph's
indentation mark is scanned.

If `\TT{with lexical master}' is given in the `\TT{define indentation mark}'
command, both lexical master parameters are set to the same
{\em lexical-master-name}.  If `\TT{with line lex\-ical master}' is
given but `\TT{with paragraph lexical master}' is not, both lexical
masters are set to the line lexical master and a parser warning message
is announced.

If while parsing an indented paragraph a line is encountered whose
indent is different from the current indent,
but the difference is less than `\key{indentation offset}'
columns (default 2),
a parser warning message is announced.
No corrective action is taken; the line may continue a logical line
or end an indented paragraph according to the usual rules.
Here the indentation offset can be
changed with the \TT{parser define indentation offset} command.
If changed in a parser block, the original value is reinstated at the
end of the block.

When an {\em indentation-mark} is recognized, the current parsing
selector set and parsing options are saved in a stack.
Then a new selector set and new options are computed by modifying
the saved selector set
according to the {\em indentation-mark-selectors}
and modifying the saved options according
to the {\em indentation-mark-options} in the indentation mark definition.
The saved selector set and options
are restored after the end of paragraph is recognized.
The \TT{TOP LEVEL} selector is turned off by default when parsing indented
paragraph lines, and the \TT{LINE LEVEL} selector is turned on by default.
Note that if no {\em new-selectors} are given, selectors
other than \TT{TOP LEVEL} and \TT{LINE LEVEL}
are not modified, and if no {\em indentation-mark-options} 
are given, options are not modified.

A new set of line variables is computed for use in parsing the
indented paragraph, as per \itemref{LINE-VARIABLES}.
The line variables include the paragraph line separator,
implied header, and lexical masters, as given in
the indentation mark definition (any of these may be missing).

There is a \TT{*TOP* *LEVEL*} indentation mark definition associated
with each active parser block; the definition for the current parser
block is the current \TT{*TOP* *LEVEL*} definition.
The parameters of this current definition are the top level parameters that
can be set and printed as per Section \itemref{PARSER-TOP-LEVEL-COMMANDS};
these parameters govern top level parsing as if the top level were inside
an indented paragraph with indentation \TT{0}.  However, when the
parsing selectors for a \TT{*TOP* *LEVEL*} indentation mark are
printed, the \TT{TOP LEVEL} and \TT{LINE LEVEL} selectors are omitted,
even though both are forced on a the beginning of each logical line.

When the parser is initialized, an initial \TT{TOP LEVEL} parser block
is created with its associated \TT{*TOP* *LEVEL*} indentation mark definition.
Each \TT{begin block ...} creates the \TT{*TOP* *LEVEL*} definition for
its block by copying the current definition from the immediately
containing parser block; the parameters of this new definition may
then be reset by \TT{define top level} commands as per
Section \itemref{PARSER-TOP-LEVEL-COMMANDS};

Explicit \TT{*TOP* *LEVEL*} indentation mark definitions are not permitted,
but the definitions can be printed by the \TT{print indentation mark ...}
command.

\begin{center}
\begin{tabular}{l}
\multicolumn{1}{c}{\bf Initial Indentation Mark Parser Commands}
\\\hline
\tt define indentation offset 2 \\
\tt define indentation mark "*PARSER*:" ... ";" [TOP LEVEL] \\
\tt ~~~~~~~with parsing selectors [data] \\
\tt define indentation mark "*PARSER* *TEST*:" ... ";" \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~[TOP LEVEL] \\
\end{tabular}
\\[2ex]
\begin{tabular}{l@{\hspace*{0.3in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{indentation marks}'\label{STANDARD-INDENTATION-MARKS}
     Component} \\
\multicolumn{2}{c}
{\bf Indentation Mark Parser Commands}
\\[1ex]
Parser Command				& \shortstack{
                                          Given\\Qualifiers}
\\\hline
\tt define indentation mark ":" ... ";" [code] & + code \\
\tt ~~~~~~~with parsing options \\
\tt ~~~~~~~~~~~~[default end at options] \\
\tt ~~~~~~~with paragraph lexical master $P$ \\
\tt ~~~~~~~with line lexical master $L$ \\
\tt define indentation mark ":" [text] & + text \\
\tt ~~~~~~~with parsing options \\
\tt ~~~~~~~~~~~~[default end at options] \\
\tt ~~~~~~~with paragraph lexical master $P$ \\
\tt ~~~~~~~with line lexical master $L$ \\
\tt ~~~~~~~with implied header \{p\} \\
\tt define indentation mark ":" [data paragraph] \\
\tt ~~~~~~~with parsing selectors [data] \\
\tt ~~~~~~~with parsing options \\
\tt ~~~~~~~~~~~~[default end at options] \\
\end{tabular}
\\[1ex]
where
\\[1ex]
\begin{tabular}{l@{\hspace*{0.5in}}l}
$P$ = {\tt PARAGRAPH-CHECK} & if {\tt + id, + table} \\	
$P$ = {\tt TABLE-CHECK} & if {\tt - id, + table} \\	
$P$ = {\tt DATA-CHECK} & if {\tt + id, - table} \\	
$P$ = inherit from context & if {\tt - id, - table} \\	
$L$ = {\tt DATA-CHECK} & if {\tt + id} \\	
$L$ = inherit from context & if {\tt - id} \\	
\end{tabular}
\\[1ex]
`inherit from context' means that the \\
`{\tt with ... lexical master ...}'~~line is omitted
\end{center}

\subsubsection{Typed Bracketed Subexpressions}
\label{TYPED-BRACKETED-SUBEXPRESSIONS}

The following are examples of
\skey{typed bracketed subexpression}s\index{bracketed subexpression!typed},
where \ldots{} denotes a list of elements:
\begin{center}
\TT{\{my type|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{my type|} ~~~\ldots~~~ \TT{|my type\}} \\
\TT{\{my type||\}} \\
\TT{\{my type: my attribute = 5, my option = TRUE|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{my type: my attribute = 5, your option = FALSE|} ~~~\ldots~~~
    \TT{|my type\}} \\
\TT{\{my type: my attribute = 5|} ~~~\ldots~~~
    \TT{|my option = TRUE: my type\}} \\
\TT{\{my type|} ~~~\ldots~~~
    \TT{|my attribute = 5, my option\}} \\
\TT{\{my type|} ~~~\ldots~~~
    \TT{|my attribute = 5, my option: my type\}} \\
\TT{\{|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{||\}} \\
\TT{\{\}} \\
\TT{\{my attribute = 5, no your option|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{"": my attribute = 5, no your option|} ~~~\ldots~~~ \TT{|""\}} \\
\TT{\{+} ~~~\ldots~~~ \TT{+\}} \\
\end{center}

The basic form is
\begin{center}
\TT{\{my type: my attribute = 5, my option = TRUE|} ~~~\ldots~~~
    \TT{|my type\}} \\
\end{center}
from which various parts can be omitted or moved.  Some or all of the
attributes can be moved to the end.
The attribute value `\TT{= TRUE}' can be omitted (as in
`\TT{my option}'), and the attribute value `\TT{= FALSE}' can be represented
by omitting it and prefacing the attribute label with `\TT{no}'
(as in `\TT{no your option}').
The type can be omitted from the end unless it is preceded
by a single attribute with omitted \TT{TRUE} value, as such an attribute
will be mistaken for the type
(i.e., in \TT{\{X|\ldots|Y\}}, \TT{Y} is
a type label and \underline{not} an attribute label, and it is an error
if \TT{X} and \TT{Y} are not the same).
If the type is given at the end, it must match the type given at the
beginning.  If no type is given at the beginning, the type is missing
and must not be given at the end.  However, \TT{""} can be used as a type
at either end to denote a missing type (e.g., \TT{\{|\ldots|""\}} is
legal and is the same as \TT{\{|\ldots|\}}).

For example, the following are equivalent:
\begin{center}
\TT{\{my option|a b c|no your option\}} \\
\TT{\{my option:~no your option|a b c|\}} \\
\TT{\{my option:~your option = FALSE |a b c|\}}
\end{center}

where `\TT{my option}' is the \TT{.type}, and \underline{not}
an attribute,
while the following is in error because it has a different \TT{.type} name
at the end than it does at the beginning:
\begin{center}
\TT{\{my option|a b c|your option\}} \\
\end{center}

A type or attribute label may be a label,
which is a sequence
of one or more words, naturals, numeric-words, numbers,
numerics, and quoted strings,
not beginning with a natural, numeric-word, or number.
Note that marks and separators must be quoted.
If there is only
one element in the sequence, the MIN string it represents is the
label, but if there is more than one element, the elements
are concatenated into a MIN label.

Attribute values are similar but may begin with a natural, numeric-word,
or number, and may alternatively be bracketed subexpressions.
In this last case, the attribute value is the bracketed subexpression,
with one exception.

The exception is that when the brackets are `\TT{\{*~*\}}',
the comma
separated elements of the bracketed subexpression are each a
distinct value of the attribute, which has a multi-set of values.
Elements must be single bracketed subexpressions,
words, naturals, numeric-words, numbers, numerics, or quoted strings
that are made into
MIN strings or MIN numbers,
or sequences of words, naturals, numeric-words, numbers, numerics, and
quoted strings that are made into
labels.  Missing elements, as indicated by the commas, are ignored,
If there are no values, as in `\TT{\{* *\}}' or `\TT{\{* , *\}}',
the attribute is not set.

Some examples of attribute values are:
\begin{center}
\TT{\{my type: x = hello, y = "hello" |} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{my type: x = 5 tomatoes, y = [< 5 tomatoes >] |}
    ~~~\ldots~~~ \TT{|\}} \\
\TT{\{my type: x = \{* A, B *\}, y = \{* , "A",{}, B, *\} |}
    ~~~\ldots~~~ \TT{|\}} \\
\TT{\{my type: y = \{* ,{}, *\} |} ~~~\ldots~~~ \TT{|\}} \\
\end{center}
In each case, the values of \TT{x} and \TT{y} are equal.

If there are no elements, `\TT{|~|}' can be collapsed into
a single lexeme `\TT{||}'.
`\TT{\{||\}}' can be collapsed into `\TT{\{\}}'.

If the type is
a single {\em mark} and there are no attributes,
the `\TT{|}'s surrounding
the elements may be omitted, in which case the {\em mark} is not
quoted, but the {\em mark} must appear both before and after the elements.
Similarly if the type is a label consisting of two \underline{distinct}
{\em marks},
and there are no attributes, the `\TT{|}'s may be
omitted with the two unquoted {\em marks} being placed before and
after the elements, respectively.
Except in these cases, type and attribute labels
cannot contain separators or marks unless these are quoted.

The following are equivalent pairs of examples with {\em mark} types:
\begin{center}
\begin{tabular}{l@{~~~~~}l}
\TT{\{+ 1 2 3 +\}} & \TT{\{"+"| 1 2 3 |"+"\}} \\
\TT{\{< 1 2 3 >\}} & \TT{\{"<" ">"| 1 2 3 |"<" ">"\}} \\
\end{tabular}
\end{center}

An attribute can have flags which are specified
in square brackets following the attribute label.
Normally there is only one lexeme in the square brackets
and it contains some combination of the 64 flag characters:
\begin{center}
\begin{tabular}{l}
\TT{*+-/@\&\#=\$\%<>} \\
\TT{abcdefghijklmnopqrstuvwxyz} \\
\TT{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \\
\end{tabular}
\end{center}
More flags can be represented by natural number flag indices
(e.g.~\TT{64}) which are separated from each other
and from any flag character by comma separators.
Multiple non-number flag lexemes, separated by comma separators,
can also be used.  Some examples are:
\begin{center}
\begin{tabular}{l}
\TT{\{my type:~my attribute [H] = (3,4)|A B C|\}} \\
\TT{\{my type:~my attribute [H, 64] = (3,4)|A B C|\}} \\
\TT{\{my type:~my attribute [64] = (3,4)|A B C|\}} \\
\TT{\{my type:~my attribute [64, HJ, 256] = (3,4)|A B C|\}} \\
\TT{\{my type:~my attribute [64, H, J, 256] = (3,4)|A B C|\}} \\
\end{tabular}
\end{center}

The 64 flag characters listed above are associated with flag
indices \TT{0} through \TT{63} in order:
\begin{center}
\begin{tabular}{r@{~have respective indices~}l}
\TT{*+-/@\&\#=\$\%<>} & 0~\ldots{}~11 \\
\TT{a\ldots{}z} & 12~\ldots{}~37 \\
\TT{A\ldots{}Z} & 38~\ldots{}~63 \\
\end{tabular}
\end{center}
Thus `\TT{[+Y]}', `\TT{[1,~Y]}', `\TT{[+,~62]}', and `\TT{[62,~1]}'
are equivalent as attribute flag specifiers.

MIN object have two types of attribues: \skey{single attribute}s
and \skey{double attribute}s.  Single attributes have an attribute label
and a multi-set of attribute values.  Double attributes have both
a (forward) attribute label and a \key{reverse attribute label}
and a multi-set of values that must be pointers to objects
(represented by object IDs: see \itemref{IDS}).

Single attributes are represented within a typed bracketed subexpression
by:
\begin{center}
\begin{tabular}{cl}
{\em attribute-label} \TT{=} {\em value} & [single value]\\
or \\
{\em attribute-label} \TT{=} \TT{\{*} {\em value}\TT{,} \ldots{} \TT{*\}}
    & [multiple value] \\
\end{tabular}
\end{center}
Double attributes are represented within a typed bracketed subexpression
by:
\begin{center}
\begin{tabular}{cl}
{\em attribute-label} \TT{=} {\em ID}
    \TT{=} {\em reverse-attribute-label} & [single value] \\
or \\
{\em attribute-label} \TT{=} \TT{\{*} {\em ID}\TT{,} \ldots{} \TT{*\}}
    \TT{=} {\em reverse-attribute-label} & [multiple value] \\
\end{tabular}
\end{center}

A single {\em attribute-label} may be shared by one single attribute
and many distinct double attributes
(with distinct {\em reverse-attribute-labels}).  Flags are attached to an {\em attribute-label} and are shared
among any single attribute and all double attributes with
that {\em attribute-label}.  Some flags affect only single attributes
and some affect only double attributes and some affect both.

An \ttkey{H}\index{H-flag} on an {\em attribute-label} prevents all attributes
with that label from printing, and in this sense \skey{hide}s these
attributes.

An \ttkey{M}\index{M-flag} on an {\em attribute-label} specifies that
the single attribute with that label has a multi-set of values.  Any
attribute representation adds to this multi-set, so that, for example,
a MIN object created by inputting:
\begin{center}
\TT{\{my type: x[M] = 1, x = 2, x = 2, x = 3, x = 3, x = 3 ||\}}
\end{center}
will output as
\begin{center}
\TT{\{my type: x[M] = \{* 1, 2, 2, 3, 3, 3 *\} ||\}}
\end{center}

An \ttkey{S}\index{S-flag} on an {\em attribute-label} specifies that
the single attribute with that label has a (non-multi) set of values.  Any
attribute representation adds to this set, so that, for example,
a MIN object created by inputting:
\begin{center}
\TT{\{my type: x[S] = 1, x = 2, x = 2, x = 3, x = 3, x = 3 ||\}}
\end{center}
will output as
\begin{center}
\TT{\{my type: x[S] = \{* 1, 2, 3 *\} ||\}}
\end{center}

The \TT{M} and \TT{S} flags only affect single attributes.  An \TT{M}
flag overrides and \TT{S} flag.  All double
attributes are input as sets of values, and are not multi-sets and
not limited to a single value.

If an {\em attribute-label} has neither an \TT{M} or \TT{S} flag,
it can have at most one value.  Thus the input:
\begin{center}
\TT{\{my type: x = 1, x = 2 ||\}}
\end{center}
is in error and the \TT{x = 2} will be mentioned in an error message
and otherwise ignored.

There is an exception to the above, in that when a multiple value
is provided for either a single or double attribute, the values
in it are added to the attribute values as if the attribute were
a multi-set.  Thus the MIN object created by the input:
\begin{center}
\TT{\{my type: x = 1, x = \{* 2, 2, 3, 3, 3 *\} ||\}}
\end{center}
will output as
\begin{center}
\TT{\{my type: x = \{* 1, 2, 2, 3, 3, 3 *\} ||\}}
\end{center}

The current implementation supports two syntactic extensions of
the above.  First, more than 2 \TT{|}'s may be used to switch
back and forth between attribute scanning and element scanning,
so that:
\begin{center}
\TT{\{T: a = 1, b = 2, c = 3, d = 4 | X Y Z | \}} \\
\TT{\{T: a = 1, b = 2, c = 3 | X Y Z | d = 4 \}} \\
\TT{\{T: a = 1, b = 2 | X Y | c = 3 | Z | d = 4 \}} \\
\TT{\{T: a = 1, b = 2 | X Y | c = 3, d = 4 | Z | \}} \\
\TT{\{T| X | a = 1, b = 2 | Y | c = 3, d = 4 | Z | \}} \\
\end{center}
are all equivalent.  Second, in {\em attribute-flags}, commas
do not have to be followed by whitespace, so that:
\begin{center}
\TT{\{T: a[PQ@*+,85,203] | X Y Z | \}} \\
\TT{\{T: a[PQ@*+, 85, 203] | X Y Z | \}} \\
\TT{\{T: a[203,P,Q,@,85,*,+] | X Y Z | \}} \\
\TT{\{T: a[203,P, Q,@,85, *,+] | X Y Z | \}} \\
\end{center}
are all equivalent.

These two syntactic extensions may become permanent or be
redacted in the future.

The general syntax of a typed bracketed subexpression is:

\begin{indpar}[0.1in]
\emkey{typed-bracketed-subexpression} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
	::= & {\em typed-opening}~~~%
	      {\em opening-type-and-attributes}\QMARK{} \\
	    & {\em typed-elements} \\
	    & {\em closing-type-and-attributes}\QMARK{}~~~%
	      {\em typed-closing} \\
	$|$ & \TT{\{}~~~{\em bracket-type-mark}~~~{\em element-list}~~~%
	                {\em bracket-type-mark}~~~\TT{\}} \\
	$|$ & \TT{\{}~~~{\em bracket-type-mark-1}~~~{\em element-list}~~~%
	                {\em bracket-type-mark-2}~~~\TT{\}} \\
	$|$ & \TT{\{\}}
	\end{tabular}%
\label{TYPED-BRACKETED-SUBEXPRESSION}
\\[0.5ex]
\emkey{typed-elements}
	\begin{tabular}[t]{@{}rl}
	::= & {\em typed-middle}~~~{\em element-list}~~~%
	      {\em typed-middle} \\
	$|$ & {\em doubled-typed-middle}
	\end{tabular}
\\[0.5ex]
\emkey{element-list} ::= see \pagref{ELEMENT-LIST}
\\[0.5ex]
\emkey{opening-type-and-attributes}\label{OPENING-TYPE-AND-ATTRIBUTES}
	\begin{tabular}[t]{@{}rl}
	::= & {\em bracket-type-label} \\
	$|$ & {\em bracket-type-label}~~~{\em typed-attribute-begin}~~~%
		                 {\em attribute-list}
	\end{tabular}
\\[0.5ex]
\emkey{closing-type-and-attributes}
	\begin{tabular}[t]{@{}rl}
	::= & {\em bracket-type-label} \\
        $|$ & {\em attribute-list} but not {\em attribute-label} \\
	$|$ & {\em attribute-list}~~~{\em typed-attribute-begin}~~~%
		                 {\em bracket-type-label}
	\end{tabular}
\\[0.5ex]
\emkey{attribute-list}\label{ATTRIBUTE-LIST} ::= {\em attribute}~~~%
	\{ {\em typed-attribute-separator}~~~{\em attribute} \}\STAR{}
\\[0.5ex]
\emkey{attribute}\label{ATTRIBUTE}
                  \begin{tabular}[t]{@{}rl}
                  ::= & {\em attribute-label}~~~%
		        \begin{tabular}[t]{@{}l}
	                {\em attribute-flags}\QMARK{} \\
	                {\em typed-attribute-equal}~~~%
			{\em single-attribute-values} \\
			\end{tabular} \\
                  $|$ & {\em attribute-label}~~~%
		        \begin{tabular}[t]{@{}l}
	                {\em attribute-flags}\QMARK{} \\
	                {\em typed-attribute-equal}~~~%
			{\em double-attribute-values} \\
	                {\em typed-attribute-equal}~~~%
			{\em reverse-attribute-label} \\
			\end{tabular} \\
                  $|$ & {\em attribute-label}~~~%
	                {\em attribute-flags} \\
                  $|$ & {\em attribute-label} \\
                  $|$ & {\em typed-attribute-negator}~~~%
		        {\em attribute-label} \\
		  \end{tabular}
\\[0.5ex]
\emkey{label} ::= \{ {\em word} $|$ {\em numeric} $|$ {\em quoted-string} \}
                  ~ {\em label-component}\STAR{}
\\[0.5ex]
\emkey{label-component} ::=
    \begin{tabular}[t]{@{}l}
    {\em word} $|$ {\em natural} $|$ {\em number}
               $|$ {\em numeric} $|$ {\em numeric-word}
	       $|$ {\em quoted-string} \\
    but \underline{not} {\em mark} or {\em separator} \\
    \end{tabular}
\\[0.5ex]
\emkey{bracket-type-label}\label{BRACKET-TYPE-LABEL} ::= {\em label }
\\[0.5ex]
\emkey{bracket-type-mark}\label{BRACKET-TYPE-MARK} ::= {\em mark}
\\[0.5ex]
\emkey{bracket-type}\label{BRACKET-TYPE}
    \begin{tabular}[t]{rl}
    ::= & {\em bracket-type-label } $|$ {\em bracket-type-mark} \\
    $|$ & MIN label with elements {\em bracket-type-mark-1} and
          {\em bracket-type-mark-2}
    \end{tabular}
\\[0.5ex]
\emkey{attribute-label} ::= {\em label}
\\[0.5ex]
\emkey{reverse-attribute-label} ::= {\em attribute-label}
\\[0.5ex]
\emkey{attribute-flags} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{@{}l}
    {\em untyped-bracketed-subexpression}
    (\pagref{UNTYPED-BRACKETED-SUBEXPRESSION})
    with {\em attribute-flag-items} as {\em elements} \\
    and {\em typed-attribute-flags-opening} as {\em opening-bracket}
    \end{tabular}
\\[0.5ex]
\emkey{attribute-flag-items} :::=
    {\em attribute-flag-item}\QMARK{}
    \{ \TT{,} {\em attribute-flag-item}\QMARK{} \}\STAR{}
\\[0.5ex]
\emkey{attribute-flag-item}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} or {\em mark} containing only letters
			    and/or \TT{*+-/@\&\#=\$\%<>} \\
    $|$ & {\em attribute-flag-index} \\
    \end{tabular}
\\[0.5ex]
\emkey{attribute-flag-index} ::= {\em natural}
\\[0.5ex]
\emkey{single-attribute-values} ::= {\em single-attribute-single-value }
                                $|$ {\em single-attribute-multivalue}
\\[0.5ex]
\emkey{single-attribute-single-value} ::= {\em value }
\\[0.5ex]
\emkey{single-attribute-multivalue} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{@{}l}
    {\em untyped-bracketed-subexpression}
    (\pagref{UNTYPED-BRACKETED-SUBEXPRESSION})
    with {\em values} as {\em elements}, \\
    {\em typed-attribute-multivalue-opening} as {\em opening-bracket}, \\
    and \TT{multivalue} reformatter
    (\pagref{MULTIVALUE-REFORMATTER})
    \end{tabular}
\\[0.5ex]
\emkey{double-attribute-values} ::= {\em object-id }
                                $|$ {\em double-attribute-multivalue}
\\[0.5ex]
\emkey{double-attribute-multivalue} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{@{}l}
    {\em untyped-bracketed-subexpression}
    (\pagref{UNTYPED-BRACKETED-SUBEXPRESSION})
    with {\em object-ids} as {\em elements}, \\
    {\em typed-attribute-multivalue-opening} as {\em opening-bracket}, \\
    and \TT{multivalue} reformatter
    (\pagref{MULTIVALUE-REFORMATTER})
    \end{tabular}
\\[0.5ex]
\emkey{value} ::= {\em label-component}\PLUS{}
              $|$ {\em bracketed-subexpression}
\\[0.5ex]
\emkey{object-id} :::= \begin{tabular}[t]{l}
                      \ttmkey{@}{in object ID} {\em ID-number}
		      $|$ \TT{@<}{\em ID-symbol}\TT{>} \\
		      This is a special kind of {\em label}.
		      \end{tabular}
\\[0.5ex]
\emkey{ID-number} :::= {\em non-zero-ASCII-digit} ~ {\em ASCII-digit}\STAR{}
\\[0.5ex]
\emkey{ID-symbol} :::= {\em ASCII-letter} ~ {\em ASCII-letter-or-digit}\STAR{}
\\[2ex]
Most of the following are defined by the {\em parser-typed-bracket-command}
    (\pagref{PARSER-TYPED-BRACKET-COMMAND}):
\begin{indpar}[0.2in]
\emkey{typed-opening} ::= {\em key} ~~~ [e.g.~`\TT{\{}']
    \label{TYPED-OPENING}
\\[0.5ex]
\emkey{typed-middle} ::= {\em key} ~~~ [e.g.~`\TT{|}']
\\[0.5ex]
\emkey{typed-closing} ::= {\em key} ~~~ [e.g.~`\TT{\}}']
    \label{TYPED-CLOSING}
\\[0.5ex]
\emkey{typed-attribute-begin} ::= {\em key} ~~~ [e.g.~`\TT{:}']
\\[0.5ex]
\emkey{typed-attribute-separator} ::= {\em key} ~~~ [e.g.~`\TT{,}']
\\[0.5ex]
\emkey{typed-attribute-equal} ::= {\em key} ~~~ [e.g.~`\TT{=}']
\\[0.5ex]
\emkey{typed-attribute-negator} ::= {\em key} ~~~ [e.g.~`\TT{no}']
\\[0.5ex]
\emkey{typed-attribute-flags-opening} ::= {\em key} ~~~ [e.g.~`\TT{[}']
\\[0.5ex]
\emkey{typed-attribute-multivalue-opening} ::= {\em key} ~~~ [e.g.~`\TT{\{*}']
\\[0.5ex]
\emkey{doubled-typed-middle} :::=
    \begin{tabular}[t]{@{}l}
    {\em typed-middle}~~~{\em typed-middle} ~~~~~ [e.g.~`\TT{||}'] \\
    as a single lexeme (when possible): see text
    \end{tabular}
\end{indpar}
The following rules apply to the set of all {\em attributes} in a
single {\em typed-bracketed-subexpression}:
\begin{enumerate}
\item
An {\em attribute} that is just `{\em attribute-label}' is equivalent to: \\
\hspace*{1in} {\em attribute-label}~~~{\em typed-attribute-equal}~~~\TT{TRUE}
\item
An {\em attribute} that is just
`{\em typed-attribute-negator}~~~{\em attribute-label}' is equivalent to: \\
\hspace*{1in}{\em attribute-label}~~~{\em typed-attribute-equal}~~~\TT{FALSE}
\item
An {\em attribute} that is just
`{\em attribute-label}~~~{\em attribute-flags}' sets just the attribute
flags and does \underline{not} set any attribute values
\item
For a given {\em attribute-label}, at most one {\em attribute} containing
{\em attribute-flags} may appear.
\item
For a given {\em attribute-label}, at most one {\em attribute} containing a
{\em single-attribute-single-value} may appear, unless the
{\em attribute-label} has been given the \TT{M} or \TT{S} flag by the
given {\em attribute} or a preceding {\em attribute}.
\end{enumerate}
\end{indpar}

A {\em typed-bracketed-subexpression} is converted to a
MIN object whose list elements are the components of the
subexpression between {\em typed-middles} (e.g., `\TT{|}'s).  The
{\em bracket-type}, if it is not missing
(and therefore \underline{not} \TT{""}), becomes the \TT{.type}
attribute of this object.  An {\em attribute-label}
becomes an attribute name of the object, and
{\em single-attribute-values} in an {\em attribute}
become the values of the {\em attribute}'s attribute name.
{\em Attribute-flags} in an {\em attribute}
become the flags of the {\em attribute}'s attribute name.
{\em Double-attribute-values} in an {\em attribute}
become the values of the attribute name/reverse attribute name
specified by the {\em attribute}'s {\em attribute-label} and
{\em reverse-attribute-label}.  The MIN object is given the
hidden \TT{.position} attribute specifying the position in the
input text of the {\em typed-bracketed-subexpression} and the
positions of each of its {\em elements}.

A {\em typed-bracketed-subexpression} with {\em bracket-type-marks}
(e.g., \TT{+}) has just \TT{.type} and \TT{.pos\-i\-tion}
attributes, and no other attributes.  The \TT{.type}
is never missing.  If the beginning and ending
{\em bracket-type-marks} are identical (e.g., \TT{\{+\ldots+\}}),
the {\em bracket-type}
is just a MIN string equal to these {\em bracket-type-marks},
but if the two {\em bracket-type-marks} are \underline{not} identical
(e.g., \TT{\{<\ldots>\}}),
the {\em bracket-type} is the MIN label whose first element is
{\em bracket-type-mark-1} and whose second element is
{\em bracket-type-mark-2}.

Note that {\em marks} cannot be part of a {\em label}, so a
{\em bracket-type-mark} cannot be part of a {\em bracket-type-label}.

Note that a {\em typed-bracketed-subexpression} must contain a
{\em typed-middle} (e.g., `\TT{|}'), unless it has
\underline{two} {\em bracket-type-marks} or is the degenerate
form `\TT{\{\}}'.
{\em Typed-prefix-separators} (\itemref{TYPED-PREFIX-SEPARATORS})
are syntactically similar to {\em typed-bracketed-subexpressions}
but have no {\em typed-middle} and at most one {\em bracket-type-mark},
and therefore have cannot have any {\em elements}.

Note that the MIN object is \underline{not} given \TT{.initiator}
~or~ \TT{.terminator} attributes, unless they are given as explicit
attributes as in:
\begin{center}
\TT{\{ "":~.initiator = "(", .terminator = ")" | 1 2 3 4 |\}}
\end{center}

If two {\em typed-middles} (e.g., `\TT{|}'s) with no intervening space
are lexically scanned as a single lexeme, then this new
{\em doubled-typed-middle} lexeme (e.g., `\TT{||}') can be used
to represent an empty list in place of
two {\em typed-middle} lexemes with an intervening space.
Note that in this case the {\em typed-middle} is required to be
a \underline{single} lexeme.

If a typed bracketed subexpression ends pre-maturely,
a parsing error is announced and any missing but required
{\em typed-middle} (e.g.~`\TT{|})
or final {\em bracket-type-mark}
and {\em typed-closing} (e.g.~`\TT{\}}'),
are inserted in the input
just after the pre-maturely ended subexpression.  Such a pre-mature end can be
discovered by finding the {\em closing-bracket} of a containing
untyped bracketed subexpression, the {\em typed-closing}
of a containing typed bracketed subexpression with a different
{\em typed-closing}, a {\em typed-closing} following a missing
{\em typed-middle}, the end of the logical line
containing the typed bracketed subexpression,
or an end of file.  However, the end must be enabled by the
parsing options (e.g., a {\em closing-bracket} cannot pre-maturely
end a subexpression if `\TT{end at outer closing}' is not a parsing
option).

When a {\em typed-opening} (e.g.~`\TT{\{}') is recognized,
the current parsing selector set and options become the
\ikey{context selectors and options}%
{context!selectors and options!of {\em typed-bracketed-subexpression}}%
\label{CONTEXT-SELECTORS}
of the {\em typed-bracketed-subexpression}.
The current parsing selectors are then reset to the
{\em typed-attribute-selectors} associated with the {\em typed-opening}
(see below), while the options remain the same as the context options
but with the `\TT{end at line separator}',
`\TT{enable indented paragraph}', and `\TT{enable header}' options turned
off.
These selectors and options are used to scan the {\em bracket-type}
and {\em attributes}, but \underline{not} the {\em elements}.
{\em Type-attribute-selectors} typically consists of just the
\TT{data} selector.

When a {\em bracket-type-label} is encountered, it is looked up in the
bracket type definition table (\itemref{BRACKET-TYPE-DEFINITIONS})
using the context selectors.
\label{TYPED-PARSING-SELECTORS-USE}
If an entry is found, the selectors and options used to scan
the {\em elements} are computed by modifying the context selectors
and options according to the
{\em bracket-selectors} and {\em bracket-options} in the
found entry.
If no entry is found, the selectors and options used to scan
the {\em elements} are computed by modifying the context selectors
and options according to the
{\em bracket-selectors} and {\em bracket-options}
associated with the {\em typed-opening} by the
\TT{parser define typed bracket} command (see below).

A {\em bracket-type-mark} is also looked up in the
bracket type table when it is encountered, and
any entry found is used to modify the context selectors
and options used to scan {\em elements} of its
{\em typed-bracketed-subexpression}.  When an initial
{\em bracket-type-mark-1} is not the same as the final
{\em bracket-type-mark-2}, and the two are combined into
a MIN label that becomes the {\em bracket-type},
\underline{only} the initial {\em bracket-type-mark-1}
is looked up to find the bracket type definition.

The parsing selectors and options are reset to the
context selectors and options after the subexpression ending
{\em typed-closing} (e.g.~`\TT{\}}') is recognized.

A {\em typed-opening} is specified by a
\ttmkey{define typed bracket}{parser command}
parser command.  An example is:

\begin{center}
\begin{tabular}{l}
\TT{parser define typed bracket "\{"~...~"|"~...~"|"~...~"\}"} \\
\TT{~~~~[text]~} \\
\TT{~~~~with parsing selectors [- data]} \\
\TT{~~~~with parsing options [- end at outer closing]} \\
\TT{~~~~with attribute selectors [data]} \\
\TT{~~~~with attributes ":"~...~"="~...~","} \\
\TT{~~~~with attribute negator "no"} \\
\TT{~~~~with attribute flags initiator "["} \\
\TT{~~~~with attribute multivalue initiator "\{*"} \\
\TT{~~~~with prefix selectors [text]} \\
\end{tabular}
\end{center}
which specifies
\begin{center}
\begin{tabular}{l}
`\TT{\{}' to be a {\em typed-opening} \\
`\TT{|}' to be a {\em typed-middle} \\
`\TT{||}' to be by implication the {\em doubled-typed-middle} \\
`\TT{\}}' to be a {\em typed-closing} \\
`\TT{text}' to be the sole definition selector \\
`\TT{[- data] }' to be the {\em bracket-selectors} \\
`\begin{tabular}[t]{@{}l}
 \TT{[- end at outer closing, - end at line separator,} \\
 \TT{~- enable indented paragraph, - enable header]}' \\
 \end{tabular} \\
~~~~~~to be the {\em bracket-options}; \\
~~~~~~here `\TT{- end at line separator}',
           `\TT{- enable indented paragraph}', \\
~~~~~~and `\TT{- enable header}' are implied. \\
`\TT{[data]}' to be the {\em typed-attribute-selectors} \\
`\TT{:}' to be the {\em typed-attribute-begin} \\
`\TT{=}' to be the {\em typed-attribute-equal} \\
`\TT{,}' to be the {\em typed-attribute-separator} \\
`\TT{no}' to be the {\em typed-attribute-negator} \\
`\TT{[}' to be the {\em typed-attribute-flags-opening} \\
`\TT{\{*}' to be the {\em typed-attribute-multivalue-opening}
\\[1.0ex]
\begin{minipage}{5in}
That a {\em typed-bracketed-subexpression} with the give {\em typed-opening}
and no elements 
should \underline{not} be treated as a {\em typed-prefix-separator}
(see \itemref{TYPED-PREFIX-SEPARATORS}) if
the context selectors do \underline{not} have the `\TT{text}' selector.
\end{minipage}
\end{tabular}
\end{center}

Note that the {\em typed-middle} must be repeated twice and both copies must
be identical.  Also, if {\em typed-middle} denotes
a single string lexeme which when concatenated
with itself forms another single string lexeme (as `\TT{|}' concatenated
with itself forms `\TT{||}'), this second doubled lexeme can be used
in place of two consecutive {\em typed-middles} (as in `\TT{\{||\}}'
being used in place of `\TT{\{|~|\}}').

The general syntax of {\em parser-typed-bracket-commands} is:

\begin{indpar}
\emkey{parser-typed-bracket-command}%
\label{PARSER-TYPED-BRACKET-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define}%
          \ttmindex{define typed bracket}{parser command}
	  \begin{tabular}[t]{@{}l@{}}
	  \TT{typed bracket} ~ {\em typed-bracket-name}
	                     ~ {\em parsing-selectors} \\
	  {}[ \TT{with parsing selectors} ~
	      {\em bracket-selectors} ] \\
	  {}[ \TT{with attribute selectors} ~
	      {\em typed-attribute-selectors} ] \\
	  {}[ \TT{with parsing options} ~
	      {\em bracket-options} ] \\
	  {}[ \TT{with attributes} ~ {\em typed-attribute-punctuation} ] \\
	  {}[ \TT{with attribute negator} ~ {\em typed-attribute-negator} ] \\
	  {}[ \TT{with} \begin{tabular}[t]{l}
	                \TT{attribute flags initiator} \\
	                {\em typed-attribute-flags-opening} ]
			\end{tabular} \\
	  {}[ \TT{with} \begin{tabular}[t]{l}
	                \TT{attribute multivalue initiator} \\
	                {\em typed-attribute-multivalue-opening} ]
			\end{tabular} \\
	  {}[ \TT{with prefix selectors} {\em typed-prefix-selectors} ] \\
	  \end{tabular} \\
    $|$ & \ttmkey{undefine typed bracket}{parser command} ~
	  \begin{tabular}[t]{@{}l@{}}
	  {\em typed-bracket-name} \\
	  {\em parsing-selectors} \\
	  \end{tabular} \\
    $|$ & \ttmkey{print typed bracket}{parser command} ~
	  {\em partial-typed-opening} \\
    \end{tabular}
\\[0.5ex]
\emkey{typed-bracket-name}  \\
\hspace*{0.2in}\begin{tabular}[t]{rl}
    ::= & {\em typed-opening} \TT{...}
          \TT{...} {\em typed-middle} \TT{...} {\em typed-middle}
          \TT{...} {\em typed-closing} \\
    $|$ & {\em typed-opening} \TT{...} {\em typed-closing} \\
    \end{tabular}
\\[0.5ex]
\emkey{typed-opening} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-middle} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-closing} ::= {\em quoted-key}
\\[0.5ex]
\emkey{partial-typed-opening} ::= {\em quoted-key}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\\[0.5ex]
\emkey{bracket-selectors} ::= see \pagref{BRACKET-SELECTORS}
\\[0.5ex]
\emkey{bracket-options} ::= see \pagref{BRACKET-OPTIONS}
\\[0.5ex]
\emkey{typed-attribute-selectors} ::= {\em selector-flags}
	~ [\pagref{SELECTOR-FLAGS}]
\\[0.5ex]
\emkey{typed-attribute-punctuation} ::= \\
    \hspace*{0.2in}
     {\em typed-attribute-begin}
     \TT{...} {\em typed-attribute-equal}
     \TT{...} {\em typed-attribute-separator}
\\[0.5ex]
\emkey{typed-attribute-begin} ::= {\em quoted-key}\label{TYPED-ATTRIBUTE-BEGIN}
\\[0.5ex]
\emkey{typed-attribute-equal} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-attribute-separator} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-attribute-negator} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-attribute-flags-opening} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-attribute-multivalue-opening} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-prefix-selectors}\label{TYPED-PREFIX-SELECTORS}
    ::= {\em selector-flags} ~ [\pagref{SELECTOR-FLAGS}]

\label{TYPED-BRACKET-DEFINITIONS}
\end{indpar}

The `\TT{print typed bracket} {\em partial-typed-opening}' command
prints all typed bracket symbol table entries whose
{\em typed-opening} contains the {\em partial-typed-opening}
as a (not necessarily initial) subsequence of lexemes.  Using \TT{""} as
a {\em partial-typed-opening} will print all typed bracket
symbol table entries.

The following is an example \TT{define typed bracket} command:
\begin{indpar}\begin{verbatim}
define typed bracket "\{" ... "|" ... "|" ... "\}"
                     [code, text, math]
       // `||' abbreviates `| |'
       // there are NO PARSING SELECTORS
       // there are NO PARSING OPTIONS
       with attribute selectors [data]
       with attributes ":" ... "=" ... ","
       with attribute negator "no"
       with attribute flags initiator "["
       with attribute multivalue initiator "\{*"
\end{verbatim}\end{indpar}

When `\TT{with parsing options}'
does not appear in a `{\tt define typed bracket ...}' command,
the parsing options used
to scan any {\em elements} are the same as the context options
modified by any parsing options
found when the {\em bracket-type} is looked up in the
bracket type table.
Similarly when
`\TT{with parsing selectors}' does not appear in a
`{\tt define typed bracket ...}' command,
the parsing selectors used to scan {\em elements}
are the same as the context selectors
modified by any parsing selectors
found when the {\em bracket-type} is looked up in the
bracket type table.
Note, however, that `\TT{- TOP LEVEL}' and `\TT{- LINE LEVEL}' are
implied by default in {\em bracket-selectors}, and
`\TT{- end at line separator}',
`\TT{ - enable indented paragraph}', and
`\TT{ - enable header}' are always implied by default in
{\em bracket-options}.

The untyped bracket definitions for `\TT{[\ldots]}' and
`\TT{\{*\ldots*\}}' given on \pagref{UNTYPED-BRACKET-BUILTINS},
all with the `\TT{data}' selector, are used to parse
attribute flags and multivalue lists in any
{\em typed-bracketed-subexpression} recognized by these definitions.

\begin{center}\label{TOP-LEVEL-{}}
\begin{tabular}{l}
\multicolumn{1}{c}{\bf Initial Typed Bracket Parser Command}
\\\hline
\tt define typed bracket "\{" ... "|" ... "|" ... "\}" [data] \\
\tt ~~~~~~~// `||' abbreviates `| |' \\
\tt ~~~~~~~// there are NO PARSING SELECTORS \\
\tt ~~~~~~~// there are NO PARSING OPTIONS \\
\tt ~~~~~~~with attribute selectors [data] \\
\tt ~~~~~~~with attributes ":" ... "=" ... "," \\
\tt ~~~~~~~with attribute negator "no" \\
\tt ~~~~~~~with attribute flags initiator "[" \\
\tt ~~~~~~~with attribute multivalue initiator "\{*" \\
\tt ~~~~~~~with prefix selectors [] \\
\end{tabular}
\\[2ex]
\begin{tabular}{l}
\multicolumn{1}{c}
{\bf Standard `\ttkey{brackets}'\label{STANDARD-BRACKETS-2} Component
     Typed Bracket Parser Command}
\\[1ex]
\multicolumn{1}{c}
{This Command Requires at Least One of {\tt + code, + text, + math}} \\
\multicolumn{1}{c}
{Selectors with Missing Standard Qualifiers are Deleted from the Command}
\\[1ex]
\tt define typed bracket "\{" ... "|" ... "|" ... "\}" \\
\tt ~~~~~~~~~~~~~~~~~~~~~[code, text, math] \\
\tt ~~~~~~~// `||' abbreviates `| |' \\
\tt ~~~~~~~// there are NO PARSING SELECTORS \\
\tt ~~~~~~~// there are NO PARSING OPTIONS \\
\tt ~~~~~~~with attribute selectors [data] \\
\tt ~~~~~~~with attributes ":" ... "=" ... "," \\
\tt ~~~~~~~with attribute negator "no" \\
\tt ~~~~~~~with attribute flags initiator "[" \\
\tt ~~~~~~~with attribute multivalue initiator "\{*" \\
\end{tabular}
\end{center}

\subsubsection{Typed Prefix Separators}
\label{TYPED-PREFIX-SEPARATORS}

A \key{typed prefix separator}
has the same syntax as a {\em typed-bracketed-subexpression}
but with no {\em typed-middles} (e.g., `\TT{|}'s) and therefore
no {\em elements}, or with only a single {\em bracket-type-mark}
and no {\em elements}.
Some examples are:
\begin{center}
\TT{\{my type\}} \\
\TT{\{my type: my attribute = 5, my option = TRUE\}} \\
\TT{\{my type: my attribute = 5, your option = FALSE\}} \\
\TT{\{my type: my attribute = 5, my option\}} \\
\TT{\{my type: my attribute = 5, not your option\}} \\
\TT{\{+\}} \\
\end{center}

The general syntax of a typed prefix separator is:

\begin{indpar}[0.1in]
\emkey{typed-prefix-separator}\label{TYPED-PREFIX-SEPARATOR} \\
\hspace*{0.5in}\begin{tabular}[t]{@{}rl}
    ::= & {\em typed-opening}~~~{\em bracket-type-label}~~~%
          {\em opening-attributes}\QMARK{}~~~{\em typed-closing} \\
    $|$ & {\em typed-opening}~~~{\em bracket-type-mark}~~~{\em typed-closing} \\
    \end{tabular}
\\[0.5em]
\emkey{typed-opening} ::= see \pagref{TYPED-OPENING}
\\[0.5em]
\emkey{typed-closing} ::= see \pagref{TYPED-CLOSING}
\\[0.5em]
\emkey{opening-attributes}
    ::= {\em typed-attribute-begin}~~~{\em attribute-list}
\\[0.5em]
\emkey{typed-attribute-begin} ::= see \pagref{TYPED-ATTRIBUTE-BEGIN}
\\[0.5em]
\emkey{attribute-list} ::= see \pagref{ATTRIBUTE-LIST}
\\[0.5em]
\emkey{bracket-type-label} ::= see \pagref{BRACKET-TYPE-LABEL}
\\[0.5em]
\emkey{bracket-type-mark} ::= see \pagref{BRACKET-TYPE-MARK}
\end{indpar}

{\em Typed-prefix-separators} and {\em typed-bracketed-subexpressions}
are parsed by the same algorithm which is driven by parameters from
the same {\em parser-typed-bracket-command} for a given {\em typed-opening}
(e.g., `\TT{\{}').
After the {\em typed-closing}
(e.g., `\TT{\}}') is read, the parsed subexpression is classified as
a {\em typed-prefix-separator} if all of the following are true:
\newcounter{PREFIX-COUNTER}
\begin{enumerate}
\item The subexpression does not contain a {\em typed-middle} (e.g., `\TT{|}'). 
\item The subexpression does not contain {\em bracket-type-marks}.
\item The subexpression contains a non-missing
      {\em bracket-type} (e.g., the subexpression is \underline{not}
      `\TT{\{\}}' or `\TT{\{""\}}').
\setcounter{PREFIX-COUNTER}{\value{enumi}}
\end{enumerate}
A {\em typed-prefix-separator} is classified as a \key{prefix}\label{PREFIX}
if in addition the following are true:
\begin{enumerate}
\setcounter{enumi}{\value{PREFIX-COUNTER}}
\item\label{TYPED-PREFIX-SELECTORS-USE}
The subexpression context selectors (\pagref{CONTEXT-SELECTORS})
and the {\em typed-prefix-selectors} (\pagref{TYPED-PREFIX-SELECTORS})
associated with the {\em typed-opening} by the
{\em parser-typed-bracket-command} have at least one selector flag in
common (the {\em typed-prefix-selectors} default to all selectors on,
so this requirement is met by default).
\item At least one of the following is true:
\begin{enumerate}
\item The `\TT{enable prefix}' option is set in the context options.
\item The `\TT{enable table prefix}' option is set in the context options
      and a bracket table entry was found for the {\em bracket-type}.
\item The `\TT{enable header}' option is set in the context options
      and a bracket table entry with `\TT{paragraph}' or `\TT{line}'
      group was found for the {\em bracket-type}.
\end{enumerate}
\end{enumerate}

A {\em typed-prefix-separator} is converted to a MIN object which has the
same structure as a typed bracketed subexpression with an empty element list.
In particular, the {\em bracket-type} of the {\em typed-prefix-separator}
becomes the \TT{.type} attribute of the MIN object.

If a {\em typed-prefix-separator} is a {\em prefix},
it becomes a \TT{PREFIX} token that can head a {\em prefix-N-list}.
Otherwise it becomes a \TT{BRACKETED} token by itself
that \underline{cannot} head a {\em prefix-N-list}, but which can
be a {\em prefix-N-list} {\em element}.

{\em Prefixes} are used to form {\em prefix-N-lists}.%
\label{PREFIX-0-LIST}
The following is an example in which the entire text is a single
logical line, in spite of the lack of indentation of continuation
lines, because {\tt \{p\}} is a special
paragraph prefix with `{\tt + end at paragraph break}'
and `{\tt - end at le indent}' options:


\begin{tabular}{p{3.5in}|l|l}
Text	& Separator &  Syntactic Category
\\\hline
\raggedright
\tt \{p\} \{s\} This is a sentence. \{s\} And
another.  \{s\} And yet another
\{foo\} sentence. & \tt \{p\} & \em prefix-0-list
\\\hline
\tt \{s\} This is a sentence.	& \tt \{s\} & \em prefix-1-list
\\\hline
\tt This is a sentence.	& (none) & \em prefix-2-list
\\\hline
\tt \{s\} And another sentence.  	& \tt \{s\} & \em prefix-1-list
\\\hline
\tt And another sentence. & (none) & \em prefix-2-list
\\\hline
\tt \{s\} And yet another \{foo\} sentence. & \tt \{s\} & \em prefix-1-list
\\\hline
\tt And yet another \{foo\} sentence. & (none) & \em prefix-2-list \\
			       &        & \TT{\{foo\}} is in error \\
			       &        & and is ignored (deleted).
\end{tabular}

The {\em prefix-0-list} in this example would be equivalent to:
\begin{indpar}\begin{verbatim}
{p|  {s| This is a sentence "." |s}
     {s| And another "." |s}
     {s| And a yet another sentence "." |s} |p}
         // `{foo}' deleted
\end{verbatim}\end{indpar}

except that {\tt \{s\}} is a special sentence prefix that invokes
a the \TT{sentence} reformatter (\pagref{SENTENCE-REFORMATTER})
which moves the {\tt "."} into a {\tt .terminator} attribute, so the
example is finally equivalent to:
\begin{indpar}[0.2in]\begin{verbatim}
{p|  {s: .terminator = "."| This is a sentence |s}
     {s: .terminator = "."| And another |s}
     {s: .terminator = "."| And a yet another sentence |s} |p}
\end{verbatim}\end{indpar}

If we changed {\tt \{p\}} to {\tt \{P\}} and {\tt \{s\}} to {\tt \{S\}}, there
would nothing special about the prefixes, the continuation
lines would have to be indented, and {\tt "."} would not be moved.

The general syntax of a prefix-n list is:

\begin{indpar}[0.1in]
\emkey{prefix-n-list}\label{PREFIX-N-LIST}
    \begin{tabular}[t]{@{}rl}
    ::= & \{ {\em prefix-n} {\em prefix-(n+1)-list} \}\PLUS{} \\
    $|$ & {\em simple-element-list} \\
    \end{tabular}
\\[0.5ex]
\emkey{prefix-n} ::= {\em prefix}
\\[0.5ex]
\emkey{prefix} ::= see text above
\\[0.5ex]
\emkey{simple-element-list} ::= see \pagref{SIMPLE-ELEMENT-LIST}
\\[0.5ex]
Note: \begin{minipage}[t]{5.8in}
      All the {\em prefix-n}'s in a given {\em prefix-n-list} must
      have the same group.  The group of a {\em prefix-n} is its
      {\em bracket-type} unless this has a bracket type definition with
      a non-missing \TT{group} member: see \pagref{BRACKET-TYPE-GROUP}.
      \end{minipage}
\end{indpar}

The elements of a {\em prefix-n-list} are modified by taking
each `{\em prefix-n} {\em prefix-(n+1)-list}' component and
moving the {\em prefix-(n+1)-list} elements to
the MIN object represented by {\em prefix-n}.  So, for example,
\begin{center}
\TT{\{T\} X Y Z}
\end{center}
is just alternate syntax for
\begin{center}
\TT{\{T| X Y Z |\}}
\end{center}

\subsubsection{Bracket Type Definitions}
\label{BRACKET-TYPE-DEFINITIONS}

Unlike brackets and indentation marks, {\em bracket-types}
(\pagref{BRACKET-TYPE}) do {\bf not}
have to be defined in order to be used.  But a {\em bracket-type}
can be defined so that it has special effects on parsing, particularly
if it is the {\em bracket-type} of a {\em typed-prefix-separator}.

Bracket type definitions are stored in the `\key{bracket type table}'
which is one of the parser symbol tables.

When a {\em typed-bracketed-subexpression} or {\em typed-prefix-separator}
is parsed, its {\em bracket-type}
(i.e., its \TT{.type} if it has one) is looked up
in the bracket type table using the selectors in effect at the beginning
of the subexpression or separator parse (the context selectors).
If a table entry is found, it is used to provide information
that affects the parse of the
{\em elements} of a {\em typed-bracketed-subexpression}
or the {\em elements} of a {\em prefix-n-list}
that begins with a {\em typed-prefix-separator}.

Entries in the bracket type table are managed by
{\em parser-bracket-type-commands}
whose general syntax is:

\begin{indpar}
\emkey{parser-bracket-type-command}%
\label{PARSER-BRACKET-TYPE-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define}%
          \ttmindex{define bracket type}{parser command} ~
	  \begin{tabular}[t]{@{}l@{}}
	  \TT{bracket type} ~ {\em bracket-type-name}
	                    ~ {\em parsing-selectors} \\
	  {}[ \TT{with parsing selectors} ~ {\em bracket-type-selectors} ] \\
	  {}[ \TT{with group} ~ {\em bracket-type-group} ] \\
	  {}[ \TT{with implied subprefix} ~ {\em implied-prefix} ] \\
          {}[ \TT{with~}\{ \TT{paragraph} | \TT{line} \}\QMARK{} \TT{~}%
	                  \begin{tabular}[t]{@{}l@{}}
			  \TT{lexical master} \\
			  {\em lexical-master-name} ] \\
			  \end{tabular} \\
	  {}[ \TT{with parsing options} ~ {\em bracket-type-options} ] \\
          {}[ \TT{with} ~ \begin{tabular}[t]{@{}l}
	                  {\em reformatter-name} ~ \TT{reformatter} \\
			  {\em reformatter-arguments}\QMARK{} ] \\
			  \end{tabular} \\
	  \end{tabular} \\
    $|$ & \ttmkey{undefine bracket type}{parser command} ~
	  {\em bracket-type-name} ~
	  {\em parsing-selectors} \\
    $|$ & \ttmkey{print bracket type}{parser command} ~
	  {\em partial-bracket-type-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{bracket-type-name} ::= {\em quoted-key}
\\[0.5ex]
\emkey{partial-bracket-type-name} ::= {\em quoted-key}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\\[0.5ex]
\emkey{bracket-type-selectors} ::= 
    {\em selector-spec} ~~~ [\pagref{SELECTOR-SPEC}]
\\[0.5ex]
\emkey{bracket-type-group} ::= {\em quoted-key}
                     $|$ {\em simple-name} not containing `\TT{with}'
\\[0.5ex]
\emkey{implied-prefix} ::= {\em typed-prefix-separator}\label{IMPLIED-PREFIX}
				~~~~~ [\pagref{TYPED-PREFIX-SEPARATOR}]
\\[0.5ex]
\emkey{lexical-master-name} ::= {\em quoted-key}
                    $|$ {\em simple-name} not containing `\TT{with}'
\\[0.5ex]
\emkey{bracket-type-options} ::=
    {\em option-spec} ~~~ [\pagref{OPTION-SPEC}]
\\[0.5ex]
\emkey{reformatter-name} ::= see \pagref{REFORMATTER-NAME} \\
\emkey{reformatter-arguments} ::= see \pagref{REFORMATTER-ARGUMENTS}

\end{indpar}


The `\TT{print bracket type} {\em partial-bracket-type-name}' command
prints all bracket type symbol table entries whose
{\em bracket-type-name} contains the {\em partial-bracket-type-name}
as a (not necessarily initial) subsequence of lexemes.  Using \TT{""} as
a {\em partial-bracket-type-name} will print all bracket type
symbol table entries.


The components special to a bracket type definition are:

\begin{indpar}[0.4in]

\hspace*{-0.2in}\ttmkey{parsing selectors}{in bracket type definition}\\
The elements of a {\em typed-bracketed-subexpression}
are parsed using the parsing selectors as they were at the beginning
subexpression (the context selectors of the subexpression) as modified by any
{\em bracket-type-selectors} found in a bracket type definition of
the {\em bracket-type} of the subexpression, if a bracket type definition is
found.  If no definition is found, the {\em bracket-selectors} of the
{\em parser-typed-bracket-command} for the {\em typed-opening} are used:
see \pagref{TYPED-PARSING-SELECTORS-USE}.

The elements of the {\em prefix-(n+1)-list} following a {\em prefix-n}
are parsed using the parsing selectors as they were at the beginning
of the containing {\em prefix-n-list} (the context selectors of the
{\em prefix-n}) as modified by any
{\em bracket-type-selectors} found in a bracket type definition of
the {\em bracket-type} of the {\em prefix-n}.
These same modified
selectors are also used to parse any subsequent {\em prefix-m} in the list
and look up its \TT{.type} in the bracket type table, even if
$m\leq n$.  So the selector modifications
should the chosen so that they do not affect parsing of
{\em typed-prefix-separators} or lookup of bracket type table definitions.

More specifically, consider {\em prefix-m} in its {\em prefix-m-list}.
Let $S_1$ be the selectors in effect at the beginning of
the entire {\em prefix-m-list}.  Let $S_2$ be the selectors
in effect at the beginning of {\em prefix-m}, and let $S_3$ be the
selectors in effect just after {\em prefix-m}.
$S_2$ is used to parse {\em prefix-m} and look up its bracket type table
entry.  Then $S_1$ is modified by the bracket type table entry
parsing selectors to produce $S_3$ (if no bracket type table entry
was found, $S_3$ equals $S_1$).  Note that if
{\em prefix-m} is not at the beginning of its {\em prefix-m-list},
$S_1$ and $S_2$ may not be the same.
Note that prefix options below do not have the same considerations
as a bracket type table cannot modify options unless it has
\TT{paragraph} group, and a {\em prefix-m} with \TT{paragraph}
group must begin its containing {\em prefix-m-list} (which is a logical
line).

\hspace*{-0.2in}\ttmkey{group}{in bracket type definition}%
	\label{BRACKET-TYPE-GROUP}\\
If the {\em bracket-type} of a {\em prefix-n}
has a bracket type definition
with a non-missing {\em bracket-type-group}, this {\em bracket-type-group} is
the group of the {\em prefix-n}.
Otherwise the {\em bracket-type} is the group of the
{\em prefix-n}.

In an expression of the form:
\begin{center}
\{ {\em prefix-n} {\em prefix-(n+1)-list} \}\PLUS{}
\end{center}
the {\em prefix-n}'s must all have the same group, but need not all
have the same {\em bracket-type}.

The groups `\TT{paragraph}', `\TT{line}', and `\TT{reset}' are special:
see \itemref{HEADED-LINES}, \itemref{HEADED-PARAGRAPHS},
and \itemref{ISOLATED-HEADERS}.

\hspace*{-0.2in}\ttmkey{implied subprefix}{in bracket type definition}%
\label{IMPLIED-SUBPREFIX} \\
If the {\em bracket-type} of a {\em prefix-n} has a bracket type definition
with a non-missing {\em implied-prefix},
a copy of this {\em implied-prefix} is inserted immediately
after the {\em prefix-n}, and becomes the head of a {\em prefix-(n+1)-list}.
If this {\em prefix-(n+1)-list}  list has no elements other than
the {\em implied-prefix}, it is deleted and ignored.

Thus the effect is to insert the {\em implied-prefix} after the
{\em prefix-n} unless the logical line or bracketed expression
containing the {\em prefix-n-list} ends immediately after the {\em prefix-n} or
unless an explicit prefix whose group is that
of a preceding prefix (including the {\em implied-prefix}) follows
the {\em prefix-n} in the input.  However, there is one difference
if there is an explicit prefix, and this is that the selectors
used to parse the explicit prefix and find any associated bracket type
table definition will be those modified by the {\em implied-prefix}
and may differ from those that would be at the same input position
had the {\em implied-prefix} not been inserted.

More specifically, consider a {\em prefix-m-list} that begins with an implied
{\em prefix-m} followed immediately by an explicit {\em prefix-m}.
Let $SO_1$ be the selectors and options in effect at the beginning of
the entire {\em prefix-m-list}.  Let $SO_2$ be the selectors and options
in effect at the beginning of explicit {\em prefix-m}, and let $SO_3$ be the
selectors and options in effect just after the explicit {\em prefix-m}.
$SO_2$, which is $SO_1$ modified by the bracket type table entry of the
implied {\em prefix-m},
is used to parse the explicit {\em prefix-m} and look up its bracket type table
entry.  Then the implied {\em prefix-m} is deleted (an implied prefix is
deleted if its element list is empty) and
$SO_1$ is modified by the explicit {\em prefix-m}'s bracket type table entry
parsing selectors and parsing options
to produce $SO_3$ (if no bracket type table entry
was found, $SO_3$ equals $SO_1$).
Note that prefix options are only affected if the {\em prefix-m}'s have
the \TT{paragraph} group, as only bracket type table entries with that
group can have parsing options.

The {\em implied-prefix} of the bracket type definition will also be
ignored unless one of the following is true, where the context options
are the parsing options in effect at the point where the {\em implied-prefix}
is to be inserted:
\begin{enumerate}[label=(\alph*)]
\item The `\TT{enable prefix}' option is set in the context options.
\item The `\TT{enable table prefix}' option is set in the context options
      and a bracket table entry was found for the {\em bracket-type} of
      the {\em implied-prefix}.
\item The `\TT{enable header}' option is set in the context options
      and a bracket table entry with `\TT{paragraph}' or `\TT{line}'
      group was found for the {\em bracket-type} of
      the {\em implied-prefix}.
\end{enumerate}

If the {\em implied-prefix} is given, it must have the form
of a {\em typed-prefix-separator},
but within its {\em parser-bracket-type-command} it must be parsed
using a definition of its {\em typed-opening} with
empty {\em typed-prefix-selectors}, so it will be recognized
as if it were a {\em typed-bracketed-subexpression} with a {\em bracket-type}
and no {\em elements}, as per
item~\ref{TYPED-PREFIX-SELECTORS-USE}, \pagref{TYPED-PREFIX-SELECTORS-USE}.
In particular, when the parser is initialized, the \TT{TOP LEVEL}
parser block is given a suitable typed bracket definition for
\TT{"\{~ ...~"|"~...~"|"~...~"\}"}
(\pagref{TOP-LEVEL-{}}).

\hspace*{-0.2in}\ttmkey{parsing options}{in bracket type definition}\\
`\TT{with parsing options}' is only permitted for prefixes that
have the `\TT{paragraph}' group.  The {\em bracket-type-options} are
used to set the current parsing options and the
\TT{op\-tions} current line variable when an explicit
paragraph header begins a paragraph:
see \itemref{EXPLICIT-HEADER-PARSING}.

\hspace*{-0.2in}\ttmkey{line lexical master}{in bracket type definition}\\
`\TT{with line lexical master}' is only permitted for prefixes that
have the `\TT{para\-graph}' group.  
This parameter may be non-missing only for isolated paragraph headers
and mapped paragraph headers, and
is used to set the corresponding current line variable.
See \itemref{ISOLATED-HEADERS} and \itemref{LINE-VARIABLES} for details.

\end{indpar}

\subsubsubsection{Bracket Type Reformatters}
\label{BRACKET-TYPE-REFORMATTERS}

The following reformatters may be used to change the MIN value
represented by a {\em prefix-n-list} headed by a prefix with
a bracket type definition:

\begin{indpar}

\ttmkey{data}{reformatter}
        \TT{(} \begin{tabular}[t]{@{}l}
	       {\em clear-sign}\TT{,}
	       {\em assign-sign}\TT{,} \\
	       {\em attribute-initiators}\TT{,}
	       {\em equal-sign}\TT{,} {\em negator}\TT{,}
	       {\em flags-opening}\TT{,} {\em multivalue-opening} \TT{)}
	       \end{tabular}
	\label{DATA-REFORMATTER}

\begin{indpar}[0.5em]
where

\begin{indpar}[0.5in]
\emkey{attribute-initiators} ::= \TT{()} $|$
    \TT{(} {\em attribute-initiator}
	   \{ \TT{,} {\em attribute-initiator} \}\STAR{} \TT{)}
\end{indpar}

The {\em prefix-n-list} must be a token list that could be represented by
a headed logical line of the form:
\begin{center}
\TT{\{}{\em data-prefix}\TT{\}} ~ {\em ID} ~
	    {\em assign-sign} ~ {\em element-list} ~
	    {\em attribute-paragraph}\QMARK{}
\end{center}
or
\begin{center}
\TT{\{}{\em data-prefix}\TT{\}} ~ {\em clear-sign}
\end{center}
where
\begin{indpar}
\emkey{data-prefix} ::= the prefix, e.g., `\TT{data}'
\\[0.5ex]
\emkey{ID} ::= see \pagref{ID}
\\[0.5ex]
\emkey{element-list} ::= see \pagref{ELEMENT-LIST}
\\[0.5ex]
\emmkey{attribute-paragraph}{in \TT{data} reformatter} ::=
    \begin{tabular}[t]{l}
    ~~~~~~~~~~{\em attribute-initiator} ~ {\em end-of-physical-line} \\
    {\em attribute-line}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emmkey{attribute-line}{in \TT{data} reformatter} ::=
    {\em attribute} (\pagref{ATTRIBUTE}) as a logical line where:
\begin{indpar}[0.5in]
{\em typed-attribute-equal} ::= {\em equal-sign} \\
{\em typed-attribute-negator} ::= {\em negator} \\
{\em typed-attribute-flags-opening} ::= {\em flags-opening} \\
{\em typed-attribute-multivalue-opening} ::= {\em multivalue-opening}
\end{indpar}
\end{indpar}

A {\em prefix-n-list} of one of the above forms
typically arises from a logical line
that begins with an {\em ID} or {\em clear-sign}.
For such a line a special lexeme with a special
lexeme type and empty character string is prefaced
to the line, and the type of this special lexeme
is mapped (\itemref{MAPPED-LEXEMES}) to the prefix of the
subexpression, e.g., to \TT{\{data\}} or \TT{\{raw data\}}.

In order for this to work with the standard lexical program,
the {\em ID-character} (\pagref{ID-CHARACTER})
must be `\TT{@}' and the {\em clear-sign} must be `\TT{@@@@}'.

The subexpression must have one of the two above forms and
contain either a {\em clear-sign} or an {\em assign-sign}.
An {\em ID} must be either
a preallocated stub or an object (that is presumed to have replaced
a preallocated stub and be identified by an ID).
The {\em prefix} must not have any associated prefix attributes other than
\TT{.type} or \TT{.position}.  If these requirements are not met, the
\TT{data} reformatter takes no action, and the {\em prefix-n-list}
beginning with the {\em data-prefix}
is retained as is in the input, but no error is announced.

Otherwise the subexpression will be reformatted and
the entire subexpression will be deleted from the token list.
The first form of subexpression defines or adds to the datum
denoted by {\em ID}.  The second form clears the symbolic ID table.
If {\em ID} denotes
an object, the object is given
elements from the {\em element-list} and attributes from the
{\em attribute-paragraph}.

An subexpression containing the {\em clear-sign} just clears the symbolic
ID table: see \pagref{CLEAR-SYMBOLIC-TABLE}.

If {\em ID} is a preallocated stub, it is initialized to
an object with no elements or attributes.  If {\em ID}
is an object, the object must \underline{not} have
{\em elements}, {\em single-attribute-values}, or
{\em attribute-flags}, except that it can have a
\TT{.position} attribute with its flags.  The object \underline{may} have
{\em double-attribute-values} (produced by data reformatter
invocations creating the objects listed in the
{\em double-attribute-values}: see example just below).
If these rules are violated, an error is announced and the
subexpression is deleted.

Before this reformatter is invoked, the {\em prefix-n-list} is parsed
and any {\em attribute-paragraph} will become a MIN object with
{\em attribute-initiator} as \TT{.ini\-tiator}, with
\TT{min::\EOL IN\-DENT\-ED\_\EOL PARAGRAPH()} as \TT{.ter\-min\-ator},
and with logical line elements.  Different
{\em attribute-initiators} may be chosen to control how this
paragraph is parsed: e.g., are operators recognized or not.
This reformatter
then further processes these logical lines in order
using its reformatter arguments to treat each line as being
formatted in the same manner as an {\em attribute}
in a {\em typed-bracketed-subexpression}
(see \pagref{TYPED-BRACKETED-SUBEXPRESSION}).

When it is processed, an {\em attribute-line} sets attribute flags and
values exactly as it would were it an {\em attribute}
in a {\em typed-bracketed-subexpression}.
If there is an error, the error is
announced and the announcement indicates that the logical line
or the flags in it or the value in it is being ignored.


A simple example involving {\em double-attribute-values} is:
\begin{indpar}[0.2in]\begin{verbatim}
@1 :=:
    name = Jack
    wife = @2 = husband
@2 :=:
    name = Jill
    husband = @1 = wife
\end{verbatim}\end{indpar}
Here the line `{\tt wife = @2 = husband}' creates object {\tt @2}
and gives it the `{\tt husband = @1 = wife}' attribute so the line
`{\tt husband = @1 = wife}' does nothing and is redundant (as double
attribute values are sets and not multisets).

As a special case, if there is only one {\em element} which is an object,
there is no {\em attribute-paragraph},
and the {\em ID} is a preallocated stub,
then all that is done is to copy the only element
to the {\em ID} preallocated stub.
After the copying, the element and the {\em ID} are distinct but
equal objects.  Previous references to {\em ID} will become
references to the copy but not to the {\em element} copied.

For example:
\begin{center}
\begin{tabular}{lrl}
\TT{@5 := Bill}     & sets \TT{@5} to  & \TT{\{| Bill |\}} \\
		    & \multicolumn{2}{l}{which is NOT a special case}
\\[1ex]
\TT{@5 := ( a b c )} & sets \TT{@5} to & \TT{( a b c )} \\
                    & instead of      & \TT{\{| ( a b c ) |\}}
\\[1ex]
\TT{@5 := \{| a b c |\}} & sets \TT{@5} to & \TT{\{| a b c |\}} \\
                    & instead of      & \TT{\{| \{| a b c |\} |\}}
\\[1ex]
\TT{@5 := a b c}    & sets \TT{@5} to  & \TT{\{| a b c |\}} \\
		    & \multicolumn{2}{l}{which is NOT a special case}
\end{tabular}
\end{center}

In the unusual case where the {\em element-list} ends in a
paragraph with the same paragraph initiator as an
{\em attribute-paragraph}, and there is no {\em attribute-paragraph},
an empty {\em attribute-paragraph} must be added to make
the {\em element-list} end as intended.
Also, the parse of the logical lines in the paragraph
at the end of the {\em element-list} will only recognize brackets,
and never operators.

\end{indpar}

\ttmkey{sentence}{reformatter} ~ {\em terminator-list}
	\label{SENTENCE-REFORMATTER}

\begin{indpar}[0.5em]
where 

\begin{indpar}
\emkey{terminator-list} ::=
    \TT{()}
    $|$ \TT{(} {\em quoted-terminator}
     \{ \TT{,} {\em quoted-terminator} \}\STAR{} \TT{)}
\\[0.5ex]
\emkey{quoted-terminator} :::= \TT{"}{\em terminator}\TT{"}
\\[0.5ex]
\emkey{terminator} :::= {\em mark} $|$ {\em separator}
\end{indpar}


The {\em prefix-n-list} must have the form:
\begin{center}
\TT{\{}{\em prefix} {\em prefix-attributes}\QMARK{}\TT{\}}
            {\em element-list}
\end{center}
where
\begin{indpar}
\emkey{prefix} ::= the prefix, e.g., `\TT{s}'
\\[0.5ex]
\emkey{prefix-attributes} ::= {\em attribute-type-begin} ~ {\em attribute-list}
			      ~~~ (see \pagref{OPENING-TYPE-AND-ATTRIBUTES})
\\[0.5ex]
\emkey{element-list} ::= see \pagref{ELEMENT-LIST}
\end{indpar}

The {\em element-list} is parsed according to the rules:
\begin{indpar}
\emkey{element-list} ::= {\em sentence}\STAR{} {\em phrase}\QMARK{}
\\[0.5ex]
\emkey{sentence} ::= {\em phrase}\QMARK{} {\em terminator}
\\[0.5ex]
\emkey{phrase} ::= {\em phrase-element}\PLUS{}
\\[0.5ex]
\emkey{phrase-element} ::= {\em element} other than {\em terminator}
\end{indpar}

The \TT{sentence} reformatter converts the subexpression to a sequence
of subexpressions, one for each {\em sentence} and one for any
non-empty final {\em phrase}.  Each of these subexpressions has
as elements the {\em phrase-elements}
of the corresponding {\em sentence} or {\em phrase},
and has as attributes copies of the attributes
of the original subexpression.
In addition, each subexpression corresponding to a {\em sentence}
has a \TT{.terminator} attribute equal to the {\em terminator}
of the {\em sentence}.



\end{indpar}

\end{indpar}

\begin{center}
\begin{tabular}{l}
\multicolumn{1}{c}
{\bf Initial Bracket Type Parser Commands}
\\[1ex]
\multicolumn{1}{c}
{(none)}
\\[2ex]
\multicolumn{1}{c}
{\bf Standard `\ttkey{bracket types}'\label{STANDARD-BRACKET-TYPES} Component
     Bracket Type Parser Commands} \\
\multicolumn{1}{c}
{\bf That Do NOT Require Any Standard Qualifier}
\\[1ex]
\multicolumn{1}{c}
{Selectors with Missing Standard Qualifiers are Deleted
                   from the Commands}
\\[1ex]
\tt define bracket type "***" [TOP LEVEL, code, text] \\
\tt ~~~~~~~with group reset \\
\tt define bracket type "data" \\
\tt ~~~~~~~~~~~~~~~[TOP LEVEL, data, code, math, text] \\
\tt ~~~~~~~with group line \\
\tt ~~~~~~~with parsing selectors [+ data paragraph] \\
\tt ~~~~~~~with data reformatter ( "=", "no", "[", "\{*" ) \\
\tt define bracket type "raw data" \\
\tt ~~~~~~~~~~~~~~~[TOP LEVEL, data, code, math, text] \\
\tt ~~~~~~~with group line \\
\tt ~~~~~~~with parsing selectors [data, data paragraph] \\
\tt ~~~~~~~with data reformatter ( "=", "no", "[", "\{*" ) \\
\end{tabular}
\\[2ex]
\begin{tabular}{l}
\multicolumn{1}{c}
{\bf Standard `\ttkey{bracket types}' Component
     Bracket Type Parser Commands} \\
\multicolumn{1}{c}
{\bf That REQUIRE the {\tt + text} Standard Qualifier}
\\[1ex]
\multicolumn{1}{c}
{Selectors with Missing Standard Qualifiers are Deleted
                   from the Commands}
\\[1ex]
\tt define bracket type "table" [code, text] \\
\tt ~~~~~~~with parsing selectors [text] \\
\tt ~~~~~~~with group paragraph \\
\tt ~~~~~~~with line lexical master ROW-CHECK \\
\tt define bracket type "row" [text] \\
\tt ~~~~~~~with group line \\
\end{tabular}
\\[2ex]
\begin{tabular}{l}
\multicolumn{1}{c}
{\bf Standard `\ttkey{bracket types}' Component
     Bracket Type Parser Commands} \\
\multicolumn{1}{c}
{\bf That REQUIRE the {\tt + text} Standard Qualifier}
\\[1ex]
\multicolumn{1}{c}
{Selectors with Missing Standard Qualifiers are Deleted
                   from the Commands}
\\[1ex]
\tt define bracket type "section" [code, text] \\
\tt ~~~~~~~with group paragraph \\
\tt ~~~~~~~with parsing selectors [+ text, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- code, - math, - data] \\
\tt ~~~~~~~with parsing options [+ end at lt indent, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ end at paragraph break, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at indent, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at le indent, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at line separator, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at outer closing] \\
\tt ~~~~~~~with implied subprefix {s} \\
\tt define bracket type "p" [code, text] \\
\tt ~~~~~~~with group paragraph \\
\tt ~~~~~~~with parsing selectors [+ text, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- code, - math, - data] \\
\tt ~~~~~~~with parsing options [+ sticky, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ end at lt indent, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ end at paragraph break, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at indent, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at le indent, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at line separator, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at outer closing] \\
\tt ~~~~~~~with implied subprefix {s} \\
\tt define bracket type "s" [text] \\
\tt ~~~~~~~with sentence reformatter \\
\tt ~~~~~~~~~~~~( ".", "?", "!", ":", ";" ) \\
\tt define bracket type "quote" [code, text] \\
\tt ~~~~~~~with group paragraph \\
\tt ~~~~~~~with parsing selectors [+ text, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- code, - math, - data] \\
\tt ~~~~~~~with parsing options [+ sticky, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ end at lt indent, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ end at paragraph break, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at indent, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at le indent, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at line separator, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- end at outer closing] \\
\tt ~~~~~~~with implied subprefix {s} \\
\end{tabular}

\end{center}


\subsubsection{Headed Lines}
\label{HEADED-LINES}

A `\key{line header}' is a typed prefix separator that has
the `\TT{line}' group.  Line headers may only
appear at the beginning of a logical line, or immediately
after a paragraph header, which itself must begin a logical
line: see \itemref{HEADED-PARAGRAPHS}.

Line headers may be implied by the \TT{implied subprefix}
of a paragraph header (see \pagref{IMPLIED-SUBPREFIX}
and \itemref{HEADED-PARAGRAPHS})
or by the \TT{implied header} line variable (see \pagref{IMPLIED-HEADER}).

Line headers, including implied line headers,
are only recognized if the \TT{enable header}
option is on at the beginning of the logical line.

A `\key{headed line}' is a logical line beginning with a line header.
The parser's output
for a headed line is a MIN object whose \TT{.type} and attributes
are taken from the line header and whose elements are
taken from the rest of the headed line, except that if the
logical line is ended by a {\em line-separator} this becomes he
\TT{.terminator} attribute of the MIN object.  The MIN object has a \TT{.type}
but \underline{no}
\TT{.initiator}, unlike the parser's output
for a logical line that has no line header, which has \underline{no}
\TT{.type} but has an \TT{.initiator}
equal to the special value \TT{min::\EOL LOGICAL\_\EOL LINE()}.

\subsubsection{Headed Paragraphs}
\label{HEADED-PARAGRAPHS}

A `\key{paragraph header}' is a typed prefix separator that has
the `\TT{paragraph}' group.  Paragraph headers may only
appear at the beginning of a logical line in paragraph beginning position,
that is, following a blank
line or the beginning of an indented paragraph or file (where
intervening comment lines are ignored).

Paragraph headers may be implied 
by the \TT{implied header} line variable (see \pagref{IMPLIED-HEADER}).

Paragraph headers, including implied paragraph headers,
are only recognized if the \TT{enable header}
option is on at the beginning the paragraph header's logical line.

A `\key{headed paragraph}' is a logical line that begins with paragraph header,
plus all the following logical or headed
lines up until the headed paragraph end.
A headed paragraph may be ended by a blank line (unless the paragraph
is `continuing'), or by the end
of its containing indented paragraph, or by the end of the input file.

The parser's output for a headed paragraph is a MIN object 
whose \TT{.type} and attributes are taken from the paragraph header
and whose elements are the logical or headed lines in the headed paragraph.
If the first logical line of the headed paragraph contains only
the paragraph header, that logical line is omitted from the list of elements
(so there are no blank logical lines).

As an example, suppose the parser is given the definitions.
\begin{indpar}\begin{verbatim}
*PARSER*:
    define bracket type "itemize" [code, text]
        with group paragraph
    define bracket type "item" [code, text]
        with group line
\end{verbatim}\end{indpar}
Then when given the input (with `\TT{code}' or `\TT{text}'
a top level parsing selector):
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"}
{item}1 chicken
{item}1 tablespoon olive oil
{item}1 tablespoon paprika
\end{verbatim}\end{indpar}
the parser produces the MIN object:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"|
    {item| 1 chicken |item}
    {item| 1 tablespoon olive oil |item}
    {item| 1 tablespoon paprika |item}
    |itemize}
\end{verbatim}\end{indpar}

Now suppose the parser is given the definitions:
\begin{indpar}\begin{verbatim}
*PARSER*:
    define bracket type "itemize" [code, text]
        with group paragraph
        with implied subprefix {item}
    define bracket type "item" [code, text]
        with group line
\end{verbatim}\end{indpar}
with a `\TT{implied subprefix}'.  Then when given given the input:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"}
1 chicken
1 tablespoon olive oil
1 tablespoon paprika
\end{verbatim}\end{indpar}
the parser will produce the same MIN object.

Next suppose the parser is given the definitions:
\begin{indpar}\begin{verbatim}
*PARSER*:
    define bracket type "itemize" [code, text]
        with group paragraph
        with implied subprefix {item}
        with parsing options [+ sticky]
    define bracket type "item" [code, text]
        with group line
\end{verbatim}\end{indpar}
with a `\TT{sticky}' option.  Then when given given the input:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"}
1 chicken
1 tablespoon olive oil
1 tablespoon paprika

a potato
1 tablespoon butter
\end{verbatim}\end{indpar}
the parser will produce two MIN objects, the first being as
above and the second being:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"|
    {item| a potato |item}
    {item| 1 tablespoon butter |item}
    |itemize}
\end{verbatim}\end{indpar}

If instead the parser is given the definitions:
\begin{indpar}\begin{verbatim}
*PARSER*:
    define bracket type "itemize" [code, text]
        with group paragraph
        with implied subprefix {item}
        with parsing options [+ continuing]
    define bracket type "item" [code, text]
        with group line
\end{verbatim}\end{indpar}
with a `\TT{continuing}' option, then when given the above input
the parser would produce the single MIN object:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"|
    {item: 1 chicken}
    {item: 1 tablespoon olive oil}
    {item: 1 tablespoon paprika}
    {item: a potato}
    {item: 1 tablespoon butter}}
\end{verbatim}\end{indpar}

Note that the `\TT{sticky}' and `\TT{continuing}' options
remain in effect until the next explicit (non-implied)
paragraph header, or until the end of a containing
indented paragraph.

The `\TT{standard}' parser block contains the definitions:
\begin{indpar}\begin{verbatim}
*PARSER*:
    define parsing selectors [+ code]
    define top level paragraph lexical master PARAGRAPH-CHECK
    define mapped lexeme "TABLE" [TOP LEVEL]
           with token value {table}
    define mapped lexeme "ROW" [TOP LEVEL]
           with token value {row}
    define bracket type "table" [code, text]
        with parsing selectors [text]
        with group paragraph
        with line lexical master ROW-CHECK
    define bracket type "row" [text]
        with group line
\end{verbatim}\end{indpar}

To see how these definitions work, consider the example:
\begin{indpar}\begin{verbatim}
=============
| 1 chicken |
-------------
| 1 tablespoon olive oil |
-
| 1 tablespoon paprika
=
\end{verbatim}\end{indpar}
where the first line appears in paragraph beginning position
(\pagref{PARAGRAPH-BEGINNING-POSITION}).
Therefore at the beginning of the first line the top level
paragraph lexical master, which is \TT{PARAGAPH-CHECK}, is used.
As this
sees a string of 5 or more \TT{=}'s, it outputs a \TT{TABLE}
special lexeme which is mapped to the \TT{\{table\}} prefix.
The `\TT{table}' prefix in turn has a definition which
changes the line lexical master to \TT{ROW-CHECK}, and this
is also used for the rest of the first line.  As none
of the \TT{=}'s have been consumed by the \TT{TABLE} special
lexeme, this \TT{ROW-CHECK} lexical master sees the first \TT{=} and
outputs a \TT{ROW} special lexeme, which is mapped to a
\TT{\{row\}} prefix.  After outputting the \TT{ROW} special
lexeme, the \TT{ROW-CHECK} lexical master transfers to the
\TT{DEFAULT} lexical master which scans the normal lexemes
in the line.  Since neither special lexeme consumed any \TT{=}'s,
the one normal lexeme in the line contains all the
\TT{=}'s.  At the beginning of the next logical line, the
top level line lexical master defined by the paragraph header
\TT{\{table\}} is installed, which is
\TT{ROW-CHECK}.  The final result is the same as if
\begin{indpar}\begin{verbatim}
{table}{row}=============
{row}| 1 chicken |
{row}-------------
{row}| 1 tablespoon olive oil |
{row}-
{row}| 1 tablespoon paprika
{row}=
\end{verbatim}\end{indpar}
had been input and is
\begin{indpar}\begin{verbatim}
{table| {row| ============= |row}
        {row| "|" 1 chicken "|" |row}
        {row| ------------- |row}
        {row| "|" 1 tablespoon olive oil "|" |row}
        {row| - |row}
        {row| "|" 1 tablespoon paprika |row}
        {row| = |row}
        |table}
\end{verbatim}\end{indpar}


At top level the paragraph and line lexical masters are
set by the `\TT{define top level}' commands, and the
only way to get an implied header is to input a paragraph
header with the `\TT{sticky}' option.  In contrast,
an indented paragraph can begin with a paragraph and
line lexical masters that are either set by the its
`\TT{define indentation mark}' command or are inherited
from the surrounding context, and the
`\TT{define indentation mark}' can optionally set an implied
paragraph or line header.
See \itemref{LINE-VARIABLES} for details.

\subsubsection{Isolated Headers}
\label{ISOLATED-HEADERS}

An \key{isolated header} is a reset header, or
is a paragraph header that resets the
\TT{line lexical master} and is not an implied prefix or mapped prefix.
A \key{mapped prefix} is an explicit prefix that was created 
when a mapped lexeme was mapped to a prefix.
A \key{mapped header} is a mapped prefix that is a paragraph header.
Isolated headers and mapped headers
are the only headers that can reset the line lexical
master to the value in the header's bracket type definition.
A \key{reset header} is a prefix with the
`\TT{reset}' group.

An isolated header must appear at the
beginning of a logical line and must be the only thing in its
logical line (in particular, the logical line cannot end with
a line separator).  In determining the extent of the logical
line containing the header,
the \TT{options} current line variable value modified
by parameters from the header's bracket type definition
is used.

An isolated paragraph header sets the current line variables
to those of the containing indented paragraph or the top level
if there is no containing indented paragraph, as modified by
the parameters in the header's bracket type definition (one of
which is the non-missing line lexical master).

A reset header sets the paragraph line variables
to those of the containing indented paragraph or the top level
if there is no containing indented paragraph.

An isolated paragraph header may \underline{not} be implied or
sticky.

A reset header's bracket type definition cannot have any parameters
other than `\TT{group}'.

A mapped paragraph header may set the line lexical master
current line variable without the requirement that the mapped
paragraph header be in a logical line by itself.  The reason
is that the special lexical master that produced the mapped
paragraph header is assumed to jump to the line lexical master
after producing the paragraph header, so the line lexical master
takes effect immediately after the mapped paragraph header in
its logical line.  However this assumption is not verified by
code.

\subsubsection{Line Variables}
\label{LINE-VARIABLES}

In order to parse logical lines, the parser maintains sets of
`\skey{line variable}s'.  There is a separate set of line
variables for each indented paragraph, and one additional set
for the top level.

The line variables are described below.  These descriptions make
use of the notion that a logical line may be in
`\key{paragraph beginning position}'\label{PARAGRAPH-BEGINNING-POSITION}.
This means that the logical line follows a blank line,
or is at the the beginning of its containing
indented paragraph, or is at the beginning of the input file,
with comment lines possibly intervening.

While parsing a logical line the parser uses the line variables:

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttmkey{selectors}{line variable}\\
    The parsing selectors are reset to this value just after the
    indent token that begins a logical line.
\\[1ex]
\hspace*{-0.2in}\ttmkey{options}{line variable}\\
    The parsing options are reset to this value just after the
    indent token that begins a logical line.
\\[1ex]
\hspace*{-0.2in}\ttmkey{implied header}{line variable}\label{IMPLIED-HEADER}\\
    May be missing or set equal to a paragraph or line header.

    If this value is not missing a copy of the value is inserted
    as an implied header just after the indent token that begins
    a logical line.  An implied header is an implied subprefix
    (\pagref{IMPLIED-SUBPREFIX})
    and is almost like an explicit prefix separator except that
    if it has no following {\em prefix-n-list} elements
    it is removed.  In particular, if an implied header is immediately
    followed by an explicit (i.e., not implied) header with the same
    group, the implied header is removed.

    A non-missing implied header must have a bracket type
    definition selected by the \TT{selec\-tors} line variable that
    has either the `\TT{paragraph}' or `\TT{line}' group.

    Modifications to selectors and options made by an implied
    header should be chosen so that they do not affect the parsing
    of any explicit header that occurs immediately after the
    implied header, and do not affect the lookup of the bracket type of that
    explicit header.  This is because if the
    logical line begins with an explicit header, that will be
    parsed and its bracket type table definition will be looked up
    using the selectors and options set by the implied
    header, and then the implied header will then be deleted (as there
    are no elements between it and the explicit header).  But
    after the implied header is deleted, the explicit header
    is \underline{not} re-parsed and its bracket type table definition
    is \underline{not} re-looked-up.
\\[1ex]
\hspace*{-0.2in}\ttmkey{paragraph lexical master}{line variable}\\
\hspace*{-0.2in}\ttmkey{line lexical master}{line variable}\\
    The lexical master is reset to one of these values
    just after the indent token that begins a logical line, unless
    the value is missing.  The paragraph lexical master is used
    for logical lines in paragraph beginning position
    (\pagref{PARAGRAPH-BEGINNING-POSITION})
    and the line lexical master is used for other logical lines.

    By convention, non-default lexical masters revert to the default master
    after identifying any special lexemes at the location where the
    non-default lexical master is installed.  If the lexical master
    is \underline{not} set at the beginning of a logical line,
    by this convention the default lexical master will be in effect.
\\[1ex]
\hspace*{-0.2in}Note: The above line variables are called
the `\ikey{\underline{current} line variables}{current line variable}'.
\\[1ex]
\hspace*{-0.2in}Note: Explicit paragraph headers and reset headers
change the line variables, except for the paragraph lexical header.
A change to the line lexical header does not take effect until
the beginning of the logical line immediately after the logical line
containing the explicit paragraph or reset header, so use of these
headers is restricted: see \itemref{ISOLATED-HEADERS}.
\\[2ex]
\hspace*{-0.2in}\ttmkey{paragraph selectors}{line variable}\\
\hspace*{-0.2in}\ttmkey{paragraph options}{line variable}\\
\hspace*{-0.2in}\ttmkey{paragraph implied header}{line variable}\\
\hspace*{-0.2in}\TT{paragraph paragraph lexical master}
                \index{paragraph paragraph@\TT{paragraph paragraph}!
		      lexical master@\TT{lexical master}!
		      line variable}\\
\hspace*{-0.2in}\TT{paragraph line lexical master}
                \index{paragraph line@\TT{paragraph line}!
		      lexical master@\TT{lexical master}!
		      line variable}\\
    These variables are called the `\key{paragraph line variables}'.

    The paragraph line variables
    are copied to corresponding current line variables
    just before the current line variables are used for a line
    in paragraph beginning position, \underline{unless} the
    \TT{options} current line variable
    contains the `\TT{continuing}' option.

    The \underline{top level} paragraph line variables, with the exception of
    the paragraph implied header, are the same as the
    parser selectors, options, and lexical masters, and can be changed
    by the \TT{define top level} parser commands
    (\pagref{DEFINE-TOP-LEVEL}).
    The \underline{top level} paragraph implied header is normally missing, but
    may be changed by a `\TT{sticky}' paragraph header as indicated below.

    For indented paragraphs, paragraph selectors and options line variables
    are computed from the context of the indented paragraph modified according
    to parameters given in the the \TT{define inden\-ta\-tion mark}
    parser command (\pagref{PARSER-INDENTATION-MARK-COMMAND}) for the mark
    that introduces the paragraph.  The paragraph lexical masters and
    implied header line variables are set from the values provided in the
    \TT{define inden\-ta\-tion mark} command.  The paragraph implied header
    may be changed while parsing the indented paragraph if a `\TT{sticky}'
    explicit paragraph header is encountered.

    An explicit paragraph header that sets the `\TT{sticky}' option
    replaces the paragraph implied header with a copy of itself.
    An explicit paragraph header that clears the `\TT{sticky}' option
    replaces the paragraph implied header with the missing value at
    top level, or with the value from the \TT{define indentation mark}
    command within an indented paragraph.

\end{indpar}

Logical line processing is as follows:

\begin{enumerate}

\item
A sequence of logical lines whose first line (and only the first line)
is a logical line prefixed by a paragraph header is collected into a
headed paragraph.  Such a sequence ends (1) just before a logical
line in paragraph beginning position if the \TT{options} current line
variable does \underline{not} have the `\TT{continuing}' option, or
(2) just before a logical line that begins with an explicit paragraph
header (such a line must be in paragraph beginning position),
or (3) just before the end of the current indented paragraph
or, at top level, the end of file.

\item\label{CONTINUING-RULE}
If a logical line is in paragraph beginning position and the
\TT{options} current line variable does not have the `\TT{continuing}'
option, then the paragraph line variables are copied
to the corresponding current line variables.

\item The parsing selectors, options, and lexical master used at the
beginning of the logical line are set from the current line variables,
specifically, the
\TT{selectors},
\TT{options}, and \TT{para\-graph/\EOL line lexical master}
current line variables.

\item\label{IMPLIED-HEADER-PARSING}
If the \TT{implied\_header} current line variable value is not missing,
the bracket type definition for this is looked up (using selectors now
equal to the \TT{selectors} current line variable).
The bracket type definition must exist and have either the `\TT{paragraph}' or
`\TT{line}' group.  Note that an isolated header cannot be implied.

The \TT{implied\_header} is treated as missing unless one of the
following options is present in the \TT{options} current line variable:
\begin{center}
\TT{enable prefix} \\
\TT{enable table prefix} \\
\TT{enable header} \\
\end{center}

If the bracket type definition has the `\TT{paragraph}' group, the
implied prefix is an implied paragraph header.  If it has the `\TT{line}' group,
the implied prefix is an implied line header.

If the \TT{implied\_header} has the `\TT{paragraph}' group and the
logical line is \underline{not} in paragraph beginning position,
an error is announced and the \TT{implied\_\EOL header} is treated as missing.

A non-missing implied header is inserted at the beginning of the logical line.
Then the parsing selectors and parsing options
in its bracket type definition are used to
modify the current selectors and options.
In addition, if the implied header has `\TT{paragraph}' group,
the new selectors and options are stored in the current line
variable selectors and options, and
the implied subprefix of the bracket type definition is stored in
the current line variable implied header variable if it has the
`\TT{line}' group when its bracket type is looked up with the
new selectors current line variable value (this implied subprefix
will also be inserted after the implied paragraph header in its
logical line).
These new current line variable values are used for subsequent lines
until the current line variables are reset from the paragraph line
variables (e.g., at beginning of the next logical line that is
in paragraph beginning position).

\item\label{EXPLICIT-HEADER-PARSING}

The first part of the rest of the logical line is then parsed.
If it begins with a prefix that has a bracket type definition with either
the `\TT{paragraph}', `\TT{line}', or `\TT{reset}' group,
then that is an explicit paragraph, line, or reset header.

If an explicit paragraph or reset
header is found immediately after implied headers,
the implied headers are deleted.
If an explicit line header is found immediately after implied headers,
an implied line header is deleted, but an implied paragraph header is not
deleted.

When implied headers are deleted, the parsing selectors, options,
and current line variables are restored to their state before the deleted
implied headers were inserted.
However the selectors and options used to parse the
explicit header and look up its
bracket type definition are \underline{not} the restored parsers and options,
but rather the selectors and options established by the implied headers.
Therefore implied headers should not change selectors and options
sufficiently to affect parsing explicit headers or looking up their
bracket type definitions.

If a line or non-isolated paragraph
explicit header is found, then after any implied headers are deleted
and the state set by the current indentation mark or top level definition
has been restored, the explicit header's bracket type definition
is used to modify the parsing selectors and options, and if the header is
a paragraph header, the current line variable selectors, options,
and implied header, and if in addition the header is a mapped paragraph
header with a non-missing line lexical master, the current line variable
line lexical master.
Here the implied header is copied from the explicit header's bracket type
definition only if the explicit header is a paragraph header and the
implied header has the `\TT{line}' group when its bracket type
definition is looked up with the new selectors current line variable.

If an isolated paragraph header is found, the header's bracket type
definition modifies the current line variables selectors, options,
line lexical master, and implied header.  Since an isolated header
must be on a logical line by itself, processing proceeds to the next
logical line.

If a reset header is found,\label{RESET-RULE}
the selectors, options, and line variables are just restored
to the values they were set to by the current indentation mark
definition or top level definition.
Then the reset header is
deleted, and its line is treated as a blank line, so the following
logical line is in paragraph beginning position.

\item
If an explicit paragraph header sets
the `\ttkey{sticky}' option flag,\label{STICKY-RULE}
then the \TT{paragraph im\-pli\-ed header} is set to
a copy of the explicit paragraph header.
Note that an isolated header cannot be implied and therefore
cannot be sticky.

If the explicit paragraph header does \underline{not}
set the `\TT{sticky}' option flag, then
the \TT{para\-graph implied header}
is reset to the value it had at the beginning of the current
indented paragraph,
or to missing if the logical line is top level.

\item

The remainder of the logical line is then parsed.
If the logical line is empty except for implied headers, any
implied headers are deleted and the logical line is deleted.

\end{enumerate}

Note that parsing definitions cannot change during the parsing of
a logical line, an indented paragraph inside a logical line,
or any headed paragraph.  Line variables, however, may change,
and new sets of line variables are created by indented paragraphs.


\subsection{Parser Passes}

After a subexpression has been identified by the top level bracketed
subexpression recognition pass, a sequence of passes is run on the
subexpression.  Which passes are in the sequence is determined by the
parser pass stack and parser selectors.

The \key{parser pass stack} is a list of parser passes with a set of
selectors associated with each pass.  A pass in this list is active
if it has a selector in common with the parsing selectors computed
by the top level bracketed subexpression recognition pass.  Each pass
calls the next active pass in the parser pass stack on subexpressions
recognized by the calling pass.  For passes like the operator pass,
this is done on subexpressions recognized by the pass which contain
no operators, and after the called pass returns, the operator pass
compacts any subexpression with zero or more than one token into
a single \TT{PURELIST} token.

The parsing selectors
computed by the opening bracket of the bracketed subexpression
become the parsing selectors while the subexpression is being parsed.
These are used to determine activity of the parser passes run on the bracketed
subexpression and also the activity
of the parser definitions (i.e., parser symbol table entries)
used by these parser passes.
Note that only the brackets surrounding a bracketed subexpression
can change parsing selectors, and then can only change them within
the bracketed subexpression.  Operators
that bound implicit subexpressions cannot change these parsing selectors.

The parser pass stack can be altered and inspected
by the following parser definitions:

\begin{indpar}
\emkey{parser-pass-command} \\
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{define pass}{parser command}
	  \begin{tabular}[t]{@{}l@{}}
	  {\em parser-pass-name} {\em parsing-selectors} \\
	  {\em parser-pass-stack-location} \\
	  \end{tabular} \\
    $|$ & \ttmkey{undefine pass}{parser command}
	  {\em parser-pass-name} \\
    $|$ & \ttmkey{print pass}{parser command}
    \end{tabular}
\\[0.5ex]
\emkey{parser-pass-stack-location}
    \begin{tabular}[t]{rl}
    ::= & \TT{after} {\em previous-parser-pass-name} \\
    $|$ & \TT{before} {\em next-parser-pass-name} \\
    $|$ & \TT{at end} \\
    \end{tabular}
\\[0.5ex]
\emkey{parser-pass-name} ::= {\em simple-name}
\\[0.5ex]
\emkey{previous-parser-pass-name} ::= {\em parser-pass-name}
\\[0.5ex]
\emkey{next-parser-pass-name} ::= {\em parser-pass-name}
\end{indpar}

The set of passes that may be run is builtin, and
cannot be changed.  The following are permitted {\em parser-pass-names}:

\begin{indpar}
\hspace*{-0.2in}\ttmkey{top}{parser pass name}\\
    This refers to the bracketed subexpression recognition pass which is
    always at the top of the parser pass stack,
    and can only be used as a {\em previous-parser-pass-name} to place
    a pass just below it on the stack.
\\[2ex]
\hspace*{-0.2in}\ttmkey{operator}{parser pass name}\\
    Parses expressions with computational operators (e.g.~\TT{+} and
    \TT{*}).
\\[2ex]
\hspace*{-0.2in}\ttmkey{lexeme replacement}{parser pass name}\\
    Replaces sequences of lexemes with other
    sequences of lexemes (e.g., replaces plurals by singulars).
\\[2ex]
\hspace*{-0.2in}\ttmkey{radix number recognition}{parser pass name}\\
    Recognizes numbers with non-decimal radixes.
\\[2ex]
\hspace*{-0.2in}\ttmkey{scientific number recognition}{parser pass name}\\
    Recognizes numbers with exponents.
\\[2ex]
\hspace*{-0.2in}\ttmkey{number pair recognition}{parser pass name}\\
    Recognizes pairs of numbers (e.g.~\TT{4 1/2}).
\\[2ex]
\hspace*{-0.2in}\ttmkey{number unit grouping}{parser pass name}\\
    Groups numbers and numeric units (e.g.~\TT{4ft 5in}).
\\[2ex]
\hspace*{-0.2in}\ttmkey{unit multiplication insertion}{parser pass name}\\
    Inserts multipliers between numbers and
    numeric units (e.g.~\TT{4*ft} and \TT{\$*4.99}).
\end{indpar}

The \TT{parser define pass} statement sets the
{\em parsing-selectors} of the named parser pass
and installs that pass in the parser pass stack at the
location specified.
If the pass was previously on the stack, it is removed from the stack
and then reinserted into the stack without altering any pass-specific
symbol tables.  The {\em parser-pass-name} and
{\em next-parser-pass-name} cannot be `\TT{top}'.
Any {\em previous-parser-pass-name} or {\em next-parser-pass-name}
given must name a pass already in the stack that is different from
the pass being installed.

The \TT{parser undefine pass} statement removes the named
parser pass from the stack, if it is in the stack, and does
nothing otherwise.  The `\TT{top}' pass cannot be undefined.

The \TT{parser undefine pass} statement destroys any symbol
tables associated with the pass being undefined.  First undefining and then
redefining a pass effectively clears this symbol table.  Thus
first undefining and then redefining the `\TT{operator}' pass
clears the symbol table set by `\TT{parser define operator \ldots}'
commands.  On the other hand,
a `\TT{parser define pass operator \ldots}' statement 
may be used to change the `\TT{operator}' pass selectors or
position in the pass stack without clearing the operator symbol
table.

The \TT{parser print pass} statement prints the parser pass stack passes
with their associated selectors.

The input and output of a parser pass is a sublist of the list
of all tokens.  When a parser pass is called, it is provided with
a pointer to the first token of this sublist, and a pointer to the
first token after the sublist.  The pass may edit the sublist.
The pass is responsible for calling the next pass down in the parser
pass stack, and may edit the sublist before and/or after calling
this next pass.

The bracketed subexpression recognition pass, also known as the `\TT{top}' pass,
which is the first pass called for each
top level input line, recognizes bracketed subexpressions,
and for each recognized bracketed subexpression
calls the next active lower pass for the token list of the subexpression
and then replaces this token list, which may have been edited by
the called lower pass, by a single MIN object.

\subsection{The Operator Parsing Pass}
\label{OPERATOR-PARSING-PASS}

The \key{operator parsing pass} is an expression parser pass that uses
operators to restructure expressions.  Operators
are defined by operator definitions that can be added to the operator
parsing definition stack.  List separators, such as `\TT{,}', are treated
as operators, and have operator definitions.

\subsubsection{Operator Expression Syntax}
\label{OPERATOR-EXPRESSION-SYNTAX}

The operator parsing pass identifies operators
and parses expressions using operator flags 
and operator precedence.
Operator definitions assign flags (prefix, infix, postfix, etc.)
and integer precedences to operators.

The operator flags \TT{initial}, \TT{left}, \TT{right}, \TT{final},
\TT{afix}, and \TT{line} are described in Figure~\ref{OPERATOR-FLAGS}.
Flag groups are names used in operator definitions for sets of flags.
For example, a \TT{prefix} operator is an operator with the
\TT{initial} and \TT{right} flags, a \TT{postfix} operator
is an operator with the \TT{left} and \TT{final} flags, and an
\TT{infix} operator is an operator with the \TT{left} and \TT{right}
flags.

Operators have precedences in the range [L,H],
where L = -1,000,000 and H = +1,000,000.  By convention,
precedence H is reserved for postfix operators and precedence H-1 is
reserved for prefix operators, but this is just convention and
some prefix or postfix operators may have other precedences.
The precedence L-1 is reserved for the `error operator' which is
inserted during parsing to `fix up' errors found during parsing.

Given this, expressions have the following syntax,
where an {\em P-expression}
is an expression all of whose operators that are outside brackets
have precedence equal to or greater than P:

\begin{indpar}
\emkey{expression}\label{EXPRESSION} ::= {\em (L-1)-expression}
\\[0.5ex]
\emkey{P-expression}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em P-final-expression} \\
    $|$ & {\em P-initial-operator} {\em P-expression}\QMARK{}
    \end{tabular}
\\[0.5ex]
\emkey{P-final-expression}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em P-middle-expression} \\
    $|$ & {\em P-final-expression}\QMARK{} {\em P-final-operator}
    \end{tabular}
\\[0.5ex]
\emkey{P-middle-expression}
    ::= \{ {\em (P+1)-expression} $|$ {\em P-middle-operator)} \}\PLUS{}
\\[0.5ex]
\emkey{(H+1)-expression} ::= {\em non-operator}\PLUS{}
\\[0.5ex]
\emkey{P-operator} ::= operator of precedence P
\\[0.5ex]
\emkey{P-initial-operator} ::= {\em P-operator} with \TT{initial} flag
\\[0.5ex]
\emkey{P-final-operator} ::= {\em P-operator} with \TT{final} flag
\\[0.5ex]
\emkey{P-middle-operator} ::= {\em P-operator} with \underline{neither}
                              \TT{initial} nor \TT{final} flag
\\[2.0ex]
where in an {\em P-expression}: \\
\hspace*{1em}\begin{tabular}[t]{l}
       P is any precedence in the range [L-1,H]; \\
       no two {\em (P+1)-expressions} may be adjacent; \\ 
       each {\em P-operator} with a \TT{left} flag must be
              preceded by an {\em (P+1)-expression}; \\
       each {\em P-operator} with a \TT{right} flag must be
	  followed by an {\em (P+1)-expression}; \\
       any operator with an \TT{afix} flag must not be the first
           {\em P-operator} in an {\em P-expression}; \\
       no operator may have both a \TT{initial} and a \TT{left} flag; \\
       no operator may have both a \TT{right} and a \TT{final} flag; \\
       no operator may have both a \TT{initial} and an \TT{afix} flag; \\
       \end{tabular}
\end{indpar}

Essentially the expression being parsed is organized into {\em P-expressions}
where $P$ is the precedence of the {\em P-expression}.  Generally
a {\em P-expression} consists of a sequence of {\em (P+1)-expressions}
and operators of precedence $P$.
If a {\em P-expression} begins with a {\em P-initial-operator},
the entire {\em P-expression} after its initial operator is an operand
of the initial operator.
If a {\em P-expression} does \underline{not} beginning
with a {\em P-initial-operator} ends with a {\em P-final-operator},
the entire {\em P-expression} before its final operator is an operand
of the final operator.

Whether or not an operator is recognized is determined by the left
context of the operator.  Thus in `{\tt x + + y}' the first {\tt +}
is recognized as an infix operator because it is preceded by an operand,
and the second {\tt +} is recognized as a prefix operator because it
is preceded by another operator (the first {\tt +}) of lower precedence.
However, in `{\tt x * * y}' the second {\tt *} is not recognized as
an operator, because only infix {\tt *} is defined, and what is immediately
to the left of the second {\tt *} is another operator (the first {\tt *})
of equal precedence.  Thus the second {\tt *} is treated as a non-operator,
(e.g., as if there were a variable named `{\tt * y}').

A consequence of this is that while an operator may have both an
infix and a prefix definition, it should not have both an infix and
a postfix definition, as both infix and postfix operators both have the
same left context (and in that context whichever was defined later will
be selected).

There can be multiple operator definitions with the afix flag
and the same {\em operator-name} but with different precedences
that are all selected by the current parsing selectors.  The most
recent definition will be used that has the same precedence
as a previous operator in the expression with no intervening
operator of lower precedence.


\begin{boxedfigure}[!t]

Operator Flags:

\begin{indpar}[0.4in]

\hspace*{-0.2in}\ttmkey{initial}{operator flag} ~
    Operator must be the first thing in any subexpression containing it.

\hspace*{-0.2in}\ttmkey{left}{operator flag} ~
    Operator must follow an operand (e.g., a non-operator or a
    subexpression formed with operators of higher precedence).
    That is, operator must have a left operand.

\hspace*{-0.2in}\ttmkey{right}{operator flag} ~
    Operator must precede an operand (e.g., a non-operator or a
    subexpression formed with operators of higher precedence).
    That is, operator must have a right operand.

\hspace*{-0.2in}\ttmkey{final}{operator flag} ~
    Operator must be the last thing in any subexpression containing it.

\hspace*{-0.2in}\ttmkey{afix}{operator flag}\label{AFIX-FLAG} ~
    Operator must be preceded in any subexpression containing it
    by another operator of the same precedence.

\hspace*{-0.2in}\ttmkey{line}{operator flag}\label{LINE-FLAG} ~
    Current parsing selectors must contain \TT{LINE LEVEL} in order
    for the operator to be recognized.

\end{indpar}

Operator Flag Groups:

\begin{indpar}[0.4in]

\hspace*{-0.2in}\ttmkey{prefix}{operator group} ~
    The flags \TT{initial} and \TT{right}.

\hspace*{-0.2in}\ttmkey{infix}{operator group} ~
    The flags \TT{left} and \TT{right}.

\hspace*{-0.2in}\ttmkey{postfix}{operator group} ~
    The flags \TT{left} and \TT{final}.

\hspace*{-0.2in}\ttmkey{nofix}{operator group} ~
    No flags.


\end{indpar}

\bigskip

\caption{\bf Operator Flags and Flag Groups}
\label{OPERATOR-FLAGS}
\end{boxedfigure}

\subsubsection{Operator Commands}
\label{OPERATOR-COMMANDS}

{\em Parser-operator-commands} modify and print
the operator parsing definition stack:

\begin{indpar}[0.1in]
\emkey{parser-operator-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em parser-operator-definition} \\
    $|$ & {\em parser-operator-print-command} \\
    \end{tabular}
\label{PARSER-OPERATOR-COMMAND}
\end{indpar}

\begin{indpar}[0.1in]
\emkey{parser-operator-definition} \\
    \hspace*{0.2in}\begin{tabular}{rl}
    ::= & \TT{define}\ttmindex{define operator}{parser command}
	   ~\begin{tabular}[t]{@{}l@{}}
	    \TT{operator}
	        \begin{tabular}[t]{l}
		{\em operator-name} ~ {\em parsing-selectors} \\
		{\em operator-flag} ~ {\em operator-flag}\,\STAR{} \\
		\end{tabular} \\
	    \TT{with precedence} ~ {\em precedence} \\
	    {}[ \TT{with} ~ {\em reformatter-name} ~ \TT{reformatter}
			  ~ {\em reformatter-arguments}\QMARK{} ] \\
	    \end{tabular} \\
    $|$ & \TT{undefine}\ttmindex{parser undefine operator}{parser command}
	   ~\begin{tabular}[t]{@{}l@{}}
	    \TT{operator}
	        \begin{tabular}[t]{l}
		{\em operator-name} ~ {\em parsing-selectors} \\
		{\em operator-flag} ~ {\em operator-flag}\,\STAR{} \\
		\end{tabular} \\
	    \TT{with precedence} ~ {\em precedence} \\
	    \end{tabular} \\
    \end{tabular}
\\[1ex]
\emkey{operator-name} \begin{tabular}[t]{rl}
		    ::= & {\em simple-operator-name} \\
		    $|$ & \TT{bracket} ~ {\em bracket-name} \\
		    $|$ & \TT{indentation mark} ~ {\em indentation-mark-name}
		    \end{tabular}
\\[1ex]
{\em simple-operator-name} ::= {\em quoted-key} \\
{\em quoted-key} ::= see \pagref{QUOTED-KEY} \\
{\em bracket-name} ::= see \pagref{BRACKET-NAME} \\
{\em indentation-mark-name} ::= see \pagref{INDENTATION-MARK-NAME}
\\[1ex]
\emkey{operator-flag} ::= \ttmkey{initial}{operator flag}
                      $|$ \ttmkey{left}{operator flag}
                      $|$ \ttmkey{right}{operator flag}
                      $|$ \ttmkey{final}{operator flag}
                      $|$ \ttmkey{afix}{operator flag}
                      $|$ \ttmkey{line}{operator flag}
                      $|$ {\em operator-flag-group}
	\\[1ex]
\emkey{operator-flag-group} ::= \ttmkey{prefix}{operator flag group}
                            $|$ \ttmkey{infix}{operator flag group}
                            $|$ \ttmkey{postfix}{operator flag group}
                            $|$ \ttmkey{nofix}{operator flag group}
	\\[1ex]
\emkey{precedence} \begin{tabular}[t]{rl}
		   :::= & {\em integer} in the range [L, H] \\
			& where L = -1,000,000 and H = +1,000,000 \\
		    \end{tabular}
	\\[1ex]
\emkey{reformatter-name} ::= see \pagref{REFORMATTER-NAME} \\
\emkey{reformatter-arguments} ::= see \pagref{REFORMATTER-ARGUMENTS}
\end{indpar}

\begin{indpar}[0.1in]
\emkey{parser-operator-print-command}%
\label{PARSER-OPERATOR-PRINT-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{print operator}{parser command}
	  {\em partial-operator-name} \\
    \end{tabular} \\[1ex]
\emkey{partial-operator-name} ::= {\em quoted-key}
\end{indpar}

An \key{operator definition} specifies for each operator the following:

\begin{indpar}[1in]
Name and Selectors \\
Operator Flags \\
Precedence \\
Reformatter
\end{indpar}

A {\em simple-operator-name} is matched to lexemes in a subexpression
in order to identify occurrences of the operator.
The other forms of {\em operator-name} permit bracketed subexpressions
with particular kinds of brackets to be parsed as if they were operators.
Thus in `\TT{x[5] = 0}' the bracketed subexpression
`\TT{[5]}' can be a postfix operator, and in:
\begin{indpar}\begin{verbatim}
int y:
    if x == 0:
        y = 5
    else:
        y = 6
\end{verbatim}\end{indpar}
the indented paragraph:
\begin{indpar}\begin{verbatim}
             :
        y = 5
\end{verbatim}\end{indpar}
introduced by the indentation mark `\TT{:}'
can be an afix operator which with the prefix `\TT{if}' operator
brackets the {\em conditional-expression} `\TT{x == 0}'.

When a bracketed subexpression (e.g., \TT{[\ldots]}) is identified as
an operator, only the opening bracket (e.g., `\TT{[}') is checked.
Since it is unusual for two defined brackets to have the same opening
and different closings, this usually is inconsequential.

Operators have \skey{operator flag}s that
affect parsing of subexpressions of the operator:
see Figure~\ref{OPERATOR-FLAGS}.
The actual flags are the union of those given in the definition.
Thus `\TT{infix left}' is the same as `\TT{infix}'.

The definition must have a {\em precedence}.

The {\em reformatter-name} in an {\em operator-definition} names a
function that is called after all other parsing has been done to
reformat a subexpression whose first operator is the defined operator.
For example, given the subexpression `\TT{(x, y, z)}', the bracket
parser recoginizes the `\TT{(~)}' brackets and calls the operator
parser on the subexpression `\TT{x, y, z}'.  The operator parser
recoginizes the `\TT{,}' operator and calls its reformatter
which changes this subexpression to the BRACKETABLE
expression `\TT{\{|x y z| .separator = ","\}}'.  The bracket parser,
seeing that this subexpression is BRACKETABLE, adds the `\TT{(~)}'
brackets to it, making: \\
\centerline{\tt \{|x y z| .separator = ",",
                          .initiator = "(",
			  .terminator = ")"\}}

However, most reformatters do not actually reformat: they just check
for errors.  Thus for `\TT{x / y}' the binary reformatter for `\TT{/}'
does nothing, but for `\TT{x / y / z}' it announces an error because
`\TT{/}' appears in a subexpression with more than one operator.

The optional {\em reformatter-arguments} are arguments to the reformatter
function.  For example, the `\TT{summation}' reformatter takes two
arguments, `\TT{(} {\em plus-op}\TT{,} {\em minus-op} \TT{)}', which
are usually `\TT{("+","-")}'.

A {\em parser-operator-print-command}
prints all operator table entries whose
{\em simple-operator-name},
{\em opening-bracket-name}, or
{\em indentation-mark-name}
contains the {\em partial-operator-name}
as a (not necessarily initial) subsequence of lexemes.  Using \TT{""} as
a {\em partial-operator-name} will print all operator
symbol table entries.

The possible operator reformatters are specified
in \itemref{OPERATOR-REFORMATTERS}.

\subsubsection{Standard Operators}
\label{STANDARD-OPERATORS}

The standard operators are given in Figures~\ref{STANDARD-OPERATORS-1},
\ref{STANDARD-OPERATORS-2},
and~\ref{STANDARD-OPERATORS-3}.

\begin{figure*}[!p]
\begin{center}
\begin{tabular}{|l|r|l|l@{\hspace*{1em}}|l@{\hspace*{1em}}|l|l|}
\hline
prece-  & selec-  &             &            &            &            & \\
~dence  & ~tors & reformatter	& flags	     & operator   & meaning    & class
\\\hline
0000    & code	& \TT{control}
                                & \TT{prefix} & \ttkey{if} & conditional & C
\\\cline{5-5}
	&	&		& \TT{line}  & \ttkey{else if} & & 
\\\cline{4-6}
	&	& 		& \TT{initial}
					     & \ttkey{else} & terminating & \\
	&	& 		& \TT{line}  &            & conditional &
\\\cline{3-6}
	&	& (none)	& \TT{afix } & \ttkey{:}  & conditional & \\
	&	&		& \TT{right} &            & modifier   & \\
	&	&		& \TT{line}  &            &            &
\\\cline{4-5}
	&	& 		& \TT{afix } & \ttkey{:} indentation & & \\
	&	&		& \TT{line}  & ~~~mark     &           &
\\\cline{4-4}\cline{6-6}
	&	& 		& \TT{postfix } &          & assignment  & \\
	&	&		& \TT{line}  &             & or loop     &
\\\cline{1-1}\cline{3-7}
1000    &     	& \TT{assignment} & \TT{left} & \ttkey{=}  & assignment & S \\
        &       &               & \TT{line}  &            &            &
\\\cline{3-7}
     	&	& \TT{binary}   & \TT{infix} & \ttkey{+=} & increment  & A
\\\cline{5-6}
     	&	&            	& \TT{line}  & \ttkey{-=} & decrement  &
\\\cline{5-6}
     	&	&            	&            & \ttkey{*=} & multiply by &
\\\cline{5-6}
     	&	&            	&            & \ttkey{/=} & divide by  &
\\\cline{5-7}
     	&	&            	&            & \ttkey{|=} & include    & B
\\\cline{5-6}
     	&	&            	&            & \ttkey{\&=} & mask      &
\\\cline{5-6}
     	&	&            	&            & \ttkey{\textasciicircum=}
	                                                  & flip       &
\\\cline{5-6}
     	&	&            	&            & \ttkey{<{}<=} & shift left  &
\\\cline{5-6}
     	&	&            	&            & \ttkey{>{}>=} & shift right  &
\\\cline{2-7}
        & math	& \TT{binary}	& \TT{infix} & \ttkey{=}  & assignment & S
\\\hline
\end{tabular}

\medskip

\begin{tabular}{ll}
Class & Standard Component
\\\hline
A: & \ttkey{arithmetic operators} \\
B: & \ttkey{bitwise operators} \\
C: & \ttkey{control operators} \\
S: & \ttkey{assignment operators} \\
\end{tabular}

\end{center}
\caption{Standard Operators: Part 1}
\label{STANDARD-OPERATORS-1}
\end{figure*}

\begin{figure*}[!p]
\begin{center}
\begin{tabular}{|l|r|l|l@{\hspace*{1em}}|l@{\hspace*{1em}}|l|l|}
\hline
prece-  & selec-  &             &            &            &            & \\
~dence  & ~tors & reformatter	& flags	     & operator   & meaning    & class
\\\hline
2000    & code	& \ttkey{separator}
				& \TT{nofix} & \ttkey{,}  & separator  & S \\
	& math	&		&	     &		  &	       &
\\\hline
3000	& code	& \ttkey{unary}
				& \TT{prefix} & \ttkey{do} & iterator & I
\\\cline{5-5}
	&	&		& \TT{line}  & \ttkey{while} & &
\\\cline{5-5}
	&	&		&	     & \ttkey{until} & &
\\\cline{3-3}\cline{5-5}
	&	& \ttkey{iteration}	&    & \ttkey{repeat} & &
\\\cline{5-5}
	&	&		&	     & \ttkey{at most} & &
\\\cline{3-6}
	&	& (none)	& \TT{afix}  & \ttkey{times} & iterator & \\
	&	&		& \TT{line}  & 		     & modifier  &
\\\hline
\end{tabular}

\medskip

\begin{tabular}{ll}
Class & Standard Component
\\\hline
S: & \ttkey{assignment operators} \\
I: & \ttkey{iteration operators} \\
\end{tabular}

\end{center}
\caption{Standard Operators: Part 2}
\label{STANDARD-OPERATORS-2}
\end{figure*}

\begin{figure*}[!p]
\begin{center}
\begin{tabular}{|l|r|l|l@{\hspace*{1em}}|l@{\hspace*{1em}}|l|l|}
\hline
prece-  & selec-  &             &            &            &            & \\
~dence  & ~tors & reformatter	& flags	     & operator   & meaning    & class
\\\hline
10000   & code  & \ttkey{selector}
				& \TT{infix} & \ttkey{if} & selector  & E
\\\cline{3-5}
        & math  & (none)        & \TT{afix}  & \ttkey{else} & & \\
	&       &               & \TT{infix} &              & &
\\\cline{1-1}\cline{3-7}
11000   & 	& \ttkey{binary}
				& \TT{infix} & \ttkey{BUT NOT}
							  & logical and not & L
\\\cline{1-1}\cline{3-6}
11100	&	& \ttkey{infix}	& \TT{infix} & \ttkey{AND} & logical and &
\\\cline{5-6}
	& 	&		&	     & \ttkey{OR}  & logical or  &
\\\cline{1-1}\cline{3-6}
11200   &	& \ttkey{unary}	& \TT{prefix} & \ttkey{NOT} & logical not &
\\\cline{1-1}\cline{3-7}
12000 	&	& (none)	& \TT{infix} & \ttkey{==} & equal      & P
\\\cline{5-6}
	& 	&		&	     & \ttkey{!=} & not equal  &
\\\cline{5-6}
	& 	&	      	&	     & \ttkey{<}  & less than  &
\\\cline{5-6}
	& 	&		&	     & \ttkey{<=} & less than or equal
	                                                               &
\\\cline{5-6}
	& 	&	      	&	     & \TT{>}	& greater than &
\\\cline{5-6}
	& 	&		&	     & \TT{>=}	& greater than or equal
	                                                               &
\\\cline{1-1}\cline{3-7}
13000	&       & \ttkey{infix}	& \TT{infix} & \TT{+}	& addition     & A
\\\cline{5-6}
	&	&		& 	     & \TT{-}	& subtraction  &
\\\cline{2-3}\cline{5-7}
	& code  & \ttkey{infix}	&            & \TT{|}	& binary or    & B
\\\cline{5-6}
	&	&		& 	     & \TT{\&}	& binary and   &
\\\cline{5-6}
	&	&		& 	     & \TT{\textasciicircum}
						        & binary exclusive or
							               &
\\\hline
13100	& code	& \ttkey{binary} & \TT{infix} & \TT{/}	& division     & A
\\\cline{1-1}\cline{3-6}
13200	& math	& \ttkey{infix}	& \TT{infix} & \TT{*}   & multiplication &
\\\cline{1-1}\cline{3-6}
13300	&	& \ttkey{binary} & \TT{infix} & \TT{**} & exponentiation &
\\\cline{2-2}\cline{5-6}
        & code 	&                &            & \TT{<{}<} & left shift &
\\\cline{5-6}
        &       &                &            & \TT{>{}>} & right shift &
\\\cline{1-2}\cline{3-6}
H-1	& code	& \ttkey{unary}	& \TT{prefix} & \TT{+}	& no-op        &
\\\cline{5-6}
	& math  &		& 	      & \TT{-}	& negation     & 
\\\cline{2-2}\cline{5-7}
	& code 	&       	& 	      & \TT{\textasciitilde}
	                                                & binary complement
							               & B
\\\hline
\end{tabular}

\medskip

\begin{tabular}{ll}
Class & Standard Component
\\\hline
A: & \ttkey{arithmetic operators} \\
B: & \ttkey{bitwise operators} \\
E: & \ttkey{selection operators} \\
L: & \ttkey{logical operators} \\
P: & \ttkey{comparison operators}
\end{tabular}

\medskip

\begin{tabular}{ll}
Note: & All operators in an expression with \TT{infix}
        \underline{reformatter} must be \\
      & identical, except that \TT{+} and \TT{-}
        are allowed in the same expression. \\
      & E.g., \TT{AND} and \TT{OR} are not both
        allowed in the same expression; \\
      & and only one of \TT{|}, \TT{\&}, and \TT{\textasciicircum}
        is allowed in an expression. \\
\end{tabular}

\end{center}
\caption{Standard Operators: Part 3}
\label{STANDARD-OPERATORS-3}
\end{figure*}

\clearpage

The following parser standard components
(see \itemref{PARSER-STANDARD-COMMANDS})
can be used to define these standard operators.

\begin{center}
\begin{tabular}{l@{\hspace*{0.2in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{control operators}'\label{STANDARD-CONTROL-OPERATORS}
     Component} \\
\multicolumn{2}{c}
{\bf Operator Definition Parser Commands}
\\[1ex]
Parser Command				& \shortstack{
                                          Given\\Qualifiers}
\\\hline
\tt define operator "if" [code] prefix line & {\tt + code} \\
\tt ~~~~~~~with precedence 0 \\
\tt ~~~~~~~with control reformatter ( ":", has condition ) \\
\tt define operator "else if" [code] prefix line & {\tt + code} \\
\tt ~~~~~~~with precedence 0 \\
\tt ~~~~~~~with control reformatter ( ":", has condition ) \\
\tt define operator "while" [code] prefix line & {\tt + code} \\
\tt ~~~~~~~with precedence 0 \\
\tt ~~~~~~~with control reformatter ( ":", has condition ) \\
\tt define operator "until" [code] prefix line & {\tt + code} \\
\tt ~~~~~~~with precedence 0 \\
\tt ~~~~~~~with control reformatter ( ":", has condition ) \\
\tt define operator "else" [code] prefix line & {\tt + code} \\
\tt ~~~~~~~with precedence 0 \\
\tt ~~~~~~~with control reformatter ( ":" ) \\
\\[1ex]
\tt define operator ":" [code] afix line & {\tt + code} \\
\tt ~~~~~~~with precedence 0 \\
\tt define operator indentation mark ":" [code] & {\tt + code} \\
\tt ~~~~~~~afix line \\
\tt ~~~~~~~with precedence 0 \\
\tt define operator indentation mark ":" [code] & {\tt + code} \\
\tt ~~~~~~~postfix line \\
\tt ~~~~~~~with precedence 0 \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{l@{\hspace*{0.5in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{assignment operators}'
     \label{STANDARD-ASSIGNMENT-OPERATORS} Component} \\
\multicolumn{2}{c}
{\bf Operator Definition Parser Commands}
\\[1ex]
Parser Command				& \shortstack{
                                          Given\\Qualifiers}
\\\hline
\tt define operator "=" [code] left line & {\tt + code} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with assignment reformatter ( ":" ) \\
\tt define operator "=" [math] infix & {\tt + math} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with binary reformatter
\\[1ex]
\tt define operator indentation mark ":" [code] & {\tt + code} \\
\tt ~~~~~~~postfix line \\
\tt ~~~~~~~with precedence 1000 \\
\\[1ex]
\tt define operator indentation mark ":" [code] & {\tt + code} \\
\tt ~~~~~~~afix line \\
\tt ~~~~~~~with precedence 1000 \\
\\[1ex]
\tt define operator "," [code, math] nofix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 2000 \\
\tt ~~~~~~~with separator reformatter \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{l@{\hspace*{0.2in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{iteration operators}'\label{STANDARD-ITERATION-OPERATORS}
     Component} \\
\multicolumn{2}{c}
{\bf Operator Definition Parser Commands}
\\[1ex]
Parser Command				& \shortstack{
                                          Given\\Qualifiers}
\\\hline
\tt define operator "do" [code] prefix line & {\tt + code} \\
\tt ~~~~~~~with precedence 3000 \\
\tt ~~~~~~~with unary reformatter \\
\tt define operator "while" [code] prefix line & {\tt + code} \\
\tt ~~~~~~~with precedence 3000 \\
\tt ~~~~~~~with unary reformatter \\
\tt define operator "until" [code] prefix line & {\tt + code} \\
\tt ~~~~~~~with precedence 3000 \\
\tt ~~~~~~~with unary reformatter
\\[1ex]
\tt define operator "repeat" [code] prefix line & {\tt + code} \\
\tt ~~~~~~~with precedence 3000 \\
\tt ~~~~~~~with iteration reformatter ( "times" ) \\
\tt define operator "at most" [code] prefix line & {\tt + code} \\
\tt ~~~~~~~with precedence 3000 \\
\tt ~~~~~~~with iteration reformatter ( "times" )
\\[1ex]
\tt define operator "times" [code] afix line & {\tt + code} \\
\tt ~~~~~~~with precedence 3000 \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{l@{\hspace*{0.2in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{selection operators}'
     \label{STANDARD-SELECTION-OPERATORS} Component} \\
\multicolumn{2}{c}
{\bf Operator Definition Parser Commands}
\\[1ex]
Parser Command				& \shortstack{
                                          Given\\Qualifiers}
\\\hline
\tt define operator "if" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 10000 \\
\tt ~~~~~~~with selector reformatter \\
\tt ~~~~~~~~~~~~( "if", "else" ) \\
\\[1ex]
\tt define operator "else" [code, math] afix infix
					    & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 10000
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{l@{\hspace*{0.2in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{logical operators}'
     \label{STANDARD-LOGICAL-OPERATORS} Component} \\
\multicolumn{2}{c}
{\bf Operator Definition Parser Commands}
\\[1ex]
Parser Command				& \shortstack{
                                          Given\\Qualifiers}
\\\hline
\tt define operator "BUT NOT" [code, math] infix
                                            & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 11000 \\
\tt ~~~~~~~with binary reformatter
\\[1ex]
\tt define operator "AND" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 11100 \\
\tt ~~~~~~~with infix reformatter ( "AND" ) \\
\tt define operator "OR" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 11100 \\
\tt ~~~~~~~with infix reformatter ( "OR" )
\\[1ex]
\tt define operator "NOT" [code, math] prefix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 11200 \\
\tt ~~~~~~~with unary reformatter \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{l@{\hspace*{0.2in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{comparison operators}'
     \label{STANDARD-COMPARISON-OPERATORS} Component} \\
\multicolumn{2}{c}
{\bf Operator Definition Parser Commands}
\\[1ex]
Parser Command				& \shortstack{
                                          Given\\Qualifiers}
\\\hline
\tt define operator "==" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 12000 \\
\tt ~~~~~~~with infix reformatter \\
\tt define operator "<=" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 12000 \\
\tt ~~~~~~~with infix reformatter \\
\tt define operator ">=" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 12000 \\
\tt ~~~~~~~with infix reformatter \\
\tt define operator "!=" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 12000 \\
\tt ~~~~~~~with infix reformatter \\
\tt define operator "<" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 12000 \\
\tt ~~~~~~~with infix reformatter \\
\tt define operator ">" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 12000 \\
\tt ~~~~~~~with infix reformatter \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{l@{\hspace*{0.2in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{arithmetic operators}'
     \label{STANDARD-ARITHMETIC-OPERATORS} Component} \\
\multicolumn{2}{c}
{\bf Operator Definition Parser Commands}
\\[1ex]
Parser Command				& \shortstack{
                                          Given\\Qualifiers}
\\\hline
\tt define operator "+=" [code] infix line & {\tt + code} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with binary reformatter \\
\tt define operator "-=" [code] infix line & {\tt + code} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with binary reformatter \\
\tt define operator "*=" [code] infix line & {\tt + code} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with binary reformatter \\
\tt define operator "/=" [code] infix line & {\tt + code} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with binary reformatter
\\[1ex]
\tt define operator "+" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 13000 \\
\tt ~~~~~~~with infix reformatter ( "+", "-" ) \\
\tt define operator "-" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 13000 \\
\tt ~~~~~~~with infix reformatter ( "+", "-" ) \\
\tt define operator "/" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 13100 \\
\tt ~~~~~~~with binary reformatter \\
\tt define operator "*" [code, math] infix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 13200 \\
\tt ~~~~~~~with infix reformatter ( "*" ) \\
\tt define operator "**" [code, math] infix
                                           & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 13300 \\
\tt ~~~~~~~with binary reformatter
\\[1ex]
\tt define operator "+" [code, math] prefix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 999999 \\
\tt ~~~~~~~with unary reformatter \\
\tt define operator "-" [code, math] prefix & {\tt + code} or {\tt + math} \\
\tt ~~~~~~~with precedence 999999 \\
\tt ~~~~~~~with unary reformatter \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{l@{\hspace*{0.2in}}l}
\multicolumn{2}{c}
{\bf Standard `\ttkey{bitwise operators}'
     \label{STANDARD-BITWISE-OPERATORS} Component} \\
\multicolumn{2}{c}
{\bf Operator Definition Parser Commands}
\\[1ex]
Parser Command				& \shortstack{
                                          Given\\Qualifiers}
\\\hline
\tt define operator "|=" [code] infix line & {\tt + code} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with binary reformatter \\
\tt define operator "\&=" [code] infix line & {\tt + code} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with binary reformatter \\
\tt define operator "\textasciicircum=" [code] infix line & {\tt + code} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with binary reformatter \\
\tt define operator "<{}<=" [code] infix line & {\tt + code} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with binary reformatter \\
\tt define operator ">{}>=" [code] infix line & {\tt + code} \\
\tt ~~~~~~~with precedence 1000 \\
\tt ~~~~~~~with binary reformatter
\\[1ex]
\tt define operator "|" [code] infix & {\tt + code} \\
\tt ~~~~~~~with precedence 13000 \\
\tt ~~~~~~~with infix reformatter ( "|" ) \\
\tt define operator "\&" [code] infix & {\tt + code} \\
\tt ~~~~~~~with precedence 13000 \\
\tt ~~~~~~~with infix reformatter ( "\&" ) \\
\tt define operator "\textasciicircum" [code] infix & {\tt + code} \\
\tt ~~~~~~~with precedence 13000 \\
\tt ~~~~~~~with infix reformatter ( "\textasciicircum" )
\\[1ex]
\tt define operator "<{}<" [code] infix & {\tt + code} \\
\tt ~~~~~~~with precedence 13000 \\
\tt ~~~~~~~with binary reformatter \\
\tt define operator ">{}>" [code] infix & {\tt + code} \\
\tt ~~~~~~~with precedence 13000 \\
\tt ~~~~~~~with binary reformatter
\\[1ex]
\tt define operator "\textasciitilde" [code] prefix & {\tt + code} \\
\tt ~~~~~~~with precedence 999999 \\
\tt ~~~~~~~with unary reformatter \\
\end{tabular}
\end{center}


\subsubsection{The Operator Parsing Algorithm}
\label{OPERATOR-PARSER-ALGORITHM}

The operator parsing pass runs the \key{operator parsing algorithm}
that accepts as input a sequence of tokens
which we call an `expression'
and edits this input, changing it into a single \TT{BRACKETABLE} token
if it contains any operators, and calling subsequent passes on the
expression if it does not contain any operators.

\subsubsubsection{Algorithm Outline}

The operator parsing algorithm runs a left to right scan which:
\begin{enumerate}
\item Identifies sequences of tokens that are operators, and
replaces each by a single \ttkey{OPERATOR} token.
\item Identifies maximal non-empty sequences of tokens between \TT{OPERATOR}
tokens, calls subsequence passes on each, and if these do not
turn the sequence into a single token that is \TT{BRACKETTED},
\TT{BRACKETABLE}, or \TT{PURELIST}, packages the sequence into
a single \TT{PURELIST} token.  The result is a single `non-operator'
token.
\item Identifies subexpressions using operator precedence and flags.
\item Processes each subexpression, innermost first, treating the
entire expression as a subexpression.  For each subexpression,
the reformatter of the first operator in the expression is called.
If there is no reformatter, or the reformatter chooses not to
collect the expression into a single \TT{BRACKETABLE} token, then
the expression is made into a single \TT{PURELIST} token unless
the expression is already a single token of \TT{BRACKETED},
\TT{BRACKETABLE}, or \TT{PURELIST} type.
\end{enumerate}


The left-to-right scan always has a current position.
All operators to the left of the current position have been
identified as per \itemref{OPERATOR-IDENTIFICATION}.
All tokens between two identified operators have been collected
into a single non-operator token.
Subexpression recognition is done after operators
and non-operators have been thus determined, and can be done
most simply by a second left-to-right scan.

\subsubsubsection{Operator Identification}
\label{OPERATOR-IDENTIFICATION}

Operator identification determines whether a sequence of lexemes
beginning at the current position is an operator by looking up
operator definitions.  Only
operator definitions selected by the current parsing selectors are
considered.  Longer operators are preferred over shorter
operators, and among these, operators defined later are
preferred over operators defined earlier.

When an operator definition is selected, it is accepted or rejected
according to its flags and the token immediately to its left, which
may be an operator or non-operator token.  The flags of the operator
definition and of any operator to its left determine whether the
operator is accepted or rejected, according to the rules in
Figure~\ref{OPERATOR-FLAG-RULES}.  If an operator is accepted,
its is made into a single token and the search for an operator
at the current position terminates.

The ends of the whole expression are treated as if they were
special operators with no flags and precedence L-2.

\begin{boxedfigure}[!t]

If an operator definition has the \ttkey{afix} flag,
the definition
is \underline{rejected} unless all of the following \underline{would} be true
after insertion of the afix definition's operator:
\begin{itemize}
\item[(1)] There is an operator preceding the inserted operator
that has the same precedence as the inserted operator.
\item[(2)] There is no
operator of lower precedence between this preceding operator
and the inserted operator.
\end{itemize}

If an operator definition D of precedence Q is not rejected
by the rule above,
the first applicable entry in the following table is used
to accept or reject the operator.
The token immediately to the left of the current position
is T, and if it is an operator, it has precedence P.

\begin{center}
\begin{tabular}{lllll}
T Type		& T Flags
			& D flags	& Condition	& Result
\\\hline
non-operator	&	& initial	&	& reject \\
non-operator	&	& other	 	&	& accept
\\[0.5ex]
operator	& right & left		&	& reject \\
operator	& right & initial	& P > Q	& reject \\
operator	& right & initial	& P < Q	& accept \\
operator	& right + initial
			& initial	& P = Q	& accept \\
operator	& right + other
			& initial	& P = Q & reject \\
operator	& right & other		& P < Q	& accept \\
operator	& right & other		& P $\ge$ Q	& reject
\\[0.5ex]
operator	& final & initial	&	& reject \\
operator	& final & left		& P > Q	& accept \\
operator	& final & left		& P < Q	& reject \\
operator	& final & left + final 	& P = Q	& accept \\
operator	& final & left + other	& P = Q	& reject \\
operator	& final & other		& P > Q	& accept \\
operator	& final & other		& P $\le$ Q	& reject
\\[0.5ex]
operator	& other	 & initial	& P < Q	& accept \\
operator	& other	 & initial	& P $\ge$ Q	& reject \\
operator	& other	 & left		& P > Q	& accept \\
operator	& other	 & left		& P $\le$ Q	& reject \\
operator	& other	 & other	& 	& accept \\

\end{tabular}
\end{center}

\caption{\bf Operator Flag Rules}
\label{OPERATOR-FLAG-RULES}
\end{boxedfigure}

If an operator is identified, its lexemes are collected into
an \TT{OPERATOR} token.  If no operator is identified, the
current position is moved one token to the right.

When an operator is identified, the non-\TT{OPERATOR}
tokens between it and the preceding operator
are treated as an operator-free subexpression.
This is a `\key{non-operator subexpression}' if it is not empty.
For each non-operator subexpression
(including the whole expression if it has no operators),
if it is a single token of \TT{BRACKETED}, \TT{BRACKETABLE}, or
\TT{PURLIST} type, it is left alone.  Otherwise
the next pass is called, and
then the subexpression is made into a single
\TT{PURELIST} token.  Thus each non-operator subexpression
is replaced by a single non-operator token.  Note that by construction,
two non-operator tokens cannot be next to each other.

If no operator is identified at the current position, and the
previous position contains an operator with the \TT{final}
flag, it is a parsing error which is `fixed up' by inserting
an \ttkey{ERROR'OPERATOR} of precedence L-1 and no flags
before the current position.

If the whole expression ends with an operator that has the
\TT{right} flag, it is a parsing error which is `fixed up'
by inserting a non-operator \ttkey{ERROR'OPERAND} before the current position.

\subsubsubsection{Subexpression Processing}
\label{SUBEXPRESSION-PROCESSING}

After operators and their fixity have been determined, the
expression is parsed into subexpressions according to the
syntax given in \itemref{OPERATOR-EXPRESSION-SYNTAX}.
At this point, all operators in a subexpression have the
same precedence, and all non-operators are single tokens
of \TT{BRACKETED}, \TT{BRACKETABLE}, or \TT{PURLIST} type.

If a subexpression contains one or more operators, the
operator parsing pass first calls the reformatter associated
with the first operator
in the subexpression, if any.  Then if the reformatter requests, or if
there is no reformatter, and if the subexpression does not consist
of a single \TT{BRACKETED}, \TT{BRACKETABLE}, or \TT{PURLIST} token,
the subexpression is compacted into a single \TT{PURELIST} token.

The bracketed subexpression recognition pass may merge brackets
into \TT{BRACKETABLE} tokens: see \pagref{MERGING-BRACKETABLE-TOKENS}.
Thus given `\TT{(x, y)}', the `\TT{separator}' reformatter
applied to `\TT{x, y}' will return
\begin{indpar}\begin{verbatim}
@1 := x y::
         .separator = ","
\end{verbatim}\end{indpar}
so without this merging the bracketed subexpression recognition
pass would produce
\begin{indpar}\begin{verbatim}
@2 := @1::
         .initiator = "("
         .terminator = ")"
@1 := x y::
         .separator = ","
\end{verbatim}\end{indpar}
but instead it produces
\begin{indpar}\begin{verbatim}
@1 := x y::
         .initiator = "("
         .terminator = ")"
         .separator = ","
\end{verbatim}\end{indpar}

\subsubsection{Operator Reformatters}
\label{OPERATOR-REFORMATTERS}

In describing the effects of operator reformatters
we use notation such as

\hspace*{2em}\begin{tabular}{lcl}
\TT{- x + y * z} & $\Longrightarrow$ & \TT{(- x) + (y * z)} \\
\TT{x AND y OR z} & $\Longrightarrow$ & error
\end{tabular}

Here $\Longrightarrow$ means `is reformatted as'.  Furthermore, the
parentheses introduced by the rewrite are \underline{implied},
which means that the lists they bracket have \underline{no}
\TT{.initiator} or \TT{.terminator}, and the parentheses are
merely written here to indicate sublists in the expression structure.

Reformatters can detect parsing errors, such the fact that the two
operators in `\TT{x AND y OR z}' are not identical (when both are
infix operators with the same precedence).

Note that many errors that one might expect to be handled by
reformatters are not so-handled because the operators are not
recognized.  For example, no operators are recognized in:
\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}l}
\TT{x NOT y}	& \TT{NOT} is not in prefix position \\
\TT{/ y}	& \TT{/} is not in infix position \\
\end{tabular}
\end{center}

With the above in mind, the operator reformatters are:


\begin{indpar}[1em]

\newcommand{\OP}[1]{\ttmkey{#1}{reformatting}}
\newcommand{\NBOP}[1]{\ttmkey{#1}{reformatting}}

\bigskip

\ttmkey{control}{reformatter}
\TT{(} {\em delimiter} \{ \TT{,} \ttkey{has condition} \}\QMARK{} \TT{)}
\hfill \OP{if} ~~~~~ \OP{else if} ~~~~~ \OP{else}


\begin{indpar}[0.5em]
Typically used with \TT{prefix} \TT{line} operators
(e.g., \TT{if}).

The expression must have one of the forms:

\hspace*{2em} {\em op} {\em condition}\QMARK{} {\em delimiter} {\em statement}

or

\hspace*{2em}\begin{tabular}{l}
             {\em op} {\em condition}\QMARK{} {\em delimiter} \\
	     ~~~~~{\em statement}\STAR{}
	     \end{tabular}

The {\em delimiter} is typically \TT{:}.
The {\em condition} expression must be present if and only if
\TT{has condition} is a reformatter argument.  This is the case
for \TT{if} and \TT{else if} but not for \TT{else}.

\end{indpar}

\ttmkey{assignment}{reformatter}
\hfill \OP{=}


\begin{indpar}[0.5em]
Typically used with line assignment operator
(e.g., \TT{=}).

The expression must be postfix or binary.  Specifically, it must
consist of an operand followed by the operator followed
by an \underline{optional} operand.

\end{indpar}

\ttmkey{separator}{reformatter}
\hfill \OP{,}


\begin{indpar}[0.5em]
Typically used with \TT{nofix} operators (e.g., \TT{,} or \TT{;}).

All operator values must be identical, must be MIN names,
and will become the \TT{.sepa\-rator} attribute of the
expression.

It is required that any two operands be separated by an operator,
but operators my be consecutive and may begin or end the subexpression.

Empty list operands are inserted to make all operators
infix (if some are originally nofix).
Then the operators are deleted, the resulting list of
operands is made into a \TT{BRACKETABLE} token with a MIN object value
that has a \ttmkey{.separator}{produced by parsing}
attribute whose value is the first operator.
Examples
with `\TT{,}' as operator are:

\hspace*{2em}\begin{tabular}{lcl@{~~~~~}l}
\TT{x , y} & $\Longrightarrow$ & \TT{x y}
					& with \TT{.separator ","} \\
\TT{, y} & $\Longrightarrow$ & \TT{\{\} y}
					& with \TT{.separator ","} \\
\TT{x ,} & $\Longrightarrow$ & \TT{x \{\}}
					& with \TT{.separator ","} \\
\TT{x , , y} & $\Longrightarrow$ & \TT{x \{\} y}
					& with \TT{.separator ","} \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{iteration}{reformatter}
\TT{(} {\em second-operator} \TT{)}
\hfill \NBOP{repeat} ~~~ \OP{at most} ~~~ \OP{times}

\begin{indpar}[0.5em]

Typically used with a \TT{prefix} operator (e.g., \TT{repeat}) and a
second \TT{afix} operator (e.g. \TT{times}).

The expression must have the form `{\em operator} {\em operand} {\em operator}'
with the second {\em operator} being equal to the reformatter argument
(e.g., \TT{times}).

\end{indpar}

\bigskip


\ttmkey{declare}{reformatter}
\TT{(} {\em second-operator} \TT{)}
\hfill \NBOP{<-{}-} ~~~ \OP{:}

\begin{indpar}[0.5em]
Typically used with a \TT{nofix} operator (e.g., \TT{<-{}-}) with
\TT{final} \TT{afix} operator following (e.g. \TT{:}).

If the expression does not begin with a non-operator, an empty
list \TT{\{\}} is inserted at the beginning of the expression.
If what is now the third token of the expression does not
exist or is an operator, an empty list \TT{\{\}} is inserted
as the third token.  If a fourth token now exists, it is checked
to be sure it equals the {\em second-operator} reformatter argument
followed by an operand
followed by the end of the expression, or it is an indented paragraph
whose {\em indentation-mark} equals the {\em second-operand} reformatter
argument.

For example, if \TT{<-{}-} is a nofix operator with this reformatter having
\TT{:} as its {\em second-operator}, and if the mark \TT{:}~is an afix operator
with the same precedence, and if the {\em indentation-mark} \TT{:} is similarly
an afix operator with the same precedence:

\hspace*{2em}\begin{tabular}{lcl}
\TT{x <-{}- y :~a b c} & $\Longrightarrow$
                       & \TT{x <-{}- y :~(a b c)} \\
\TT{x <-{}- :~a b c } & $\Longrightarrow$
                      & \TT{x <-{}- \{\} :~(a b c)} \\
\TT{<-{}- y :~a b c } & $\Longrightarrow$
                      & \TT{\{\} <-{}- y :~(a b c)} \\
\TT{x <-{}-}          & $\Longrightarrow$
                      & \TT{x <-{}- \{\}}
\\[1ex]
\begin{tabular}{@{}l@{}}
\TT{x~<-{}-~u v w:} \\
\TT{~~~~~~a b c}
\end{tabular}
& $\Longrightarrow$ &
\begin{tabular}{@{}l@{}}
\TT{x <-{}- ( u v w ):} \\
\TT{~~~~a b c}
\end{tabular}
\end{tabular}

Because \TT{:} is an afix operator
with same precedence as \TT{<-{}-},
`\TT{x <-{}- y :~a b c}' does \underline{not}
end up as `\TT{x <-{}- x ( y :~a b c )}'.

\end{indpar}

\bigskip

\ttmkey{selector}{reformatter}
\TT{(} {\em first-operator}\TT{,} {\em second-operator} \TT{)}
\hfill \OP{if} ~~~ \OP{else}


\begin{indpar}[0.5em]
Typically used with \TT{infix} operators (e.g., \TT{if} and \TT{else}).

Operators and operands must alternate, with the first and last
subexpression elements being operands.

There must be an even number of operators, the first two as given by
the reformatter arguments, and all the operators must alternate between
these two possibilities.

\end{indpar}

\bigskip

\ttmkey{infix}{reformatter} 
    \{ \TT{(} {\em operator} \{ \TT{,} {\em operator} \}\STAR{} \TT{)}
    \}\QMARK{}
    \hfill \NBOP{AND} ~~~ \NBOP{OR} ~~~ \NBOP{+}
    ~ \NBOP{-} ~ \NBOP{|} ~ \NBOP{\&} ~ \NBOP{\textasciicircum} ~ \NBOP{*}

\begin{indpar}[0.5em]
Should only be used with operators whose precedence contains only
\TT{infix} operators.

Checks that operands and operators alternate, and that the expression
begins and ends with an operator.

Checks that all the operators in the expression are listed as arguments
to the reformatter.  But if the reformatter has no arguments, does
\underline{not} check the operators.
\end{indpar}

\bigskip


\ttmkey{right associative}{reformatter}
    \{ \TT{(} {\em operator} \{ \TT{,} {\em operator} \}\STAR{} \TT{)}
    \}\QMARK{}

\begin{indpar}[0.5em]
Identical to the \TT{infix} reformatter, except after checking
the expression, inserts implied brackets into the expression from
right to left making all operators
binary with the \underline{rightmost}
operator innermost (executed first).


Thus if \TT{=}, \TT{+=}, and \TT{*=}
are all infix operators of the same precedence with this reformatter
and reformatter arguments {\tt ("=", "+=")}, then:

\hspace*{2em}\begin{tabular}{lcl}
\TT{y = z} & $\Longrightarrow$ & \TT{y = z} \\
\TT{x = y += z} & $\Longrightarrow$ & \TT{x = (y += z)} \\
\TT{x = y *= z} & $\Longrightarrow$ & error
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{left associative}{reformatter}
    \{ \TT{(} {\em operator} \{ \TT{,} {\em operator} \}\STAR{} \TT{)}
    \}\QMARK{}

\begin{indpar}[0.5em]
Identical to the \TT{infix} reformatter, except after checking
the expression, inserts implied brackets into the expression from left
to right making all operators
binary with the \underline{leftmost}
operator innermost (executed first).


Thus if \TT{+}, \TT{-}, and \TT{++}
are all infix operators of the same precedence with this reformatter
and reformatter arguments {\tt ("+", "-")}, then:

\hspace*{2em}\begin{tabular}{lcl}
\TT{y + z} & $\Longrightarrow$ & \TT{y + z} \\
\TT{x + y - z} & $\Longrightarrow$ & \TT{(x + y) - z} \\
\TT{x + y ++ z} & $\Longrightarrow$ & error
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{unary}{reformatter}
    \hfill \NBOP{NOT} ~~~ \NBOP{+} ~~~ \NBOP{-} ~~~ \NBOP{\textasciitilde}

\begin{indpar}[0.5em]
Typically used with \TT{prefix} operators.

Checks that the subexpression has exactly two elements, an operator followed
by an operand.  Examples
where \TT{NOT} is a prefix operator with this reformatter:

\hspace*{2em}\begin{tabular}{lcl}
\TT{NOT x} & $\Longrightarrow$ & \TT{NOT x} \\
\TT{NOT NOT x} & $\Longrightarrow$ & \TT{NOT (NOT x)} \\
\TT{NOT} & $\Longrightarrow$ & \TT{NOT ERROR'OPERAND} \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{binary}{reformatter}
    \hfill \NBOP{=} ~~~ \NBOP{BUT NOT} ~~~ \NBOP{<{}<} ~~ \NBOP{>{}>}
                          ~~~ \NBOP{/} ~~~ \NBOP{**}

\begin{indpar}[0.5em]
Typically used with \TT{infix} operators.

The subexpression must have exactly three elements, an operand
followed by an operator followed by an operand.
Examples:

\hspace*{2em}\begin{tabular}{lcl}
\TT{x BUT NOT y} & $\Longrightarrow$ & \TT{x [< BUT NOT >] y} \\
\TT{x / y} & $\Longrightarrow$ & \TT{x / y} \\
\TT{x \textasciicircum{} y} & $\Longrightarrow$ & \TT{x \textasciicircum{} y} \\
\TT{x / y / z} & $\Longrightarrow$ & error \\
\end{tabular}

Note that in these examples `\TT{BUT NOT}' is a single label element
of the resulting subexpression,
and \underline{not} two word elements of the subexpression.
\end{indpar}

\bigskip

\end{indpar}



\clearpage

\appendix

\section{Standard Lexical Program}
\label{STANDARD-LEXICAL-PROGRAM}

\begin{indpar}
\lstinputlisting{../test/ll_lexeme_standard.lex}
\end{indpar}

\newpage

\section{C++ Lexical Program}
\label{C++-LEXICAL-PROGRAM}

\begin{indpar}
\lstinputlisting{../test/ll_lexeme_c++.lex}
\end{indpar}

\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
