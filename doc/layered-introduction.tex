% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
\newcommand{\ttikey}[2]{{\tt \bf #1}\index{#2@{\tt #2}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttnbakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\ttitemref}[1]{{\tt \ref{#1} ({p\pageref{#1}})}}
\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newsavebox{\DOUBLEQUOTEBOX}
\begin{lrbox}{\DOUBLEQUOTEBOX}
\verb/"/
\end{lrbox}
\newcommand{\DOUBLEQUOTE}{\usebox{\DOUBLEQUOTEBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

April 16, 2013
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A machine independent reduced instruction set architecture
	  programming language.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& Similar to the C programming language but more flexible.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& Implements standardized lists, symbols, arrays, etc. to extend
	  the M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `{\tt hello}', `{\tt +}', `{\tt ;}',
`{\tt 9.200}' are four lexemes.

The lexical scanner is written in the M-Language and can be
replaced.  This section describes the standard scanner which
is driven by the lexical tables and is capable scanning
lexemes of common languages such as C and C++.

The standard scanner attempts to be both machine and human
efficient.  It attempts to be machine efficient by being
deterministic\footnote{Unlike regular expression scanners.}
and attempts to be human efficient by supporting algorithms
that people can readily understand and hopefully quickly
learn to mimic.\footnote{A possibly non-verifiable goal.}

The standard scanner operates on an input stream of 32-bit
UNICODE characters.  Each character is associated with
a position value that specifies from where the character
came.  For example, a position value may encode a file name,
line-within-file number, and column-within-line number.
The standard scanner identifies a lexeme as a sequence
of input stream UNICODE 32-bit characters each with a
corresponding position value.

The standard scanner also produces a translation of each
lexeme.  This may just be a copy of the 32-bit characters
in the lexeme, or it may have some changes, or `translations',
of some of these characters.  For example, the lexeme
\verb|"a line<LF>"| may have a translation that omits the
\verb|"|'s and converts the four characters \verb|<LF>| into
a single linefeed character.

When the standard scanner identifies a lexeme it also identifies
a `\mkey{type}{of lexeme}' for the lexeme.
For example, the lexeme \verb|9.35| may have type `{\tt number}'
while the lexeme \verb|"abc"| may have the type `{\tt quoted string}'.

At its most fundamental level the
standard scanner identifies lexical atoms in the input text.
A \key{lexical atom} is a single character (e.g., the letters
in an identifier or word) or a short string of characters
(e.g., the 4-character atom \verb|<LF>| in a quoted string).
Lexical atoms are read left to right and
grouped by the scanner into \skey{lexeme}s.

Lexical atoms have fixed small lengths.  Lexemes, in contrast,
can be of arbitrary length.

Each atom is translated individually to produce an
\key{atom translation}.  Just as the sequence of atoms in a lexeme
comprise the lexeme, the sequence of their atom translations
comprises the translation of the lexeme.  An atom translation
may be the empty string, in effect omitting the atom from the
lexeme translation.

The scanner has a state containing a current point 
in the input UNICODE character stream,
a \key{current lexical table} identifier, a \key{current lexeme type}
which may be `{\tt none}', and a \key{return stack}
of lexical table identifiers.  A
\key{lexical table} is a set of atom patterns
that match atoms, and for each pattern an
instruction that determines what to do when the pattern is matched.
There is also a \key{default instruction} associated with
the lexical table that
determines what to do when no table pattern matches the next characters
in the input stream.

An \key{atom pattern}\index{pattern!lexical atom} is a fixed
length sequence of character patterns, and matches any sequence of
input characters of the same length as the atom pattern
if each input character of the sequence matches the corresponding
character pattern.  A \key{character pattern} is simply a
specification of a set of characters, e.g., letters or digits.
Thus one can construct an atom pattern that will recognize
single letters, or one that will recognize the sequence of
characters such as the 4-character sequence \verb|<LF>| which matches
the atom pattern \verb|"<" "LF" ">"|
(in which the quoted string has been broken into three parts to prevent
\verb|<LF>| being treated as representing a single line feed character)
or the 4-character sequence \verb|<0a>| which matches the atom pattern
\begin{center}
\verb|"<0<hex-digit>>"|
\end{center}
where \verb|<hex-digit>| names a character pattern matching characters
in the ranges \verb|0-9|, \verb|a-f|, and \verb|A-F|.

The atom patterns of a single lexical table must not conflict:
no character string can be recognized by two atom patterns of the
same lexical table.  However, a shorter atom pattern in a
table may match the initial segment of an atom matched by a longer
atom pattern in the table, in which case the longer pattern is
used for the atom.

The scanner operates by identifying the
longest sequence of characters beginning at the current input character
stream point that matches an atom pattern of the current lexical table.
This sequence of characters becomes
the next atom, and an instruction associated with its matching
atom pattern is then executed.  If no atom pattern can be matched,
the default instruction associated with the lexical table is executed instead.

A lexical table
instruction can optionally reduce the length of a matched atom
and optionally change the current lexical table.  It can also do other
things described below.

There are four kinds of lexical tables:
\mkey{master}{lexical table} tables,
\mkey{lexeme}{lexical table} tables,
\mkey{sublexeme}{lexical table} tables, and
\mkey{atom}{lexical table} tables.
Master tables are used to dispatch to lexeme or sublexeme tables which
typically recognize lexemes.  Atom tables are used
to recognize atoms whose patterns are logically the union
of a finite set of patterns.

Thus a simple scanner might have
one master table that dispatches to different lexeme tables,
one to recognize identifiers, one to recognize numbers, one to
recognize whitespace, and one to recognize comments.

Lexeme tables have \ikey{types}{type!of lexeme table}.
When the current lexical table becomes a lexeme table,
the current lexeme type is set equal to the type of that table.
The `{\tt output} {\em type}' and `{\tt output none}'
instruction components can also be
used to change the current lexeme type.

Sublexeme tables are just like lexeme tables except they
have no associated type and do not reset the current lexeme type.

Upon finishing the execution of an instruction, if the
current lexical table is a master table,
the currently accumulated lexeme is output
with the current lexeme type, if that is not `{\tt none}', or the
currently accumulated lexeme is discarded if the current lexeme
type is `{\tt none}'.
The current lexeme type is reset to `{\tt none}' whenever
the current lexical table becomes a master table.

Thus if an lexical table of
type `\verb|whitespace|' cannot recognized any atom and
the default instruction associated with it
changes the current lexical table to a master table,
the lexeme accumulated so far will
be output as a lexeme of type `\verb|whitespace|'.

When it is between lexemes the current lexical table in the scanner state
is always a master table.  Master tables correspond to lexical
contexts.  A well designed language has only one main master
table, plus a few small master tables to handle error situations
such a premature new-line and premature end-of-file;
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.
Legacy languages
may have more master tables: C/C++ has several to handle
special lexical scanning of preprocessing lexemes;
see Appendix \itemref{C++-LEXICAL-PROGRAM}.

The standard scanner can report errors in one of two ways.  It may
simply output a lexeme with a type that indicates an error.  For
example, the character \verb|\| appearing outside a quoted string
might be returned as a 1-character lexeme of type `{\tt unrecognized
character}'.  Alternatively a single atom may be reported as an
error of a given type without interrupting the normal operation
of the scanner.  For example, if \verb|<H>| appears in a quoted
string, it may be reported as an erroneous atom of type
`{\tt unrecognized escape sequence}'.  Otherwise this atom will be processed
normally; it might, for example, be omitted from the lexeme
translation or be represented in that translation by the DEL
character (hex code \verb|7f|).

\ikey{Instructions}{instruction!in lexical program}
that are associated with atom patterns contain optional instruction
components that can do the following:
\begin{itemize}
\raggedright
\item invoke an atom table to replace the matched atom and translate it
\item reduce the length of the matched atom
\item translate the reduced length atom to a different character string
(otherwise the translation of an atom is a copy of the atom)
\item make instruction success conditional
      on the translated atom matching an atom pattern
\item announce the reduced length atom as an erroneous atom of a given type
\item change the current lexeme type
\item change the current lexical table
\item force the instruction containing atom table to fail to match any atom
\end{itemize}

An instruction can fail while invoking an atom table or making
a translation of the atom or if the translation does not match
an atom pattern.  An \key{instruction group} is a sequence of instructions
such that the first successful instruction will be the effective
instruction in the group.

Details and examples are given in the next section.


\subsection{Lexical Programs}

A \key{lexical program} is a set of character pattern definitions
and lexical tables.  A lexical program can include another lexical program.
The top level lexical program must begin with a master
table that serves as the initial lexical table.

The lexemes in a lexical program are specified on
\pagref{LEXEME-PROGRAM-LEXEMES}.

Consecutive quoted string lexemes are glued together if they are in the
same (possibly continued) line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence"
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line boundaries.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \verb|"<" "LF" ">"| is
\underline{not} equivalent to \verb|"<LF>"|.  The former is a 4-character
quoted string, the characters being \verb|<|, \verb|L|, \verb|F|,
and \verb|>|.  The latter is a 1-character quoted string, the character
being a line feed.

The special {\em character-representatives} generally consist of
the ASCII character name surrounded by angle brackets.  Examples are
\verb|<NUL>|, \verb|<LF>|, \verb|<SP>|.  There are two other cases:
\verb|<Q>| represents the doublequote \verb|"|, and \verb|<NL>| (new line)
represents a line feed (same as \verb|<LF>|).

\begin{figure*}[!p]
\begin{tabular}{p{2.2in}rl}
\emkey{lexeme} & ::= & {\em symbol} $|$ {\em non-natural-number}
                                    $|$ {\em quoted-string}
\\[0.5ex]
\emkey{symbol} & ::= & {\em word} $|$ {\em mark} $|$ {\em separator}
	         $|$ {\em natural-number}
\\[0.5ex]
\emkey{word} & ::= & {\em word-character} {\em word-character}\,$^\star$ 
\\[0.5ex]
\emkey{mark} & ::= & {\em mark-character} {\em mark-character}\,$^\star$
\\[0.5ex]
\emkey{number} & ::= &
        {\em number-character} {\em number-character}\,$^\star$
\\[0.5ex]
\emkey{natural-number} & ::= & {\em digit} {\em digit}\,$^\star$
\\[0.5ex]
\emkey{quoted-string} & ::= &
    \verb|"| {\em character-representative}\,$^\star$ \verb|"|
\\[0.5ex]
\emkey{separator} & ::= & {\em separator-character}
\\[0.5ex]
\emkey{white-space} & ::= & {\em white-space-character}
                            {\em white-space-character}\,$^\star$
\\[2ex]
\emkey{word-character} & ::= & {\em letter} \\
		       & $|$ & \verb|'| followed by a letter \\
\emkey{letter} & ::= & {\em lower-case-letter} $|$ {\em upper-case-letter} \\
\emkey{lower-case-letter} & ::= &
                               \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\
\emkey{upper-case-letter} & ::= &
                               \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
\\[0.5ex]
\emkey{mark-character} & ::= &
                                \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|:| \\
		     & $|$ & \verb|.| not followed by a {\em digit} \\
		     & $|$ & \verb|/| not surrounded by {\em digits}
\\[0.5ex]
\emkey{separator-character} & ::= &
		        \verb|(|
	       	    $|$ \verb|)|
	       	    $|$ \verb|[|
	       	    $|$ \verb|]|
	       	    $|$ \verb|{|
	       	    $|$ \verb|}|
	       	    $|$ \verb|;|
	       	    $|$ \verb|`| \\
		& $|$ & \verb|,| not surrounded by {\em digits} \\
		& $|$ & \verb|'| not followed by a letter 
\\[0.5ex]
\emkey{number-character} & ::= & {\em digit} \\
		& $|$ & \verb|.| followed by by a {\em digit } \\
		& $|$ & \verb|,| surrounded by {\em digits} \\
		& $|$ & \verb|/| surrounded by {\em digits} \\
\emkey{digit} & ::= &
                   \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9| 
\\[2.0ex]
\emkey{character-representative}
    & ::= & {\em graphic-character} \\
    & $|$ & {\tt <}{\em upper-case-letter}$^+$%
	    \{{\tt -}{\em upper-case-letter}$^+$\}$^\star${\tt >} \\
\emkey{graphic-character} & ::= &
    {\em non-whitespace-non-control-character} \\
\emkey{angle-brackets} & ::= & \verb|<| $|$ \verb|>|
\\[2.0ex]
\emkey{white-space-character}
    & ::= & {\em horizontal-space-character} \\
    & $|$ & {\em vertical-space-character} \\
\emkey{horizontal-space-character} & ::= &
    {\em space} $|$ {\em horizontal-tab} \\
\emkey{vertical-space-character} & ::= &
    {\em line-feed} $|$ {\em vertical-tab} $|$ {\em form-feed}
\end{tabular}
\label{LEXEME-PROGRAM-LEXEMES}
\end{figure*}

The syntax of a lexical program is specified on
\pagref{LEXEME-PROGRAM-SYNTAX-1} and
\pagref{LEXEME-PROGRAM-SYNTAX-2}.

\begin{figure*}[!p]
\begin{tabular}{l}
\emkey{name} ::= 
	\{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}$^\star$
	{\em word}
	\{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}$^\star$
\end{tabular}
\\[1ex]
\begin{tabular}{p{2.2in}rl}
\emkey{lexical-program} & ::= &
	{\tt begin} {\em program-name} {\tt lexical program;}\\
	& &  ~~~~{\em lexical-program-unit}$^\star$ \\
	& & {\tt end} {\em program-name} {\tt lexical program};
\\[1ex]
\emkey{program-name} & ::= & {\em name}
\\[1ex]
\emkey{lexical-program-unit}
	& ::= & {\em cpat-definition} \\
	& $|$ & {\em lexical-table-definition} \\
	& $|$ & {\em program-inclusion}
\\[1ex]
\emkey{program-inclusion} & ::= & {\tt include} {\em program-name}
				  {\em remove-clause}$^\star$ {\tt ;}
\\[1ex]
\emkey{remove-clause} & ::= & {\tt remove} {\em lexical-table-name} \\
                      & $|$ & {\tt remove} {\tt "}{\em cpat-name}{\tt "}
\\[1ex]
\multicolumn{3}{l}{~~~~~~Note: `{\em cpat}\,' abbreviates
                               `{\em character-pattern}\,'}
\\[1ex]
\emkey{cpat-definition} & ::= &
	{\tt "}{\em cpat-name}{\tt "} {\tt =}
		{\em cpat-expression} {\tt ;}
\\[1ex]
\emkey{cpat-name} & ::= &
	{\tt <}{\em letter}$^+$\{{\tt -}{\em letter}$^+$\}$^\star${\tt >} \\
	\multicolumn{2}{r}{but not} &
	{\tt <}{\em upper-case-letter}$^+$%
	\{{\tt -}{\em upper-case-letter}$^+$\}$^\star${\tt >} \\
\\[1ex]
\emkey{cpat-expression} & ::= &
	{\em cpat-term}
	\{ {\tt |} {\em cpat-term} \}$^\star$ \\
       & $|$ &
	{\em cpat-term}
	\{ {\tt \&} {\em cpat-term} \}$^\star$
\\[1ex]
\emkey{cpat-term} & ::= & {\em cpat-factor} $|$ \TILDE {\em cpat-factor}
\\[1ex]
\emkey{cpat-factor} & ::= & {\tt "}{\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em quotable-character}{\tt -}%
		                   {\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em cpat-name}{\tt "} \\
		    & $|$ & {\tt (} {\em cpat-expression}
		                {\tt )}
\\[1ex]
\emkey{quotable-character} & ::= & {\em character-representative}
\\[1ex]
\emkey{lexical-table-definition} & ::= &
	{\tt begin} {\em lexical-table-name}
		    {\em lexical-table-kind} {\tt table} {\tt ;} \\
	& &  ~~~~{\em lexical-table-entry}$^\star$ \\
	& &  ~~~~{\em default-instruction-group} \\
	& & {\tt end} {\em lexical-table-name}
		      {\em lexical-table-kind} {\tt table} {\tt ;}
\\[1ex]
\emkey{lexical-table-kind} & ::= &
    {\tt master} $|$ {\tt lexeme} $|$ {\tt sublexeme} $|$ {\tt atom}
\\[1ex]
\emkey{lexical-table-name} & ::=
    & {\em name} except {\tt scan error} or {\tt none}
\\[1ex]
\emkey{type} & ::= & {\em name} except {\tt scan error} or {\tt none}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-1}
\end{figure*}

\begin{figure*}[!t]
\begin{tabular}{p{2.2in}rl}
\emkey{default-instruction-group}
	& ::= &  {\em empty} $|$ {\em instruction-group}
\\[1ex]
\emkey{lexical-table-entry}
	& ::= & {\em atom-pattern} {\em instruction-group} {\tt ;} \\
	& $|$ & {\em atom-pattern} {\tt ;}
\\[1ex]
\emkey{atom-pattern} & ::= &
	{\tt "}\{{\em quotable-character}$|${\em cpat-name}\}$^+${\tt "}
\\[1ex]
\emkey{instruction-group}
	& ::= & {\em instruction}
	        \{ {\tt else} {\em instruction} \}$^\star$

\\[1ex]
\emkey{instruction} & ::= & {\em instruction-component}$^+$
\\[1ex]
\emkey{instruction-component}
	& ::= & {\tt accept} \\
	& $|$ & {\tt match} {\em atom-table-name} \\
	& $|$ & {\tt keep} {\em natural-number} \\
	& $|$ & {\tt translate to} {\em translation-string} \\
	& $|$ & {\tt translate hex}
			{\em natural-number} {\em natural-number} \\
	& $|$ & {\tt translate oct}
			{\em natural-number} {\em natural-number} \\
	& $|$ & {\tt require} {\em atom-pattern} \\
	& $|$ & {\tt error} {\em type} \\
	& $|$ & {\tt output} {\em type} \\
	& $|$ & {\tt output} {\tt none} \\
	& $|$ & {\tt goto} {\em master-table-name} \\
	& $|$ & {\tt goto} {\em lexeme-table-name} \\
	& $|$ & {\tt goto} {\em sublexeme-table-name} \\
	& $|$ & {\tt call} {\em lexeme-table-name} \\
	& $|$ & {\tt call} {\em sublexeme-table-name} \\
	& $|$ & {\tt return} \\
	& $|$ & {\tt fail} \\
\\[1ex]
\emkey{atom-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{lexeme-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{sublexeme-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{master-table-name} & ::= & {\em lexical-table-name}
\\[1ex]
\emkey{translation-string} & ::= & {\em quoted-string}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-2}
\end{figure*}

An example lexical program that recognizes
whitespace and quoted strings is given
on \pagref{EXAMPLE-LEXEME-PROGRAM}.
\verb|<LF>| is the only {\em character-representative} recognized
in quoted strings by this example.

\begin{figure*}[!p]
\addtolength{\baselineskip}{-0.4ex}
\begin{indpar}\begin{verbatim}
begin example lexical program;

"<whitespace-char>" = " " | "<LF>" | "<HT>" | "<VT>" | "<FF>";

begin main master table;
    "<whitespace-char>" goto whitespace;
    "<Q>" translate to "" goto quoted string;
    "<other>" output bad character;
    output end of file;
end main master table;

begin whitespace lexeme table;
    "<whitespace-char>" accept;
    goto main;
end whitespace lexeme table;

begin quoted string lexeme table;
    "<Q>" translate to "" goto main;
    "<LF>" keep 0 goto premature end of line;
    "<" "LF" ">" translate to "<LF>";
    "<other>" accept;
    goto premature end of file;
end quoted string lexeme table;

include premature tables;

end example lexical program;

begin premature tables lexical program;
    // Stuff to include.

begin premature end of line master table;
    "<LF>" output premature end of line
           goto main;
end premature end of line master table;

begin premature end of file master table;
    output premature end of file
           goto main;
end premature end of file master table;

end premature tables lexical program;
\end{verbatim}\end{indpar}
\label{EXAMPLE-LEXEME-PROGRAM}
\end{figure*}

A \emkey{lexical-program} consists of a sequence of units that are
{\em character-\EOL pattern-\EOL defi\-ni\-tions},
{\em lexical-\EOL table-\EOL defi\-ni\-tions},
or {\em program-inclusions}.  These respectively define character pattern sets
and lexical tables, and include lexical program units of
previously defined lexical programs.

\subsubsection{Lexical Program Inclusion}

A \emkey{program-inclusion} names a previously defined lexical program
whose units are to be included in the current lexical program
at the point of the {\em program-inclusion}.
There is a simple example of a program inclusion at the end of
the {\tt example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.
Identical definitions
may be repeated without error,
as can happen when one program includes two programs each of
which include the same third program.
A {\em program-inclusion} can have
\emsmkey{remove-clause}s{in {\em program-inclusion}}
each of which removes a named definition from the set of included
definitions.  This is the only way to resolve conflicts between
definitions.

\subsubsection{Character Pattern Definitions}

A \emkey{character-pattern-definition} (abbreviated as
\emkey{cpat-definition}) assigns a set of characters to a
{\em character-pattern-name}.  The latter is just a string of
letters and hyphens (\verb|-|) surrounded by angle brackets (\verb|< >|)
with hyphens occurring only between letters.  Examples:
\verb|<digit>| and \verb|<line-break>|.  However, a {\em character-pattern-name}
cannot contain only upper case letters, as this could conflict with
some {\em character-representative}.

The character set is denoted by a \emkey{character-pattern-expression}.
The simplest character pattern
expression is just a single {\em quotable-character} in quotes, which denotes
the character set containing only the quoted character.  Examples:
\verb|"0"| and \verb|"+"|.  The next simplest is two {\em quotable-characters}
separated by a hyphen (\verb|-|) denoting the character set consisting
of all characters in the range from the first to the second of the two
characters.  Examples: \verb|"0-9"| and \verb|"A-Z"|.  The characters
are ordered according to their 32 bit unsigned UNICODE value, and the
second of the two characters must not be smaller than the first.

A {\em quotable-character} is a representative of a single UNICODE
character that can be used inside quotes (\verb|"|).
Printable ASCII characters represent themselves.  Other characters
are represented by character sequences surrounded by the angle
brackets \verb|<| and \verb|>| (which are also the less than and
greater than signs).
For example, a line feed can be represented by any of the
following: \verb|<LF>|, \verb|<0A>|,
\verb|<00A>|, \ldots, or \verb|<00000000A>|.

A quoted {\em character-pattern-name} denotes the character set associated
with that name by a \underline{previous} {\em character-pattern-definition}.

The \verb/|/, \verb|&|, and \verb|~| operators and can be used to take
the union, intersection, and complements of character sets.  The complement
is relative to the universe of all 32 bit unsigned integer UNICODE
character codes.  Thus \verb|~ "b-y"| denotes the same character set as
\verb$"<0>-a" | "z-<0FFFFFFFF>"$.

Parentheses may be used in {\em character-pattern-expressions} as is
normal in algebraic expressions.
Note that the \verb/|/ and \verb|&| operators cannot be used together
in the same expression without intervening parentheses as neither
takes precedence over the other.  This is done to prevent ambiguity.

Some example {\em character-pattern-definitions} are:

\begin{indpar}\begin{verbatim}
"<hex-digit>" = "0-9" | "a-f" | "A-F";
"<non-line-break-char>" = ~ "<LF>" & ~ "<VT>" & ~ "<FF>";
"<quotable-char>" = "<020>-<07E>" & ~ "<Q>";
"<whitespace-char>" = " " | "<LF>" | "<VT>" | "<FF>" | "<HT>";
"<source-character>" =
    ( "<020>-<07E>" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";
\end{verbatim}\end{indpar}

\subsubsection{Lexical Tables}

A {\em lexical-table-definition} specifies a {\em lexical-table-name},
the {\em lexical-table-kind} of the table,
a set of {\em lexical-table-entries}
each containing an {\em atom-pattern} and optionally an {\em instruction},
and an optional {\em default-instruction-group} that is executed when
no atom is recognized by any of the table entries.

The {\em lexical-table-kinds} are
\mkey{master}{lexical table kind},
\mkey{lexeme}{lexical table kind},
\mkey{sublexeme}{lexical table kind}, or
\mkey{atom}{lexical table kind}.
In a master table {\em atom-patterns} are typically associated
with {\tt goto} or {\tt call} instructions
that change the current table from the
master table to a lexeme or sublexeme table.
In a lexeme or sublexeme table {\em atom-patterns}
are typically associated with {\tt accept} instructions which
accept the matched atom as part of the current lexeme.  In a lexeme
or sublexeme
table the default instruction is typically a {\tt goto} or {\tt return}
back to a
master table, and because this changes the current lexical table
to a master table, it causes any accumulated lexeme
to be output with its lexeme type being the current lexeme type
if that is not `{\tt none}', or it causes any accumulated lexeme
to be discarded if the current lexeme type is `{\tt none}'.

Atom tables permit sets of atom patterns to be used in
several places without copying all the patterns.  Details are
on \pagref{ATOM-TABLE}.

The first master table in a lexical program
becomes the current lexical table when the scanner
is initialized.  This table is typically named `{\tt main}',
as it is in the {\tt example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.

A lexical table consists of {\em lexical-table-entries}%
\emindex{lexical-table-entry} each containing an {\em atom-pattern} and
an {\em instruc\-tion-group}.  The \emkey{atom-pattern} is matched against
the remaining input characters.  The pattern consists of a sequence
of {\em quotable-characters}, each of which match only themselves,
and {\em character-pattern-names}, each of which match any character
in the named set of characters.  Thus
\begin{center}
\verb|"<0<hex-digit><hex-digit>>"|
\end{center}
matches 5-character atoms consisting of a \verb|<| followed by an
\verb|0| followed by two characters each in the character set
named by \verb|<hex-digit>| followed by a \verb|>|.
Note that each {\em atom-pattern}
only matches atoms of a particular length.


The special character pattern name
{\tt \bf \LESSTHAN other\GREATERTHAN}%
\index{other@{\tt \LESSTHAN other\GREATERTHAN}}%
\label{<OTHER>}
can be used in an atom pattern to match any character not otherwise
matched.  More specifically, in the atom pattern
\verb|"|$P$\verb|<other>|$Q$\verb|"|,
the prefix \verb|<other>| matches any characters not matched by
any other character pattern $C$ that is an some atom pattern of the form
\verb|"|$PCR$\verb|"| in the same lexical table.
There are several examples of this on \pagref{EXAMPLE-LEXEME-PROGRAM}.

There must be no sequence of characters that matches the
{\em atom-patterns} of two distinct {\em lexical-table-entries}
in the same {\em lexical-table}.  Since {\em atom-patterns} can only
match atoms of a particular length, it is permissible for
a sequence of characters that matches one pattern to have a proper
initial segment that matches another pattern; in this case the
longer pattern takes precedence.  The order of {\em lexical-table-entries}
in a {\em lexical-table} is not significant.

The atom pattern \verb|""| which would recognize zero length atoms is
\underline{not} permitted, but the {\em default-instruction-group} at the
end of the lexical table executes in the equivalent case where no atom
pattern in the table matches the remaining input.  In particular
the {\em default-instruction-group} always executes if the input has reached
an end of file.  This fact is used in both the `{\tt main master table}'
and `{\tt quoted string lexeme table}'
on \pagref{EXAMPLE-LEXEME-PROGRAM}.

\subsubsection{Lexical Instructions}

A \emkey{lexical-table-entry} contains an
{\em atom-pattern} and an optional
\emkey{instruction-group} that consists of one or more {\em instructions}
separated by {\tt else}'s.  Most {\em instruction-groups} contain just
a single {\em instruction}, so we will explain this first.
{\em Instruction-groups} with more than one instruction contain
instructions that can fail, causing
the failing instruction to become a no-operation and the
next instruction in the instruction group to be executed instead.

An \emmkey{instruction}{in lexical-table-entry} in an {\em lexical-table-entry}
specifies actions to be taken when an atom is recognized by the
{\em atom-pattern} of the entry.  The {\em instruction} consists of
a set of {\em instruction-components} each of which controls part of the
atom processing.

The {\em default-instruction-group} at the end of an lexical table behaves as
if a it was associated with the {\em atom-pattern} \verb|""|
that recognizes zero length atoms.  Note that actual {\em atom-patterns}
are not allowed to be \verb|""|.

The order of processing {\em instruction-components} in an {\em instruction}
is:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{Components that may
cause their containing instruction to fail:} \\[1ex]
~~~~~~~~ & {\tt match}, {\tt translate oct}, or {\tt translate hex} \\
~~~~~~~~ & {\tt require}
\\[2ex]
\multicolumn{2}{l}{Components that only execute if their
containing instruction does not fail:} \\[1ex]
~~~~~~~~ & {\tt keep} \\
~~~~~~~~ & {\tt translate to}\\
~~~~~~~~ & {\tt error} \\
~~~~~~~~ & {\tt output} \\
~~~~~~~~ & {\tt goto}, {\tt call}, {\tt return}, or {\tt fail} \\
\end{tabular}
\end{center}

An {\em instruction} with no {\em instruction-components} simply accepts
the matched atom and copies it into the translation.  In order to
indicate this, the instruction may be written as if it had a single
`{\tt accept}' instruction component.  If this component is present
in an {\em instruction}, no other {\em instruction-components}
may be present in the {\em instruction}.

\subsubsubsection{Match Instruction Components and Atom Tables}

The `\ttmkey{match}{in lexical program} {\em atom-table-name}'
{\em instruction-component} invokes the named
\key{atom table}\label{ATOM-TABLE}
to recognize an atom and provide its translation.
Any previously matched atom and translation are ignored, and
the atom table {\em atom-patterns} are used to rematch the current atom,
provide a translation of the atom, and determine
whether the containing {\em instruction} fails.

Atom tables match only a single atom and implicitly return
to their invoking instruction after matching one atom.  The
{\tt output}, {\tt goto}, {\tt call}, and {\tt return}
{\em instruction-components} \underline{cannot} be used in an
atom table.  However, the {\tt fail} {\em instruction-component}
can only be used in an atom table, and when executed indicates
that the atom table invoking {\em instruction} has failed, so that
{\em instruction} becomes a no-operation and the next
{\em instruction} in the invoking
{\em instruction-group} (i.e., the {\em instruction}
after the `{\tt else}' following the failed {\em instruction}) is
executed.

{\tt accept}, {\tt match}, {\tt keep}, {\tt require}, and
any of the {\tt translate} {\em instruction-components} can be used in
an atom table {\em instruction}.  An atom table
instruction may invoke another atom table, but recursion
is prohibited.

If an instruction invokes an atom table and
the atom table does not fail,
the original atom match that caused the instruction
to be executed is replaced by the atom matched by the
atom table, and the atom translation is that provided by the atom table.

An instruction that invokes an atom table fails if the atom table
fails or if the instruction has a {\tt require} component that fails
when applied to the atom translation produced by the atom table.
If the instruction fails, the
original atom match is reinstated (the instruction becomes a
no-operation) before the next {\em instruction} in the {\em instruction group}
executes.

The {\tt error} instruction component can also be used in an atom
table, but if the atom table fails, or if a subsequent {\tt require}
causes a {\tt match} that invoked the atom table to fail, the
effects of the {\tt error} instruction component will \underline{not}
be undone.  Normally the only effect is to announce an error.

Atom tables may have a {\em default-instruction-group}.
However, this only makes sense if it is just a `{\tt fail}', or
if it is contains {\tt match} components.  If an atom table
is invoked and none of its {\em atom-patterns} match an atom,
and if the table has \underline{no} {\em default-instruction-group},
then a scan error is signaled (i.e., `{\tt fail}' is \underline{not}
implicit).

\subsubsubsection{Translate Hex/Oct Instruction Components}

\hfill The {\tt translate hex/\EOL oct} \\ components are applied to a matched
atom to produce a single UNICODE character translation of the atom.

An instruction can contain at most one of the following components:
\begin{center}
\tt
match \\
translate hex \\
translate oct
\end{center}
This is because all three of these components independently produce
an atom translation.

Note that if any previous instruction in an instruction group contains
a {\tt match} component, that instruction must have failed, and the
atom as it was when the instruction group started to execute must have
been reinstated, so {\tt translate hex/oct} components are always
applied to the matched atom as it was when the containing instruction
group started to execute, before any {\tt match} components in the
group executed.

Also note that any {\tt keep} component executes \underline{after}
{\tt translate hex/oct} components, and so does not affect the
matched atom used by these components.

The `\ttmkey{translate hex}{in lexical program} $m$ $n$'
{\em instruction-component} ignores the
first $m$ and last $n$ characters of the matched atom and, viewing the rest as
hexadecimal digits, converts these into an 32 bit unsigned integer
UNICODE character code, which becomes the 1-character atom translation.
An example is the the lexical table entry
\begin{center}
\verb|"<0<hex-digit><hex-digit>>" translate hex 2 1;|
\end{center}
which might be used to accept a character representative in a quoted string
and copy the appropriate hexadecimally related character code into
the lexeme translation.  If characters that
are supposed to be hexadecimal digits are not, the {\tt translate-hex}
component fails (but in our example
this cannot happen because the definition of \verb|<hex-digit>|
restricts these characters appropriately).

The `\ttmkey{translate oct}{in lexical program} $m$ $n$'
{\em instruction-component} is identical but
views the rest of the characters as octal and not hexadecimal.
An example use would be the lexical table entry
\begin{center}
\verb|"\<oct-digit><oct-digit><oct-digit>" translate oct 1 0;|
\end{center}

\subsubsubsection{Require Instruction Components}

The `\ttmkey{require}{in lexical program} {\em atom-pattern}'
{\em instruction-component} tests whether the atom translation
matches the given {\em atom-pattern},
and if \underline{no}, causes the {\em instruction} to fail.
A {\tt require} should only appear in an
{\em instruction} which is followed by an `{\tt else}' in an
{\em instruction-group}.
A {\tt require} should only appear in an instruction that also
contains a {\tt match}, {\tt translate hex}, or {\tt translate oct}
instruction component, and is only useful for testing the
translations produced by these latter components.

An example use would be the lexical table entry
\begin{indpar}
\verb|"\u<hex-digit><hex-digit><hex-digit><hex-digit>" translate hex 2 0| \\
\verb|    require "<letter>" else| \\
\verb|    translate to "" error bad character in identifier;|
\end{indpar}
which might be used to process an atom of the form \verb|\uXXXX| in
an identifier, accepting the atom as a legitimate representation of a
character if that character is a letter, and otherwise designating
the atom as an error while not putting anything in the lexeme translation
(see below for the definition of the `{\tt error}' instruction component).

The last {\em instruction} in an {\em instruction-group} must
never fail, and so cannot contain a {\tt require} {\em instruction-component}.

\subsubsubsection{Keep Instruction Components}

The `\ttmkey{keep}{in lexical program} $n$'
{\em instruction-component} causes the atom length
to be shortened to $n$.  For example, the lexical table entry
\begin{center}
\verb|",<digit>" keep 1;|
\end{center}
will recognize a 1-character atom consisting of just a comma as long as
the comma is followed by character in the \verb|<digit>| character pattern
character set.  Atoms may not be lengthened by {\tt keep}.

A {\tt keep} component in the same instruction as a {\tt match} component
applies to the atom matched by the atom table invoked by the {\tt match}
component.

\subsubsubsection{Translate To Instruction Components}

A `\ttmkey{translate to}{in lexical program} {\em translation-string}'
{\em instruction-component}
specifies a {\em quoted-string} of characters,
the {\em translation-string},
that becomes the translation of the atom.
A {\em translation-string} may be empty, as in the lexical table entry
\begin{center}
\verb|"<Q>" translate to "" goto main;|
\end{center}
which can be used to recognize the last \verb|"| of a quoted string, avoid
copying anything into the lexeme translation, and then switch to the
`{\tt main}' lexical table.
See the example on \pagref{EXAMPLE-LEXEME-PROGRAM}.

The {\tt translate to} component is executed \underline{after}
any {\tt match}, {\tt translate hex}, or {\tt translate oct}, or
{\tt require} components are executed, and overrides the translations produced
by these components.  It is therefore possible to produce a translation,
test it with {\tt require}, and if the test is successful, override the
translation with {\tt translate to}.  An example is
\begin{center}
\begin{tabular}{l}
\verb|"<"  "<digit>" match escaped char| \\
\verb|               require "<ascii-character>"| \\
\verb|               error ascii escaped character| \\
\verb|               translate to ""| \\
\end{tabular}
\end{center}
which announces that any escape sequence producing an ASCII character
is an erroneous atom and replaces that atom by the empty translation
so it is as if the atom did not exist in the input.
One could also use `{\tt translate to "?"}' to replace the atom
by a question mark.

If an instruction does not contain any {\tt match}, {\tt translate hex},
{\tt translate oct}, or {\tt translate to} components, the translation
of an atom defaults to a copy of the atom itself, \underline{after}
any {\tt keep} component has been used to change the length of the atom.

\subsubsubsection{Error Instruction Component}

A `\ttmkey{error}{in lexical program} {\em type}\,' {\em instruction-component}
announces the current atom as an erroneous atom of the given {\em type}.
The atom remains part of the current lexeme,
and its translation is governed
independently by {\tt match} and translate instruction components.
The following are some examples:
\begin{indpar}\begin{verbatim}
"\<other>" error bad escape sequence;
"\<other>" translate to "" error bad escape sequence;
"\<other>" translate to "<DEL>" error bad escape sequence;
\end{verbatim}\end{indpar}
These might be entries in an lexical table for a quoted string.
All identify an atom consisting of a backslash followed by any
character that does not match any character pattern $C$ that is in
a lexical table
atom pattern of the form \verb|"\|$C$\ldots\verb|"| where $C$ is a character
pattern other than \verb|<other>| (see \pagref{<OTHER>}).
The first entry copies the entire 2-character atom, including the
backslash, into the lexeme translation.  The second entry copies
nothing (the empty string \verb|""|) into the lexeme translation.
The third entry copies the DEL character (hex code \verb|7f|)
into the lexeme translation.  An alternative is the entry
\begin{indpar}\begin{verbatim}
"\<other>" keep 1 error bad escape;
\end{verbatim}\end{indpar}
that reduces the atom size to 1 character, just the backslash,
which is announced as an error without its following character,
and copied to the lexeme translation.  The character following
the backslash remains in the input and will part of the next
atom recognized.
Another alternative is
\begin{indpar}\begin{verbatim}
"\" match bad escape translate "" error bad escape;
. . .
<any> = <0-<0FFFFFFFF>>;      // Matches any character.
begin bad escape atom table;
"\<any><any><any>"
end bad escape atom table;
\end{verbatim}\end{indpar}
in which the lexical table entry will be invoked if the next character
in the input is \verb|\| and no longer
lexical table atom pattern of the form \verb|"\|\ldots\verb|"| is matched, 
and as a result the \verb|\| and the next three characters will be identified
as a `{\tt bad escape}'
erroneous atom and translated to the empty character sequence.


The routine that announces an error atom is given the position
of the atom in the input stream, so characters surrounding the
atom may also be included in the announcement.  For example,
the line containing the atom may be printed with marks under the
characters of the atom.  So the fact that the erroneous atom
proper in the last example might be just the backslash does not
prevent the characters after the backslash from being included
in the error announcement.

An erroneous atom is different from an erroneous lexeme.
An erroneous lexeme is simply a lexeme whose {\em type}
indicates to the user of the lexical scanner that the lexeme is erroneous.
As such an erroneous lexeme is
handled by the lexical scanner just as any other lexeme would be:
i.e., the lexical scanner has no special knowledge of erroneous lexemes
and no special operations for detecting or announcing them.

\subsubsubsection{Output Instruction Component}

\hfill A `\ttmkey{output}{in lexical program} {\em type}\,'
{\em instruction-component} sets the \key{current lexeme type}.

The {\tt output} {\em instruction-component} is
used to change the type of the lexeme to be output from
the type of the table containing the instruction.
For example, at the top of \pagref{EXAMPLE-LEXEME-PROGRAM} the
{\tt main} master table has `{\tt output end of file;}' as its
{\em default-instruction-group}, thereby outputting a zero length
lexeme with `{\tt end of file}' type whenever the input is at the
end of file.

As another example, the `{\tt main}' master table at the top of
\pagref{EXAMPLE-LEXEME-PROGRAM} contains the entry:
\begin{indpar}\begin{verbatim}
"<other>" output bad character;
\end{verbatim}\end{indpar}
which causes an unrecognized character to be treated as a 1-character
lexeme of type `{\tt bad character}'.  The translation of this lexeme is
the character itself, but if the entry:
\begin{indpar}\begin{verbatim}
"<other>" translate to "<DEL>" output bad character;
\end{verbatim}\end{indpar}
had been used instead the translation would have been the ASCII delete
(DEL) character.

Upon finishing the execution of an instruction, if the
current lexical table is a master table,
the currently accumulated lexeme is output
with the current lexeme type, if that is not `{\tt none}', or the
currently accumulated lexeme is discarded if the current lexeme
type is `{\tt none}'.
The current lexeme type is reset to `{\tt none}' whenever
the current lexical table becomes a master table.

\subsubsubsection{Goto, Call, Return, and Fail Instruction Components}

A `\ttmkey{goto}{in lexical program} {\em lexical-table-name}\,'
{\em instruction-component} switches the current lexical table after
the current atom is processed.  If the table switches
to a master table and the current lexeme type is not `{\tt none}',
then the current lexeme is output with the
current lexeme type as its type.

A `\ttmkey{call}{in lexical program} {\em lexeme-table-name}\,'
{\em instruction-component} is just like `{\tt goto}' except
that it also pushes the identifier of the lexical table in which
the `{\tt call}' occurs (the `caller') into the return stack.
The \key{return stack} is a stack of up to 16 lexical table identifiers
used by the `{\tt call}' and `{\tt return}' instruction components
and also by the `{\tt match} {\em atom-table-name}'
instruction components.  Recursive calls are prohibited.
Whenever a master table becomes the current lexical table, the
return stack is cleared.

A `\ttmkey{return}{in lexical program}'
{\em instruction-component} is just like `{\tt goto}' except
that uses the lexical table identifier at the top of the return
stack to determine the next lexical table.  This identifier is
also popped from the stack.

The return stack is set to empty whenever the current lexical table
becomes a master table.
A {\tt call} \underline{cannot} be used
to call a master or atom table.  A {\tt return} can only
appear in a lexeme or sublexeme table.
A {\tt goto} \underline{cannot} be used to go to an atom table.

The `{\tt call}' and `{\tt goto}' instruction components
can both be used in the same {\em instruction}, in 
which case the {\tt goto} lexical table identifier is pushed into the
return stack instead of the current lexical table identifier.
The `{\tt return}' instruction component cannot be used with
`{\tt call}' or `{\tt goto}' (if `{\tt return}' and `{\tt call}'
could be used together, they would have the same affect as
a simple `{\tt goto}')

The `{\tt call}' and `{\tt return}' instruction components
permit a lexeme or sublexeme table to be shared among different
master, lexeme, and sublexeme tables.  For example, a lexeme table to scan
a comment lexeme may be shared among several master tables;
see Appendix \itemref{C++-LEXICAL-PROGRAM} for examples.

The `{\tt call}' and `{\tt return}' instruction components
add nothing new to the lexical scanning language, since they
cannot be used recursively,
and they can always be eliminated by making
copies of the called tables with hard coded returns.
But for certain languages these instruction components
substantially reduce the size of the lexical program.

A `\ttmkey{fail}{in lexical program}'
{\em instruction-component} can only be used in an atom
table and causes the instruction invoking the atom table to fail.
The `{\tt goto}', `{\tt call}', and `{\tt return}' instruction components
\underline{cannot} be used in an atom table.

\section{Parsing}

The layered languages parser attempts to promote human efficiency
both by standardizing many aspects of syntax and my permitting
substantial additions to syntax.  Humans reason
syntactically, and therefore new types of data and algorithm often
need to be supported by new syntax.  But this new syntax needs to
integrate with the old syntax, so the goal of the parser is to make
possible syntactic additions that integrate well with existing syntax.

The parser is a sequence of passes each of which operates on a list
of tokens.  A token is either a lexeme, a subexpression, or an operator.
The top level parser pass, the bracketed subexpression recognition pass,
recognizes subexpressions that are bounded by brackets
such as `{\tt (}' and `{\tt )}', by an indentation mark and eventual
end of indentation, by a line end, or by a line separator that is
equivalent to a line end.
The non-top-level passes
operate on the subexpressions recognized by previous passes;
for example, the operator pass recognizes
subexpressions bounded by operators.
Brackets can be used to change syntax, so, for example,
the syntax of a {\tt ( )} bracketed expression may differ from
the syntax of a {\tt ` '} bracketed expression.

Parsing reduces each recognized subexpression, including each input
line and each paragraph,
to a single expression token.  Here indentation is used to continue
lines and paragraphs.

\subsection{Tokens}

A token has the following components:

\begin{indpar}
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{type}{of token}
		& One of: \hspace{0.5in}\begin{tabular}[t]{l}
        	          A lexeme type. \\
        	          \ttmnbkey{OPERATOR}{token type} \\
        	          \ttmnbkey{BRACKETED}{token type} \\
        	          \ttmnbkey{BRACKETABLE}{token type} \\[1ex]
			  \end{tabular}
\\[1ex]
		& For a lexeme, the translation of the
		  lexeme may be recorded in either the token
		  {\tt value} as a MIN string or in the token {\tt string}.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& Standardly the token lexeme types are word, mark, separator,
		  and number which have token {\tt value}s that are
		  MIN strings equal to the lexeme characters,
		  quoted string which has token {\tt string}s equal
		  to the lexeme translation string,
		  and line break and end of file which have neither
		  {\tt value} nor {\tt string}.
		  Both natural numbers and other numbers are grouped
		  together as numbers.
		  Standardly whitespace and comment lexemes are
		  not translated into tokens, and error lexemes are
		  announced when input but not translated into tokens.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& For an {\tt OPERATOR}, the token {\tt value}
		  is the operator name recorded as
		  a MIN string or a MIN label, or in the case
		  where a bracketed subexpression is an operator,
		  the {\tt value} is the MIN object as described
		  for {\tt BRACKETED} tokens below.
		  {\tt OPERATOR} tokens are
		  produced inside the operator pass and consumed by
		  expression reformatters invoked by that pass.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& For a {\tt BRACKETED} subexpression, the token {\tt value}
		  is a MIN object which may have
		  attributes such as {\tt .initiator} or {\tt .terminator}.
		  The following attributes of a {\tt BRACKETED} token
		  {\tt value} are directly related to syntax and are called 
		  `\key{syntax attribute}s':
		  \begin{center}
		  \tt
		  \begin{tabular}{l}
		  .initiator \\
		  .terminator \\
		  .separator \\
		  .middle \\
		  .name \\
		  .arguments \\
		  .keys \\
		  \end{tabular}
		  \end{center}
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& A {\tt BRACKETABLE} token
		  is equivalent to (and an optimization of) a {\tt BRACKETED}
		  token whose MIN object value has no syntax attributes other
		  than the {\tt .separator} attribute.  If such a token
		  is to become the only element of a containing {\tt BRACKETED}
		  token subexpression, instead of creating a new
		  {\tt BRACKETED} token, its attributes are added to
		  the {\tt BRACKETABLE} token, and the type of that
		  token is then
		  changed to {\tt BRACKETED}.  When this is done the
		  {\tt .position} attribute is also changed to include
		  the added syntax attributes.  Other non-syntax
		  attributes are inherited from the {\tt BRACKATABLE} token.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& Empty subexpressions are recorded as {\tt BRACKETABLE}
		  subexpressions whose MIN object has no elements and
		  no syntax attri\-butes.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{value}{of token}
		& The token {\tt value}, as described above.  This is
		  MIN string, label, or object.  Numbers are encoded
		  as MIN strings, so {\tt 001}, {\tt 01}, and {\tt 1}
		  are all distinct, as are {\tt 0.10}, {\tt 0.1},
		  and {\tt .10}.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{string}{of token}
		& For quoted string lexemes,
		  which do not have token {\tt value}'s,
                  this is the translation string of the lexeme,
		  stored in a manner that makes
		  garbage collection and memory reuse more
		  efficient than it would be if MIN strings
		  were used, but makes lookup less efficient.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{position}{of token}
		& The positions in the input file of
                  the first character of the token
		  and the first character after the token in the
		  input text.  A character position records a line number
		  and the byte offset within a UTF-8 encoding
		  of the line.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{indent}{of token}
	        & The indentation of the token from the beginning
                  of the line, for the first token of a line only.
		  Calculated assuming a single space character is
		  1 column and horizontal tabs are every 8 columns.
		  A special missing value if the token is not the
		  first token on a line.
		\\[1ex]
		& Used by the bracketed subexpression recognizer
		  to recognize indentation.
\end{tabular}
\end{indpar}

Tokens are organized in a doubly threaded list.  A file is translated into
such a list that ends with a token containing an end-of-file
lexeme.
The tokens of a file are not read in all at once, but are read in as
needed.

As the parser identifies subexpressions, the tokens in the
subexpression are replaced by a single {\tt BRACKETED} or {\tt BRACKETABLE}
token which encodes the subexpression.
File input lines may also be organized into paragraphs containing
paragraph lines, and both paragraph lines and paragraphs are
treated as subexpressions.  Although at the top level an entire
input file can be considered to be a paragraph, the parser \underline{never}
forms a single token that would represent it, but instead
delivers top level paragraph line tokens one at a time for subsequent
processing.  These top level paragraph line tokens are placed at the
beginning of the token stream, and as they are never again accessed
by the parser, they may be removed from the token stream at any time
by post-parser processing.

\subsection{Parser Symbol Table}

Sequences of lexemes encoded as tokens are looked up in
\skey{parser symbol table}s.
A parser symbol table is conceptually a stack of
\skey{parser definition}s.

In fact, there are different
symbol tables for different parser passes, as each pass
looks up only pass specific definitions.

Each parser definition has the following
components:

\begin{indpar}
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{label}{of symbol table entry}
		& A sequence of `symbols' that identifies the definition.
\\[1ex]
		& A \key{symbol} is a MIN string equal to the
		  lexeme string of a word, mark, separator,
		  or number lexeme.  Quoted string
		  lexemes are not symbols.
\\[1ex]
		& Labels are symbol table `\skey{key}s', that is, they
		  are what is looked up in a symbol table.
\\[1ex]
		& If a label has just one symbol, it is represented by
		  a MIN string.  Otherwise it is represented by
		  a MIN label whose elements are MIN strings
		  equal to the symbols.
\\[1ex]
		& Note that numbers are represented by MIN
		  strings equal to their lexeme translation strings,
		  and are \underline{not} represented as MIN numbers.
		  As a consequence `{\tt 01}' and `{\tt 1}' are
		  different number symbols, as are `{\tt 0.10}'
		  and `{\tt .1}'.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{type}{of symbol table entry}
		& The type of the definition.  Each parser pass has
		  one (or sometimes more) symbol tables containing
		  definitions of types particular to the pass.
		  For example, the bracketed subexpression recognition
		  pass has {\tt opening bracket}, {\tt closing bracket},
		  {\tt indentation mark}, and {\tt indentation separator}
		  type definitions, among others.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{selectors}{of symbol table entry}
		& A set of \skey{parsing selector}s that determine if
		  the definition is active.  See text.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{level}{of symbol table entry}
		& Block nesting level, 0, 1, 2, \ldots, of the parser block
		  containing the definition that made this symbol
		  table entry.  When the block ends, this entry
		  will be removed from the symbol table stack.  The top level is
		  level 0, which outside all blocks.
\end{tabular}
\end{indpar}

Lookup in a parser symbol table takes as input a token sequence
that is part of a line (for the bracketed subexpression recognition pass)
or subexpression (for other passes), and finds an active symbol table
entry with a label whose symbols match an initial segment of the
token sequence.  Only symbol tokens, whose lexeme types are word,
mark, separator, or number, can match label symbols.  These are just
the token types that have values which are MIN strings equal to the
translation strings of their lexemes, and it is these values that
are matched for equality with the table entry label symbols.
When a match is found,
the initial segment of tokens used in the match is called
a `\key{matched label}\,'.

At any point the longest active match is choosen.  Entries may
not be active because they have the wrong type or wrong selectors (see below)
for the current parser pass or context.
Entries may be activated only when other entries are recognized
in the current context, as when afix operators become active
only after an associated non-afix operator is recognized in
the same subexpression (see \pagref{AFIX-OPERATOR}).

In the bracketed
subexpression recognition pass matched labels may not span line boundaries.
In later passes, line boundary tokens are no longer present, and
matched labels can span line boundaries,
but cannot cross bracketed subexpression
boundaries.

The context of a symbol table lookup includes a set of selectors.
In order to be active, a symbol table entry's set of selectors
must have some selector in common with the context set of selectors.
A selector set is represented as a 64-bit unsigned integer value
with the bit in
position 1{\tt <<}N being on if the N+1'st selector is in the set.
Thus there can be at most 64 distinct selectors used by any set of
parser definitions.  For convenience, the selectors that can be
currently used are given names that a sequences of symbols.

The context selectors may change when an explicit opening bracket
is recognized, and remain changed until the associated explicit closing
bracket is recognized.  The initial context selectors used to scan a
top level line are determined by a context key at the beginning of
the line, or by the absence of any such key.
There are no other mechanisms for setting or changing the
context selectors.

The parser symbol tables act like stacks; as new parsing
definitions are encountered, their effects are `pushed' into the
symbol tables.  These stacks can be popped, removing
the parser definitions in reverse order.  When a definition
is popped, its effects are removed from the symbol tables.
Definitions are popped by the ends of parser blocks: see
\pagref{PARSER-BLOCKS}.

It is also possible to `\mkey{undefine}{parser symbol table entry}'
parser symbol table entries by clearing some or all of their selectors.
One can also think of `undefine's as being pushed into and popped
from symbol tables,
where pushing corresponds to clearing selectors from some entries
and popping corresponds to restoring those selectors to their
previous state.

\subsection{Parser Commands}

A parser command is a top level line that changes parser tables.
The syntax of a parser commands in general and in particular those
associated parser block definition, parser testing, and selector definition
is specified on \pagref{PARSER-COMMANDS}.

\begin{boxedfigure}[!p]
\emkey{parser-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em parser-block-command} \\
    $|$ & {\em parser-test-command} \\
    $|$ & {\em parser-selector-command} \\
    $|$ & {\em parser-undefine-command} \\
    $|$ & {\em parser-bracketed-command} \\
    $|$ & {\em parser-operator-command} \\
    \end{tabular}
\label{PARSER-COMMAND}
\\[1.5ex]
\emkey{simple-name-component} ::= {\em word} $|$ {\em number}
\\[0.5ex]
\emkey{simple-name} ::= {\em simple-name-component}
                        {\em simple-name-component}\,$^\star$
\\[1.5ex]
\emkey{quoted-name-component} ::=
    {\em word} $|$ {\em mark} $|$ {\em separator} $|$ {\em number}
\\[0.5ex]
\emkey{quoted-name} ::=
    {\tt "}{\em quoted-name-component}
           {\em quoted-name-component}\,$^\star${\tt "}
\\[1.5ex]
\emkey{parser-flag} ::= {\em simple-name}
\\[0.5ex]
\emkey{parser-flag-list}
    ::= {\tt [ ]}  $|$ {\tt [} {\em parser-flag}
          \{ \verb|,| {\em parser-flag} \}\,$^\star$ {\tt ]}
\\[0.5ex]
\emkey{parser-flag-modifier-list}
    \begin{tabular}[t]{@{}r@{~}l@{~}l@{}}
    ::= & {\tt [} & {\em parser-flag-op} {\em parser-flag} \\
        &         & \{ \verb|,| {\em parser-flag-op}
	                        {\em parser-flag} \}\,$^\star$ {\tt ]} \\
    \end{tabular}
\\[0.5ex]
\emkey{parser-flag-op} ::= \verb|+| $|$ \verb|-| $|$ \verb|^|
\\[1.5ex]
\emkey{parser-block-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttikey{parser begin}{begin!parser block} {\em block-name} \\
    $|$ & \ttikey{parser end}{end!parser block} {\em block-name} \\
    $|$ & \ttikey{parser print blocks}{print!parser blocks} \\
    \end{tabular}
\label{PARSER-BLOCK-COMMAND}
\\[0.5ex]
\emkey{block-name} ::= {\em simple-name}
\\[1.5ex]
\emkey{parser-test-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttikey{parser trace}{trace!parser} {\em parser-flag-list} \\
    $|$ & \ttikey{parser trace}{trace!parser} {\em parser-flag-modifier-list} \\
    $|$ & \ttikey{parser print trace}{trace!parser print} \\
    $|$ & \ttikey{parser test}{test!parser} \ldots \\
    \end{tabular}
\label{PARSER-TEST-COMMAND}
\\[1.5ex]
\emkey{parser-trace-flag} ::= see page \pageref{PARSER-TRACE-FLAGS}
\\[1.5ex]
\emkey{parser-selector-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttikey{parser define selector}{selector!define} {\em selector} \\
    $|$ & \ttikey{parser print selectors}{selector!print} \\
    \end{tabular}
\label{PARSER-SELECTOR-COMMAND}
\\[0.5ex]
\emkey{selector} ::= {\em parser-flag}
\\[0.5ex]
\emkey{selectors} ::= {\em parser-flag-list}

\bigskip

\centerline{\bf Parser Command Syntax}

\label{PARSER-COMMANDS}
\end{boxedfigure}

A parser command is a top level input line by itself, and is
executed by the parser itself after the command is read,
thus affecting subsequent parsing.  Parser commands are
themselves parsed before they are executed.

Parser commands begin with the word `\ttmkey{parser}{in parser command}'.
Parser commands make use of {\em simple-names} that are just
sequences of {\em word} and {\em number} lexemes, and
{\em quoted-names}, that are arbitrary sequences of {\em word},
{\em mark}, {\em separator}, and {\em number} lexemes enclosed
in quotation marks to form a {\em quoted-string} lexeme.
This embedding of lexemes in a {\em quoted-string} lexeme
serves to keep the embedded lexemes from being given a special
interpretation by the parser when the parser command is parsed.

Parser commands may be organized into \skey{parser-block}s of the form:%
\label{PARSER-BLOCKS}
\begin{center}
\begin{tabular}{l}
\ttmkey{parser begin}{block} {\em block-name} \\
{\em parser-command} \\
.~.~.~.~.~.~.~.~.~. \\
\ttmkey{parser end}{block} {\em block-name} \\
\end{tabular}
\end{center}

When a parser block ends, all changes to the parser tables made in
the block are erased, so subsequent parsing is as if the block
had never existed.
The {\em block-name} merely serves as an error check; it is
not possible to have one `{\tt parser end}' command end more than
one parser block.

The parser has two sets of \emkey{parser-flags}\index{flags!parser}:
the parser trace flags and the
selectors.  Each set has up to 64 named flags.  A set of parser flags can be
specified by giving a {\em parser-flag-list} or a
{\em parser-flag-modifier-list}.

When a \emkey{parser-flag-modifier-list}\label{FLAG-MODIFIER-LIST}
is used, the flag set is made by modifying the current
flag set (trace flags or selectors) according to the
instructions `{\em parser-flag-op} {\em parser-flag}' pairs.
These pairs are interpreted as follows:
\begin{center}
\begin{tabular}{ll}
{\tt +} {\em parser-flag} & set the named flag \\
{\tt -} {\em parser-flag} & clear the named flag \\
\CIRCUMFLEX {\em parser-flag} & complement (flip) the named flag \\
\end{tabular}
\end{center}

In either the case of a {\em parser-flag-list} or
{\em parser-flag-modifier-list} no flag may be named more than once.
 
The current set of
\skey{parser trace flag}s\index{trace flag!parser}\index{flag!parser trace}
may be given or modified by the `\ttkey{parser trace}' command.
The trace flags cause trace printouts to the printer the parser uses
for error messages.  The trace flag names are builtin and are listed
in on page \pageref{PARSER-TRACE-FLAGS}.

The `\ttkey{parser print trace}' command prints the current set of
parser trace flags.

\begin{boxedfigure}[!p]

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttmkey{parser input}{parser trace flag} ~
    When the parser reads a token from the input,
    a description of the token is printed.

\hspace*{-0.2in}\ttmkey{parser output}{parser trace flag}
    When the parser produces a output line token, the token value
    is printed.

\hspace*{-0.2in}\ttmkey{parser commands}{parser trace flag}
    Upon successfully finishing the execution of a parser command,
    the command is printed (if the command is in error the error
    printout will print the command).

\hspace*{-0.2in}\ttmkey{bracketed subexpressions}{parser trace flag}
    Enables tracing for the parser bracketed subexpression recognition pass.

\hspace*{-0.2in}\ttmkey{operator subexpressions}{parser trace flag}
    Enables tracing for the parser operator recognition pass.

\hspace*{-0.2in}\ttmkey{subexpression lines}{parser trace flag}
    The printing of a value by the `{\tt parser output}' or
    `\ldots{} {\tt subexpressions}' trace flags, or the
    {\tt parser test} command, includes
    the lines containing the value with the value producing subexpression
    within these lines underlined.

\hspace*{-0.2in}\ttmkey{subexpression elements}{parser trace flag}
    The printing of a value by the `{\tt parser output}' or
    `\ldots{} {\tt subexpressions}' trace flags, or the
    {\tt parser test} command, includes
    a direct rendition of the value with implicit brackets and
    graphic representations of non-graphic characters
    shown.  This is the default.

\hspace*{-0.2in}\ttmkey{subexpression details}{parser trace flag}
    The printing of a value by the `{\tt parser output}' or
    `\ldots{} {\tt subexpressions}' trace flags, or the
    {\tt parser test} command, includes
    a detailed rendition of the value with all attributes shown.

\hspace*{-0.2in}\ttmkey{keys}{parser trace flag}
    During execution of a subexpression by a trace-enabled parser 
    pass, the keys found in the pass symbol tables are printed.
    If a key is rejected after being found, a rejection message
    is also printed.

\end{indpar}

\bigskip

\centerline{\bf Parser Trace Flags}
\label{PARSER-TRACE-FLAGS}
\end{boxedfigure}

The `\ttkey{parser test}' command just causes the parse of itself
to be printed in detail.  Since parser commands are parsed before they
are executed, any text placed after the words `{\tt parser test}' will
be parsed and the resulting printout will indicate the details of that
parse.

Selector names (unlike trace flag names) are \underline{not} buitin,
and must be defined by the
`\ttikey{parser define selector}{selector!parser define}'
command.  When the parser block containing a selector name definition
command ends, the selector name is erased.
There may be at most 64 selectors defined at any one time.
The current selector names can be printed by using
the `\ttikey{parser print selectors}{selector!parser print}'
command.

In the following sections various `\ttkey{parser define}' commands
are described.  These push entries in to the parser symbol tables.
The general syntax of these is
\begin{center}
{\tt parser define} {\em type} {\em name} {\em selectors} \ldots 
\end{center}
and an example is
\begin{center}
{\tt parser define bracket "("~...~")" [operator, text]} \ldots
\end{center}
The {\em type}, `{\tt bracket}' in the example, identifies the parser pass into
whose symbol tables entries are to be pushed.  The {\em name},
`{\tt "("~...~")"}' in the example, gives {\em quoted-names} that become
the entry labels.  The {\em selectors},
`{\tt [operator, text]}' in the example, specify the selector set of
the entries to be pushed.

The end of a parser block pops all entries pushed into parser
symbol tables during the block.

The `\ttkey{parser undefine}' command effectively undoes
{\tt parser define} commands by clearing selector bits in
the designated symbol table entries.  Its syntax is
\begin{center}
{\tt parser undefine} {\em type} {\em name} {\em selectors}
\end{center}
and it clears the specified selector bits from \underline{all} symbol table
entries with the same {\em type} and {\em name}.  When the
block containing a {\tt parser undefine} command ends, the
effects of that command are undone by restoring the cleared
selector bits to their previous state.

\subsection{The Bracketed Subexpression Recognition Pass}

The bracketed subexpression recognition pass recognizes:
\begin{indpar}[1.0in]
\hspace*{-0.5in}brackets (e.g.~`{\tt (}' and `{\tt )}')
    and bracketed subexpressions \\
\hspace*{-0.5in}indentation marks (e.g.~`{\tt :}')
    and line separators (e.g.~`{\tt ;}'),
    indented paragraphs, and indented paragraph lines \\
\hspace*{-0.5in}named brackets (e.g.~`{\tt <b|}' and `{\tt |b>}')
      and named bracketed subexpressions \\
\hspace*{-0.5in}named operators (e.g.~`{\tt <p>}')
\end{indpar}

The bracketed subexpression recognition pass also merges
consecutive quoted strings if they are on the same
(possibly continued) line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence"
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line boundaries.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \verb|"<" "LF" ">"| is
\underline{not} equivalent to \verb|"<LF>"|.  The former is a 4-character
quoted string, the characters being \verb|<|, \verb|L|, \verb|F|,
and \verb|>|.  The latter is a 1-character quoted string, the character
being a line feed.

Brackets, indentation marks, and line separators are
symbol table keys.  However named brackets and named operators are
not.  Instead, a named bracket or named operator is formed by using
named openings (e.g.~`{\tt <}'),
named key separators (e.g.~`{\tt \#}'),
named middles (e.g.~`{\tt |}'),
and named closings (e.g.~`{\tt >}'), which are all symbol table
keys, to surround or separate
sequences of words, numbers, quoted strings, and
(unnamed) bracketed subexpressions, and thence form named brackets
and named operators.

In bracketed subexpression recognition, 
multi-lexeme symbol table keys are not recognized in the
input if their lexemes are not all on the same line.
This is different from other parser passes, which are executed
after line breaks have been removed.

The output of the parser is a sequence of {\tt BRACKETED} tokens,
one per top level line.  The value of one of these tokens is a
MIN object with a {\tt .terminator} equal to the MIN string
{\tt "<NL>"} or {\tt ";"} (this is the line separator at the top level),
and with no other syntax attributes.

In general, the bracketed subexpression recognizer converts
subexpressions to single {\tt BRACK\-ET\-ED} tokens whose {\tt value}'s
are MIN objects with
either an {\tt .initiator} attribute or
a {\tt .terminator} attribute or both.
The elements of one of these MIN objects
are the {\tt value}'s of the tokens which make
up the represented
subexpression after recursive calls to the bracketed subexpression
recognizer.  Quoted string lexemes must be handled
differently because they have no token {\tt value}.  These are
represented by MIN objects
that have the {\tt .initiator} attribute {\tt "<Q>"}
and that have a single
element which is a MIN string equal as a character string to the
{\tt string} of the quoted string token being represented.

For example, the line
\begin{indpar}\begin{verbatim}
parser test (x 5 "foo")
\end{verbatim}\end{indpar}
causes the parser to output a {\tt BRACKETED} token whose {\tt value} is
\begin{indpar}\begin{verbatim}
{| parser test
   {| x 5 {| foo; .initiator = "<Q>"|};
      .initiator = "("; .terminator = ")" |};
   .terminator = "<NL>"
|}
\end{verbatim}\end{indpar}
where a MIN object is represented by
\begin{center}
\verb/{|/ {\em element} \ldots{\tt ;} {\em attribute-name} {\tt =}
				      {\em attribute-value}{\tt ;}
				      \ldots \verb/|}/
\end{center}

and a MIN string is represented by its character sequence, optionally
quoted with {\tt "}'s.

The MIN object that is the value of a {\tt BRACKETED} token and
represents a subexpression may have the following `\skey{syntax attribute}s':

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttdmkey{initiator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals
    \begin{center}
    \begin{tabular}{ll}
       & the {\em opening-bracket-name} of a bracketed subexpression, \\
    or & the {\em indentation-mark-name} of an indented subexpression, \\
    or & the {\em named-opening} of a named bracketed subexpression, \\
    or & the {\em named-opening} of a named operator, \\
    or & \verb|"<Q>"| if the MIN object represents a quoted string lexeme.
    \end{tabular}
    \end{center}
\medskip
\hspace*{-0.2in}\ttdmkey{terminator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals
    \begin{center}
    \begin{tabular}{ll}
       & the {\em closing-bracket-name} of a bracketed subexpression, \\
    or & \verb|"<NL>"| if the subexpression is an new-line terminated
         indented line \\
       & in an indented paragraph, \\
    or & the {\em line-separator-name} used to separate lines of an
         indented paragraph, \\
    or & the {\em named-closing} of a named bracketed subexpression, \\
    or & the {\em named-closing} of a named operator. \\
    \end{tabular}
    \end{center}
\medskip
\hspace*{-0.2in}\ttdmkey{separator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals an operator, such as `{\tt ,}' that acts as a
    separator in a subexpression.
\\[2ex]
\hspace*{-0.2in}\ttdmkey{middle}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals the {\em named-middle} of a named bracketed subexpression.
\\[2ex]
\hspace*{-0.2in}\ttdmkey{name}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals the {\em bracket-name} of a named bracketed subexpression
    or the {\em operator-name} of a {\em named-operator}.
\\[2ex]
\hspace*{-0.2in}\ttdmkey{arguments}{subexpression attribute}\\
    A MIN object whose elements are the arguments of the
    {\em opening-named-bracket} of a named bracketed subexpression,
    or of a {\em named-operator}.  The object is formatted like the
    {\tt value} of a {\tt BRACkETED} token, except that it has no syntax
    attributes.  Each argument is either a bracketed subexpression
    or a quoted string.
\\[2ex]
\hspace*{-0.2in}\ttdmkey{keys}{subexpression attribute}\\
    A MIN object whose elements are the keys of the
    {\em opening-named-bracket} of a named bracketed subexpression,
    or of a {\em named-operator}.  The keys are the elements of
    the object, and the object's only syntax attributes are
    {\tt .initiator} and {\tt .separator} both of which equal the
    {\em named-key-separator} of the {\em opening-named-bracket}
    or {\em named-operator}.
    The keys and attributes
    are all either MIN strings or MIN labels with MIN string
    elements.

\end{indpar}

In addition to the attributes just given, a MIN object may have
a \ttdmkey{position}{of MIN object} attribute that is a
{\tt min::\EOL phrase\_\EOL position\_\EOL vec} giving the positions
of the lexemes which the MIN object and its elements represent.
This is not considered to be a syntax attribute.

The parser commands specific to the bracketed subexpression recognizer
are further divided into those specific to the different kinds of subexpression
recognized by this recognizer:

\begin{indpar}[0.1in]
\emkey{parser-bracketed-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em parser-bracket-command} \\
    $|$ & {\em parser-indentation-mark-command} \\
    $|$ & {\em parser-named-bracket-command} \\
    \end{tabular}
\label{PARSER-BRACKETED-COMMAND}
\end{indpar}

The following subsections describe these different kinds of commands
and the subexpressions they control.

\subsubsection{Bracketed Subexpressions}

A \key{bracketed subexpression}\index{bracketed subexpression!unnamed}
begins with
an {\em opening-bracket-name} and ends with a match\-ed
{\em closing-bracket-name} as defined by a
\ttikey{parser define bracket}{bracket!parser define}
command.  An example of such a definition is
\begin{center}
{\tt parser define bracket "("~...~")" [operator, text]} \ldots
\end{center}
which specifies `{\tt (}' to be an {\em opening-bracket-name}
with `{\tt )}' as its corresponding {\em closing-bracket-name}
and `{\tt operator}' and `{\tt text}' as the definition selectors.

The general syntax of {\em parser-bracket-commands} is:

\begin{indpar}[0.1in]
\emkey{parser-bracket-command}%
\label{PARSER-BRACKET-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rll}
    ::= & \multicolumn{2}{l}{\ttikey{parser define bracket}%
                                    {bracket!parser define}
		    {\em bracket-name} {\em selectors}} \\
	& \hspace*{3em} & [ {\tt with parsing selectors}
	                    {\em new-selectors} ] \\
        &               & [ {\tt with full lines} ] \\
    $|$ & \multicolumn{2}{l}{\ttikey{parser undefine bracket}%
                                    {bracket!parser undefine}
		    {\em bracket-name} {\em selectors}} \\
    \end{tabular}
\\[0.5ex]
\emkey{bracket-name} ::= {\em opening-bracket-name}
			 \ttmkey{...}{in {\em bracket-name}}
			 {\em closing-bracket-name}
\label{BRACKET-NAME}
\\[0.5ex]
\emkey{opening-bracket-name} ::= {\em quoted-name}
\\[0.5ex]
\emkey{closing-bracket-name} ::= {\em quoted-name}
\\[0.5ex]
\emkey{new-selectors} ::= {\em parser-flag-modifier-list}

\end{indpar}

Brackets such as `{\tt (}' and `{\tt )}'
are sometimes called `\key{unnamed brackets}'
to distinguish them from named brackets
such as `\verb/<b|/' and `\verb/|b>/'
in which the name, in this case `{\tt b}',
is arbitrary.  See Section~\itemref{NAMED-BRACKETED-SUBEXPRESSIONS}
for a description of named brackets.

A bracketed subexpression is converted to a {\tt BRACKETED}
token whose {\tt value} is a
MIN object whose list elements are the components of the
subexpression except for the brackets.  The
{\em opening-bracket-name} becomes the {\tt .initiator}
attribute of this object, and the {\em closing-bracket-name}
becomes the {\tt .terminator} attribute of the object.

If a bracketed subexpression ends pre-maturely, before
its {\em closing-bracket-name} is discovered, a parsing error is
announced and the {\em closing-bracket-name} is inserted in the input
just after the pre-maturely ended subexpression.  Such a pre-mature end can be
discovered by finding the {\em closing-bracket-name} of a containing
bracketed subexpression, the {\em named-closing-bracket}
of a containing named bracketed subexpression, the end of the paragraph line
containing the bracketed subexpression,
or an end of file.

An exception to this is made if the bracket definition has the
\ttmkey{full lines}{in bracket definition} property.  In this case
it is expected that the subexpression will consist of one or
more full input lines.  While the subexpression is being scanned,
use of indentation is turned off, and only the {\em closing-bracket-name}
associated with the full lines {\em opening-bracket-name}, or an
end-of-file,
can terminate the subexpression.  During parsing of a
`{\tt full lines}' subexpression, the parser only knows about
subexpressions and paragraphs that are included completely inside the
`{\tt full lines}' subexpression.

When an {\em opening-bracket-name} is recognized, the current parser
selector set is saved in a stack and
a new set is computed by modifying the saved set
according to the {\em new-selectors} in the bracket definition.
The saved selector set is restored after the {\em closing-bracket}
is recognized.  However {\em closing-bracket-name}
recognition does not depend
upon the current parser selectors, but only on previous recognition
of an associated {\em opening-bracket-name}.

\subsubsection{Indented Paragraph Subexpressions}

An \key{indented paragraph subexpression}
begins with an {\em indentation-mark-name} which must be at the end of
a line.  This is followed by an \key{indented paragraph}
consisting of zero or more \skey{paragraph line}s,
each beginning at the same indentation which
is called the \key{paragraph indentation}.  The paragraph indentation
is defined as the indentation of the first paragraph line of the paragraph.
A paragraph line may have a continuation lines that are indented with
respect to the paragraph indentation.

The following is an example using `{\tt :}' as an {\em indentation-mark-name}:
\begin{indpar}\begin{verbatim}
the line before the outer paragraph
this is an outer paragraph:
    the first line of the outer paragraph
    the second line of the outer paragraph which
        is continued on this indented line
    an inner paragraph:
        the first line of the inner paragraph
        the second line of the inner paragraph which
            is continued on this indented line
    the first outer paragraph line after the inner paragraph
    another inner paragraph, but one with zero lines:
    the last line of the outer paragraph
the line after the outer paragraph
\end{verbatim}\end{indpar}


An {\em indentation-mark-name} is specified by a
\ttikey{parser define indentation mark}{indentation mark!parser define} or
\ttikey{parser define gluing indentation mark}%
       {gluing indentation mark!parser define}
parser command, and may have
an associated {\em line-separator-name} supplied by that definition.
An example is
\begin{center}
{\tt define gluing indentation mark ":"~...~";" [operator]} \ldots
\end{center}
which specifies `{\tt :}' to be a {\em gluing-indentation-mark-name}
with `{\tt ;}' as its corresponding {\em line-separator-name}
and `{\tt operator}' as the sole definition selector.

The general syntax of {\em parser-indentation-mark-commands} is:

\begin{indpar}[0.1in]
\emkey{parser-indentation-mark-command} \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttikey{parser define}{define indentation mark}
	  \begin{tabular}[t]{@{}l@{}}
	  {\tt \bf indentation mark}
	  {\em indentation-name} {\em parsing-selectors} \\
	  {}[ {\tt with parsing selectors} {\em new-selectors} ] \\
	  \end{tabular} \\
    $|$ & \ttikey{parser define}{define gluing indentation mark}
	  \begin{tabular}[t]{@{}l@{}}
	  {\tt \bf gluing indentation mark} \\
	  \hspace*{5em} {\em gluing-indentation-name} {\em parsing-selectors} \\
	  {}[ {\tt with parsing selectors} {\em new-selectors} ] \\
	  \end{tabular} \\
    $|$ & \ttikey{parser undefine indentation mark}{undefine indentation mark}
	  {\em indentation-name} {\em parsing-selectors} \\
    $|$ & \ttikey{parser undefine}{undefine gluing indentation mark}
	  \begin{tabular}[t]{@{}l@{}}
	  {\tt \bf gluing indentation mark} \\
	  {\em gluing-indentation-name} {\em parsing-selectors} \\
	  \end{tabular} \\
    $|$ & \ttikey{parser define indentation offset}{define indentation offset}
	  {\em indentation-offset}  \\
    \end{tabular}
\label{INDENTATION-MARK-DEFINITION}
\\[0.5ex]
\emkey{indentation-name} ::= {\em indentation-mark-name}
	[ {\tt ...} {\em line-separator-name} ]
\\[0.5ex]
\emkey{indentation-mark-name} ::= {\em quoted-name}
\label{INDENTATION-MARK-NAME}
\\[0.5ex]
\emkey{gluing-indentation-name} \\
    \hspace*{0.2in}~
    ::= {\em gluing-indentation-mark-name}
	[ {\tt ...} {\em line-separator-name} ]
\\[0.5ex]
\emkey{gluing-indentation-mark-name} ::= {\tt "}{\em mark}\,{\tt "}
\\[0.5ex]
\emkey{line-separator-name} ::= {\em quoted-name}
\\[0.5ex]
\emkey{new-selectors} ::= {\em parser-flag-modifier-list}
\\[0.5ex]
\emkey{indentation-offset} ::= unsigned integer
\end{indpar}

The {\em line-separator-name} may be used to separate
paragraph lines, as long as it is outside subexpressions
(unnamed bracketed, named bracketed, or indented subparagraph)
in the paragraph.

Each paragraph line is converted to a MIN object whose elements are
the components of the line, treated as subexpression components, except for
any {\em line-separator-name} that ends the line.  This
object is given a {\tt .terminator} attribute value
equal to the line ending {\em line-separator-name} if this exists, or
equal to {\tt "<NL>"}
if there is no line ending {\em line-separator-name}.

However, an empty paragraph line with no ending
{\em line-separator-name} is ignored as if it did not exist.

The paragraph as a whole is converted to a MIN object whose elements
are the paragraph lines, and whose {\tt .initiator} attribute
is the {\em indentation-mark-name} that introduced the paragraph.
A paragraph may be empty (have no paragraph lines).

A {\em gluing-indentation-mark-name} is a single mark that may be glued
to a preceding mark at the end of its line.  For example, `{\tt :}'
may be glued to `{\tt =}' to make `{\tt =:}'.

After a gluing indentation mark is split from a previous mark at the end of
a line, previous tokens are checked to see if they contain
the label of a symbol table entry used by the bracketed subexpression
parser.  More explicitly, any sequence of words, numbers, marks,
and separators at the
end of the line is re-parsed, excluding lexemes that were
part of or before a previously recognized symbol table entry.

An anomaly may exist if the selectors that allowed a gluing indentation mark to
be recognized are changed by a closing bracket that is glued to the indentation
mark so the indentation mark is no longer recognized.
The indentation mark will be split, the closing bracket will be recognized
on rescan
and change the selectors so the indentation mark is no longer
recognizable, and then the indentation mark will be scanned and not recognized.
This situation can be avoided by not allowing
brackets that might be glued to indentation marks
to change selectors that control recognition of those marks.

No differences exist between {\em gluing-indentation-mark-names} and
{\em indentation-\EOL mark-\EOL names}
other than that the former can be
glued to a preceeding mark and that the former must be a single mark
lexeme, while the latter can be any sequence of marks, separators, numbers,
and words.

If while parsing an indented paragraph a line is encountered whose
indentation is different from the paragraph indentation,
but the difference is less than $N$ columns (default $N=2$),
an error is announced.
No corrective action is taken; the line is accepted as either ending
the paragraph if its indentation is less than the paragraph
indentation, or continuing the current paragraph line if its indentation
is greater than the paragraph indentation.  Here $N$ is called the
\key{parser indent offset}, and is a parser parameter that can be
changed with the {\tt parser define indentation offset} command.
If changed in a parser block, the original value is reinstated at the
end of the block.

When an {\em indentation-mark-name} is recognized, the current parser
selector set is saved in a stack and
a new set is computed by modifying the saved set
according to the {\em new-selectors} in the indentation mark definition.
The saved selector set is restored after the end of paragraph
is recognized.  However {\em line-separator-name}
recognition does not depend
upon the current parser selectors, but only on previous recognition
of an associated {\em indentation-mark-name}.

\ikey{Top level parsing}{top level parsing}
of a file recognizes paragraph lines as if the whole
file were a paragraph, and forms each line into a MIN object.  However,
these are \underline{not} combined into a paragraph MIN object, but
are instead processed as they are produced.  In particular, if they
are parser commands, they are processed by the parser to make
modifications in the parser tables.  Also, the initial
\key{top level paragraph indent}
is set to zero, and an error is announced if the first non-comment,
non-line-break, non-end-of-file
lexeme in the file has non-zero indent.

Comments are ignored when determining line indentation, but may
cause errors to be announced.  A comment is considered to be in error
if it appears on a line by itself and is less indented than the first
following non-comment non-blank line.
Comments at the beginning or end of a file cannot be
in error.

\subsubsection{Named Bracketed Subexpressions}
\label{NAMED-BRACKETED-SUBEXPRESSIONS}

An \key{named bracket subexpression}
\index{bracketed subexpression!named}
begins with an {\em opening-named-bracket} and ends with
a {\em closing-named-bracket}.  These have the syntax:

\begin{indpar}[0.1in]
\emkey{opening-named-bracket} ::=
	\begin{tabular}[t]{@{}l@{~}l@{}}
	{\em named-opening} & {\em bracket-name} {\em argument}$^\star$ \\
	                    & \{ {\em named-key-separator}
			       {\em key} \}$^\star$ \\
	                    & {\em named-middle} \\
	\end{tabular}
\\[0.5ex]
\emkey{named-opening} ::= as defined by a
    {\em parser-named-bracket-command} (\pagref{PARSER-NAMED-BRACKET-COMMAND})
\\[0.5ex]
\emkey{bracket-name} ::= {\em word} \{ {\em word} $|$ {\em number} \}$^\star$
\\[0.5ex]
\emkey{argument} ::= {\em bracketed-subexpression}
                 $|$ {\em quoted-string}
\\[0.5ex]
\emkey{named-key-separator} ::= as defined by a
    {\em parser-named-bracket-command} (\pagref{PARSER-NAMED-BRACKET-COMMAND})
\\[0.5ex]
\emkey{key} ::= {\em key-component} {\em key-component}$^\star$
\\[0.5ex]
\emkey{key-component} ::= {\em word} $|$ {\em number} $|$ {\em quoted-string}
\\[0.5ex]
\emkey{named-middle} ::= as defined by a
    {\em parser-named-bracket-command} (\pagref{PARSER-NAMED-BRACKET-COMMAND})
\\[0.5ex]
\emkey{closing-named-bracket} ::= \\
	\hspace*{0.4in}
	    {\em named-middle} {\em bracket-name-initial-segment}
	                       {\em named-closing} \\
\\[0.5ex]
\emkey{named-closing} ::= as defined by a
    {\em parser-named-bracket-command} (\pagref{PARSER-NAMED-BRACKET-COMMAND})
\\[0.5ex]
\emkey{bracket-name-initial-segment}~~
	\begin{tabular}[t]{@{}rl@{}}
        ::= & {\em empty } \\
	$|$ & {\em word} \{ {\em word} $|$ {\em number} \}$^\star$
	\end{tabular}
\end{indpar}

If the {\em named-opening}, {\em named-key-separator}, {\em named-middle},
and {\em named-closing} are respectively `{\tt <}', `{\tt \#}',
`{\tt |}', and `{\tt >}', then an example named bracketed subexpression is
\begin{center}
{\tt <h1(2) \# Diamond Lemma|} ~~~\ldots~~~ {\tt |h>}
\end{center}

Here the {\em named-opening-bracket} contains the {\em bracket-name}
`{\tt h1}' (note `{\tt h}' and `{\tt 1}' are separate lexemes),
the {\em argument} `{\tt (2)}', and the {\em key} `{\tt Diamond Lemma}',
while the {\em named-closing-bracket} just contains an initial
segment of the {\em bracket-name}.   The initial name segment
in the {\em named-closing-bracket} may be empty, so
{\tt |>}, {\tt |h>}, or {\tt |h1>} could all be used as closing
brackets in the above example.

The {\em named-opening}, {\em named-key-separator}, {\em named-middle},
and {\em named-closing} are symbol table keys
from which named opening and closing
brackets are constructed.  They are specified by a
\ttkey{parser defined named bracket} parser definition, an example of
which is:
\begin{center}
{\tt parser define named bracket
     "<"~...~"\#"~...~"|"~...~"|"~...~">" [text]} \ldots
\end{center}
which specifies `{\tt <}' to be a {\em named-opening},
`{\tt \#}' to be a {\em named-key-separator},
`{\tt |}' to be a {\em named-middle},
`{\tt >}' to be a {\em named-closing},
and `{\tt text}' to be the sole definition selector.
Recall that as bracketed subexpression recognizer
symbol table keys,
{\em named-openings},
{\em named-key-separators},
{\em named-middles},
and {\em named-closings}
may not span multiple lines, but
{\em named-opening-brackets},
{\em named-closing-brackets},
and {\em named-operators} may span multiple lines.

The general syntax of {\em parser-named-bracket-commands} is:

\begin{indpar}
\emkey{parser-named-bracket-command}%
\label{PARSER-NAMED-BRACKET-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttikey{parser define named bracket}{named bracket!parser define}
	  {\em named-bracket-name} {\em parsing-selectors} \\
    $|$ & \ttikey{parser undefine named bracket}{named bracket!parser undefine}
	  {\em named-bracket-name} {\em parsing-selectors} \\
    \end{tabular}
\\[0.5ex]
\emkey{named-bracket-name} \\
    \hspace*{0.2in}
     ::= \begin{tabular}[t]{@{}l@{}}
	 {\em named-opening} [ {\tt ...} {\em named-key-separator} ] \\
         {}[ {\tt ...} {\em named-middle} {\tt ...} {\em named-middle} ] \\
	 {\tt ...} {\em named-closing}
	 \end{tabular}
\\[0.5ex]
\emkey{named-opening} ::= {\em quoted-name}
\\[0.5ex]
\emkey{named-key-separator} ::= {\em quoted-name}
\\[0.5ex]
\emkey{named-middle} ::= {\em quoted-name}
\\[0.5ex]
\emkey{named-closing} ::= {\em quoted-name}

\label{NAMED-BRACKET-DEFINITIONS}
\end{indpar}


A named bracketed subexpression is converted to a
MIN object whose list elements are the components of the
subexpression except for the brackets.  The
{\em named-opening} becomes the {\tt .initiator}
attribute of this object, the {\em named-middle} becomes
the {\tt .middle} attribute of this object,
the {\em named-closing} becomes the {\tt .terminator} attribute
of the object, the {\em bracket-name} (from the {\em named-opening-bracket})
becomes the
{\tt .name} attribute of the object, the {\em arguments}
become the {\tt .arguments} attribute of the object,
and the {\tt keys} become the {\tt .keys} attribute of the object.
The {\tt .arguments} attribute value is itself a MIN object
whose list elements are the argument subexpressions formatted
in the same way as they would be if they were ordinary
subexpression components.
The {\tt .keys} attribute is a MIN object whose list elements
are the individual {\em keys}, and whose {\tt .initiator} and 
{\tt .separator} attributes are both the {\em named-key-separator}.
Every value inside the subexpression object attributes
that is not a MIN object and not part of an {\em argument}
is a MIN string or a MIN label with 2 or more
elements that are MIN strings.
If there are no {\em arguments}, the {\tt .arguments} attribute
is not set, and similarly if there are no {\em keys}, the {\tt .keys}
attribute is not set.

In particular, quoted strings in {\em keys} are converted to
MIN strings whose values equal the translation strings of the
quoted string.  Thus the keys
`{\tt lemma "5.1.1"}' and `{\tt lemma 5.1.1}' become identical
when stored in the {\tt .keys} attribute of the parser result.

If the {\em named-middle} ends in a mark and the {\em named-closing}
begins with a mark, these may be glued together to make a
{\em named-closing-bracket} with empty {\em bracket-name-initial-segment}.
Thus in our example the single mark `{\tt |>}' may be used in place of
the two separate marks `{\tt | >}'.

If a named bracketed subexpression ends pre-maturely, before
its {\em named-closing-bracket} is discovered, a parsing error is
announced and the {\em named-closing-bracket} is inserted in the input
just after the pre-maturely ended subexpression.  Such a pre-mature end can be
discovered by finding the {\em closing-bracket-name} of a containing
unnamed bracketed subexpression, the {\em named-closing-bracket}
of a containing named bracketed subexpression, the end of the paragraph line
containing the named bracketed subexpression,
or an end of file.

\subsubsection{Named Operators}

A \key{named operator} has the same syntax as an {\em opening-named-bracket}
except that the {\em named-operator} ends with a
{\em named-closing} instead of a {\em named-middle}:

\begin{indpar}[0.1in]
\emkey{named-operator}
    \begin{tabular}[t]{@{}l@{~}l@{}}
    {\em named-opening} & {\em operator-name} {\em argument}$^\star$ \\
	                & \{ {\em named-key-separator} {\em key} \}$^\star$ \\
	                & {\em named-closing} \\
	 \end{tabular}
\\[0.5ex]
\emkey{operator-name} ::= {\em word} \{ {\em word} $|$ {\em number} \}$^\star$
\end{indpar}

A {\em named-operator} is converted to a MIN object which has the
same structure as a named bracketed subexpression with an empty list
but with its {\tt .name} attribute equal to
the {\em operator-name} instead of a {\em bracket-name} and with
no {\tt .middle} attribute.  As for a named bracketed subexpression,
the {\tt .initiator} is the {\em named-opening},
the {\tt .terminator} is the {\em named-closing},
and the {\tt .arguments} and {\tt .keys} are set from the
contents of the {\em named-operator} just as they would be from the
contents of a {\em named-opening-bracket}.

\subsection{Parser Passes}

After a subexpression has been identified by the top level bracketed
subexpression recognition pass, a sequence of passes are run on the
subexpression.  Which passes are run is determined by the the
parser pass stack.

The \key{parser pass stack} is a list of parsers with a set of
selectors associated with each parser.  After the top level pass
recognizes a subexpression, the active parsers in the parser pass stack
are run in the order that they appear in the stack.

The parsing selectors
computed by the opening bracket of the bracketed subexpression, which
are used to scan the bracketed subexpression, are also attached to that
bracketed subexpression.
These are used to determine activity of the parser passes run on the bracketed
subexpression and also the activity
of the parser definitions (i.e., parser symbol table entries)
used by these parser passes.
Note that only the brackets surrounding a bracketed subexpression
can change the parsing selectors in the parser context; the operators
that bound implicit subexpressions cannot change these parsing selectors.

The parser pass stack can be altered
by the following parser definitions:

\begin{indpar}
\emkey{parser-pass-definition} \\
    \begin{tabular}[t]{rl}
    ::= & \ttikey{parser define pass}{pass!parser define}
	  \begin{tabular}[t]{@{}l@{}}
	  {\em parser-pass-name} {\em parsing-selectors} \\
	  {\tt after} {\em previous-parser-pass-name}
	  \end{tabular} \\
    $|$ & \ttikey{parser undefine pass}{pass!parser undefine}
	  {\em parser-pass-name} {\em parsing-selectors} \\
    \end{tabular}
\\[0.5ex]
\emkey{parser-pass-name}
    ::= {\em word} \{ {\em word} $|$ {\em number} \}$^\star$
\\[0.5ex]
\emkey{previous-parser-pass-name} ::= {\em pass-name}
\end{indpar}

The {\tt parser define pass} statement sets the parser pass
{\em parsing-selectors}
and installs the parser pass in the parser pass stack after the
parser pass already in that stack which has the name
{\em previous-parser-pass-name}.  If the parser pass was already
in the stack, it is removed first and reinstalled.

The {\tt parser undefine pass} statement removes the given
{\em parsing-selectors} from the parser pass if that is in the
parsing pass stack.

The set of passes that may be run is currently builtin, and
cannot be changed.  The following are permitted {\em parser-pass-names}:

\begin{indpar}
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
top & This refers to an imaginary pass at the top of the parser pass stack,
      and can only be used as a {\em previous-parser-pass-name} to place
      a pass at the top of the stack.
\\[1ex]
operator & Parses expressions with computational operators (e.g., \verb|+| and
\verb|*|).
\\[1ex]
lexeme replacement & Replaces sequences of lexemes with other
sequences of lexemes (e.g., replaces plurals by singulars).
\end{tabular} \\
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
radix number recognition & Recognizes numbers with non-decimal radixes.
\\[1ex]
scientific number recognition & Recognizes numbers with exponents.
\\[1ex]
number pair recognition & Recognizes pairs of numbers (e.g., \verb|4 1/2|).
\end{tabular} \\
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
number unit grouping & Groups numbers and numeric units
(e.g., \verb|4ft 5in|).
\\[1ex]
\begin{tabular}[t]{@{}l@{}}
unit multiplication \\
insertion 
\end{tabular} & Inserts multipliers between numbers and
numeric units (e.g., \verb|4*ft| and \verb|$*4.99|).
\end{tabular}
\end{indpar}


The input and output of a parser pass is a sublist of the list
of all tokens.  When a parser pass is called, it is provided with
a pointer to the first token of this sublist, and a pointer to the
first token after the sublist.  The pass may edit the sublist.

The bracketed subexpression recognition pass calls the other passes,
in the order they appear in the parser pass stack, excluding any
that are inactive because they have no selector in common with
the current parser context selectors.  After the last pass has been
called, the bracketed subexpression recognition pass replaces the
final sublist, which is the subexpression that has been recognized,
by an EXPRESSION token with a MIN object value, as described above.

\subsection{The Operator Parsing Pass}
\label{OPERATOR-PARSING-PASS}

The \key{operator parsing pass} is an expression parser pass that uses
operators to restructure expressions.  Operators
are defined by operator definitions that can be added to the
parsing definition stack.  List separators, such as `\verb|,|', are treated
as operators, and have operator definitions.

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITION}

An \key{operator definition} specifies for each operator the following:

\begin{indpar}[1in]
Name and Selectors \\
Precedence \\
Operator Flags \\
Reformatter \\
Evaluator
\end{indpar}

The syntax of operator definitions is:

\begin{indpar}
\emkey{operator-definition} \\
    \hspace*{0.5in}\begin{tabular}{rl}
    ::= & \ttkey{parser define operator}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em operator-name} {\em parsing-selectors} \\
	    {\em operator-flag} {\em operator-flag}\,$^\star$ \\
	    \verb|with precedence| {\em precedence} \\
	    {}[ \verb|with reformatter| {\em reformatter-name} ] \\
	    \end{tabular} \\
    $|$ & \ttkey{parser undefine operator}
	    \begin{tabular}[t]{@{}l@{}}
	    {\em operator-name} {\em parsing-selectors} \\
	    {\em operator-flag} {\em operator-flag}\,$^\star$ \\
	    \verb|with precedence| {\em precedence} \\
	    \end{tabular} \\
    \end{tabular}
\\[1ex]
\emkey{operator-name} \begin{tabular}[t]{rl}
		    ::= & {\em simple-operator-name} \\
		    $|$ & \verb|bracket| {\em bracket-name} \\
		    $|$ & \verb|indentation mark| {\em indentation-mark-name}
		    \end{tabular}
\\[1ex]
{\em simple-operator-name} ::= {\em quoted-name} \\[1ex]
{\em bracket-name} ::= see \pagref{BRACKET-NAME} \\[1ex]
{\em indentation-mark-name} ::= see \pagref{INDENTATION-MARK-NAME} \\[1ex]
\emkey{operator-flag} ::= \ttmkey{prefix}{operator flag}
                    $|$ \ttmkey{infix}{operator flag}
                    $|$ \ttmkey{postfix}{operator flag}
                    $|$ \ttmkey{nofix}{operator flag}
                    $|$ \ttmkey{afix}{operator flag}
	\\[1ex]
\emkey{precedence} ::= {\em sign-option} {\em natural-number}
	\\[1ex]
\emkey{sign-option} ::= {\em empty} $|$ \verb|+| $|$ \verb|-|
	\\[1ex]
\emkey{reformatter-name} ::= {\em simple-name }
\end{indpar}

A {\em simple-operator-name} is matched to lexemes in a subexpression
in order to identify occurrences of the operator.
The other forms of {\em operator-name} permit bracketed subexpressions
with particular kinds of brackets to be parsed as if they were operators.
Thus in `\verb|x[5]=0|' the bracketed subexpression
`\verb|[5]|' can be a postfix operator.  A subexpression
bracketed by `\verb|{ }|' is used as an afix (see below) to the
\verb|<--| operator (as is a subexpression introduced by the `\verb|:|'
indentation mark).

By abuse of language, the term `\key{operator}' is often used
as a synonym for `{\em simple-operator-name}'.

Operators can have \skey{operator flag}s that
affect parsing of subexpressions of the operator.  The possible
flags are `{\tt infix}', `{\tt prefix}', `{\tt postfix}',
`{\tt nofix}', and `{\tt afix}'.  By default an operator is `{\tt nofix}'.

An \ttkey{infix} operator must be between two non-empty operands,
while a \ttkey{prefix} operator must precede a non-empty operand,
and a \ttkey{postfix} operator must follow a non-empty operand.
A prefix operator can only appear at the beginning of a subexpression and
has no preceding operand.
A postfix operator can only appear at then end of a subexpression and has
no following operand.

A \ttkey{nofix} operator is like an infix operator but may or may not be
preceded or followed by operands.  It may appear at the beginning or ending of
an expression, or two nofix operators may be consecutive in an expression.

An \ttkey{afix} operator\label{AFIX-OPERATOR} must follow
another operator that has the same precedence in a subexpression.
Subexpressions bracketed by `\verb|{ }|'
are standard afix operators with the same precedence
as the \verb|<--| operator, so that an expression such as:
\begin{center}
\verb|sum from X through Y <-- integer X, integer Y { ... }|
\end{center}
is parse as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y) { ... }|
\end{center}
and \underline{not} as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y { ... })|
\end{center}

An\label{FIXITY-RULES}
operator must be prefix, infix, postfix, or nofix.
A prefix operator may also be infix or postfix, but may not be afix.
An infix operator may also be prefix or afix, but not postfix.
An postfix operator may also be prefix or afix, but not infix.
A nofix operator may afix, but not prefix, infix, or postfix.

This can be summarized in the following compatibility table:

\begin{center}
\begin{tabular}{|c|c|c|c|c|l}
\cline{1-5}
prefix & infix  & postfix & nofix & afix & \\
\hline
\multicolumn{1}{c|}{}
       & yes    & yes     & no    & yes   &  \multicolumn{1}{|l|}{prefix} \\
\cline{2-6}
\multicolumn{2}{c|}{}
                & no      & no    & yes   &  \multicolumn{1}{|l|}{infix} \\
\cline{3-6}
\multicolumn{3}{c|}{}
                          & no    & yes   &  \multicolumn{1}{|l|}{postfix} \\
\cline{4-6}
\multicolumn{4}{c|}{}
                                  & yes   &  \multicolumn{1}{|l|}{nofix} \\
\cline{5-6}
\end{tabular}
\end{center}

The {\em precedence} of an operator is an integer.  Precedence is used to
determine which operators are inside and outside implicit brackets.
Operators with higher precedence are placed inside the 
implicit brackets that surround operands of operators of lower precedence.
Implicit brackets are used to define subexpressions, so that all operators
in a subexpressions that are not in sub-subexpressions are of the same
precedence.

The {\em reformatter-name} in an {\em operator-definition} names a
function that is called after all other parsing has been done to
reformat a subexpression whose first operator is the defined operator.
For example, given the expression `\verb|-x+6*y|', the subexpression
`\verb|6*y|' is extracted, and as its first operator is `\verb|*|',
the reformatter for that operator is called and yields `\verb|* 6 y|'.
Similarly the subexpression `\verb|-x|' is extracted but the reformatter
for `\verb|-|' does not change it.
Then the reformatter for `\verb|+|' is called
with `\verb/(|-x|)+(|* 6 y|)/', since `\verb|+|' is the first operator in
this subexpression \underline{after} subexpressions have been handled.
This reformatter returns `\verb/+ (|-x|) (|* 6 y|)/'.  Here we have
use parentheses \verb/(|  |)/ to indicate implicit parentheses.


\subsubsection{Standard Operators}
\label{STANDARD-OPERATORS}

The standard operators are given on 
\pagref{STANDARD-OPERATOR-LIST}.

\begin{figure*}[!p]
\begin{center}
\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}

precedence & reformatter	& type	& operator	& meaning 
\\[2ex]
0000	& \ttkey{define}	& \tt nofix	& \ttnbkey{<--}	& define \\
	&			& \tt afix	& \ttkey{\LEFTBRACKET{}
							 ... \RIGHTBRACKET}
								& block \\
1000	& \tt \bf right		& \tt infix	& \ttnbkey{=}	& assignment \\
     	& \tt \bf associative\ttindex{right associative}
				&          	& \ttnbkey{+=}	& increment \\
     	&               	&          	& \ttnbkey{-=}	& decrement \\
     	&               	&          	& \ttnbkey{*=}	& multiply by \\
     	&               	&          	& \ttnbkey{/=}	& divide by \\
2000	& \ttkey{separator}	& \tt nofix	& \ttkey{,}	& separator \\
3000	& \ttkey{binary}	& \tt nofix	& \ttkey{BUT NOT}
								& logical and
								  not \\
3100	& \ttkey{infix}		& \tt infix	& \ttkey{AND}	& logical and \\
	&			&		& \ttkey{OR}	& logical or \\
3100	& \ttkey{unary}		& \tt nofix	& \ttkey{NOT}	& logical not \\
4000 	& \ttkey{compare}	& \tt infix	& \ttnbkey{==}	& equal \\
	&			&		& \ttnbkey{/=}  & not equal \\
	&			&		& \ttnbkey{!=}	& ditto \\
	&		      	&		& \ttnbkey{<}	& less than \\
	&			&		& \ttnbkey{<=}	& less than or
								  equal \\
	&			&		& \ttnbkey{=<}	& ditto \\
	&		      	&		& \ttnbkey{>}	& greater than
									\\
	&			&		& \ttnbkey{>=}	& greater than
								  or equal \\
	&			&		& \ttnbkey{=>}	& ditto \\
5000	& \ttkey{sum}		& \tt infix	&  \ttnbkey{+}	& addition \\
	&			&		& \ttnbkey{-}	& subtraction \\
5100	& \ttkey{binary}	& \tt infix	& \ttnbkey{/}	& division \\
5200	& \ttkey{infix}		& \tt infix	& \ttnbkey{*}
							& multiplication \\
5300	& \ttkey{binary}	& \tt infix	& \ttnbkey{\CIRCUMFLEX}
							& exponentiation \\
10000	& \ttkey{prefix}	& \tt prefix	&  \ttnbkey{-}	& minus \\
	& 			& \tt prefix	&  \ttnbkey{+}	& plus \\
	& 			& \tt prefix	&  \ttnbkey{@}	& object
	                                                          identifier \\
none	& \ttkey{subscript}	& \tt postfix	&  \ttnbkey{[...]}
								& subscript \\
\end{tabular}
\end{center}
\label{STANDARD-OPERATOR-LIST}
\end{figure*}


Below be describe the effects of standard operator reformatters.
We use notation such as

\hspace*{2em}\begin{tabular}{lcl}
\verb|x = y = z + w| & $\Longrightarrow$ & \verb|= x ( = y (+ x w))| \\
\verb|x AND AND y| & $\Longrightarrow$ & error
\end{tabular}

Here $\Longrightarrow$ means `is reformatted as'.  Furthermore, the
parentheses introduced by the rewrite are \underline{implied},
which means that the lists they bracket have \underline{no}
\verb|.initiator| or \verb|.terminator|, and the parentheses are
merely written here to indicate sublists in the expression structure.

Reformatters can detect parsing errors, such the missing operand
in `\verb|x AND AND y|'.

In some circumstances 
the bracketed subexpression recognition pass merges the brackets
it finds into a list returned by a reformater.
If the bracketed subexpression recognition pass
would otherwise
return a list (with {\tt .initiator} or {\tt .terminator}) that has a single
element which is a list without an {\tt .initiator} or
{\tt .terminator}, then instead of forming the outer list,
the bracketed subexpression recognition
pass copies its attributes to the inner list.

Thus given `\verb|(x,y)|', the `\verb|separator|'
reformatter will return
\begin{indpar}\begin{verbatim}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
so without this merging the bracketed subexpression recognition
pass would produce
\begin{indpar}\begin{verbatim}
@2 = @1 {| .initiator = "("; .terminator = ")" |}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
but instead it produces
\begin{indpar}\begin{verbatim}
@3 = x y :|
    .initiator = "("
    .terminator = ")"
    .separator = ","
\end{verbatim}\end{indpar}

Sometimes \ikey{temporaries}{temporary}\label{TEMPORARY}
are introduced by reformatting.  The syntax involving temporaries is:

\begin{indpar}
\emkey{temporary-definition} ::= {\em temporary} {\em subexpression} \\[1ex]
\emkey{temporary} ::= \verb|$| {\em natural-number}
\end{indpar}

During reformatting, a subexpression may be replaced by
a {\em temporary-definition} containing the subexpression.  This
defines the {\em temporary} as a name for the value of the subexpression.
Then the {\em temporary} can be used in the reformatted
expression to refer to this value.  An example is

\begin{center}
\verb|x == y + 3 == z| ~~~ $\Longrightarrow$ ~~~
\verb|AND (== x ($ 563 (+ y 3))) (== ($ 563) z)|
\end{center}

Here the temporary has been used to avoid computing \verb|y + 3|
more than once.

The {\em decimal-naturals} in {\em temporaries} must be assigned so no
two {\em temporary-definitions} ever have the same {\em temporary}.

With these things in mind, the reformatters are:

\begin{indpar}[1em]

\newcommand{\OP}[1]{\ttmkey{#1}{reformatting}}
\newcommand{\NBOP}[1]{\ttmnbkey{#1}{reformatting}}

\bigskip

\ttmkey{separator}{reformatter} \hfill \OP{;} ~~~ \OP{,}

\begin{indpar}[0.5em]
There must be at least one operator, all operator values must
be identical, and any two operands must be separated by an operator
(but operators my be consecutive and may begin or end the subexpression).

A list of all between-operator subexpressions is made, with empty
between-operator subexpressions being represented by empty lists.
There will be at least two subexpressions: one following
the last operator and one preceding the first operator.
The list of subexpressions is given a
\ttmkey{.separator}{produced by parsing}
attribute with value of the operator token,
and is returned as the result of the reformatting.  Examples:

\hspace*{2em}\begin{tabular}{lcl@{~~~~~}l}
\verb|x , y| & $\Longrightarrow$ & \verb|x y|
					& with {\tt .separator} {\tt ,} \\
\verb|, y| & $\Longrightarrow$ & \verb|() y|
					& with {\tt .separator} {\tt ,} \\
\verb|x ,| & $\Longrightarrow$ & \verb|x ()|
					& with {\tt .separator} {\tt ,} \\
\verb|x ,, y| & $\Longrightarrow$ & \verb|x () y|
					& with {\tt .separator} {\tt ,} \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{define}{reformatter} \hfill \NBOP{<--} ~~~
	\NBOP{\LEFTBRACKET \RIGHTBRACKET} ~~~ \OP{:}

\begin{indpar}[0.5em]

There will be a \verb|<--| operator (the other operators are afix),
and it is a parsing error
detected by the reformatter if there is more than one.
The one \verb|<--| operator is moved to the front of the expression:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x <-- y { z }| & $\Longrightarrow$ & \verb|<-- x y { z }| \\
\verb|x <-- { z }| & $\Longrightarrow$ & \verb|<-- x { z }| \\
\verb|x <--| & $\Longrightarrow$ & \verb|<-- x|
\end{tabular}

Indented subexpressions introduced by the \verb|:| indentation
mark are parsed like final \verb|{ }|
bracketed subexpressions.  Because they are afix operators with the
same precedence as \verb|<--|,
`\verb|x <-- y { z }|' does \underline{not}
end up as `\verb|<-- x ( y { z } )|', and instead we get results like:

\hspace*{2em}\begin{tabular}{lcl}

\verb|x <-- u v w { z }| & $\Longrightarrow$ & \verb|<-- x ( u v w ) { z }|
\\[1ex]
\begin{tabular}{@{}l@{}}
\verb|x <-- u v w:| \\
\verb|    z|
\end{tabular}
& $\Longrightarrow$ &
\begin{tabular}{@{}l@{}}
\verb|<-- x ( u v w ):| \\
\verb|    z|
\end{tabular}

\end{tabular}


\end{indpar}

\bigskip


\ttmkey{right associative}{reformatter}
    \hfill \NBOP{=} ~~~ \NBOP{+=} ~~~ \NBOP{-=} ~~~ \NBOP{*=} ~~~ \NBOP{/=}

\begin{indpar}[0.5em]
Use only with {\tt infix} operators.

Operands and operators are assumed to alternate,
with the first and last subexpression
elements being operands, and there must be at least one operator.

If there is only one operator, it is simply moved to the front.  If there
are several, they are rewritten as one operator subexpressions so the
rightmost executes first.  Examples:

\hspace*{2em}\begin{tabular}{lcl}
\verb|y = z| & $\Longrightarrow$ & \verb|= y z| \\
\verb|x = y = z| & $\Longrightarrow$ & \verb|= x (= y z)| \\
\verb|x += y *= z| & $\Longrightarrow$ & \verb|+= x (*= y z)| \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{unary}{reformatter} \hfill \NBOP{NOT}

\begin{indpar}[0.5em]
May be used with {\tt nofix} or {\tt prefix} operators.  Has no effect if used
with {\tt prefix} operators.

The subexpression must have exactly two elements, an operator followed
by an operand.  The subexpression is left unchanged.  Examples:

\hspace*{2em}\begin{tabular}{lcl}
\verb|NOT x| & $\Longrightarrow$ & \verb|NOT x| \\
\verb|x NOT| & $\Longrightarrow$ & error \\
\verb|x NOT y| & $\Longrightarrow$ & error \\
\verb|NOT NOT x| & $\Longrightarrow$ & error \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{prefix}{reformatter} \hfill \NBOP{+} ~~~ \NBOP{-} ~~~ \NBOP{@}

\begin{indpar}[0.5em]
May be used with {\tt prefix} operators.

The subexpression must consist of one or more operators followed by a single
operand.  If there is more than one operator, sub-subexpressions of the
form `operator operand' at the end of the subexpression are
recursively parenthesized until just two elements
are left in the subexpression.  Examples:

\hspace*{2em}\begin{tabular}{lcl}
\verb|- - x| & $\Longrightarrow$ & \verb|- (- x)| \\
\verb|+ - x| & $\Longrightarrow$ & \verb|+ (- x)| \\
\verb|- @ x| & $\Longrightarrow$ & \verb|- (@ x)| \\
\verb|- @ @ x| & $\Longrightarrow$ & \verb|- (@ (@ x))| \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{binary}{reformatter} \hfill \NBOP{BUT NOT} ~~~ \NBOP{/}
					           ~~~ \NBOP{\CIRCUMFLEX}

\begin{indpar}[0.5em]
May be used with {\tt nofix} or {\tt infix} operators.

The subexpression must have exactly three elements, an operand
followed by an operator followed by an operand.  The operator is moved
to the beginning of the expression.  Examples:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x BUT NOT y| & $\Longrightarrow$ & \verb|BUT NOT x y| \\
\verb|x / y| & $\Longrightarrow$ & \verb|/ x y| \\
\verb|x ^ y| & $\Longrightarrow$ & \verb|^ x y| \\
\verb|x / y / z| & $\Longrightarrow$ & error \\
\verb|/ y| & $\Longrightarrow$ & error \\
\verb|x /| & $\Longrightarrow$ & error \\
\end{tabular}

Note that in these examples `{\tt BUT NOT}' is a single label element
of the resulting subexpression,
and \underline{not} two word elements of the subexpression.
\end{indpar}

\bigskip

\ttmkey{infix}{reformatter} \hfill \NBOP{AND} ~~~ \NBOP{OR} ~~~ \NBOP{*}

\begin{indpar}[0.5em]
Use only with {\tt infix} operators.

Operands and operators must alternate, with the first and last subexpression
elements being operands, there must be at least one operator, and all
operators must have the same value.  The first operator is moved to the
front of the subexpression, and the other operators are removed.
Examples:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x AND y| & $\Longrightarrow$ & \verb|AND x y| \\
\verb|x AND y AND z| & $\Longrightarrow$ & \verb|AND x y z| \\
\verb|x OR y| & $\Longrightarrow$ & \verb|OR x y| \\
\verb|x OR y OR z| & $\Longrightarrow$ & \verb|OR x y z| \\
\verb|x * y| & $\Longrightarrow$ & \verb|* x y| \\
\verb|x * y * z| & $\Longrightarrow$ & \verb|* x y z| \\
\verb|AND y AND z| & $\Longrightarrow$ & error \\
\verb|x AND AND z| & $\Longrightarrow$ & error \\
\verb|x AND y AND| & $\Longrightarrow$ & error \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{compare}{reformatter} \hfill
	\NBOP{=} ~~~ \NBOP{<} ~~~ \NBOP{>} ~~~
	\NBOP{/=} ~~~ \NBOP{!=} ~~~
	\NBOP{=>} ~~~ \NBOP{>=} ~~~
	\NBOP{=<} ~~~ \NBOP{<=}

\begin{indpar}[0.5em]
Use only with {\tt infix} operators.

Operands and operators must alternate, with the first and last subexpression
Operands and operators must alternate, with the first and last subexpression
elements being operands, and there must be at least one operator.
If there is only one operator, it is simply moved to the front.  Otherwise
the expression is rewritten so the operators become two-argument functions
whose values are combined by a multi-argument {\tt AND} and whose
shared operands are represented by temporaries to avoid computing
an operand twice. 
(\pagref{TEMPORARY})
Examples:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x < y < z| & $\Longrightarrow$ &
    \verb|AND (< x ($ 56 y)) (< ($ 56) z))| \\[1ex]
\verb|w == x != y <= z| & $\Longrightarrow$
             & \begin{tabular}[t]{@{}l@{~}l@{}}
	       \verb|AND| & \verb|(== w ($ 57 x))| \\
			  & \verb|(!= ($ 57) ($ 58 y))| \\
			  & \verb|(<= ($ 58) z)| \\
	       \end{tabular}
\end{tabular}

Note that sequences of comparison operators are treated as they are
in mathematics and not as they are in classical programming languages.
E.g., \verb|x<y<z| means \verb|x<y AND y<z| and \underline{not}
\verb|(x<y)<z|.
\end{indpar}

\bigskip

\ttmkey{sum}{reformatter} \hfill \NBOP{+} ~~~ \NBOP{-}

\begin{indpar}[0.5em]
Use only with {\tt infix} operators.

Operands and operators must alternate, with the last subexpression
element being an operand, and there must be at least one operator.
The operators must be either `\verb|+|' or `\verb|-|'.

If there is only one operator at the front of the subexpression,
the subexpression is left unchanged.
Otherwise if `\verb|+|' is only one operator
it is simply moved to the front.  Otherwise
the results are rewritten using the multi-argument summation function
`\verb|+|' and the unary negation function `\verb|-|'.  Examples:

\hspace*{2em}\begin{tabular}{lcl}
\verb|- x| & $\Longrightarrow$ & \verb|- x| \\
\verb|+ x| & $\Longrightarrow$ & \verb|+ x| \\
\verb|x + y| & $\Longrightarrow$ & \verb|+ x y| \\
\verb|+ x + y| & $\Longrightarrow$ & \verb|+ x y| \\
\verb|x - y| & $\Longrightarrow$ & \verb|+ x (- y)| \\
\verb|- x - y| & $\Longrightarrow$ & \verb|+ (- x) (- y)| \\
\verb|x - y + z - w| & $\Longrightarrow$ & \verb|+ x (- y) z (- w)| \\
\verb|x + y z| & $\Longrightarrow$ & error \\
\verb|x +| & $\Longrightarrow$ & error \\
\verb|x + - y| & $\Longrightarrow$ & error \\
\end{tabular}

Note that prefix `\verb|-|' has the same precedence as infix
`\verb|+|', which differs from mathematics and classical programming languages.
E.g., \verb|x * - y| becomes \verb|+ ( x * ) ( - y )| which would of
course be in error.
\end{indpar}

\bigskip

\ttmkey{subscript}{reformatter} \hfill \NBOP{[~...~]}

\begin{indpar}[0.5em]
The subexpression must consist of two elements, an operand followed
by an operator.
The subexpression is rewritten using the binary subscript function:

\hspace*{2em}\begin{tabular}{lcl}
\verb|x[y]| & $\Longrightarrow$ & \verb|subscript x y| \\
\end{tabular}

\end{indpar}


\end{indpar}


\subsubsection{The Operator Parsing Algorithm}
\label{OPERATOR-PARSER-ALGORITHM}


The operator parsing pass runs an
algorithm that accepts as input a sequence of tokens
which we call an `expression'
and edits this input, changing it into a single token.
To do this it performs the following steps:
\begin{itemlist}[0.7in]
\item[Step 1:] Identify subexpressions within the expression and run the
operator parsing pass on these, converting them into a single
{\tt EXPRESSION} or lexeme token.
\item[Step 2:] Identify operators within the expression and replace them
with {\tt OPERATOR} tokens.
\item[Step 3:] If no operators were found in the expression,
run any passes subsequent to the operator parsing pass on the expression,
and then if the expression still has more than one
token, replace the expression by a single BRACKETABLE token listing the
tokens of the expression.

If operators were found in the expression,
run the reformatter of the first operator
in the expression.  This replaces the expression by a single token.
If no reformatter is provided by the first operator, a default
reformatter is run that replaces the expression by a single BRACKETABLE
token whose value has the operator label as its {\tt .operator} attribute.

After this step the expression is always a single non-{\tt OPERATOR} token.
\end{itemlist}

The token list at the point where Step 3 is about to execute
obeys the following requirements:
\begin{itemlist}[1.3in]
\item[Requirement 1:] 
All the {\tt OPERATOR} tokens in the token list are for operators
with the same precedence.  Furthermore, this precedence is lower
than the precedence of all operators in EXPRESSION tokens of the list
that have neither {\tt .initiator} nor {\tt .terminator} attributes
(i.e., are non-explicitly-bracketed subexpressions).
\item[Requirement 2:] 
The first {\tt OPERATOR} token in the list is not afix.
\item[Requirement 3:] 
Any prefix {\tt OPERATOR} token in the list is preceded by
the beginning of the expression or by another prefix {\tt OPERATOR} token.
Any prefix {\tt OPERATOR} token in the list
is followed by another prefix {\tt OPERATOR} token or by a
non-{\tt OPERATOR} token.
\item[Requirement 4:] 
All infix {\tt OPERATOR} tokens in the list are both preceded by and
followed by non-{\tt OPERATOR} tokens.
\item[Requirement 5:] 
Any postfix {\tt OPERATOR} token in the list is followed
by the end of the expression or by another postfix {\tt OPERATOR} token.
Any postfix {\tt OPERATOR} token is preceded by another
postfix {\tt OPERATOR} token or by a non-{\tt OPERATOR} token.
\end{itemlist}

A single non-{\tt OPERATOR}, non-{\tt EXPRESSION}
lexeme token output by a operator parsing pass may be
thought of as the equivalent of
a single {\tt EXPRESSION} token whose token value is the lexeme token value,
which is a MIN string,
if the lexeme is not a quoted string
or a {\tt EXPRESSION} token value
is a list of one element with the element being equal to the
token value converted to a MIN string and with
an {\tt .initiator} attribute equal to {\tt "} if
the lexeme represented is a quoted string.
When a single lexeme token output from an operator parsing pass
must be converted to an
{\tt EXPRESSION} token, it is converted to this equivalent.

The operator parsing pass scans its input token list from
left to right.  At any point in the scan the pass obeys the
following rules:
\begin{itemlist}[0.7in]
\item[Rule 1:] An afix operator is not recognized unless it
is proceeded by an operator of equal precedence with no
intervening operators of less precedence.
\item[Rule 2:] A prefix operator of precedence $P'$
must be preceded by the beginning of
the entire token list, or by an operator
of precedence less than $P'$,
or by a prefix operator of precedence equal to $P'$,
else the prefix operator is not recognized.
\item[Rule 3:] An infix operator of precedence $P'$
must be preceded by a non-operator,
or by an operator of precedence greater than $P'$,
else the infix operator is not recognized.
\item[Rule 4:] A postfix operator of precedence $P'$
must be preceded by a non-operator,
or by an operator of precedence greater than $P'$,
or by a postfix operator of precedence equal to $P'$,
else the postfix operator is not recognized.
\item[Rule 5:] A recognized prefix operator of precedence $P'$
must be followed by a non-operator or by an operator
of precedence greater than $P'$,
or by a prefix operator of precedence equal to $P'$,
else an `error operand' which is not an operator
is inserted after the prefix operator
and an error is announced.
\item[Rule 6:] A recognized infix operator of precedence $P'$
must be followed by a non-operator or by an operator
of precedence greater than $P'$,
else an `error operand' which is not an operator
is inserted after the infix operator
and an error is announced.
\item[Rule 7:] A recognized postfix operator of precedence $P'$
must be followed by the end of the entire token list,
or by an operator of precedence less than $P'$,
or by a postfix operator of precedence equal to $P'$,
else an `error nofix operator' of precedence $P'-1$
is inserted after the postfix operator and an error is announced.
\end{itemlist}

By simply by enforcing these rules the operator parser pass enforces
the requirements listed above.

During its left-to-right scan the operator parser pass maintains
the following state:
\begin{itemlist}[0.7in]
\item[$C$:] A pointer to the current token, initialized to the
first token in the input.
\item[$N$:] A pointer to the next token after the subexpression
being input, which may be an end-of-file token.  Not changed during
the scan from its initial value.  Initially $C\neq N$.
\item[$P$:] A stack of subexpression terminating precedences,
initialized to a one element stack containing a precedence less
than any legal operator precedence.  Whenever an operator is found,
the top of this stack is set to the precedence of the operator
(the stack may be pushed or popped before this is done).
\item[$F$:] A stack of pointers to the first token in a subexpression,
initialized to a one element stack containing a pointer to the first
token in the input.  Whenever an operator is found, the top of this
stack is set to point to the token after the operator (the stack
may be pushed or popped before this is done).
\item[$T$:] The type of the last operator found.  Valid only if
$C=F$ (meaning $C$ equals the top of the $F$ stack, and so $C$
points at the token after the operator).
Can equal {\em prefix}, {\em postfix}, {\em nofix}, {\em infix}, or {\em none}.
Initialized to {\em none}.
\end{itemlist}

In the following $F$ is used to denote either the stack $F$ or
the top element of this stack.  Similarly $P$ is used to denote either the
stack $P$ or the top element of this stack.

The operator parser pass algorithm simply repeats the following
steps in a loop:
\begin{itemlist}[1.2in]
\item[Loop Step 1:]
If $C\neq N$, find an operator beginning at token $C$, if there is one.

If $C=F$ (i.e., $C$ is at the beginning of the token list or just after
an operator of precedence $P$),
prefix operators of precedence less than $P$ are ignored,
prefix operators of precedence equal to $P$ are ignored unless
$T=\mbox{\em prefix}$,
infix operators of precedence greater than or equal to $P$ are ignored,
postfix operators of precedence greater than $P$ are ignored,
postfix operators of precedence equal to $P$ are ignored unless
$T=\mbox{\em postfix}$.

If $C\neq F$ (i.e., a non-operator is just before $C$),
prefix operators are ignored.

Any afix operator whose precedence is not in the $P$ stack is ignored.

Any operator whose selectors are disjoint from the current parser context
selectors is ignored.

Among all non-ignored operators, a longest
is selected, and among all the longest, the one with the most recent
operator definition is selected.

If an operator was found, replace its tokens by a single
OPERATOR token, point $C$ at that token.  Let $P'$ be the precedence
of the found operator and $T'$ be its type.
\item[Loop Step 2:]
If $C=F$ and $T=\mbox{\em postfix}$
(the token before $C$ is a postfix operator),
$C\neq N$, and either no operator was find in Loop Step 1,
or an operator was found and either $P'>P$
or both $P'=P$ and $T'\not=\mbox{\em postfix}$,
insert the error nofix operator of precedence
equal to $P-1$ as a single
OPERATOR token before $C$, set $C$ to point at it,
set $P'=P-1$,
announce an error, and continue (as if an operator were found in
Loop Step 1).

\item[Loop Step 3:]
Else if $C\neq N$
and no operator was find in Loop Step 1 or generated by Loop Step 2,
repoint $C$ to the next token after $C$ and go to the next loop iteration.

Note that if the iteration continues after this step,
then either $C=N$ or an operator was found in Loop Step 1
or generated in Loop Step 2.
\item[Loop Step 4:]
If $C=F$ and any of the following are true:
\\[1ex]
\hspace*{0.2in}
\begin{tabular}{@{}l@{}}
$T=\mbox{\em infix}$ and $C=N$ or $P'\leq P$, \\
$T=\mbox{\em prefix}$ and $C=N$ or $P'<P$
    or both $P'=P$ and $T'\not=\mbox{\em prefix}$
\end{tabular}
\\[1ex]
then insert
an new error operand lexeme token before $C$,
set $F$ to this new token,
announce an error, and then continue as if no error were found.
\item[Loop Step 5:]
If $C\not=F$,
apply Step 3 above to the list of tokens beginning with
$F$ and ending just before $C$.  This replaces this list of tokens
by a single non-operator token.

If $C=N$, pop the $P$ and $F$ stacks.  If these stacks are now
empty, terminate the operator parser pass algorithm.  Otherwise
repeat this loop step.

Else if $P'<P$ or both $P'=P$ and $T=\mbox{\em postfix}$,
pop the $P$ and $F$ stacks and repeat this loop step
(cannot happen if the $P$ and $F$ stacks have only one entry as
in that case $P$ is less than any possible $P'$).

Else if $P'>P$ or both $P'=P$ and $T=\mbox{\em prefix}$,
push $P'$ into the $P$ stack, and push a pointer to the
next token after $C$ into the $F$ stack.

Else if $P'=P$, set $F$ to point at the next token after $C$.

\item[Loop Step 6:]
Set $T=T'$,
repoint $C$ to the token after $C$, and iterate the loop.
\end{itemlist}

\clearpage

\appendix

\section{Standard Lexical Program}
\label{STANDARD-LEXICAL-PROGRAM}

\begin{indpar}
\begin{verbatim}
// This file was automatically generated from
// ll_lexeme_standard.lexcc.


begin standard lexical program;

"<ascii-char>" = "<0>-<7F>"  [ASCII Character]

// NON_ASCII_LETTERS, NON_ASCII_COMBINING_
// CHARACTERS, NON_ASCII_CONTROL_CHARACTERS are
// defined in ll_lexeme_non_ascii_characters.h.

"<non-ascii-letter>" = NON_ASCII_LETTERS

"<non-ascii-combining-char>" =
    NON_ASCII_COMBINING_CHARACTERS

"<non-ascii-control-char>" =
    NON_ASCII_CONTROL_CHARACTERS

"<ascii-letter>" = "a-z" | "A-Z";

"<digit>" = "0-9";

"<hex-digit>" = "0-9" | "A-F";

"<non-digit>" = ~ "<digit>";

"<letter>" = "<ascii-letter>"
           | "<non-ascii-letter>"

"<non-ascii-word-char>" =
      "<non-ascii-letter>"
    | "<non-ascii-combining-char>"

// Context sensitive character classifications,
// e.g., classifying ' as a word character if it
// is followed by a letter, cannot be included
// in character pattern definitions, but are
// noted in comments.  They are accounted for
// by separate lexeme table entries below.

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@"
              | "#" | "$" | "%" | "^" | "&"
              | "=" | "|" | ">" | "_" | "!"
              | "?" | ":";
              //
              // Also . not followed by a digit
              //      / not surrounded by digits
              //        or followed by /
              //      < not beginning escaped
              //        hex character

"<non-slash-char>" = ~ "/";

"<separator-char>" = "(" | ")" | "[" | "]"
                   | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter

"<misplaced-space-char>" =
        "<CR>" | "<VT>" | "<FF>"

"<ascii-control-char>" = "<0>-<1F>" | "<7F>"

"<control-char>" = "<ascii-control-char>"
                 | "<non-ascii-control-char>"

"<control-char-except-CR-LF>" =
    "<control-char>" & ~ "<CR>" & ~ "<LF>"

"<horizontal-space-char>" = " " | "<HT>";

"<escape-char>" = "A-Z" | "0-9" | "-";


begin main master table;

   // Unrecognized characters or escapes, etc,
   // outside quoted strings are output as
   // lexemes, and can separate other lexemes.
   // If these are treated by post-processing
   // in the same manner as horizontal space,
   // they could be replaced by horizontal space
   // without changing the semantics of the
   // output.
   //
   // Inside quoted strings, unrecognized
   // escapes are treated as erroneous atoms,
   // translated to "", and ignored.  The
   // lexemes output would be the same if they
   // were removed.

   // Whitespace is separated out into 4 types
   // of lexemes:
   //
   //   `space'
   //       single spaces and horizontal tabs
   //   `line break'
   //       linefeeds, carriage returns, form
   //       feeds, and vertical tabs, with at
   //       least one line feed
   //   `misplaced space'
   //       ditto but with no line feed
   //   `comments'
   //       `//' up to just before next line
   //        break, misplaced space, or (pre-
   //        mature) end of file
   //
   "//" call comment;
   "/"  call mark;

   "<horizontal-space-char>"
        call horizontal space;

   "<LF>" call line break;
   "<misplaced-space-char>"
        call misplaced space;

   "<letter>" call word;

   "'<letter>" call word;
   "'" output separator;

  "<" "<digit>"
          match escaped hex char
          require "<non-ascii-letter>"
          call word
     else match escaped hex char
          require "<ascii-char>"
          output ascii escape seq
     else match escaped hex char
          output non letter escape seq
     else keep 1 call mark;
   "<" call mark;

   "<mark-char>" call mark;

   "<digit>" keep 0 call natural number;
             // We keep 0 so natural number can
             // recognize <digit>,<digit> etc.

   ".<digit>" keep 1 call number;
              // We keep 1 so number can recog-
              // nize <digit>,<digit> etc.
   "." call mark;

   "<separator-char>" output separator;

   "," output separator;

   "<Q>" translate to "" call quoted string;

   "<other>" output misplaced char;

   output end of file;

end main master table;


// The below tables are entered from the master
// table with the first zero, one, or two
// characters scanned.


begin comment lexeme table;

   "<LF>" keep 0 return;
   "<misplaced-space-char>" keep 0 return;

   "<other>" accept;

   goto premature end of file;

end comment lexeme table;


begin horizontal space lexeme table;

   "<horizontal-space-char>" accept;

   return;

end horizontal space lexeme table;


begin misplaced space lexeme table;

   "<LF>" goto line break;

   "<misplaced-space-char>" accept;

   return;

end misplaced space lexeme table;


begin line break lexeme table;

   "<LF>" accept;
   "<misplaced-space-char>" accept;

   return;

end line break lexeme table;


begin word lexeme table;

   "<letter>" accept;
   "<non-ascii-combining-char>" accept;

   "'<letter>" accept;

    "<" "<digit>"
              match escaped hex char
              require "<non-ascii-word-char>"
         else keep 0 return;

   return;

end word lexeme table;


begin mark lexeme table;

   "<mark-char>" accept;
   "<non-ascii-combining-char>" accept;

   ".<digit>" keep 0 return;
   "." accept;

   "//" keep 0 return;
   "/" accept;

    "<" "<digit>"
          match escaped hex char
          require "<non-ascii-combining-char>"
      else
          match escaped hex char
          keep 0 return;
      else
          keep 1;
    "<" accept;

   return;

end mark lexeme table;


begin natural number lexeme table;


   // In order to recognize , and / surrounded
   // by digits as number atoms, entries to this
   // table upon recognizing "X<digit>" must do
   // a `keep 1' so the digit will be left to be
   // recognized by <digit>/<digit> or
   // <digit>,<digit>.

   // Alternatively we could have a separate
   // table for the state where the last atom
   // ended with a digit.

   "<digit>/<digit>" keep 2 goto number;
   "<digit>,<digit>" keep 2 goto number;
   "<digit>" accept;

   ".<digit>" keep 1 goto number;

   return;

end natural number lexeme table;


begin number lexeme table;

   // See note on , and / in `natural number'
   // table above.

   "<digit>/<digit>" keep 2;
   "<digit>,<digit>" keep 2;
   "<digit>" accept;

   ".<digit>" keep 1;

   return;

end number lexeme table;


begin quoted string lexeme table;

    "<Q>" translate to "" return;
            // End quoted string.

    "<" match escaped char
        else match unrecognized escape seq
             error unrecognized escape seq
             translate to ""
        else accept;

    "<LF>"
        keep 0 goto premature end of line;

    "<CR><LF>"
        keep 0 goto premature end of line;
    "<CR>"
        error misplaced control char
        translate to "";

    "<control-char-except-CR-LF>"
        error misplaced control char
        translate to "";

    "<other>" accept;

    goto premature end of file;

end quoted string lexeme table;


begin escaped char atom table;

    "<" "ACK" ">" translate to "<ACK>";
    "<" "BEL" ">" translate to "<BEL>";
    "<" "BS" ">" translate to "<BS>";
    "<" "CAN" ">" translate to "<CAN>";
    "<" "CR" ">" translate to "<CR>";
    "<" "DC1" ">" translate to "<DC1>";
    "<" "DC2" ">" translate to "<DC2>";
    "<" "DC3" ">" translate to "<DC3>";
    "<" "DC4" ">" translate to "<DC4>";
    "<" "DEL" ">" translate to "<DEL>";
    "<" "DLE" ">" translate to "<DLE>";
    "<" "EM" ">" translate to "<EM>";
    "<" "ENQ" ">" translate to "<ENQ>";
    "<" "EOT" ">" translate to "<EOT>";
    "<" "ESC" ">" translate to "<ESC>";
    "<" "ETB" ">" translate to "<ETB>";
    "<" "ETX" ">" translate to "<ETX>";
    "<" "FF" ">" translate to "<FF>";
    "<" "FS" ">" translate to "<FS>";
    "<" "GS" ">" translate to "<GS>";
    "<" "HT" ">" translate to "<HT>";
    "<" "LF" ">" translate to "<LF>";
    "<" "NAK" ">" translate to "<NAK>";
    "<" "NL" ">" translate to "<NL>";
    "<" "NUL" ">" translate to "<NUL>";
    "<" "Q" ">" translate to "<Q>";
    "<" "RS" ">" translate to "<RS>";
    "<" "SI" ">" translate to "<SI>";
    "<" "SO" ">" translate to "<SO>";
    "<" "SOH" ">" translate to "<SOH>";
    "<" "SP" ">" translate to "<SP>";
    "<" "STX" ">" translate to "<STX>";
    "<" "SUB" ">" translate to "<SUB>";
    "<" "SYN" ">" translate to "<SYN>";
    "<" "US" ">" translate to "<US>";
    "<" "VT" ">" translate to "<VT>";

    "<" "<digit>" match escaped hex char
            else fail;

    fail;

end escaped char atom table;


begin escaped hex char atom table;

    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit>" ">" translate hex 1 1;

    fail;

end escaped hex char atom table;


begin unrecognized escape seq atom table;

    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>" ">";
    "<" "<escape-char>" ">";

    fail;

end unrecognized escape seq atom table;


begin premature end of line master table;

    output premature end of line goto main;

end premature end of line master table;


begin premature end of file master table;

    output premature end of file goto main;

end premature end of file master table;


end standard lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{C++ Lexical Program}
\label{C++-LEXICAL-PROGRAM}

\begin{indpar}\begin{verbatim}
// This file was automatically generated from
// ll_lexeme_c++.lexcc.

begin c++ lexical program;

// Before this lexical program is used the input
// should be preprocessed to
//
//    (1) Replace trigraph sequences.
//    (2) Eliminate carriage-returns next to a
//        newline (others become misplaced)
//    (3) Eliminate sequences of the form:
//        backslash newline
//
// After this lexical program is used the output
// should be post-processed to
//
//    (4) Perform C/C++ macro preprocessing
//        (macro expansion).
//    (5) Delete whitespace and newlines.
//    (6) Concatenate adjacent quoted strings
//        of the same character type (ordinary,
//        u, U, or L).

"<digit>" = "0-9";

"<non-zero-digit>" = "1-9";

"<oct-digit>" = "0-7";

"<hex-digit>" = "0-9" | "a-f" | "A-F";

"<ascii-letter>" = "a-z" | "A-Z";

"<letter>" = "<ascii-letter>"
           | "<non-ascii-letter>

// <non-ascii-letter> ::= UNICODE character in
// one of the code ranges designated in
// NON_ASCII_LETTERS in ll_lexeme_non_ascii_
// characters.h.

// <combining-char> ::= UNICODE character in
// one of the code ranges designated in
// NON_ASCII_COMBINING_CHARACTERS in ll_lexeme_
// non_ascii_characters.h.

// Universal characters are only permitted in
// identifiers, character literals, and string
// literals.  In identifiers they must represent
// non-ASCII-letters or non-ASCII combining
// characters, and the latter cannot be the
// initial character of an identifier.

"<identifier-non-digit>" = "_" | "<letter>";

"<identifier-char>" = "<identifier-non-digit>"
                    | "<digit>"
                    | "<combining_char>"

"<non-ascii-identifier-char>" =
          "<non-ascii-letter>"
        | "<combining_char>"

// Because `u', `U', or `L' can start a char-
// acter or string literal, we must define:
//
"<u_U_L>" = "u" | "U" | "L";
"<identifier-non-literal>" =
          "<identifier-non-digit>"
        & ~ "<u_U_L>";

"<whitespace-char>" =
    " " | "<HT>" | "<VT>" | "<FF>";
    // newline is treated separately


// The following can begin an operator or punc-
// tuation mark.
//
// / not followed by / or * and . not followed
// by <digit> are handled separately.
//
"<op-char>" = "#" | "<" | ">" | ":" | "%" |
            | "?" | "+" | "-" | "*" | "="
            | "^" | "&" | "|" | "~" | "!" | ","
            | "(" | ")" | "[" | "]" | "{" | "}"
            | ";";

"<sign>" = "+" | "-" ;

"<u_U>" = "u" | "U" ;

"<ascii-char>" = "<0>-<7F>"  [ASCII Character]


// C/C++ preprocessing is hereafter abbreviated
// as `pp'.

// Alternative operators that are not identi-
// fiers are translated.  E.g., <: becomes [ in
// the lexeme translation.

// C++ punctuation are treated as `operators'.

// Pp numbers are divided into 5 categories
// (note that a `suffix' is an identifier):
//
//      decimal integer
//          nothing but digits not beginning
//          with 0, with an optional suffix
//      octal integer
//          nothing but octal digits beginning
//          with 0, with an optional suffix
//      hexadecimal integer
//          nothing but hexadecimal digits
//          refaced by 0x or 0X, with an
//          optional suffix
//      float
//          legal floating point #'s, with an
//          optional suffix
//      pp number
//          all other pp numbers

// Because of pp control lines, lexical scanning
// is slightly context dependent.  There are
// several contexts, each corresponding to a
// different master table:
//
//    initial master
//        Used in line beginning situations to
//        recognize the # token that introduces
//        a pp control line.
//    pp beginning master
//        Used to scan the beginning of a pp
//        control line after the # has been
//        scanned but before anything else is
//        scanned.
//    pp include master
//        Used to scan the pp-header token in a
//        #include line after #include has been
//        scanned.
//    normal master
//        Used to scan a non pp control line or
//        the rest of a pp control line after
//        any #include header.
//
// The whitespace lexeme types are:
//
//    newline
//        a single <NL>
//    horizontal-space
//        sequence of "<whitespace-char>"s
//        (excludes <NL>'s)
//    comment
//        "/*" comment (including /* and */)
//        "//" comment (including // but not
//                      ending newline)
//
// This allows line feeds to be used to end pp
// control lines.


// Characters that are not part of legal lexemes
// and which are outside character literal ''s
// and and quoted string literal ""s are made
// into error lexemes that can separate other
// lexemes in exactly the same way that white-
// space can.
//
// Note that ## cannot be used to move charac-
// ters inside a character or string literal ''
// or "".  Also, we do NOT allow ## to append a
// combining character to another character.
// Therefore ## cannot be used to create a legal
// pp token by concatenating a legal pp token
// with a stray character that is not part of a
// legal pp token.  Thus we can treat all stay
// characters as errors, instead of making them
// into pp tokens.

// Characters that are part of erroneous atoms
// INSIDE character literal ''s or quoted string
// ""s are announced as part of an erroneous
// atom which is translated to "" and ignored as
// if it did not appear at all in the input.

begin initial master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur INSIDE
    // a pp directive line.
    //
    "/*" call "/*" comment;

    "#" output operator goto pp beginning;
    "##" output operator goto normal;

    "%:" translate to "#" output operator
         goto pp beginning;
    "%:%:" translate to "##" output operator
           goto normal;

    goto normal;

end initial master table;


begin pp beginning master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur inside
    // pp directive line.
    //
    "/*" call "/*" comment;

    // "include" identifier must be followed by
    // one of the following for a header to be
    // recognized:
    //
    //     <whitespace-char>
    //     /* comment
    //     <...> header
    //     "..." header
    //
    "include<whitespace-char>"
        keep 7 output identifier
        goto pp include;
    "include/"
        keep 7 output identifier
        goto pp include;
    "include<"
        keep 7 output identifier
        goto pp include;
    "include<Q>"
        keep 7 output identifier
        goto pp include;

    goto normal;

end pp beginning master table;

begin pp include master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur inside
    // pp directive line.
    //
    "/*" call "/*" comment;

    "<" translate to ""
        goto bracketed header name;

    "<Q>" translate to ""
        goto quoted header name;

    goto normal;

end pp include master table;


begin premature newline master table;

    output premature newline goto normal;

end premature newline master table;


begin premature end of file master table;

    output premature end of file goto initial;

end premature end of file master table;

begin whitespace lexeme table;

    "<whitespace-char>" accept;

    return;

end whitespace lexeme table;


begin "/*" comment lexeme table;

    "*/" return;
    "*" accept;

    "<other>" accept;

    translate_to "*/"
    goto premature end of file;

end "/*" comment lexeme table;


begin "//" comment lexeme table;

    "<NL>" keep 0 return;

    "<other>" accept;

    goto premature end of file;

end "//" comment lexeme table;


begin bracketed header name lexeme table;

    ">" translate to "" goto normal;

    "<NL>"
        keep 0 goto premature newline;

    "<other>" accept;

    goto premature end of file;

end bracketed header name lexeme table;


// Quoted header names are not the same as
// quoted strings, and cannot have escape
// sequences.
//
begin quoted header name lexeme table;

    "<Q>" translate to "" goto normal;

    "<NL>"
        keep 0 goto premature newline;

    "<other>" accept;

    goto premature end of file;

end quoted header name lexeme table;


begin normal master table;

    "<whitespace-char>" call whitespace;

    "/*" call "/*" comment;
    "//" call "//" comment;
    "/" match operator output operator
        // match should always succeed

    "<op-char>"
        match operator output operator
        // match should always succeed

    "<identifier-non-literal>"
        call identifier;
        // Also see "u/U/L..." etc. below.

    "u'" translate to ""
         output u char literal
         call char literal;
    "u<Q>" translate to ""
           output u string literal
           call string literal;
    "u"  call identifier;

    "U'" translate to ""
         output U char literal
         call char literal;
    "U<Q>" translate to ""
           output U string literal
           call string literal;
    "U"  call identifier;

    "L'" translate to ""
         output L char literal
         call char literal;
    "L<Q>" translate to ""
           output L string literal
           call string literal;
    "L"  call identifier;

    "\<u_U>" match universal char
             require <non-ascii-letter>
             call identifier
        else match universal char
             require "<ascii-char>"
             output ascii universal char
        else match universal char
             output misplaced universal char
        else match short universal char
             output universal char
             // Match should always succeed.
    "\" output misplaced char

    "<non-zero-digit>" call decimal integer;

    "0x" call hexadecimal integer;
    "0X" call hexadecimal integer;
    "0" call octal integer;

    ".<digit>" call fraction;
    "." match operator output operator
        // match should always succeed

    "'" translate to ""
        output char literal
        call char literal;

    "<Q>" translate to ""
          output string literal
          call string literal;

    "<NL>" output newline goto initial;

    "<other>" output misplaced char;

    output end of file;

end normal master table;


begin operator atom table;

    "("; ")"; "["; "]"; "{"; "}"; ";"; ","; "?";
    "~";

    "#";
    "##";

    "<:" translate to "[";
    "<%"; translate to "{";
    "<<="; "<<"; "<";

    ">>="; ">>"; ">";

    ":>" translate to "]";
    "::"; ":";

    "%>" translate to "}";
    "%:%:" translate to "##";
    "%:" translate to "#";
    "%="; "%";

    "..."; ".*"; ".";

    "++"; "+="; "+";

    "->*"; "->"; "--"; "-="; "-";

    "*="; "*";
    "/="; "/";
    "^="; "^";
    "!="; "!";
    "=="; "=";

    "&&"; "&="; "&";

    "||"; "|="; "|";

    fail;

end operator atom table;


begin identifier lexeme table;

    "<identifier-non-digit>" accept;
    "<digit>" accept;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
        else keep 0 return

    return;

end identifier lexeme table;

"<e_E> = "e" | "E";
"<identifier-non-digit-except-eE>" =
    "<identifier-non-digit>" & ~ "<e_E>";


begin decimal integer lexeme table;

    "<digit>" accept;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end decimal integer lexeme table;


begin octal integer lexeme table;

    "<oct-digit>" accept;

    "8" goto float integer;
    "9" goto float integer;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end octal integer lexeme table;

"<identifier-non-hex-digit>" =
    "<identifier-non-digit>" & ~ "<hex-digit>";


begin hexadecimal integer lexeme table;

    "<hex-digit>" accept;

    "<identifier-non-hex-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end hexadecimal integer lexeme table;


// integer began with 0 and then included a
// non-octal digit.
//
begin float integer lexeme table;

    "<digit>" accept;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto pp number;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto pp_number
        else keep 0 goto pp number

    goto pp number;

end float integer lexeme table;


// Come here to process suffix at end of integer
// or float lexeme.  Similar to identifier but
// changes lexeme type to pp number when certain
// character sequences are encountered.
//
begin suffix sublexeme table;

    "<identifier-non-digit-except-eE>" accept;
    "<digit>" accept;

    "<e_E><sign>" goto pp number;
    "<e_E>" accept;

    "." goto pp number;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
             else keep 0 return;

    return;

end suffix sublexeme table;

begin pp number lexeme table;

    "<identifier-non-digit-except-eE>" accept;
    "<digit>" accept;

    "<e_E><sign>" accept;
    "<e_E>" accept;

    "." accept;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
             else keep 0 return;

    return;

end pp number lexeme table;


begin fraction lexeme table;

    "<digit>" accept;

    "." goto pp number;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<identifier-non-digit>" goto suffix;

    "\<u_U>" match universal char
             require "<non-ascii-letter>"
             goto suffix
             else keep 0 return;

    return;

end fraction lexeme table;


begin exponent lexeme table;

    "<digit>" accept;

    "." goto pp number;

    "<e_E><sign>" goto pp number;
    "<identifier-non-digit>" goto suffix;

    "\<u_U>" match universal char
             require "<non-ascii-letter>"
             goto suffix
             else keep 0 return;

    return;

end exponent lexeme table;


begin char literal sublexeme table;

    "'" translate to "" return;

    "<NL>" keep 0 goto premature newline

    "\" match escaped char
        // match should always succeed

    "<other>" accept

    goto premature end of file

end char literal sublexeme table;


begin string literal sublexeme table;

    "<Q>" translate to "" return;

    "<NL>" keep 0 goto premature newline

    "\" match escaped char
        // match should always succeed

    "<other>" accept

    goto premature end of file

end string literal sublexeme table;


// This atom table is used when the next atom
// begins with \ and is in a character or string
// literal.  This atom table always succeeds,
// but may produce an erroneous atom with ""
// translation.
//
// We allow only a maximum of 8 hexadecimal
// digits after \x; 9 digits is an error.  The
// C++ standard permits any number of hexa-
// decimal digits.
//
begin escaped char atom table;

    "\n" translate to "<NL>";

    "\t" translate to "<HT>";

    "\v" translate to "<VT>";

    "\b" translate to "<BS>";

    "\r" translate to "<CR>";

    "\f" translate to "<FF>";

    "\a" translate to "<BEL>";

    "\\" translate to "\";

    "\?" translate to "?";

    "\<Q>" translate to "<Q>";

    "\'" translate to "'";

    "\<oct-digit><oct-digit><oct-digit>"
        translate oct 1 0;
    "\<oct-digit><oct-digit>"
        translate oct 1 0;
    "\<oct-digit>"
        translate oct 1 0;

    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        error too long hex escape
        translate to "";
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit>"
        translate hex 2 0;
    "\x" error ill formed escape
        translate to "";

    "\<u_U>" match universal char
        else match short universal char
             error short universal char
             translate to "";
             // This should always succeed

"\<NL>" keep 1
        error ill formed escape
        translate to "";

"\<other>" error ill formed escape
           translate to "";

"\" error ill formed escape
    translate to "";
    // In case \ followed by end of file

// This table should always succeed.

end escaped char atom table;


// This atom table is called when the next
// atom begins with \U or \u.  If the atom
// has the correct number of hexadecimal
// digits after the \U or \u, it is recognized
// and translated.
//
begin universal char atom table;

    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;

    "\u<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;

    fail;

end universal char atom table;


// This atom table is called when the next
// atom begins with \U or \u but there are too
// few hexadecimal digits following.  An atom
// is always recognized but is NOT translated.
//
begin short universal char atom table;

    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>";
    "\U<hex-digit>";
    "\U";

    "\u<hex-digit><hex-digit>"
      "<hex-digit>";
    "\u<hex-digit><hex-digit>";
    "\u<hex-digit>";
    "\u";

    // The above should always succeed.

end short universal char atom table;


end c++ lexical program;

\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
