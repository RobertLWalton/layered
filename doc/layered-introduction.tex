% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttnbakey}[2]{{\tt #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\ttitemref}[1]{{\tt \ref{#1} ({p\pageref{#1}})}}
\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newsavebox{\DOUBLEQUOTEBOX}
\begin{lrbox}{\DOUBLEQUOTEBOX}
\verb/"/
\end{lrbox}
\newcommand{\DOUBLEQUOTE}{\usebox{\DOUBLEQUOTEBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

November 10, 2010
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{4.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A machine independent reduced instruction set architecture
	  programming language.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& Similar to the C programming language but more flexible.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& Implements standardized lists, symbols, arrays, etc. to extend
	  the M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `{\tt hello}', `{\tt +}', `{\tt ;}',
`{\tt 9.200}' are four lexemes.

The lexical scanner is written in the M-Language and can be
replaced.  This section describes the standard scanner which
is driven by the atom tables and is capable scanning
lexemes of common languages such as C and C++.

The standard scanner attempts to be both machine and human
efficient.  It attempts to be machine efficient by being
deterministic\footnote{Unlike regular expression scanners.}
and attempts to be human efficient by supporting algorithms
that people can readily understand and hopefully quickly
learn to mimic.\footnote{A possibly non-verifiable goal.}

The standard scanner operates on an input stream of 32-bit
UNICODE characters.  Each character is associated with
a position value that specifies from where the character
came.  For example, a position value may encode a file name,
line-within-file number, and column-within-line number.
The standard scanner identifies a lexeme as a sequence
of input stream UNICODE 32-bit characters each with a
corresponding position value.

The standard scanner also produces a translation of each
lexeme.  This may just be a copy of the 32-bit characters
in the lexeme, or it may have some changes, or `translations',
of some of these characters.  For example, the lexeme
\verb|"a line\lf/"| may have a translation that omits the
\verb|"|'s and converts the three characters \verb|\lf/| into
a single linefeed character.

When the standard scanner identifies a lexeme it also identifies
a `\mkey{type}{of lexeme}' for the lexeme.
For example, the lexeme \verb|9.35| may have type `{\tt number}'
while the lexeme \verb|"abc"| may have the type `{\tt quoted string}'.

At its most fundamental level the
standard scanner identifies lexical atoms in the input text.
A \key{lexical atom} is a single character (e.g., the letters
in an identifier or symbol) or a short string of characters
(e.g., the characters \verb|\lf/| in a quoted string).
Lexical atoms are read left to right and
grouped by the scanner into \skey{lexeme}s.

The scanner has a state containing a current point 
in the input UNICODE character stream
and a \key{current atom table} identifier.  An
\key{atom table} is a set of atom patterns
that match lexical atoms, and for each pattern an
instruction that determines what to do when the pattern is matched.
There is also a \key{default instruction} associated with the atom table that
determines what to do when no table pattern matches the next characters
in the input stream.

An \key{atom pattern}\index{pattern!lexical atom} is a fixed
length sequence of character patterns, and matches any sequence of
input characters of the same length as the atom pattern
if each input character of the sequence matches the corresponding
character pattern.  A \key{character pattern} is simply a
specification of a set of characters, e.g., letters or digits.
Thus one can construct an atom pattern that will recognize
single letters, or one that will recognize the sequence of
characters such as the 3-character sequence \verb|\lf/| which matches
the atom pattern \verb|"\/lf/"|
or the 7-character sequence \verb|\0a/| which matches the atom pattern
\begin{center}
\verb|"\/0<hex-digit>/"|
\end{center}
where \verb|<hex-digit>| names a character pattern matching characters
in the ranges \verb|0-9|, \verb|a-f|, and \verb|A-F|.

The atom patterns of a single atom table must not conflict:
no character string can be recognized by two atom patterns of the
same atom table.

The scanner operates by identifying the
longest sequence of characters beginning at the current input character
stream point that matches an atom pattern of the current atom table.
This sequence of characters becomes
the next atom, and an instruction associated with its matching
atom pattern is then executed.  If no atom pattern can be matched,
the default instruction associated with the atom table is executed instead.

An atom table
instruction can optionally reduce the length of a matched atom
and optionally change the current atom table.  It can also do other
things described below.

Atom tables have \skey{mode}s that are either lexeme types or
are the special mode `\ttmkey{master}{mode}'.
Non-master mode tables, whose modes are types,
are typically dedicated to recognizing lexemes
of the indicate type.  Master mode atom tables are used to
dispatch to non-master mode tables.

Thus a simple scanner might have
one master table that dispatches to different non-master tables,
one to recognize identifiers, one to recognize numbers, one to
recognize whitespace, and one to recognize comments.

When the current lexical atom table is changed from a non-master mode
table to a master mode table, any non-zero length lexeme accumulated
so far is output as a lexeme whose type\label{KIND-OUTPUT}
equals
the mode of the non-master mode table.  Thus if an atom table of
mode `\verb|whitespace|' cannot recognized any atom and
the default instruction associated with it
changes the current atom table to a master mode table,
any non-zero length lexeme accumulated so far will
be output as a lexeme of type `\verb|whitespace|'.

When it is between lexemes that current atom table in the scanner state
is always a master mode table.  Master mode tables correspond to lexical
contexts.  A well designed language has only one main master mode
table, plus a few small master mode tables to handle error situations
such a premature new-line and premature end-of-file;
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.
Legacy languages
may have more master mode tables: C/C++ has several to handle
special lexical scanning of preprocessing lexemes;
see Appendix \itemref{C++-LEXICAL-PROGRAM}.

The standard scanner can report errors in one of two ways.  It may
simply output a lexeme with a type that indicates an error.  For
example, the character \verb|\| appearing outside a quoted string
might be returned as a 1-character lexeme of type `{\tt erroneous
character}'.  Alternatively a single atom may be reported as an
error of a given type without interrupting the normal operation
of the scanner.  For example, if \verb|\h| appears in a quoted
string, it may be reported as an erroneous atom of type
`{\tt bad escape sequence}'.  Otherwise this atom is processed
normally; it might, for example, be omitted from the lexeme
translation or be represented in that translation by the DEL
character (\verb|\u007F|).

\ikey{Instructions}{instruction!in lexical program}
that are associated with atom patterns can optionally do any
of the following:
\begin{itemize}
\item reduce the length of the matched atom
\item translate the reduced length atom to a different
character string within the lexeme translation
\item announce the reduced length atom as an erroneous atom of a given type
\item output the atoms accumulated so far as a lexeme of a given type
\item change the current atom table
\end{itemize}

More details and examples are given in the next section.

A \key{lexical program} is a set of character pattern definitions
and atom tables.  A lexical program can include another lexical program.
The top level lexical program must begin with a master-mode atom
table that serves as the initial atom table.


\subsection{Lexical Programs}

The lexemes in a lexical program are specified on
\pagref{LEXEME-PROGRAM-LEXEMES} and
and the syntax of a lexical program is specified on
\pagref{LEXEME-PROGRAM-SYNTAX-1} and
\pagref{LEXEME-PROGRAM-SYNTAX-2}.

\begin{figure*}[!p]
\begin{tabular}{p{2.2in}rl}
\emkey{lexeme} & ::= & {\em symbol} $|$ {\em number}
\\[0.5ex]
\emkey{symbol} & ::= & {\em word} $|$ {\em mark} $|$ {\em quoted-string}
	         $|$ {\em separator}
\\[0.5ex]
\emkey{word} & ::= & {\em word-character} {\em word-character}\,$^\star$ 
\\[0.5ex]
\emkey{mark} & ::= & {\em mark-character} {\em mark-character}\,$^\star$
\\[0.5ex]
\emkey{number-lexeme} & ::= &
        {\em number-character} {\em number-character}\,$^\star$
\\[0.5ex]
\emkey{quoted-string} & ::= &
    \verb|"| {\em character-representative}\,$^\star$ \verb|"|
\\[0.5ex]
\emkey{separator} & ::= & {\em separator-character}
\\[0.5ex]
\emkey{white-space} & ::= & {\em white-space-character}
                            {\em white-space-character}\,$^\star$
\\[2ex]
\emkey{word-character} & ::= & {\em letter} \\
		       & $|$ & \verb|'| followed by a letter \\
\emkey{letter} & ::= & {\em lower-case-letter} $|$ {\em upper-case-letter} \\
\emkey{lower-case-letter} & ::= &
                               \verb|a|%
			    $|$\verb|b|%
			    $|$\verb|c|%
			    $|$\verb|d|%
			    $|$\verb|e|%
			    $|$\verb|f|%
			    $|$\verb|g|%
			    $|$\verb|h|%
			    $|$\verb|i|%
			    $|$\verb|j|%
			    $|$\verb|k|%
			    $|$\verb|l|%
			    $|$\verb|m|%
			    $|$\verb|n|%
			    $|$\verb|o|%
			    $|$\verb|p|%
			    $|$\verb|q|%
			    $|$\verb|r|%
			    $|$\verb|s|%
			    $|$\verb|t|%
			    $|$\verb|u|%
			    $|$\verb|v|%
			    $|$\verb|w|%
			    $|$\verb|x|%
			    $|$\verb|y|%
			    $|$\verb|z|
			    \\
\emkey{upper-case-letter} & ::= &
                               \verb|A|%
			    $|$\verb|B|%
			    $|$\verb|C|%
			    $|$\verb|D|%
			    $|$\verb|E|%
			    $|$\verb|F|%
			    $|$\verb|G|%
			    $|$\verb|H|%
			    $|$\verb|I|%
			    $|$\verb|J|%
			    $|$\verb|K|%
			    $|$\verb|L|%
			    $|$\verb|M|%
			    $|$\verb|N|%
			    $|$\verb|O|%
			    $|$\verb|p|%
			    $|$\verb|Q|%
			    $|$\verb|R|%
			    $|$\verb|S|%
			    $|$\verb|T|%
			    $|$\verb|U|%
			    $|$\verb|V|%
			    $|$\verb|W|%
			    $|$\verb|X|%
			    $|$\verb|Y|%
			    $|$\verb|Z|
\\[0.5ex]
\emkey{mark-character} & ::= &
                                \verb|+|%
		             $|$\verb|-|%
		             $|$\verb|*|%
		             $|$\verb|/|%
		             $|$\verb|\|%
		             $|$\verb|~|%
		             $|$\verb|@|%
		             $|$\verb|#|%
		             $|$\verb|$|%
		             $|$\verb|%|%
		             $|$\verb|^|%
		             $|$\verb|&|%
		             $|$\verb|=|%
		             $|$\verb/|/%
		             $|$\verb|<|%
		             $|$\verb|>|%
		             $|$\verb|_|%
		             $|$\verb|!|%
		             $|$\verb|?|%
			     $|$\verb|:| \\
		     & $|$ & \verb|.| not followed by a {\em digit} \\
		     & $|$ & \verb|/| not surrounded by {\em digits}
\\[0.5ex]
\emkey{separator-character} & ::= &
		        \verb|(|
	       	    $|$ \verb|)|
	       	    $|$ \verb|[|
	       	    $|$ \verb|]|
	       	    $|$ \verb|{|
	       	    $|$ \verb|}|
	       	    $|$ \verb|;|
	       	    $|$ \verb|`| \\
		& $|$ & \verb|,| not surrounded by {\em digits} \\
		& $|$ & \verb|'| not followed by a letter 
\\[0.5ex]
\emkey{number-character} & ::= & {\em digit} \\
		& $|$ & \verb|.| followed by by a {\em digit } \\
		& $|$ & \verb|,| surrounded by {\em digits} \\
		& $|$ & \verb|/| surrounded by {\em digits} \\
\emkey{digit} & ::= &
                   \verb|0|%
		$|$\verb|1|%
		$|$\verb|2|%
		$|$\verb|3|%
		$|$\verb|4|%
		$|$\verb|5|%
		$|$\verb|6|%
		$|$\verb|7|%
		$|$\verb|8|%
		$|$\verb|9| 
\\[0.5ex]
\emkey{character-representative}
    & ::= & {\em graphic-character-other-than-backslash} \\
    & ::= & \verb|\| {\em graphic-character-other-than-slash}$^\star$
            \verb|/| \\
\emkey{graphic-character} & ::= &
    {\em non-whitespace-non-control-character} \\
\emkey{backslash} & ::= & \verb|\| \\
\emkey{slash} & ::= & \verb|/|
\\[0.5ex]
\emkey{white-space-character}
    & ::= & {\em horizontal-space-character} \\
    & $|$ & {\em vertical-space-character} \\
\emkey{horizontal-space-character} & ::= &
    {\em space} $|$ {\em horizontal-tab} \\
\emkey{vertical-space-character} & ::= &
    {\em line-feed} $|$ {\em vertical-tab} $|$ {\em form-feed}
\end{tabular}
\label{LEXEME-PROGRAM-LEXEMES}
\end{figure*}

\begin{figure*}[!p]
\begin{tabular}{p{2.2in}rl}
\emkey{name}
    & ::= & \{ {\em word} $|$ {\em quoted-string} \} \\
    &     & \{ {\em word} $|$ {\em number} $|$ {\em quoted-string} \}$^\star$
\end{tabular}

\begin{tabular}{p{2.2in}rl}
\emkey{lexical-program} & ::= &
	{\tt begin} {\em program-name} {\tt lexical program;}\\
	& &  ~~~~{\em lexical-program-unit}$^\star$ \\
	& & {\tt end} {\em program-name} {\tt lexical program};
\\[1ex]
\emkey{program-name} & ::= & {\em name}
\\[1ex]
\emkey{lexical-program-unit}
	& ::= & {\em cpat-definition} \\
	& $|$ & {\em atom-table-definition} \\
	& $|$ & {\em program-inclusion}
\\[1ex]
\emkey{program-inclusion} & ::= & {\tt include} {\em program-name}
				  {\em remove-clause}$^\star$ {\tt ;}
\\[1ex]
\emkey{remove-clause} & ::= & {\tt remove} {\em atom-table-name} \\
                      & $|$ & {\tt remove} {\tt "}{\em cpat-name}{\tt "}
\\[1ex]
\multicolumn{3}{l}{~~~~~~Note: `{\em cpat}\,' abbreviates
                               `{\em character-pattern}\,'}
\\[1ex]
\emkey{cpat-definition} & ::= &
	{\tt "}{\em cpat-name}{\tt "} {\tt =}
		{\em cpat-expression} {\tt ;}
\\[1ex]
\emkey{cpat-name} & ::= &
	{\tt <}{\em letter}$^+$\{{\tt -}{\em letter}$^+$\}$^\star${\tt >}
\\[1ex]
\emkey{cpat-expression} & ::= &
	{\em cpat-term}
	\{ {\tt |} {\em cpat-term} \}$^\star$ \\
       & $|$ &
	{\em cpat-term}
	\{ {\tt \&} {\em cpat-term} \}$^\star$
\\[1ex]
\emkey{cpat-term} & ::= & {\em cpat-factor} $|$ \TILDE {\em cpat-factor}
\\[1ex]
\emkey{cpat-factor} & ::= & {\tt "}{\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em quotable-character}{\tt -}%
		                   {\em quotable-character}{\tt "} \\
		    & $|$ & {\tt "}{\em cpat-name}{\tt "} \\
		    & $|$ & {\tt (} {\em cpat-expression}
		                {\tt )}
\\[1ex]
\emkey{quotable-character} & ::= & 
	any quotable UNICODE character representative
\\[1ex]
\emkey{atom-table-definition} & ::= &
	{\tt begin} {\em atom-table-name}
		    {\tt atom table} {\tt ;} \\
	& &  ~~~~{\em mode-option} \\
	& &  ~~~~{\em atom-table-entry}$^\star$ \\
	& &  ~~~~{\em default-instruction-option} \\
	& & {\tt end} {\em atom-table-name} {\tt atom table;}
\\[1ex]
\emkey{atom-table-name} & ::= & {\em mode} $|$ {\em type}
\\[1ex]
\emkey{type} & ::= & {\em name} \begin{tabular}[t]{@{}r@{~}l@{}}
                                     except & {\tt master} \\
					 or & {\tt scan error} \\[1ex]
				    \end{tabular}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-1}
\end{figure*}

\begin{figure*}[!t]
\begin{tabular}{p{2.2in}rl}
\emkey{mode} & ::= &  {\tt master} $|$ {\em type}
\\[1ex]
\emkey{mode-option} & ::= & {\em empty} $|$ {\tt mode} {\em mode} {\tt ;}
                                        $|$ {\tt type} {\em type} {\tt ;}
\\[1ex]
\emkey{default-instruction-option}
	& ::= &  {\em empty} $|$ {\em instruction}
\\[1ex]
\emkey{atom-table-entry}
	& ::= & {\em atom-pattern} {\em instruction-group} {\tt ;}
\\[1ex]
\emkey{atom-pattern} & ::= &
	{\tt "}\{{\em quotable-character}$|${\em cpat-name}\}$^\star${\tt "}
\\[1ex]
\emkey{instruction-group}
	& ::= & {\em instruction}
	        \{ {\tt else} {\em instruction} \}$^\star$

\\[1ex]
\emkey{instruction} & ::= & {\em instruction-component}$^+$
\\[1ex]
\emkey{instruction-component}
	& ::= & {\tt accept} \\
	& $|$ & {\tt keep} {\em natural-number} \\
	& $|$ & {\tt translate} {\em translation-string} \\
	& $|$ & {\tt translate hex} \begin{tabular}[t]{l}
			{\em natural-number} {\em natural-number} \\
		        {\em cpat-option}
			\end{tabular} \\
	& $|$ & {\tt translate oct} \begin{tabular}[t]{l}
			{\em natural-number} {\em natural-number} \\
		        {\em cpat-option}
			\end{tabular} \\
	& $|$ & {\tt error} {\em type} \\
	& $|$ & {\tt output} {\em type} \\
	& $|$ & {\tt goto} {\em atom-table-name} \\
	& $|$ & {\tt call} {\em atom-table-name} {\em return-vector-option} \\
	& $|$ & {\tt return} {\em return-index-option} \\
\\[1ex]
\emkey{translation-string} & ::= & {\em quoted-string}
\\[1ex]
\emkey{cpat-option} & ::= & {\em empty} $|$ {\tt "}{\em cpat-name}{\tt "}
\\[1ex]
\emkey{return-vector-option}
    & ::= & {\em empty} \\
    & $|$ & {\tt (}{\em atom-table-name}
                      \{ {\tt ,} {\em atom-table-name} \}$^\star$ {\tt )}
\\[1ex]
\emkey{return-index-option}
    & ::= & {\em empty} $|$ {\tt (} {\em natural-number} {\tt )}
\end{tabular}
\label{LEXEME-PROGRAM-SYNTAX-2}
\end{figure*}

An example lexical program that recognizes
whitespace and quoted strings without escapes is given
on \pagref{EXAMPLE-LEXEME-PROGRAM}.

\begin{figure*}[!p]
\addtolength{\baselineskip}{-0.4ex}
\begin{indpar}\begin{verbatim}
begin example lexical program;

"<whitespace-char>" = " " | "\lf/" | "\ht/" | "\vt/" | "\ff/";

begin master atom table;
    "<whitespace-char>" goto whitespace;
    "\"/" translate "" goto quoted string;
    "<other>" output bad character;
    output end of file;
end master atom table;

begin whitespace atom table;
    "<whitespace-char>" accept;
    goto master;
end whitespace atom table;

begin quoted string atom table;
    "\"/" translate "" goto master;
    "\lf/" keep 0 goto premature end of line;
    "<other>" accept;
    goto premature end of file;
end quoted string atom table;

include premature tables;

end example lexical program;

begin premature tables lexical program;
    // Stuff to include.

begin premature end of line;
    mode master;
    "\lf/" output premature end of line
         goto master;
end premature end of line;

begin premature end of file;
    mode master;
    output premature end of file;
end premature end of file;

end premature tables lexical program;
\end{verbatim}\end{indpar}
\label{EXAMPLE-LEXEME-PROGRAM}
\end{figure*}

A \emkey{lexical-program} consists of a sequence of
{\em character-\EOL pattern-\EOL defi\-ni\-tions},
{\em atom-\EOL table-\EOL defi\-ni\-tions},
and {\em program-inclusions}.  These define character pattern sets
and atom tables, and include in the lexical program definitions from
other previously defined lexical programs.

A \emkey{program-inclusion} names a previously defined lexical program
whose definitions are to be included in the current lexical program
at the point of the {\em program-inclusion}.
There is a simple example of a program inclusion at the end of
the {\tt example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.
Identical definitions
may be repeated without error,
as can happen when one program includes two each of
which include the same third program.
A {\em program-inclusion} can have
\emsmkey{remove-clause}s{in {\em program-inclusion}}
each of which removes a named definition from the set of included
definitions.  This is the only way to resolve conflicts between
definitions.

A \emkey{character-pattern-definition} (abbreviated as
\emkey{cpat-definition}) assigns a set of characters to a
{\em character-pattern-name}.  The latter is just a string of
letters and hyphens (\verb|-|) surrounded by angle brackets (\verb|< >|)
with hyphens occurring only between letters.  Examples:
\verb|<digit>| and \verb|<line-break>|.

The character set is denoted by a \emkey{character-pattern-expression}.
The simplest character pattern
expression is just a single {\em quotable-character} in quotes, which denotes
the character set containing only the quoted character.  Examples:
\verb|"0"| and \verb|"+"|.  The next simplest is two {\em quotable-characters}
separated by a hyphen (\verb|-|) denoting the character set consisting
of all characters in the range from the first to the second of the two
characters.  Examples: \verb|"0-9"| and \verb|"A-Z"|.  The characters
are ordered according to their 32 bit unsigned UNICODE value, and the
second of the two characters must not be smaller than the first.

A {\em quotable-character} is a representative of a single UNICODE
character that can be used inside quotes (\verb|"|).
Printable ASCII characters represent themselves.  Other characters
are represented by sequences started with backslash (\verb|\|).
For example, a line feed can be represented by any of the
following: \verb|\n|, \verb|\0a|,
\verb|\00a|, \ldots, or \verb|\00000000a|.

A quoted {\em character-pattern-name} denotes the character set associated
with that name by a \underline{previous} {\em character-pattern-definition}.

The \verb/|/, \verb|&|, and \verb|~| operators and can be used to take
the union, intersection, and complements of character sets.  The complement
is relative to the universe of all 32 bit unsigned integer UNICODE
character codes.  Thus \verb|~ "b-y"| denotes the same character set as
\verb$"\0/-a" | "z-\0ffffffff/"$.

Parentheses may be used in {\em character-pattern-expressions} as is
normal in algebraic expressions.
Note that the \verb/|/ and \verb|&| operators cannot be used together
in the same expression without intervening parentheses as neither
takes precedence over the other.  This is done to prevent ambiguity.

Some example {\em character-pattern-definitions} are:

\begin{indpar}\begin{verbatim}
"<hex-digit>" = "0-9" | "a-f" | "A-F";
"<non-line-break-char>" = ~ "\lf/" & ~ "\vt/" & ~ "\ff/";
"<quotable-char>" = "\020/-\07e/" & ~ "\"/" & ~ "\\/";
"<whitespace-char>" = " " | "\lf/" | "\vt/" | "\ff/" | "\ht/" | "\cr/";
"<source-character>" =
    ( "\020/-\07e/" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";
\end{verbatim}\end{indpar}

An {\em atom-table-definition} specifies an {\em atom-table-name},
a {\em mode} for the table, a set of {\em atom-table-entries}
each containing an {\em atom-pattern} and an {\em instruction},
and an optional {\em default-instruction} that is executed when
no atom is recognized by any of the table entries.

The {\em mode} of an atom table can be either a {\em type} or can be
the special `\ttmkey{master}{atom table mode}' mode.  If it is a
{\em type} then it is used as the {\em type} of any lexeme recognized
by the table (not all tables recognize lexemes).  See
\pagref{KIND-OUTPUT} for a description of how modes and types are used

The {\em mode} of an atom table is the same as the {\em atom-table-name}
unless a non-empty {\em mode-option} is given at the beginning of the
{\em atom-table-definition}.  The `{\tt premature end of line}' atom
table on \pagref{EXAMPLE-LEXEME-PROGRAM} is an example
of an atom table with a {\em mode-option}.

The first atom table in a lexical program must have `{\tt master}'
mode, and will become the current atom table when the scanner
is initialized.  This table is typically named `{\tt master}',
as it is in the {\tt example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.

Each \emkey{atom-table-entry} contains an {\em atom-pattern} and
an {\em instruction-group}.  The \emkey{atom-pattern} is matched against
the remaining input characters.  The pattern consists of a sequence
of {\em quotable-characters}, each of which match only themselves,
and {\em character-pattern-names}, each of which match any character
in the named set of characters.  Thus
\begin{center}
\verb|"\\/0<hex-digit><hex-digit>/"|
\end{center}
matches 5-character atoms consisting of a \verb|\| followed by an
\verb|0| followed by two characters each in the character set
named by \verb|<hex-digit>| followed by a \verb|/|.
Note that each {\em atom-pattern}
only matches atoms of a particular length.


The special character pattern
{\tt \bf \LESSTHAN other\GREATERTHAN}%
\index{other@{\tt \LESSTHAN other\GREATERTHAN}}%
\label{<OTHER>}
can be used in an atom pattern to match any character not otherwise
matched.  More explicitly, in the atom pattern
\verb|"|$P$\verb|<other>|$Q$\verb|"|,
the prefix $P$\verb|<other>| matches any sequence of characters not matched by
any atom pattern of the form
\verb|"|$PCQ$\verb|"| in the same atom table,
where $C$ is a character pattern other than
\verb|<other>|.
There are several examples of this on \pagref{EXAMPLE-LEXEME-PROGRAM}.

There must be no sequence of characters that matches the
{\em atom-patterns} of two distinct {\em atom-table-entries}
in the same {\em atom} table.  Since {\em atom-patterns} can only
match atoms of a particular length, it is permissible for
a sequence of characters that matches one pattern to have a proper
initial segment that matches another pattern; in this case the
longer pattern takes precedence.  The order of {\em atom-table-entries}
in an {\em atom-table} is not significant.

The atom pattern \verb|""| which would recognize zero length atoms is
\underline{not} permitted, but the {\em default-instruction} at the
end of the atom table executes in the equivalent case where no atom
pattern in the table matches the remaining input.  In particular
the {\em default-instruction} always executes if the input has reached
an end of file.  This fact is used in the `{\tt quoted string atom table}'
on \pagref{EXAMPLE-LEXEME-PROGRAM}.

An {\em atom-pattern} in an atom table is associated with an
{\em instruction-group} that consists of one or more {\em instructions}
separated by {\tt else}'s.  Most {\em instruction-groups} contain just
a single {\em instruction}, so we will explain this first.
{\em Instruction-groups} with more than one instruction are associated
with {\em cpat-options} of {\tt translate} {\tt hex}/{\tt oct}
instruction components.

An \emmkey{instruction}{in atom-table-entry} in an {\em atom-table-entry}
specifies actions to be taken when an atom is recognized by the
{\em atom-pattern} of the entry.  The {\em instruction} consists of
a set of {\em instruction-components} each of which controls part of the
atom processing.  If there are no components, the default actions are
performed, which consist of just skipping over the atom in the input and
copying the atom to the translation buffer.

The {\em default-instruction} at the end of an atom table behaves as
if a zero length atom had been recognized.

The \ttmkey{accept}{in lexical program} {\em instruction-component}
accepts the
atom without translation or length change, skips over the atom in the
input, and copies the atom characters to the translation buffer.
It is incompatible with the {\tt keep} and {\tt translate} instruction
components.

In the absence of any {\tt keep} or {\tt translate}
instruction components, {\tt accept} must be given.

The `\ttmkey{keep}{in lexical program} $n$'
{\em instruction-component} causes the atom length
to be shortened to $n$.  For example, the atom table entry
\begin{center}
\verb|",<digit>" keep 1;|
\end{center}
will recognize a 1-character atom consisting of just a comma as long as
the comma is followed by character in the \verb|<digit>| character pattern
character set.  Atoms may not be lengthened by {\tt keep}.

There are three possible translate {\em instruction-components}, at most
one of which may be used.  These affect how the atom is placed into
the translation buffer, and are applied to the atom \underline{after}
any {\tt keep} is applied.  In the absence of any of these components,
the atom is copied `as-is' to the translation buffer.

A `\ttmkey{translate}{in lexical program} {\em translation-string}'
{\em instruction-component}
specifies a {\em quoted-string} of characters,
the {\em translation-string},
that is copied into the translation buffer instead of the atom.
A {\em translation-string} may be empty, as in the atom table entry
\begin{center}
\verb|"\"" translate "" goto master;|
\end{center}
which can be used to recognize the last \verb|"| of a quoted string, avoid
copying anything into the translation buffer, and then switch to the
`{\tt master}' atom table.  See the example on \pagref{EXAMPLE-LEXEME-PROGRAM}.

The `\ttmkey{translate hex}{in lexical program} $m$ $n$'
{\em instruction-component} ignores the
first $m$ and last $n$ characters of the atom and viewing the rest as
hexadecimal digits, converts these into an 32 bit unsigned integer
UNICODE character code, which is placed into the translation buffer
instead of the atom.  An example is the the atom table entry
\begin{center}
\verb|"\\/0<hex-digit><hex-digit>/" translate hex 2 1;|
\end{center}
which might be used to accept a character representative in a quoted string
and copy the appropriate hexadecimally related character code into
the translation buffer.  It is a scanner error if characters that
are supposed to be hexadecimal digits are not (but in our example
this cannot happen because the definition of \verb|<hex-digit>|
restricts these characters appropriately).

The `\ttmkey{translate oct}{in lexical program} $m$ $n$'
{\em instruction-component} is identical but
views the rest of the characters as octal and not hexadecimal.
An example use would be the atom table entry
\begin{center}
\verb|"\\/o<oct-digit><oct-digit><oct-digit>/" translate oct 2 1;|
\end{center}

The {\tt translate hex} and {\tt translate oct} components may end with
a {\em character-pattern} (the {\em cpat-option})
that tests the 32 bit unsigned character code
produced by the translation.  Such a test should only appear in an
{\em instruction} which is followed by an `{\tt else}' in an
\emmkey{instruction-group}{in lexical program}.
If the 32 bit unsigned character code is in
the character set defined by the {\em character-pattern}, the {\em instruction}
containing the {\em character-pattern} is executed and the rest of the
{\em instruction-group}, the part after the next `{\tt else}', is ignored.
But if the character code is not in the character set the instruction
containing the {\em character-pattern} is turned into a no-operation and
the first {\em instruction} after the next `{\tt else}' is executed in
its place.

An example use would be the atom table entry
\begin{indpar}
\verb|"\\/0<hex-digit><hex-digit><hex-digit><hex-digit>" translate hex 2 1| \\
\verb|    "<letter>" else| \\
\verb|    translate "" error bad character in identifier;|
\end{indpar}
which might be used to process an atom of the form \verb|\0XXXX| in
an identifier, accepting the atom as a legitimate representation of a
character if that character is a letter, and otherwise designating
the atom as an error and not putting anything in the translation buffer
(see below for the definition of the `{\tt error}' instruction component).

A `\ttmkey{error}{in lexical program} {\em type}\,' {\em instruction-component}
announces the current atom as an erroneous atom of the given {\em type}.
The atom remains part of the current lexeme,
and what is put in the translation buffer is governed
independently by translation instruction components.
The following are some examples:
\begin{indpar}\begin{verbatim}
"\\<other>" error bad escape sequence;
"\\<other>" translate "" error bad escape sequence;
"\\<other>" translate "\del/" error bad escape sequence;
\end{verbatim}\end{indpar}
These might be entries in an atom table for a quoted string.
All identify an atom consisting of a backslash followed by any
character, as long as the atom is not recognized by another entry
that does not have the \verb|<other>| character pattern (see
\pagref{<OTHER>}).
The first entry copies the entire 2-character atom, including the
backslash, into the translation buffer.  The second entry copies
nothing (the empty string \verb|""|) into the translation buffer.
The third entry copies the DEL character (hex code \verb|7f|)
into the translation buffer.  An alternative is the entry
\begin{indpar}\begin{verbatim}
"\\<other>" keep 1 error bad escape;
\end{verbatim}\end{indpar}
that reduces the atom size to 1 character, just the backslash,
which is announced as an error without its following character,
and copied to the translation buffer.  The character following
the backslash remains in the input and will part of the next
atom recognized.

The routine that announces an error atom is given the position
of the atom in the input stream, so characters surrounding the
atom may also be included in the announcement.  For example,
the line containing the atom may be printed with marks on the
characters of the atom.  So the fact that the erroneous atom
proper in the last example is just the backslash does not
prevent the character after the backslash from being included
in the error announcement.

An erroneous atom is different from an erroneous lexeme.
An erroneous lexeme is simply a lexeme whose {\em type}
indicates to the user of the lexical scanner that the lexeme is erroneous.
As such an erroneous lexeme is
handled by the lexical scanner just as any other lexeme would be:
i.e., the lexical scanner has no special knowledge of erroneous lexemes
and no special operations for detecting or announcing them.

A `\ttmkey{output}{in lexical program} {\em type}\,'
{\em instruction-component} emits the current lexeme
with the given {\em type}.  This
{\em instruction-component} must either be used
in a master mode atom table or combined with a 
{\tt goto} transferring to a master mode atom table.
This works even if the current lexeme is of zero length.
It may be used in the {\em default-instruction} of an atom table;
for example, at the top of \pagref{EXAMPLE-LEXEME-PROGRAM} the
{\tt master} atom table has `{\tt output end of file;}' as its
{\em default-instruction}, thereby outputting a zero length
lexeme with `{\tt end of file}' type whenever the input is at the
end of file.

As an example, the `{\tt master}' atom table at the top of
\pagref{EXAMPLE-LEXEME-PROGRAM} contains the entry:
\begin{indpar}\begin{verbatim}
"<other>" output bad character;
\end{verbatim}\end{indpar}
which causes an unrecognized character to be treated as a 1-character
lexeme of type `{\tt bad character}'.  The translation of this lexeme is
the character itself, but if the entry:
\begin{indpar}\begin{verbatim}
"<other>" translate "\del/" output bad character;
\end{verbatim}\end{indpar}
had been used instead the translation would have been the DEL character.

A `\ttmkey{goto}{in lexical program} {\em atom-table-name}\,'
{\em instruction-component} switches the current atom table after
the current atom is processed.  If the table switches from a table
of non-{\tt master} mode to one of {\tt master} mode,
if the instruction contains no `{\tt output}' component,
and if the current lexeme is of non-zero length, then the current
lexeme is output with the {\em type} of the non-{\tt master} mode
table: see \pagref{KIND-OUTPUT}.

A `\ttmkey{call}{in lexical program} {\em atom-table-name}\,'
{\em instruction-component} is just like `{\tt goto}' except
that it also pushes the identifier of the atom table in which
the `{\tt call}' occurs (the `caller') into the return stack.
The \key{return stack} is a stack of up to 8 atom table identifiers
used by the `{\tt call}' and `{\tt return}' instruction components.

A `\ttmkey{return}{in lexical program}'
{\em instruction-component} is just like `{\tt goto}' except
that uses the atom table identifier at the top of the return
stack to determine the next atom table.  This identifier is
also popped from the stack.

The return stack is emptied whenever the current atom table
becomes a master mode table.

A `{\tt call}' instruction can have an optional \key{return-vector}
which is used by a `{\tt return}' instruction with a \key{return-index}.
A {\em return-vector} is a list of {\em atom-table-names}.
A {\em return-index} is a natural number, {\tt 1}, {\tt 2}, etc., that
selects the corresponding element of the {\em return-vector} of the
`{\tt call}' instruction to which the `{\tt return}' instruction is
returning.  This permits the `{\tt return}' instruction to return to
an atom table other than the one containing the `{\tt call}' instruction.
For example, if `{\tt call t(x,y,z)}' called an atom table, in that
table `{\tt return}' would return to the atom table containing the
`{\tt call}' instruction, while `{\tt return(2)}' would return to
atom table {\tt y}.


The `{\tt call}' and `{\tt return}' instruction components
permit a non-master atom table to be shared among different
master tables.  For example, a non-master table to scan
a comment lexeme may be shared among several master tables;
see Appendix \itemref{C++-LEXICAL-PROGRAM} for examples.

The `{\tt call}' and `{\tt return}' instruction components
also permit a non-master atom table to be shared among different
non-master tables.  For example, a table to scan escape sequences
may be shared among several atom tables dedicated to scanning
different types of quoted strings.
Again Appendix \itemref{C++-LEXICAL-PROGRAM} has examples.

The `{\tt call}' and `{\tt return}' instruction components
add nothing new to the lexical scanning language, since they
cannot be used recursively (due to limits on the size of the
return stack), and they can always be eliminated by making
copies of the called tables with hard coded returns.
But for certain languages these instruction components
substantially reduce the size of the lexical program.

\section{Parsing}

The parser is a sequence of passes each of which takes an input
stream and produces and output stream.  The components of the
streams can be lexemes, subexpressions, or expression components
such as numbers, operators, and punctuation.  For better
modularity all stream components are called \skey{token}s,
and the data is organized as streams of tokens.

\subsection{Token Streams}

A token can have any of the following components.

\begin{indpar}
\begin{tabular}{p{1in}p{4in}}
\tt kind	& One of: \\
        	& ~~~~{\tt lexeme} \\
        	& ~~~~{\tt name} \\
        	& ~~~~{\tt expression}
\\[1ex]
		& A {\tt name} is a symbol such as `{\tt x}'
		  or `{\tt +}', or a natural number, or a
		  list of names (called a label).
\\[1ex]
		& An {\tt expression} is a list of names and
		  expressions and in addition a map from names
		  to values that are names or expressions.
\\[1ex]
\tt type	& For lexemes, the type of the lexeme. \\[0.3ex]
		& For names, one of: \\
		& ~~~~{\tt symbol} \\
		& ~~~~{\tt natural\_number} \\
		& ~~~~{\tt label} \\
\end{tabular} \\[1ex]
\begin{tabular}{p{1in}p{4in}}
\tt string	& For lexemes, the character string of the lexeme.
\\[1ex]
\tt ident	& For names and expressions,
                  a 32 or 64 bit numeric or pointer
		  value that denotes the name or expression.
		  Two names are different if and only if they
		  have different idents, so
		  names can be compared by comparing their idents.
		  No name can have the same ident as an expression.
\\[1ex]
		& It is possible to recover from the ident of
		  a name the character string of a symbol, the value of
		  a natural number, or the name list of a label.
		  It is possible to recover from the ident of
		  an expression the list elements and the name/value map
		  of the expression.
		  But these things are rarely done by the parser.
\\[1ex]
\tt hash	& A 32 bit unsigned integer that is a randomized hash of
          	  the character string of a symbol, a hash of the value of a
		  natural number, or a hash of the names of a label.  Usable to
		  make hash tables in which names are keys.
\end{tabular} \\[1ex]
\begin{tabular}{p{1in}p{4in}}
\tt positions	& The positions of the first and last character of the
	          token in the input text.  It is possible to recover
		  from a position the column number within a line
		  and a line ident, where two line idents are equal
		  if and only if the file lines they denote are the same.
		  A printed representation of a line ident may also
		  be obtained for error messages.
\end{tabular}
\end{indpar}

Tokens of `name' kind are called \skey{name token}s, or
just plain `names'.
Tokens of `expression' kind are called \skey{subexpression token}s, or
just plain `subexpressions'.  The parser passes may take a sequence of tokens
and replace it by a name or subexpression token, but once this is done,
the parser passes never break the name or subexpression tokens apart to
look at their components.  Name and subexpression tokens may be be broken
apart in error messages, however.

\subsection{Token Streams}

Tokens are organized into bidirectional \skey{token list}s and
into `\skey{token stream}s' that are segments of token lists.

Tokens are linked together bidirectionally into token lists.  It is
actually possible to design a parser that is a set of passes all of
which put tokens in the same token list.

A token stream has the following components:

\begin{indpar}
\begin{tabular}{p{1in}p{4in}}
\tt first	& Pointer at the first token in the stream.
\\[1ex]
\tt last	& Pointer at the current last token in the stream.
\\[1ex]
\tt eos		& True if the last token is really the last token
		  of the stream, and false if there may be more
		  tokens.
\\[1ex]
\tt get		& Function to call to get more tokens and add them
		  to the end of the stream, if {\tt eos} is false.
		  A parser pass provides this function to users of
		  streams the pass produces, and much of the execution
		  of the parser pass actually occurs inside this function.
\end{tabular}
\end{indpar}

At any given time a token must be in exactly one token stream.

All the tokens in one token stream are in the same token list.

A parser pass receives a stream as input produces a stream as output.
If the parser pass decides to use its input stream token list as its
output stream token list, it may move tokens from input to output
by merely adjusting the `{\tt first}' and `{\tt last}' components
of the streams.

Because streams are highly tailored by the parser passes that produce
them, the token stream class is an abstract base class ith the `{\tt get}'
function as a virtual function.

\subsection{Parser Passes}

A \key{parser pass} is a function that takes as input a stream (i.e., a
sequence) of tokens and produces as output a stream of tokens.
Parser passes call other parser passes to process streams of tokens.

The LL standard parser passes are:

\begin{indpar}
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
operator & Parses expressions with computational operators (e.g., \verb|+| and
\verb|*|).
\\[1ex]
text & Parses text expressions containing named brackets
and \verb|<>| operators (e.g.
\verb/<b|/\ldots\verb/|b>/ and \verb/<p>/).
\end{tabular} \\
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
explicit subexpression & Identifies explicitly bracketed subexpressions.
\\[1ex]
lexeme replacement & Replaces sequences of lexemes with other
sequences of lexemes (e.g., replaces plurals by singulars).
\end{tabular} \\
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
radix number recognition & Recognizes numbers with non-decimal radixes.
\\[1ex]
scientific number recognition & Recognizes numbers with exponents.
\\[1ex]
number pair recognition & Recognizes pairs of numbers (e.g., \verb|4 1/2|).
\end{tabular} \\
\begin{tabular}{@{}p{1.9in}p{4.0in}@{}}
number unit grouping & Groups numbers and numeric units
(e.g., \verb|4ft 5in|).
\\[1ex]
\begin{tabular}[t]{@{}l@{}}
unit multiplication \\
insertion 
\end{tabular} & Inserts multipliers between numbers and
numeric units (e.g., \verb|4*ft| and \verb|$*4.99|).
\end{tabular}
\end{indpar}


A parser pass can call another parser pass.  For example,
the explicit subexpression parser recursively calls itself when
it recognizes an explicit subexpression beginning bracket.

The input and output of a parser pass is a stream of tokens.
When a parser pass P1 calls another parser pass P2, P1 provides the P2
with an input stream that holds tokens at the beginning
of the stream and provides a `{\tt get}' function that can be called by P2
to add tokens to the end of its input stream.  This `{\tt get}' function
is actually a continuation function for pass P1.

\subsection{Parser Symbol Table}

The \key{parser symbol table} is conceptually a stack of
\skey{parser definition}s.  Each parser definition has the following
components:

\begin{indpar}
\begin{tabular}{p{1in}p{4in}}
\tt key		& A sequence of names that identifies the definition.
\\[1ex]
\tt type	& The type of the definition.
\\[1ex]
\tt selectors	& A set of \skey{parsing selector}s that determine if
		  the definition is active.
\\[1ex]
\tt next	& Pointer to the next definition in the stack that
                  has the same key.
\end{tabular}
\end{indpar}

Tokens that are lexemes are converted to names if possible before the
first parser pass.  To use definitions, in most cases
a parser pass simply takes the sequence of name tokens
beginning at the current point the pass's input token stream
and looks it up in the symbol table.  The parser pass also has
at any given time a selector set, and it checks a definition to
see if the parser pass and the definition share a selector.  If yes,
the definition is used by the pass, and is said to be
\mkey{active}{definition}.
If no, the definition is said to be \mkey{inactive}{definition},
and the next definition
in the definition stack with the same key is examined.

If there are several sequences of name tokens that match active definitions
at the current point in the token stream, the longest is used.  If the
token at the current point in the token stream is not a name, then
\underline{no} definition can be referenced.

A hash table is maintained to permit passes to quickly look up
parsing definitions given the named tokens at the pass's current
token stream position.

A Parser pass also generally ignores definitions that are not of
a type appropriate to the pass.
Some parser passes do not use the current tokens as a key to look up in
the symbol table, but look up all definitions of a particular type.
An example is the lexeme replacement pass, that uses lexeme
replacement definitions, which
provide their own
mechanisms for determining whether or not the tokens beginning
at the current token stream position should be replaced.
For efficiency this pass
keeps a separate hash table that memoizes the results
for tokens that have been recently seen.  One consequence of this is
that making changes to lexeme replacement definitions is less efficient
than making changes to other kinds of definitions.

\newpage

\appendix

\section{Standard Lexical Program}
\label{STANDARD-LEXICAL-PROGRAM}

\begin{indpar}
\begin{verbatim}
begin standard lexical program;

"<ascii-letter>" = "a-z" | "A-Z";
"<digit>" = "0-9";
"<oct-digit>" = "0-7";
"<hex-digit>" = "0-9" | "a-f" | "A-F";

"<non-digit>" = ~ "<digit>";

// The following list of language specific letters is taken
// from Annex E of the Working Paper for Draft Proposed
// International Standard for Information Systems—Programming
// Language C++, 1996.

"<latin-letter>" = "\u00c0-\n00d6" | "\u00d8-\u00f6"
                 | "\u00f8-\u01f5" | "\u01fa-\u0217"
                 | "\u0250-\u02a8" | "\u1ea0-\u1ef9";

. . . . . letter character pattern definitions omitted . . . . .

"<CJK-letter>" = "\uf900-\ufa2d" | . . .  // Details omitted

// Context sensitive character classifications, e.g.,
// classifying ' as a word character if it is followed by
// a letter, cannot be included in character pattern
// definitions, but are noted in comments.  They are
// accounted for by separate atom table entries below.

"<letter>" = "<ascii-letter>" | "<latin-letter>"
           | . . . | "<CJK-letter>";   // Details omitted

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@" | "#" | "$" | "%"
              | "^" | "&" | "=" | "|" | "<" | ">" | "_" | "!"
              | "?" | ":";
              //
              // Also \ not followed by u or U,
              //      . not followed by a digit
              //      / not surrounded by digits

"<non-u-char>" = ~ "u" & ~ "U";
"<non-slash-char>" = ~ ";";

"<separator-char>" = "(" | ")" | "[" | "]" | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter

"<line-break-char>" = "\n" | "\v" | "\f" | "\r";

"<non-line-break-char>" = ~ "<line-break-character>";

"<horizontal-space-char>" = " " | "\t";

begin master atom table;

   // Whitespace is separated out into 3 types of lexeme:
   //
   //   `horizontal space'  spaces and horizontal tabs
   //   `line break'        linefeeds, carriage returns,
   //                       form feeds, and vertical
   //                       tabs
   //   `comments'          `//' up to just before next
   //                       line break
   //
   "//" call comment;
   "<horizontal-space-char>" call horizontal space;
   "<line-break-char>" call line break;

   "<word-char>" call word;
   "'<letter>" call word;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate hex 2 0 "<letter"> call word
        else keep 2 error bad escape sequence;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate hex 2 0 "<letter"> call word
        else keep 2 error bad escape sequence;

    "\\u" error bad escape sequence;
    "\\U" error bad escape sequence;

   "<mark-char>" call mark;
   "." call mark;  // ".<non-digit>"
   "/" call mark;  // "/<non-slash-char>"
   "\\" call mark; // "\\<non-u-char>"

   // We assume that the preceding text is not a digit
   // or the current input is not / or , followed by a digit.
   //
   "<digit>" keep 0 call natural number;
   ".<digit>" keep 1 call number;

   "<separator-char>" output separator;
   "," output separator;
   "'" output separator;        // "'<non-letter>"

   "\"" translate "" call quoted string;

   "<other>" output bad character;
   output end of file;

end master atom table;


// The below tables are entered from the master table
// with the first one or two characters scanned.


begin comment atom table;
   "<non-line-break-char>" accept;
   return;
end comment atom table;


begin horizontal space atom table;
   "<horizontal-space-char>" accept;
   return;
end horizontal space atom table;


begin line break atom table;
   "<line-break-char>" accept;
   return;
end line break atom table;


begin word atom table;

   "<word-char>" accept;
   "'<letter>" accept;

    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate hex 2 0 "<letter">
        else keep 0 return
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate hex 2 0 "<letter">
        else keep 0 return

   return;

end word atom table;

begin mark atom table;
   "<mark-char>" accept;
   ".<non-digit>" keep 1;
   "/<non-slash-char>" keep 1;
   "\\<non-u-char>" keep 1;
   return;
end mark atom table;

begin natural number atom table;

   "<digit>" accept;
   ".<digit>" keep 1 goto number;
   "<digit>/<digit>" keep 2 goto number;
   "<digit>,<digit>" keep 2 goto number;
   return;

end natural number atom table;

begin number atom table;

   // In order to recognize , and / surrounded by digits
   // as number atoms, entries to this table upon
   // recognizing "X<digit>" must do a `keep 1' so the
   // digit will be left to be recognized by
   // <digit>/<digit> or <digit>,<digit>.

   // Alternatively we could have a separate table
   // for the state where the last atom ended with
   // a digit.

   "<digit>" accept;
   ".<digit>" keep 1;
   "<digit>/<digit>" keep 2;
   "<digit>,<digit>" keep 2;
   return;

end number atom table;


begin quoted string atom table;

    "\"" translate "" return;   // End quoted string.

    "\\\"" translate "\"";
    "\\\n" translate "\n";
    "\\\r" translate "\r";
    "\\\t" translate "\t";
    "\\\b" translate "\b";
    "\\\f" translate "\f";
    "\\\v" translate "\v";
    "\\\\" translate "\\";
    "\\~"  translate " " ;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
                                translate hex 2 0;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
                                translate hex 2 0;
    "\\<line-break-char>"
        keep 1 error bad escape sequence;

    "<line-break-char>"
        goto bad end of line;
    "\\<other>" error bad escape sequence;

    "<other>" accept;

    goto bad end of file;

end quoted string atom table;


begin bad end of line;
    mode master;
    output bad end of line
           goto master;
end bad end of line;


begin bad end of file;
    mode master;
    output bad end of file
           goto master;
end bad end of file;


end standard lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{C++ Lexical Program}
\label{C++-LEXICAL-PROGRAM}

\begin{indpar}\begin{verbatim}
begin c++ lexical program;

// Before this lexical program is used the input should
// be preprocessed to
//
//    (1) Replace trigraph sequences.
//    (2) Eliminate carriage returns next to newlines.
//    (3) Eliminate backslash newline pairs.
//    (4) Replace any source file character that is not
//        one of the 96 `source characters' by a univer-
//        sal character name (\uXXXX or \UXXXXXXXX).
//
// After this lexical program is used the output should
// be post-processed to
//
//    (5) Perform C/C++ macro preprocessing (macro
//        expansion.
//    (6) Concatenate adjacent ordinary quoted strings
//        and adjacent wide quoted strings.

"<digit>" = "0-9";
"<oct-digit>" = "0-7";
"<hex-digit>" = "0-9" | "a-f" | "A-F";
"<non-digit>" = "_" | "a-z" | "A-Z";
    // I.e., in identifier.

"<ascii-letter>" = "a-z" | "A-Z";

"<space-char>" = " " | "\t" | "\v" | "\f";

"<source-character>" =
    ( "\u0020-\u007e" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";

"<sign>" = "+" | "-" ;

// The following list of language specific letters is
// taken from Annex E of the Working Paper for Draft
// Proposed International Standard for Information
// Systems—Programming Language C++, 1996.

"<latin-letter>" = "\u00c0-\n00d6" | "\u00d8-\u00f6"
                 | "\u00f8-\u01f5" | "\u01fa-\u0217"
                 | "\u0250-\u02a8" | "\u1ea0-\u1ef9";

. . . letter character pattern definitions omitted . . .

"<CJK-letter>" = "\uf900-\ufa2d" | . . .
    // Details omitted

"<letter>" = "<ascii-letter>" | "<latin-letter>"
           | . . . | "<CJK-letter>";
    // Details omitted

// Alternative operators that are not identifiers are
// translated.  E.g., <: becomes [ in the translation
// buffer.

// C/C++ preprocessing is hereafter abbreviated as `pp'.
//
// Because of pp control lines, lexical scanning is
// slightly context dependent.  There are several
// contexts, each corresponding to a different master
// atom table:
//
//    pp group master (initial master)
//        Used in line beginning situations to recognize
//        the # token that introduces a pp control line.
//    pp control line beginning master
//        Used to scan the beginning of a pp control
//        line.
//    pp include header name master
//        Used to scan the header name of an #include
//        statement.
//    pp define identifier name master
//        Used to scan the 
//        statement.
//    pp control line master
//        Used to scan the remainder of a pp control
//        line.  Recognizes the line ending line feed.
//    normal line master
//        Used to scan a non pp control line or the rest
//        of a pp control line that consists of just pp
//        tokens.
//
// The whitespace lexeme types are:
//
//    line feed (lexeme is "\n")
//    horizontal space
//    "/*" comment (include /* and */)
//    "//" comment (does not include ending line feed)
//    end of file (lexeme is "")
//    premature line feed (lexeme is "\n")
//    premature end of file (lexeme is "")
//
// This allows line feeds to be used to end pp control
// lines.  The `premature' lexemes are errors: the
// previous lexeme is treated as if there were no error
// (i.e., as if there were a ", ', */, etc.) and the
// next lexeme is a `premature ...' lexeme.

// Initial master is used only to start at pp group
// master.
//
begin initial master atom table;
    goto pp group master;
end initial master atom table;

begin horizontal space atom table;
    "<horizontal-space-char>" accept;
    return;
end horizontal space atom table;

begin "/*" comment atom table;
    "*/" return;
    "<other>" accept;
    goto premature end of file master;
end "/*" comment atom table;

begin "//" comment atom table;
    "\n" keep 0 return;
    "<other>" accept;
    goto premature end of file master;
end "//" comment atom table;

begin premature end of file master atom table;
    mode master;
    output premature end of file;
end premature end of file master atom table;

begin premature end of line master atom table;
    mode master;
    "\n" output premature newline
                goto pp group master;
end premature end of line master atom table;

begin pp group master atom table;
    mode master;
    "<horizontal-space-char>"
        call horizontal space;
    "/*" call "/*" comment;
    "##" output operator
         goto normal line master;
    "%:%:" translate "##" output operator
                          goto normal line master;
    "#" output punctuation
        goto pp control master;
    "%:" translate "#" output punctuation
                       goto pp control master;
    goto normal line master;
end pp group master atom table;

begin pp control master atom table;
    mode master;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "include<horizontal-space-char>" keep 7
        output identifier
        goto pp include header name master;
    "include/*" keep 7 output identifier
        goto pp include header name master;
    "define<horizontal-space-char>" keep 6
        output identifier
        goto pp define identifier master;
    "define/*" keep 6 output identifier
        goto pp define identifier master;
    goto normal line master;
end pp control master atom table;

begin include header name master atom table;
    mode master;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "<" translate "" goto bracketed header name;
    "\"" translate "" goto quoted header name;
    goto normal line master;
end include header name master atom table;

begin bracketed header name atom table;
    ">" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "'" error bad character in header name;
    "\"" error bad character in header name;
    "\\" error bad character in header name;
    "//" error bad character pair in header name;
    "/*" error bad character pair in header name;
    "<other>" accept;
    goto premature end of file master;
end bracketed header name atom table;

// Quoted header names are not the same as quoted
// strings, and cannot have escape sequences.
//
begin quoted header name atom table;
    "\"" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "'" error bad character in header name;
    "\\" error bad character in header name;
    "//" error bad character pair in header name;
    "/*" error bad character pair in header name;
    "<other>" accept;
    goto premature end of file master;
end quoted header name atom table;

begin define identifier master atom table;
    mode master;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "<non-digit>" goto defined identifier;
    goto normal line master;
end define identifier master atom table;

begin defined identifier atom table;
    type identifier;
    "<non-digit>" accept;
    "<digit>" accept;
    "(" keep 0 goto lparen master;
    goto normal line master;
end defined identifier atom table;

begin lparen master;
    mode master;
    "(" output lparen goto normal line master;
end lparen master;

begin normal line master atom table;
    mode master;
    "<horizontal-space-char>" call horizontal space;
    "/*" call "/*" comment;
    "//" call "//" comment;

    "<non-digit>" goto identifier;

    "<digit>" goto number;
    ".<digit>" goto number;

    "'" translate "" goto character literal;
    "L'" translate "" goto wide character literal;
    "\"" translate "" goto string literal;
    "L\"" translate "" goto wide string literal;

    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
            translate hex 2 0 goto identifier
            "<letter>"
            else output non-letter UNICODE error;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
            translate hex 2 0 goto identifier
            "<letter>"
            else output non-letter UNICODE error;

    "{" output punctuation;
    "}" output punctuation;
    "[" output punctuation;
    "]" output punctuation;
    "(" output punctuation;
    ")" output punctuation;
    ")" output punctuation;
    "#" output punctuation;
    "##" output punctuation;
    "+" output operator;
    "++" output operator;
    . . . other punctuation and operators omitted . . .

    "<other>" output erroneous character;
begin normal line master atom table;

begin identifier atom table;
    "<letter>" accept;
    "<digit>" accept;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
            translate hex 2 0 "<letter>"
            else keep 0 goto normal line master;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
            translate hex 2 0 "<letter>"
            else keep 0 goto normal line master;
    goto normal line master;
end identifier atom table;

begin number atom table;
    "<digit>" accept;
    "<non-digit>" accept;
    "e<sign>" accept;
    "E<sign>" accept;
    "." accept;
    goto normal line master;
end number atom table;

begin character literal atom table;
    "'" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "\\" keep 0 call escape character;
    "<other>" accept;
    goto premature end of file master;
end character literal atom table;

begin wide character literal atom table;
    "'" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "\\" keep 0 call escape character;
    "<other>" accept;
    goto premature end of file master;
end wide character literal atom table;

begin string literal atom table;
    "\"" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "\\" keep 0 call escape character;
    "<other>" accept;
    goto premature end of file master;
end string literal atom table;

begin wide string literal atom table;
    "\"" translate "" goto normal line master;
    "\n" keep 0 goto premature end of line master;
    "\\" keep 0 call escape character;
    "<other>" accept;
    goto premature end of file master;
end wide string literal atom table;

// This atom table is called when the next atom
// begins with \ and is in a character or string
// literal.
//
// We allow only a maximum of 8 hexadecimal digits
// after \x; 9 digits is an error.  The C++ standard
// permits any number of hexadecimal digits.
//
begin escape character atom table;
    "\\n" translate "\n" return;
    "\\t" translate "\t" return;
    "\\v" translate "\v" return;
    "\\b" translate "\b" return;
    "\\r" translate "\r" return;
    "\\f" translate "\f" return;
    "\\a" translate "\a" return;
    "\\\\" translate "\\" return;
    "\\?" translate "\?" return;
    "\\\"" translate "\"" return;
    "\\'" translate "'" return;
    "\\<oct-digit>"
        translate-oct 1 0 return;
    "\\<oct-digit><oct-digit>"
        translate-oct 1 0 return;
    "\\<oct-digit><oct-digit><oct-digit>"
        translate-oct 1 0 return;
    "\\x<hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\x<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit>"
        error too many hex digits after "\\x" return;
    "\\u<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\U<hex-digit><hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit><hex-digit>"
        translate-hex 2 0 return;
    "\\<other>" error bad escape sequence return;
end escape character atom table;

end c++ lexical program;
\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
