% The Layered Programming Languages
%
% File:         layered-introduction.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}
% \usepackage{pictex} (obsolete? not available under CentOS 7)
\usepackage{upquote} % (imported to local directory
                     % ; not available under CentOS 7)
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\RESERVE}[1][0.3in]%
    {\par\rule[-#1]{0in}{#1}\vspace*{-#1}\vspace*{-\parsep}\par}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@\TT{#1}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@\TT{#2}}}
\newcommand{\ttimkey}[3]{\TT{#1}\index{#2@\TT{#1}!#3}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@\TT{#1}!#2@\TT{#2}}}
\newcommand{\ttilkey}[3]{\TT{#1}\index{#2@\TT{#2}!#3@\TT{#3}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@\TT{#1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@\TT{.#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@\TT{.#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@\TT{[#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@\TT{[#1]}!#2}}

\newcommand{\ttsvkey}[1]{\TT{[\$~#1~\$]}\index{#1@\TT{[\$~#1~\$]}}}
\newcommand{\ttsvmkey}[2]{\TT{[\$~#1~\$]}\index{#1@\TT{[\$~#1~\$]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@\TT{<#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@\TT{<#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@\TT{#1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@\TT{#1}}}
\newcommand{\ttmindex}[2]{\index{#1@\TT{#1}!#2}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minlkey}[2]%
           {\TT{min::#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                          \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
Introduction to \\[0.5ex]
The Layered Programming Languages \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

May 26, 2017
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Overview}

This introduces the Layered Programming Languages:

\begin{center}
\begin{tabular}{l@{~~~~~~~~~~}p{5.0in}}
\key{L}	& The Lower Language, or L-Language. \\
	& A C level language with facilities for writing
	  C++ like libraries and strongly type checking their
	  usage but not their implementation.
\\[1ex]
\key{M}	& The Middle Language, or M-Language. \\
	& The L-Language plus libraries.
\\[1ex]
\key{H}	& The Higher Language, or H-Language. \\
	& An interpreted/compiled language extending the
	  M-language to something comparable to LISP and TCL.
\end{tabular}
\end{center}

This document gives a brief tutorial introduction for each
of these languages, and then specifies the common syntax
shared by all three languages.

There are a few fundamental principals that inform the design
of these languages:

\begin{indpar}
\key{Syntax Hypothesis}~~~~ People reason syntactically
rather than semantically, so language syntax is very important,
and the ability to extend syntax to support
new library functionality is very important.

\key{Type Checking Segregation Hypothesis}~~~~ A strongly typed
completely capable language is impossible.  What is possible is
to segregate code into small inline library functions that are not
type checkable, while code that uses these functions is
strongly type checkable.

\key{Distributed Modularity}~~~~ 
Enhancements made by non-communicating users can be fit together
without too much labor.\footnote{Solutions like using regular
expressions for lexical analysis and LL parsers do not appear to
meet this criteria.}
\end{indpar}

\section{Tutorial Introduction to the L-Language}

\section{Tutorial Introduction to the M-Language}

\section{Tutorial Introduction to the H-Language}

\section{Lexical Scanning}

The L-, M-, and H-Languages are each encoded as UTF-8 text
files (UTF-8 is an encoding of UNICODE that extends ASCII).
These files are read and converted to a sequence of lexemes
by a process known as lexical scanning.  A lexeme is a UTF-8
character string: e.g., `\TT{hello}', `\TT{+}', `\TT{;}',
`\TT{9.200}' are four lexemes.

The lexical scanner is written in the M-Language and can be
replaced.\footnote{As of 2015 the scanner is actually written
in C++.}  This section describes the standard scanner which
is driven by the lexical tables and is capable of scanning
lexemes of common languages such as C and C++.

The standard scanner attempts to be both machine and human
efficient.  It attempts to be \key{machine efficient} by being
deterministic\footnote{Unlike regular expression scanners.}
and attempts to be \key{human efficient} by supporting algorithms
that people can readily understand and hopefully quickly
learn to mimic.\footnote{A possibly non-verifiable goal.}

The standard scanner also tries to promote `\key{distributed modularity}',
meaning that enhancements made by non-communicating users are
more likely to fit together.\footnote{Regular expression grammars are
too unruly to meet this criterion.}

The standard scanner operates on an input stream of 32-bit
UNICODE characters.  Each character is associated with
a \mkey{position}{of character}\label{POSITION-OF-CHARACTER}
that specifies the location of the
character within its file.  Specifically, a position encodes
a line-within-file number and byte-within-line offset.
The standard scanner identifies a lexeme as a consecutive sequence
of input stream UNICODE 32-bit characters with
corresponding consecutive position values.

The \mkey{line number}{of input character} of a character is 1 plus the
number of {\em line-feeds} preceding the character.
The \mkey{byte offset}{of input character} of a character is the number
of bytes before the character but after the first {\em line-feed}
preceding the character, or after the beginning of input if there
is no such {\em line-feed}.  The first line in a file has line number \TT{1}
and the first character in a line has byte offset \TT{0}.

The standard scanner also computes an
\mkey{indent}{of input character}\label{INDENT-OF-CHARACTER}
for each input character.  This
is the sum of the columns taken by all the
characters before the character and after
the first {\em line-feed} preceding the
character, or after the beginning of input if there is no such {\em line-feed}.
The first character in a line has indent \TT{0}.

For the purpose of computing indents,
characters in UNICODE subcategories \TT{Mn} (combining marks)
and \TT{Me} (enclosing marks),
and {\em control-characters} that are not
{\em horizontal-space-characters}, take zero columns.  All other characters
take one column, except for horizontal tab, which takes from
1 to 7 columns, with tabs being set every 8 columns in the line,
so the indent of the character after a horizontal tab
is always divisible by 8.

However for the purposes of printing a line,
the column in which a character is printed
depends upon both the position of the character
and the format in which the line is printed, and may not be the
same as the character's indent.  For example,
horizontal tab may be printed as 1 to 7 blank columns or
in a single column as
{\tiny $\stackrel{\textstyle H~~~}{~~~T}$}.

The standard scanner also produces a translation of each
lexeme.  This may just be a copy of the 32-bit characters
in the lexeme, or it may have some changes, or `translations',
of some of these characters.  For example, the lexeme
\TT{"a line<LF>"} may have a translation that omits the
\TT{"}'s and converts the four characters \TT{<LF>} into
a single linefeed character.

When the standard scanner identifies a lexeme it also identifies
a `\mkey{type}{of lexeme}' for the lexeme.
For example, the lexeme \TT{9.35} may have type `\TT{numeric}'
while the lexeme \TT{"abc"} may have the type `\TT{quoted string}'.

At its most fundamental level the
standard scanner identifies lexical atoms in the input text.
A \key{lexical atom} is a single character (e.g., the letters
in an identifier or word), a short string of characters
(e.g., the 4-character atom \TT{<LF>} in a quoted string),
or in some cases a longer string of characters containing
a repetition of characters from some character set (e.g., an arbitrarily
long string of hexadecimal digits).

Lexical atoms are read left to right and
grouped by the scanner into \skey{lexeme}s.
Lexical atoms are the unit of backup in the scanner; recognition
of a lexical atom can fail after some number of characters, but
once it is recognized, the scanner cannot back up past a lexical atom.
This permits limited look ahead in lexical scanning.  For example,
in some application
the string \TT{<LF>X} may begin with the lexical atom \TT{<LF>},
while the string \TT{<LFX} may begin with the lexical atom \TT{<}.
However, the syntax of lexical atom patterns is simple, so such
look ahead is limited.  Also, in most cases actual
lexical atoms are very short, and actual backup is rare.

Each atom is translated individually to produce an
\key{atom translation}.  Just as the sequence of atoms in a lexeme
comprise the lexeme, the sequence of their atom translations
comprises the translation of the lexeme.  Most atoms translate
to themselves.  An atom translation
may be the empty string, in effect omitting the atom from the
lexeme translation.  For example, the lexeme \TT{"x"} might
consist of three atoms, the first and last of which are \TT{"}
and translate into the empty string, whereas the middle atom
\TT{x} translates to itself.  Similarly \TT{"<LF>"} might also
consist of three atoms, with the middle atom \TT{<LF>} translating
to a single line feed character.

The scanner has a state containing a current point 
in the input UNICODE character stream,
a \key{current lexical table} identifier, a \key{current lexeme type}
which may be `\TT{none}', a \key{return stack}
of lexical table identifiers, and a \key{translation buffer} holding
translations of atoms.  A
\key{lexical table} is a set of atom patterns
that match atoms, and for each pattern an
\ikey{instruction}{lexical}
that determines what to do when the pattern is matched.
There is also a \key{default instruction} associated with
the lexical table that
determines what to do when no table pattern matches the next characters
in the input stream.

Most \skey{atom pattern}s\index{pattern!lexical atom} are fixed
length sequences of character patterns that match any sequence of
input characters of the same length as the atom pattern
if each input character of the sequence matches the corresponding
character pattern.  A \key{character pattern} is simply a
specification of a set of characters, e.g., letters or digits.
Thus one can construct an atom pattern that will recognize
single letters, or one that will recognize the sequence of
characters such as the 4-character sequence \TT{<LF>} which matches
the atom pattern \TT{"<" "LF" ">"}
(in which the quoted string has been broken into three parts to prevent
\TT{<LF>} being treated as representing a single line feed character)
or the 4-character sequence \TT{<0a>} which matches the atom pattern
\begin{center}
\TT{"<0<hex-digit>{}>"}
\end{center}
where \TT{<hex-digit>} names a character pattern matching characters
in the ranges \TT{0-9} and \TT{A-F}.

Atom patterns can also contain the special indicator
\TT{<repeat>} that allows an immediately preceding character pattern
to be repeated zero or more times.  Thus the pattern
\begin{center}
\TT{"<hex-digit><repeat>"}
\end{center}
recognizes any sequence of 1 or more \TT{<hex-digit>}'s (a single
\TT{<hex-digit>} followed by zero or more repetitions).

The atom patterns of a single lexical table must not conflict:
no character string can be recognized by two atom patterns of the
same lexical table.  However, a shorter atom pattern in a
table may match the initial segment of an atom matched by a longer
atom pattern in the table, in which case the longer pattern is
used for the atom.

The scanner operates by identifying the
longest sequence of characters beginning at the current input character
stream point that matches an atom pattern of the current lexical table.
This sequence of characters becomes
the next atom, and an instruction associated with its matching
atom pattern is then executed.  If no atom pattern can be matched,
the default instruction associated with the lexical table is executed instead.

A single lexical table instruction can do many things.
It can optionally reduce the length of a matched atom,
translated the matched atom to a different character string,
replace the matched atom and its translation,
or change the current lexical table.
An instruction can fail if the atom cannot be replaced or the
translated atom does not match a given pattern.
An \key{instruction group} is a sequence of instructions
such that the first successful instruction will be the effective
instruction in the group.  An instruction group, instead of a single
instruction, may be associated with an atom pattern or be the default
instruction of a lexical table.


There are four kinds of lexical tables:
\mkey{master}{lexical table} tables,
\mkey{lexeme}{lexical table} tables,
\mkey{sublexeme}{lexical table} tables, and
\mkey{atom}{lexical table} tables.
\ikey{Master tables}{master table}\label{MASTER-TABLE}
are used to dispatch to lexeme or sublexeme tables which
typically recognize lexemes.  Atom tables are used
to recognize atoms whose patterns are logically the union
of a finite set of patterns.

Thus a simple scanner might have
one master table that dispatches to different lexeme tables,
one to recognize identifiers, one to recognize numbers, one to
recognize whitespace, and one to recognize comments.

Lexeme tables have \ikey{types}{type!of lexeme table}.
When the current lexical table becomes a lexeme table,
the current lexeme type is set equal to the type of that table.
The `\TT{output} {\em type}' and `\TT{output none}'
instruction components can also be
used to change the current lexeme type.

Sublexeme tables are just like lexeme tables except they
have no associated type and do not reset the current lexeme type.

Upon finishing the execution of an instruction, if the
current lexical table is a master table,
the currently accumulated lexeme is output
with the current lexeme type, if that is not `\TT{none}', or the
currently accumulated lexeme is discarded if the current lexeme
type is `\TT{none}'.
The current lexeme type is reset to `\TT{none}' whenever
the current lexical table becomes a master table.

Thus if a lexeme table of
type `\TT{whitespace}' cannot recognized any atom and
the default instruction associated with it
changes the current lexical table to a master table,
the lexeme accumulated so far will
be output as a lexeme of type `\TT{whitespace}'.

When it is between lexemes the current lexical table in the scanner state
is always a master table.  Master tables correspond to lexical
contexts.  A well designed language has only one main master
table, plus a few small master tables to handle error situations
such as premature end-of-file;
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.
Legacy languages
may have more master tables: C/C++ has several to handle
special lexical scanning of preprocessing lexemes;
see Appendix \itemref{C++-LEXICAL-PROGRAM}.

The standard scanner can report errors in one of two ways.  It may
simply output a lexeme with a type that indicates an error.  For
example, the character \TT{\textbackslash} appearing outside a quoted string
might be returned as a 1-character lexeme of type `\TT{misplaced
character}'.  Alternatively a single atom may be reported as an
error of a given type without interrupting the normal operation
of the scanner.  For example, if \TT{<H>} appears in a quoted
string, it may be reported as an erroneous atom of type
`\TT{unrecognized escape}'.  Otherwise this atom will be processed
normally; it might, for example, be omitted from the lexeme
translation or be represented in that translation by the Unicode
Replacement Character (hex code \TT{FFFD}).

The algorithm for scanning a lexeme is given on in
Figure~\itemref{LEXICAL-SCANNING-ALGORITHM}.

\begin{boxedfigure}[!p]
\begin{center}
\begin{tabular}{l}
To scan a lexeme: \\
~~~~\begin{tabular}[t]{l}
    input: \begin{tabular}[t]{l}
           \TT{current} \TT{lexical} \TT{table} which must be a
	       \TT{MASTER} table \\
           \TT{input position} in input UNICODE character stream \\
           \end{tabular} \\
    set \TT{current} \TT{lexeme} \TT{type} = \TT{NONE} \\
    make \TT{return} \TT{stack} empty \\
    make \TT{translation} \TT{buffer} empty \\
    loop: \\
    ~~~~\begin{tabular}[t]{l}
        if \begin{tabular}[t]{l}
	   \TT{current} \TT{lexical} \TT{table} is a \TT{MASTER} table and  \\
           ~~~~~~~~\TT{current} \TT{lexeme} \TT{type} is \underline{not}
	       \TT{NONE}: \\
	   \end{tabular} \\
        ~~~~~~~~terminate loop \\
        if \TT{current} \TT{lexical} \TT{table} is a lexeme table: \\
        ~~~~~~~~set \TT{current} \TT{lexeme} \TT{type} to the
	        lexeme table type \\
        find the longest atom beginning at the \TT{input} \TT{position} \\
        ~~~~~~~~that matches an atom pattern in the \TT{current} \TT{lexical}
	        {table}, if any \\
        if an atom was found: \\
        ~~~~\begin{tabular}[t]{l}
            copy the atom to the end of the \TT{translation} \TT{buffer} \\
	    ~~~~and update the \TT{input position} to point after the atom \\
            execute the \TT{instruction} associated with the atom
	        pattern used \\
	    ~~~~(the simplest \TT{instruction} is `\TT{accept}' which does
	        nothing) \\
            \end{tabular} \\
	else: \\
	~~~~\begin{tabular}[t]{l}
	    execute the \TT{default instruction} associated with \\
	    ~~~~the \TT{current} \TT{lexical} \TT{table} \\
	    ~~~~(the simplest of these just change the
	     \TT{current} \TT{lexical} \TT{table})
            \end{tabular} \\
        \end{tabular} \\
    output: \begin{tabular}[t]{l}
            a lexeme consisting of the \TT{translation} \TT{buffer} contents \\
	    ~~~~(which may be empty) \\
	    ~~~~with the \TT{current} \TT{lexeme} \TT{type} as its type \\
	    ~~~~(which may \underline{not} be \TT{NONE}) \\
            the \TT{current} \TT{lexical} \TT{table}
	        (which is a \TT{MASTER} table) \\
            the \TT{input} \TT{position} (which has moved to just after
	        the lexeme) \\
            \end{tabular}
    \end{tabular}
\end{tabular}
\end{center}
\caption{Algorithm for Scanning a Lexeme}
\label{LEXICAL-SCANNING-ALGORITHM}
\end{boxedfigure}


A single \mkey{instruction}{in lexical program} can do the following:
\begin{itemize}
\raggedright
\item invoke an atom table to replace the matched atom and translate it
\item reduce the length of the matched atom (before it is copied to the
      \TT{translation} \TT{buffer}) (the length can be reduced to \TT{0})
\item translate the reduced length atom in the \TT{translation} \TT{buffer}
to a different character string
(otherwise the translation of an atom is a copy of the atom)
\item make instruction success conditional
      on the translated atom matching an atom pattern
\item announce the reduced length (untranslated) atom
      as an erroneous atom of a given type
\item change the \TT{current} \TT{lexeme} \TT{type} (the type can be changed
      to \TT{NONE})
\item change the \TT{current} \TT{lexical} \TT{table} - optionally the previous
      table ID can be pushed into the \TT{return} \TT{stack},
      or optionally the
      new table ID can be popped from this stack
\item force the atom table that contains the instruction
      to fail to match any atom
\end{itemize}

Details and examples are given in the next section.


\subsection{Lexical Programs}

A \key{lexical program} is a set of character pattern definitions
and lexical tables.  A lexical program can include another lexical program.
The top level lexical program must begin with a master
table that serves as the initial lexical table.

The lexemes of a lexical program
are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes single space) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::=
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe}, \\
    and \TT{Pf}; includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{ASCII-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em ASCII-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of white-space characters (single space, horizontal tab, form
feed, etc.), but is not itself a lexeme:
\begin{indpar}
\emkey{white-space} ::= {\em horizontal-space} $|$ {\em vertical-space}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

Two kinds of {\em horizontal-space} are given special distinction:
\begin{indpar}
\emkey{indent} ::=
	\begin{tabular}[t]{l}
        {\em horizontal-space} just before the first \\
	non-comment {\em graphic} character on a line
	\end{tabular}
\\[0.3ex]
\emkey{indent-before-comment} ::=
	\begin{tabular}[t]{l}
	{\em horizontal-space} just before a comment \\
        on a line containing just a comment
	\end{tabular}
\end{indpar}

These \skey{indent lexeme}s are unique in that they can be empty
(have no characters).  The are used to communicate the indent of
the first character after the indent lexeme to the parser.
If a parser is using line indentation to
determine when a logical line ends (see \itemref{LOGICAL-LINES}),
the parser can read lexemes till it reads an indent lexeme
whose after-lexeme character, the first graphic on the line,
has an indent not greater than the indent of the logical line being read
(lines with greater indent are continuation lines).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

Non-indent, non-line-break {\em whitespace-space} lexemes, such as occur
in the middle of text or code, are usually ignored
by the parser, though they are still used during lexical scanning
to separate other lexemes.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::=
    \begin{tabular}[t]{l}
    {\em horizontal-space-character}, other than \\ single space
    \end{tabular}
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= {\em vertical-space-character}
	other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::=
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} \\
    or {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::=
    \begin{tabular}[t]{l}
    UNICODE character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these strings generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing special, aside from generating
warning messages.  If the warning messages are turned off, these
sequences can be included in {\em quoted-strings} and {\em comments}
just like other characters can be included.

Lexemes may be tagged with the position
(\pagref{POSITION-OF-CHARACTER})
and/or indent (\pagref{INDENT-OF-CHARACTER})
of their first character
and of the first character after the lexeme.  The second
or both of these characters
may be an imaginary end-of-file character after the end of the input.

The lexemes in a lexical program are specified in
Figure~\itemref{LEXEME-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see page \pageref{ILLEGAL-CHARACTERS}
above to account for such characters.

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.
{\em Comments} are treated as lexemes, but are discarded before the
lexeme stream is transmitted to the parser.

The lexemes are organized into \skey{logical line}s.  Most of these
consist of a single non-indented input line.  Indented lines continue
the previous logical line.  A `\TT{;}' ends a logical line, as does
an end of file.  In syntax equations such as
those of Figure~\itemref{LEXEME-PROGRAM-LEXEMES},
the end of a logical line is denoted by `\TT{;}', but in examples
it is usually denoted by line indentation.

\ikey{Consecutive quoted string lexemes}{quoted strings!consecutive}
are glued together if they are in the
same logical line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence"
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" "LF" ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

A special {\em character-representative} can consist of
the UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{NBSP}.  There are three other cases:
\TT{<Q>} represents the doublequote \TT{"}, \TT{<NL>} (new line)
represents a line feed (same as \TT{<LF>}), and \TT{<UUC>} represents
the `unknown UNICODE character' which in turn is used to represent
illegal UTF-8 character encodings.

A special {\em character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

\begin{boxedfigure}[!p]
\begin{indpar}

\emkey{lexeme}
	::= {\em word} $|$ {\em mark} $|$ {\em number}
	$|$ {\em separator}
	$|$ {\em quoted-string}
	$|$ {\em comment}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::=
	\begin{tabular}[t]{l}
	{\em lexical-item} \\
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme} containing a {\em letter} before any
                  {\em digit}
\\[0.5ex]
\emkey{natural-number} :::= {\em ASCII-digit}\PLUS{} not beginning with \TT{0}
                     $|$ \TT{0}
\\[0.5ex]
\emkey{numeric} :::= \begin{tabular}[t]{l}
                     {\em middle-lexeme} containing a {\em digit}
                         before any {\em letter}, \\
		     but \underline{not} a {\em natural-number}
		     \end{tabular}
\\[0.5ex]
\emkey{number} :::= {\em natural-number} $|$ {\em numeric}
\\[0.5ex]
\emkey{mark} :::= {\em middle-lexeme} that is not a {\em word} or
		  {\em number}
\\[1ex]
\emkey{comment} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\label{COMMENT}

\end{indpar}
\caption{Lexeme Program Lexemes}
\label{LEXEME-PROGRAM-LEXEMES}
\end{boxedfigure}

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.%
\footnote{It is possible to use a strictly left to right scan with
backup over lexical atoms to perform
the right to left removal of {\em trailing-separators} from a
{\em lexical-item}, by recognizing a sequence of
{\em trailing-separator-characters} not followed by a
{\em lexical-item-character} that is not a
{\em trailing-separator-character}
as an atom that is backed up over and rescanned:
see Appendix \itemref{STANDARD-LEXICAL-PROGRAM}.}

The syntax of a lexical program is specified in
Figures~\itemref{LEXEME-PROGRAM-SYNTAX-1}
and~\itemref{LEXEME-PROGRAM-SYNTAX-2}.

\begin{boxedfigure}[!p]
\begin{indpar}
\emkey{name} ::= 
        \begin{tabular}[t]{l}
	\{ {\em word} $|$ {\em natural-number}
	              $|$ {\em quoted-string} \}\STAR{} \\
	{\em word} \\
	\{ {\em word} $|$ {\em natural-number} $|$ {\em quoted-string} \}\STAR{}
	\end{tabular}
\\[0.3ex]
\emkey{lexical-program} ::=
        \begin{tabular}[t]{@{}l@{}}
	\TT{begin} {\em program-name} \TT{lexical program;}\\
	~~~~{\em lexical-program-unit}\STAR{} \\
	\TT{end} {\em program-name} \TT{lexical program};
	\end{tabular}
\\[0.3ex]
\emkey{program-name} ::= {\em name}
\\[0.3ex]
\emkey{lexical-program-unit}
        \begin{tabular}[t]{@{}rl@{}}
	::= & {\em cpat-definition} \\
	$|$ & {\em lexical-table-definition} \\
	$|$ & {\em program-inclusion}
	\end{tabular}
\\[0.3ex]
\emkey{program-inclusion} ::= \TT{include} {\em program-name}
				  {\em remove-clause}\STAR{} \TT{;}
\\[0.3ex]
\emkey{remove-clause}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{remove} {\em lexical-table-name} \\
	$|$ & \TT{remove} \TT{"}{\em cpat-name}\TT{"}
	\end{tabular}
\\[2.0ex]
\hspace*{0.2in}
    {\bf Note:} `{\em cpat}\,' abbreviates `{\em character-pattern}\,'
\\[2.0ex]
\emkey{cpat-definition} ::=
	\TT{"}{\em cpat-name}\TT{"} \TT{=}
		{\em cpat-expression} \TT{;}
\\[0.3ex]
\emkey{cpat-name}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{<}{\em letter}\PLUS{}\{\TT{-}{\em letter}\PLUS{}\}\STAR{}%
	       \TT{>} \\
	    & but not \TT{<}{\em upper-case-ASCII-letter}\PLUS{}\TT{>}
	\end{tabular}
\\[0.3ex]
\emkey{special-cpat-name}
        \begin{tabular}[t]{@{}rl@{}}
	:::= & \TT{<UNICODE-}{\em category}\TT{>} \\
	 $|$ & \TT{<UNICODE-}{\em subcategory}\TT{>} \\
	 $|$ & \TT{<others>} \\
	\end{tabular}
\\[0.3ex]
\emkey{category} :::= UNICODE category, e.g., \TT{L} \\
\emkey{subcategory} :::= UNICODE subcategory, e.g., \TT{Lu}
\\[0.3ex]
\emkey{cpat-expression}
        \begin{tabular}[t]{@{}rl@{}}
	::= & {\em cpat-term} \{ \TT{|} {\em cpat-term} \}\STAR{} \\
        $|$ & {\em cpat-term} \{ \TT{\&} {\em cpat-term} \}\STAR{}
	\end{tabular}
\\[0.3ex]
\emkey{cpat-term} ::= {\em cpat-factor}
                  $|$ \TT{\textasciitilde} {\em cpat-factor}
\\[0.3ex]
\emkey{cpat-factor}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{"}{\em character-representative}\TT{"} \\
	$|$ & \TT{"}{\em character-representative}\TT{-}%
		    {\em character-representative}\TT{"} \\
	$|$ & \TT{"}{\em cpat-name}\TT{"} \\
	$|$ & \TT{(} {\em cpat-expression} \TT{)}
	\end{tabular}
\\[1.0ex]
\emkey{lexical-table-definition} ::=
        \begin{tabular}[t]{@{}l@{}}
	\TT{begin} {\em lexical-table-name}
		    {\em lexical-table-kind} \TT{table} \TT{;} \\
	~~~~{\em lexical-table-entry}\STAR{} \\
	~~~~{\em default-instruction-group} \\
	\TT{end} {\em lexical-table-name}
		 {\em lexical-table-kind} \TT{table} \TT{;}
	\end{tabular}
\\[0.3ex]
\emkey{lexical-table-kind} ::=
    \TT{master} $|$ \TT{lexeme} $|$ \TT{sublexeme} $|$ \TT{atom}
\\[0.3ex]
\emkey{lexical-table-name} ::=
    {\em name} except \TT{scan error} or \TT{none}
\end{indpar}
\caption{Lexeme Program Syntax: Part I}
\label{LEXEME-PROGRAM-SYNTAX-1}
\end{boxedfigure}

\begin{boxedfigure}[!p]
\begin{indpar}
\emkey{default-instruction-group}
	::= {\em empty} $|$ {\em instruction-group}
\\[0.3ex]
\emkey{lexical-table-entry}
        \begin{tabular}[t]{@{}rl@{}}
	::= & {\em atom-pattern} {\em instruction-group} \TT{;} \\
	$|$ & {\em atom-pattern} \TT{;}
	\end{tabular}
\\[0.3ex]
\emkey{atom-pattern} ::= \TT{"}{\em atom-factor}\PLUS{}\TT{"}
\\[0.3ex]
\emkey{atom-factor} ::= {\em atom-primary} {\em repeat}\QMARK{}
\\[0.3ex]
\emkey{atom-primary} ::= {\em character-representative} $|$
                             {\em cpat-name} except {\em repeat}
\\[0.3ex]
\emkey{repeat} ::= \TT{<repeat>} $|$ \TT{<repeat-}{\em ASCII-digit}\PLUS{}\TT{>}
\\[0.3ex]
\emkey{instruction-group}
	::= {\em instruction}
	        \{ \TT{else} {\em instruction} \}\STAR{}
\\[0.3ex]
\emkey{instruction} ::= {\em instruction-component}\PLUS{}
\\[0.3ex]
\emkey{instruction-component}
        \begin{tabular}[t]{@{}rl@{}}
	::= & \TT{accept} \\
	$|$ & \TT{match} ~ {\em atom-table-name} \\
	$|$ & \TT{keep} ~ {\em natural-number} \\
	$|$ & \TT{translate to} ~ {\em translation-string} \\
	$|$ & \TT{translate hex} ~
			{\em natural-number} ~ {\em natural-number} \\
	$|$ & \TT{translate oct} ~
			{\em natural-number} ~ {\em natural-number} \\
	$|$ & \TT{translate name} ~
			{\em natural-number} ~ {\em natural-number} \\
	$|$ & \TT{require} ~ {\em atom-pattern} \\
	$|$ & \TT{error} ~ {\em type-name} \\
	$|$ & \TT{output} ~ {\em type-name} \\
	$|$ & \TT{output} ~ \TT{none} \\
	$|$ & \TT{goto} ~ {\em master-table-name} \\
	$|$ & \TT{goto} ~ {\em lexeme-table-name} \\
	$|$ & \TT{goto} ~ {\em sublexeme-table-name} \\
	$|$ & \TT{call} ~ {\em lexeme-table-name} \\
	$|$ & \TT{call} ~ {\em sublexeme-table-name} \\
	$|$ & \TT{return} \\
	$|$ & \TT{fail} \\
	\end{tabular}
\\[0.3ex]
\emkey{type-name} ::= {\em name} except ~ \TT{scan error} ~ or ~ \TT{none}
\\[0.3ex]
\emkey{atom-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{lexeme-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{sublexeme-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{master-table-name} ::= {\em lexical-table-name}
\\[0.3ex]
\emkey{translation-string} ::= {\em quoted-string}
\end{indpar}
\caption{Lexeme Program Syntax: Part II}
\label{LEXEME-PROGRAM-SYNTAX-2}
\end{boxedfigure}

An example lexical program that recognizes
whitespace and quoted strings is given
in Figure~\itemref{EXAMPLE-LEXEME-PROGRAM}.
\TT{<LF>} is the only {\em character-representative} recognized
in quoted strings by this example.

\begin{boxedfigure}[!p]
\addtolength{\baselineskip}{-0.4ex}
\begin{indpar}\begin{verbatim}
begin example lexical program;

"<whitespace-char>" = " " | "<HT>"
                    | "<LF>" | "<VT>" | "<FF>";

begin main master table;
    "<whitespace-char>" goto whitespace;
    "<Q>" translate to "" goto quoted string;
    "<others>" output misplaced character;
    output end of file;
end main master table;

begin whitespace lexeme table;
    "<whitespace-char>" accept;
    goto main;
end whitespace lexeme table;

begin quoted string lexeme table;
    "<Q>" translate to "" goto main;
    "<LF>" keep 0 goto premature end of line;
    "<" "LF" ">" translate to "<LF>";
    "<others>" accept;
    goto premature end of file;
end quoted string lexeme table;

include premature tables;

end example lexical program;

begin premature tables lexical program;
    // Stuff to include.

begin premature end of line master table;
    "<LF>" output premature end of line
           goto main;
end premature end of line master table;

begin premature end of file master table;
    output premature end of file
           goto main;
end premature end of file master table;

end premature tables lexical program;
\end{verbatim}\end{indpar}
\caption{Example Lexeme Program}
\label{EXAMPLE-LEXEME-PROGRAM}
\end{boxedfigure}

A \emkey{lexical-program} consists of a sequence of units that are
{\em character-\EOL pattern-\EOL defi\-ni\-tions},
{\em lexical-\EOL table-\EOL defi\-ni\-tions},
or {\em program-inclusions}.  These respectively define character pattern sets
and lexical tables, and include lexical program units of
previously defined lexical programs.

\subsubsection{Lexical Program Inclusion}

A \emkey{program-inclusion} names a previously defined lexical program
whose units are to be included in the current lexical program
at the point of the {\em program-inclusion}.
There is a simple example of a program inclusion at the end of
the \TT{example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.
Identical definitions
may be repeated without error,
as can happen when one program includes two programs each of
which include the same third program.
A {\em program-inclusion} can have
\emsmkey{remove-clause}s{in {\em program-inclusion}}
each of which removes a named definition from the set of included
definitions.  This is the only way to resolve conflicts between
definitions.

\subsubsection{Character Pattern Definitions}

A \emkey{character-pattern-definition} (abbreviated as
\emkey{cpat-definition}) assigns a set of characters to a
{\em character-pattern-name}.  The latter is just a string of
letters and hyphens (\TT{-}) surrounded by angle brackets (\TT{< >})
with hyphens occurring only between letters.  Examples:
\TT{<digit>} and \TT{<line-break>}.  However, the
{\em character-pattern-name} defined by a {\em character-pattern-definition}
cannot contain only upper case letters, as this could conflict with
some {\em character-representative}
(some {\em special-character-pattern-names} which have builtin definitions do contain only upper case letters).

The character set is denoted by a \emkey{character-pattern-expression}.
The simplest character pattern
expression is just a single {\em character-representative} in quotes,
which denotes
the character set containing only the quoted character.  Examples:
\TT{"0"} and \TT{"+"}.
The next simplest is two {\em character-representatives}
separated by a hyphen (\TT{-}) denoting the character set consisting
of all characters in the range from the first to the second of the two
characters.  Examples: \TT{"0-9"} and \TT{"A-Z"}.  The characters
are ordered according to their 32 bit unsigned UNICODE value, and the
second of the two characters must not be smaller than the first.

A {\em character-representative} is a representative of a single UNICODE
character that can be used inside quotes (\TT{"}).
Most graphic UNICODE characters represent themselves.  Other characters
are represented by character sequences surrounded by the angle
brackets \TT{<} and \TT{>} (which are also the less than and
greater than signs).
For example, a line feed can be represented by any of the
following: \TT{<LF>}, \TT{<0A>},
\TT{<00A>}, \ldots, or \TT{<00000000A>}.

A quoted {\em character-pattern-name} denotes the character set associated
with that name by a \underline{previous} {\em character-pattern-definition},
or in the case of {\em special-character-pattern-names}, by one of the
following rules:
\begin{center}
\begin{tabular}{ll}
\TT{<UNICODE-$C$>} & all characters in UNICODE category $C$ \\
\TT{<UNICODE-$SC$>} & all characters in UNICODE subcategory $SC$ \\
\TT{<others>} & see page \pageref{<OTHERS>} \\
\end{tabular}
\end{center}

The \TT{|}, \TT{\&}, and \TT{\textasciitilde} operators and can be used to take
the union, intersection, and complements of character sets.  The complement
is relative to the universe of all 32 bit unsigned integer UNICODE
character codes.  Thus \TT{\textasciitilde "b-y"}
denotes the same character set as
\TT{"<0>-a"\,|\,"z-<0FFFFFFFF>"}.

Parentheses may be used in {\em character-pattern-expressions} as is
normal in algebraic expressions.
Note that the \TT{|} and \TT{\&} operators cannot be used together
in the same expression without intervening parentheses as neither
takes precedence over the other.  This is done to prevent ambiguity.

Some example {\em character-pattern-definitions} are:

\begin{indpar}[0.05in]\begin{verbatim}
"<hex-digit>" = "0-9" | "a-f" | "A-F";
"<non-line-break-char>" = ~ "<LF>" & ~ "<VT>" & ~ "<FF>";
"<quotable-char>" = "<020>-<07E>" & ~ "<Q>";
"<whitespace-char>" = " " | "<LF>" | "<VT>" | "<FF>" | "<HT>";
"<source-character>" =
    ( "<020>-<07E>" & ~ "$" & ~ "@" & ~ "`" )
    | "<whitespace-char>";
\end{verbatim}\end{indpar}

Current implementations require that any two non-LATIN1 UNICODE
characters that have the same UNICODE subcategory, UNICODE name
(a.k.a. `abbreviation alias',
e.g., \TT{HT} or \TT{SOH} or \TT{NBSP}, or may be `missing'),
and UNICODE numeric value (e.g., \TT{3} or \TT{1/3}, or may be `missing'),
must be treated identically: that is, one is in a character pattern's set
if and only if the other is in the set.  This means that the
character pattern expression \TT{"<0FFFF>-<0FFFFFF>"} is not implemented,
for example, although \TT{"<0F>-<0FF>"} is implemented because it
involves only LATIN1 characters.

\subsubsection{Lexical Tables}

A {\em lexical-table-definition} specifies a {\em lexical-table-name},
the {\em lexical-table-kind} of the table,
a set of {\em lexical-table-entries}
each containing an {\em atom-pattern} and optionally an {\em instruction},
and an optional {\em default-instruction-group} that is executed when
no atom is recognized by any of the table entries.

The {\em lexical-table-kinds} are
\mkey{master}{lexical table kind},
\mkey{lexeme}{lexical table kind},
\mkey{sublexeme}{lexical table kind}, or
\mkey{atom}{lexical table kind}.
In a master table {\em atom-patterns} are typically associated
with \TT{goto} or \TT{call} instructions
that change the current table from the
master table to a lexeme or sublexeme table.
In a lexeme or sublexeme table {\em atom-patterns}
are typically associated with \TT{accept} instructions which
accept the matched atom as part of the current lexeme.  In a lexeme
or sublexeme
table the default instruction is typically a \TT{goto} or \TT{return}
back to a
master table, and because this changes the current lexical table
to a master table, it causes any accumulated lexeme
to be output with its lexeme type being the current lexeme type
if that is not `\TT{none}', or it causes any accumulated lexeme
to be discarded if the current lexeme type is `\TT{none}'.

Atom tables permit sets of atom patterns to be used in
several places without copying all the patterns.  Details are
on \pagref{ATOM-TABLE}.

The first master table in a lexical program
becomes the current lexical table when the scanner
is initialized.  This table is typically named `\TT{main}',
as it is in the \TT{example} lexical program on
\pagref{EXAMPLE-LEXEME-PROGRAM}.

A lexical table consists of {\em lexical-table-entries}%
\emindex{lexical-table-entry} each containing an {\em atom-pattern} and
an {\em instruc\-tion-group}.  The \emkey{atom-pattern} is matched against
the remaining input characters.  The pattern consists of a sequence
of {\em character-representatives}, each of which match only themselves,
and {\em character-pattern-names}, each of which match any character
in the named set of characters.  Thus
\begin{center}
\verb|"<0<hex-digit><hex-digit>>"|
\end{center}
matches 5-character atoms consisting of a \TT{<} followed by an
\TT{0} followed by two characters each in the character set
named by \TT{<hex-digit>} followed by a \TT{>}.
Note that this {\em atom-pattern}
only matches atoms that are 5 characters long.


The special character pattern name
\TT{<{others}>}%
\index{others@{\tt <others>}}%
\label{<OTHERS>}
can be used in an atom pattern to match any character not otherwise
matched.  More specifically, in the atom pattern
\TT{"}$P$\TT{<others>}$Q$\TT{"},
the pattern name \TT{<others>} matches any characters not matched by
any other character pattern $C$ that is in some atom pattern of the form
\TT{"}$PCR$\TT{"} in the same lexical table.
There are several examples of this on \pagref{EXAMPLE-LEXEME-PROGRAM}.

The special character pattern name
\TT{<{repeat}>}%
\index{repeat@{\tt <repeat>}}%
\label{<REPEAT>}
can be used in an atom pattern to match zero or more occurrences of
the previous character pattern.  There must be a previous character
pattern.  That pattern can be \TT{<others>}.
The number of repetitions is the maximum number of characters in
the input that match the previous character pattern.
As an example use, the atom pattern \TT{"\textbackslash x<hex-digit><repeat>"}
will recognize an atom consisting of the characters \TT{\textbackslash x}
followed by one or more characters matching the character pattern
\TT{<hex-digit>}.  This particular atom pattern will match a C++
hexadecimal escape sequence.

The special character pattern name
\TT{<{repeat-$N$}>}%
\index{repeat-N@{\tt <repeat-$N$>}}%
is similar but matches zero through $N$ occurrences of the previous
character pattern, where $N$ is a sequence of {\em ASCII-digits}
not beginning with \TT{0}.

Note that if \TT{$C_1$<repeat>$C_2$} is part of an atom pattern where
$C_1$ and $C_2$ are character patterns or representatives, then
any atom recognized by the pattern must contain some number of
$C_1$ characters followed by a $C_2$ character that is \underline{not} also
a $C_1$ character.
For example, the pattern
\TT{"X<repeat>X"} cannot recognize the atom \TT{XXX} because the
string \TT{XXX} will match \TT{X<repeat>} leaving nothing to match
the final \TT{X} in the pattern.

If {\em atom-patterns} of two distinct {\em lexical-table-entries}
in the same {\em lexical-table} have the forms 
\TT{"}$PC_1Q_1$\TT{"} and \TT{"}$PC_2Q_2$\TT{"} with a common
prefix $P$ where
$C_1$ and $C_2$ are both character patterns or representatives
optionally followed
by \TT{<repeat>} or \TT{<repeat-$N$>} and
$Q_1$ and $Q_2$ are either both empty or both non-empty,
then the character sets of $C_1$ and $C_2$ \underline{must}
be disjoint.  This permits a deterministic finite automaton that
recognizes the atoms of the lexical table to be constructed.

It is permissible for
a sequence of characters that matches one pattern to have a proper
initial segment that matches another pattern; in this case the
longer pattern takes precedence.  This is why either $Q_1$ or $Q_2$
in the previous paragraph can be empty, but not both.

The order of {\em lexical-table-entries}
in a {\em lexical-table} is not significant.

The atom pattern \TT{""} which would recognize zero length atoms is
\underline{not} permitted, but the {\em default-instruction-group} at the
end of the lexical table executes in the equivalent case where no atom
pattern in the table matches the remaining input.  In particular
the {\em default-instruction-group} always executes if the input has reached
its end.  This fact is used in both the `\TT{main master table}'
and `\TT{quoted string lexeme table}'
on \pagref{EXAMPLE-LEXEME-PROGRAM}.

\subsubsection{Lexical Instructions}

A \emkey{lexical-table-entry} contains an
{\em atom-pattern} and an optional
\emkey{instruction-group} that consists of one or more {\em instructions}
separated by \TT{else}'s.  Most {\em instruction-groups} contain just
a single {\em instruction}, so we will explain this first.
{\em Instruction-groups} with more than one instruction contain
instructions that can fail, causing
the failing instruction to become a no-operation and the
next instruction in the instruction group to be executed instead.

An \emmkey{instruction}{in lexical-table-entry} in an {\em lexical-table-entry}
specifies actions to be taken when an atom is recognized by the
{\em atom-pattern} of the entry.  The {\em instruction} consists of
a set of {\em instruction-components} each of which controls part of the
atom processing.

The {\em default-instruction-group} at the end of an lexical table behaves as
if a it was associated with the {\em atom-pattern} \TT{""}
that recognizes zero length atoms.  Note that actual {\em atom-patterns}
are not allowed to be \TT{""}.

The order of processing {\em instruction-components} in an {\em instruction}
is:
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{l}{Components that may
cause their containing instruction to fail:} \\[1ex]
~~~~~~~~ & \TT{match}, \TT{translate oct}, \TT{translate hex},
                                       or \TT{translate name}\\
~~~~~~~~ & \TT{require}
\\[2ex]
\multicolumn{2}{l}{Components that only execute if their
containing instruction does not fail:} \\[1ex]
~~~~~~~~ & \TT{keep} \\
~~~~~~~~ & \TT{translate to}\\
~~~~~~~~ & \TT{error} \\
~~~~~~~~ & \TT{output} \\
~~~~~~~~ & \TT{goto}, \TT{call}, \TT{return}, or \TT{fail} \\
\end{tabular}
\end{center}

An {\em instruction} with no {\em instruction-components} simply accepts
the matched atom and copies it into the translation.  In order to
indicate this, the instruction may be written as if it had a single
`\TT{accept}' instruction component.  If this component is present
in an {\em instruction}, no other {\em instruction-components}
may be present in the {\em instruction}.

\subsubsubsection{Match Instruction Components and Atom Tables}

The `\ttmkey{match}{in lexical program} {\em atom-table-name}'
{\em instruction-component} invokes the named
\key{atom table}\label{ATOM-TABLE}
to recognize an atom and provide its translation.
Any previously matched atom and translation are ignored, and
the atom table {\em atom-patterns} are used to rematch the current atom,
provide a translation of the atom, and determine
whether the containing {\em instruction} fails.

Atom tables match only a single atom and implicitly return
to their invoking instruction after matching one atom.  The
\TT{output}, \TT{goto}, \TT{call}, and \TT{return}
{\em instruction-components} \underline{cannot} be used in an
atom table.  However, the \TT{fail} {\em instruction-component}
can only be used in an atom table, and when executed indicates
that the atom table invoking {\em instruction} has failed, so that
{\em instruction} becomes a no-operation and the next
{\em instruction} in the invoking
{\em instruction-group} (i.e., the {\em instruction}
after the `\TT{else}' following the failed {\em instruction}) is
executed.

\TT{accept}, \TT{match}, \TT{keep}, \TT{require}, and
any of the \TT{translate} {\em instruction-components} can be used in
an atom table {\em instruction}.  An atom table
instruction may contain a \TT{match} that invokes another atom table,
but recursion is prohibited, and as \TT{match} uses the
\TT{return stack}, a very deep nesting of \TT{match}'es may
exceed the stack limit (which is at least \TT{32}).

If an instruction invokes an atom table and
the atom table does not fail,
the original atom match that caused the instruction
to be executed is replaced by the atom matched by the
atom table, and the atom translation is that provided by the atom table.

An instruction that invokes an atom table fails if the atom table
fails or if the instruction has a \TT{require} component that fails
when applied to the atom translation produced by the atom table.
If the instruction fails, the
original atom match is reinstated (the instruction becomes a
no-operation) before the next {\em instruction} in the {\em instruction group}
executes.

The \TT{error} instruction component can also be used in an atom
table, but if the atom table fails, or if a subsequent \TT{require}
causes a \TT{match} that invoked the atom table to fail, the
effects of the \TT{error} instruction component will \underline{not}
be undone.  Normally the only effect is to announce an error.

Atom tables may have a {\em default-instruction-group}.
However, this only makes sense if it is just a `\TT{fail}', or
if it is contains \TT{match} components.  If an atom table
is invoked and none of its {\em atom-patterns} match an atom,
and if the table has \underline{no} {\em default-instruction-group},
then a scan error is signaled (i.e., `\TT{fail}' is \underline{not}
implicit).

\subsubsubsection{Translate Hex/Oct/Name Instruction Components}

The \TT{translate hex/\EOL oct/\EOL name} components are applied to a matched
atom to produce a single UNICODE character translation of the atom.

An instruction can contain at most one of the following components:
\begin{center}
\tt
match \\
translate hex \\
translate oct \\
translate name
\end{center}
This is because all four of these components independently produce
an atom translation.

Note that if any previous instruction in an instruction group contains
a \TT{match} component, that instruction must have failed, and the
atom as it was when the instruction group started to execute will have
been reinstated, so \TT{translate hex/oct/name} components are always
applied to the matched atom as it was when the containing instruction
group started to execute, before any \TT{match} components in the
group executed.

Also note that any \TT{keep} component executes \underline{after}
\TT{translate hex/oct/name} components, and so does not affect the
matched atom used by these components.

The `\ttmkey{translate hex}{in lexical program} $m$ $n$'
{\em instruction-component} ignores the
first $m$ and last $n$ characters of the matched atom and, viewing the rest as
hexadecimal digits, converts these into an 32 bit unsigned integer
UNICODE character code, which becomes the 1-character atom translation.
An example is the lexical table entry
\begin{center}
\verb|"<0<hex-digit><hex-digit>>" translate hex 2 1;|
\end{center}
which might be used to accept a character representative in a quoted string
and copy the appropriate hexadecimally represented character code into
the lexeme translation.  If characters that
are supposed to be hexadecimal digits are not, the \TT{translate-hex}
component fails (but in our example
this cannot happen because the definition of \TT{<hex-digit>}
restricts these characters appropriately).  The `\TT{translate hex}
instruction component accepts the characters \TT{a-f}, \TT{A-F},
and \TT{0-9} as hexadecimal digits (but \TT{<hex-digit>} in the
example might not accept all these).

The `\ttmkey{translate oct}{in lexical program} $m$ $n$'
{\em instruction-component} is identical but
views the rest of the characters as octal and not hexadecimal.
An example use would be the lexical table entry
\begin{center}
\verb|"\<oct-digit><oct-digit><oct-digit>" translate oct 1 0;|
\end{center}

The `\ttmkey{translate name}{in lexical program} $m$ $n$'
{\em instruction-component} is similar but
views the rest of the characters as the UNICODE name
(a.k.a., UNICODE abbreviation alias)
of a character.
An example use would be the lexical table entry
\begin{center}
\verb|"<<upper-case-ASCII-letter><repeat>>" translate name 1 1;|
\end{center}
which would translate the atom `\TT{<LF>}' to a line feed.
Note that UNICODE names consist of ASCII upper case letters and
digits, with a letter being first.
In addition to standard UNICODE character names, \TT{NL} is
recognized as the name of the line feed character,
\TT{Q} is recognized as the name of the \TT{"} character,
and \TT{UUC} is recognized as the name of the
`\key{Unknown UNICODE Character}' that replaces erroneous
UTF-8 character encodings on input.

\subsubsubsection{Require Instruction Components}

The `\ttmkey{require}{in lexical program} {\em atom-pattern}'
{\em instruction-com\-po\-nent} tests whether the atom translation
matches the given {\em atom-pattern},
and if \underline{no}, causes the {\em instruction} to fail.
A \TT{require} should only appear in an
{\em instruction} which is followed by an `\TT{else}' in an
{\em instruction-group}.
A \TT{require} should only appear in an instruction that also
contains a \TT{match}, \TT{translate hex}, or \TT{translate oct}
instruction component, and is only useful for testing the
translations produced by these latter components.

An example use would be the lexical table entry
\begin{indpar}
\verb|"\u<hex-digit><hex-digit><hex-digit><hex-digit>"| \\
\verb|    translate hex 2 0| \\
\verb|    require "<letter>" else| \\
\verb|    translate to "" error misplaced character in identifier;|
\end{indpar}
which might be used to process an atom of the form \TT{\textbackslash uXXXX} in
an identifier, accepting the atom as a legitimate representation of a
character if that character is a letter, and otherwise designating
the atom as an error while not putting anything in the lexeme translation
(see below for the definition of the `\TT{error}' instruction component).

The last {\em instruction} in an {\em instruction-group} must
never fail, and so cannot contain a \TT{require} {\em instruction-component}.

A \TT{require} component executes before any \TT{translate to}
component (\pagref{TRANSLATE-TO-INSTRUCTION-COMPONENTS} below),
so the translation tested by \TT{require} can be replaced by
\TT{translate to}.

\subsubsubsection{Keep Instruction Components}

The `\ttmkey{keep}{in lexical program} $n$'
{\em instruction-component} causes the atom length
to be shortened to $n$ UNICODE characters.
For example, the lexical table entry
\begin{center}
\verb|",<digit>" keep 1;|
\end{center}
will recognize a 1-character atom consisting of just a comma as long as
the comma is followed by character in the \TT{<digit>} character pattern
character set.  Atoms may not be lengthened by \TT{keep}.

A \TT{keep} component in the same instruction as a \TT{match} component
applies to the atom matched by the atom table invoked by the \TT{match}
component.

\subsubsubsection{Translate To Instruction Components}
\label{TRANSLATE-TO-INSTRUCTION-COMPONENTS}

A `\ttmkey{translate to}{in lexical program}~~{\em translation-string}'
{\em in\-struc\-tion-com\-po\-nent}
specifies a {\em quoted-string} of characters,
the {\em translation-string},
that becomes the translation of the atom.
A {\em translation-string} may be empty, as in the lexical table entry
\begin{center}
\verb|"<Q>" translate to "" goto main;|
\end{center}
which can be used to recognize the last \TT{"} of a quoted string, avoid
copying anything into the lexeme translation, and then switch to the
`\TT{main}' lexical table.
See the example on \pagref{EXAMPLE-LEXEME-PROGRAM}.

The \TT{translate to} component is executed \underline{after}
any \TT{match}, \TT{translate hex}, \TT{tran\-slate oct},
\TT{translate name}, or
\TT{require} components are executed, and overrides the translations produced
by these components.  It is therefore possible to produce a translation,
test it with \TT{require}, and if the test is successful, override the
translation with \TT{translate to}.  An example is
\begin{center}
\begin{tabular}{l}
\verb|"<"  "<digit>" match escaped char| \\
\verb|               require "<ascii-character>"| \\
\verb|               error ascii escaped character| \\
\verb|               translate to ""| \\
\end{tabular}
\end{center}
which announces that any escape sequence producing an ASCII character
is an erroneous atom and replaces that atom by the empty translation
so it is as if the atom did not exist in the input.
One could also use `\TT{translate to "?"}' to replace the atom
by a question mark.

If an instruction does not contain any of the components \TT{match},
\TT{translate hex}, \TT{tran\-s\-late oct},
\TT{trans\-late name}, or \TT{trans\-late to},
the translation
of an atom defaults to a copy of the atom itself, \underline{after}
any \TT{keep} component has been used to change the length of the atom.

\subsubsubsection{Error Instruction Component}

~~~~ An `\ttmkey{error}{in lexical program} {\em type-name}\,'
{\em instruction-component}
an\-noun\-ces the current atom as an erroneous atom of the given {\em type}.
The atom remains part of the current lexeme,
and its translation is governed
independently by \TT{match} and \TT{translate} instruction components
(or the absence of such).
The following are some examples:
\begin{indpar}\begin{verbatim}
"\<others>" error bad escape sequence;
"\<others>" translate to "" error bad escape sequence;
"\<others>" translate to "<DEL>" error bad escape sequence;
\end{verbatim}\end{indpar}
These might be entries in an lexical table for a quoted string.
All identify an atom consisting of a backslash followed by any
character that does not match any character pattern $C$ that is in
a lexical table
atom pattern of the form \TT{"\textbackslash}$C$\ldots\TT{"} where $C$ is a character
pattern other than \TT{<others>} (see \pagref{<OTHERS>}).
The first entry copies the entire 2-character atom, including the
backslash, into the lexeme translation.  The second entry copies
nothing (the empty string \TT{""}) into the lexeme translation.
The third entry copies the DEL character (hex code \TT{7f})
into the lexeme translation.  An alternative is the entry
\begin{indpar}\begin{verbatim}
"\<others>" keep 1 error bad escape;
\end{verbatim}\end{indpar}
that reduces the atom size to 1 character, just the backslash,
which is announced as an error without its following character,
and copied to the lexeme translation.  The character following
the backslash remains in the input and will part of the next
atom recognized.
Another alternative is
\begin{indpar}\begin{verbatim}
"\" match bad escape translate "" error bad escape;
. . .
<any> = <0-<0FFFFFFFF>>;      // Matches any character.
begin bad escape atom table;
"\<any><any><any>"
end bad escape atom table;
\end{verbatim}\end{indpar}
in which the lexical table entry will be invoked if the next character
in the input is \TT{\textbackslash} and no longer
lexical table atom pattern of the form \TT{"\textbackslash}\ldots\TT{"} is matched, 
and as a result the \TT{\textbackslash} and the next three characters will be identified
as a `\TT{bad escape}'
erroneous atom and translated to the empty character sequence.


The routine that announces an error atom is given the position
of the atom in the input stream, so characters surrounding the
atom may also be included in the announcement.  For example,
the line containing the atom may be printed with marks under the
characters of the atom.

An erroneous atom is different from an erroneous lexeme.
An erroneous lexeme is simply a lexeme whose {\em type}
indicates to the user of the lexical scanner that the lexeme is erroneous.
As such an erroneous lexeme is
handled by the lexical scanner just as any other lexeme would be:
i.e., the lexical scanner has no special knowledge of erroneous lexemes
and no special operations for detecting or announcing them.

\subsubsubsection{Output Instruction Component}

\hfill An `\ttmkey{output}{in lexical program} {\em type-name}\,'
{\em instruction-component} sets the \key{current lexeme type}.

The \TT{output} {\em instruction-component} is
used to change the type of the lexeme to be output from
the type of the table containing the instruction.
For example, at the top of \pagref{EXAMPLE-LEXEME-PROGRAM} the
\TT{main} master table has `\TT{output end of file;}' as its
{\em default-instruction-group}, thereby outputting a zero length
lexeme with `\TT{end of file}' type whenever the input is at the
end of file.

As another example, the `\TT{main}' master table at the top of
\pagref{EXAMPLE-LEXEME-PROGRAM} contains the entry:
\begin{indpar}\begin{verbatim}
"<others>" output misplaced character;
\end{verbatim}\end{indpar}
which causes an unrecognized character to be treated as a 1-character
lexeme of type `\TT{misplaced char\-ac\-ter}'.
The translation of this lexeme is
the character itself, but if the entry:
\begin{indpar}\begin{verbatim}
"<others>" translate to "<DEL>" output misplaced character;
\end{verbatim}\end{indpar}
had been used instead the translation would have been the ASCII delete
(DEL) character.

Upon finishing the execution of an instruction, if the
current lexical table is a master table,
the currently accumulated lexeme is output
with the current lexeme type, if that is not `\TT{none}', or the
currently accumulated lexeme is discarded if the current lexeme
type is `\TT{none}'.
The current lexeme type is reset to `\TT{none}' whenever
the current lexical table becomes a master table.

The `\TT{output none}' instruction can be used to reset the current
lexeme type to `\TT{none}' in order to discard the currently
accumulated lexeme.

\subsubsubsection{Goto, Call, Return, and Fail Instruction Components}

A `\ttmkey{goto}{in lexical program} {\em lexical-table-name}\,'
{\em instruction-component} switches the current lexical table after
the current atom is processed.  If the table switches
to a master table and the current lexeme type is not `\TT{none}',
then the current lexeme translation is output with the
current lexeme type as its type.

A `\ttmkey{call}{in lexical program} {\em lexeme-table-name}\,'
{\em instruction-component} is just like `\TT{goto}' except
that it also pushes the identifier of the lexical table in which
the `\TT{call}' occurs (the `caller') into the return stack.
The \key{return stack} is a stack of up to 32 lexical table identifiers
used by the `\TT{call}' and `\TT{return}' instruction components
and also by the `\TT{match} {\em atom-table-name}'
instruction components.  Recursive calls are prohibited.
Whenever a master table becomes the current lexical table, the
return stack is cleared.

A `\ttmkey{return}{in lexical program}'
{\em instruction-component} is just like `\TT{goto}' except
that uses the lexical table identifier at the top of the return
stack to determine the next lexical table.  This identifier is
also popped from the stack.

The return stack is set to empty whenever the current lexical table
becomes a master table.
A \TT{call} \underline{cannot} be used
to call a master or atom table.  A \TT{return} can only
appear in a lexeme or sublexeme table.
A \TT{goto} \underline{cannot} be used to go to an atom table.

The `\TT{call}' and `\TT{goto}' instruction components
can both be used in the same {\em instruction}, in 
which case the \TT{goto} lexical table identifier is pushed into the
return stack instead of the current lexical table identifier.
The `\TT{return}' instruction component cannot be used with
`\TT{call}' or `\TT{goto}' (if `\TT{return}' and `\TT{call}'
could be used together, they would have the same affect as
a simple `\TT{goto}')

The `\TT{call}' and `\TT{return}' instruction components
permit a lexeme or sublexeme table to be shared among different
master, lexeme, and sublexeme tables.  For example, a lexeme table to scan
a comment lexeme may be shared among several master tables;
see Appendix \itemref{C++-LEXICAL-PROGRAM} for examples.

The `\TT{call}' and `\TT{return}' instruction components
add nothing new to the lexical scanning language, since they
cannot be used recursively,
and they can always be eliminated by making
copies of the called tables with hard coded returns.
But for certain languages these instruction components
substantially reduce the size of the lexical program.

A `\ttmkey{fail}{in lexical program}'
{\em instruction-component} can only be used in an atom
table and cannot be used with any other instruction components.
It causes the instruction invoking the atom table to fail, but
the instruction containing the `\TT{fail}' succeeds.

The `\TT{goto}', `\TT{call}', and `\TT{return}' instruction components
\underline{cannot} be used in an atom table.

\section{Parsing}

The layered languages parser attempts to promote human efficiency
both by standardizing many aspects of syntax and by permitting
substantial additions to syntax.  Humans reason
syntactically, and therefore new types of data and algorithm
need to be supported by new syntax.  But this new syntax needs to
integrate with the old syntax, so the goal of the parser is to make
possible syntactic additions that integrate well with existing syntax.%
\footnote{General LL parsers are too unruly to meet his criterion.}

The parser is a sequence of passes each of which operates on a list
of tokens.  A token is either a lexeme, a subexpression, or an operator.

The top level parser pass, the bracketed subexpression recognition pass,
recognizes:
\begin{itemize}

\item Logical lines, terminated either by line breaks with or without
possible indented or non-indented
continuation lines, or by logical line separators
(e.g.~`\TT{;}'), or by blank lines.  Note that logical
lines with non-indented continuation lines that are
terminated by blank lines are typically headed paragraphs.

\item Indented paragraphs, introduced by line-ending
indentation marks such as `\TT{:}', and terminated by the end of indentation.
An indented paragraph is a part of a logical
line, typically at the end of its containing logical line,
and in turn contains logical lines of its own.

The top level is considered to be its own indented paragraph whose
indentation mark is the file beginning and which ends at the file end.

\item Bracketed subexpressions bounded by brackets
such as `\TT{(}' and `\TT{)}'.

\item Typed bracketed subexpressions bounded by typed brackets
such as `\TT{\{b|}' and `\TT{|b\}}'.

\item Typed separated subexpressions that are introduced by 
`typed prefix separators' such as `\TT{\{s\}}'.
These are converted to typed bracketed subexpressions.

\item Headed lines, that are logical lines which begin with
a `line header' that is
a typed prefix separator that has the `\TT{line}' prefix group.
The line header may be implied.
Headed lines are converted to typed bracketed subexpressions.

\item Headed paragraphs, that are groups of logical lines
that begin with a `paragraph header' that is
a typed prefix separator that has the `\TT{paragraph}' prefix group.
The paragraph header may be implied.
These are converted to typed bracketed subexpressions.

\end{itemize}

The non-top-level passes
operate on the subexpressions recognized by previous passes;
for example, the operator pass operates on bracketed subexpressions
and recognizes
subexpressions bounded by operators.

Prefix separators, brackets, and indentation marks
can be used to change syntax, so, for example,
the syntax within a \TT{\{p\}} paragraph may differ from the
the syntax within a \TT{\{code\}} paragraph,
the syntax within a \TT{[ ]} bracketed subexpression may differ from
the syntax within a \TT{` '} bracketed subexpression, and
the syntax within a `\TT{:}' introduced indented paragraph may differ
from the syntax of its containing logical line.
This is an important feature of the multi-pass organization of
the parser.

Parsing reduces each recognized subexpression, including each top level
logical line, to a single expression token.

\subsection{Tokens}
\label{TOKENS}

A token has the following components:

\begin{indpar}
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{type}{of token}
		& One of: \hspace{0.5in}\begin{tabular}[t]{l}
        	          A lexeme type. \\
        	          \ttmkey{OPERATOR}{token type} \\
        	          \ttmkey{BRACKETED}{token type} \\
        	          \ttmkey{BRACKETABLE}{token type} \\
        	          \ttmkey{PREFIX}{token type} \\
        	          \ttmkey{IMPLIED\_PREFIX}{token type} \\
        	          \ttmkey{DERIVED}{token type} \\[1ex]
			  \end{tabular}
\\[1ex]
		& For a lexeme, the translation of the
		  lexeme may be recorded in either the token
		  \TT{value} as a MIN string or in the token \TT{string}.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& Standardly the token lexeme types are word, mark, separator,
		  and natural-number whose tokens have a \TT{value} that is
		  a MIN string equal to the lexeme characters,
		  quoted string and numeric whose tokens
		  have a \TT{string} equal
		  to the lexeme translation string,
		  and comment, indent, line break, start of file,
		  and end of file
		  whose tokens have neither
		  \TT{value} nor \TT{string}.
		  Standardly non-indent, non-line-break
		  whitespace lexemes and erroneous lexemes
		  (which are announced when read)
		  are not translated into tokens.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& For an \TT{OPERATOR}, the token \TT{value}
		  is the operator name recorded as
		  a MIN string or a MIN label, or in the case
		  where a bracketed subexpression is an operator,
		  the \TT{value} is the MIN object as described
		  for \TT{BRACKETED} tokens below.
		  \TT{OPERATOR} tokens are
		  produced inside the operator pass and consumed by
		  expression reformatters invoked by that pass.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& \TT{BRACKETED} and \TT{BRACKETABLE} tokens
		  are used to represent subexpressions, and have
		  MIN objects as their \TT{value}.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& The \TT{value} of a \TT{BRACKETED} token may have
		  any attributes, including \TT{.type},
		  \TT{.initiator}, and \TT{.terminator}.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& A \TT{BRACKETABLE} token
		  is equivalent to (and an optimization of) a \TT{BRACKETED}
		  token whose \TT{value} is a MIN object
		  that does \underline{not} have
		  a \TT{.type}, \TT{.initiator}, or \TT{.terminator}
		  attribute.
		  If such a token is to become the \underline{only} element of a
		  containing subexpression that will have no attributes other
		  than \TT{.type}, \TT{.initiator}, or \TT{.terminator}, 
		  then instead of creating a new
		  \TT{BRACKETED} token, any \TT{.type}, \TT{.initiator},
		  or \TT{.terminator} from the containing subexpression
		  is added to the \TT{BRACKETABLE} token,
		  the token type of this token is then
		  changed to \TT{BRACKETED}, and
		  its token position and \TT{.position} attribute are
		  updated to the position of its containing subexpression.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& Empty subexpressions are recorded as \TT{BRACKETABLE}
		  subexpressions whose MIN object has no elements and
		  no attributes other than \TT{.position}.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
		& A \TT{PREFIX} token is a
		  \TT{BRACKETED} token that has
		  been identified as a prefix separator.  It can be
		  converted to a \TT{BRACKETED} token when its identity
		  as a prefix separator is no longer useful.
		  A \TT{PREFIX} token necessarily has a \TT{.type},
		  which is recorded in
		  the \TT{value\_type} component of the token,
		  but the token does \underline{not} have an \TT{.initiator}
		  or \TT{.terminator}.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
		& An \TT{IMPLIED\_PREFIX} token is a prefix token that
		  was inserted as an implied header
                  (see \itemref{LINE-VARIABLES}).  It is just like
		  a \TT{PREFIX} token except that it is deleted and
		  ignored if it heads a {\em prefix-n-list} with zero
		  elements.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
		& A \TT{DERIVED} token is a non-lexeme that which has
		  a token \TT{value} that is \underline{not} a MIN object.
		  For example, a bracketed
		  subexpression reformatter may
		  produce a \TT{DERIVED} token with a \TT{value} that is
		  a MIN special value or a MIN label.
\end{tabular}
\\[1ex]  
\begin{tabular}{p{1in}p{4.5in}}
		& \TT{BRACKETED}, \TT{BRACKETABLE}, \TT{PREFIX},
		  \TT{IMPLIED\_PREFIX} and \TT{DERIVED}
		  tokens are called
		  \skey{expression token}s and \TT{OPERATOR} and lexeme
		  tokens are called non-expression tokens.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{value}{of token}
		& The token \TT{value}, as described above.  This is
		  a MIN string, label, special value, or object.
		  For tokens that do not have \TT{value}'s, this is \TT{MISSING}
		  (but for \TT{DERIVED} type tokens the token my have
		  a \TT{value} that equals \TT{MISSING}).
\\[1ex]
		& Note that natural-numbers have token \TT{value}'s that are MIN
		  strings equal to their lexemes,
		  and are \underline{not} MIN numbers.
		  This allows very large natural-number lexemes,
		  and does not try to exploit the 1-1 correspondence
		  between not-too-large natural-number lexemes and
		  non-negative integral MIN numbers.  It means that
		  equal natural numbers with differing numbers of
		  leading zeros are different symbols (see \pagref{SYMBOL}).
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{value\_type}{of token}
		& This token component can be computed from other
		  token components, and exists purely to optimize finding
		  the \TT{.initiator}, \TT{.type}, or header group
		  of the token \TT{value}.
\\[1ex]
		& For a \TT{BRACKETED} token whose
		  token \TT{value} has an \TT{.ini\-tiator},
		  the value of this \TT{.initiator}.  For a
		  \TT{BRACKETED} token whose \TT{value} was derived
		  from a headed line or headed paragraph
		  (\itemref{HEADED-LINES} and \itemref{HEADED-PARAGRAPHS})
		  and has a \TT{.type}
		  with either the `\TT{paragraph}' or `\TT{line}'
		  prefix group, the value of this prefix group.
		  For a \TT{PREFIX} token, the \TT{.type} of the token
		  \TT{value} if there is one.  Otherwise \TT{MISSING}.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{string}{of token}
		& For quoted string and numeric lexemes,
		  which do not have token \TT{value}'s,
                  this is the translation string of the lexeme,
		  stored in a manner that makes
		  garbage collection and memory reuse more
		  efficient than it would be if MIN strings
		  were used, but makes lookup less efficient.
\\[1ex]
		& For all other tokens this equals
		  \TT{min::\EOL NULL\_\EOL STUB}.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{position}{of token}
		& The positions in the input file of
                  the first character of the token
		  and the first character after the token in the
		  input text.  A character position records a line number
		  and the byte offset within a UTF-8 encoding
		  of the line.  The column containing the character
		  can then be computed from the line itself, the format
		  in which the line is being printed, and the
		  byte offset of the character.
\end{tabular}
\\[1ex]
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{indent}{of token}
	        & For an indent lexeme only,
		  the indent of the first character after the lexeme.  See
		  \pagref{INDENT-OF-CHARACTER}.
\end{tabular}
\end{indpar}

Tokens are organized in a doubly threaded list.  A file is translated into
such a list of lexeme tokens that begins with a beginning-of-file lexeme token
and ends with an end-of-file lexeme token.
The lexeme tokens of a file are not read in all at once.  When more tokens
are needed, they are read from the file until an indent or end of file
token has been read.

Lexemes are read by a lexical scanner which can be controlled by
resetting the master table from which the scan of the next lexeme
starts (see \pagref{MASTER-TABLE}).  In the parser, the master
can be reset at the beginning of a logical line (see \itemref{LOGICAL-LINES}).

As the parser identifies subexpressions, the tokens in the
subexpression are replaced by a single expression token (of
type \TT{BRACKETED}, \TT{BRACKETABLE}, \TT{PREFIX},
\TT{IMPLIED\_PREFIX}, or \TT{DERIVED})
that encodes the subexpression.
Although at the top level an entire
input file can be considered to be a list of logical lines (see below),
the parser \underline{never}
forms a single token that would represent this list, but instead
delivers top level logical line tokens
one at a time for subsequent
processing.  These top level tokens appear in the
the token stream as they are created,
and never again accessed by the parser.
They are just after the file beginning
lexeme token, and may be removed from the token stream at any time
by post-parser processing.

\subsection{Logical Lines}
\label{LOGICAL-LINES}

Input is parsed into a sequence of \skey{logical line}s, each of which is
a sequence of tokens.  Once parsed, logical lines may be grouped into
paragraphs.

In the input physical lines begin with an indent lexeme token that
contains an indentation that is the number of columns before the first
graphic character in the physical line (which cannot be a blank line or
line containing just a comment).
By `\key{indent token}' we mean such
a token and by an `\mkey{indent}{of indent token}' we mean the indentation
of an indent token or an integer that will be compared to such.

A logical line begins just after the first indent token in the
file or the first indent token after the previous logical line.
The indent of this token is called the `\key{line indent}'.
A logical line ends with one
of the following as controlled by parser options defined in
Figures~\itemref{END-AT-OPTIONS-1}
and~\itemref{END-AT-OPTIONS-2}:

\begin{itemize}
\item An indent token with indent equal to or less than the current indent.
\item An indent token with indent less than the current indent.
\item Any line break.
\item Any completely blank (non-comment) line.
This is called a `\key{paragraph break}'.
\item A line separator, e.g.~`\TT{;}'.
\item The end of file.  An end of file always terminates a logical line,
regardless of option settings.
\end{itemize}

\begin{boxedfigure}[!p]

\begin{indpar}[0.5in]

\hspace*{-0.2in}\ttmkey{end at line break}{parser option} \\
    This parser option causes a simple line break to end a logical line.
    In this case continuation lines are not possible.

\vspace*{-0.05in}
\hspace*{-0.2in}\ttmkey{end at paragraph break}{parser option} \\
    This parser option causes a blank line to end a logical line.
    If this option is not present, blank lines have no affect
    on parsed input.

    This option is most often used with an implied paragraph header
    (\itemref{LINE-VARIABLES})
    to turn sequences of lines between blank lines into headed paragraphs
    (\itemref{HEADED-PARAGRAPHS}).
    

\vspace*{-0.05in}
\hspace*{-0.2in}\ttmkey{end at le indent}{parser option} \\
    This parser option causes an indent token with indent less than
    \underline{or equal to} the current indent to end a logical line.
    This means that logical lines can be continued by input lines
    with indent greater than the current indent, assuming other
    options permit.

\vspace*{-0.05in}
\hspace*{-0.2in}\ttmkey{end at lt indent}{parser option} \\
    This parser option causes an indent token with indent less than
    the current indent to end a logical line.
    This means that logical lines can be continued by input lines
    with indent \underline{equal to} or greater
    than the current indent, assuming other
    options permit.

\vspace*{-0.05in}
\hspace*{-0.2in}\ttmkey{end at line separator}{parser option}
\label{END-AT-LINE-SEPARATOR} \\
    This parser option allows a line separator to end a logical line.
    The line separator controlled is that of either the top level
    when not inside an indented paragraph (default is `\TT{;}'),
    or of the smallest containing indented paragraph when inside
    an indented paragraph.

    If this option is off or is turned off by an opening bracket
    or indentation mark or prefix separator,
    the controlled line separator will not
    be recognized anywhere in the the bracketed subexpression,
    indented paragraph, or prefix list.

\vspace*{-0.05in}
\hspace*{-0.2in}\ttmkey{end at outer closing}{parser option} \\
    This parser option allows a bracketed subexpression or
    indented paragraph to be
    ended by the closing bracket of a containing bracketed subexpression
    in the same logical line.
    E.g., in `\TT{[x(y]}' the `\TT{]}' is permitted to end the
    subexpression `\TT{(y}' by automatically inserting a `\TT{)}'
    before the `\TT{]}', while also announcing an error.

    If this option is off, the only closing bracket that will be
    recognized is that of the innermost open bracketed expression.
    Also, a bracketed subexpression that contains an indented paragraph
    will contain logical lines, but these contained logical lines
    can never contain the closing bracket of the subexpression.


\end{indpar}

\medskip

\caption{\bf Parsing End-At Options: Part I}
\label{END-AT-OPTIONS-1}

\end{boxedfigure}

\begin{boxedfigure}[!t]

Two option groups are also defined:

\begin{center}
\begin{tabular}{ll}
\ttmkey{default options}{parser option group}
				& \TT{end at le indent} \\
				& \TT{end at line separator} \\
				& \TT{end at outer closing}
\\[2ex]
\ttmkey{other end at options}{parser option group}
				& all `\TT{end at}' options
\end{tabular}
\end{center}

\TT{Default options} are also the parser top level options.

\medskip

\caption{\bf Parsing End-At Options: Part II}
\label{END-AT-OPTIONS-2}

\end{boxedfigure}

The above makes use of the notion of a \key{current indent}.  At top
level this is just \TT{0}.  An indented paragraph changes the current
indent to the indent of the first indent token within the indented
paragraph.  See \itemref{PARAGRAPHS} for more detail.

Note that in applying the above comments and lines containing
just a comment are ignored.  Thus a `blank line' means any sequence
of comment line and blank lines containing at least one completely
blank line.

Prefix separators, brackets, and indentation marks, all of which
can be used to change syntax, can change the options that control
what terminates a logical line.  Thus if at top level logical
lines end with a line break followed by a non-indented line
(i.e., an indent token with \TT{0} indent),
but the opening bracket \TT{`{}`{}`} changes the parser options so that
the current logical line is continued by any physical line regardless of
indent (and the corresponding closing bracket \TT{'{}'{}'} restores
the top level options), then the input:
\begin{indpar}\begin{verbatim}
This logical line contains ```
This quoted
paragraph is inside a logical
line!''',
    which is a subexpression.
\end{verbatim}\end{indpar}

is parsed to the logical line
\begin{indpar}\begin{verbatim}
This logical line contains @ which is a subexpression.
\end{verbatim}\end{indpar}

where \TT{@} represents the subexpression

\begin{indpar}\begin{verbatim}
```This quoted paragraph is inside a logical line!'''
\end{verbatim}\end{indpar}

As another example, if the indentation mark `\TT{:}' does not
change the top level line ending options, but
the prefix separator \TT{\{p\}} changes these
options so that only a blank line, the beginning of a
line indented less than the current indent, or an end of file
terminate a logical line,
then:
\begin{indpar}\begin{verbatim}
This logical line contains:
    {p} This is a headed paragraph
    in the indented paragraph.

    {p}
    And this is a second
    headed paragraph.
This is the next logical line.
\end{verbatim}\end{indpar}

is parsed to two logical lines, the first containing an indented paragraph
whose sole elements are:
\begin{indpar}\small\begin{verbatim}
{p|This is a headed paragraph in the indented paragraph "."|p}
\end{verbatim}\end{indpar}

and

\begin{indpar}\begin{verbatim}
{p|This is a second headed paragraph "."|p}
\end{verbatim}\end{indpar}

Note that a closing bracket or a prefix separator can \underline{not}
force the end of a logical line.  Subexpressions bracketed by opening
and closing brackets must be inside a logical line.  Similarly subexpressions
delimited by prefix separators must be inside a logical line, with the
exception of headed paragraphs beginning with paragraph prefix separators like
\TT{\{p\}} in the example.

The master table used to scan the lexemes of a logical line
is called the `\key{lexical master}'\label{LEXICAL-MASTER} of the line.
This can be reset at the beginning of the logical line,
and will be effective for all lexemes in the line after the indent token
preceding the logical line and through and including any indent token
that follows the logical line.
See \itemref{LINE-VARIABLES} for more details.

\subsection{Paragraphs}
\label{PARAGRAPHS}

There are two kinds of \skey{paragraph}s: indented and headed.
Paragraphs consist of sequences of logical lines, or in the case
of some headed paragraphs, of a single logical line.

An \key{indented paragraph} begins with an indentation mark at the
end of a physical line, and is most frequently the last thing in the
logical line to which this physical line belongs.  The indentation
mark resets the \key{current indent} for the duration of the indented
paragraph to the indent of the next indent token (the indent of
the next non-blank, non-comment line), if this indent
is greater than the current indent at the time the indentation mark
is encountered.  If the indent is not greater, or if there is an
end of file before any indent token, the indented paragraph is
empty and contains no logical lines.

The current indent during the duration of an indented paragraph is
also referred to as the \key{paragraph indent} of that indented paragraph.
The paragraph ends with the first indent token that has a smaller
indent (first non-blank, non-comment line with smaller indent),
or with an end of file.

Top level parsing behaves as if input were in an indented paragraph
with \TT{0} paragraph indent and a fictious indentation mark named
`\TT{TOP LEVEL}'.

Details on indented paragraphs are given
in \itemref{INDENTED-PARAGRAPH-SUBEXPRESSIONS}.

An \key{headed paragraph}
begins with explicit or implicit \skey{paragraph header},
which is a prefix separator such as the `\TT{\{p\}}'s in
\begin{indpar}\begin{verbatim}
{p} This is a
paragraph.

{p}
And another
paragraph.
\end{verbatim}\end{indpar}

The type of the paragraph header, \TT{p} in this example, must 
appear in the parser's \key{prefix table} (\itemref{PREFIX-DEFINITIONS}),
and be marked there as a paragraph header (i.e., must have the `\TT{paragraph}'
group).  A paragraph header must appear at the
beginning of a logical line that is itself either at the
beginning of an indented paragraph or just after a blank line
that follows another logical line.
A headed paragraph ends with the next blank line that
follows a logical line (there is an exception if the paragraph prefix table
entry has the
`\TT{continuing}' property), or when the indented paragraph that
contains the headed paragraph ends (this can be at an
end of file).


Details on headed paragraphs are given in
\itemref{HEADED-PARAGRAPHS}.

While an indented paragraph is being scanned, there is a
`\mkey{implied header}{in line variables}' that if not \TT{MISSING}
is inserted at the beginning of each logical line in the indented paragraph
that does not have its own beginning header.  This implied header
may be a paragraph header (\itemref{HEADED-PARAGRAPHS})
or a line header (\itemref{HEADED-LINES}).

There is also a `\mkey{lexical master}{in line variables}'
table index, which when not \TT{0} specifies the
lexical master used to scan logical line lexemes
(see \pagref{LEXICAL-MASTER}).
This scan can introduce special lexemes at the beginning of the
logical line that are based on
the first characters in the logical line,
and these lexemes can be mapped to paragraph or line headers
(see \itemref{MAPPED-LEXEMES}).

A paragraph header changes both the implied header and lexical master
temporarily while the logical lines of the headed paragraph are being
scanned (\itemref{LINE-VARIABLES}).

\subsection{Parser Symbol Tables}
\label{PARSER-SYMBOL-TABLES}

Sequences of lexemes encoded as tokens are looked up in
\skey{parser symbol table}s.
A parser symbol table is conceptually a stack of
\skey{parser definition}s.

There are different symbol tables for different parser passes, as each pass
looks up only pass specific definitions.  Some passes have more than
one symbol table.

Each parser definition has the following
components:

\begin{indpar}
\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{label}{of symbol table entry}
		& A non-empty
		  sequence of `symbols' that identifies the definition.
\\[1ex]
		& A \key{symbol}\label{SYMBOL} is a MIN string equal to the
		  lexeme string of a word, mark, separator,
		  or natural-number lexeme.  Quoted string and numeric
		  lexemes are not symbols.
\\[1ex]
		& Labels are symbol table `\skey{key}s', that is, they
		  are what is looked up in a symbol table.
\\[1ex]
		& If a label has just one symbol, it is represented by
		  a MIN string.  Otherwise it is represented by
		  a MIN label whose elements are MIN strings
		  equal to the symbols.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{type}{of symbol table entry}
		& The type of the definition.  Each parser pass has
		  one (or sometimes more) symbol tables containing
		  definitions of types particular to the pass.
		  For example, the bracketed subexpression recognition
		  pass has a symbol table containing symbols of type
		  \TT{opening bracket}, \TT{indentation mark},
		  and \TT{line separator}, among others.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{selectors}{of symbol table entry}
		& A set of \skey{parsing selector}s that determine if
		  the definition is active.  See text.
\end{tabular}

\begin{tabular}{p{1in}p{4.5in}}
\ttmkey{level}{of symbol table entry}
		& Block nesting level, 0, 1, 2, \ldots, of the parser block
		  containing the definition that made this symbol
		  table entry.  When the parser block ends, this entry
		  will be removed from the symbol table stack.  The top level is
		  level 0, which is outside all parser blocks.
\end{tabular}
\end{indpar}

Lookup in a parser symbol table takes as input a token sequence
that is part of a line (for the bracketed subexpression recognition pass)
or subexpression (for other passes), and finds an active symbol table
entry with a label whose symbols match an initial segment of the
token sequence.  Only symbol tokens, with lexeme types word,
mark, separator, or natural-number, can match label symbols.  These are just
the token types that have values which are MIN strings equal to the
translation strings of their lexemes, and it is these values that
are matched for equality with the table entry label symbols.
When a match is found,
the initial segment of tokens used in the match is called
a `\key{matched label}\,'.

At any point the longest active match is chosen.  Entries may
not be active because they have the wrong type or wrong selectors (see below)
for the current parser pass or context.
Entries may be activated only when other entries are recognized
in the current context, as when afix operators become active
only after an associated non-afix operator is recognized in
the same subexpression (see \pagref{AFIX-OPERATOR}).

In the bracketed
subexpression recognition pass matched labels may not span physical
line boundaries.
In later passes, physical line boundary tokens are no longer present, and
matched labels can span physical line boundaries,
but cannot cross bracketed subexpression
boundaries.

The context of a symbol table lookup includes a set of
\skey{parsing selector}s.\label{PARSING-SELECTORS}
In order to be active, a symbol table entry's set of selectors
must have some selector in common with the parsing selectors.
A selector set is represented as a 47-bit unsigned integer value
with the bit in
position 1\TT{<{}<}N being on if the N+1'st selector is in the set.
Thus there can be at most 47 distinct selectors used by any set of
parser definitions.  The selectors that can be
currently used are given names that are sequences of symbols,
and must be referenced by these names.

The parsing selectors may change when an explicit opening bracket,
indentation mark, or prefix separator
is recognized, and remain changed until the associated explicit closing
bracket, end of indented paragraph, or end of prefix separator list
is recognized.  The parser also has top level set of selectors
used to begin parsing a top level logical line, and these top level
selectors can be changed by parsing commands.

There are no other mechanisms for setting or changing the
parsing selectors.

The following parsing selectors are builtin:

\begin{indpar}[0.5in]

\hspace*{-0.2in}\ttmkey{TOP LEVEL}{top level selector} \\
    This is on when a top level logical line is parsed, and off
    when indented paragraph logical lines or a bracketed
    subexpression is parsed.

\hspace*{-0.2in}\ttmkey{data}{parser selector} \\
    This selects symbol table entries that parse raw data.  Is
    it used to enable symbol table entries that parse prefix
    separators and the type/attribute parts of typed
    brackets.

\end{indpar}

One selector group is also defined:

\begin{center}
\begin{tabular}{ll}
\ttmkey{other selectors}{parser selector group}
				& all selectors
\end{tabular}
\end{center}

For a few parser symbol tables lookup does not use a sequence
of tokens, but instead uses a pre-scanned sequence of symbols,
such as the type of a prefix separator.  An example of such
a symbol table is the prefix table (\itemref{PREFIX-DEFINITIONS}).

The parser symbol tables act like stacks; as new parsing
definitions are encountered, they are are `pushed' into the
symbol tables.  These stacks can be popped, removing
the parser definitions in reverse order.  When a definition
is popped, its effects are removed from the symbol tables.
Definitions are popped by the ends of parser blocks: see
\pagref{PARSER-BLOCKS}.

It is also possible to `\mkey{undefine}{parser symbol table entry}'
parser symbol table entries by clearing some or all of their selectors.
One can also think of `undefine's as being pushed into and popped
from symbol tables,
where pushing corresponds to clearing selectors from some entries
and popping corresponds to restoring those selectors to their
previous state.


\subsection{Parser Commands}
\label{PARSER-COMMANDS}

Parser commands are logical lines within a {\em parser-command-paragraph}
that change parser tables.
The syntax of a parser commands in general and in particular those
associated block definition, parser trace flags, and parser selectors
is specified in Figure~\itemref{PARSER-COMMAND-SYNTAX}.

A {\em parser-command-paragraph} is an indented paragraph on a line by itself
that has the indentation mark `\TT{*PARSER*:}',
Thus `\TT{*PARSER*:}' must appear by itself in a top level
physical line, and the indented logical lines that follow are
{\em parser-commands}.

\begin{boxedfigure}[!p]
\emkey{parser-command-paragraph}
    \begin{tabular}[t]{@{}rlrl@{}}
    ::= & \TT{*PARSER*:}\index{PARSER@{\tt *PARSER*:}} \\
    	& ~~~~{\em parser-command}\STAR{}
    \end{tabular}
\label{PARSER-COMMAND-PARAGRAPH}
\\[0.6ex]
\emkey{parser-test-paragraph}
    \begin{tabular}[t]{@{}rlrl@{}}
    ::= & \TT{*PARSER* *TEST:}\index{parser test@{\tt *PARSER* *TEST:}} \\
    	& ~~~~{\em logical-line}\STAR{}
    \end{tabular}
\\[0.6ex]
\emkey{parser-command}
    \begin{tabular}[t]{@{}rlrl@{}}
    ::= & {\em parser-block-command} &
    $|$ & {\em parser-trace-command} \\
    $|$ & {\em parser-selector-command} &
    $|$ & {\em parser-bracketed-command} \\
    $|$ & {\em parser-pass-command} &
    $|$ & {\em parser-operator-command}
    \end{tabular}
\label{PARSER-COMMAND}
\\[0.6ex]
\emkey{simple-name} ::= {\em word} \{ {\em word} $|$ {\em natural-number}
            \}\STAR{}
\\[0.0ex]
\emkey{key}\label{KEY}
    ::= \{ {\em separator} $|$ {\em mark} $|$ {\em word}
                           $|$ {\em natural-number} \}\PLUS{}
\\[0.0ex]
\emkey{quoted-key}\label{QUOTED-KEY}
    :::= \TT{"}{\em key}\TT{"}
\\[0.0ex]
\emkey{partial-name} ::= \TT{""} | {\em quoted-key}
\\[0.6ex]
\emkey{parser-flag} ::= {\em simple-name}
\\[0.0ex]
\emkey{parser-flag-list}\label{PARSER-FLAG-LIST}
    ::= \TT{[ ]}  $|$ \TT{[} {\em parser-flag}
          \{ \TT{,} {\em parser-flag} \}\,\STAR{} \TT{]}
\\[0.0ex]
\emkey{parser-flag-modifier-list}
    \begin{tabular}[t]{@{}r@{~}l@{~}l@{}}
    ::= & \TT{[} & {\em parser-flag-op} {\em parser-flag} \\
        &         & \{ \TT{,} {\em parser-flag-op}
	                        {\em parser-flag} \}\,\STAR{} \TT{]} \\
    \end{tabular}
\\[0.0ex]
\emkey{parser-flag-op} ::= \TT{+} $|$ \TT{-} $|$ \TT{\textasciicircum}
\\[0.0ex]
\emkey{parser-flag-spec} ::= {\em parser-flag-list} $|$
                              {\em parser-flag-modifier-list}
\\[0.6ex]
\emkey{selector} ::= {\em parser-flag} as per \pagref{SELECTOR-NAMES}
\\[0.0ex]
\emkey{selectors} ::= {\em parser-flag-list}
                      with only selector names (\pagref{SELECTOR-NAMES})
\\[0.0ex]
\emkey{selector-spec} ::= {\em parser-flag-spec}
                          with only selector names (\pagref{SELECTOR-NAMES})
			  \label{SELECTOR-SPEC}
\\[0.0ex]
\emkey{selector-flags} ::= {\em parser-flag-list}
                          with only selector names (\pagref{SELECTOR-NAMES})
			  \label{SELECTOR-FLAGS}
\\[0.0ex]
\emkey{end-at-option} ::= {\em parser-flag} as per \pagref{END-AT-OPTIONS-1}
\\[0.0ex]
\emkey{end-at-option-spec} ::= {\em parser-flag-spec}
                          with only end at option names
			  (\pagref{END-AT-OPTIONS-1})
			  \label{END-AT-OPTION-SPEC}
\\[0.0ex]
\emkey{trace-flag} ::= {\em parser-flag} as per \pagref{TRACE-FLAGS}
\\[0.0ex]
\emkey{trace-flag-spec} ::= {\em parser-flag-spec} with only trace flag names
			    (\pagref{TRACE-FLAGS})
\\[0.6ex]
\emkey{parser-block-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttmkey{begin block}{parser command} ~ {\em block-name} \\
    $|$ & \ttmkey{end block}{parser command} ~ {\em block-name} \\
    \end{tabular}
\label{PARSER-BLOCK-COMMAND}
\\[0.0ex]
\emkey{block-name} ::= {\em simple-name}
\\[0.6ex]
\emkey{parser-selector-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttmkey{define selector}{parser command} ~ {\em selector} \\
    $|$ & \ttmkey{print selector}{parser command} ~ {\em partial-name} \\
    $|$ & \ttmkey{define top level}{parser command} \\
        & ~~~~~~~~\TT{with parsing selectors} ~ {\em selector-spec} \\
        & ~~~~~~~~\TT{with parsing options} ~ {\em end-at-option-spec} \\
        & ~~~~~~~~\TT{with lexical master} ~ {\em master-name} \\
    \end{tabular}
\label{PARSER-SELECTOR-COMMAND}
\\[0.6ex]
\emkey{parser-trace-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & \ttmkey{trace}{parser command} ~ {\em trace-flag-spec} \\
    $|$ & \ttmkey{print trace}{parser print} \\
    \end{tabular}
\label{PARSER-TRACE-COMMAND}

\medskip

\caption{\bf Parser Command Syntax}
\label{PARSER-COMMAND-SYNTAX}

\end{boxedfigure}

A {\em parser-command-paragraph} is first completely parsed, and then
the commands it contains are executed in order.
The \TT{*PARSER*:}' indentation mark sets the parser selectors
to `\TT{[data]}', so only the `\TT{data}' selector is present when
parser commands are parsed.  It is possible, but not advisable, to
use parser commands to alter the way that input is parsed if only
the `\TT{data}' selector is present.

Parser commands make use of {\em simple-names} that are just a {\em word}
optionally followed by a sequence of {\em words} and/or {\em natural-numbers}.
Parser commands also make use of
{\em quoted-keys}, that are arbitrary sequences of {\em word},
{\em mark}, {\em separator}, and {\em natural-number} lexemes enclosed
in quotation marks to form a {\em quoted-string} lexeme.
This embedding of lexemes in a {\em quoted-string} lexeme
serves to keep the embedded lexemes from being given a special
interpretation by the parser when the parser command is parsed.

Parser commands may be organized into \skey{parser-block}s of the form:%
\label{PARSER-BLOCKS}
\begin{center}
\begin{tabular}{l}
\TT{*PARSER*:} \\
\TT{~~~~}\TT{begin block} {\em block-name} \\
\TT{~~~~}{\em parser-command} \\
.~.~.~.~.~.~.~.~.~. \\
\TT{*PARSER*:} \\
\TT{~~~~}\TT{end block} {\em block-name} \\
\end{tabular}
\end{center}

When a parser block ends, all changes to the parser tables made in
the block are erased, so subsequent parsing is as if the block
had never existed.
The {\em block-name} merely serves as an error check; it is
not possible to have one `\TT{end block}' command end more than
one parser block.

The parser has several sets of \emkey{parser-flags}\index{flags!parser}:
\begin{center}
\begin{tabular}{lll}
parsing selectors 	& 47 bits	& \pagref{PARSING-SELECTORS} \\
parsing end at options	& 6 bits	& \pagref{END-AT-OPTIONS-1} \\
parsing header options	& 2 bits	& \pagref{PARSING-HEADER-OPTIONS} \\
parsing trace flags	& 64 bits	& \pagref{TRACE-FLAGS} \\
\end{tabular}
\end{center}
A set of parser flags can be
specified by giving a {\em parser-flag-list} or a
{\em parser-flag-modifier-list}.

When a \emkey{parser-flag-modifier-list}\label{FLAG-MODIFIER-LIST}
is used, the flag set is made by modifying the current
flag set (trace flags, selectors, or options) according to the
instruction's `{\em parser-flag-op} {\em parser-flag}' pairs.
These pairs are interpreted as follows:
\begin{center}
\begin{tabular}{ll}
\TT{+} {\em parser-flag} & set the named flag \\
\TT{-} {\em parser-flag} & clear the named flag \\
\TT{\textasciicircum}{\em parser-flag} & complement (flip) the named flag \\
\end{tabular}
\end{center}

In either the case of a {\em parser-flag-list} or
{\em parser-flag-modifier-list} no flag may be named more than once.

Each particular kind of flag can also have flag groups, which are names
of sets of flags.  If a flag group name is used, it is effectively
replaced by the names of all the flags in the group, \underline{except}
those flags explicitly named in the {\em parser-flag-list} or
{\em parser-flag-modifier-list} in which the flag group name appears.
So for example, the flag modifier list
\begin{center}
\TT{[+ other end at options, - end at paragraph break]}
\end{center}
is equivalent to a {\em parser-flag-list} setting all end-at options
except \TT{end at paragraph break} which is cleared.
This is because the group name
\TT{other end at options} denotes the set of all end-at options, but
since \TT{end at paragraph break} is explicitly mentioned in this
{\em parser-flag-modifier-list}, it is deleted from the set in this
context.

\subsubsection{Parser Selector Commands}
\label{PARSER-SELECTOR-COMMANDS}

The only builtin selector names\label{SELECTOR-NAMES}
are `\TT{TOP LEVEL}' and `\TT{data}'.
Other selector names must be defined by the {\em parser-selector-command}:
\begin{center}
    \ttmkey{define selector}{parser command} ~ {\em selector}
\end{center}
When the parser block containing a selector name definition
command ends, the selector name is erased.
There may be at most 47 selectors, including the builtin selectors,
defined at any one time.

The selector print command:
\begin{center}
    \ttmkey{print selector}{parser command} ~ {\em partial-name}
\end{center}
prints all selectors whose names contain the {\em partial-name}.
In particular,
\begin{center}
    \TT{print selectors ""}
\end{center}
prints all selectors.
The block in which each selector is defined is also printed.
Here a {\em partial-name} is a sequence of lexemes that is matched
to any subsequence of lexemes in a selector name, not just an initial
subsequence.  There is \underline{no} matching of partial lexemes.

The top level selectors and end-at options can be reset by the
{\em parser-selector-command}:
\begin{center}
    \begin{tabular}[t]{l}
    \ttmkey{define top level}{parser command} \\
    \TT{~~~~}[ \TT{with parsing selectors} {\em selector-spec} ] \\
    \TT{~~~~}[ \TT{with parsing options} {\em end-at-option-spec} ] \\
    \TT{~~~~}[ \TT{with lexical master} {\em master-name} ] \\
    \end{tabular}
\end{center}

The \TT{TOP LEVEL} selector is always set implicitly by this command, and is
the only default selector if no `\TT{define top level}' commands
are given.  So the \TT{TOP LEVEL} selector is always included in the
top level selectors.

The \key{standard parser} creates a single initial parsing block
named `\ttmkey{standard}{parsing block}' and defines in it the selectors
\begin{center}
\ttkey{code} ~~~ \ttkey{text} ~~~ \ttkey{math}
\end{center}
The standard parser also sets the top level selector set to contain just
`\TT{TOP LEVEL}' and `\TT{code}'.

Thus the standard parser begins by executing the
equivalent of
\begin{indpar}\begin{verbatim}
*PARSER*:
    begin block standard
    define selector code
    define selector math
    define selector text
    define top level
        with parsing selectors [code]
\end{verbatim}\end{indpar}

The end of a parser block erases the effects of any
{\em parser-selector-commands} executed during the block.
Thus the actions of the standard parser can be
canceled by an `\TT{end block standard}' parser command.

\subsubsection{Parser Trace Commands}
\label{PARSER-TRACE-COMMANDS}

The current set of
\skey{parsing trace flag}s\index{trace flag!parser}\index{flag!parsing trace}
may be given or modified by the {\em parser-trace-command}:
\begin{center}
    \ttmkey{trace}{parser command} ~ {\em trace-flag-spec}
\end{center}
Trace flags cause trace printouts to the printer the parser uses
for error messages.  The trace flag names are builtin and are listed
in Figure~\itemref{TRACE-FLAGS}.

\begin{boxedfigure}[!p]

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttmkey{parser input}{parsing trace flag} ~
    When the parser reads a token from the input,
    a description of the token is printed.

\hspace*{-0.2in}\ttmkey{parser output}{parsing trace flag}
    When the parser produces a output line token, the token value
    is printed.

\hspace*{-0.2in}\ttmkey{parser commands}{parsing trace flag}
    Upon successfully finishing the execution of a parser command,
    the command is printed (if the command is in error the error
    printout will print the command).

\hspace*{-0.2in}\ttmkey{bracketed subexpressions}{parsing trace flag}
    Enables tracing for the parser bracketed subexpression recognition pass.

\hspace*{-0.2in}\ttmkey{operator subexpressions}{parsing trace flag}
    Enables tracing for the parser operator recognition pass.

\hspace*{-0.2in}\ttmkey{subexpression elements}{parsing trace flag}
    The printing of a value by the `\TT{parser output}' or
    `\ldots{} \TT{subexpressions}' trace flags, or of a logical line
    in a {\em parser-test-paragraph}, includes
    a direct rendition of the value with implicit brackets and
    graphic representations of non-graphic characters
    shown.  This is the default.

\hspace*{-0.2in}\ttmkey{subexpression details}{parsing trace flag}
    The printing of a value by the `\TT{parser output}' or
    `\ldots{} \TT{subexpressions}' trace flags, or of a logical line
    in a {\em parser-test-paragraph}, includes
    a detailed rendition of the value with all attributes shown.

\hspace*{-0.2in}\ttmkey{subexpression lines}{parsing trace flag}
    The printing of a value by the `\TT{parser output}' or
    `\ldots{} \TT{subexpressions}' trace flags, or of a logical line
    in a {\em parser-test-paragraph}, includes
    the lines containing the value with the value producing subexpression
    within these lines underlined.

\hspace*{-0.2in}\ttmkey{keys}{parsing trace flag}
    During parsing of a subexpression by a trace-enabled parser 
    pass, the keys found in the pass symbol tables are printed.
    If a key is rejected after being found, a rejection message
    is also printed.

\end{indpar}

\bigskip

\caption{\bf Parsing Trace Flags}
\label{TRACE-FLAGS}
\end{boxedfigure}


The print command:
\begin{center}
    \ttmkey{print trace}{parser command}
\end{center}
prints the state of the current parser trace flags.

The end of a parser block erases the effects of any
{\em parser-trace-commands} executed during the block.

\subsubsection{Parser Define/Undefine Commands}
\label{PARSER-DEFINE/UNDEFINE-COMMANDS}

In the following sections various parser symbol table `\ttkey{define}' commands
are described.  These push entries into the parser symbol tables.
The general syntax of these is
\begin{center}
\TT{define} {\em type} {\em name} {\em selectors} \ldots 
\end{center}
and an example is
\begin{center}
\TT{define bracket "("~...~")" [operator, text]} \ldots
\end{center}
The {\em type}, `\TT{bracket}' in the example, identifies the parser pass into
whose symbol tables entries are to be pushed.  The {\em name},
`\TT{"("~...~")"}' in the example, gives {\em quoted-keys} that become
the entry labels.  The {\em selectors},
`\TT{[operator, text]}' in the example, specify the selector set of
the entries to be pushed.

The end of a parser block pops all entries pushed into parser
symbol tables during the block.

For each parser symbol table \TT{define} command
there is a companion parser
\ttkey{undefine} command that effectively undoes
the parser \TT{define} command by clearing selector bits in
the designated symbol table entries.  Its syntax is
\begin{center}
\ttmkey{undefine}{parser-command} ~ {\em type} ~ {\em name} ~ {\em selectors}
\end{center}
and it clears the specified selector bits from \underline{all} symbol table
entries with the same {\em type} and {\em name}.  When the
block containing a parser \TT{undefine} command ends, the
effects of that command are undone by restoring the cleared
selector bits to their previous state.

Thus the end of a parser block erases the effects of any
parser \TT{define} and \TT{undefine} commands executed during the block.

\subsubsection{Parser Test Paragraph}
\label{PARSER-TEST-PARAGRAPH}

A {\em parser-test-paragraph} may be used to test the parser.
It is an indented paragraph on a top level logical line by itself
that has the indentation mark `\TT{*PARSER* *TEST:}'.
Thus `\TT{*PARSER* *TEST:}' must appear by itself in a top level
physical line, and the indented logical lines that follow are the
lines whose parsing is to be tested.

A {\em parser-test-paragraph} is first parsed using the current top
level selectors, and then information about the each logical line
of the paragraph is printed according to the setting of the
trace flags:
\begin{center}
\TT{subexpression elements} \\
\TT{subexpression details} \\
\TT{subexpression lines} \\
\end{center}

A {\em parser-test-paragraph} has no effect other than to produce
the indicated printout.

\subsection{The Bracketed Subexpression Recognition Pass}
\label{BRACKETED-SUBEXPRESSION-RECOGNITION-PASS}

The bracketed subexpression recognition pass recognizes:
\begin{indpar}[0.5in]
\hspace*{-0.2in}indented paragraphs, consisting of a line-ending
    indentation mark (e.g.~`\TT{:}') followed by a sequence of
    indented logical lines, ended by a non-indented line or end
    of file \\
\hspace*{-0.2in}logical lines, which may end with any line break,
    or with a line break not followed by an indented line,
    or with a line break followed by a counter-indented line,
    or with a line separator (e.g.~`\TT{;}'),
    or with any blank line, or with an end of file \\
\hspace*{-0.2in}headed paragraphs,
    which are sequences of logical lines
    ended by a blank line, by the next headed paragraph,
    or by the end of a containing indented paragraph,
    where the whole headed paragraph begins with a paragraph
    header \\
\hspace*{-0.2in}brackets (e.g.~`\TT{(}' and `\TT{)}')
    and bracketed subexpressions, which must be inside logical lines \\
\hspace*{-0.2in}typed brackets (e.g.~`\TT{\{b|}' and `\TT{|b\}}')
    and typed bracketed subexpressions, which must be inside logical lines \\
\hspace*{-0.2in}typed prefix separators (e.g.~`\TT{\{p\}}')
    and prefix lists that are lists of subexpressions between
    typed prefix separators, which must be inside logical lines \\
\hspace*{-0.2in}paragraph and line headers, which are special typed prefix
    separators \\
\hspace*{-0.2in}mapped lexemes, which are special lexemes typically
    produced at the beginning of a logical line that are mapped onto
    paragraph or line headers or other typed prefix separators
\end{indpar}

The bracketed subexpression recognition pass also merges
quoted strings if they are in the same logical line and are
separated by the quoted string concatenator (e.g., `\TT{\#}').
Thus if logical lines end with a line break
but permit indented continuation lines, then
\begin{indpar}\begin{verbatim}
"This is a longer sentence"
    # " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across physical line boundaries.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

The concatenator can be changed by the parser command:
\begin{indpar}[0.1in]
\emkey{parser-string-concatenator-command}%
\label{PARSER-STRING-CONCATENATOR-COMMAND} ::= \\
\hspace*{3em} \ttmkey{define string concatenator}{parser command}
	  ~ {\em string-concatenator}
\\[0.5ex]
\emkey{string-concatenator} ::= {\em quoted-key} with a single component
		     $|$ \TT{disabled} $|$ \TT{enabled}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\end{indpar}

If {\em string-concatenator} is `\TT{disabled}', quoted strings
are never concatenated.  If it is `\TT{enabled}', consecutive
quoted strings are concatenated; that is, no concatenator lexeme
needs to be placed between the strings.

The end of a parser block erases the effects of any
{\em define-string-concatenator-commands} executed during the block.

The bracketed parser pass has three symbol tables.  The bracketed
symbol table contains:
\begin{indpar}[0.5in]
\hspace*{-0.2in}opening brackets (e.g.~`\TT{(}') and their
    corresponding closing brackets (e.g.~`\TT{)}') \\
\hspace*{-0.2in}indentation marks (e.g.~`\TT{:}')
    and any corresponding line separators (e.g.~`\TT{;}') \\
\hspace*{-0.2in}typed openings (e.g.~`\TT{\{}') and their
      corresponding typed closings (e.g.~`\TT{\}}') \\
      and typed middles (e.g.~`\TT{|}')
\end{indpar}

The bracketed parser pass also has a symbol table
for prefixes
(see \itemref{PREFIX-DEFINITIONS})
and a symbol table for mapped prefix lexemes (see \itemref{MAPPED-LEXEMES}).

In bracketed subexpression recognition, 
multi-lexeme keys in the bracketed symbol table
are not recognized in the
input if their lexemes are not all on the same physical line.
This is different from other parser passes, which are executed
after line breaks have been removed.

Like other parser passes, the bracketed subexpression recognition pass uses
parsing selectors and parsing options.
However, the bracketed subexpression recognition pass
is the only pass that can change these selectors and options.  Details are in
the following subsections.

In addition the bracketed subexpression recognition pass maintains
the parser current paragraph indent, which indicates how much
lines in the current paragraph should be indented.  This indent
may be changed by an indentation mark
(see \itemref{INDENTED-PARAGRAPH-SUBEXPRESSIONS}).

Syntactically a {\em bracketed-subexpression} may take many forms:

\begin{indpar}[0.1in]
\emkey{bracketed-subexpression}
    \begin{tabular}[t]{@{}rll@{}}
    ::= & {\em untyped-bracketed-subexpression}
        & see \itemref{UNTYPED-BRACKETED-SUBEXPRESSIONS} \\
    $|$ & {\em indented-paragraph-subexpression}
	& see \itemref{INDENTED-PARAGRAPH-SUBEXPRESSIONS} \\
    $|$ & {\em typed-bracketed-subexpression}
        & see \itemref{TYPED-BRACKETED-SUBEXPRESSIONS} \\
    $|$ & {\em typed-prefix-separator}
	& see \itemref{TYPED-PREFIX-SEPARATORS} \\
    $|$ & {\em prefix-n-list}
	& see \pagref{PREFIX-N-LIST} in \itemref{TYPED-PREFIX-SEPARATORS} \\
    $|$ & implied paragraph and line headers
	& see \itemref{HEADED-PARAGRAPHS} \\
    $|$ & mapped lexemes
	& see \itemref{MAPPED-LEXEMES} \\
    $|$ & {\em headed-lines}
	& see \itemref{HEADED-LINES} \\
    $|$ & {\em headed-paragraphs}
	& see \itemref{HEADED-PARAGRAPHS} \\
    \end{tabular}
\end{indpar}

However, some of these forms can only be recognized in particular
contexts, e.g., {\em indented-para\-graph-subexpressions} can only be
recognized if their beginning indentation mark is at the end of a physical line.
See the indicated sections for details.

The parser commands specific to the bracketed subexpression recognizer
are similarly divided:

\begin{indpar}[0.1in]
\emkey{parser-bracketed-command}
    \begin{tabular}[t]{@{}rll@{}}
    ::= & {\em parser-string-concatenator-command}
        & see \pagref{PARSER-STRING-CONCATENATOR-COMMAND} \\
    $|$ & {\em parser-untyped-bracket-command}
        & see \pagref{PARSER-UNTYPED-BRACKET-COMMAND} \\
    $|$ & {\em parser-indentation-mark-command}
        & see \pagref{PARSER-INDENTATION-MARK-COMMAND} \\
    $|$ & {\em parser-typed-bracket-command}
        & see \pagref{PARSER-TYPED-BRACKET-COMMAND} \\
    $|$ & {\em parser-prefix-command}
        & see \pagref{PARSER-PREFIX-COMMAND} \\
    $|$ & {\em parser-mapped-lexeme-command}
        & see \pagref{PARSER-MAPPED-LEXEME-COMMAND} \\
    $|$ & {\em bracketed-parser-print-command}
        & see \pagref{BRACKETED-PARSER-PRINT-COMMAND} \\
    \end{tabular}
\label{PARSER-BRACKETED-COMMAND}
\end{indpar}

The following subsections first describe the output of the
bracketed subexpression parser pass and then describe
the different kinds of
{\em bracketed-subexpressions} and their related
{\em parser-bracketed-commands}.  Lastly {\em bracketed-parser-print-commands}
are described.

\subsubsection{Bracketed Subexpression Parser Pass Output}
\label{BRACKETED-SUBEXPRESSION-PARSER-PASS-OUTPUT}

The bracketed subexpression recognizer converts
subexpressions to single \TT{BRACK\-ET\-ED} tokens whose \TT{value}'s
are MIN objects, or into \TT{DERIVED} tokens whose values are
not MIN objects (e.g., they are labels or special values).

The final output of the parser is a sequence of \TT{BRACKETED} tokens,
one per top level logical line or headed paragraph.
For each of these tokens,
its `\TT{value}' is a MIN object that encodes its logical line or
headed paragraph.

For {\em untyped-bracketed-subexpressions} that are \underline{not}
reformatted, the brackets become the
\TT{.ini\-ti\-ator} (e.g. `\TT{(}') and \TT{.terminator} (e.g., `\TT{)}').
{\em Indented-paragraph-subexpressions} are similar, with the
{\em indentation-mark} (e.g., `\TT{:}') being the \TT{.ini\-ti\-ator} and
the special value
\begin{center}
\ttsvkey{IN\-DEN\-TED\_\EOL PARAGRAPH}
\end{center}
being the
\TT{.term\-i\-na\-tor}.  The elements of an indented paragraph are
logical lines, whose \TT{.in\-i\-ti\-a\-tor}
is the special value
\begin{center}
\ttsvkey{LOGICAL\_LINE}
\end{center}
and whose \TT{.term\-i\-na\-tor}
is the line separator (e.g., `\TT{;}') if there is one,
or \TT{"<LF>"} otherwise.

For {\em typed-bracketed-subexpressions} there is \underline{no}
implied \TT{.initiator} or \TT{.terminator}, though these may
be given as explicit attributes.  There is a \TT{.type}
attribute unless the type is represented by \TT{""}.
{\em Prefix-n-lists} are just an alternate form of
{\em typed-bracketed-sub\-ex\-pres\-sions}, and headed paragraphs
are just an alternate form of {\em prefix-n-lists}.

The elements of a MIN object are the values of sub-subexpressions and
may themselves the MIN objects, as when brackets are nested.  The
elements of indented paragraphs are always logical lines or
headed subparagraphs.

If MIN object X has just one element that is a MIN object Y,
X has no attributes other than \TT{.type}, \TT{.initiator},
and \TT{.terminator}, and Y does not have any of these three
attributes, then X and Y are merged to get a new object with
the attributes of both X and Y and the elements of Y.  This is implemented
by having the bracketed subexpression parser give the token type
\TT{BRACKETABLE} to Y as a temporary token type indicating that Y
does not have any \TT{.type}, \TT{.initiator}, or \TT{.terminator}
attribute.  Then when X is formed, the knowledge of the structure
of X and the \TT{BRACKETABLE} type of Y permit the two objects
to be merged.%
\label{MERGING-BRACKATABLE-TOKENS}

Consider the example:
\begin{center}
\tt ( x, y 5, 8, w, p )
\end{center}

The token sequence
\begin{center}
\tt x "," y 5 "," 8 "," w "," p
\end{center}
is converted by the standard operator pass
(see \itemref{OPERATOR-PARSING-PASS})
to
\begin{center}
\tt \{"": .separator = "," | x  \{| y 5 |\} 8 w p |\}
\end{center}
where \TT{""} denotes a missing \TT{.type}.  This is a \TT{BRACKETABLE}
token.  If we denote it by Y,
then the full expression is
\begin{center}
\tt \{"": .initiator = "(", .terminator = ")" | Y |\}
\end{center}
and the above rule merges the attributes into Y to get
\begin{center}
\tt
\{"": \begin{tabular}[t]{l}
      .initiator = "(", .terminator = ")", .separator = "," \\
      | x  \{| y 5 |\} 8 w p |\}
      \end{tabular}
\end{center}
as the \TT{value} of a \TT{BRACKETED} token.

In the process of forming a MIN object, some tokens must be converted to
object elements.  If these tokens have MIN values, their values are used.
But for quoted string and numeric lexemes, there is a token \TT{string}
but no token \TT{value}.  Such tokens are converted to a MIN object
whose \TT{.type} is \TT{"<Q>"} for a quoted string or \TT{\#} for
a numeric, and whose single element is a MIN string equal to the
token \TT{string}.

Note that natural-numbers, consisting of just decimal digits
with no leading zeros, are not numeric lexemes, and have MIN string
values equal to the lexeme (the string of digits).  This allows
arbitrarily long natural-numbers to be used in names.

Thus for example, the parser input
\begin{center}
\tt \{| 98765432109876543210 "HELLO" 3.4 |\}
\end{center}
produces a \TT{BRACKETED} token whose \TT{value} is a MIN object with
\underline{no} attributes and with the three elements that
can be represented as:
\begin{center}
\begin{tabular}{lll}
\TT{98765432109876543210}	& MIN string	& from natural number token \\
\TT{\{"<Q>"| HELLO |\}}		& MIN object	& from quoted string token \\
\TT{\{\# 3.4 \#\}} or \TT{\{"\#"| 3.4 |\}}
				& MIN object	& from numeric token \\
\end{tabular}
\end{center}

{\em Untyped-bracketed-subexpressions} may be reformatted to
produce tokens of \TT{DERIVED} type with \TT{value}'s that may be
MIN labels or special values.  Examples are:
\begin{center}
\begin{tabular}{ll}
\TT{[\$ LOGICAL\_LINE \$]}	& MIN special \TT{LOGICAL\_LINE} value \\
\TT{[< A B 5 >]}	& MIN label with three components, \TT{A}, \TT{B},
			  and \TT{"5"} \\
			& (this last a MIN string and not a MIN number) \\
\end{tabular}
\end{center}

The following is a review of the standard MIN object attributes
mentioned above:

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttdmkey{type}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals
    \begin{center}
    \begin{tabular}{ll}
       & the {\em type-label} of a typed bracketed subexpression, \\
    or & \TT{""} for a typed bracketed subexpression with no
         {\em type-label}, \\
    or & \TT{"<Q>"} if the MIN object represents a quoted string lexeme. \\
    or & \TT{\#} if the MIN object represents a numeric lexeme. \\
    \end{tabular}
    \end{center}
\medskip
\hspace*{-0.2in}\ttdmkey{initiator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    or a MIN special value,
    that equals
    \begin{center}
    \begin{tabular}{ll}
       & the {\em opening-bracket-name} of
         an untyped bracketed subexpression, \\
    or & the {\em indentation-mark-name} of an indented paragraph, \\
    or & \TT{min::LOGICAL\_LINE()} for a logical line \\
    \end{tabular}
    \end{center}
\medskip
\hspace*{-0.2in}\ttdmkey{terminator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    or a MIN special value,
    that equals
    \begin{center}
    \begin{tabular}{ll}
       & the {\em closing-bracket-name} of
         an untyped bracketed subexpression, \\
    or & \TT{min::INDENTED\_PARAGRAPH()} for an indented paragraph \\
    or & the terminator of a logical line: \\
       & ~~~ either \TT{"<LF>"}, \\
       & ~~~ or a {\em line-separator-name} (e.g. \TT{";"}) \\
    or & the terminator of sentence (e.g. \TT{"."}) \\
    \end{tabular}
    \end{center}
\medskip
\hspace*{-0.2in}\ttdmkey{separator}{subexpression attribute}\\
    A MIN string, or a MIN label whose elements are MIN strings,
    that equals
    the operator (e.g., \TT{","}) that acts as a
    separator in a subexpression.

\end{indpar}

In addition to the attributes just given, a MIN object that is
the value of a \TT{BRACKETED} token will have
a \ttdmkey{position}{of MIN object} attribute that is a
\TT{min::\EOL phrase\_\EOL position\_\EOL vec} giving the positions
of the lexemes which the MIN object and its elements represent.
This is a hidden attribute that is not (normally) printed.

\subsubsection{Untyped Bracketed Subexpressions}
\label{UNTYPED-BRACKETED-SUBEXPRESSIONS}

The following are examples of
\ikey{untyped bracketed expressions}{bracketed expressions!untyped},
where \ldots{} denotes a list of elements:
\begin{center}
\TT{(} ~~~\ldots~~~ \TT{)} \\
\TT{(|} ~~~\ldots~~~ \TT{|)} \\
\TT{[} ~~~\ldots~~~ \TT{]} \\
\TT{[<} ~~~\ldots~~~ \TT{>]} \\
\end{center}

The general syntax is:

\begin{indpar}[0.1in]
\emkey{untyped-bracketed-subexpression} ::=
	{\em opening-bracket} ~ {\em element-list} ~ {\em closing-bracket}
\\[0.5ex]
\emkey{opening-bracket} ::=
   {\em key} ~~~ [e.g., `\TT{(}' or `\TT{[<}', ~
    as per
    {\em parser-untyped-bracket-command}
    \pagref{PARSER-UNTYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{closing-bracket} ::=
   {\em key} ~~~ [e.g., `\TT{)}' or `\TT{>]}', ~
    as per
    {\em parser-untyped-bracket-command}
    \pagref{PARSER-UNTYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{key} ::= see \pagref{KEY}
\\[0.5ex]
\emkey{element-list} ::= {\em prefix-0-list}
\label{ELEMENT-LIST}
\\[0.5ex]
\emkey{prefix-0-list}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em simple-element-list} \\
    $|$ & see \pagref{PREFIX-0-LIST}
    \end{tabular}
\\[0.5ex]
\emkey{simple-element-list} ::= {\em element}\STAR{}
\label{SIMPLE-ELEMENT-LIST}
\\[0.5ex]
\emkey{element}
    \begin{tabular}[t]{rl}
    ::= & {\em word} $|$ {\em number} $|$ {\em mark} $|$
                    {\em separator} $|$ {\em quoted-string} \\
    $|$ & {\em untyped-bracketed-subexpression} \\
    $|$ & {\em indented-paragraph-subexpression} \\
    $|$ & {\em typed-bracketed-subexpression}
          that is not a {\em typed-prefix-separator} \\
    \end{tabular}
\\[0.5ex]
\emkey{indented-paragraph-subexpression} ::=
    see \pagref{INDENTED-PARAGRAPH-SUBEXPRESSION}
\\[0.5ex]
\emkey{typed-bracketed-subexpression} ::=
    see \pagref{TYPED-BRACKETED-SUBEXPRESSION}
\\[0.5ex]
\emkey{typed-prefix-separator} ::=
    see \pagref{TYPED-PREFIX-SEPARATOR}
\\[0.5ex]
Note: \begin{minipage}[t]{5.8in}
      An {\em untyped-bracketed-subexpression} {\em element-list}
      is normally terminated by the expression's {\em closing-bracket}.
      It may be abnormally terminated by an outer
      {\em bracketed-subexpression's}
      {\em closing-bracket}, {\em typed-closing},
      or {\em non-continuation-line-break}, but \underline{not}
      by a {\em line-separator} or {\em typed-middle}.
      \end{minipage}
\end{indpar}

A \key{bracketed subexpression}\index{bracketed subexpression!untyped}
begins with
an {\em opening-bracket} and ends with a match\-ed
{\em clos\-ing-bracket} as defined by a
\TT{parser define bracket} command, an example of which is
\begin{center}
\TT{parser define bracket "("~...~")" [operator, text]} \ldots
\end{center}
which specifies `\TT{(}' to be an {\em opening-bracket}
with `\TT{)}' as its corresponding {\em closing-bracket}
and `\TT{operator}' and `\TT{text}' as the definition selectors.

The general syntax of {\em parser-untyped-bracket-commands} is:

\begin{indpar}[0.1in]
\emkey{parser-untyped-bracket-command}%
\label{PARSER-UNTYPED-BRACKET-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rll}
    ::= & \multicolumn{2}{l}{\ttmkey{define bracket}{parser command}
		    ~ {\em bracket-name} ~ {\em selectors}} \\
	& \hspace*{3em} & [ \TT{with parsing selectors}
	                    ~ {\em new-selectors} ] \\
        &               & [ \TT{with parsing options}
	                    ~ {\em bracket-options} ] \\
        &               & [ \TT{with}
			    ~ {\em reformatter-name}
			    ~ \TT{reformatter}
			    ~ {\em reformatter-arguments} ] \\
    $|$ & \multicolumn{2}{l}{\ttmkey{undefine bracket}{parser command}
		    ~ {\em bracket-name} ~ {\em selectors}} \\
    \end{tabular}
\\[0.5ex]
\emkey{bracket-name} ::= {\em opening-bracket}
			 ~ \ttmkey{...}{in {\em bracket-name}}
			 ~ {\em closing-bracket}
\label{BRACKET-NAME}
\\[0.5ex]
\emkey{opening-bracket} ::= {\em quoted-key}
\\[0.5ex]
\emkey{closing-bracket} ::= {\em quoted-key}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\\[0.5ex]
\emkey{new-selectors} ::= {\em selector-spec} ~~~ [\pagref{SELECTOR-SPEC}]
\\[0.5ex]
\emkey{bracket-options} ::= {\em end-at-option-spec}
	~ except ~ `\TT{end at line separator}'
	~~~ [see \pagref{END-AT-OPTION-SPEC}]
\\[0.5ex]
\emkey{reformatter-name}\label{REFORMATTER-NAME} ::=
    {\em simple-name} not containing `\TT{reformatter}'
\\[0.5ex]
\emkey{reformatter-arguments}\label{REFORMATTER-ARGUMENTS}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em empty} $|$ \TT{()} \\
    $|$ & \TT{(} {\em reformatter-argument}
          \{ \TT{,} {\em reformatter-argument} \}\STAR{} \TT{)} \\
    \end{tabular} \\
\emkey{reformatter-argument} ::= {\em quoted-key} $|$ {\em simple-name}

\end{indpar}

Brackets such as `\TT{(}' and `\TT{)}'
are sometimes called `\key{untyped brackets}'
to distinguish them from typed brackets
such as `\TT{\{b|}' and `\TT{|b\}}'
in which the type, in this case `\TT{b}',
is arbitrary.  See \itemref{TYPED-BRACKETED-SUBEXPRESSIONS}
for a description of typed brackets.

In the absence of a reformatter,
a bracketed subexpression is converted to a \TT{BRACKETED}
token whose \TT{value} is a
MIN object whose list elements are the components of the
subexpression except for the brackets.  The
{\em opening-bracket} becomes the \TT{.initiator}
attribute of this object, and the {\em closing-bracket}
becomes the \TT{.terminator} attribute of the object.
See below for {\em untyped-bracketed-subexpression} reformatters.

If a bracketed subexpression ends pre-maturely, before
its {\em closing-bracket} is discovered, a parsing error is
announced and the {\em closing-bracket} is inserted in the input
just after the pre-maturely ended subexpression.  Such a pre-mature end can be
discovered by finding the {\em closing-bracket} of a containing
{\em untyped-bracketed-subexpression} or {\em typed-bracketed-subexpression},
or the end of the logical line
containing the {\em untyped-bracketed-subexpression}.

When an {\em opening-bracket} is recognized, the current parser
selector set and options are saved in a stack.  Then if the
bracket definition contains {\em new-selectors},
a new selector set is computed by modifying the saved set
according to the {\em new-selectors}.
Similarly if the bracket definition contains {\em bracket-options},
these are used to compute a new set of end-at options,
and additionally the `\TT{end at line separator}' option is turned off.
The saved selector set and options are restored after the {\em closing-bracket}
is recognized.  However {\em closing-bracket}
recognition does not depend
upon the current parser selectors, but only on previous recognition
of an associated {\em opening-bracket}.

An example using {\em bracket-options} to permit
\TT{`{}`{}`\ldots'{}'{}'}
to bracket arbitrary text with arbitrary indentation is:
\begin{indpar}\begin{verbatim}
parser define bracket "```" ... "'''" [code]
       with parsing options []
( An indented paragraph:
    ```This logical line continues on no
matter what, even with a spurious ), until
  the following is encountered- '''
    Second line of indented paragraph.
    ) // End of () bracketed subexpression
\end{verbatim}\end{indpar}

The `\TT{- end at line separator}' option is always implied
by `\TT{parser define bra\-cket}', and if the options
`\TT{+ end at line separator}' or
`\TT{\textasciicircum{} end at line separa\-tor}' are given, they
are ignored and warning messages are output.

Several reformatters are provided that change the MIN value
represented by an {\em untyped-bracketed-subexpression}:

\begin{indpar}

\ttmkey{label}{reformatter} \hfill e.g.:~\ttmkey{[<~>]}{reformatting}

\begin{indpar}[0.5em]
Requires that the expression element values be MIN strings or
natural numbers or labels.
Elements derived from {\em quoted-string} or {\em numeric}
lexemes are considered to be the strings represented by the lexemes.

The subexpression is converted to a \TT{DERIVED}
token whose \TT{value} is the value of the single element
of the subexpression if the subexpression has exactly one
element, and whose value is otherwise the MIN label made from the
subexpression element values (an empty label is possible).
\end{indpar}

\ttmkey{special}{reformatter} \hfill e.g.:~\ttmkey{[\$~\$]}{reformatting}

\begin{indpar}[0.5em]
Requires that the expression consist of a single element with a string
value that names a MIN special value (e.g., `\TT{MISSING}' or
`\TT{INDENTED\_PARAGRAPH}').

The subexpression is converted to a \TT{DERIVED}
token whose \TT{value} is the special value named.
\end{indpar}

\ttmkey{multivalue}{reformatter} \TT{(} {\em separator} \TT{)}
	\hfill e.g.:~\ttmkey{\{*~*\}}{reformatting}%
	\label{MULTIVALUE-REFORMATTER}

\begin{indpar}[0.5em]
Requires that the expression element values be MIN strings,
numbers, labels, bracketed subexpressions, or equal to the
{\em separator} argument.

The subexpression is divided into components by {\em separator}
tokens and is converted to a \TT{BRACKETED}
token whose \TT{value} is a list with one element for each
non-missing component.  A component must be a single MIN object,
string, number, or label, except that a list of more than one
string, number, and label valued tokens is converted to a MIN label.
Components derived from {\em quoted-string} or {\em numeric}
lexemes are considered to be the strings represented by the lexemes.
The \TT{BRACKETED} result token gets the {\em separator} as its
\TT{.separator} attribute, and the opening and closing brackets
as its \TT{.initiator} and \TT{.terminator} attributes.

The {\em separator} argument (e.g., \TT{","}) must denote
a single MIN string, and
cannot denote a multi-component MIN label (this is purely an implementation
limitation).
\end{indpar}

\end{indpar}



The definitions\label{UNTYPED-BRACKET-BULITINS}
\begin{indpar}\begin{verbatim}
*PARSER*:
     define bracket "(" ... ")" [data]
     define bracket "[" ... "]" [data]
     define bracket "{{" ... "}}" [data]
     define bracket "`" ... "'" [data]
     define bracket "[<" ... ">]" [data]
         with label reformatter
     define bracket "{*" ... "*}" [data]
         with multivalue reformatter ( "," )
     define bracket "[$" ... "$]" [data]
         with special reformatter
\end{verbatim}\end{indpar}
are builtin.

The definitions
\begin{indpar}\begin{verbatim}
*PARSER*:
     define bracket "(" ... ")" [code, math, text, data]
     define bracket "[" ... "]" [code, math, text, data]
     define bracket "{{" ... "}}" [code, math, text]
         with parsing selectors [ + math, - code, - text]
     define bracket "`" ... "'" [code, math, text]
         with parsing selectors [ + text, - code, - math]
     define bracket "[<" ... ">]" [code, math, text, data]
         with parsing selectors [data]
         with label reformatter
     define bracket "[$" ... "$]" [code, math, text, data]
         with parsing selectors [data]
         with special reformatter
\end{verbatim}\end{indpar}
are included by the standard parser at the beginning of
its `\TT{standard}' parser block.

\subsubsection{Indented Paragraph Subexpressions}
\label{INDENTED-PARAGRAPH-SUBEXPRESSIONS}

The following is an example
\key{indented paragraph subexpression}
using `\TT{:}' as an {\em indentation-mark}:
\begin{indpar}\begin{verbatim}
the line before the outer paragraph
this is an outer paragraph:
    the first line of the outer paragraph
    the second line of the outer paragraph which
        is continued on this indented line
    an inner paragraph:
        the first line of the inner paragraph
        the second line of the inner paragraph which
            is continued on this indented line
    the first outer paragraph line after the inner paragraph
    another inner paragraph, but one with zero lines:
    the last line of the outer paragraph
the line after the outer paragraph
\end{verbatim}\end{indpar}

An \key{indented paragraph subexpression}
begins with an {\em indentation-mark} (e.g. `\TT{:}')
which must be at the end of a physical line.
This is followed by an \key{indented paragraph}
consisting of zero or more non-empty
(see \pagref{NON-EMPTY-PARAGRAPH-LINE-RULE})
logical lines called \skey{paragraph line}s.
The paragraph has a \key{paragraph indent},
which is the indent of the
first non-blank, non-comment physical line after the
line containing the indentation mark, if this indent
is greater than the current indent.
But if this indent is less than or equal
to the current indent, or if there is no non-blank, non-comment
physical line before an end of file,
the paragraph is empty, and has no paragraph lines.

At the beginning of the paragraph,
the \key{current indent} is set to the paragraph indent,
and at the end of the paragraph, the current indent is
restored to its previous value.  The top level
current indent is \TT{0}.

The general syntax is:

\begin{indpar}[0.1in]
\emkey{indented-paragraph-subexpression} ::=
	\begin{tabular}[t]{@{}l}
	{\em indentation-mark} {\em line-break} \\
	~~~~ {\em paragraph-line}\STAR{} \\
	{\em paragraph-end}
	\end{tabular}%
\label{INDENTED-PARAGRAPH-SUBEXPRESSION}
\\[0.5ex]
\emkey{paragraph-line} ::=
    \begin{tabular}[t]{l}
    {\em logical-line}, possibly ended by a {\em line-separator} \\{}
    [May be grouped into headed paragraphs: see \itemref{HEADED-PARAGRAPHS}] \\
    \end{tabular}
\\[0.5ex]
{\em logical-line} ::= see \itemref{LOGICAL-LINES}
	~~ [Includes headed lines: see \itemref{HEADED-LINES}]
\\[0.5ex]
\emkey{paragraph-end}
    \begin{tabular}[t]{rl}
    ::= & indent lexeme with indent that is less than
			  the paragraph indent \\
    $|$ & end of file
    \end{tabular}
\\[0.5ex]
\emkey{indentation-mark} ::=
   {\em key} ~~~ [e.g., `\TT{:}', ~ as per
    {\em parser-indentation-mark-command}
    \pagref{PARSER-INDENTATION-MARK-COMMAND}]
\\[0.5ex]
\emkey{line-separator} ::=
   {\em key} ~~~ [e.g., `\TT{;}', ~ as per
    {\em parser-indentation-mark-command}
    \pagref{PARSER-INDENTATION-MARK-COMMAND}]
\end{indpar}

{\em Paragraph-lines} are logical lines that end according to
the setting of the end-at options;
See~\pagref{END-AT-OPTIONS-1}.  The setting of these options can be
controlled by the specification of the {\em indentation-mark}.

{\em Paragraph-lines} may be headed lines (see \itemref{HEADED-LINES})
or may be grouped into headed paragraphs (see \itemref{HEADED-PARAGRAPHS}).

An {\em indentation-mark} is specified by a
\ttmkey{define indentation mark}{parser command}
parser command, and may have
an associated {\em line-separator} supplied by that definition.
An example is
\begin{center}
\TT{define indentation mark ":"~...~";" [code]} \ldots
\end{center}
which specifies `\TT{:}' to be an {\em indentation-mark}
with `\TT{;}' as its corresponding {\em line-separator}
and `\TT{code}' as the sole definition selector.

The general syntax of {\em parser-indentation-mark-commands} is:

\begin{indpar}[0.1in]
\emkey{parser-indentation-mark-command}%
\label{PARSER-INDENTATION-MARK-COMMAND} \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define}\ttmindex{define indentation mark}{parser command} ~
	  \begin{tabular}[t]{@{}l@{}}
	  \TT{indentation mark} ~
	  {\em indentation-name} ~ {\em parsing-selectors} \\
	  {}[ \TT{with parsing selectors} ~ {\em new-selectors} ] \\
	  {}[ \TT{with parsing options} ~ {\em end-at-options} ] \\
	  {}[ \TT{with implied header} ~ {\em header} ] \\
	  {}[ \TT{with lexical master} ~ {\em master-name} ] \\
	  \end{tabular} \\
    $|$ & \ttmkey{undefine indentation mark}{parser command} ~
	  {\em indentation-name} ~ {\em parsing-selectors} \\
    $|$ & \ttmkey{define indentation offset}{parser command} ~
	  {\em indentation-offset}  \\
    \end{tabular}
\label{INDENTATION-MARK-DEFINITION}
\\[0.5ex]
\emkey{indentation-name} ::= {\em indentation-mark}
	[ \TT{...} {\em line-separator} ]
\\[0.5ex]
\emkey{indentation-mark} ::= {\em quoted-key}
\label{INDENTATION-MARK-NAME}
\\[0.5ex]
\emkey{line-separator} ::= {\em quoted-key}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\\[0.5ex]
\emkey{new-selectors} ::= {\em selector-spec} ~~~ [\pagref{SELECTOR-SPEC}]
\\[0.5ex]
\emkey{end-at-options} ::= {\em parser-flag-spec}
	~~~~~ [see \pagref{END-AT-OPTIONS-1}]
\\[0.5ex]
\emkey{header} ::= \begin{tabular}[t]{l}
                   {\em typed-prefix-separator}
                       (\pagref{TYPED-PREFIX-SEPARATOR}) \\
		   with `\TT{paragraph}' or `\TT{line}' group
		       (\itemref{HEADED-LINES}, \itemref{HEADED-PARAGRAPHS}) \\
		   \end{tabular}
\\[0.5ex]
\emkey{master-name} ::= {\em quoted-key}
                    $|$ {\em simple-name} not containing `\TT{with}'
\\[0.5ex]
\emkey{indentation-offset} ::= unsigned integer
\end{indpar}

The {\em line-separator} may be used to end
paragraph lines, as long as the \TT{end at line sepa\-ra\-tor}
(\pagref{END-AT-LINE-SEPARATOR}) option permits.
Line separators are only recognized outside explicitly
bracketed subexpressions (untyped bracketed or typed bracketed)
in the paragraph.

\ikey{Empty logical lines}{empty logical line} with no ending
{\em line-separator} are always ignored as if they did not exist%
\label{NON-EMPTY-PARAGRAPH-LINE-RULE}.
This rule allows physical lines such as
\begin{center}
\tt This logical line is followed by an empty logical line;
\end{center}
to represent a single paragraph line, instead of two paragraph lines
the second of which is empty.  All paragraph lines
are non-empty.

A paragraph line may be a headed line (that has a line header:
see \itemref{HEADED-LINES})
or be part of a headed paragraph (see: \itemref{HEADED-PARAGRAPHS}).
Any other paragraph line is converted to a MIN object that becomes an
element of the indented paragraph.  The elements of this object are
the components of the line, treated as subexpression components, except for
any {\em line-separator} that ends the line.  The
object is given a \TT{.initiator} attribute value
equal to \TT{min::\EOL LOGICAL\_\EOL LINE()}.
If it ends with a {\em line-separator},
it is given a \TT{.terminator} attribute equal to the
{\em line-separator}, and otherwise it is given a
\TT{.terminator} attribute equal to \TT{"<LF>"}.

Headed lines are converted to a MIN object with attributes
(including \TT{.type}) taken from their line header and
elements taken from the rest of the logical line.  If the
headed line is terminated by a line separator, that line
separator becomes the \TT{.terminator} attribute of the MIN object.
See \itemref{HEADED-LINES} for details.

A headed paragraph is converted to a single MIN object
that becomes an element in the indented paragraph.
This MIN object has attributes (including \TT{.type})
taken from its paragraph header and
elements that are the logical lines belonging to the headed paragraph
(these may include headed lines).
See \itemref{HEADED-LINES} for details.

The indented paragraph as a whole is converted to a MIN object whose elements
are the MIN objects produced by {\em paragraph-lines} outside headed
paragraphs and headed paragraphs.
The \TT{.initiator} attribute of this paragraph MIN object
is the {\em indentation-mark} that introduced the paragraph,
and the \TT{.terminator} attribute is \TT{min::INDENTED\_PARAGRAPH()}.
A paragraph may be empty (have no paragraph lines or object elements).

The \TT{implied paragraph header} and \TT{lexical master} parameters
can be used to initialize line variables
that affect the parsing of indented paragraphs: see \itemref{LINE-VARIABLES}.
They have no effect if they are not explicitly included in the indentation
mark definition command.

If while parsing an indented paragraph a line is encountered whose
indent is different from the current indent,
but the difference is less than $N$ columns (default $N=2$),
a parse warning message is announced.
No corrective action is taken; the line is accepted as either ending
the paragraph if its indent is less than the current
indent, or continuing the current paragraph line if its indent
is greater than the current indent.  Here $N$ is called the
\key{parser indentation offset}, and is a parser parameter that can be
changed with the \TT{parser define indentation offset} command.
If changed in a parser block, the original value is reinstated at the
end of the block.

When an {\em indentation-mark} is recognized, the current parsing
selector set, parsing options, and line separator are saved in a stack.
Then a new selector set and new options are computed by modifying
the saved selector set
according to the {\em new-selectors} and modifying the saved options according
to the {\em end-at-options} in the indentation mark definition,
and a new line separator is set according to that definition.
A new set of line variables is computed for use in parsing the
indented paragraph, as per \itemref{LINE-VARIABLES}.
The saved selector set, options, and line separator
are restored after the end of paragraph is recognized.
The \TT{TOP LEVEL} selector is always turned off when parsing indented
paragraph lines.
Note that if no {\em new-selectors} are given, selectors
other than \TT{TOP LEVEL}
are not modified, if no {\em end-at-options} 
are given, options are not modified, and if no
{\em line-separator} is given, no line separator can end
an indented paragraph logical line.

\ikey{Top level parsing}{top level parsing}
of a file recognizes paragraph lines as if the whole
file were an indented paragraph, and forms each line or headed
paragraph into a MIN object.
However,
these are \underline{not} combined into a paragraph MIN object, but
are instead processed as they are produced.  In particular, if they
are parser commands, they are processed by the parser to make
modifications in the parser tables.  Also, the initial
\key{top level current indent}\index{current indent!top level}
is set to \TT{0}, and an error is announced if the first non-comment,
non-line-break, non-end-of-file
lexeme in the file has non-zero indent.  The top level line
variables (\itemref{LINE-VARIABLES}) are all set to missing.

Comments are ignored when determining line indentation, but may
cause errors to be announced.  A comment is considered to be in error
if it appears on a line by itself and is less indented than the first
following non-comment non-blank line.
Comments at the beginning or end of a file cannot be
in error.

The definitions
\begin{indpar}\begin{verbatim}
*PARSER*:
    define indentation mark "TOP LEVEL" ... ";" []
        // Indentation mark definition governing top level
        // parsing; may NOT be redefined.
    define indentation mark "*PARSER*" ... ";" [TOP LEVEL]
        with parsing selectors [data]
    define indentation mark "*PARSER* *TEST*" ... ";"
        [TOP LEVEL]
\end{verbatim}\end{indpar}
are builtin.

The definition
\begin{indpar}\begin{verbatim}
*PARSER*:
     define indentation mark ":" ... ";" [code]
         with parsing options [default options]
\end{verbatim}\end{indpar}
is included by the standard parser at the beginning of
its `\TT{standard}' parser block.

\subsubsection{Typed Bracketed Subexpressions}
\label{TYPED-BRACKETED-SUBEXPRESSIONS}

The following are examples of
\skey{typed bracketed subexpression}s\index{bracketed subexpression!typed},
where \ldots{} denotes a list of elements:
\begin{center}
\TT{\{my type|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{|} ~~~\ldots~~~ \TT{|my type\}} \\
\TT{\{my type|} ~~~\ldots~~~ \TT{|my type\}} \\
\TT{\{my type||\}} \\
\TT{\{||my type\}} \\
\TT{\{my type: my attribute = 5, my option = TRUE|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{my type: my attribute = 5, your option = FALSE|} ~~~\ldots~~~
    \TT{|my type\}} \\
\TT{\{my attribute = 5|} ~~~\ldots~~~
    \TT{|my option = TRUE: my type\}} \\
\TT{\{my type|} ~~~\ldots~~~
    \TT{|my attribute = 5, my option\}} \\
\TT{\{my type|} ~~~\ldots~~~
    \TT{|my attribute = 5, my option: my type\}} \\
\TT{\{|} ~~~\ldots~~~ \TT{|my attribute = 5, my option: my type\}} \\
\TT{\{|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{||\}} \\
\TT{\{\}} \\
\TT{\{my attribute = 5, no your option|} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{"": my attribute = 5, no your option|} ~~~\ldots~~~ \TT{|""\}} \\
\TT{\{+} ~~~\ldots~~~ \TT{+\}} \\
\end{center}

The basic form is
\begin{center}
\TT{\{my type: my attribute = 5, my option = TRUE|} ~~~\ldots~~~
    \TT{|my type\}} \\
\end{center}
from which various parts can be omitted or moved.  Some or all of the
attributes can be moved to the end.
The attribute value `\TT{= TRUE}' can be omitted (as in
`\TT{my option}'), and the attribute value `\TT{= FALSE}' can be represented
by omitting it and prefacing the attribute label with `\TT{no}'
(as in `\TT{no your option}').
The type can be omitted from the beginning unless it is followed by
a single attribute with omitted \TT{TRUE} value, as such an attribute
will be mistaken for the type (i.e., in \TT{\{X|\ldots|\}}, \TT{X} is
a type label and \underline{not} an attribute label).
The type can be omitted from the end unless it is preceded
by a single attribute with omitted \TT{TRUE} value, as such an attribute
will be mistaken for the type.
(i.e., in \TT{\{|\ldots|X\}}, \TT{X} is
a type label and \underline{not} an attribute label).
If omitted from both
beginning and end, the type is missing, but there can still be
attributes.  Also \TT{""} may be used as a type label to denote
a missing type.

For example, the following are equivalent:
\begin{center}
\TT{\{my option|a b c|no your option\}} \\
\TT{\{no your option|a b c|my option\}} \\
\TT{\{my option:~your option = FALSE |a b c|\}}
\end{center}

where `\TT{my option}' is the \TT{.type}, and \underline{not}
an attribute,
while the following is in error because it has a different \TT{.type} name
at the end than it does at the beginning:
\begin{center}
\TT{\{my option|a b c|your option\}} \\
\end{center}

A type, attribute label, or attribute value may be a label,
which is a sequence
of one or more words, natural-numbers, numerics, and quoted strings, each
representing a MIN string.  Note that marks and separators must be quoted.
If there is only
one element in the sequence, the MIN string it represents is the
label, but if there is more than one element, the elements
are concatenated into a MIN label.

Attribute values may alternatively be bracketed subexpressions.
In this case, the attribute value is the bracketed subexpression,
with one exception.

The exception is that when the brackets are `\TT{\{*~*\}}',
the comma
separated elements of the bracketed subexpression are each a
distinct value of the attribute, which has a multi-set of values.
Elements must be single bracketed subexpressions,
words, natural-numbers, numerics, and quoted strings that are made into
MIN strings, or sequences of words, natural-numbers, numerics, and
quoted strings that are made into
labels.  Missing elements, as indicated by the commas, are ignored,
If there are no values, as in `\TT{\{* *\}}' or `\TT{\{* , *\}}',
the attribute is not set.

Some examples of attribute values are:
\begin{center}
\TT{\{my type: x = 5, y = "5" |} ~~~\ldots~~~ \TT{|\}} \\
\TT{\{my type: x = 5 tomatoes, y = [< 5 tomatoes >] |}
    ~~~\ldots~~~ \TT{|\}} \\
\TT{\{my type: x = \{* A, B *\}, y = \{* , "A",{}, B, *\} |}
    ~~~\ldots~~~ \TT{|\}} \\
\TT{\{my type: y = \{* ,{}, *\} |} ~~~\ldots~~~ \TT{|\}} \\
\end{center}
In each case, the values of \TT{x} and \TT{y} are equal.

If there are no elements, `\TT{|~|}' can be collapsed into
a single lexeme `\TT{||}'.
`\TT{\{||\}}' can be collapsed into `\TT{\{\}}'.

If the type is
a single {\em mark} lexeme and there are no attributes,
the `\TT{|}'s surrounding
the elements may be omitted, in which case the {\em mark} is not
quoted.
Similarly if the type is a label consisting of two \underline{distinct}
{\em mark}
lexemes, and there are no attributes, the `\TT{|}'s may be
omitted with the two unquoted {\em marks} being placed before and
after the elements, respectively.
Except in these cases, type and attribute labels
cannot contain separators or marks unless these are quoted.

The following are equivalent pairs of examples with {\em mark} types:
\begin{center}
\begin{tabular}{l@{~~~~~}l}
\TT{\{+ 1 2 3 +\}} & \TT{\{"+"| 1 2 3 |"+"\}} \\
\TT{\{< 1 2 3 >\}} & \TT{\{"<" ">"| 1 2 3 |"<" ">"\}} \\
\end{tabular}
\end{center}

An attribute can have flags which are specified
in square brackets following the attribute label.
Normally there is only one lexeme in the square brackets
and it contains some combination of the 64 flag characters:
\begin{center}
\begin{tabular}{l}
\TT{*+-/@\&\#=\$\%<>} \\
\TT{abcdefghijklmnopqrstuvwxyz} \\
\TT{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \\
\end{tabular}
\end{center}
More flags can be represented by natural number flag indices
(e.g., \TT{64}) which are separated from each other
and from any flag character by comma separators.
Multiple non-number flag lexemes, separated by comma separators,
can also be used.  Some examples are:
\begin{center}
\begin{tabular}{l}
\TT{\{my attribute [H] = (3,4)|A B C|\}} \\
\TT{\{my attribute [H, 64] = (3,4)|A B C|\}} \\
\TT{\{my attribute [64] = (3,4)|A B C|\}} \\
\TT{\{my attribute [64, HJ, 256] = (3,4)|A B C|\}} \\
\TT{\{my attribute [64, H, J, 256] = (3,4)|A B C|\}} \\
\end{tabular}
\end{center}

The 64 flag characters listed above are associated with flag
indices \TT{0} through \TT{63} in order: `\TT{*}' is associated
with index \TT{0} and `\TT{Z}' with index \TT{63}.
Thus `\TT{[+Y]}', `\TT{[1,~Y]}', `\TT{[+,~62]}', and `\TT{[62,~1]}'
are equivalent as attribute flag specifiers.


The general syntax is:

\begin{indpar}[0.1in]
\emkey{typed-bracketed-subexpression} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
	::= & {\em typed-opening}~~~%
	      {\em opening-type-and-attributes}\QMARK{} \\
	    & {\em typed-elements} \\
	    & {\em closing-type-and-attributes}\QMARK{}~~~%
	      {\em typed-closing} \\
	$|$ & \TT{\{}~~~{\em type-mark}~~~{\em element-list}~~~%
	                {\em type-mark}~~~\TT{\}} \\
	$|$ & \TT{\{\}}
	\end{tabular}%
\label{TYPED-BRACKETED-SUBEXPRESSION}
\\[0.5ex]
\emkey{typed-elements}
	\begin{tabular}[t]{@{}rl}
	::= & {\em typed-middle}~~~{\em element-list}~~~%
	      {\em typed-middle} \\
	$|$ & {\em doubled-typed-middle}
	\end{tabular}
\\[0.5ex]
\emkey{element-list} ::= see \pagref{ELEMENT-LIST}
\\[0.5ex]
\emkey{opening-type-and-attributes}
	\begin{tabular}[t]{@{}rl}
	::= & {\em type-label} \\
        $|$ & {\em attribute-list} but not {\em attribute-label} \\
	$|$ & {\em type-label}~~~{\em typed-attribute-begin}~~~%
		                 {\em attribute-list}
	\end{tabular}
\\[0.5ex]
\emkey{closing-type-and-attributes}
	\begin{tabular}[t]{@{}rl}
	::= & {\em type-label} \\
        $|$ & {\em attribute-list} but not {\em attribute-label} \\
	$|$ & {\em attribute-list}~~~{\em typed-attribute-begin}~~~%
		                 {\em type-label}
	\end{tabular}
\\[0.5ex]
\emkey{attribute-list}\label{ATTRIBUTE-LIST} ::= {\em attribute}~~~%
	\{ {\em typed-attribute-separator}~~~{\em attribute} \}\STAR{}
\\[0.5ex]
\emkey{attribute} \begin{tabular}[t]{@{}rl}
                  ::= & {\em attribute-label}~~~%
	                {\em typed-attribute-equal}~~~%
			{\em single-attribute-value} \\
                  $|$ & {\em attribute-label}~~~%
		        \begin{tabular}[t]{@{}l}
	                {\em typed-attribute-equal}~~~%
			{\em double-attribute-value} \\
	                {\em typed-attribute-equal}~~~%
			{\em attribute-label} \\
			\end{tabular} \\
                  $|$ & {\em attribute-label} \\
                  $|$ & {\em typed-attribute-negator}~~~%
		        {\em attribute-label} \\
		  \end{tabular}
\\[0.5ex]
\emkey{label} ::= {\em label-component}\PLUS{}
\\[0.5ex]
\emkey{label-component} ::=
    \begin{tabular}[t]{@{}l}
    {\em word} $|$ {\em natural-number}
               $|$ {\em numeric} $|$ {\em quoted-string} \\
    but \underline{not} {\em mark} or {\em separator} \\
    \end{tabular}
\\[0.5ex]
\emkey{type-label} ::= {\em label}\label{TYPE-LABEL}
\\[0.5ex]
\emkey{type-mark} ::= {\em mark}\label{TYPE-MARK}
\\[0.5ex]
\emkey{attribute-label} ::= {\em label} {\em attribute-flags}\QMARK{}
\\[0.5ex]
\emkey{attribute-flags}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em typed-attribute-flags-opening}~~~{\em attribute-flag-item} \\
        & \{ {\em typed-attribute-flags-separator}~~~%
	  {\em attribute-flag-item} \}\STAR{} \\
	& {\em typed-attribute-flags-closing} \\
    \end{tabular}
\\[0.5ex]
\emkey{attribute-flag-item}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} or {\em mark} containing only letters
			    and/or \TT{*+-/@\&\#=\$\%<>} \\
    $|$ & {\em attribute-flag-index} \\
    \end{tabular}
\\[0.5ex]
\emkey{attribute-flag-index} ::= {\em natural-number}
\\[0.5ex]
\emkey{single-attribute-value}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em value} \\
    $|$ & {\em attribute-multivalue-opening} {\em value}\QMARK{} \\
        & \{ {\em attribute-multivalue-separator} {\em value}\QMARK{}
	                                       \}\STAR{} \\
	& {\em attribute-multivalue-closing} \\
    \end{tabular}
\\[0.5ex]
\emkey{double-attribute-value}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em object-id} \\
    $|$ & {\em attribute-multivalue-opening} {\em object-id}\QMARK{} \\
        & \{ {\em attribute-multivalue-separator} {\em object-id}\QMARK{}
	                                       \}\STAR{} \\
	& {\em attribute-multivalue-closing} \\
    \end{tabular}
\\[0.5ex]
\emkey{value} ::= {\em label} $|$ {\em bracketed-subexpression}
\\[0.5ex]
\emkey{object-id} ::= \begin{tabular}[t]{l}
                      \ttmkey{@}{in object ID} {\em natural-number} \\
		      This is a special kind of label.
		      \end{tabular}
\\[0.5ex]
\emkey{typed-opening} ::= {\em key} ~~~ [e.g. `\TT{\{}' ~
    as per {\em parser-typed-bracket-command} ~
    \pagref{PARSER-TYPED-BRACKET-COMMAND}]%
    \label{TYPED-OPENING}
\\[0.5ex]
\emkey{typed-middle} ::= {\em key} ~~~ [e.g. `\TT{|}' ~
    as per {\em parser-typed-bracket-command} ~
    \pagref{PARSER-TYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{typed-closing} ::= {\em key} ~~~ [e.g. `\TT{\}}' ~
    as per {\em parser-typed-bracket-command} ~
    \pagref{PARSER-TYPED-BRACKET-COMMAND}]%
    \label{TYPED-CLOSING}
\\[0.5ex]
\emkey{typed-attribute-begin} ::= {\em key} ~~~ [e.g. `\TT{:}' ~
    as per {\em parser-typed-bracket-command} ~
    \pagref{PARSER-TYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{typed-attribute-separator} ::= {\em key} ~~~ [e.g. `\TT{,}' ~
    as per {\em parser-typed-bracket-command} ~
    \pagref{PARSER-TYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{typed-attribute-equal} ::= {\em key} ~~~ [e.g. `\TT{=}' ~
    as per {\em parser-typed-bracket-command} ~
    \pagref{PARSER-TYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{typed-attribute-negator} ::= {\em key} ~~~ [e.g. `\TT{no}' ~
    as per {\em parser-typed-bracket-command} ~
    \pagref{PARSER-TYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{typed-attribute-flags-opening} ::= {\em key} ~~~ [e.g. `\TT{[}' ~
    as per {\em parser-typed-bracket-command} ~
    \pagref{PARSER-TYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{typed-attribute-flags-separator} :::= \TT{,} ~~~ [cannot be changed]
\\[0.5ex]
\emkey{typed-attribute-flags-closing} ::= {\em key} ~~~ [e.g. `\TT{]}'
    as per {\em parser-untyped-bracket-command} ~
    \pagref{PARSER-UNTYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{attribute-multivalue-opening} ::= {\em key} ~~~ [e.g. `\TT{\{*}' ~
    as per {\em parser-typed-bracket-command} ~
    \pagref{PARSER-TYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{attribute-multivalue-separator} ::= {\em key} ~~~ [e.g. `\TT{,}' ~
    as per \TT{multivalue} reformatter ~
    \pagref{MULTIVALUE-REFORMATTER}]
\\[0.5ex]
\emkey{attribute-multivalue-closing} ::= {\em key} ~ [e.g. `\TT{*\}}' ~
    as per {\em parser-untyped-bracket-command} ~
    \pagref{PARSER-UNTYPED-BRACKET-COMMAND}]
\\[0.5ex]
\emkey{doubled-typed-middle} :::=
    \begin{tabular}[t]{@{}l}
    {\em typed-middle}~~~{\em typed-middle} ~~~~~ [e.g. `\TT{||}'] \\
    as a single lexeme (when possible): see text
    \end{tabular}
\end{indpar}

A typed bracketed expression is converted to a
MIN object whose list elements are the components of the
subexpression between {\em typed-middles}.  The
{\em type-label} or {\em type-mark}(s) become(s) the \TT{.type}
attribute of this object.  Any {\em attributes} given in the
typed bracketed expression become attributes of the object.
An attribute with just a {\em typed-attribute-label} and neither
a {\em typed-attribute-value} or {\em typed-attribute-negator} prefix
gets the implied value \TT{TRUE}.
An attribute with a {\em typed-attribute-negator}
and {\em typed-attribute-label} but no {\em typed-attribute-value}
gets the implied value \TT{FALSE}.
If an {\em attribute-label} is followed by {\em attribute-flags},
the attribute is given the indicated flags.

Note that the MIN object is \underline{not} given \TT{.initiator}
or \TT{.terminator} attributes, unless they are given as explicit
attributes as in:
\begin{center}
\TT{\{ .initiator = "(", .terminator = ")" | 1 2 3 4 |\}}
\end{center}

During the scanning of typed subexpression {\em attribute-lists}
parsing selectors are standardly set to just `\TT{data}',
while during the scanning of typed subexpression
{\em element-lists} parsing selectors are standardly
those of the subexpression context.
During both scans options are standardly set to those of the
context less the `\TT{end at line separator}' option.

If two {\em typed-middles} with no intervening space
are lexically scanned as a single lexeme, then this new
{\em doubled-typed-middle} lexeme can be used
to represent an empty list in place of
two {\em typed-middle} lexemes with an intervening space.
Note that in this case the {\em typed-middles} must be single
lexemes.

If a typed bracketed subexpression ends pre-maturely,
a parsing error is
announced and missing but required {\em typed-middle}'s and {\em typed-closings}
are inserted in the input
just after the pre-maturely ended subexpression.  Such a pre-mature end can be
discovered by finding the {\em closing-bracket} of a containing
untyped bracketed subexpression, the {\em typed-closing}
of a containing typed bracketed subexpression with a different
{\em typed-closing}, the end of the logical line
containing the typed bracketed subexpression,
or an end of file.  However, the end must be enabled by the
parsing options (e.g., a {\em closing-bracket} cannot pre-maturely
end a subexpression if `\TT{end at outer closing}' is not a parsing
option).

When a {\em typed-opening} is recognized, the current parsing
selector set and options are saved in a stack and
a new selector set and new options are computed by modifying the saved set
and options
according to the {\em typed-element-selectors} and {\em bracket-options}
associated with the {\em typed-opening}
(see the \TT{parser define typed bracket}
command below).  The modified selector set and options become the current
parsing selector set and options while scanning the {\em element-list}.
But while scanning the type label and attributes, the
current parsing selector set is set to the {\em typed-attribute-selectors}
associated with the {\em typed-opening} (also see below), while the
{\em end-at-options} remain the same as those use to scan the
{\em element-list}.
The saved selector set and options are restored after the subexpression ending
{\em typed-closing} is recognized.

A {\em typed-opening} is specified by a
\ttmkey{define typed bracket}{parser command}
parser command.  An example is:

\begin{center}
\begin{tabular}{l}
\TT{parser define typed bracket "\{"~...~"|"~...~"|"~...~"\}"} \\
\TT{~~~~[text]~} \\
\TT{~~~~with element selectors [- data]} \\
\TT{~~~~with parsing options [- end at outer closing]} \\
\TT{~~~~with attribute selectors [data]} \\
\TT{~~~~with attributes ":"~...~"="~...~","} \\
\TT{~~~~with attribute negator "no"} \\
\TT{~~~~with attribute flags initiator "["} \\
\TT{~~~~with attribute multivalue initiator "\{*"} \\
\TT{~~~~with prefix separators allowed} \\
\end{tabular}
\end{center}
which specifies
\begin{center}
\begin{tabular}{l}
`\TT{\{}' to be a {\em typed-opening} \\
`\TT{|}' to be a {\em typed-middle} \\
`\TT{\}}' to be a {\em typed-closing} \\
`\TT{text}' to be the sole definition selector \\
`\TT{[- data]}' to be the {\em typed-element-selectors} \\
`\TT{[- end at outer closing]}' to be the {\em bracket-options} \\
~~~~~ (This does not actually have to be given explicitly as it is implied.) \\
`\TT{[data]}' to be the {\em typed-attribute-selectors} \\
`\TT{:}' to be the {\em typed-attribute-begin} \\
`\TT{=}' to be the {\em typed-attribute-equal} \\
`\TT{,}' to be the {\em typed-attribute-separator} \\
`\TT{no}' to be the {\em typed-attribute-negator} \\
`\TT{[}' to be the {\em typed-attribute-flags-opening} \\
`\TT{\{*}' to be the {\em typed-attribute-multivalue-opening} \\
that {\em typed-bracketed-subexpressions} with the give {\em typed-opening}
and no elements \\
are to be treated as {\em typed-prefix-separators}
(see \itemref{TYPED-PREFIX-SEPARATORS}).
\end{tabular}
\end{center}

Note that the {\em typed-middle} must be repeated twice and both copies must
be identical.  Also, if {\em typed-middle} denotes
a single string lexeme which when concatenated
with itself forms another single string lexeme (as `\TT{|}' concatenated
with itself forms `\TT{||}'), this second doubled lexeme can be used
in place of two consecutive {\em typed-middles} (as in `\TT{\{||\}}'
being used in place of `\TT{\{|~|\}}').

The general syntax of {\em parser-typed-bracket-commands} is:

\begin{indpar}
\emkey{parser-typed-bracket-command}%
\label{PARSER-TYPED-BRACKET-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define}%
          \ttmindex{define typed bracket}{parser command}
	  \begin{tabular}[t]{@{}l@{}}
	  \TT{typed bracket} ~ {\em typed-bracket-name}
	                     ~ {\em parsing-selectors} \\
	  {}[ \TT{with element selectors} ~
	      {\em typed-element-selectors} ] \\
	  {}[ \TT{with attribute selectors} ~
	      {\em typed-attribute-selectors} ] \\
	  {}[ \TT{with parsing options} ~
	      {\em bracket-options} ] \\
	  {}[ \TT{with prefix separators allowed} ] \\
	  {}[ \TT{with attributes} ~ {\em typed-attribute-punctuation} ] \\
	  {}[ \TT{with attribute negator} ~ {\em typed-attribute-negator} ] \\
	  {}[ \TT{with} \begin{tabular}[t]{l}
	                \TT{attribute flags initiator} \\
	                {\em typed-attribute-flags-opening} ]
			\end{tabular} \\
	  {}[ \TT{with} \begin{tabular}[t]{l}
	                \TT{attribute multivalue initiator} \\
	                {\em typed-attribute-multivalue-opening} ]
			\end{tabular} \\
	  \end{tabular} \\
    $|$ & \ttmkey{undefine typed bracket}{parser command} ~
	  \begin{tabular}[t]{@{}l@{}}
	  {\em typed-bracket-name} \\
	  {\em parsing-selectors} \\
	  \end{tabular} \\
    \end{tabular}
\\[0.5ex]
\emkey{typed-bracket-name}  \\
\hspace*{0.2in}\begin{tabular}[t]{rl}
    ::= & {\em typed-opening} \TT{...}
          \TT{...} {\em typed-middle} \TT{...} {\em typed-middle}
          \TT{...} {\em typed-closing} \\
    $|$ & {\em typed-opening} \TT{...} {\em typed-closing} \\
    \end{tabular}
\\[0.5ex]
\emkey{typed-opening} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-middle} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-closing} ::= {\em quoted-key}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\\[0.5ex]
\emkey{typed-element-selectors} ::= {\em selector-spec}
	~ [see \pagref{SELECTOR-SPEC}]
\\[0.5ex]
\emkey{bracket-options} ::=
	{\em end-at-option-spec} ~ except ~ `\TT{end at line separator}' ~
	[see \pagref{END-AT-OPTION-SPEC}]
\\[0.5ex]
\emkey{typed-attribute-selectors} ::= {\em selector-flags}
	~ [see \pagref{SELECTOR-FLAGS}]
\\[0.5ex]
\emkey{typed-attribute-punctuation} ::= \\
    \hspace*{0.2in}
     {\em typed-attribute-begin}
     \TT{...} {\em typed-attribute-equal}
     \TT{...} {\em typed-attribute-separator}
\\[0.5ex]
\emkey{typed-attribute-begin} ::= {\em quoted-key}\label{TYPED-ATTRIBUTE-BEGIN}
\\[0.5ex]
\emkey{typed-attribute-equal} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-attribute-separator} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-attribute-negator} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-attribute-flags-opening} ::= {\em quoted-key}
\\[0.5ex]
\emkey{typed-attribute-multivalue-opening} ::= {\em quoted-key}

\label{TYPED-BRACKET-DEFINITIONS}
\end{indpar}

Here the `\TT{with prefix separators allowed}' option permits the use of
the typed brackets for {\em typed-prefix-separators} described in
Section \itemref{TYPED-PREFIX-SEPARATORS}.

The definition
\begin{indpar}\begin{verbatim}
*PARSER*:
    define typed bracket "{" ... "|" ... "|" ... "}" [data]
        // `||' abbreviates `| |'
        // there are NO ELEMENT SELECTORS
        with attribute selectors [data]
        with attributes ":" ... "=" ... ","
        with attribute negator "no"
        with attribute flags initiator "["
        with attribute multivalue initiator "{*"
        // WITHOUT prefix separators allowed
\end{verbatim}\end{indpar}

is builtin.  The definition

\begin{indpar}\begin{verbatim}
*PARSER*:
    define typed bracket "{" ... "|" ... "|" ... "}"
                         [code, math, text]
        // `||' abbreviates `| |'
        // there are NO ELEMENT SELECTORS
        with attribute selectors [data]
        with attributes ":" ... "=" ... ","
        with attribute negator "no"
        with attribute flags initiator "["
        with attribute multivalue initiator "{*"
        with prefix separators allowed
\end{verbatim}\end{indpar}

is included by the standard parser at the beginning of
its `\TT{standard}' parser block.  Since there are no
{\em typed-element-selectors} in either typed bracket definition,
the parsing selectors
for the {\em element-list} of a {\em typed-bracketed-subexpression}
recognized by this definition are the same as the parsing selectors
just outside the typed bracketed subexpression.
The untyped bracket definitions for `\TT{[\ldots]}' and
`\TT{\{*\ldots*\}}' given on \pagref{UNTYPED-BRACKET-BULITINS},
all with the `\TT{data}' selector, are used to parse
attribute flags and multivalue lists.

The current implementation supports two syntactic extensions of
the above.  First, more than 2 \TT{|}'s may be used to switch
back and forth between attribute scanning and element scanning,
so that:
\begin{center}
\TT{\{T: a = 1, b = 2, c = 3, d = 4 | X Y Z | \}} \\
\TT{\{T: a = 1, b = 2, c = 3 | X Y Z | d = 4 \}} \\
\TT{\{T: a = 1, b = 2 | X Y | c = 3 | Z | d = 4 \}} \\
\TT{\{T: a = 1, b = 2 | X Y | c = 3, d = 4 | Z | \}} \\
\TT{\{T| X | a = 1, b = 2 | Y | c = 3, d = 4 | Z | \}} \\
\end{center}
are all equivalent.  Second, in {\em attribute-flags}, commas
do not have to be followed by whitespace, so that:
\begin{center}
\TT{\{T: a[PQ@*+,85,203] | X Y Z | \}} \\
\TT{\{T: a[PQ@*+, 85, 203] | X Y Z | \}} \\
\TT{\{T: a[203,P,Q,@,85,*,+] | X Y Z | \}} \\
\TT{\{T: a[203,P, Q,@,85, *,+] | X Y Z | \}} \\
\end{center}
are all equivalent.

These two syntactic extensions may become permanent or be
redacted in the future.

\subsubsection{Typed Prefix Separators}
\label{TYPED-PREFIX-SEPARATORS}

A \key{typed prefix separator}
has the same syntax as an {\em typed-bracketed-subexpression}
but without the {\em element-list}, meaning there are no
{\em typed-middles} (e.g., `\TT{|}'s) or {\em elements}.
Some examples are:
\begin{center}
\TT{\{my type\}} \\
\TT{\{my type: my attribute = 5, my option = TRUE\}} \\
\TT{\{my type: my attribute = 5, your option = FALSE\}} \\
\TT{\{my type: my attribute = 5, my option\}} \\
\TT{\{my type: my attribute = 5, not your option\}} \\
\TT{\{+\}} \\
\end{center}

The general syntax of a typed prefix separator is:

\begin{indpar}[0.1in]
\emkey{typed-prefix-separator}\label{TYPED-PREFIX-SEPARATOR}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em typed-opening}~~~{\em type-label}~~~%
          {\em opening-attributes}\QMARK{}~~~{\em typed-closing} \\
    $|$ & {\em typed-opening}~~~{\em type-mark}~~~{\em typed-closing} \\
    \end{tabular}
\\[0.5em]
\emkey{typed-opening} ::= see \pagref{TYPED-OPENING}
\\[0.5em]
\emkey{typed-closing} ::= see \pagref{TYPED-CLOSING}
\\[0.5em]
\emkey{opening-attributes}
    ::= {\em typed-attribute-begin}~~~{\em attribute-list}
\\[0.5em]
\emkey{typed-attribute-begin} ::= see \pagref{TYPED-ATTRIBUTE-BEGIN}
\\[0.5em]
\emkey{attribute-list} ::= see \pagref{ATTRIBUTE-LIST}
\\[0.5em]
\emkey{type-label} ::= see \pagref{TYPE-LABEL}
\\[0.5em]
\emkey{type-mark} ::= see \pagref{TYPE-MARK}
\end{indpar}

The ~ `\TT{with prefix separators allowed}' ~ option to a
{\em parser-typed-bracket-command} (see \pagref{PARSER-TYPED-BRACKET-COMMAND})
enables use of
punctuation defined by the command
to construct {\em typed-prefix-separators}.

A {\em typed-prefix-separator} is converted to a MIN object which has the
same structure as a typed bracketed subexpression with an empty list.

{\em Typed-prefix-separators} are used to form {\em prefix-N-lists}.%
\label{PREFIX-0-LIST}
The following is an example in which {\em line-breaks} are ignored:


\begin{tabular}{lll}
Text	& Separator &  Syntactic Category
\\\hline
\tt \{p\} \{s\} This is a sentence.	& \tt \{p\} & \em prefix-0-list \\
\tt ~~~ \{s\} And another. \\
\tt \{p\} \{s\} And a new \{foo\} paragraph.
\\\hline
\tt \{s\} This is a sentence.	& \tt \{s\} & \em prefix-1-list
\\\hline
\tt This is a sentence.	& (none) & \em prefix-2-list
\\\hline
\tt \{s\} And another.  	& \tt \{s\} & \em prefix-1-list
\\\hline
\tt And another. & (none) & \em prefix-2-list
\\\hline
\tt \{s\} And a new \{foo\} paragraph. & \tt \{s\} & \em prefix-1-list
\\\hline
\tt And a new \{foo\} paragraph. & (none) & \em prefix-2-list \\
			       &        & \TT{\{foo\}} is in error \\
			       &        & and is ignored (deleted).
\end{tabular}

The {\em prefix-0-list} in this example is equivalent to:
\begin{indpar}\begin{verbatim}
{|  {p|  {s| This is a sentence "." |}
         {s| And another "." |} |}
    {p|  {s| And a new paragraph "." |} |} |}
             // `{foo}' deleted
\end{verbatim}\end{indpar}

The general syntax of a prefix-n list is:

\begin{indpar}[0.1in]
\emkey{prefix-n-list}\label{PREFIX-N-LIST}
    \begin{tabular}[t]{@{}rl}
    ::= & \{ {\em prefix-n} {\em prefix-(n+1)-list} \}\PLUS{} \\
    $|$ & {\em simple-element-list} \\
    \end{tabular}
\\[0.5ex]
\emkey{prefix-n} ::= {\em typed-prefix-separator}
\\[0.5ex]
\emkey{simple-element-list} ::= see \pagref{SIMPLE-ELEMENT-LIST}
\\[0.5ex]
Note: \begin{minipage}[t]{5.8in}
      All the {\em prefix-n}'s in a given {\em prefix-n-list} must
      have the same group.  The group of a {\em prefix-n} is its
      \TT{.type} attribute unless it has a prefix definition with
      a non-missing \TT{group} member: see \pagref{PREFIX-GROUP}.
      \end{minipage}
\end{indpar}

The elements of a {\em prefix-n-list} are modified by taking
each `{\em prefix-n} {\em prefix-(n+1)-list}' component and
moving the {\em prefix-(n+1)-list} elements to
the MIN object represented by {\em prefix-n}.  So, for example,
\begin{center}
\TT{\{T\} X Y Z}
\end{center}
is just alternate syntax for
\begin{center}
\TT{\{T| X Y Z |\}}
\end{center}

\subsubsection{Prefix Definitions}
\label{PREFIX-DEFINITIONS}

Unlike brackets and indentation marks, prefix separator types do {\bf not}
have to be defined in order to be used.  But a prefix separator type
can be defined so that it has special effects on parsing.  For this purpose
a `\key{prefix separator type}' is referred to as just a `\key{prefix}'.

Prefix definitions are stored in the `\key{prefix table}' which is one
of the parser symbol tables.

When a prefix separator is parsed, its \TT{.type} is looked up
in the prefix table using the selectors in effect at the beginning
of the prefix separator parse.  If a table entry is found, it is
attached to the prefix and used thereafter to provide information
about the prefix.

It is important to note that the selectors used
in this lookup are those at the point of parsing the particular
prefix separator, and can lead to different results for the same
prefix \TT{.type} at different points in the input text.  In particular
these selectors may not be those in effect at the beginning of
the {\em prefix-n-list} containing the prefix separator.


Entries in the prefix table are managed by {\em parser-prefix-commands}
whose general syntax is:

\begin{indpar}
\emkey{parser-prefix-command}%
\label{PARSER-PREFIX-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define}%
          \ttmindex{define prefix}{parser command} ~
	  \begin{tabular}[t]{@{}l@{}}
	  \TT{prefix} ~ {\em prefix-name} ~ {\em parsing-selectors} \\
	  {}[ \TT{with parsing selectors} ~ {\em new-selectors} ] \\
	  {}[ \TT{with group} ~ {\em prefix-group} ] \\
	  {}[ \TT{with implied subprefix} ~ {\em implied-prefix} ] \\
	  {}[ \TT{with lexical master} ~ {\em master-name} ] \\
	  {}[ \TT{with parsing options} ~ {\em prefix-options} ] \\
          {}[ \TT{with} ~ \begin{tabular}[t]{@{}l}
	                  {\em reformatter-name} ~ \TT{reformatter} \\
			  {\em reformatter-arguments} ] \\
			  \end{tabular} \\
	  \end{tabular} \\
    $|$ & \ttmkey{undefine prefix}{parser command} ~
	  {\em prefix-name} ~
	  {\em parsing-selectors} \\
    \end{tabular}
\\[0.5ex]
\emkey{prefix-name} ::= {\em quoted-key}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\\[0.5ex]
\emkey{prefix-group} ::= {\em quoted-key}
                     $|$ {\em simple-name} not containing `\TT{with}'
\\[0.5ex]
\emkey{implied-prefix} ::= {\em typed-prefix-separator}\label{IMPLIED-PREFIX}
				~~~~~ [see \pagref{TYPED-PREFIX-SEPARATOR}]
\\[0.5ex]
\emkey{master-name} ::= {\em quoted-key}
                    $|$ {\em simple-name} not containing `\TT{with}'
\\[0.5ex]
\emkey{prefix-options}
    ::= \TT{[]}
    $|$ \TT{[} {\em prefix-option}
               \{ \TT{,} {\em prefix-option} \}\STAR{} \TT{]}
\\[0.5ex]
\emkey{prefix-option}
    \begin{tabular}[t]{rl@{~~~~~}l}
    ::= & {\em end-at-option} ~ except ~ `\TT{end at line separator}'
        & [see \pagref{END-AT-OPTIONS-1}] \\
    $|$ & \ttkey{sticky} $|$ \ttkey{continuing}
          \label{PARSING-HEADER-OPTIONS}
    \end{tabular}
\\[0.5ex]
\emkey{reformatter-name} ::= see \pagref{REFORMATTER-NAME} \\
\emkey{reformatter-arguments} ::= see \pagref{REFORMATTER-ARGUMENTS}

\end{indpar}

The components special to this definition are:

\begin{indpar}[0.4in]

\hspace*{-0.2in}\ttmkey{parsing selectors}{in prefix definition}\\
The elements of the {\em prefix-(n+1)-list} following a {\em prefix-n}
are parsed using the parsing selectors as they were at the beginning
of the containing {\em prefix-n-list} as modified by any {\em new-selectors}
found in a prefix definition of the type of the {\em prefix-n}.  These modified
selectors are also used to parse any subsequent {\em prefix-n} in the list
(and so the modifications should the chosen so they do not affect parsing of
prefixes or the lookup of prefix table definitions).

\hspace*{-0.2in}\ttmkey{group}{in prefix definition}\label{PREFIX-GROUP}\\
If the \TT{.type} attribute of a prefix has a prefix definition
with a non-missing {\em prefix-group}, this {\em prefix-group} is
the group of the prefix.  Othersie the \TT{.type} is the group of the
prefix.

In an expression of the form:
\begin{center}
\{ {\em prefix-n} {\em prefix-(n+1)-list} \}\PLUS{}
\end{center}
the {\em prefix-n}'s must all have the same group.

The groups `\TT{paragraph}' and `\TT{line}' are special:
see \itemref{HEADED-LINES} and \itemref{HEADED-PARAGRAPHS}.

\hspace*{-0.2in}\ttmkey{implied subprefix}{in prefix definition} \\
A copy of the {\em implied-prefix} is inserted immediately
after the {\em prefix-n}, and becomes the head of a {\em prefix-(n+1)-list}.
If this {\em prefix-(n+1)-list}  list has no elements other than
the {\em implied-prefix}, it is deleted and ignored.

Thus the effect is to insert the {\em implied-prefix} after the
{\em prefix-n} unless the logical line or bracketed expression
containing the {\em prefix-n-list} ends after the {\em prefix-n} or
unless an explicit prefix whose group is that
of a preceeding prefix (including the {\em implied-prefix}) follows
the {\em prefix-n} in the input.  However, there is one difference
if there is an explicit prefix, and this is that the selectors
used to parse the explicit prefix and find any associated prefix
table definition will be those modified by the {\em implied-prefix}
and may differ from those that would be at the same input position
had the {\em implied-prefix} not been inserted.

\hspace*{-0.2in}\ttmkey{parsing options}{in prefix definition}\\
`\TT{with parsing options}' is only permitted for prefixes that
have the `\TT{paragraph}' group.  The {\em prefix-options} are
used to set the \TT{paragraph\_options} line variable:
see \itemref{LINE-VARIABLES}.

\hspace*{-0.2in}\ttmkey{lexical master}{in prefix definition}\\
For prefixes with the `\TT{paragraph}' group, the {\em master-name} is used to
set the \TT{para\-graph\_lexi\-cal\_\EOL header} line variable.
For prefixes with the `\TT{line}' group, this may be
used to set the \TT{lexical\_header} line variable.
See \itemref{LINE-VARIABLES}.

\end{indpar}

The following reformatters may be used to change the MIN value
represented by a {\em prefix-n-list} headed by a defined prefix:

\begin{indpar}

\ttmkey{data}{reformatter}

\begin{indpar}[0.5em]
The subexpression must have the form
\begin{center}
TBD
\end{center}
TBD
\end{indpar}

\end{indpar}

\subsubsection{Mapped Lexemes}
\label{MAPPED-LEXEMES}

A `\key{mapped-lexeme}'
is a special kind of lexeme that can be mapped to different
type of token by a `\key{mapped lexeme symbol table}' entry.
Entries in this symbol table are managed by
{\em parser-mapped-lexeme-commands}:

\begin{indpar}[0.1in]
\emkey{parser-mapped-lexeme-command}%
\label{PARSER-MAPPED-LEXEME-COMMAND} \\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define}%
          \ttmindex{define mapped lexeme}{parser command}
	  \begin{tabular}[t]{@{}l@{}}
	  \TT{~mapped lexeme} ~ {\em mapped-lexeme-name} ~
	                       {\em parsing-selectors} \\
	  {}[ \TT{with token value} ~ {\em token-value} ] \\
	  {}[ \TT{with lexical master} ~ {\em master-name} ] \\
	  \end{tabular} \\
    $|$ & \ttmkey{undefine mapped lexeme}{parser command} ~
	  {\em mapped-lexeme-name} ~ {\em parsing-selectors} \\
    \end{tabular}
\label{MAPPED-LEXEME-DEFINITION}
\\[0.5ex]
\emkey{mapped-lexeme-name} ::= {\em quoted-key}
\\[0.5ex]
\emkey{quoted-key} ::= see \pagref{QUOTED-KEY}
\\[0.5ex]
\emkey{token-value}
    \begin{tabular}[t]{rl}
    ::= & {\em typed-bracketed-subexpression} \\
    $|$ & {\em typed-prefix-separator} \\
    $|$ & {\em untyped-bracketed-subexpression} \\
    \end{tabular}
\\[0.5ex]
\emkey{master-name} ::= {\em quoted-key}
                    $|$ {\em simple-name} not containing `\TT{with}'
\end{indpar}

If a \TT{parser define mapped lexeme} command gives no lexical master,
the lexical master is missing.

When the bracketed subexpression parser first sees a lexeme in
its token, the parser looks up the lexeme in the mapped lexeme
symbol table, selecting entries active according to the current
parser selectors.  If an entry is found, it is used to replace
the lexeme's token by another token, with token
value taken from the table entry, and token type computed
from the token value (e.g., \TT{BRACKETED}, \TT{BRACKETABLE},
\TT{PREFIX}, etc.).  The lexical master is also
changed to the value in the table entry before scanning more
lexemes, unless the table entry lexical master is missing.

If the {\em token-value} has a \TT{.type} and
no elements, no \TT{.initiator}, and no \TT{.terminator},
the token is given the \TT{PREFIX} token type rather
than the \TT{BRACKETED} token type.  Note that {\em token-values}
cannot be lexemes, quoted strings, or numerics.

A {\em token-value} may be an {\em untyped-bracketed-expression}
that becomes a \TT{DERIVED} label or special value upon being parsed.
A mapped lexeme can map to such a {\em token-value}, but not to
another lexeme.

A mapped lexeme is called a `\key{header lexeme}' if it is only
produced by looking
at the first non-whitespace characters of a logical line and does
not actually consume any of the characters it looks at.
So for example, if the
line begins with `\TT{========}', a header lexeme indicating
a table paragraph might be produced, followed by a header lexeme
indicating a table line, but none of the line beginning `\TT{=}'
characters will be skipped over while producing these header lexemes.
In short, the scanner will peek ahead but not read ahead when
producing header lexemes.  Header lexemes are usually mapped
to paragraph or line header \TT{PREFIX} tokens described in the
next sections.

\subsubsection{Headed Lines}
\label{HEADED-LINES}

A `\key{line header}' is a typed prefix separator that has
the `\TT{line}' group.  Line headers may only
appear at the beginning of a logical line, or immediately
after a paragraph header, which itself must begin a logical
line: see \itemref{HEADED-PARAGRAPHS}.

A `\key{headed line}' is a line header and the part of its containing logical
line that follows the line header.
The parser's output
for a headed line is a MIN object whose \TT{.type} and attributes
are taken from the line header and whose elements are
taken from the rest of the headed line.  This output has \underline{no}
\TT{.initiator}, unlike the parser's output
for a logical line that has no line header whose \TT{.initiator}
is the special value \TT{min::\EOL LOGICAL\_\EOL LINE()}.

Line headers may be implied by the \TT{implied subprefix}
of a paragraph header (see \itemref{PREFIX-DEFINITIONS}
and \itemref{HEADED-PARAGRAPHS})
or by line variables (see \itemref{LINE-VARIABLES}).

\subsubsection{Headed Paragraphs}
\label{HEADED-PARAGRAPHS}

A `\key{paragraph header}' is a typed prefix separator that has
the `\TT{paragraph}' group.  Paragraph headers may only
appear at the beginning of a logical line that follows a blank
line or is at the beginning of an indented paragraph (where
intervening comment lines are ignored).

A `\key{headed paragraph}' is a logical line that begins with paragraph header,
plus all the following logical or headed
lines up until the headed paragraph end.
A headed paragraph may be ended by a blank line (unless the paragraph
is `continuing'), or by the end
of its containing indented paragraph.

The parser's output for a headed paragraph is a MIN object 
whose \TT{.type} and attributes are taken from the paragraph header
and whose elements are the logical or headed lines in the headed paragraph.
If the first logical line of the headed paragraph contains only
the paragraph header, it is omitted from the list of elements
(so there is no blank logical line).

As an example, suppose the parser is given the definitions.
\begin{indpar}\begin{verbatim}
*PARSER*:
    define prefix "itemize" [code, text]
        with group paragraph
    define prefix "item" [code, text]
        with group line
\end{verbatim}\end{indpar}
Then when given the input (with `\TT{code}' or `\TT{text}'
a top level parsing selector):
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"}
{item}1 chicken
{item}1 tablespoon olive oil
{item}1 tablespoon paprika
\end{verbatim}\end{indpar}
the parser produces the MIN object:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"|
    {item: 1 chicken}
    {item: 1 tablespoon olive oil}
    {item: 1 tablespoon paprika}}
\end{verbatim}\end{indpar}

Now suppose the parser is given the definition:
\begin{indpar}\begin{verbatim}
*PARSER*:
    define prefix "itemize" [code, text]
        with group paragraph
        with implied subprefix {item}
\end{verbatim}\end{indpar}
with a `\TT{implied subprefix}'.  Then when given given the input:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"}
1 chicken
1 tablespoon olive oil
1 tablespoon paprika
\end{verbatim}\end{indpar}
the parser will produce the same MIN object.

Next suppose the parser is given the definition:
\begin{indpar}\begin{verbatim}
*PARSER*:
    define prefix "itemize" [code, text]
        with group paragraph
        with implied subprefix {item}
	with parsing options [+ sticky]
\end{verbatim}\end{indpar}
with a `\TT{sticky}' option.  Then when given given the input:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"}
1 chicken
1 tablespoon olive oil
1 tablespoon paprika

a potato
1 tablespoon butter
\end{verbatim}\end{indpar}
the parser will produce two MIN objects, the first being as
above and the second being:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"|
    {item: a potato}}
    {item: 1 tablespoon butter}}
\end{verbatim}\end{indpar}

If instead the parser is given the definition:
\begin{indpar}\begin{verbatim}
*PARSER*:
    define prefix "itemize" [code, text]
        with group paragraph
        with implied subprefix {item}
	with parsing options [+ continuing]
\end{verbatim}\end{indpar}
with a `\TT{continuing}' option, then when given the above input
the parser would produce the single MIN object:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"|
    {item: 1 chicken}
    {item: 1 tablespoon olive oil}
    {item: 1 tablespoon paprika}
    {item: a potato}}
    {item: 1 tablespoon butter}}
\end{verbatim}\end{indpar}

TBD

The indentation mark of an indented paragraph sets an
\TT{implied paragraph header} variable to either have
a missing value or to have a paragraph header value.  If the value of
this variable is not missing and a logical line beginning is
encountered that is not part of some previous headed paragraph,
a copy of this variable's value is inserted at the beginning of
that logical line.  See \itemref{LINE-VARIABLES} for details.

Consider the example:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*"}
{item}1 chicken 
{item}1 tablespoon olive oil
{item}1 tablespoon paprika

a potato
1 tablespoon butter

=============
| 1 chicken |
-------------
| 1 tablespoon olive oil |
-
| 1 tablespoon paprika
=
\end{verbatim}\end{indpar}

Here there are 3 headed paragraphs inside the top level indented
paragraph.  The first headed paragraph has
paragraph header `\TT{\{itemize\}}' and line headers `\TT{\{item\}}'
for each of its logical lines.  The second has the same headers but
they are implied.  The third headed paragraph has lexical headers:
the first line begins with `\TT{====}' which causes the
\begin{center}
\TT{\{table\}\EOL\{line\}}
\end{center}
paragraph header and line header to be inserted at this line's beginning,
and in subsequent lines `\TT{|}' inserts `\TT{\{row\}}' line headers
and both `\TT{-}' and `\TT{=}' insert `\TT{\{line\}}' line headers.
All this assumes there are appropriate entries in the parser's
prefix table for `\TT{itemize}', `\TT{item}', `\TT{table}',
`\TT{line}', and `\TT{row}', and that the lexical scanner has
been programmed to produce special lexemes in certain
contexts.  To be specific about the latter, the lexical scanner
at top level, upon seeing `\TT{====}' at the beginning of logical
line following a blank line,
must produce a special lexeme that maps
to `\TT{table}' and a second special lexeme that maps to `\TT{line}'.
Then for the remaining logical lines within this
`\TT{table}' headed paragraph, the scanner must
produce special lexemes that map to
`\TT{row}' for lines beginning with `\TT{|}' and
`\TT{line}' for lines beginning with `\TT{-}' or `\TT{=}'.

The above example might be used to generate the output:

\begin{indpar}
\begin{indpar}[5em]
\begin{itemize}
\item[*] 1 chicken
\item[*] 1 tablespoon olive oil
\item[*] 1 tablespoon paprika
\end{itemize}
\end{indpar}

\begin{indpar}[5em]
\begin{itemize}
\item[*] 1 potato
\item[*] 1 tablespoon butter
\end{itemize}
\end{indpar}

\begin{tabular}{|l|}
\hline\hline
1 chicken
\\\hline
1 tablespoon olive oil
\\\hline
1 tablespoon paprika
\\\hline\hline
\end{tabular}

\end{indpar}

For this example the indented paragraph elements produced are
the MIN objects:
\begin{indpar}\begin{verbatim}
{itemize: indent = 5em, mark = "*" |
    {item: | 1 chicken |}
    {item: | 1 tablespoon olive oil |}
    {item: | 1 tablespoon paprika |} |}

{itemize: indent = 5em, mark = "*" |
    {item: a potato |}
    {item: 1 tablespoon butter |} |}

{table: |
    {line: | ============= |}
    {row: "|" 1 chicken "|" |}
    {line: | ------------- |}
    {row: | "|" 1 tablespoon olive oil "|" |}
    {line: | - |}
    {row: | "|" 1 tablespoon paprika |}
    {line: | = |} |}
\end{verbatim}\end{indpar}

\subsubsection{Line Variables}
\label{LINE-VARIABLES}

A logical line is said to be in `\key{paragraph beginning position}'
if it follows a blank line or the beginning of its containing
indented paragraph, with comment lines possibly intervening.

While parsing an indented paragraph, the parser maintains the
following `\skey{line variable}s':

\begin{indpar}[0.4in]
\hspace*{-0.2in}\ttmkey{selectors}{line variable}\\
    The parsing selectors are reset to this value just after the
    indent token that begins a logical line.
\\[1ex]
\hspace*{-0.2in}\ttmkey{options}{line variable}\\
    The parsing options are reset to this value just after the
    indent token that begins a logical line.
\\[1ex]
\hspace*{-0.2in}\ttmkey{implied header}{line variable}\\
    May be missing or set equal to a paragraph or line header.

    If this value is not missing a copy of the value is inserted
    as an implied prefix just after the indent token that begins
    a logical line.  An implied prefix is just like an explicit
    prefix except if it has no following {\em prefix-n-list} elements
    it is removed.

    The type of a non-missing implied header must have a prefix
    definition selected by the \TT{selectors} line variable that
    has either the `\TT{paragraph}' or `\TT{line}' group.
\\[1ex]
\hspace*{-0.2in}\ttmkey{lexical master}{line variable}\\
    The lexical master is reset to this value just after the
    indent token that begins a logical line.
\\[1ex]
\hspace*{-0.2in}Note: The above line variables are called
the `\key{current line variables}'.
\\[1ex]
\hspace*{-0.2in}Note: If any current line variable is reset
after the current line varables
have been used at the beginning of a logical line,
the new value will not take affect until the next logical line.
\\[2ex]
\hspace*{-0.2in}\ttmkey{paragraph selectors}{line variable}\\
\hspace*{-0.2in}\ttmkey{paragraph options}{line variable}\\
\hspace*{-0.2in}\ttmkey{paragraph implied header}{line variable}\\
\hspace*{-0.2in}\ttmkey{paragraph lexical master}{line variable}\\
    These variables are called the `\key{paragraph line variables}'.

    The paragraph line variables
    are copied to corresponding current line variables
    just before the current line variables are used for a line
    in paragraph beginning position, \underline{unless} the
    \TT{options} current line variable
    contains the `\TT{continuing}' option.
\end{indpar}

An indentation mark initializes the paragraph line
variables from the definition of the indentation mark, and these
are copied to the current line variables at the
beginning of the indented paragraph.  The copied paragaph
line variables are used to process the first line of a paragraph,
and any implicit or explicit paragraph header then resets the
current line variables which are used to process the remaining lines
of the paragraph.

We assume that implicit paragraph and line headers
do \underline{not} change the selectors in such a way
as to alter the parsing of prefix separators.  If they do,
explicit paragraph or line headers may not be unrecognized
as prefix separators.  Importantly, the prefix
definitions cannot be changed during the parsing of a logical line.
Lastly, it is an error noted below if a prefix at the beginning
of a logical line has either the
`\TT{paragraph}' or `\TT{line}' group
when selected by selectors computed by implied
prefixes that may occur at the beginning of the line, but does
not have this same group when selected with selectors with some
of the implied prefixes deleted.

Line processing is as follows:

\begin{enumerate}

\item If the line is in paragraph beginning position and the
\TT{options} current line variable does not have the `\TT{continuing}'
option, the paragraph line variables are copied
to the corresponding current line variables.

\item The parsing selectors, options, and lexical master are set
from the corresponding current line variables.

\item If the current \TT{implied\_header} variable value is not missing,
a copy of that value is inserted at the beginning of the line.  The
prefix definition for this is looked up (using selectors now
equal to the \TT{selectors} current line variable) and used to modify
the selectors and options used to parse the rest of the line.

The prefix definition must exist and have either the `\TT{paragraph}' or
`\TT{line}' group, and if it has the `\TT{paragraph}' group,
the line must be in paragraph beginning position.

If the prefix definition has the `\TT{paragraph}' group, the
modified selectors and options, and the
lexical master from the prefix definition, are then used to reset
the corresponding current line variables.
If in addition the prefix definition has an implied subheader
that itself has a prefix definition selected by the modified
selectors which has the `\TT{line}' group, this implied subheader
is copied to the \TT{implied\_header} current line variable.

The {\em prefix-0-list} headed by the inserted implied header
is then parsed.  If this has no elements, it must be ended
by an explicit prefix separator that has a prefix definition
selected by the modified selectors that has the same group
as the implied header (as the logical line cannot
be empty).  In this case the inserted
implied header is deleted, the current line variables are
restored to their values just before they were reset by the
implied header (these are necessarily equal to the paragraph
line variable values), and parsing continues as if the
explicit prefix separator had been found directly.

If an empty {\em prefix-0-list} is ended by
a prefix that does not have a prefix definition
with the `\TT{paragraph}' group when looked up using the
\TT{selectors} current line variable (which must equal the
\TT{selectors} paragraph line variable), then the prefix is
in error and is ignored.  This error occurs because the prefix
definition is looked up twice with different selectors, and
the two look ups yielded a definition with the `\TT{paragraph}' group
the first time but not the second time.

Otherwise the {\em prefix-0-list} must have elements, as the
logical line is not empty.  In addition, the {\em prefix-0-list}
must end at the end of the logical line, as any prefix separator
within the line that would end the {\em prefix-0-list} before
the end of the line is in error and is ignored.

\item If the current implied header variable is missing,
or if an empty {\em prefix-0-list} was found and deleted by the previous
step, and if the first element of the logical line is a prefix
whose definition selected by the \TT{selectors} current line variable
has the `\TT{paragraph}' group, this prefix is an explicit paragraph
header.

If an explicit paragraph header is found,
its prefix definition is used to
modify selectors and options, and these modified selectors and options and the
lexical master from the prefix definition are then used to reset
the corresponding current line variables.
If in addition the prefix definition has an implied subheader
that itself has a prefix definition selected by the modified
selectors which has the `\TT{line}' group, his implied subheader
is copied to the \TT{implied header} current line variable.

Also if an explicit paragraph header is found, then:

\begin{enumerate}

\item If the \TT{options} current line variable
now has the `\TT{sticky}' option flag, the \TT{para\-graph implicit
header} line variable is set to a copy of the explicit paragraph header.

\item Otherwise the \TT{paragraph implicit header} line variable
is reset to the value it had at the beginning of the indented paragraph.

\end{enumerate}

\end{enumerate}



\subsubsection{Bracketed Parser Print Commands}
\label{BRACKETED-PARSER-PRINT-COMMANDS}

TBD

For parser \TT{define} commands defined in the following sections,
and also for the parser \TT{define selector} and
`\TT{define top level}' commands defined above,
there is a companion parser
`\ttkey{print}' command that prints the contents of the
parser symbol table entries with the designated {\em type} and any
{\em name} containing within it
the {\em partial-name} supplied by the print command.
Its syntax is
\begin{center}
\TT{parser print} {\em type} {\em partial-name}
\end{center}
The {\em partial-name} and {\em name} are both treated as sequences
of complete lexemes, and the former can be any subsequence of the
latter, not just an initial subsequence.  There is \underline{no}
partial lexeme matching.

The `\ttkey{print trace}' command prints the current set of
parsing trace flags.

The current string concatenator
can be printed by the \TT{parser print string con\-cat\-e\-na\-tor} command:
see \pagref{BRACKETED-PARSER-PRINT-COMMAND}.

A {\em bracketed-parser-print-command} has the syntax:

\begin{indpar}
\emkey{bracketed-parser-print-command}%
\label{BRACKETED-PARSER-PRINT-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{print bracket}{parser command}
	  {\em partial-name} \\
    $|$ & \ttmkey{print prefix}{parser command}
	  {\em partial-name} \\
    $|$ & \ttmkey{print mapped lexeme}{parser command}
	  {\em partial-name} \\
    $|$ & \ttmkey{print indentation offset}{parser command} \\
    $|$ & \ttmkey{print string concatenator}{parser command} \\
    \end{tabular}
\end{indpar}

All bracket symbol table entries are printed whose first name
component includes the {\em partial-name}, where the first name
component is one of
\begin{indpar}
\em
opening-bracket-name \\
indentation-mark-name \\
gluing-indentation-mark-name \\
typed-opening
\end{indpar}

A {\em parser-print-header-command} has the syntax:

\begin{indpar}
\emkey{parser-print-header-command}%
\label{PARSER-PRINT-HEADER-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{print header}{parser command} {\em partial-name} \\
    \end{tabular}
\end{indpar}

All bracket header symbol table entries are printed whose header name
component includes the {\em partial-name}.

\subsection{Parser Passes}

After a subexpression has been identified by the top level bracketed
subexpression recognition pass, a sequence of passes is run on the
subexpression.  Which passes are in the sequence is determined by the
parser pass stack and parser selectors.

The \key{parser pass stack} is a list of parser passes with a set of
selectors associated with each pass.  A pass in this list is active
if it has a selector in common with the parsing selectors computed
by the bracketed subexpression recognition pass.  After the top level pass
recognizes a subexpression, the active passes in the parser pass stack
are run in the order that they appear in the stack.

The parsing selectors
computed by the opening bracket of the bracketed subexpression
are attached to that bracketed subexpression.
These are used to determine activity of the parser passes run on the bracketed
subexpression and also the activity
of the parser definitions (i.e., parser symbol table entries)
used by these parser passes.
Note that only the brackets surrounding a bracketed subexpression
can change the parsing selectors in the parser context; the operators
that bound implicit subexpressions cannot change these parsing selectors.

The parser pass stack can be altered and inspected
by the following parser definitions:

\begin{indpar}
\emkey{parser-pass-command} \\
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{define pass}{parser command}
	  \begin{tabular}[t]{@{}l@{}}
	  {\em parser-pass-name} {\em parsing-selectors} \\
	  {\em parser-pass-stack-location} \\
	  \end{tabular} \\
    $|$ & \ttmkey{undefine pass}{parser command}
	  {\em parser-pass-name} \\
    $|$ & \ttmkey{print pass}{parser command}
    \end{tabular}
\\[0.5ex]
\emkey{parser-pass-stack-location}
    \begin{tabular}[t]{rl}
    ::= & \TT{after} {\em previous-parser-pass-name} \\
    $|$ & \TT{before} {\em next-parser-pass-name} \\
    $|$ & \TT{at end} \\
    \end{tabular}
\\[0.5ex]
\emkey{parser-pass-name} ::= {\em simple-name}
\\[0.5ex]
\emkey{previous-parser-pass-name} ::= {\em parser-pass-name}
\\[0.5ex]
\emkey{next-parser-pass-name} ::= {\em parser-pass-name}
\end{indpar}

The set of passes that may be run is builtin, and
cannot be changed.  The following are permitted {\em parser-pass-names}:

\begin{indpar}
\hspace*{-0.2in}\ttmkey{top}{parser pass name}\\
    This refers to the bracketed subexpression recognition pass which is
    always at the top of the parser pass stack,
    and can only be used as a {\em previous-parser-pass-name} to place
    a pass just below it on the stack.
\\[2ex]
\hspace*{-0.2in}\ttmkey{operator}{parser pass name}\\
    Parses expressions with computational operators (e.g., \TT{+} and
    \TT{*}).
\\[2ex]
\hspace*{-0.2in}\ttmkey{lexeme replacement}{parser pass name}\\
    Replaces sequences of lexemes with other
    sequences of lexemes (e.g., replaces plurals by singulars).
\\[2ex]
\hspace*{-0.2in}\ttmkey{radix number recognition}{parser pass name}\\
    Recognizes numbers with non-decimal radixes.
\\[2ex]
\hspace*{-0.2in}\ttmkey{scientific number recognition}{parser pass name}\\
    Recognizes numbers with exponents.
\\[2ex]
\hspace*{-0.2in}\ttmkey{number pair recognition}{parser pass name}\\
    Recognizes pairs of numbers (e.g., \TT{4 1/2}).
\\[2ex]
\hspace*{-0.2in}\ttmkey{number unit grouping}{parser pass name}\\
    Groups numbers and numeric units (e.g., \TT{4ft 5in}).
\\[2ex]
\hspace*{-0.2in}\ttmkey{unit multiplication insertion}{parser pass name}\\
    Inserts multipliers between numbers and
    numeric units (e.g., \TT{4*ft} and \TT{\$*4.99}).
\end{indpar}

The \TT{parser define pass} statement sets the
{\em parsing-selectors} of the named parser pass
and installs that pass in the parser pass stack at the
location specified.
If the pass was previously on the stack, it is removed first
and then re-installed.  The {\em parser-pass-name} and
{\em next-parser-pass-name} cannot be `\TT{top}'.
Any {\em previous-parser-pass-name} or {\em next-parser-pass-name}
given must name a pass already in the stack that is different from
the pass being installed.

The \TT{parser undefine pass} statement removes the named
parser pass from the stack, if it is in the stack, and does
nothing otherwise.  The `\TT{top}' pass cannot be undefined.

The \TT{parser undefine pass} statement destroys any symbol
table associated with the pass being undefined.  First undefining and then
redefining a pass effectively clears this symbol table.  Thus
first undefining and then redefining the `\TT{operator}' pass
clears the symbol table set by `\TT{parser define operator \ldots}'
commands.  On the other hand,
a `\TT{parser define pass operator \ldots}' statement 
may be used to change the `\TT{operator}' pass selectors or
position in the pass stack without clearing the operator symbol
table.

The \TT{parser print pass} statement prints the parser pass stack passes
with their associated selectors.

The input and output of a parser pass is a sublist of the list
of all tokens.  When a parser pass is called, it is provided with
a pointer to the first token of this sublist, and a pointer to the
first token after the sublist.  The pass may edit the sublist.
The pass is responsible for calling the next pass down in the parser
pass stack, and may edit the sublist before and/or after calling
this next pass.

The bracketed subexpression pass, also known as the `\TT{top}' pass,
is the first pass called for each
top level input line, recognizes bracketed subexpressions,
calls the next active lower pass for each bracketed subexpression,
and then replaces the bracketed subexpression by a single MIN object.

\subsection{The Operator Parsing Pass}
\label{OPERATOR-PARSING-PASS}

The \key{operator parsing pass} is an expression parser pass that uses
operators to restructure expressions.  Operators
are defined by operator definitions that can be added to the
parsing definition stack.  List separators, such as `\TT{,}', are treated
as operators, and have operator definitions.

{\em Parser-operator-commands} modify and print
the parsing definition stack:

\begin{indpar}[0.1in]
\emkey{parser-operator-command}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em parser-operator-definition} \\
    $|$ & {\em parser-print-operator-command} \\
    \end{tabular}
\label{PARSER-OPERATOR-COMMAND}
\end{indpar}

\subsubsection{Operator Definitions}
\label{OPERATOR-DEFINITION}

An \key{operator definition} specifies for each operator the following:

\begin{indpar}[1in]
Name and Selectors \\
Precedence \\
Operator Flags \\
Reformatter
\end{indpar}

The syntax of operator definitions is:

\begin{indpar}[0.1in]
\emkey{parser-operator-definition} \\
    \hspace*{0.2in}\begin{tabular}{rl}
    ::= & \TT{define}\ttmindex{define operator}{parser command}
	   ~\begin{tabular}[t]{@{}l@{}}
	    \TT{operator}
	        \begin{tabular}[t]{l}
		{\em operator-name} ~ {\em parsing-selectors} \\
		{\em operator-flag} ~ {\em operator-flag}\,\STAR{} \\
		\end{tabular} \\
	    \TT{with precedence} ~ {\em precedence} \\
	    {}[ \TT{with} ~ {\em reformatter-name} ~ \TT{reformatter}
			  ~ {\em reformatter-arguments} ] \\
	    \end{tabular} \\
    $|$ & \TT{undefine}\ttmindex{parser undefine operator}{parser command}
	   ~\begin{tabular}[t]{@{}l@{}}
	    \TT{operator}
	        \begin{tabular}[t]{l}
		{\em operator-name} ~ {\em parsing-selectors} \\
		{\em operator-flag} ~ {\em operator-flag}\,\STAR{} \\
		\end{tabular} \\
	    \TT{with precedence} ~ {\em precedence} \\
	    \end{tabular} \\
    \end{tabular}
\\[1ex]
\emkey{operator-name} \begin{tabular}[t]{rl}
		    ::= & {\em simple-operator-name} \\
		    $|$ & \TT{bracket} ~ {\em bracket-name} \\
		    $|$ & \TT{indentation mark} ~ {\em indentation-mark-name}
		    \end{tabular}
\\[1ex]
{\em simple-operator-name} ::= {\em quoted-key} \\[1ex]
{\em bracket-name} ::= see \pagref{BRACKET-NAME} \\[1ex]
{\em indentation-mark-name} ::= see \pagref{INDENTATION-MARK-NAME} \\[1ex]
\emkey{operator-flag} ::= \ttmkey{prefix}{operator flag}
                    $|$ \ttmkey{infix}{operator flag}
                    $|$ \ttmkey{postfix}{operator flag}
                    $|$ \ttmkey{nofix}{operator flag}
                    $|$ \ttmkey{afix}{operator flag}
	\\[1ex]
\emkey{precedence} ::= {\em sign-option} ~ {\em natural-number}
	\\[1ex]
\emkey{sign-option} ::= {\em empty} $|$ \TT{+} $|$ \TT{-}
	\\[1ex]
\emkey{reformatter-name} ::= see \pagref{REFORMATTER-NAME} \\
\emkey{reformatter-arguments} ::= see \pagref{REFORMATTER-ARGUMENTS}
\end{indpar}

A {\em simple-operator-name} is matched to lexemes in a subexpression
in order to identify occurrences of the operator.
The other forms of {\em operator-name} permit bracketed subexpressions
with particular kinds of brackets to be parsed as if they were operators.
Thus in `\TT{x[5]=0}' the bracketed subexpression
`\TT{[5]}' can be a postfix operator.  A subexpression
bracketed by `\TT{\{ \}}' is used as an afix (see below) to the
\TT{<-{}-} operator (as is a subexpression introduced by the `\TT{:}'
indentation mark).

By abuse of language, the term `\key{operator}' is often used
as a synonym for `{\em simple-operator-name}'.

Operators have \skey{operator flag}s that
affect parsing of subexpressions of the operator.  The possible
flags are `\TT{infix}', `\TT{prefix}', `\TT{postfix}',
`\TT{nofix}', and `\TT{afix}'.  An operator must have at least
one of these flags.

An \ttkey{infix} operator must be between two non-empty operands,
while a \ttkey{prefix} operator must precede a non-empty operand,
and a \ttkey{postfix} operator must follow a non-empty operand.
A prefix operator can only appear at the beginning of a subexpression and
has no preceding operand.
A postfix operator can only appear at then end of a subexpression and has
no following operand.

A \ttkey{nofix} operator is like an infix operator but may or may not be
preceded or followed by operands.  It may appear at the beginning or ending of
an expression, or two nofix operators may be consecutive in an expression.

An \ttkey{afix} operator\label{AFIX-OPERATOR} must follow
another operator that has the same precedence in a subexpression.
Subexpressions bracketed by `\TT{\{ \}}'
are standard afix operators with the same precedence
as the \TT{<-{}-} operator, so that an expression such as:
\begin{center}
\verb|sum from X through Y <-- integer X, integer Y { ... }|
\end{center}
is parse as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y) { ... }|
\end{center}
and \underline{not} as
\begin{center}
\verb|(sum from X through Y) <-- (integer X, integer Y { ... })|
\end{center}

An\label{FIXITY-RULES}
operator must be prefix, infix, postfix, nofix, or afix.
A prefix operator may also be infix or postfix, but may not be afix.
An infix operator may also be prefix or afix, but not postfix.
An postfix operator may also be prefix or afix, but not infix.
A nofix operator may afix, but not prefix, infix, or postfix.

This can be summarized in the following compatibility table:

\begin{center}
\begin{tabular}{|c|c|c|c|l}
\cline{1-4}
infix  & postfix & nofix & afix & \\
\hline
yes    & yes     & no    & yes   &  \multicolumn{1}{|l|}{prefix} \\
\cline{1-5}
\multicolumn{1}{c|}{}
       & no      & no    & yes   &  \multicolumn{1}{|l|}{infix} \\
\cline{2-5}
\multicolumn{2}{c|}{}
                 & no    & yes   &  \multicolumn{1}{|l|}{postfix} \\
\cline{3-5}
\multicolumn{3}{c|}{}
                         & yes   &  \multicolumn{1}{|l|}{nofix} \\
\cline{4-5}
\end{tabular}
\end{center}

The {\em precedence} of an operator is an integer.  Precedence is used to
determine which operators are inside and outside implicit brackets.
Operators with higher precedence are placed inside the 
implicit brackets that surround operands of operators of lower precedence.
Implicit brackets are used to define subexpressions, so that all operators
in a subexpression that are not in sub-subexpressions are of the same
precedence.

The {\em reformatter-name} in an {\em operator-definition} names a
function that is called after all other parsing has been done to
reformat a subexpression whose first operator is the defined operator.
For example, given the expression `\TT{-x+6*y}', the subexpression
`\TT{6*y}' is extracted, and as its first operator is `\TT{*}',
the reformatter for that operator is called and yields `\TT{* 6 y}'.
Similarly the subexpression `\TT{-x}' is extracted but the reformatter
for `\TT{-}' does not change `\TT{-x}'.
Then the reformatter for `\TT{+}' is called
with `\TT{[. -x .]+[. * 6 y .]}', since `\TT{+}' is the first operator in
this subexpression \underline{after} subexpressions have been handled.
This reformatter returns `\TT{+ [. -x .] [. * 6 y .]}'.  Here we have
use parentheses \TT{[. .]} to indicate implicit parentheses.

The optional {\em reformatter-arguments} are arguments to the reformatter
function.  For example, the `\TT{summation}' reformatter takes two
arguments, `\TT{(} {\em plus-op}\TT{,} {\em minus-op} \TT{)}', which
are usually `\TT{("+","-")}'.

\subsubsection{The Print Operator Command}

A {\em parser-print-operator-command} has the syntax:

\begin{indpar}
\emkey{parser-print-operator-command}%
\label{PARSER-PRINT-OPERATOR-COMMAND}
\\
    \hspace*{0.2in}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{print operator}{parser command}
	  {\em partial-name} \\
    \end{tabular}
\end{indpar}

All operator symbol table entries are printed whose first name
component includes the {\em partial-name}, where the first name
component is one of
\begin{indpar}
\em
simple-operator-name \\
opening-bracket-name \\
indentation-mark-name \\
gluing-indentation-mark-name
\end{indpar}


\subsubsection{Standard Operators}
\label{STANDARD-OPERATORS}

The standard operators are given on 
\pagref{STANDARD-OPERATOR-LIST}.

\begin{figure*}[!p]
\begin{center}
\begin{tabular}{rll@{\hspace*{2em}}l@{\hspace*{2em}}l}

precedence & reformatter	& type	& operator	& meaning 
\\[2ex]
0000	& \ttkey{declare}	& \TT{nofix}	& \ttkey{<-{}-}	& define \\
	&			& \TT{afix}	& \ttkey{\{ ... \}} & block \\
1000	& \TT{right}		& \TT{infix}	& \ttkey{=}	& assignment \\
     	& \TT{associative\ttindex{right associative}}
				&          	& \ttkey{+=}	& increment \\
     	&               	&          	& \ttkey{-=}	& decrement \\
     	&               	&          	& \ttkey{*=}	& multiply by \\
     	&               	&          	& \ttkey{/=}	& divide by \\
2000	& \ttkey{separator}	& \TT{nofix}	& \ttkey{,}	& separator \\
3000	& \ttkey{binary}	& \TT{nofix}	& \ttkey{BUT NOT}
								& logical and
								  not \\
3100	& \ttkey{infix}		& \TT{infix}	& \ttkey{AND}	& logical and \\
	&			&		& \ttkey{OR}	& logical or \\
3100	& \ttkey{unary}		& \TT{prefix}	& \ttkey{NOT}	& logical not \\
4000 	& \ttkey{infix and}	& \TT{infix}	& \ttkey{==}	& equal \\
	&			&		& \ttkey{/=}  & not equal \\
	&			&		& \ttkey{!=}	& ditto \\
	&		      	&		& \ttkey{<}	& less than \\
	&			&		& \ttkey{<=}	& less than or
								  equal \\
	&			&		& \TT{=<}	& ditto \\
	&		      	&		& \TT{>}	& greater than
									\\
	&			&		& \TT{>=}	& greater than
								  or equal \\
	&			&		& \TT{=>}	& ditto \\
5000	& \ttkey{sum}		& \TT{infix}	&  \TT{+}	& addition \\
	&			&		& \TT{-}	& subtraction \\
5100	& \ttkey{binary}	& \TT{infix}	& \TT{/}	& division \\
5200	& \ttkey{infix}		& \TT{infix}	& \TT{*}
							& multiplication \\
5300	& \ttkey{binary}	& \TT{infix}	& \TT{\textasciicircum}
							& exponentiation \\
10000	& 			& \TT{prefix}	&  \TT{-}	& minus \\
	& 			& \TT{prefix}	&  \TT{+}	& plus \\
	& 			& \TT{prefix}	&  \TT{@}	& object
	                                                          identifier \\
\end{tabular}
\end{center}
\label{STANDARD-OPERATOR-LIST}
\end{figure*}


Below we describe the effects of standard operator reformatters.
We use notation such as

\hspace*{2em}\begin{tabular}{lcl}
\TT{x = y = z + w} & $\Longrightarrow$ & \TT{= x ( = y (+ x w))} \\
\TT{x AND y OR z} & $\Longrightarrow$ & error
\end{tabular}

Here $\Longrightarrow$ means `is reformatted as'.  Furthermore, the
parentheses introduced by the rewrite are \underline{implied},
which means that the lists they bracket have \underline{no}
\TT{.initiator} or \TT{.terminator}, and the parentheses are
merely written here to indicate sublists in the expression structure.

Reformatters can detect parsing errors, such the fact that both
operators in `\TT{x AND y OR z}' are not identical (when both are
infix operators with the same precedence).

Note that what would be parsing errors in some other parsing systems
are not in this system.  For example,

\hspace*{2em}\begin{tabular}{lcl}
\TT{x AND AND y} & $\Longrightarrow$ & \TT{AND x (AND y)} \\
\end{tabular}

because the second \TT{AND} is not considered to be an operator and
`\TT{AND y}' is considered to be a valid subexpression that might be
a variable name.  If this does not name anything, a naming error should
be detected, but this is not a parsing error.

In some circumstances 
the bracketed subexpression recognition pass merges the brackets
it finds into a list returned by a reformatter.
If the bracketed subexpression recognition pass
would otherwise
return a list (with \TT{.initiator} or \TT{.terminator}) that has a single
element which is a list without an \TT{.initiator} or
\TT{.terminator}, then instead of forming the outer list,
the bracketed subexpression recognition
pass copies its attributes to the inner list.

Thus given `\TT{(x,y)}', the `\TT{separator}'
reformatter will return
\begin{indpar}\begin{verbatim}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
so without this merging the bracketed subexpression recognition
pass would produce
\begin{indpar}\begin{verbatim}
@2 = @1 {| .initiator = "("; .terminator = ")" |}
@1 = x y {| .separator = "," |}
\end{verbatim}\end{indpar}
but instead it produces
\begin{indpar}\begin{verbatim}
@3 = x y :|
    .initiator = "("
    .terminator = ")"
    .separator = ","
\end{verbatim}\end{indpar}
See \pagref{MERGING-BRACKATABLE-TOKENS} for more details.

Sometimes \ikey{temporaries}{temporary}\label{TEMPORARY}
are introduced by reformatting.  The syntax involving temporaries is:

\begin{indpar}
\emkey{temporary-definition} ::= {\em temporary} {\em subexpression} \\[1ex]
\emkey{temporary} ::= \TT{\$} {\em natural-number}
\end{indpar}

During reformatting, a subexpression may be replaced by
a {\em temporary-definition} containing the subexpression.  This
defines the {\em temporary} as a name for the value of the subexpression.
Then the {\em temporary} can be used in the reformatted
expression to refer to this value.  An example is

\begin{center}
\TT{x == y + 3 == z} ~~~ $\Longrightarrow$ ~~~
\TT{AND (== x (\$ 563 (+ y 3))) (== (\$ 563) z)}
\end{center}

Here the temporary has been used to avoid computing \TT{y + 3}
more than once.

The {\em natural-numbers} in {\em temporaries} must be assigned so no
two {\em temporary-definitions} ever have the same {\em temporary}.

With these things in mind, the reformatters are:

\begin{indpar}[1em]

\newcommand{\OP}[1]{\ttmkey{#1}{reformatting}}
\newcommand{\NBOP}[1]{\ttmkey{#1}{reformatting}}

\bigskip

\ttmkey{separator}{reformatter} \TT{(} {\em separator} \TT{)}
\hfill \OP{;} ~~~ \OP{,}


\begin{indpar}[0.5em]
May only be used with \TT{nofix} operators.

There must be at least one operator, and all operator values must
be identical.  It is required that any two operands be separated by an operator,
but operators my be consecutive and may begin or end the subexpression.

Empty list operands are inserted to make all operators
infix.  Then the operators are deleted, the resulting list of
operands is given a \ttmkey{.separator}{produced by parsing}
attribute with value of the {\em separator} argument to the reformatter,
and this is returned as the result of the reformatting.  Examples
with `\TT{,}' as both the operator and the {\em separator} argument to the
reformatter are:

\hspace*{2em}\begin{tabular}{lcl@{~~~~~}l}
\TT{x , y} & $\Longrightarrow$ & \TT{x y}
					& with \TT{.separator} \TT{","} \\
\TT{, y} & $\Longrightarrow$ & \TT{() y}
					& with \TT{.separator} \TT{","} \\
\TT{x ,} & $\Longrightarrow$ & \TT{x ()}
					& with \TT{.separator} \TT{","} \\
\TT{x ,, y} & $\Longrightarrow$ & \TT{x () y}
					& with \TT{.separator} \TT{","} \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{declare}{reformatter} \hfill \NBOP{<-{}-} ~~~ \NBOP{\{\}} ~~~ \OP{:}

\begin{indpar}[0.5em]
May only be used with \TT{nofix}, \TT{prefix}, or \TT{infix} operators.


All operators but the first must be bracketed subexpressions,
and any operands must be just before or just after the first operator.
If the first operator is not preceded by an operand,
an empty list is inserted as the preceding operand.
Similarly if first operator is not followed by an operand, an empty
list is inserted as the following operand.
Then the first operator is moved to the
beginning of the expression and the remaining
bracketed operators are converted to operands.
Indented subexpressions are treated as bracketed subexpressions and
may be bracketed operators.

For example, if \TT{<-{}-} is a nofix operator with this reformatter, and
\TT{\{ \}} bracketed subexpressions and \TT{:} indented subexpressions
are afix operators of the same precedence:

\hspace*{2em}\begin{tabular}{lcl}
\TT{x <-{}- y \{ z \}} & $\Longrightarrow$ & \TT{<-{}- x y \{ z \}} \\
\TT{x <-{}- \{ z \}} & $\Longrightarrow$ & \TT{<-{}- x () \{ z \}} \\
\TT{<-{}- y \{ z \}} & $\Longrightarrow$ & \TT{<-{}- () y \{ z \}} \\
\TT{x <-{}-} & $\Longrightarrow$ & \TT{<-{}- x ()}
\\[1ex]
\begin{tabular}{@{}l@{}}
\TT{x~<-{}-~u v w:} \\
\TT{~~~~~~z}
\end{tabular}
& $\Longrightarrow$ &
\begin{tabular}{@{}l@{}}
\TT{<-{}- x ( u v w ):} \\
\TT{~~~~z}
\end{tabular}
\end{tabular}

Note that because \TT{\{ \}} bracketed subexpressions are afix operators
with same precedence as \TT{<-{}-},
`\TT{x <-{}- y \{ z \}}' does \underline{not}
end up as `\TT{<-{}- x ( y \{ z \} )}'.

\end{indpar}

\bigskip


\ttmkey{right associative}{reformatter}
    \hfill \NBOP{=} ~~~ \NBOP{+=} ~~~ \NBOP{-=} ~~~ \NBOP{*=} ~~~ \NBOP{/=}

\begin{indpar}[0.5em]
May only be used with \TT{infix} operators.

Therefore operands and operators alternate,
with the first and last subexpression
elements being operands, and there is at least one operator.

If there is only one operator, it is simply moved to the front.  If there
are several, they are rewritten as one operator subexpressions so the
rightmost executes first.  Thus if \TT{=}, \TT{+=}, and \TT{*=}
are all infix operators of the same precedence with this reformatter:

\hspace*{2em}\begin{tabular}{lcl}
\TT{y = z} & $\Longrightarrow$ & \TT{= y z} \\
\TT{x = y = z} & $\Longrightarrow$ & \TT{= x (= y z)} \\
\TT{x += y *= z} & $\Longrightarrow$ & \TT{+= x (*= y z)} \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{unary}{reformatter}
    \hfill \NBOP{NOT} ~~~ \NBOP{+} ~~~ \NBOP{-} ~~~ \NBOP{@}

\begin{indpar}[0.5em]
May only be used with \TT{nofix} or \TT{prefix} operators.

The subexpression must have exactly two elements, an operator followed
by an operand.  The subexpression is left unchanged.  Examples:

\hspace*{2em}\begin{tabular}{lcl}
\TT{NOT x} & $\Longrightarrow$ & \TT{NOT x} \\
\TT{x NOT} & $\Longrightarrow$ & error \\
\TT{x NOT y} & $\Longrightarrow$ & error \\
\TT{NOT NOT x} & $\Longrightarrow$ & error \\
\TT{- x y} & $\Longrightarrow$ & error \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{binary}{reformatter} \hfill \NBOP{BUT NOT} ~~~ \NBOP{/}
					           ~~~ \NBOP{\textasciicircum}

\begin{indpar}[0.5em]
May only be used with \TT{nofix} or \TT{infix} operators.

The subexpression must have exactly three elements, an operand
followed by an operator followed by an operand.  The operator is moved
to the beginning of the expression.  Examples:

\hspace*{2em}\begin{tabular}{lcl}
\TT{x BUT NOT y} & $\Longrightarrow$ & \TT{BUT NOT x y} \\
\TT{x / y} & $\Longrightarrow$ & \TT{/ x y} \\
\TT{x \textasciicircum y} & $\Longrightarrow$ & \TT{\textasciicircum x y} \\
\TT{x / y / z} & $\Longrightarrow$ & error \\
\TT{/ y} & $\Longrightarrow$ & error \\
\TT{x /} & $\Longrightarrow$ & error \\
\end{tabular}

Note that in these examples `\TT{BUT NOT}' is a single label element
of the resulting subexpression,
and \underline{not} two word elements of the subexpression.
\end{indpar}

\bigskip

\ttmkey{infix}{reformatter} \hfill \NBOP{AND} ~~~ \NBOP{OR} ~~~ \NBOP{*}

\begin{indpar}[0.5em]
May only be used with \TT{infix} operators.

Operands and operators must alternate, with the first and last subexpression
elements being operands, there must be at least one operator, and all
operators must be the same.  The first operator is moved to the
front of the subexpression, and the other operators are removed.
Examples:

\hspace*{2em}\begin{tabular}{lcl}
\TT{x AND y} & $\Longrightarrow$ & \TT{AND x y} \\
\TT{x AND y AND z} & $\Longrightarrow$ & \TT{AND x y z} \\
\TT{x OR y} & $\Longrightarrow$ & \TT{OR x y} \\
\TT{x OR y OR z} & $\Longrightarrow$ & \TT{OR x y z} \\
\TT{x * y} & $\Longrightarrow$ & \TT{* x y} \\
\TT{x * y * z} & $\Longrightarrow$ & \TT{* x y z} \\
\TT{AND y AND z} & $\Longrightarrow$ & error \\
\TT{x AND AND z} & $\Longrightarrow$ & error \\
\TT{x AND y AND} & $\Longrightarrow$ & error \\
\end{tabular}
\end{indpar}

\bigskip

\ttmkey{infix and}{reformatter} \TT{(} {\em and\_op} \TT{)} \hfill
	\NBOP{==} ~~~ \NBOP{<} ~~~ \NBOP{>} ~~~
	\NBOP{/=} ~~~ \NBOP{!=} ~~~
	\NBOP{=>} ~~~ \NBOP{>=} ~~~
	\NBOP{=<} ~~~ \NBOP{<=}

\begin{indpar}[0.5em]
May only be used with \TT{infix} operators.

Operands and operators must alternate, with the first and last subexpression
elements being operands, and there must be at least one operator.
If there is only one operator, it is simply moved to the front.  Otherwise
the expression is rewritten so the operators become two-argument functions
whose values are combined by a multi-argument {\em and\_op} and whose
shared operands are represented by temporaries (\pagref{TEMPORARY})
to avoid computing an operand twice. 
Examples in which \TT{<}, \TT{==}, \TT{!=}, and \TT{<=} all have
the same precedence and this reformatter with {\em and\_op} being `\TT{AND}':

\hspace*{2em}\begin{tabular}{lcl}
\TT{x < y < z} & $\Longrightarrow$ &
    \TT{AND (< x (\$ 56 y)) (< (\$ 56) z))} \\[1ex]
\TT{w == x != y <= z} & $\Longrightarrow$
             & \begin{tabular}[t]{@{}l@{~}l@{}}
	       \TT{AND} & \TT{(== w (\$ 57 x))} \\
			  & \TT{(!= (\$ 57) (\$ 58 y))} \\
			  & \TT{(<= (\$ 58) z)} \\
	       \end{tabular}
\end{tabular}

Note that sequences of comparison operators are treated as they are
in mathematics and not as they are in classical programming languages.
E.g., \TT{x<y<z} means \TT{x<y AND y<z} and \underline{not}
\TT{(x<y)<z}.
\end{indpar}

\bigskip

\ttmkey{sum}{reformatter} \TT{(} {\em plus\_op} {\em minus\_op} \TT{)}
			  \hfill \NBOP{+} ~~~ \NBOP{-}

\begin{indpar}[0.5em]
May only be used with \TT{infix} operators.

Operands and operators must alternate, with the last subexpression
element being an oper\-and, and there must be at least one operator.
The operators must be either {\em plus\_op} or {\em minus\_op}.

Every `{\em minus\_op} {\em operand}' is rewritten as
`{\em plus\_op} \TT{(} {\em minus\_op} {\em operand} \TT{)}'.
Then the first {\em plus\_op} is moved to the front and the other
{\em plus\_op}'s are removed.

For example, if {\em plus\_op} is `\TT{+}' and {\em minus\_op} is
`\TT{-}' and both these operators are infix with the same precedence
and this reformatter:

\hspace*{2em}\begin{tabular}{lcl}
\TT{x + y} & $\Longrightarrow$ & \TT{+ x y} \\
\TT{x - y} & $\Longrightarrow$ & \TT{+ x (- y)} \\
\TT{x - y + z - w} & $\Longrightarrow$ & \TT{+ x (- y) z (- w)} \\
\end{tabular}

\end{indpar}

\bigskip

\end{indpar}


\subsubsection{The Operator Parsing Algorithm}
\label{OPERATOR-PARSER-ALGORITHM}


The operator parsing pass runs an
algorithm that accepts as input a sequence of tokens
which we call an `expression'
and edits this input, changing it into a single token.
To do this it performs the following steps:
\begin{itemlist}[0.7in]
\item[Step 1:] Identify subexpressions within the expression and run the
operator parsing pass on these, converting them into a single
\TT{BRACKETABLE} or lexeme token.
\item[Step 2:] Identify operators within the expression and replace them
with \TT{OPERATOR} tokens.
\item[Step 3:] If no operators were found in the expression,
run any passes subsequent to the operator parsing pass on the expression,
and then if the expression (after running the subsequent passes)
has zero or more than one
token, replace the expression by a single \TT{BRACKETABLE} token listing the
tokens of the expression.

If operators were found in the expression,
run the reformatter of the first operator
in the expression.  This replaces the expression by a single
\TT{BRACKETABLE} or lexeme token.
If no reformatter is provided by the first operator, a default
reformatter is run that replaces the expression by a single \TT{BRACKETABLE}
token whose value has the operator label as its \TT{.operator} attribute.

After this step the expression is always a single \TT{BRACKETABLE} or
lexeme token.
\end{itemlist}

The token list at the point where Step 3 is about to execute
obeys the following requirements:
\begin{itemlist}[1.3in]
\item[Requirement 1:] 
All the \TT{OPERATOR} tokens in the token list are for operators
with the same precedence.  Furthermore, if $P$ is this precedence, and
$P'$ is the precedence of operators in an \TT{BRACKETABLE} token of the list,
then either $P<P'$ or all of the following are true:
\begin{itemize}
\item[(a)] $P=P'$
\item[(b)] The token list contains only two members, an operator and
a \TT{BRACK\-ET\-ABLE} token operand.
\item[(c)] Either the token list and the operand both begin with a prefix
operator, or both end with a postfix operator.
\end{itemize}
\item[Requirement 2:] 
The list does \underline{not} contain two consecutive non-\TT{OPERATOR} tokens.
\item[Requirement 3:] 
The first \TT{OPERATOR} token in the list is not afix.
\item[Requirement 4:] 
If the list contains a prefix \TT{OPERATOR} token, that is the first
token in the list, and it is followed in the list by a
non-\TT{OPERATOR} token.
\item[Requirement 5:] 
All infix \TT{OPERATOR} tokens in the list are both preceded by and
followed by non-\TT{OPERATOR} tokens.
\item[Requirement 6:] 
If the list contains a postfix \TT{OPERATOR} token, that is the last
token in the list, and it is preceded in the list by a
non-\TT{OPERATOR} token.
\end{itemlist}

A single
lexeme token output by a operator parsing pass may be
thought of as the equivalent of one of the following:
\begin{itemize}
\item[(a)] If the token is not a quoted string, and therefore
has a token value that is a MIN string, the token is equivalent to
a single \TT{BRACKETABLE} token whose token value is a MIN object
with no \TT{.separator} attribute whose only element is this MIN string.
\item[(b)] If the token is a quoted string, the token is equivalent to
a single \TT{BRACKETED} token whose token value
is a MIN object with one element equal to the
token value converted to a MIN string and with
an \TT{.initiator} attribute equal to \TT{"}.
\end{itemize}
When a single lexeme token output from an operator parsing pass
must be converted to an expression token, it is converted according
to this equivalence.

The operator parsing pass scans its input token list from
left to right, recognizing operators, beginning non-explicitly
bracketed subexpressions, and ending such subexpressions.
At any point in the scan the pass obeys the
following rules:
\begin{itemlist}[0.7in]
\item[Rule 1:] An afix operator is not recognized unless it
is proceeded by an operator of equal precedence with no
intervening operators of less precedence.
\item[Rule 2:] A prefix operator of precedence $P'$
must be preceded by the beginning of
the entire token list, or by an operator
of precedence less than $P'$,
or by a prefix operator of precedence equal to $P'$,
else the prefix operator is not recognized.
\item[Rule 3:] An infix operator of precedence $P'$
must be preceded by a non-operator,
or by an operator of precedence greater than $P'$,
else the infix operator is not recognized.
\item[Rule 4:] A postfix operator of precedence $P'$
must be preceded by a non-operator,
or by an operator of precedence greater than $P'$,
or by a postfix operator of precedence equal to $P'$,
else the postfix operator is not recognized.
\item[Rule 5:] A recognized prefix operator of precedence $P'$
must be followed by a non-operator or by an operator
of precedence greater than $P'$,
or by a prefix operator of precedence equal to $P'$,
else an `error operand' which is not an operator
is inserted after the prefix operator
and an error is announced.
\item[Rule 6:] A recognized infix operator of precedence $P'$
must be followed by a non-operator or by an operator
of precedence greater than $P'$,
else an `error operand' which is not an operator
is inserted after the infix operator
and an error is announced.
\item[Rule 7:] A recognized postfix operator of precedence $P'$
must be followed by the end of the entire token list,
or by an operator of precedence less than $P'$,
or by a postfix operator of precedence equal to $P'$,
else an `error nofix operator' of precedence $P'-1$
is inserted after the postfix operator and an error is announced.
\item[Rule 8:] When an operator is found, a new subexpression
with the precedence of the found operator is begin if one of
the following is true:
\begin{itemize}
\item[(a)] There is no previous operator outside all ended subexpressions.
\item[(b)] The found operator has higher precedence than the nearest
previous operator outside all ended subexpressions.
\item[(c)] The found operator is immediately preceded by a prefix
operator of equal precedence to the found operator.
\end{itemize}
The new subexpression begins just after the nearest previous operator
that is outside all ended subexpressions, if there is such an operator,
or at the beginning of the entire list, otherwise.
\item[Rule 9:] A subexpression is ended just before an operator
which has precedence lower than the precedence of the subexpression,
just before the end of the list, or just before an operator which
has precedence equal to the precedence of the subexpression if that
operator immediately follows a postfix operator.
\item[Rule 10:] A subexpression 
is replaced when it ends by a single BRACKETABLE whose
elements are the values of the tokens in the subexpression, unless
the subexpression contains just a single non-operator token.
\end{itemlist}

By simply by enforcing these rules the operator parser pass enforces
the requirements listed above.

During its left-to-right scan the operator parser pass maintains
the following state:
\begin{itemlist}[0.7in]
\item[$C$:] A pointer to the current token, initialized to the
first token in the input.
\item[$N$:] A pointer to the next token after the subexpression
being input, which may be an end-of-file token.  Not changed during
the scan from its initial value.  Initially $C\neq N$.
\item[$P$:] A stack of subexpression terminating precedences,
initialized to a one element stack containing a precedence less
than any legal operator precedence.  Whenever an operator is found,
the top of this stack is set to the precedence of the operator
(the stack may be pushed or popped before this is done).
\item[$F$:] A stack of pointers to the first token in a subexpression,
initialized to a one element stack containing a pointer to the first
token in the input.  Whenever an operator is found, the top of this
stack is set to point to the token after the operator (the stack
may be pushed or popped before this is done).
\item[$T$:] The type of the last operator found.  Valid only if
$C=F$ (meaning $C$ equals the top of the $F$ stack, and so $C$
points at the token after the operator).
Can equal {\em prefix}, {\em postfix}, {\em nofix}, {\em infix}, or {\em none}.
Initialized to {\em none}.
\end{itemlist}

In the following $F$ is used to denote either the stack $F$ or
the top element of this stack.  Similarly $P$ is used to denote either the
stack $P$ or the top element of this stack.

The operator parser pass algorithm simply repeats the following
steps in a loop:
\begin{itemlist}[1.2in]
\item[Loop Step 1:]
If $C\neq N$, find an operator beginning at token $C$, if there is one.

If $C=F$ (i.e., $C$ is at the beginning of the token list or just after
an operator of precedence $P$),
prefix operators of precedence less than $P$ are ignored,
prefix operators of precedence equal to $P$ are ignored unless
$T=\mbox{\em prefix}$,
infix operators of precedence greater than or equal to $P$ are ignored,
postfix operators of precedence greater than $P$ are ignored,
postfix operators of precedence equal to $P$ are ignored unless
$T=\mbox{\em postfix}$.

If $C\neq F$ (i.e., a non-operator is just before $C$),
prefix operators are ignored.

Any afix operator whose precedence is not in the $P$ stack is ignored.

Any operator whose selectors are disjoint from the current parser context
selectors is ignored.

Among all non-ignored operators, a longest
is selected, and among all the longest, the one with the most recent
operator definition is selected.

If an operator was found, replace its tokens by a single
OPERATOR token, point $C$ at that token.  Let $P'$ be the precedence
of the found operator and $T'$ be its type.
\item[Loop Step 2:]
If $C=F$ and $T=\mbox{\em postfix}$
(the token before $C$ is a postfix operator),
$C\neq N$, and either no operator was find in Loop Step 1,
or an operator was found and either $P'>P$
or both $P'=P$ and $T'\not=\mbox{\em postfix}$,
insert the error nofix operator of precedence
equal to $P-1$ as a single
OPERATOR token before $C$, set $C$ to point at it,
set $P'=P-1$,
announce an error, and continue (as if an operator were found in
Loop Step 1).

\item[Loop Step 3:]
Else if $C\neq N$
and no operator was find in Loop Step 1 or generated by Loop Step 2,
re-point $C$ to the next token after $C$ and go to the next loop iteration.

Note that if the iteration continues after this step,
then either $C=N$ or an operator was found in Loop Step 1
or generated in Loop Step 2.
\item[Loop Step 4:]
If $C=F$ and any of the following are true:
\\[1ex]
\hspace*{0.2in}
\begin{tabular}{@{}l@{}}
$T=\mbox{\em infix}$ and $C=N$ or $P'\leq P$, \\
$T=\mbox{\em prefix}$ and $C=N$ or $P'<P$
    or both $P'=P$ and $T'\not=\mbox{\em prefix}$
\end{tabular}
\\[1ex]
then insert
an new error operand lexeme token before $C$,
set $F$ to this new token,
announce an error, and then continue as if no error were found.
\item[Loop Step 5:]
If $C\not=F$,
apply Step 3 above to the list of tokens beginning with
$F$ and ending just before $C$.  This replaces this list of tokens
by a single non-operator token.

If $C=N$, pop the $P$ and $F$ stacks.  If these stacks are now
empty, terminate the operator parser pass algorithm.  Otherwise
repeat this loop step.

Else if $P'<P$ or both $P'=P$ and $T=\mbox{\em postfix}$,
pop the $P$ and $F$ stacks and repeat this loop step
(cannot happen if the $P$ and $F$ stacks have only one entry as
in that case $P$ is less than any possible $P'$).

Else if $P'>P$ or both $P'=P$ and $T=\mbox{\em prefix}$,
push $P'$ into the $P$ stack, and push a pointer to the
next token after $C$ into the $F$ stack.

Else if $P'=P$, set $F$ to point at the next token after $C$.

\item[Loop Step 6:]
Set $T=T'$,
re-point $C$ to the token after $C$, and iterate the loop.
\end{itemlist}

\clearpage

\appendix

\section{Standard Lexical Program}
\label{STANDARD-LEXICAL-PROGRAM}

\begin{indpar}
\begin{verbatim}
// This file was automatically generated from
// ll_lexeme_standard.lexcc.


begin standard lexical program;

"<ascii-char>" = "<0>-<7F>"  [ASCII Character]

// NON_ASCII_LETTERS, NON_ASCII_COMBINING_
// CHARACTERS, NON_ASCII_CONTROL_CHARACTERS are
// defined in ll_lexeme_non_ascii_characters.h.

"<non-ascii-letter>" = NON_ASCII_LETTERS

"<non-ascii-combining-char>" =
    NON_ASCII_COMBINING_CHARACTERS

"<non-ascii-control-char>" =
    NON_ASCII_CONTROL_CHARACTERS

"<ascii-letter>" = "a-z" | "A-Z";

"<digit>" = "0-9";

"<hex-digit>" = "0-9" | "A-F";

"<non-digit>" = ~ "<digit>";

"<letter>" = "<ascii-letter>"
           | "<non-ascii-letter>"

"<non-ascii-word-char>" =
      "<non-ascii-letter>"
    | "<non-ascii-combining-char>"

// Context sensitive character classifications,
// e.g., classifying ' as a word character if it
// is followed by a letter, cannot be included
// in character pattern definitions, but are
// noted in comments.  They are accounted for
// by separate lexeme table entries below.

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@"
              | "#" | "$" | "%" | "^" | "&"
              | "=" | "|" | ">" | "_" | "!"
              | "?" | ":";
              //
              // Also . not followed by a digit
              //      / not surrounded by digits
              //        or followed by /
              //      < not beginning escaped
              //        hex character

"<non-slash-char>" = ~ "/";

"<separator-char>" = "(" | ")" | "[" | "]"
                   | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter

"<misplaced-space-char>" =
        "<CR>" | "<VT>" | "<FF>"

"<ascii-control-char>" = "<0>-<1F>" | "<7F>"

"<control-char>" = "<ascii-control-char>"
                 | "<non-ascii-control-char>"

"<control-char-except-CR-LF>" =
    "<control-char>" & ~ "<CR>" & ~ "<LF>"

"<horizontal-space-char>" = " " | "<HT>";

"<escape-char>" = "A-Z" | "0-9" | "-";


begin main master table;

   // Unrecognized characters or escapes, etc,
   // outside quoted strings are output as
   // lexemes, and can separate other lexemes.
   // If these are treated by post-processing
   // in the same manner as horizontal space,
   // they could be replaced by horizontal space
   // without changing the semantics of the
   // output.
   //
   // Inside quoted strings, unrecognized
   // escapes are treated as erroneous atoms,
   // translated to "", and ignored.  The
   // lexemes output would be the same if they
   // were removed.

   // Whitespace is separated out into 4 types
   // of lexemes:
   //
   //   `space'
   //       single spaces and horizontal tabs
   //   `line break'
   //       linefeeds, carriage returns, form
   //       feeds, and vertical tabs, with at
   //       least one line feed
   //   `misplaced space'
   //       ditto but with no line feed
   //   `comments'
   //       `//' up to just before next line
   //        break, misplaced space, or (pre-
   //        mature) end of file
   //
   "//" call comment;
   "/"  call mark;

   "<horizontal-space-char>"
        call horizontal space;

   "<LF>" call line break;
   "<misplaced-space-char>"
        call misplaced space;

   "<letter>" call word;

   "'<letter>" call word;
   "'" output separator;

  "<" "<digit>"
          match escaped hex char
          require "<non-ascii-letter>"
          call word
     else match escaped hex char
          require "<ascii-char>"
          output ascii escape seq
     else match escaped hex char
          output non letter escape seq
     else keep 1 call mark;
   "<" call mark;

   "<mark-char>" call mark;

   "<digit>" keep 0 call natural number;
             // We keep 0 so natural number can
             // recognize <digit>,<digit> etc.

   ".<digit>" keep 1 call number;
              // We keep 1 so number can recog-
              // nize <digit>,<digit> etc.
   "." call mark;

   "<separator-char>" output separator;

   "," output separator;

   "<Q>" translate to "" call quoted string;

   "<others>" output misplaced char;

   output end of file;

end main master table;


// The below tables are entered from the master
// table with the first zero, one, or two
// characters scanned.


begin comment lexeme table;

   "<LF>" keep 0 return;
   "<misplaced-space-char>" keep 0 return;

   "<others>" accept;

   goto premature end of file;

end comment lexeme table;


begin horizontal space lexeme table;

   "<horizontal-space-char>" accept;

   return;

end horizontal space lexeme table;


begin misplaced space lexeme table;

   "<LF>" goto line break;

   "<misplaced-space-char>" accept;

   return;

end misplaced space lexeme table;


begin line break lexeme table;

   "<LF>" accept;
   "<misplaced-space-char>" accept;

   return;

end line break lexeme table;


begin word lexeme table;

   "<letter>" accept;
   "<non-ascii-combining-char>" accept;

   "'<letter>" accept;

    "<" "<digit>"
              match escaped hex char
              require "<non-ascii-word-char>"
         else keep 0 return;

   return;

end word lexeme table;


begin mark lexeme table;

   "<mark-char>" accept;
   "<non-ascii-combining-char>" accept;

   ".<digit>" keep 0 return;
   "." accept;

   "//" keep 0 return;
   "/" accept;

    "<" "<digit>"
          match escaped hex char
          require "<non-ascii-combining-char>"
      else
          match escaped hex char
          keep 0 return;
      else
          keep 1;
    "<" accept;

   return;

end mark lexeme table;


begin natural number lexeme table;


   // In order to recognize , and / surrounded
   // by digits as number atoms, entries to this
   // table upon recognizing "X<digit>" must do
   // a `keep 1' so the digit will be left to be
   // recognized by <digit>/<digit> etc.

   // Alternatively we could have a separate
   // table for the state where the last atom
   // ended with a digit.

   "<digit>:<digit>" keep 2 goto number;
   "<digit>/<digit>" keep 2 goto number;
   "<digit>,<digit>" keep 2 goto number;
   "<digit>" accept;

   ".<digit>" keep 1 goto number;

   return;

end natural number lexeme table;


begin number lexeme table;

   // See note on , and / in `natural number'
   // table above.

   "<digit>:<digit>" keep 2;
   "<digit>/<digit>" keep 2;
   "<digit>,<digit>" keep 2;
   "<digit>" accept;

   ".<digit>" keep 1;

   return;

end number lexeme table;


begin quoted string lexeme table;

    "<Q>" translate to "" return;
            // End quoted string.

    "<" match escaped char
        else match unrecognized escape seq
             error unrecognized escape seq
             translate to ""
        else accept;

    "<LF>"
        keep 0 goto premature end of line;

    "<CR><LF>"
        keep 0 goto premature end of line;
    "<CR>"
        error misplaced control char
        translate to "";

    "<control-char-except-CR-LF>"
        error misplaced control char
        translate to "";

    "<others>" accept;

    goto premature end of file;

end quoted string lexeme table;


begin escaped char atom table;

    "<" "ACK" ">" translate to "<ACK>";
    "<" "BEL" ">" translate to "<BEL>";
    "<" "BS" ">" translate to "<BS>";
    "<" "CAN" ">" translate to "<CAN>";
    "<" "CR" ">" translate to "<CR>";
    "<" "DC1" ">" translate to "<DC1>";
    "<" "DC2" ">" translate to "<DC2>";
    "<" "DC3" ">" translate to "<DC3>";
    "<" "DC4" ">" translate to "<DC4>";
    "<" "DEL" ">" translate to "<DEL>";
    "<" "DLE" ">" translate to "<DLE>";
    "<" "EM" ">" translate to "<EM>";
    "<" "ENQ" ">" translate to "<ENQ>";
    "<" "EOT" ">" translate to "<EOT>";
    "<" "ESC" ">" translate to "<ESC>";
    "<" "ETB" ">" translate to "<ETB>";
    "<" "ETX" ">" translate to "<ETX>";
    "<" "FF" ">" translate to "<FF>";
    "<" "FS" ">" translate to "<FS>";
    "<" "GS" ">" translate to "<GS>";
    "<" "HT" ">" translate to "<HT>";
    "<" "LF" ">" translate to "<LF>";
    "<" "NAK" ">" translate to "<NAK>";
    "<" "NL" ">" translate to "<NL>";
    "<" "NUL" ">" translate to "<NUL>";
    "<" "Q" ">" translate to "<Q>";
    "<" "RS" ">" translate to "<RS>";
    "<" "SI" ">" translate to "<SI>";
    "<" "SO" ">" translate to "<SO>";
    "<" "SOH" ">" translate to "<SOH>";
    "<" "SP" ">" translate to "<SP>";
    "<" "STX" ">" translate to "<STX>";
    "<" "SUB" ">" translate to "<SUB>";
    "<" "SYN" ">" translate to "<SYN>";
    "<" "US" ">" translate to "<US>";
    "<" "VT" ">" translate to "<VT>";

    "<" "<digit>" match escaped hex char
            else fail;

    fail;

end escaped char atom table;


begin escaped hex char atom table;

    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>"
       "<hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>"
       "<hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit><hex-digit>" ">"
              translate hex 1 1;
    "<" "<digit>" ">" translate hex 1 1;

    fail;

end escaped hex char atom table;


begin unrecognized escape seq atom table;

    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char><escape-char>" ">";
    "<" "<escape-char><escape-char>"
        "<escape-char>" ">";
    "<" "<escape-char><escape-char>" ">";
    "<" "<escape-char>" ">";

    fail;

end unrecognized escape seq atom table;


begin premature end of line master table;

    output premature end of line goto main;

end premature end of line master table;


begin premature end of file master table;

    output premature end of file goto main;

end premature end of file master table;


end standard lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{Alternate Lexical Program}
\label{ALTERNATE-LEXICAL-PROGRAM}

This \key{alternate lexical scheme} is the original version
of the standard lexical scheme defined on
\pagref{LEXEME-PROGRAM-LEXEMES}.  The main difference is
that the character sequence
\begin{center}
\TT{(AB,CD+E,)}
\end{center}
scans as the 4 lexemes
\begin{center}
\TT{( AB,CD+E , )}
\end{center}
in the standard scheme, and as the 8 lexemes
\begin{center}
\TT{( AB , CD + E , )}
\end{center}
in this alternate scheme.  That is, in the alternate scheme
word lexemes can only contain letters, mark lexemes can only
contain marks, separator lexemes can only contain separators,
and so forth.  Special exceptions are made for period followed
by a digit, comma surrounded by digits, and so forth.

The syntax equations for the alternative lexical scheme and
the lexical program for that scheme are:

\begin{indpar}
\emkey{lexeme} ::= {\em word}
               $|$ {\em numeric}
               $|$ {\em mark}
	       $|$ {\em separator}
	       $|$ {\em quoted-string}
	       $|$ {\em comment}
\\[0.3ex]
\emkey{word} :::= {\em word-prefix-character}\QMARK{}
                 {\em word-character}\PLUS{}
\\[0.3ex]
\emkey{numeric} :::= {\em numeric-character}\PLUS{}
\\[0.3ex]
\emkey{natural-number} :::= {\em digit}\PLUS{}
\\[0.3ex]
\emkey{non-natural-numeric} ::= {\em numeric} except {\em natural-number}
\\[0.3ex]
\emkey{mark} :::= {\em mark-character}\PLUS{}
\\[0.3ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{comment} :::= \TT{//}{\em comment-character}\STAR{}
\\[0.3ex]
\emkey{separator} ::= {\em separator-character} except \TT{|} or \TT{:}
                  $|$ \TT{|}\PLUS{}
                  $|$ \TT{:}\PLUS{}
\\[1ex]
\emkey{word-prefix-character} ::= \TT{.}
	\begin{tabular}[t]{@{}l@{}}
	followed by a {\em letter} \\
	and \underline{not} preceded by a {\em mark-character}
	\end{tabular}
\\[0.3ex]
\emkey{word-character}
	::= {\em letter}
	$|$ \TT{'} followed by a letter
\\[0.3ex]
\emkey{letter} ::= {\em lower-case-letter} $|$ {\em upper-case-letter}
\\[0.3ex]
\emkey{lower-case-letter} ::=
                               \TT{a}%
			    $|$\TT{b}%
			    $|$\TT{c}%
			    $|$\TT{d}%
			    $|$\TT{e}%
			    $|$\TT{f}%
			    $|$\TT{g}%
			    $|$\TT{h}%
			    $|$\TT{i}%
			    $|$\TT{j}%
			    $|$\TT{k}%
			    $|$\TT{l}%
			    $|$\TT{m}%
			    $|$\TT{n}%
			    $|$\TT{o}%
			    $|$\TT{p}%
			    $|$\TT{q}%
			    $|$\TT{r}%
			    $|$\TT{s}%
			    $|$\TT{t}%
			    $|$\TT{u}%
			    $|$\TT{v}%
			    $|$\TT{w}%
			    $|$\TT{x}%
			    $|$\TT{y}%
			    $|$\TT{z}
\\[0.3ex]
\emkey{upper-case-letter} ::=
                               \TT{A}%
			    $|$\TT{B}%
			    $|$\TT{C}%
			    $|$\TT{D}%
			    $|$\TT{E}%
			    $|$\TT{F}%
			    $|$\TT{G}%
			    $|$\TT{H}%
			    $|$\TT{I}%
			    $|$\TT{J}%
			    $|$\TT{K}%
			    $|$\TT{L}%
			    $|$\TT{M}%
			    $|$\TT{N}%
			    $|$\TT{O}%
			    $|$\TT{P}%
			    $|$\TT{Q}%
			    $|$\TT{R}%
			    $|$\TT{S}%
			    $|$\TT{T}%
			    $|$\TT{U}%
			    $|$\TT{V}%
			    $|$\TT{W}%
			    $|$\TT{X}%
			    $|$\TT{Y}%
			    $|$\TT{Z}
\\[0.3ex]
\emkey{mark-character}
	\begin{tabular}[t]{@{}rl@{}}
	::= & \TT{+}%
        $|$\TT{-}%
        $|$\TT{*}%
        $|$\TT{/}%
        $|$\TT{\textbackslash}%
        $|$\TT{\textasciitilde}%
        $|$\TT{@}%
        $|$\TT{\#}%
        $|$\TT{\$}%
        $|$\TT{\%}%
        $|$\TT{\textasciicircum}%
        $|$\TT{\&}%
        $|$\TT{=}%
        $|$\TT{|}%
        $|$\TT{<}%
        $|$\TT{>}%
        $|$\TT{\_}%
        $|$\TT{!}%
        $|$\TT{?} \\
        $|$ & \TT{.} \begin{tabular}[t]{@{}l@{}}
	             not surrounded by {\em digits} \\
		     and either preceded by a {\em mark-character} \\
		     or \underline{not} followed by a {\em letter} \\
		     \end{tabular} \\
        $|$ & \TT{/} \begin{tabular}[t]{@{}l@{}}
	             not surrounded by {\em digits} \\
		     or followed by a \TT{/} \\
		     \end{tabular} \\
	\end{tabular}
\\[0.3ex]
\emkey{separator-character}
	\begin{tabular}[t]{@{}rl@{}}
	::= & \TT{(}
	$|$ \TT{)}
	$|$ \TT{[}
	$|$ \TT{]}
	$|$ \TT{\{}
	$|$ \TT{\}}
	$|$ \TT{;}
	$|$ \TT{`}
	$|$ \TT{|} \\
	$|$ & \TT{,} not surrounded by {\em digits} \\
	$|$ & \TT{:} not surrounded by {\em digits} \\
	$|$ & \TT{'} not followed by a letter \\
	\end{tabular}
\\[0.3ex]
\emkey{numeric-character}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em digit} \\
	$|$ & \TT{.} surrounded by {\em digits} \\
	$|$ & \TT{,} surrounded by {\em digits} \\
	$|$ & \TT{:} surrounded by {\em digits} \\
	$|$ & \TT{/} surrounded by {\em digits} \\
	\end{tabular}
\\[0.3ex]
\emkey{digit} ::= \TT{0}%
	      $|$\TT{1}%
	      $|$\TT{2}%
	      $|$\TT{3}%
	      $|$\TT{4}%
	      $|$\TT{5}%
	      $|$\TT{6}%
	      $|$\TT{7}%
	      $|$\TT{8}%
	      $|$\TT{9} 
\\[0.3ex]
\emkey{character-representative}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{graphic-character} ::= character than makes a mark on paper
\\[0.3ex]
\emkey{special-character-representative} ::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[0.3ex]
\emkey{comment-character}
    ::= {\em graphic-character}
    $|$ {\em single-space-character}
    $|$ {\em horizontal-tab}

\end{indpar}

\begin{indpar}
\begin{verbatim}
// This lexical analyzer was the original
// layered language standard lexical analyzer,
// but was replaced in that role.

// This file was automatically generated from
// ll_lexeme_alternate.lexcc.


begin alternate lexical program;

"<ascii-char>" = "<0>-<7F>"  [ASCII Character]

// NON_ASCII_LETTERS, NON_ASCII_COMBINING_
// CHARACTERS, NON_ASCII_CONTROL_CHARACTERS are
// defined in ll_lexeme_non_ascii_characters.h.

"<non-ascii-letter>" = NON_ASCII_LETTERS

"<non-ascii-combining-char>" =
    NON_ASCII_COMBINING_CHARACTERS

"<non-ascii-control-char>" =
    NON_ASCII_CONTROL_CHARACTERS

"<ascii-letter>" = "a-z" | "A-Z";

"<digit>" = "0-9";

"<hex-digit>" = "0-9" | "A-F";

"<non-digit>" = ~ "<digit>";

"<letter>" = "<ascii-letter>"
           | "<non-ascii-letter>"

"<non-ascii-word-char>" =
      "<non-ascii-letter>"
    | "<non-ascii-combining-char>"

// Context sensitive character classifications,
// e.g., classifying ' as a word character if it
// is followed by a letter, cannot be included
// in character pattern definitions, but are
// noted in comments.  They are accounted for
// by separate lexeme table entries below.

"<non-letter>" = ~ "<letter>";

"<mark-char>" = "+" | "-" | "*" | "~" | "@"
              | "#" | "$" | "%" | "^" | "&"
              | "=" | "<" | ">" | "_" | "!"
	      | "?" ;
              //
              // Also . not surrounded by digits
	      //        and not both followed by
	      //        a letter and preceded
	      //        by a non-mark character
              //      / not surrounded by digits
              //        or followed by /

"<non-slash-char>" = ~ "/";

"<separator-char>" = "(" | ")" | "[" | "]"
                   | "{" | "}" | ";" | "`";
              //
              // Also , not surrounded by digits
              //      ' not followed by a letter
	      //        or a digit
	      //      | (possibly repeated)
	      //      : (possibly repeated)

"<misplaced-space-char>" =
        "<CR>" | "<VT>" | "<FF>"

"<ascii-control-char>" = "<0>-<1F>" | "<7F>"

"<control-char>" = "<ascii-control-char>"
                 | "<non-ascii-control-char>"

"<control-char-except-CR-LF>" =
    "<control-char>" & ~ "<CR>" & ~ "<LF>"

"<horizontal-space-char>" = " " | "<HT>";

"<escape-char>" = "A-Z" | "0-9" | "-";


begin main master table;

   // Unrecognized characters or escapes, etc,
   // outside quoted strings are output as
   // lexemes, and can separate other lexemes.
   // If these are treated by post-processing
   // in the same manner as horizontal space,
   // they could be replaced by horizontal space
   // without changing the semantics of the
   // output.
   //
   // Inside quoted strings, unrecognized char-
   // acter representatives, such as unrecog-
   // nized escapes, are treated as erroneous
   // atoms and translated to "<UUC>".

   // Whitespace is separated out into 4 types
   // of lexemes:
   //
   //   `space'
   //       single spaces and horizontal tabs
   //   `line break'
   //       linefeeds, carriage returns, form
   //       feeds, and vertical tabs, with at
   //       least one line feed
   //   `misplaced space'
   //       ditto but with no line feed
   //   `comments'
   //       `//' up to just before next line
   //        break, misplaced space, or (pre-
   //        mature) end of file
   //
   "//" call comment;
   "/"  call mark;

   "<horizontal-space-char>"
        call horizontal space;

   "<LF>" call line break;
   "<misplaced-space-char>"
        call misplaced space;

   "<letter>" call word;

   "'<letter>" call word;
   "'<digit>" keep 1 call number;
   "'" output separator;

   "<mark-char>" call mark;

   "<digit>" keep 0 call natural number;
             // We keep 0 so natural number can
             // recognize <digit>,<digit> etc.

   ".<letter>" call word;
   "." call mark;

   "<separator-char>" output separator;

   ":<repeat>" output separator;
   "|<repeat>" output separator;

   "," output separator;

   "<Q>" translate to "" call quoted string;

   "<others>" output misplaced char;

   output end of file;

end main master table;


// The below tables are entered from the master
// table with the first zero, one, or two
// characters scanned.


begin comment lexeme table;

   "<LF>" keep 0 return;
   "<misplaced-space-char>" keep 0 return;

   "<others>" accept;

   goto premature end of file;

end comment lexeme table;


begin horizontal space lexeme table;

   "<horizontal-space-char>" accept;

   return;

end horizontal space lexeme table;


begin misplaced space lexeme table;

   "<LF>" goto line break;

   "<misplaced-space-char>" accept;

   return;

end misplaced space lexeme table;


begin line break lexeme table;

   "<LF>" accept;
   "<misplaced-space-char>" accept;

   return;

end line break lexeme table;


begin word lexeme table;

   "<letter>" accept;
   "<non-ascii-combining-char>" accept;

   "'<letter>" accept;

   return;

end word lexeme table;


begin mark lexeme table;

   "<mark-char>" accept;
   "." accept;
   "<non-ascii-combining-char>" accept;

   "//" keep 0 return;
   "/" accept;

   return;

end mark lexeme table;


begin natural number lexeme table;


   // In order to recognize X (e.g., : or /)
   // surrounded by digits as number atoms,
   // entries to this table upon recognizing
   // "<digit>X<digit>" must do a `keep 2' so
   // the last digit will be left to be
   // recognized by <digit>Y<digit> etc.

   // Alternatively we could have a separate
   // table for the state where the last atom
   // ended with a digit.

   "<digit>.<digit>" keep 2 goto number;
   "<digit>:<digit>" keep 2 goto number;
   "<digit>/<digit>" keep 2 goto number;
   "<digit>,<digit>" keep 2 goto number;
   "<digit>" accept;

   "'<digit>" keep 1 goto number;

   return;

end natural number lexeme table;


begin number lexeme table;

   // See note about `keep 2' in natural number
   // table above.

   "<digit>.<digit>" keep 2;
   "<digit>:<digit>" keep 2;
   "<digit>/<digit>" keep 2;
   "<digit>,<digit>" keep 2;
   "<digit>" accept;

   "'<digit>" keep 1;

   return;

end number lexeme table;


begin quoted string lexeme table;

    "<Q>" translate to "" return;
            // End quoted string.

    "<" match escaped char
        else match unrecognized escape seq
             error unrecognized escape seq
             translate to "<UUC>"
        else accept;

    "<LF>"
        keep 0 goto premature end of line;

    "<CR><LF>"
        keep 0 goto premature end of line;
    "<CR>"
        error misplaced control char
        translate to "<UUC>";

    "<control-char-except-CR-LF>"
        error misplaced control char
        translate to "<UUC>";

    "<others>" accept;

    goto premature end of file;

end quoted string lexeme table;


begin escaped char atom table;

    "<" "ACK" ">" translate to "<ACK>";
    "<" "BEL" ">" translate to "<BEL>";
    "<" "BS" ">" translate to "<BS>";
    "<" "CAN" ">" translate to "<CAN>";
    "<" "CR" ">" translate to "<CR>";
    "<" "DC1" ">" translate to "<DC1>";
    "<" "DC2" ">" translate to "<DC2>";
    "<" "DC3" ">" translate to "<DC3>";
    "<" "DC4" ">" translate to "<DC4>";
    "<" "DEL" ">" translate to "<DEL>";
    "<" "DLE" ">" translate to "<DLE>";
    "<" "EM" ">" translate to "<EM>";
    "<" "ENQ" ">" translate to "<ENQ>";
    "<" "EOT" ">" translate to "<EOT>";
    "<" "ESC" ">" translate to "<ESC>";
    "<" "ETB" ">" translate to "<ETB>";
    "<" "ETX" ">" translate to "<ETX>";
    "<" "FF" ">" translate to "<FF>";
    "<" "FS" ">" translate to "<FS>";
    "<" "GS" ">" translate to "<GS>";
    "<" "HT" ">" translate to "<HT>";
    "<" "LF" ">" translate to "<LF>";
    "<" "NAK" ">" translate to "<NAK>";
    "<" "NL" ">" translate to "<NL>";
    "<" "NUL" ">" translate to "<NUL>";
    "<" "Q" ">" translate to "<Q>";
    "<" "RS" ">" translate to "<RS>";
    "<" "SI" ">" translate to "<SI>";
    "<" "SO" ">" translate to "<SO>";
    "<" "SOH" ">" translate to "<SOH>";
    "<" "SP" ">" translate to "<SP>";
    "<" "STX" ">" translate to "<STX>";
    "<" "SUB" ">" translate to "<SUB>";
    "<" "SYN" ">" translate to "<SYN>";
    "<" "US" ">" translate to "<US>";
    "<" "VT" ">" translate to "<VT>";

    "<" "<digit>" match escaped hex char
            else fail;

    fail;

end escaped char atom table;


begin escaped hex char atom table;

    "<" "<digit>" ">" translate hex 1 1;
    "<" "<digit><hex-digit><repeat>" ">"
              translate hex 1 1;

    fail;

end escaped hex char atom table;


begin unrecognized escape seq atom table;

    "<" "<escape-char><repeat>" ">";

    fail;

end unrecognized escape seq atom table;


begin premature end of line master table;

    output premature end of line goto main;

end premature end of line master table;


begin premature end of file master table;

    output premature end of file goto main;

end premature end of file master table;


end alternate lexical program;
\end{verbatim}
\end{indpar}

\newpage

\section{C++ Lexical Program}
\label{C++-LEXICAL-PROGRAM}

\begin{indpar}\begin{verbatim}
// This file was automatically generated from
// ll_lexeme_c++.lexcc.

begin c++ lexical program;

// Before this lexical program is used the input
// should be preprocessed to
//
//    (1) Replace trigraph sequences.
//    (2) Eliminate carriage-returns next to a
//        newline (others become misplaced)
//    (3) Eliminate sequences of the form:
//        backslash newline
//
// After this lexical program is used the output
// should be post-processed to
//
//    (4) Perform C/C++ macro preprocessing
//        (macro expansion).
//    (5) Delete whitespace and newlines.
//    (6) Concatenate adjacent quoted strings
//        of the same character type (ordinary,
//        u, U, or L).

"<digit>" = "0-9";

"<non-zero-digit>" = "1-9";

"<oct-digit>" = "0-7";

"<hex-digit>" = "0-9" | "a-f" | "A-F";

"<ascii-letter>" = "a-z" | "A-Z";

"<letter>" = "<ascii-letter>"
           | "<non-ascii-letter>

// <non-ascii-letter> ::= UNICODE character in
// one of the code ranges designated in
// NON_ASCII_LETTERS in ll_lexeme_non_ascii_
// characters.h.

// <combining-char> ::= UNICODE character in
// one of the code ranges designated in
// NON_ASCII_COMBINING_CHARACTERS in ll_lexeme_
// non_ascii_characters.h.

// Universal characters are only permitted in
// identifiers, character literals, and string
// literals.  In identifiers they must represent
// non-ASCII-letters or non-ASCII combining
// characters, and the latter cannot be the
// initial character of an identifier.

"<identifier-non-digit>" = "_" | "<letter>";

"<identifier-char>" = "<identifier-non-digit>"
                    | "<digit>"
                    | "<combining_char>"

"<non-ascii-identifier-char>" =
          "<non-ascii-letter>"
        | "<combining_char>"

// Because `u', `U', or `L' can start a char-
// acter or string literal, we must define:
//
"<u_U_L>" = "u" | "U" | "L";
"<identifier-non-literal>" =
          "<identifier-non-digit>"
        & ~ "<u_U_L>";

"<whitespace-char>" =
    " " | "<HT>" | "<VT>" | "<FF>";
    // newline is treated separately


// The following can begin an operator or punc-
// tuation mark.
//
// / not followed by / or * and . not followed
// by <digit> are handled separately.
//
"<op-char>" = "#" | "<" | ">" | ":" | "%" |
            | "?" | "+" | "-" | "*" | "="
            | "^" | "&" | "|" | "~" | "!" | ","
            | "(" | ")" | "[" | "]" | "{" | "}"
            | ";";

"<sign>" = "+" | "-" ;

"<u_U>" = "u" | "U" ;

"<ascii-char>" = "<0>-<7F>"  [ASCII Character]


// C/C++ preprocessing is hereafter abbreviated
// as `pp'.

// Alternative operators that are not identi-
// fiers are translated.  E.g., <: becomes [ in
// the lexeme translation.

// C++ punctuation are treated as `operators'.

// Pp numbers are divided into 5 categories
// (note that a `suffix' is an identifier):
//
//      decimal integer
//          nothing but digits not beginning
//          with 0, with an optional suffix
//      octal integer
//          nothing but octal digits beginning
//          with 0, with an optional suffix
//      hexadecimal integer
//          nothing but hexadecimal digits
//          refaced by 0x or 0X, with an
//          optional suffix
//      float
//          legal floating point #'s, with an
//          optional suffix
//      pp number
//          all other pp numbers

// Because of pp control lines, lexical scanning
// is slightly context dependent.  There are
// several contexts, each corresponding to a
// different master table:
//
//    initial master
//        Used in line beginning situations to
//        recognize the # token that introduces
//        a pp control line.
//    pp beginning master
//        Used to scan the beginning of a pp
//        control line after the # has been
//        scanned but before anything else is
//        scanned.
//    pp include master
//        Used to scan the pp-header token in a
//        #include line after #include has been
//        scanned.
//    normal master
//        Used to scan a non pp control line or
//        the rest of a pp control line after
//        any #include header.
//
// The whitespace lexeme types are:
//
//    newline
//        a single <NL>
//    horizontal-space
//        sequence of "<whitespace-char>"s
//        (excludes <NL>'s)
//    comment
//        "/*" comment (including /* and */)
//        "//" comment (including // but not
//                      ending newline)
//
// This allows line feeds to be used to end pp
// control lines.


// Characters that are not part of legal lexemes
// and which are outside character literal ''s
// and and quoted string literal ""s are made
// into error lexemes that can separate other
// lexemes in exactly the same way that white-
// space can.
//
// Note that ## cannot be used to move charac-
// ters inside a character or string literal ''
// or "".  Also, we do NOT allow ## to append a
// combining character to another character.
// Therefore ## cannot be used to create a legal
// pp token by concatenating a legal pp token
// with a stray character that is not part of a
// legal pp token.  Thus we can treat all stay
// characters as errors, instead of making them
// into pp tokens.

// Characters that are part of erroneous atoms
// INSIDE character literal ''s or quoted string
// ""s are announced as part of an erroneous
// atom which is translated to "" and ignored as
// if it did not appear at all in the input.

begin initial master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur INSIDE
    // a pp directive line.
    //
    "/*" call "/*" comment;

    "#" output operator goto pp beginning;
    "##" output operator goto normal;

    "%:" translate to "#" output operator
         goto pp beginning;
    "%:%:" translate to "##" output operator
           goto normal;

    goto normal;

end initial master table;


begin pp beginning master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur inside
    // pp directive line.
    //
    "/*" call "/*" comment;

    // "include" identifier must be followed by
    // one of the following for a header to be
    // recognized:
    //
    //     <whitespace-char>
    //     /* comment
    //     <...> header
    //     "..." header
    //
    "include<whitespace-char>"
        keep 7 output identifier
        goto pp include;
    "include/"
        keep 7 output identifier
        goto pp include;
    "include<"
        keep 7 output identifier
        goto pp include;
    "include<Q>"
        keep 7 output identifier
        goto pp include;

    goto normal;

end pp beginning master table;

begin pp include master table;

    "<whitespace-char>" call whitespace;

    // We only need handle /*...*/ comments
    // because only these can occur inside
    // pp directive line.
    //
    "/*" call "/*" comment;

    "<" translate to ""
        goto bracketed header name;

    "<Q>" translate to ""
        goto quoted header name;

    goto normal;

end pp include master table;


begin premature newline master table;

    output premature newline goto normal;

end premature newline master table;


begin premature end of file master table;

    output premature end of file goto initial;

end premature end of file master table;

begin whitespace lexeme table;

    "<whitespace-char>" accept;

    return;

end whitespace lexeme table;


begin "/*" comment lexeme table;

    "*/" return;
    "*" accept;

    "<others>" accept;

    translate_to "*/"
    goto premature end of file;

end "/*" comment lexeme table;


begin "//" comment lexeme table;

    "<NL>" keep 0 return;

    "<others>" accept;

    goto premature end of file;

end "//" comment lexeme table;


begin bracketed header name lexeme table;

    ">" translate to "" goto normal;

    "<NL>"
        keep 0 goto premature newline;

    "<others>" accept;

    goto premature end of file;

end bracketed header name lexeme table;


// Quoted header names are not the same as
// quoted strings, and cannot have escape
// sequences.
//
begin quoted header name lexeme table;

    "<Q>" translate to "" goto normal;

    "<NL>"
        keep 0 goto premature newline;

    "<others>" accept;

    goto premature end of file;

end quoted header name lexeme table;


begin normal master table;

    "<whitespace-char>" call whitespace;

    "/*" call "/*" comment;
    "//" call "//" comment;
    "/" match operator output operator
        // match should always succeed

    "<op-char>"
        match operator output operator
        // match should always succeed

    "<identifier-non-literal>"
        call identifier;
        // Also see "u/U/L..." etc. below.

    "u'" translate to ""
         output u char literal
         call char literal;
    "u<Q>" translate to ""
           output u string literal
           call string literal;
    "u"  call identifier;

    "U'" translate to ""
         output U char literal
         call char literal;
    "U<Q>" translate to ""
           output U string literal
           call string literal;
    "U"  call identifier;

    "L'" translate to ""
         output L char literal
         call char literal;
    "L<Q>" translate to ""
           output L string literal
           call string literal;
    "L"  call identifier;

    "\<u_U>" match universal char
             require <non-ascii-letter>
             call identifier
        else match universal char
             require "<ascii-char>"
             output ascii universal char
        else match universal char
             output misplaced universal char
        else match short universal char
             output universal char
             // Match should always succeed.
    "\" output misplaced char

    "<non-zero-digit>" call decimal integer;

    "0x" call hexadecimal integer;
    "0X" call hexadecimal integer;
    "0" call octal integer;

    ".<digit>" call fraction;
    "." match operator output operator
        // match should always succeed

    "'" translate to ""
        output char literal
        call char literal;

    "<Q>" translate to ""
          output string literal
          call string literal;

    "<NL>" output newline goto initial;

    "<others>" output misplaced char;

    output end of file;

end normal master table;


begin operator atom table;

    "("; ")"; "["; "]"; "{"; "}"; ";"; ","; "?";
    "~";

    "#";
    "##";

    "<:" translate to "[";
    "<%"; translate to "{";
    "<<="; "<<"; "<";

    ">>="; ">>"; ">";

    ":>" translate to "]";
    "::"; ":";

    "%>" translate to "}";
    "%:%:" translate to "##";
    "%:" translate to "#";
    "%="; "%";

    "..."; ".*"; ".";

    "++"; "+="; "+";

    "->*"; "->"; "--"; "-="; "-";

    "*="; "*";
    "/="; "/";
    "^="; "^";
    "!="; "!";
    "=="; "=";

    "&&"; "&="; "&";

    "||"; "|="; "|";

    fail;

end operator atom table;


begin identifier lexeme table;

    "<identifier-non-digit>" accept;
    "<digit>" accept;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
        else keep 0 return

    return;

end identifier lexeme table;

"<e_E> = "e" | "E";
"<identifier-non-digit-except-eE>" =
    "<identifier-non-digit>" & ~ "<e_E>";


begin decimal integer lexeme table;

    "<digit>" accept;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end decimal integer lexeme table;


begin octal integer lexeme table;

    "<oct-digit>" accept;

    "8" goto float integer;
    "9" goto float integer;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end octal integer lexeme table;

"<identifier-non-hex-digit>" =
    "<identifier-non-digit>" & ~ "<hex-digit>";


begin hexadecimal integer lexeme table;

    "<hex-digit>" accept;

    "<identifier-non-hex-digit>" goto suffix;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto suffix
        else keep 0 return

    return;

end hexadecimal integer lexeme table;


// integer began with 0 and then included a
// non-octal digit.
//
begin float integer lexeme table;

    "<digit>" accept;

    "." goto fraction;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<e_E><digit>" goto exponent;
    "<identifier-non-digit>" goto pp number;

    "\"      match universal char
             require "<non-ascii-letter>"
             goto pp_number
        else keep 0 goto pp number

    goto pp number;

end float integer lexeme table;


// Come here to process suffix at end of integer
// or float lexeme.  Similar to identifier but
// changes lexeme type to pp number when certain
// character sequences are encountered.
//
begin suffix sublexeme table;

    "<identifier-non-digit-except-eE>" accept;
    "<digit>" accept;

    "<e_E><sign>" goto pp number;
    "<e_E>" accept;

    "." goto pp number;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
             else keep 0 return;

    return;

end suffix sublexeme table;

begin pp number lexeme table;

    "<identifier-non-digit-except-eE>" accept;
    "<digit>" accept;

    "<e_E><sign>" accept;
    "<e_E>" accept;

    "." accept;

    "\<u_U>" match universal char
             require
                 "<non-ascii-identifier-char>"
             else keep 0 return;

    return;

end pp number lexeme table;


begin fraction lexeme table;

    "<digit>" accept;

    "." goto pp number;

    "<e_E><sign><digit>" goto exponent;
    "<e_E><digit>" goto exponent;
    "<e_E><sign>" goto pp number;
    "<identifier-non-digit>" goto suffix;

    "\<u_U>" match universal char
             require "<non-ascii-letter>"
             goto suffix
             else keep 0 return;

    return;

end fraction lexeme table;


begin exponent lexeme table;

    "<digit>" accept;

    "." goto pp number;

    "<e_E><sign>" goto pp number;
    "<identifier-non-digit>" goto suffix;

    "\<u_U>" match universal char
             require "<non-ascii-letter>"
             goto suffix
             else keep 0 return;

    return;

end exponent lexeme table;


begin char literal sublexeme table;

    "'" translate to "" return;

    "<NL>" keep 0 goto premature newline

    "\" match escaped char
        // match should always succeed

    "<others>" accept

    goto premature end of file

end char literal sublexeme table;


begin string literal sublexeme table;

    "<Q>" translate to "" return;

    "<NL>" keep 0 goto premature newline

    "\" match escaped char
        // match should always succeed

    "<others>" accept

    goto premature end of file

end string literal sublexeme table;


// This atom table is used when the next atom
// begins with \ and is in a character or string
// literal.  This atom table always succeeds,
// but may produce an erroneous atom with ""
// translation.
//
// We allow only a maximum of 8 hexadecimal
// digits after \x; 9 digits is an error.  The
// C++ standard permits any number of hexa-
// decimal digits.
//
begin escaped char atom table;

    "\n" translate to "<NL>";

    "\t" translate to "<HT>";

    "\v" translate to "<VT>";

    "\b" translate to "<BS>";

    "\r" translate to "<CR>";

    "\f" translate to "<FF>";

    "\a" translate to "<BEL>";

    "\\" translate to "\";

    "\?" translate to "?";

    "\<Q>" translate to "<Q>";

    "\'" translate to "'";

    "\<oct-digit><oct-digit><oct-digit>"
        translate oct 1 0;
    "\<oct-digit><oct-digit>"
        translate oct 1 0;
    "\<oct-digit>"
        translate oct 1 0;

    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        error too long hex escape
        translate to "";
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
      "<hex-digit>"
        translate hex 2 0;
    "\x<hex-digit><hex-digit>"
        translate hex 2 0;
    "\x<hex-digit>"
        translate hex 2 0;
    "\x" error ill formed escape
        translate to "";

    "\<u_U>" match universal char
        else match short universal char
             error short universal char
             translate to "";
             // This should always succeed

"\<NL>" keep 1
        error ill formed escape
        translate to "";

"\<others>" error ill formed escape
           translate to "";

"\" error ill formed escape
    translate to "";
    // In case \ followed by end of file

// This table should always succeed.

end escaped char atom table;


// This atom table is called when the next
// atom begins with \U or \u.  If the atom
// has the correct number of hexadecimal
// digits after the \U or \u, it is recognized
// and translated.
//
begin universal char atom table;

    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;

    "\u<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
        translate hex 2 0;

    fail;

end universal char atom table;


// This atom table is called when the next
// atom begins with \U or \u but there are too
// few hexadecimal digits following.  An atom
// is always recognized but is NOT translated.
//
begin short universal char atom table;

    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit><hex-digit>";
    "\U<hex-digit><hex-digit>"
      "<hex-digit>";
    "\U<hex-digit><hex-digit>";
    "\U<hex-digit>";
    "\U";

    "\u<hex-digit><hex-digit>"
      "<hex-digit>";
    "\u<hex-digit><hex-digit>";
    "\u<hex-digit>";
    "\u";

    // The above should always succeed.

end short universal char atom table;


end c++ lexical program;

\end{verbatim}\end{indpar}


\bibliographystyle{plain}
\bibliography{layered-introduction}

\printindex

\end{document}
