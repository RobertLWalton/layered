% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\LSTAR}{L$^\star$}
\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttakey}[1]{\TT{*#1*}\index{#1@{\tt *#1*}}}
\newcommand{\ttamkey}[2]{\TT{*#1*}\index{#1@{\tt *#1*}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{\,\textsuperscript{p\pageref{#1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\TS}{\hspace*{0in}\tt}

\newcommand{\TMP}{\$}			% Compiler Temporary
\newcommand{\ABV}{-{}-{}->}		% Abbreviates
\newcommand{\CNV}{\longrightarrow}	% Converts to

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

October 19, 2018
 
\end{center}

{\small \tableofcontents}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language, which is similar to the C programming language
but differs in the following ways:

\begin{enumerate}

\item
L-Language facilitates isolating non-type-safe code into small inline functions.

\item
All L-Language data types are builtin number types or subtypes of
builtin number types.  All data managed directly by L-Language consists
of single numbers allocated to the stack.

\item
Memory references other than those to single stack allocated numbers
are handled by code
encapsulated in small inline functions written by the programmer.
These memory references
are treated in a manner reminiscent of input/output.
The bodies of these inline functions are not type-safe, but if
there are written correctly, usage of these functions is type-safe.

\item
There is no concept of a memory structure in the L-Language.  There
is a new concept, the `cluster', which is a collection of stack
variables that can be passed to inline functions
and returned from inline functions as a syntactic unit.

\item
The type `\TT{type}' is first class, is a subtype of integers, and
each `\TT{type}' value is assigned
a unique constant small integer value.  Constant
argument values, such as the value of a `\TT{type}' valued
argument, can be used to select overloaded functions.

\item
Most L-Language functions are inline.  Out-of-line functions can be
called using a block syntax that mirrors the overhead involved in
manipulating an argument stack in memory.

\item
L-Language uses a single-assignment style of program structure
to encourage
efficient code that leaves an audit trail for debugging in the stack.
Partial evaluation of expressions and inline code is supported without
compromising debuggability.

\item
L-Language allows code to be compiled at run-time just before
it is run, for extra efficiency.

\item
L-Language allows code to be compiled into the compiler, to support
language enhancements.

\item
L-Language has module structure to manage
multi-file source code in a well-ordered and type-safe manner.


\end{enumerate}


\section{Lexemes}
\label{LEXEMES}

An L-Language source file is a sequence of bytes that is a UTF-8 encoding
of a sequence of UNICODE characters.  This is scanned into a sequence
of \skey{lexeme}s.

Unless otherwise specified, the term `\key{character}' in this
document means a 32-bit UNICODE character.

Lexemes are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes ASCII single space) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} :::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::=
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe}, \\
    and \TT{Pf}; includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{decimal-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em decimal-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment}\label{COMMENT} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

The following is a special virtual lexeme:
\begin{indpar}
\emkey{indent}\label{INDENT} ::=
        virtual lexeme inserted just before the first
	{\em graphic} character on a line
\end{indpar}

\ikey{Indent lexemes}{indent lexeme} have no characters, but
do have an \mkey{indent}{of indent lexeme}, which is the indent of
the graphic character after the indent lexeme.
The \mkey{indent}{of character} of a character is the number
of columns that precede the character in the character's physical line.
Indent lexemes are used to form logical lines and blocks
(\itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break}\label{LINE-BREAK} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::=
    \begin{tabular}[t]{l}
    {\em horizontal-space-character}, other than \\
    ASCII single space
    \end{tabular}
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= {\em vertical-space-character}
	other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::=
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} \\
    or {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::=
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these sequences generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

\begin{boxedfigure}[!p]
\begin{indpar}

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em word} $|$ {\em mark} $|$ {\em number} $|$
	      {\em separator} $|$ {\em quoted-string} $|$ {\em indent} \\
	$|$ & {\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}\label{CHARACTER-REPRESENTATIVE}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em ASCII-single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{number} \begin{tabular}[t]{rl}
    ::= & {\em middle-lexeme} with a {\em digit} before any {\em letter} \\
    $|$ & {\em middle-lexeme} with a {\em digit} immediately after
                               a `\TT{+}' or `\TT{-}' \\
	\end{tabular}
\\[0.5ex]
\emkey{natural-number}\label{NATURAL-NUMBER}
	:::= {\em decimal-digit}\PLUS{} not beginning with \TT{0} $|$ \TT{0}
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme} containing a {\em letter} that is not
                  a {\em number}
\\[0.5ex]
\emkey{mark} :::= {\em middle-lexeme} that is not a {\em word} or
		  {\em number}
\\[0.5ex]
{\em indent} ::= see \pagref{INDENT}
\\[0.5ex]
{\em line-break} ::= see \pagref{LINE-BREAK}
\\[0.5ex]
{\em comment} ::= see \pagref{COMMENT}
\\[0.5ex]
{\em end-of-file} ::= see \pagref{END-OF-FILE}

\end{indpar}
\caption{L-Language Program Lexemes}
\label{L-LANGUAGE-PROGRAM-LEXEMES}
\end{boxedfigure}

The lexemes in a L-Language program are specified in
Figure~\itemref{L-LANGUAGE-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see page \pageref{ILLEGAL-CHARACTERS}
above to account for such characters.

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file}\label{END-OF-FILE}
lexeme that occurs only at the end of a file.

Files are scanned into sequences of lexemes which are then divided
into logical lines as per \itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}.
After each logical line is formed,
{\em indent}, {\em comment},
{\em line-break}, and {\em end-of-file} lexemes are deleted
from the logical line.

\ikey{Quoted string lexemes}{quoted strings!concatenated}
separated by the `\TT{\#}' mark
are glued together if they are in the
same logical line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence" #
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

A \emkey{special-character-representative} can consist of
a UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.

A {\em special-character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.

\section{Logical Lines, Blocks, and Statements}
\label{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}

Each non-blank physical line begins with an {\em indent} lexeme
that is followed by a
lexeme that is not an {\em indent}, {\em line-break}, or
{\em end-of-file}.

Lexemes are organized into \skey{logical line}s.  A logical line
begins immediately after an {\em indent} lexeme, and the
\mkey{indent}{of logical line} of the logical line is the
indent of this {\em indent} lexeme (i.e., the indent of the
first graphic character of the logical line).

A logical line ends with the next {\em indent} lexeme whose indent
is not greater than the indent of the logical line, or with an
{\em end-of-file}.  Thus physical
lines with indent greater than that of the current logical line
are \skey{continuation line}s for that logical line.

A code file is a sequence of `\key{top level}' logical lines that
are required to have indent \TT{0}.

A logical line may end with a \key{block} that is itself a sequence of
logical lines that have indents greater than the indent of the
logical line containing the block.
The block is introduced by a `\TT{:}' at the end
of a physical line.  If the first {\em indent} lexeme after the
`\TT{:}' has an indent that is \underline{not} greater than the indent
of the logical line containing the `\TT{:}', the block is empty.
Otherwise the indent of this {\em indent} lexeme becomes the
\mkey{indent}{of block} of the block and the indent of all the
logical lines in the block.  The first logical line of the block
starts immediately after this {\em indent} lexeme.
The block ends just before the first
logical line with lesser indent than the block indent, or the end of file.
More specifically, the last logical line of the block ends with an
{\em indent} whose indent is less than the block indent, or with an
{\em end-of-file}.

Examples are:
\begin{indpar}\begin{verbatim}
this is a top level logical line ending with a block:
    this is the first line of the block
    this is the
         second line of the block
    this is the third line of the block:
        this is the first line of a subblock
        this is the second line
                of the subblock:
            this is the only line of a sub-subblock
        this is the third line of the subblock
    this is the fourth line
            of the block:
        this is the only line of the second subblock
    this is the fifth line of the block
         and it ends with an empty subblock:
this is the second top level
     logical line
\end{verbatim}\end{indpar}

A warning message is output if two indents that are being compared
differ by more than \TT{0} and
less than \TT{2} columns, in order to better detect
indentation mistakes.

{\em Line-break} lexemes are effectively ignored.  A sequence
of {\em line-break} lexemes is followed by an {\em indent}
or {\em end-of-file} which is not ignored.
Blank physical lines are represented by sequences of
more than one {\em line-break} lexeme, and are effectively
ignored.

A logical line that contains {\em comments}, but no
lexemes other than {\em comments}, {\em line-breaks}, {\em indents}
and a possible {\em end-of-file}, is
a `\key{comment line}', and is ignored.

It is an error to begin non-comment logical lines with
a {\em comment}.
{\em Comments} can be used freely in the middle of or at the
end of any logical line, or at the beginning of a comment line.

It is an error for the first logical line of a file
to have an indent that is greater than \TT{0}, the top level
indent.

It is an error for a block to be in the middle of a logical
line.  This means that the first {\em indent} following the
block must have an indent no greater than that of the logical
line containing the block.

Examples are:
\begin{indpar}\begin{verbatim}
// this is a logical line that is a single comment

// this is a logical line that has two
    // comments

this is a logical line // with a comment
     // and another comment
     with three comments // and a last comment

this is a logical line ending with a block:
     First line of the block
     Second line of the block
// Comment that ends block
// Comment that is in error because
    it begins a logical line that this continues

this is a logical line with a block:
     First line of the block
     Second line of the block
  but the block is in error because it is before
  this continuation of the logical line that contains
  the block

this is a logical line ending with a block:
        First line of the block
        Second line of the block
  // comments that end the block, but are in error,
  // because they continue the logical line
  // containing the block
\end{verbatim}\end{indpar}

After a logical line
has been formed, any {\em indent},
{\em comment}, {\em line-break}, and {\em end-of-file}
lexemes in the logical line
are removed from the logical line.  If the result is
empty, i.e., the logical line is a comment line, it is discarded.
Otherwise the
modified logical line becomes a L-Language `\emkey{statement}'.

Therefore a file is a sequence of top-level statements.

Since a logical line can end with a block that itself consists
of a sequence of logical lines, a statement can end with
a block that itself consists of a sequence of statements.


\section{Names}
\label{NAMES}

A \key{name} is a sequence of lexemes used to name things like
variables and functions.

\begin{indpar}
\emkey{name}\label{NAME} ::=
    {\em initial-name-item} {\em continuing-name-item}\STAR{} \\
\emkey{initial-name-item} ::= {\em name-item} other than {\em natural-number} \\
\emkey{continuing-name-item} ::= {\em name-item} not containing `\TT{.}' \\
\emkey{name-item}\label{NAME-ITEM}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} containing no `\TT{.}' following a character
                     that is not a `\TT{.}' \\
        & [see text about splitting words with embedded `\TT{.}'s] \\
    $|$ & {\em natural-number} \\
    $|$ & {\em quoted-mark} not containing `\TT{.}'s \\
    $|$ & {\em quoted-separator} not containing `\TT{.}'s \\
    \end{tabular} \\
\emkey{quoted-mark} :::= \TT{"} {\em mark} \TT{"} \\
\emkey{quoted-separator} :::= \TT{"} {\em separator} \TT{"}
\end{indpar}

{\em Words} containing embedded `\TT{.}'s are split into
{\em name-items} which can only contain `\TT{.}'s at their beginning.
Thus
\begin{center}
\TT{bills.wife.1.weight..size}
\end{center}
is split into
\begin{center}
\TT{bills~~~.wife~~~.1~~~.weight~~~~..size}
\end{center}
However, `\TT{.1}' is not a legal {\em name-item} and so cannot
be part of a legal {\em name}.

Name items beginning with more than one `\TT{.}' are reserved
for use by systems and compilers (e.g., \TT{..size} in the example).
Name items beginning and ending with `\TT{*}' are
similarly reserved.

Words ending with `\TT{\TMP$n$}', where $n$ is a {\em natural-number}, are
reserved for use by the compiler and may not be used in names by the
L-Language user.  For example, names of the form \TT{T\TMP$n$} are used as
temporary variables introduced during compilation.

Names can be computed at compile time:
see~\itemref{THE-NAME-TYPE}.
One name can be used to abbreviate another:
see~\itemref{ABBREVIATIONS}.
A name may begin with a {\em word} that is a {\em module-abbreviation}
that designates a code module: see~\itemref{MODULES}.

The builtin names in this document are implicitly in the
\TT{"standard"} module whose {\em module-abbreviation} is `\TT{std}'.
See the section on modules (\itemref{MODULES}) for details.
For example the name `\TT{bool}' of the boolean data type is actually a builtin
abbreviation defined by:
\begin{center}
\TT{define abbreviation bool {\ABV} `std bool'}
\end{center}
and the builtin type name proper is `\TT{std bool}' and not `\TT{bool}'.


Similarly the  builtin function such as \TT{round} as used in:
\begin{center} \tt
\begin{tabular}{l}
float$x$ v = \ldots{} \\
float$x$ r = round ( v ) \\
\end{tabular}
\end{center}
actually has the function prototype (\pagref{FUNCTION-PROTOTYPE}):
\begin{center}
{\tt function std float$x$ r = std round ( std float$x$ v )} \\
\end{center}
so its proper name is `\TT{std round}' and not `\TT{round}',
but in this case it is not necessary (or desirable) to make `\TT{round}'
an abbreviation because its module can be implied in a function call
(see `module deficient' on \pagref{MODULE-DEFICIENT}).

\subsection{Kinds of Names}
\label{KINDS-OF-NAMES}

The L-Language uses several kinds of names:

\begin{indpar}
\emkey{module-abbreviation}
	::= \TT{word} not containing any `\TT{.}'s \\
\emkey{type-name}\label{TYPE-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{qualifier-name}\label{QUALIFIER-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{variable-base-name}\label{VARIABLE-BASE-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{variable-name}\label{VARIABLE-NAME}
	::= {\em variable-base-name} {\em member-selector}\STAR{} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript } \\
\emkey{member-name}\label{MEMBER-NAME}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark}
			    or {\em quoted-separator}
			\end{tabular} \\
\emkey{member-subscript} ::= see \pagref{MEMBER-SUBSCRIPT} \\
\emkey{term-name} ::= {\em name} \\
\emkey{function-variable-name} ::=
    \begin{tabular}[t]{@{}p{4in}@{}}
    {\em term-name} $N$ that appears in a {\em function-prototype}
    of the form `{\tt function $N$ = \ldots};
    see \pagref{FUNCTION-VARIABLE-NAME}
    \end{tabular} \\
\emkey{block-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{include-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator}

where
\begin{enumerate}
\item
A {\em qualifier-name} must not be an initial segment
of a {\em type-name}.  See text below.
\item
A {\em qualifier-name} or {\em type-name} must not be an initial segment
of a {\em name} $N$ that might begin a {\em statement} of
the form `{\tt $N$ = \ldots}'.  Examples of such names $N$
are {\em deferred-variables} (\pagref{DEFERRED-VARIABLE})
and {\em function-variable-names} (\pagref{FUNCTION-VARIABLE-NAME}).
See text below.
\label{TYPE-NAME-RULE}
\item
A {\em type-name}, {\em qualifier-name}, {\em variable-base-name},
{\em block-name}, or {\em include-name}
may not begin with the word `\TT{next}' or `\TT{previous}' or
contain the words `\TT{is}', `\TT{as}', `\TT{with}', `\TT{without},
or `\TT{if}'.
\item
{\em Name-items} ending with `\TT{\TMP$n$}',
where $n$ is a {\em natural-number}, are
reserved for use by the compiler.
\item
{\em Name-items} beginning with `\TT{..}' (possibly followed by more
`\TT{.}'s) are reserved
for use by systems and compilers (e.g., `\TT{..size}').
\item
{\em Name-items} beginning \underline{and} ending
with `\TT{*}' are reserved
for use by systems and compilers (e.g., \TT{*UNCHECKED*}).
\end{enumerate}
\end{indpar}

The first two rules are not enforced as such.  Instead the parser
parses statements into abstract syntax trees that contain
sequences of names, without separating the names in each sequence.
Then as a first step in compilation after parsing,
any name sequence that might be of the form
\begin{center}
{\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
\end{center}
is scanned left to right to first remove any {\em qualifier-names}
and then a {\em type-name}, leaving a non-empty {\em variable-name}.
At any point, if several suitable {\em qualifier-names} or
{\em type-names} match the
beginning of the remaining part of the name sequence, the longest
is chosen.  If this process succeeds without backup, the name
sequence is of the above form.  Otherwise it is not -- there is
no backup.  If the process does not succeed, in some
cases the name sequence may still be a single {\em variable-name}
by itself, and in other cases it might be a sequence of one or
more {\em term-names}.
Also the {\em qualifier-name} and {\em type-name}
candidates are those of the current scope (\pagref{SCOPE}).

Name sequences that might be of the above form can only occur at
the beginning of a statement or as a {\em result-variable-declaration}
(\pagref{RESULT-VARIABLE-DECLARATION})
or an {\em argument-declaration} in a {\em function-prototype}
or {\em generic-prototype}
(\pagref{ARGUMENT-DECLARATION}).

In addition, non-empty name sequences
may appear in abstract tree subexpressions of the form
\begin{center}
{\em qualifier-name}\STAR{} {\em type-name}\QMARK{} {\tt (~\ldots{}~)}
\end{center}
and are treated similarly.


\subsection{Abbreviations}
\label{ABBREVIATIONS}


An \key{abbreviation} is a {\em name} that is replaced
by another {\em name}.  There are separate abbreviations for
{\em qualifier-names}, {\em type-names}, {\em variable-base-names},
and {\em member-names}.

Abbreviations are declared by:
\begin{indpar}
\emkey{abbreviation-declaration}\label{ABBREVIATION-DECLARATION} \\
\hspace*{0.5in}\begin{tabular}{@{}rl@{}}
    ::= & \ttkey{define abbreviation}\TT{~}{\em abbreviation}\TT{~}%
          \ttkey{\ABV}\TT{~}{\em abbreviation-replacement} \\
    $|$ & \TT{define abbreviations:} \\
        & {\TS ~~~~}{\em abbreviation}\TT{ \ABV{} }
		  {\em abbreviation-replacement} \\
        & {\TS ~~~~}{\em abbreviation}\TT{ \ABV{} }
		  {\em abbreviation-replacement} \\
        & {\TS ~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
    \end{tabular}
\\[1ex]
\emkey{abbreviation} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\\[1ex]
\emkey{abbreviation-replacement} ::= \\
\hspace*{0.5in}
    {\em expression} that evaluates at compile time to a \TT{name};
    see \itemref{THE-NAME-TYPE}
\end{indpar}

The most common {\em abbreviation-replacement} is a {\em name-constant}:

\begin{indpar}
\emkey{name-constant}
    ::= \TT{`}{\em name-item}\STAR{}\TT{'} \\
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

The only {\em names}
that can be abbreviated are {\em qualifier-names},
{\em type-names}, {\em variable-base-names}, and
{\em member-names}.

If the replacement name of an {\em abbreviation} is a {\em qualifier-name}
in the context of the {\em abbreviation-declaration},
the {\em abbreviation} becomes a {\em qualifier-name}, and
must have they syntax of a {\em qualifier-name}.
Similarly, if the replacement name of an {\em abbreviation} is a {\em type-name}
in the context of the {\em abbreviation-declaration},
the {\em abbreviation} becomes a {\em type-name}, and
must have they syntax of a {\em type-name}.
In other cases, the {\em abbreviation} must have the syntax of
a {\em variable-base-name} if its replacement does, and the syntax of
a {\em member-name} if its replacement does.

The rules in \itemref{KINDS-OF-NAMES}
apply to {\em abbreviations}.  For example, the rule regarding
{\em type-names} applies to {\em abbreviations}
of {\em type-names}.

Abbreviation replacement occurs after
{\em qualifier-names},
{\em type-names}, {\em variable-base-names}, and
{\em member-names} have been identified by the compiler.

Abbreviations are internal and never external (\pagref{EXTERNAL}),%
\label{ABBREVIATIONS-ARE-INTERNAL}
even if they begin with a {\em module-abbreviation}.
They do have scope (\pagref{SCOPE}) like other declarations, but their scope
is limited to the extended module (\pagref{EXTENDED-MODULE}) in
which they are declared.

Some examples are:
\begin{indpar}\begin{verbatim}
define abbreviations:
    int32 ---> `std int32'
    uns64 ---> `std uns64'
        // Builtin type abbreviations
    *UNCHECKED*  ---> `std *UNCHECKED*'
        // Builtin qualifier abbreviation

*UNCHECKED* int32 x 1 = 99
    // Same as: std *UNCHECKED* std int32 x 1 = 99
define abbreviations:
    .foo ---> `fee'
        // Illegal: `fee' does not begin with `.'.
    "+" ---> `std int64'
        // Illegal: `"+"' is not allowed as a type-name
        // (or a qualifier name, variable-base-name, or
        // member-name).

define abbreviation int64 unsigned ---> `uns64'
int64 unsigned z = 9 + 7
    // Legal, same as: std uns64 z = (9) "+" (7)
    // Matches builtin function prototype:
    //   function std uns64 r =
    //       std (std uns64 v1) "+" (std uns64 v2)
    // unless another function with prototype:
    //   function std uns64 r =
    //       (std uns64 v1) "+" (std uns64 v2)
    // is defined.

define abbreviations:
    x 1 ---> `x'
    .foo ---> `.fee'
int64 y = x 1 .foo + 10
    // Same as: std int64 y = (x.fee) "+" (10)
\end{verbatim}\end{indpar}

Abbreviation is recursive: an {\em abbreviation-replacement} can
itself be an abbreviation.
Abbreviation loops are possible and result in compile errors when
the abbreviation is used.
For example:
\begin{indpar}\begin{verbatim}
    define abbreviation X ---> `Y'
    int64 X = 5       // Same as: std int64 Y = 5
    define abbreviation Y ---> `Z'
    int64 X = 5       // Same as: std int64 Z = 5
    define abbreviation Z ---> `X'
    int64 X = 5       // Compile error replacing X.
\end{verbatim}\end{indpar}


\section{Program Organization}
\label{PROGRAM-ORGANIZATION}

Code is organized into two kinds of files: \skey{module}s
and \ikey{bodies}{body}.
Each body is associated
with a particular module, the `\key{module of the body}',
and extends that module.  A module
may have zero or more bodies.
A module and all its bodies together form
an `\key{extended module}'\label{EXTENDED-MODULE}.

Modules and bodies consist of a sequence
of \skey{declaration}s:
\begin{indpar}
\emkey{declaration}
    \begin{tabular}[t]{rll}
    ::= & {\em module-declaration}
        & [see \pagref{MODULE-DECLARATION}] \\
    $|$ & {\em body-declaration}
        & [see \pagref{BODY-DECLARATION}] \\
    $|$ & {\em defined-type-declaration}
        & [see \pagref{DEFINED-TYPE-DECLARATION}] \\
    $|$ & {\em type-name-declaration}
        & [see \pagref{TYPE-NAME-DECLARATION}] \\
    $|$ & {\em enum-type-declaration}
        & [see \pagref{ENUM-TYPE-DECLARATION}] \\
    $|$ & {\em qualifier-declaration }
        & [see \pagref{QUALIFIER-DECLARATION}] \\
    $|$ & {\em function-type-declaration }
        & [see \pagref{FUNCTION-TYPE-DECLARATION}] \\
    $|$ & {\em out-of-line-function-declaration }
        & [see \pagref{OUT-OF-LINE-FUNCTION-DECLARATION}] \\
    $|$ & {\em function-declaration }
        & [see \pagref{FUNCTION-DECLARATION}] \\
    $|$ & {\em generic-declaration }
        & [see \pagref{GENERIC-DECLARATION}] \\
    $|$ & {\em abbreviation-declaration }
        & [see \pagref{ABBREVIATION-DECLARATION}] \\
    $|$ & {\em assignment-statement }
        & [see \pagref{ASSIGNMENT-STATEMENTS}] \\
    \end{tabular}
\end{indpar}

Declarations declare {\em names}, {\em function-prototypes},
and {\em generic-prototypes}.
An {\em assignment-state\-ment} may also be a {\em declaration} of
its result {\em variable-names}.

{\em Names} shared between modules begin with {\em module-abbreviations}
that designate the module in which the name is declared.
Such names are called `\key{external}'.\label{EXTERNAL}
Similarly the pattern of a {\em function-prototype}
(\pagref{FUNCTION-PROTOTYPE})
or {\em generic-prototype}
(\pagref{GENERIC-PROTOTYPE})
may begin with the {\em module-abbreviation} of the module in
which the prototype is declared,
and such prototypes are `\key{external}'.

External names and prototypes can only be declared in modules, and
never in bodies.  External names and prototypes cannot be declared inside
statement blocks, but must be declared at `top level' outside
blocks.

As an exception, abbreviations are internal, and never external, even if
they begin with a {\em module-abbreviation}
(\pagref{ABBREVIATIONS-ARE-INTERNAL}).

In {\em function-calls} and {\em generic-calls} the
{\em module-abbreviation} may be omitted
if the {\em function-proto\-type} or {\em generic-prototype} matching the call
can be unambiguously determined: see
`module deficient' on \pagref{MODULE-DEFICIENT}.
This may \underline{not} be done
for names (e.g., external types, external variables).

An example is:
\begin{indpar}\begin{verbatim}
module "lib/math" as math

define type math complex as void
    // Given `math complex x', x[0] is the real part of a
    // complex number and x[1] is the imaginary part.

function math complex r, float64 r[0], float64 r[1] =
    math complex ( float64 real, float64 imaginary ):
    r[0] = real
    r[1] = imaginary

function math complex r, float64 r[0], float64 r[1] =
    math ( math complex a1, float64 a1[0], float64 a1[1] )
    "+"  ( math complex a2, float64 a2[0], float64 a2[1] ):
    r[0] = a1[0] + a2[0]
    r[1] = a1[1] + a2[1]

---------------------------------------------
module "my-module" as mine
    import "lib/math" as math

.............................
math complex x = math complex ( 1, 0 )
math complex y = complex ( 0, 1 )
    // The second `complex' in each line is a function name
    // so `math' may be omitted.  In this case the function
    // prototype that applies is selected by the y result
    // variable type.
math complex z1 = x + y
    // Parses to `math complex z1 = ( (x) "+" (y) )'.
    // Standard "+" does not apply because it does not match
    // result type.  `math' module abbreviation is implied so
    // that `math' module "+" applies.
math complex z2 = math ( x + y )
    // Parses to `math complex z2 = ( math (x) "+" (y) )'.
    // `math' module abbreviation for "+" is explicit and
    // NOT implied.
\end{verbatim}\end{indpar}

\subsection{Modules}
\label{MODULES}

A \key{module} is a file that begins with a {\em module-declaration}:

\begin{indpar}
\emkey{module-declaration}\label{MODULE-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= & {\em simple-module-declaration} \\
    $|$ & {\em simple-module-declaration}\TT{:} \\
	& \TT{~~~~}{\em module-clause}\STAR{} \\
    \end{tabular} \\
\emkey{simple-module-declaration} ::= \TT{module} {\em module-name}
        \TT{as} {\em module-abbreviation} \\
\emkey{module-name} ::= {\em quoted-string} \\
\emkey{module-abbreviation}\label{MODULE-ABBREVIATION}
	::= \TT{word} not containing any `\TT{.}'s \\
\emkey{module-clause}\label{MODULE-CLAUSE} ::=
    {\em import-clause} $|$ {\em parser-block} \\
\emkey{import-clause}\label{IMPORT-CLAUSE}
    ::= \TT{import} {\em module-name} \TT{as} {\em module-abbreviation} \\
\emkey{parser-block}\label{PARSER-BLOCK} ::=
    \begin{tabular}[t]{@{}l}
    \TT{external}\QMARK{} \TT{parsing:} \\
    \TT{~~~~}{\em parser-instruction}\STAR{} \\
    \end{tabular} \\
{\em parser-instruction} ::= see \pagref{PARSER-INSTRUCTION}

\begin{itemize}

\item
A {\em module-declaration} may only appear at the very beginning
of a module file.

\item
In a {\em module-declaration} all {\em module-abbreviations} must be
distinct, and all {\em module-names} must be distinct.

\item
There may be at most one {\em parser-block} in a {\em module-declaration}.
\end{itemize}
\end{indpar}

A {\em module-name} is a POSIX file name.
The {\em module-name} of a {\em module-declaration} must match the
name of the file containing the
{\em module-declaration}, relative to one of several directories
specified separately to the compiler.

The {\em module-abbreviation} associated with a {\em module-name}
may differ in different files.  Specifically, the {\em module-abbreviation}
for a module used in the module's own module file need not be the same
as the {\em module-abbreviations} used for the module in files
that import the module.

The conceptual directed graph whose nodes are modules and whose
arrows connect each module to the modules it or its bodies import is called
the `\key{module graph}'.\label{MODULE-GRAPH}
This graph \underline{must be acyclic}.

The module \TT{"standard"}\index{standard@\TT{"standard"}} with
module abbreviation \ttkey{std} is builtin and contains the builtin types and
functions.  The {\em import-clause}
\begin{center}
{\tt import }\TT{"standard"}\ttindex{standard@\TT{"standard"}}{\tt{}
    as \ttkey{std}}
\end{center}
is implied in every {\em module-declaration} and
{\em body-declaration} (see \itemref{BODIES}).

When a type is declared, functions with arguments or result
values of that type are automatically declared.  For example,
the declaration
\begin{center}
{\tt define type $T1$ as $T2$}
\end{center}
automatically declares
\begin{center}
\begin{tabular}{l}
{\tt function bool r = ( $T1$ x ) "==" ( $T1$ y ):} \\
{\tt ~~~~r = ( $T2$ ( x ) ) "==" ( $T2$  ( y ) )}
\end{tabular}
\end{center}

If the declared type begins with module abbreviation $ma$, the function
will also be given this module abbreviation.  Thus if $T1$ begins with
$ma$, the function will be
\begin{center}
\begin{tabular}{l}
{\tt function bool r = $ma$ ( $T1$ x ) "==" ( $T1$ y ):} \\
{\tt ~~~~r = ( $T2$ ( x ) ) "==" ( $T2$  ( y ) )}
\end{tabular}
\end{center}


\subsection{Scope}
\label{SCOPE}

A {\em declaration} has a \key{scope},
that is the set of statements in which any
names or prototypes defined by the {\em declaration}
are recognized.  The scope of a {\em declaration}
begins just after the {\em declaration}
itself, and
lasts to the end of smallest block containing the {\em declaration},
or until the end of the file containing the {\em declaration} if
the {\em declaration} is not inside any block.
If the {\em declaration} is at top level in a module, the scope of the
{\em declaration} is extended to include all the bodies of that
module.
If the {\em declaration} is external, the scope of the
{\em declaration} is extended to include all modules and
bodies that import the module containing the {\em declaration}.

Some statement subblocks are not considered to be blocks for
the purposes of defining scope.  These include subblocks inside
{\em abbreviation-declarations} (\pagref{ABBREVIATION-DECLARATION}),
{\em type-declarations} (\pagref{TYPE-DECLARATION}),
and {\em in\-clude-statements} (\pagref{INCLUDE-STATEMENT}).
These subblocks are considered to be syntactic sugar for
sequences of statements that do not contain the subblocks.

The scope of a {\em name}, {\em function-prototype}, or
{\em generic-prototype}
is the scope of the declaration that defines it.

The scope of a {\em block-name} is the block it names
(see \itemref{BLOCK-ASSIGNMENT-STATEMENTS}).

The \key{context}\label{CONTEXT} of a statement is the set of declarations
whose scope the statement is in.

When a {\em function-call} to an inline function
or a {\em generic-call} to a generic is compiled,
the context of the compilation is \underline{not} the current context but
rather the context of the inline function or generic
declaration.
Also the context in which any {\em default-value} expression
provided by a declaration
is compiled is the \underline{not} the current context but
rather the context of that declaration.

Code included by a generic
(\itemref{GENERICS}), however, \underline{is} compiled in the current context.

If two different declarations of the same {\em name} have overlapping
scope, one of these scopes must include the other,
and the declaration with the smaller scope is said to 
`\mkey{hide}{declaration}'\label{HIDE} the other declaration.
Such hiding is a compiler error unless the smaller scope
is within one of the following kinds of statements, and
the larger scope includes the whole statement:
\begin{center}
\begin{tabular}{ll}
{\em function-type-declaration}
    & [see \pagref{FUNCTION-TYPE-DECLARATION}] \\
{\em out-of-line-function-assignment}
    & [see \pagref{OUT-OF-LINE-FUNCTION-ASSIGNMENT}] \\
{\em out-of-line-function-declaration}
    & [see \pagref{OUT-OF-LINE-FUNCTION-DECLARATION}] \\
{\em function-declaration}
    & [see \pagref{FUNCTION-DECLARATION}] \\
{\em generic-declaration}
    & [see \pagref{GENERIC-DECLARATION}] \\
{\em block-assignment-statement} with context option
    & [see \pagref{BLOCK-ASSIGNMENT-STATEMENTS}] \\
{\em compile-and-run-assignment-statement} with context option
    & [see \pagref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}] \\
\end{tabular}\label{HIDING-EXCEPTIONS}
\end{center}

As an exception to the last rule, the declaration with the
smaller scope may be an assignment statement declaring
a variable name `\TT{next} {\tt v}' when the declaration
with the larger scope is an assignment statement
declaring `{\tt v}', and the two declarations have the
same smallest containing block.
Within the smaller scope `{\tt v}' refers to the
`\TT{next} {\tt v}' declaration: see \pagref{NEXT}.

By the last rule,
`\TT{next} {\tt v}' cannot be declared in a block $B$ if `{\tt v}' was
declared outside $B$ and $B$ is completely within
the scope of `{\tt v}', so the smallest containing block of
`{\tt v}' is not the same as the smallest containing block of
`\TT{next} {\tt v}'.

Prototypes cannot hide each other.  If the
current scope contains two declarations whose prototypes
both match a {\em function-call} or {\em generic-call},
the call is ambiguous and
in error, even if the scope of one declaration is within
a subblock of the scope of the other.
As a consequence, it may be unwise to place {\em function-declarations}
or {\em generic-declarations}
within assignment statements that have the context option.

A call that is a statement by itself
is matched against both {\em generic-prototypes}
and {\em function-proto\-types}, and will be ambiguous if it matches
one of each kind.

A declaration not inside a block is said to be `\key{top level}'.
The scope of a top level declaration in a module file is
extended to include the
bodies of that module.  External declarations must be top level in a
module file,
and their scope is extended to the modules and bodies that import the module.

A top level declaration
may \underline{not} have `\TT{next} {\em variable-name}' as
a result variable.

A top level assignment statement in a module may not include references to
out-of-line functions or to inline functions that in turn include
references to out-of-line functions.  This implies that all code needed
to initialize a top level variable will be initialized before the
variable is initialized.

However a top level assignment statement may have a
\key{deferred value} (\pagref{DEFERRED-ASSIGNMENT-STATEMENTS}) indicating
that its result variable values will not be assigned until later.
The statement
assigning the values must be in the same extended module
as the deferred assignment statement, but may be in a body
of that module, and if it is in a body,
may use out-of-line functions.
It is a programming error to access
deferred result variable values before they are assigned.

A name or prototype pattern
declared by a top level declaration in a module may begin with
the {\em module-abbreviation} of the module.  In this case the
name or prototype is `\key{external}',
unless it is an abbreviation.
The scope of external names and prototypes is extended
to include modules and bodies that import the declaring module.
All other names and prototypes declared in the module or
its bodies are `\key{internal}',
and these names and prototype patterns may not begin
with any {\em module-abbreviation}.

{\em Abbreviations} are always internal (\pagref{ABBREVIATIONS-ARE-INTERNAL}),
even when they begin with a {\em module-abbreviation}.

Any name or prototype declared to be external in an imported module is
said to be `\key{imported}'.  The name or prototype is said to be
`\key{exported}' by the module that contains its declaration,
and `\key{imported}' by modules and bodies that import that module.

Imported names can be used only if they begin
with the {\em module-abbreviation} that references the module in which
they are declared.  Imported prototypes may be used by calls beginning with
the {\em module-abbreviation} that references the module in which
they are declared, or if there is no ambiguity the {\em module-abbreviation}
may be omitted from the calls.

An example is:
\begin{indpar}\begin{verbatim}
module "my_own_module" as mom:
    // `import "standard" as std' is implied
    import "George's_own_module" as gom
    // gom contains:
    //    function int32 z = gom ( int32 x ) "+" ( int32 y )

int32 mom my external constant = ...
int32 my internal constant = ...

function int32 y = mom my external function ( int32 x ):
    ... function body omitted ...
function int32 y = my internal function ( int32 x ):
    ... function body omitted ...

function int32 z = my inline function ( int32 x, int32 y ):
    int32 z1 = gom ( x + y )
        // Uses gom's + operator.
        // Compiles as as `gom (x) "+" (y)'.
    int32 z2 = std ( x + y )
        // Uses builtin std's + operator.
        // Compiles as as `std (x) "+" (y)'.
    z  = z1 + z2 
        // Compiles as `z = ( (x) "+" (y) )'.
        // Compile error, ambiguous: both std + operator
        // and gom's + operator match the call to "+".
\end{verbatim}\end{indpar}\label{EXTERNAL-INTERNAL-EXAMPLE}

More specifically,
when a function declaration is used, the {\em module-abbreviation}
beginning the function call may be omitted if the function declaration is
the only function declaration within scope that matches the usage,
according to the module deficiency rules of
section~\itemref{MATCHING-CALLS-TO-PROTOTYPES}.
Thus in the context of the above example the lines:
\begin{indpar}\begin{verbatim}
int32 y = mom my external function ( x )
int32 y = my external function ( x )
\end{verbatim}\end{indpar}
are equivalent if no {\em function-prototype}
\begin{center}
\tt function int32 r = $ma$\QMARK{} my external function ( int32 v )
\end{center}
is in scope, where $ma$ is a module abbreviation other than `{\tt mom}'.

\subsection{Bodies}
\label{BODIES}

A \key{body}
is a file that begins with an {\em body-declaration}:

\begin{indpar}
\emkey{body-declaration}\label{BODY-DECLARATION} ::=
    \begin{tabular}[t]{l}
    \TT{body }{\em body-name}\TT{ of }{\em module-name}\TT{:} \\
    \TT{~~~~}{\em body-clause}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{body-name} ::= {\em quoted-string}
\\[0.5ex]
{\em body-clause} ::= {\em import-clause} $|$ {\em after-clause} $|$
                      {\em internal-parser-block}
\\[0.5ex]
{\em import-clause} ::= see \pagref{IMPORT-CLAUSE}
\\[0.5ex]
{\em after-clause} ::= \TT{initialize after }{\em body-name}
\\[0.5ex]
\emkey{internal-parser-block} ::=
{\em parser-block} without \TT{external} option
\\[0.5ex]
{\em parser-block} ::= see \pagref{PARSER-BLOCK}


\begin{itemize}

\item
A {\em body-declaration} may only appear at the very beginning
of a body file.

\item
In a {\em body-declaration} all {\em module-abbreviations} must be
distinct, and all {\em module-names} and {\em body-names}
must be distinct.

\item
There may be at most one {\em parser-block} in a {\em body-declaration}.
\end{itemize}

\end{indpar}

A {\em body-name} is a POSIX file name.
The {\em body-name} of a {\em body-declaration} must match the
name of the file containing the
{\em body-declaration}, relative to one of several directories
specified separately to the compiler.

A \key{body} is an extension of the module named in the first
line of the {\em body-declaration}.  The body cannot itself
contain external declarations.  It can provide
assignments for variables and out-of-line functions deferred in the
module it extends, and can call out-of-line functions in these
assignments.
It can also declare internal names and functions used only in the
body.

A body implicitly imports the module it extends.  Within the
body that module has the same {\em module-abbreviation} that it
had in the module's own file.  The other modules imported in the
module's own file are \underline{not} implicitly imported
to the body.  The body must import whatever other modules it uses
explicitly.

The {\em after-clauses} name other bodies that extend the same
module, and control initialization: see \itemref{PROGRAM-INITIALIZATION}.

\subsection{Program Initialization}
\label{PROGRAM-INITIALIZATION}

Modules must be initialized.  A module is initialized after every
module that it imports is initialized.  Otherwise the order of
initializing modules is indeterminate.  Because the module graph
(\pagref{MODULE-GRAPH}) is acyclic, it is always possible to
initialize imported modules before the importing module.

A module is initialized by executing top level assignment statements
in the module file, and then initializing
bodies that extend the module.  A body is initialized
by executing top level assignment statements in the body.
Top level statements in a file are executed in order.
Note that some of these assignment statements may not have
result variables.

A module is initialized before any bodies that extend it.
Unless specified by {\em after-clauses}, the order of initializing the
bodies that extend a module is indeterminate.
An `\TT{initialized after "$B1$"}' clause for module \TT{"$B2$"} causes
\TT{"$B2$"} to be initialized after \TT{"$B1$"}.

Each module has a `\key{body graph}'\label{BODY-GRAPH}
whose nodes are bodies that extend
the module and whose arrows connect each body to the bodies it
initializes after.  This graph must be acyclic.

All {\em deferred-assignment-statements}
(\pagref{DEFERRED-ASSIGNMENT-STATEMENTS})
and {\em out-of-line-function-deferred-assignments}
(\pagref{OUT-OF-LINE-FUNCTION-DEFERRED-ASSIGNMENT}) must be executed
before statements initializing their deferred variables or deferred functions.
Statements initializing deferred variables and functions must be executed
during initialization of the extended module containing the
deferred variables and functions, and
before the deferred variable values or deferred functions are used.

\subsection{Parsing}

The parser converts each statement to an abstract syntax tree,
using the language syntax equations and the {\em module-abbreviations}
and {\em parser-clauses}
of the current module's {\em module-declaration} or body's
{\em body-declaration}.  The abstract syntax
tree of a statement can be represented by inserting implied
parentheses into the statement and quoting operators.

For example, the statement
\begin{center}
\tt int64 x 1 = y 5 b + sin (w) * cos z
\end{center}
becomes the abstract syntax tree represented by
\begin{center}
\tt (int64 x 1) = ((y 5 b) "+" ((sin (w)) "*" (cos z)))
\end{center}
Note that the abstract tree representation is not legal
program code as it has parentheses around the result
variable declaration `{\tt int64 x 1}'.

Operators in the original statement are replaced by quoted
versions of the operators in the abstract
syntax tree, e.g., {\tt +} is replaced by {\tt "+"}, so that
the operators become {\em term-names}.

The parser does not process {\em result-variable-declarations} or
{\em argument-declarations}.  Thus
\begin{center}
\tt function int64 r = ( int64 a 1 ) "+" ( int64 a 2 )
\end{center}
becomes
\begin{center}
\tt function (int64 r) = (( int64 a 1 ) "+" ( int64 a 2 ))
\end{center}

Since the parser has only syntax information and {\em module-abbreviations}
available to
it, the parser does not know the {\em qualifier-names}
and {\em type-names} in a given scope, and in fact the parser
has no notion of scope.

The parser does know about {\em module-abbreviations} and
converts a statement of the form:
\begin{center}
{\em module-abbreviation} {\tt (~\ldots~)}
\end{center}
to
\begin{center}
{\tt (~}{\em module-abbreviation}{\tt ~\ldots~)}
\end{center}
after parsing `{\tt \ldots}'.  Thus if $ma$ is a {\em module-abbreviation},
\begin{center}
\tt int64 x 1 = $ma$ ( y 5 b + sin (w) * cos z )
\end{center}
becomes the abstract syntax tree represented by
\begin{center}
\tt (int64 x 1) = ($ma$ (y 5 b) "+" ((sin (w)) "*" (cos z)))
\end{center}

\section{Types}
\label{TYPES}

The basic builtin types are the number types and the \TT{void} type.
All defined types are subtypes of these types.
One of the builtin defined subtypes is the `\TT{type}' type.

A type is denoted by its {\em type-name}.  New types are
defined by statements of the form:

\begin{indpar}
\emkey{type-declaration}\label{TYPE-DECLARATION} \\
\hspace*{0.5in}\begin{tabular}{@{}rl@{}}
    ::= & \ttkey{define type}\TT{~}{\em type-name}\TT{~as~}\ldots \\
    $|$ & \TT{define types:} \\
        & {\TS ~~~~}{\em type-name}\TT{ as }\ldots \\
        & {\TS ~~~~}{\em type-name}\TT{ as }\ldots \\
        & {\TS ~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
    \end{tabular}
\\[1ex]
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\end{indpar}

\subsection{Number Types}
\label{NUMBER-TYPES}

Numbers are sequences of bits, and each number is one of
four kinds, unsigned integer, signed integer, floating point number,
or address:

\begin{indpar}
\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\bf Name & \bf Kind & \bf Size \\[2ex]
\TT{std}~~~\ttkey{uns8}		& unsigned integer & 8 bits \\
\TT{std}~~~\ttkey{uns16}	& unsigned integer & 16 bits \\
\TT{std}~~~\ttkey{uns32}	& unsigned integer & 32 bits \\
\TT{std}~~~\ttkey{uns64}	& unsigned integer & 64 bits \\
\TT{std}~~~\ttkey{uns128}	& unsigned integer & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{int8}		& signed integer & 8 bits \\
\TT{std}~~~\ttkey{int16}	& signed integer & 16 bits \\
\TT{std}~~~\ttkey{int32}	& signed integer & 32 bits \\
\TT{std}~~~\ttkey{int64}	& signed integer & 64 bits \\
\TT{std}~~~\ttkey{int128}	& signed integer & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{float16}	& IEEE floating point number & 16 bits \\
\TT{std}~~~\ttkey{float32}	& IEEE floating point number & 32 bits \\
\TT{std}~~~\ttkey{float64}	& IEEE floating point number & 64 bits \\
\TT{std}~~~\ttkey{float128}	& IEEE floating point number & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unsadr}	& unsigned integer & size of address \\
\TT{std}~~~\ttkey{intadr}	& signed integer & size of address \\
\TT{std}~~~\ttkey{adr}		& address
                                & size of address \\
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unswrd}	& unsigned integer & size of integer register \\
\TT{std}~~~\ttkey{intwrd}	& signed integer & size of integer register \\
\TT{std}~~~\ttkey{floatwrd}	& IEEE floating point number
                                & size of floating point register
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unsmax}	& unsigned integer & max implemented size \\
\TT{std}~~~\ttkey{intmax}	& signed integer & max implemented size \\
\TT{std}~~~\ttkey{floatmax}	& IEEE floating point number
                                & max implemented size
\end{tabular}

\end{indpar}

These are the \key{built in number types}.  The \TT{adr} type is a
signed or unsigned integer used as an address, and is differentiated
from other integers in case hardware differentiates addresses from
integers.
The \TT{\ldots{}wrd} types
are the sizes that execute fastest, while the \TT{\ldots{}max} types
may be larger sizes for which all arithmetic and comparison
operations are \key{implemented}\label{IMPLEMENTED}.
Copying and conversion of values is always implemented for
\underline{all}
number types, except for implementations
that do not implement \underline{any} floating point types.

It is required that the sizes of {\tt unswrd} and {\tt intwrd} be the
same, and that the sizes of {\tt unsmax} and {\tt intwrd} be the
same.  It is required that the size of {\tt unsmax} be at least
as large as the size of {\tt unswrd}, and similarly for {\tt int\ldots}
and {\tt float\ldots}.

Here `\TT{std}' is the module abbreviation for the \TT{"standard"}
module to which builtin types and functions belong.  For convenience
the following abbreviations are builtin:
\begin{indpar}
{\tt define abbreviations:}
\begin{indpar}[0.3in]

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{uns8} & {\tt `std~uns8'} \\
\ttkey{uns16} & {\tt `std~uns16'} \\
\ttkey{uns32} & {\tt `std~uns32'} \\
\ttkey{uns64} & {\tt `std~uns64'} \\
\ttkey{uns128} & {\tt `std~uns128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{int8} & {\tt `std~int8'} \\
\ttkey{int16} & {\tt `std~int16'} \\
\ttkey{int32} & {\tt `std~int32'} \\
\ttkey{int64} & {\tt `std~int64'} \\
\ttkey{int128} & {\tt `std~int128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{float16} & {\tt `std~float16'} \\
\ttkey{float32} & {\tt `std~float32'} \\
\ttkey{float64} & {\tt `std~float64'} \\
\ttkey{float128} & {\tt `std~float128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unsadr} & {\tt `std~unsadr'} \\
\ttkey{intadr} & {\tt `std~intadr'} \\
\ttkey{adr} & {\tt `std~adr'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unswrd} & {\tt `std~unswrd'} \\
\ttkey{intwrd} & {\tt `std~intwrd'} \\
\ttkey{floatwrd} & {\tt `std~floatwrd'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unsmax} & {\tt `std~unsmax'} \\
\ttkey{intmax} & {\tt `std~intmax'} \\
\ttkey{floatmax} & {\tt `std~floatmax'} \\
\end{tabular}

\end{indpar}
\end{indpar}

Here
\begin{center}
{\em abbreviation-name}~~\TT{\ABV}~~\TT{`}{\em replacement-name}\TT{'}
\end{center}
specifies that whenever the {\em abbreviation-name} occurs it is to be
replaced by the {\em replacement-name}.  See \itemref{ABBREVIATIONS} for
more abbreviation details.

In this document we will use these abbreviations as the
`\skey{builtin number type}s':

\begin{indpar}
{\em builtin-number-type-name}\label{BUILTIN-NUMBER-TYPE-NAME}
    \begin{tabular}[t]{@{}cl}
    ::= & \TT{uns8} $|$ \TT{uns16} $|$ \TT{uns32} $|$ \TT{uns64}
                    $|$ \TT{uns128} \\
    $|$ & \TT{int8} $|$ \TT{int16} $|$ \TT{int32} $|$ \TT{int64}
                    $|$ \TT{int128} \\
    $|$ & \TT{float16} $|$ \TT{float32} $|$ \TT{float64} $|$ \TT{float128} \\
    $|$ & \TT{unsadr} $|$ \TT{intadr} $|$ \TT{adr} \\
    $|$ & \TT{unswrd} $|$ \TT{intwrd} $|$ \TT{floatwrd}  \\
    $|$ & \TT{unsmax} $|$ \TT{intmax} $|$ \TT{floatmax}  \\
    \end{tabular}
\end{indpar}

\subsubsection{Integer Number Types}

The \mkey{size}{of number}
of a number is the number of its bits.  Numbers can have
different sizes: for example, unsigned integers can have
sizes of 8, 16, 32, 64, or 128 bits.

Numbers are stored in registers or in random access memory (RAM).

An \key{unsigned integer} of size $S$ is a binary integer with
$S$ binary digits (\skey{bit}s) and range from $0$ to $2^S-1$.

A \key{signed integer} of size $S$ is a two's complement integer
of size $S$ and range from $-2^{S-1}$ to $+2^{S-1}-1$.
This represents the integer $I$ in the given range
by the unsigned $S$-bit integer equal to $I~\mbox{modulo}~2^S$.

An \key{address} holds a RAM byte address.
An address is a 32-bit or 64-bit signed or unsigned integer whose size
and signage are determined by the target machine.
Some of high order bits may be
required to be all 0's or all 1's, depending upon
the target machine.  The \TT{unsadr} and \TT{intadr}
unsigned and signed integer types of the same size
as an address are provided for storing indices and offsets.

A reasonable assumption for 64-bit addresses is that only the low
order 48-bits of the address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing an address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The L-Language does
\underline{not} depend upon this assumption, but does provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$ (see {\tt extract adr}, \pagref{EXTRACT-ADR}).
The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.\footnote{The I86 64-bit architecture
uses only the low order 48 bits of an address, but \underline{requires}
the high order 17 bits to all be the same, either all 1's or all 0's.
However, as it is unlikely that there will ever be an allocated memory region
that includes address 0 in its interior, it makes no significant difference
whether we consider addresses to be unsigned or signed.}

\subsubsection{Floating Point Number Types}

A \key{floating point number} of size $S$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes are as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}r@{~~~~~~}r}
                   &              &              &             & \bf Maximum \\
\bf Floating Point & \bf Exponent & \bf Mantissa & \bf Decimal & \bf Decimal\\
\bf Number Size    & \bf Size     & \bf Size     & \bf Digits  & \bf Exponent
\\[2ex]
16 bits & 5 bits & 10 bits & 3.31 & 4.51 \\
32 bits & 8 bits & 23 bits & 7.22 & 38.23 \\
64 bits & 11 bits & 52 bits & 15.95 & 307.95 \\
128 bits & 15 bits & 112 bits & 34.02 & 4931.77 \\
\end{tabular}
\end{center}

There are also three special floating point values:
\TT{+Inf} denoting positive infinity,
\TT{-Inf} denoting negative infinity,
and \TT{NaN} denoting `\key{not-a-number}' which is a value produced
when, for example, \TT{0} is divided by \TT{0}.
In this document \ttkey{NaN}\label{NAN} denotes the particular non-signaling
not-a-number value
produced by arithmetic operations that cannot produce a number.%
\footnote{For example, the x86 architecture generates a
`\key{floating indefinite NaN}' as output of such operations.}
Floating point variables can store many other not-a-number values.

\subsubsection{Number Conversion Functions}

In the following we specify builtin conversion functions using
function prototypes of the form:
\begin{center}
\tt function $T1$ r = std $F$ ( $T2$ v )
\end{center}
This says that if you apply the function $F$ to the value \TT{v} which
is of type $T2$, the function will return a value \TT{r} of type $T1$.
See \itemref{FUNCTION-PROTOTYPES-AND-CALLS} for more function prototype details.

If a conversion from type $T2$ to type $T1$ may be implied, then
in code of the form
\begin{center} \tt
\begin{tabular}{l}
$T2$ v = \ldots \\
$T1$ r = v
\end{tabular}
\end{center}
the second statement will automatically invoke the implied conversion.

The following builtin conversion functions are defined:

\begin{indpar}
{\tt function uns$x$~~~r = std \ttkey{uns$x$}~~~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{int$x$}~~~( uns$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{int$x$}~~~( int$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( int$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( float$y$ v )}
\begin{center}
for any $x>y$ for which the types are builtin
\end{center}
\begin{indpar}
For these conversion functions, no information is lost from
the value when it is converted to the new type.  These conversions
can be \ikey{implied}{implied conversion}.
\end{indpar}

{\tt function uns$x$~~~r = std \ttkey{truncate}~~~( uns$y$ v )} \\
{\tt function uns$x$~~~r = std \ttkey{truncate}~~~( int$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{truncate}~~~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{truncate}~~~( int$y$ v )}
\begin{center}
for any $x$ and $y$ for which the types are builtin
\end{center}
\begin{indpar}
These functions return a value equal to the argument
modulo $2^x$.
\end{indpar}

{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( float$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( float$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( float$y$ v )}
\ttindex{nearest}
\begin{center}
for any $x$ and $y$ for which the types are builtin
\end{center}
\begin{indpar}
These functions round the argument to the nearest value (ties to even)
of the result type if the result must have less precision than the argument.
If the value overflows the result type, the result is \TT{+Inf} or \TT{+Inf}
for floating point results, and the largest or smallest possible result
value for integer results.
\end{indpar}

\end{indpar}

Note the difference between \TT{truncate} and \TT{nearest} when applied to
integers outside the range of the target type:
\begin{center}
\begin{tabular}{l}
{\tt uns8 ( truncate ( 257 ) ) == 1} \\
{\tt uns8 ( nearest ( 257 ) ) == 255} \\
\end{tabular}
\end{center}

Floating point numbers can be converted to integer valued floating point
numbers via:

\begin{indpar}
{\tt function float$x$~~~r = std \ttkey{round}~~~~~( float$x$ v )} \\
{\tt function float$x$~~~r = std \ttkey{ceiling}~~~( float$x$ v )} \\
{\tt function float$x$~~~r = std \ttkey{floor}~~~~~( float$x$ v )}

\begin{center}
for any $x$ for which the types are builtin
\end{center}
\begin{indpar}
These functions round to nearest (ties to even),
round up, and round down respectively.
\end{indpar}
\end{indpar}


\subsubsection{Unchecked Number Conversions}

The following \underline{unchecked} conversion functions are defined.
Note that here \TT{*UNCHECKED*} is a qualifier; see \itemref{QUALIFIERS}
for qualifier details.

\begin{indpar}
{\tt function \TT{*UNCHECKED*} uns$x$~~~r =~%
	\ttmkey{uns$x$}{conversion function}~~~( int$x$ v )} \\
{\tt function \TT{*UNCHECKED*} uns$x$~~~r =~%
	\ttmkey{uns$x$}{conversion function}~~~( float$x$ v )} \\
{\tt function \TT{*UNCHECKED*} int$x$~~~r =~%
	\ttmkey{int$x$}{conversion function}~~~( uns$x$ v )} \\
{\tt function \TT{*UNCHECKED*} int$x$~~~r =~%
	\ttmkey{int$x$}{conversion function}~~~( float$x$ v )} \\
{\tt function \TT{*UNCHECKED*} float$x$~r =~%
	\ttmkey{float$x$}{conversion function}~( uns$x$ v )} \\
{\tt function \TT{*UNCHECKED*} float$x$~r =~%
	\ttmkey{float$x$}{conversion function}~( int$x$ v )}

\begin{center}
for any $x$ for which the types are builtin
\end{center}
\begin{indpar}
These functions just return the $x$-bit value of \TT{v}
unchanged except for giving it a different type.
\end{indpar}
\end{indpar}

\subsubsection{Number Constants}
\label{NUMBER-CONSTANTS}

A \key{number-constant} is a {\em number} lexeme with specific syntax
that is used to denote a number.  The syntax is:

\begin{indpar}
\emkey{number-constant}\label{NUMBER-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em decimal-constant} \\
    $|$ & {\em binary-constant} \\
    $|$ & {\em hexadecimal-constant} \\
    $|$ & \TT{+Inf}\index{Inf@\TT{+Inf}}
          ~$|$~ \TT{-Inf}\index{Inf@\TT{-Inf}}
          ~$|$~ \ttkey{NaN}
    \end{tabular}
\\[0.5ex]
\emkey{sign} :::= \TT{+} $|$ \TT{-} \\
\emkey{exponent} :::=
	\{ \TT{e} $|$ \TT{E} \} {\em sign}\QMARK{} {\em dit}\PLUS{}
\\[0.5ex]
\emkey{decimal-constant} \begin{tabular}[t]{@{}rl@{}}
                         ::= & {\em decimal-lexeme} \\
			 $|$ & {\em decimal-constant-prefix} ~
			       {\em decimal-quoted-body} ~
			       {\em exponent}\QMARK{}
			 \end{tabular}
\\[0.5ex]
\emkey{decimal-lexeme} :::= {\em sign}\QMARK{} ~ {\em decimal-integer} ~
			    {\em decimal-fraction}\QMARK{} ~
                            {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{decimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{D}
\\[0.5ex]
\emkey{decimal-quoted-body} :::= \TT{"} {\em decimal-integer} ~
				 {\em decimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{decimal-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em dit}\PLUS{} \\
     $|$ & {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
     $|$ & {\em dit} {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
     $|$ & {\em dit} {\em dit} {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
    \end{tabular} \\
\emkey{decimal-fraction} :::= \TT{.} {\em dit}\PLUS{} \\
\emkey{dit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
 \\[0.5ex]
\emkey{binary-constant} ::= {\em binary-constant-prefix} ~
                              {\em binary-quoted-body} ~
			      {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{binary-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{B}
\\[0.5ex]
\emkey{binary-quoted-body} :::= \TT{"} {\em binary-integer} ~
				{\em binary-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{binary-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em bit}\PLUS{} \\
     $|$ & {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
     $|$ & {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
     $|$ & {\em bit} {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
     $|$ & {\em bit} {\em bit} {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
    \end{tabular} \\
\emkey{binary-fraction} :::= \TT{.} {\em bit}\PLUS{} \\
\emkey{bit} :::= \TT{0} $|$ \TT{1}
 \\[0.5ex]
\emkey{hexadecimal-constant} ::= \\
\hspace*{0.5in}{\em hexadecimal-constant-prefix} ~
               {\em hexadecimal-quoted-body} ~
	       {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{hexadecimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{X}
\\[0.5ex]
\emkey{hexadecimal-quoted-body} :::= \TT{"} {\em hexadecimal-integer} ~
				     {\em hexadecimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{hexadecimal-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em hit}\PLUS{} \\
     $|$ & {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
     $|$ & {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
     $|$ & {\em hit} {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
     $|$ & {\em hit} {\em hit} {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
    \end{tabular} \\
\emkey{hexadecimal-fraction} :::= \TT{.} {\em hit}\PLUS{} \\
\emkey{hit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
	     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
	     $|$ \TT{a} $|$ \TT{b} $|$ \TT{c} $|$ \TT{d} $|$ \TT{e} $|$ \TT{f}
	     $|$ \TT{A} $|$ \TT{B} $|$ \TT{C} $|$ \TT{D} $|$ \TT{E} $|$ \TT{F}
\end{indpar}

The integer part of decimal constants may have commas
every 3 digits, and the integer part of binary and hexadecimal constants
may have commas every 4 digits.
If there is a decimal point, there \underline{must}
be at least one integer digit and
one fraction digit.

\TT{NaN} denotes a canonical non-signaling NaN such
at that produced by hardware on the target machine
(\pagref{NAN}).
\TT{+Inf} denotes positive infinity; \TT{-Inf} denotes negative infinity.

{\em Number-constants} have no type.  They can be converted to
values of number type as follows.

A {\em number-constant} can be implicitly converted to any number
type that can represent the number exactly.

A {\em number-constant} can be implicitly converted to any
floating point number type.  If it is too large, it is converted to
\TT{+Inf}, and if it is too small, it is converted to \TT{-Inf}.
If it cannot be represented exactly, it is rounded (ties to even).

A {\em number-constant} can be explicitly converted to any number
type by either the \TT{truncate} or \TT{nearest} functions.
It may be explicitly
converted by \TT{uns$x$}, \TT{int$x$}, or \TT{float$x$} functions only
if it may be implicitly converted to the desired type.

{\em Number-constants} are compile time values and can be combined by
the standard operators to produce compile time values.

\subsection{The Void Type}
\label{THE-VOID-TYPE}

A \ttkey{void} type variable has no value.  No value can be
assigned to such a variable.  Nevertheless such variables have
uses, for example, as base variable in clusters (\pagref{CLUSTERS}).
When used as the base variable of a cluster, an assignment statement
may appear to be assigning a value to a \TT{void} variable, but
in fact it is assigning values to cluster members.

\subsection{Defined Types}
\label{DEFINED-TYPES}

A declaration statement of the following form defines a new type and
specifies a {\em type-name} for that type:
\begin{indpar}
\emkey{defined-type-declaration}\label{DEFINED-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
\TT{define type}
          {\em qualifier-name}\STAR{} {\em defined-type-name}
          \TT{as} {\em base-type-expression} \\
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME} \\
\emkey{defined-type-name} ::= {\em type-name} ~~~~~ [see \pagref{TYPE-NAME}] \\
\emkey{base-type-expression} ::= {\em expression} evaluating at compile-time
				 to a \TT{type} value \\
{\em expression} ::= see \pagref{EXPRESSION}
\end{indpar}

A \TT{type} value is an enumeration value (\pagref{ENUMERATION-TYPES}),
which is basically a small integer that identifies the type.
Types can be computed
by compile-time expressions, just like integers.
A \TT{type} value can be associated with zero or more {\em type-names},
which can be used in various ways, including as the name of a constant
equal to the \TT{type} value.

In a {\em defined-type-declaration}
the {\em base-type-expression} specifies
the `\key{base type}' of the new type defined
by the {\em defined-type-declaration}.
The {\em defined-type-name} names a new `\key{defined type}'.
The simplest {\em base-type-expres\-sion} is just a {\em type-name} of the
base type.

Any {\em qualifiers} in the declaration are attached to every
variable or argument declared with the {\em defined-type-name} (see
section \itemref{QUALIFIERS} for more on {\em qualifiers}).
Such {\em qualifiers} are associated with {\em type-names} and not
with \TT{type} values.

No {\em type-name} may be a prefix of
any {\em deferred-variable} (\pagref{DEFERRED-VARIABLE})
or any {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME}).
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.

Consider the example:
\begin{indpar}\begin{verbatim}
define type T1 as int32
type T2 = int32
define type T3 as T2  // Same as `define type T3 as int32'
int32 x = 1
*UNCHECKED* T1 x1 = T1 ( x )
*UNCHECKED* T2 x2 = x        // Compile error:
                             // T2 is not a type-name
*UNCHECKED* T3 x3 = T3 ( x )
\end{verbatim}\end{indpar}

A `{\tt \ttkey{define type} T as \ldots}'
statement defines {\tt T} to be a {\em type-name} that can be used in
a declaration of the form `{\tt T v}',
or can be used to name a constant equal a \TT{type} value
as in `{\tt T == int32}',
or can be used
as a function of one argument to convert the argument to the
type, as in `{\tt T(v)}', provided the result is a variable with
the \TT{*UNCHECKED*} qualifier.
However a statement of the form `{\tt type T = \ldots}'
declares {\tt T} to be a mere variable name that can only be
use as a constant equal a \TT{type} value.

A defined type has an
`\mkey{underlying type}{of defined type}'\label{UNDERLYING-TYPE} that
is a builtin type.  Underlying types are defined recursively:
the underlying type of a defined type is the underlying type of
its base type, and the underlying type of a builtin type is
the builtin type itself.

The following builtin unchecked conversion functions are defined:
\begin{indpar}\label{DEFINED-TYPE-UNCHECKED-CONVERSIONS}
{\tt function \TT{*UNCHECKED*} $T$ r = $T$ ( $B$ v )} \\
{\tt function \TT{*UNCHECKED*} $B$ r = $B$ ( $T$ v )}

where $T$ is a {\em defined-type-name} and $B$ is any {\em type-name}
for the base type of $T$

\begin{indpar}
These functions do not change the actual value, but merely its
compile-time type.
\end{indpar}\label{DEFINED-TYPE-UNCHECKED-CONVERSION}

\end{indpar}

The \TT{*UNCHECKED*} qualifier
(\itemref{QUALIFIERS} and \pagref{THE-UNCHECKED-QUALIFIER})
may be attached to variables and must be attached to the result
variables of an unchecked type conversion.  An example of
their use to define type and \underline{explicit} conversion from
type {\tt T1} to type {\tt T2} that is \underline{not} unchecked is:
\begin{indpar}\label{NOT-UNCHECKED-CONVERSION-DEFINITION}\begin{verbatim}
define type T1 as T2
function T2 r = T2 ( T1 v ):
    *UNCHECKED* r2 = T2 ( v )
    r = r2
\end{verbatim}\end{indpar}
They can also be used to define an implied conversion from type
{\tt T1} to type {\tt T2}, as in the
following example:
\begin{indpar}\begin{verbatim}
define type T1 as T2
function Qs T2 r = assign (| qualifiers Qs |) ( Qs T1 v ):
    *UNCHECKED* Qs r2 = T2 ( v )
    r = r2
\end{verbatim}\end{indpar}
See \itemref{IMPLIED-CONVERSION} implied conversion details.

The following builtin functions are also defined:

\begin{indpar}
{\tt function type r = std \ttkey{base type of} ( type t )}

\begin{indpar}
Returns the base type of the defined type {\tt t}.
\end{indpar}

{\tt function type r = std \ttkey{underlying type of} ( type t )}

\begin{indpar}
Returns the underlying type of the defined type or builtin type {\tt t}.
\end{indpar}
\end{indpar}

A type may have zero or more type names associate with it.
An additional name may be associated with a type by the statement:
\begin{indpar}
\emkey{type-name-declaration}\label{TYPE-NAME-DECLARATION} ::= \\
\hspace*{0.5in}
\TT{define type}
          {\em qualifier-name}\STAR{} {\em type-name}
          \TT{as type name of} {\em type-expression} \\
\emkey{type-expression} ::= {\em expression} evaluating at compile-time
				 to a \TT{type} value \\
{\em expression} ::= see \pagref{EXPRESSION}
\end{indpar}

Unlike the {\em defined-type-declaration}, the {\em type-name-declaration}
does \underline{not} define a new type.  It merely defines a new
{\em type-name} that references an old type.
The {\em qualifier-names} in either declaration are associated
with the {\em type-name}, and not the type, and are applied whenever
the {\em type-name} is used to declare a variable.

An example is:
\begin{indpar}\begin{verbatim}
define type T4 as type name of int32
    // Now T4 == int32
T4 x = 1              // Same as `int32 x = 1'
int32 y = T4 ( x )    // Same as `int32 y = int32 ( x )'
define type T5 as int32
    // Now T5 != int32 and T5 != T4
define *UNCHECKED* T6 as type name of int32
    // *UNCHECKED* is a builtin qualifier
    // Now T6 == int32
T6 x = 1              // Same as `*UNCHECKED* int32 x = 1'
\end{verbatim}\end{indpar}

There is one builtin defined type:
\begin{indpar} \tt
define type \ttkey{std bool}\label{BOOL} as unswrd \\
define abbreviation \ttkey{bool} \ABV{} `std bool' \\
function std bool r = \ttkey{std false}: \\
\TS~~~~*UNCHECKED* r2 = std bool ( 0 ) \\
\TS~~~~r = r2 \\
function std bool r = \ttkey{std true}: \\
\TS~~~~*UNCHECKED* r2 = std bool ( 1 ) \\
\TS~~~~r = r2 \\
function std intwrd r = \ttkey{std int} ( bool v ): \\
\TS~~~~r = 1 if v else 0
\end{indpar}

In statements that test \TT{bool} values to determine control
flow, \TT{false} (derived by converting the integer zero)
denotes false, and any \TT{bool} value derived by converting
a non-zero integer denotes true.

Implied conversions from any type of value to a \TT{bool}%
\label{IMPLIED-BOOL-CONVERSION} may
be defined as a shorthand for testing the validity of the value.
Because of this, it is important that \TT{bool} values \underline{not} be
acceptable as operands of builtin operators, e.g., comparison
operators.  This in turn makes it impossible to define \TT{bool}
as an enumeration type as per Section~\itemref{ENUMERATION-TYPES}.

\subsection{Enumeration Types}
\label{ENUMERATION-TYPES}

An \key{enumeration type} is a defined type whose values are
integers assigned to \skey{enumeration constant}s.
Each enumeration constant is assigned a value during compilation
that is an integer unique relative to all enumeration
constants of its enumeration type that are being compiled together.
Then during program initialization
the enumeration constant is assigned a possibly
different value that is an integer unique relative to all enumeration
constants of its enumeration type that are being initialized by
the program.

A declaration statement of the following form defines an \key{enumeration type}:
\begin{indpar}
\emkey{enum-type-declaration}\label{ENUM-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
    \TT{define type} {\em qualifier-name}\STAR{}
    \begin{tabular}[t]{@{}l@{}}
    {\em enum-type-name} \TT{as}~~~{\em enum-base} \\
    \TT{with enum range}~~~{\em enum-range} \\
    \end{tabular}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
\emkey{enum-type-name} ::= {\em type-name} ~~~~~ [see \pagref{TYPE-NAME}]
\\[0.5ex]
\emkey{enum-base}
    \begin{tabular}[t]{rl}
    ::= & {\em integer-type-expression} \\
    $|$ & {\em enum-direction}~~~{\em enum-type-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{integer-type-expression} ::= {\em expression} evaluating at compile-time
				 to a builtin integer \TT{type}
\\[0.5ex]
\emkey{enum-direction} ::= \TT{next} $|$ \TT{previous}
\\[0.5ex]
\emkey{enum-type-expression} ::= {\em expression} evaluating at compile-time
				 to an enumeration \TT{type}
\\[0.5ex]
\emkey{enum-range}
    \begin{tabular}[t]{rl}
    ::= & \TT{[} {\em first-enum} \TT{..} {\em last-enum} \TT{]} \\
    $|$ & \TT{[} {\em first-enum} \TT{..} \TT{]} \\
    $|$ & \TT{[} \TT{..} {\em last-enum} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{first-enum} ::=
    {\em expression} evaluating at compile-time to an integer
\\[0.5ex]
\emkey{last-enum} ::=
    {\em expression} evaluating at compile-time to an integer
\\[0.5ex]
\emkey{expression} ::= see \pagref{EXPRESSION}
\end{indpar}

Here {\em first-enum} and {\em last-enum} are compile time integer
values assigned to the newly defined enum type.
{\em First-enum} must be less than or equal to {\em last-enum}.
If {\em last-enum} is not given, it is assumed to be the maximum
value permitted by the {\em enum-base} that conforms to the
rules given below.
Similarly if {\em first-enum} is not given, it is assumed to be the minimum
value permitted by the {\em enum-base}.

The {\em enum-base} specifies the `\mkey{base type}{of enumeration type}'
of the enumeration type
which is either the type given by an {\em integer-type-expression} or
the type given by an {\em enum-type-expression}.
The `\mkey{underlying type}{of enumeration type}'
of the enumeration type
is the base type if that is an integer type, or is the
underlying type of the base type otherwise.
This definition is recursive, so the underlying type of an enumeration
type is always an
integer type.

Information about
an enumeration type
can be discovered by the functions:

\begin{indpar}

{\tt function type r = std \ttkey{base type of} ( type t )} \\
{\tt function type r = std \ttkey{underlying type of} ( type t )}

\begin{indpar}
Returns the base type or underlying type of the enumeration type {\tt t}.
\end{indpar}

{\tt function intwrd r = std \ttkey{enum direction of} ( type t )}

\begin{indpar}
Returns the {\em enum-direction} of the enumeration type {\tt t}.
{\tt -1} is returned if the direction is `{\tt previous}',
{\tt +1} is returned if the direction is `{\tt next}',
and {\tt 0} is returned if the direction is not given.
\end{indpar}

{\tt function $I$ r = std \ttkey{first enum of} ( type t )} \\
{\tt function $I$ r = std \ttkey{last enum of} ( type t )}

\begin{center}
where $I$ is the most specific type (\pagref{MORE-SPECIFIC-RELATION})
in the set \\
\TT{unswrd     intwrd     unsmax     intmax} \\
such that both the {\em first-enum} and the {\em last-enum} \\
of enumeration type {\tt t} are convertible to $I$
\end{center}

\begin{indpar}
Returns the {\em first-enum} or {\em last-enum} of the enumeration type {\tt t}.
\end{indpar}

\end{indpar}

Enumeration values can be assigned by assignment statements of the form
\begin{indpar}
\emkey{enum-assignment}
    \begin{tabular}[t]{rl}
    ::= & {\em enum-type-name} ~ {\em enum-constant-name}\TT{ = next enum} \\
    $|$ & {\em enum-type-name} ~ {\em enum-constant-name}\TT{ = previous enum}
    \end{tabular}
\\[0.5ex]
\emkey{enum-constant-name} ::= {\em variable-name}
		~~~~~ [see \pagref{VARIABLE-NAME}]
\end{indpar}

These statements invoke one of the builtin functions:
\begin{indpar}
{\tt function $T$ r = $ma$\QMARK{} \ttkey{next enum}} \\
{\tt function $T$ r = $ma$\QMARK{} \ttkey{previous enum}}
\begin{center}
where $T$ is the {\em enum-type-name} and $ma$ is its
{\em module-abbreviation}, if any
\end{center}


\end{indpar}

Within a compilation the compiler assigns the value {\em first-enum}
to the first constant named in a `\TT{next enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in increasing order.
It is an error if `\TT{next~enum}'
would return a value beyond the {\em last-enum} value in a range.

Similarly the compiler assigns the value {\em last-enum}
to the first constant named in a `\TT{previous enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in decreasing order.
It is an error if `\TT{previous~enum}'
would return a value below the {\em first-enum} value in a range.

It is also an error if for a given type the same value is returned
by some \TT{next~enum} and also by some \TT{previous~enum}.

In memory an enumeration value is represented by an integer value
of the underlying type of the enumeration value's enumeration type.
This is called the `\mkey{underlying value}{of enumeration value}'
of the enumeration value.

The following unchecked conversions between enumeration values are builtin:
\begin{indpar}

{\tt function \TT{*UNCHECKED*} $E1$ r = $E1$ ( $E2$ v )}
\begin{center}
where $E1$ and $E2$ are both enumeration types
and $E1$ and $E2$ have the same underlying type
\end{center}
\begin{indpar}
These conversions do nothing but change the type of the value.
\end{indpar}

\end{indpar}

The enumeration value also has a
numeric value in the range
{\tt [}{\em first-enum}{\tt ,} {\em last-enum}{\tt ]}, which is
called the `\mkey{range value}{of enumeration value}' of the
enumeration value.  The difference between the underlying value
and the range value of an enumeration value is a constant
called the `\mkey{enumeration offset}{of enumeration type}' of
the enumeration type.

In order to represent range values the `\mkey{range type}{of enumeration type}'
is used.
This is the most specific type (\pagref{MORE-SPECIFIC-RELATION})
$R$ in the set \\
\centerline{\TT{unswrd     intwrd     unsmax     intmax}}
such that both the {\em first-enum} and the {\em last-enum}
of the enumeration type are implicitly convertible to $R$.

In order to represent enumeration offset the
`\mkey{offset type}{of enumeration type}' is used.
This is the most specific type (\pagref{MORE-SPECIFIC-RELATION})
$O$ in the set \\
\centerline{\TT{unswrd     intwrd     unsmax     intmax}}
such that values of either the underlying type or the range type
of the enumeration type are implicitly convertible to $O$.

The following builtin functions can be used to find
these values:

\begin{indpar}

{\tt function $U$ r = $ma$\QMARK{} \ttkey{underlying value of} ( $E$ v )} \\
{\tt function $R$ r = $ma$\QMARK{} \ttkey{range value of} ( $E$ v )}

\begin{center}
where $E$ is an {\em enum-type-name}, 
$ma$ is the {\em module-abbreviation} of $E$ if any, \\
$U$ is the underlying type of $E$,
and $R$ is the range type of $E$
\end{center}
\begin{indpar}
The underlying value or range value of {\tt v} is returned.
\end{indpar}

{\tt function $O$ r = std \ttkey{enumeration offset of} ( type t )} \\
{\tt function type r = std \ttkey{range type of} ( type t )} \\
{\tt function type r = std \ttkey{offset type of} ( type t )}

\begin{center}
where {\tt t} is an enumeration type and $O$ is its offset type
\end{center}
\begin{indpar}
The enumeration offset, range type, or offset type of {\tt t} is returned.
\end{indpar}

\end{indpar}

Thus for a value {\tt v} of an enumeration type $E$,
\begin{center}
\tt underlying value of ( v ) \begin{tabular}[t]{@{}l@{}}
                              = range value of ( v ) \\
			      + enumeration offset of ( $E$ )
			      \end{tabular}
\end{center}

If the base type of an enumeration type is a builtin integer type,
the integer value corresponding to {\em first-enum} is {\em first-enum}
itself, and similarly for {\em last-enum}.  Thus the enumeration offset
is zero and we have the following example:
\begin{indpar}\begin{verbatim}
define type E as int32 with enum range [1 .. 20]
    // Now enumeration offset of (E) == 0
E C1 = next enum
    // Now underlying value of (C1) == 1
E C2 = next enum
    // Now underlying value of (C2) == 2
E C3 = previous enum
    // Now underlying value of (C3) == 20
E C4 = previous enum
    // Now underlying value of (C4) == 19
\end{verbatim}\end{indpar}

The enumeration offset of an {\em enum-type-name} is defined in general
as per the following cases:

\begin{indpar}
\begin{itemlist}
\item[\TT{define type} {\em qualifier-name}\STAR{} {\em enum-type-name}~~%
    \TT{as}~~{\em integer-type-expression} \ldots{}] ~\\
The enumeration offset of the {\em enum-type-name} equals \TT{0}.
\item[\TT{define type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em enum-type-name}~~\TT{as}~~%
              \TT{next}~~{\em enum-type-expression} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Has the effect of compiling the statements:
\begin{center}
\begin{tabular}{l}
{\em base-enum-type-name} {\tt ~V0~~=~~next enum} \\
{\em base-enum-type-name} {\tt ~V1~~=~~next enum} \\
{\em base-enum-type-name} {\tt ~V2~~=~~next enum} \\
\ldots\ldots\ldots \\
{\em base-enum-type-name} {\tt ~V$n$~~=~~next enum} \\
\end{tabular}
\end{center}
where $n$ = {\em last-enum} - {\em first-enum}, and then setting
\begin{center}
\TT{enumeration offset of (}{\em enum-type-name}\TT{)} = \\
{\tt ~~~~underlying value of (V0)~-~}{\em first-enum}
\end{center}
\item[\TT{define type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em enum-type-name}~~\TT{as}~~%
              \TT{previous}~~{\em enum-type-expression} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Has the effect of compiling the statements:
\begin{center}
\begin{tabular}{l}
{\em base-enum-type-name} {\tt ~V0~~=~~previous enum} \\
{\em base-enum-type-name} {\tt ~V1~~=~~previous enum} \\
{\em base-enum-type-name} {\tt ~V2~~=~~previous enum} \\
\ldots\ldots\ldots \\
{\em base-enum-type-name} {\tt ~V$n$~~=~~previous enum} \\
\end{tabular}
\end{center}
where $n$ = {\em last-enum} - {\em first-enum}, and then setting
\begin{center}
\TT{enumeration offset of (}{\em enum-type-name}\TT{)} = \\
{\tt ~~~~underlying value of (V0)~-~}{\em last-enum}
\end{center}
\end{itemlist}
\end{indpar}

The above is exemplified by:
\begin{indpar}\begin{verbatim}
define type E1 as int32 with enum range [1 .. 20]
    // Now enumeration offset of (E1) == 0
E1 C1 = previous enum
    // Now range value of (C1) == 20
    // Now underlying value of (C1) == 20
define type E2 as previous E1 with enum range [1 .. 10]
    // Now enumeration offset of (E2) == 9
E2 C2 = next enum 
    // Now range value of (C2) == 1,
    // Now underlying value of (C2) == 10
E2 C3 = previous enum 
    // Now range value of (C3) == 10,
    // Now underlying value of (C3) == 19
define type E3 as next E2 with enum range [1 .. 5]
    // Now enumeration offset of (E3) == 10
E3 C4 = next enum 
    // Now range value of (C4) == 1,
    // Now underlying value of (C4) = 11
\end{verbatim}\end{indpar}

The following builtin functions allow comparison and subtraction
of enumeration values:

\begin{indpar}

{\tt function bool r = $ma$\QMARK{} ( $E$ v1 ) "$cop$" ( $E$ v1 )}

\begin{center}
where $E$ is an enumeration type, \\
$ma$ is the {\em module-abbreviation} of $E$ if any, \\
and $cop$ is
\ttmkey{<}{of enum values}, \ttmkey{<=}{of enum values},
\ttmkey{==}{of enum values}, \ttmkey{!=}{of enum values},
\ttmkey{=>}{of enum values}, or \ttmkey{>}{of enum values}.
\end{center}
\begin{indpar}
Returns {\tt range value of (v1) "$cop$" range value of (v2)}.
\end{indpar}

{\tt function $R$ r =
    $ma$\QMARK{} ( $E$ v1 ) "\ttmkey{-}{of enum values}" ( $E$ v1 )}
\begin{center}
where $E$ is an enumeration type, \\
$ma$ is the {\em module-abbreviation} of $E$ if any, \\
and $R$ is $E$'s range type
\end{center}
\begin{indpar}
Returns {\tt range value of (v1) "-" range value of (v2)}.
\end{indpar}

\end{indpar}

Two enumeration values of different types
may be compared or subtracted if they can be implicitly
converted to a common enumeration or integer type.

The following are builtin enumeration types:
\begin{indpar} \tt
define types: \\
\TS~~~~\ttkey{std type}~as unswrd with enum [0~..] \\
\TS~~~~\ttkey{std qualifier}~as unswrd with enum [0~..] \\
define abbreviations: \\
\TS~~~~\ttkey{type} \ABV{} `std type' \\
\TS~~~~\ttkey{qualifier} \ABV{} `std qualifier' \\
\\[1ex]
type \ttkey{std missing type}~= next enum // 0 \\
function std type r = \ttmkey{std missing}{type}: \\
\TS~~~~r = std missing type
\\[1ex]
qualifier~\ttkey{std missing qualifier}~= next enum // 0 \\
function std qualifier r = \ttmkey{std missing}{qualifier}: \\
\TS~~~~r = std missing qualifier
\end{indpar}

Builtin types not mentioned above, such as `\TT{void}' and `\TT{int32}',
are given unspecified (i.e., implementation dependent)
`\TT{type}' enumeration values.
Similarly builtin qualifiers, e.g.~\TT{*MEM*}, are given
unspecified `\TT{quali\-fier}' enumeration values.  
The `\TT{range value of}' function above
can be used to find the range value of an
enumeration constant, but unspecified builtin values may differ from
one compilation or program to the next.

Enumeration values are assigned within a compilation in
the order that {\em enum-assignments} are compiled.
Enumeration values are assigned during program initialization
according to the order
that code files containing the {\em enum-assignments} are initialized.
The program initialization
and compile values assigned by an {\em enum-assignment}
may differ.

However, within a code file, all assignments to an enumeration type
are done in the same order during program initialization as during compilation.
Thus values assigned within the same code file can be assumed to
have the same relative values at compile and run times.  Also,
compile and run values of a given enumeration type
can be assumed to be the same if \underline{all} values
of that enumeration type are assigned in the a single code file.

\subsection{Enumeration Set and List Types}
\label{ENUMERATION-SET-AND-LIST-TYPES}

For every enumeration type two additional types are created,
an enumeration set type and an enumeration list type.
An \key{enumeration set} is a set of enumeration values.
An \key{enumeration list} is a list of enumeration values.
These two new types do not have {\em type-names},
but they can be discovered by the following functions:

\begin{indpar}

{\tt function type r = std \ttkey{set of} ( type E )} \\
{\tt function type r = std \ttkey{list of} ( type E )}
\begin{indpar}
Returns the type whose values are sets or lists
of elements of type {\tt E}, where
{\tt E} must have an integer underlying type.
\end{indpar}

\end{indpar}

These types can be given type names by
{\em type-name-declarations} (\pagref{TYPE-NAME-DECLARATION}) of the form
\begin{indpar}
{\tt define type }{\em type-name}{\tt ~as type name of set of ( $E$ )} \\
{\tt define type }{\em type-name}{\tt ~as type name of list of ( $E$ )}
\end{indpar}
where $E$ is the element type.

Note that the element type of an enumeration set or list can be
a builtin integer type or a non-enumeration defined type
with a builtin integer underlying type.

The syntax
for enumeration set and list constants is:
\begin{indpar}
\emkey{enum-set-constant}\label{ENUM-SET-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{~\}} \\
    $|$ &\TT{\{} {\em enum-item}
                   \{ \TT{,} {\em enum-item} \}\STAR{} \TT{\}} \\
    \end{tabular} \\
\emkey{enum-list-constant}\label{ENUM-LIST-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{[~]} \\
    $|$ &\TT{[} {\em enum-item}
                   \{ \TT{,} {\em enum-item} \}\STAR{} \TT{]} \\
    \end{tabular} \\
\emkey{enum-item}
    ::= {\em enum-value} $|$ {\em enum-range} \\
\emkey{enum-range}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em enum-value}~~~\TT{..}~~~{\em enum-value} \\
    $|$ & {\em enum-value}~~~\TT{..} \\
    $|$ & \TT{..}~~~{\em enum-value} \\
    \end{tabular} \\
\emkey{enum-value} ::= {\em expression} evaluating at compile-time to
			an enumeration or integer value
\end{indpar}

If the {\em enum-values} in an {\em enum-set-constant} or
{\em enum-list-constant} have different
types, and these are defined types or enumeration types,
implied conversions from these to their base types
are inserted until all have the same defined type, enumeration type,
or builtin integer type,
which is called the
`\key{common element type}'\label{COMMON-ELEMENT-TYPE}
of the set or list.
This is the most specific type to which all the set
or list
elements can be converted by implied conversions
(see \pagref{MORE-SPECIFIC-RELATION}).
It is an error
if this cannot be done because some of the types have no implied
conversion to their base type defined for them.
The type of an enumeration set or list is the set or list type
defined for this common element type.

An {\em enum-range} designates the two values given and all
values in between.
After implied conversion, if the first {\em enum-value} in an {\em enum-range}
is greater than the second {\em enum-value} in the {\em enum-range},
the set is empty.  If the first or second {\em enum-value} of
an {\em enum-range} is omitted, it is taken to be the lower or upper
limit of the enumeration type of the non-omitted {\em enum-value}.

The order in which values are given in an {\em enum-set-constant}
does not matter.  Overlapping and adjoining ranges are implicitly
combined.\footnote{Internally an enumeration set may be stored as a
sorted list of integers with binary indicators specifying when all
the values between one integer and the next integer are to be included
in the set.}
Thus
\begin{indpar}\begin{verbatim}
define type X as uns8 with enum range [1 .. 20]
X X1 = next enum
X X2 = next enum
. . . . . . . . . .
X X20 = next enum

// Then:
//
//    { X1, X5, X2, X10 .. X16, X19 .. X20, X15 .. X18 }
// == { X1, X2, X5, X10 .. X20 }
\end{verbatim}\end{indpar}

The order in which values are given in an {\em enum-list-constant}
does matter, and ranges are not combined.  Thus in the above
example `{\tt [X1, X2] != [X2, X1]}' and `{\tt [X1, X1] != [X1]}'.

Enumeration set and list values are used in logical expressions that
condition function lookup.  For example,
\begin{indpar}\begin{verbatim}
T v = signed max (| type T |) ( T v1, T v2 )
      [| T is in { int8, int16, int32, int64, int128 } |]:
    . . . . . . . . . . .
\end{verbatim}\end{indpar}

defines a function that takes only signed integer type
arguments, and not unsigned integer type arguments.
The logical expression inside \TT{[|~|]} must be satisfied
for the function definition to match a function call, and
the type argument {\tt T}, which is implied and need not be
given in the function call, must be in the given set of
types, where types are values of the enumeration type `\TT{type}'
(see Section~\itemref{TYPE-VALUES}).

The information about enumeration set and list types can be determined
at compile-time by:

\begin{indpar}
{\tt function bool r = \ttkey{is enumeration set type} ( type T )}
\begin{indpar}
Returns \TT{true} if {\tt T} is an enumeration set type and \TT{false}
otherwise.
\end{indpar}

{\tt function bool r = \ttkey{is enumeration list type} ( type T )}
\begin{indpar}
Returns \TT{true} if {\tt T} is an enumeration list type and \TT{false}
otherwise.
\end{indpar}

{\tt function type r = \ttkey{element type of} ( type T )}
\begin{indpar}
Returns the element type of an enumeration set or list type {\tt T}.
\end{indpar}

\end{indpar}

The following are builtin enumeration set types:
\begin{indpar} \tt
define types: \\
\TS~~~~\ttkey{std types} as set of type \\
\TS~~~~\ttkey{std qualifiers} as set of qualifier \\
define abbreviations: \\
\TS~~~~\ttkey{types} \ABV{} `std types' \\
\TS~~~~\ttkey{qualifiers} \ABV{} `std qualifiers'
\end{indpar}

The following unchecked conversions between enumeration
set types and enumeration list types are builtin:
\begin{indpar}
{\tt function \TT{*UNCHECKED*} $T1$ r = $T1$ ( $T2$ v )}
\begin{center}
where $T1$ and $T2$ are either both enumeration set types or both
enumeration list types \\
and the element types of $T1$ and $T2$ have the same underlying type
\end{center}
\begin{indpar}
These conversions do nothing but change the type of the value.
\end{indpar}
\end{indpar}

Variables with compile-type enumeration set or list values can be defined.
If $S$ is an enumeration set type with element type $E$,
$L$ is an enumeration list type with element type $E$,
and $ma$ is the {\em module-abbreviation} of the original type name
of $E$ if any,
then the following functions are defined at compile-time
(but may not be defined at run-time):

\begin{indpar}
{\tt function $S$ r =
    $ma$\QMARK{} ($S$ v1) "\ttmkey{+}{enumeration set union}" ( $S$ v2 )}
\begin{indpar}
Returns the union of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $S$ r =
    $ma$\QMARK{} ($S$ v1) "\ttmkey{*}{enumeration set intersection}" ( $S$ v2 )}
\begin{indpar}
Returns the intersection of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $S$ r =
    $ma$\QMARK{} ($S$ v1) "\ttmkey{-}{enumeration set difference}" ( $S$ v2 )}
\begin{indpar}
Returns the set difference of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function bool r =
    $ma$\QMARK{} ($E$ e) \ttmkey{is in}{enumeration set} ($S$ s)}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the set {\tt s}, and
\TT{false} otherwise.
\end{indpar}

{\tt function $S$ r =
    $ma$\QMARK{} ($E$ e) "\ttmkey{+}{enumeration set union}" ($S$ s)}
\begin{indpar}
Returns union of \{{\tt e}\} and {\tt s}.
\end{indpar}

{\tt function $S$ r =
    $ma$\QMARK{} ($S$ s) "\ttmkey{+}{enumeration set union}" ($E$ e)}
\begin{indpar}
Returns union of \{{\tt e}\} and {\tt s}.
\end{indpar}

{\tt function $S$ r =
    $ma$\QMARK{} ($S$ s) "\ttmkey{-}{enumeration set union}" ($E$ e)}
\begin{indpar}
Returns the set difference of {\tt s} and \{{\tt e}\}.
\end{indpar}

{\tt function unswrd r = $ma$\QMARK{} \ttmkey{size of}{enumeration set} ($S$ s)}
\begin{indpar}
Returns the size of the set {\tt s} (number of elements in {\tt s}).
\end{indpar}

{\tt function $E$ r = $ma$\QMARK{} ($S$ s) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of enumeration set}
\begin{indpar}
Returns the {\tt i+1}'st element of {\tt s}, where the elements
of {\tt s} are taken in the order of their integer underlying values.
It is an error if {\tt i => size of (s)}.
\end{indpar}

{\tt function $S$ r = $S$ ($L$ ls)}
\begin{indpar}
Convert the enumeration list {\tt ls} to an enumeration set,
removing duplicate elements.
\end{indpar}

{\tt function $L$ r = $ma$\QMARK{} ($L$ ls1)
		    "\ttmkey{+}{enumeration list concatenation}" ($L$ ls2)}
\begin{indpar}
Returns the concatenation of {\tt ls1} and {\tt ls2}.
\end{indpar}

{\tt function $L$ r = $ma$\QMARK{} ($L$ ls)
                        "\ttmkey{-}{enumeration list difference}" ($S$ s)}
\begin{indpar}
Returns the list made by removing all elements from {\tt ls} that
are in {\tt s}.
\end{indpar}

{\tt function bool r = $ma$\QMARK{} ($E$ e)
                        \ttmkey{is in}{enumeration list} ($L$ ls)}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the list {\tt ls}, and
\TT{false} otherwise.
\end{indpar}

{\tt function $L$ r = $ma$\QMARK{} ($E$ e)
                        "\ttmkey{+}{enumeration list prepend}" ($L$ ls)}
\begin{indpar}
Returns the list made by prepending {\tt e} to {\tt ls}.
\end{indpar}

{\tt function $L$ r = $ma$\QMARK{} ($L$ ls)
                        "\ttmkey{+}{enumeration list append}" ($E$ e)}
\begin{indpar}
Returns the list made by appending {\tt e} to {\tt ls}.
\end{indpar}

{\tt function $L$ r = $ma$\QMARK{} ($L$ ls)
                        "\ttmkey{-}{enumeration list remove}" ($E$ e)}
\begin{indpar}
Returns the list made by removing the all occurrences of
{\tt e} in {\tt ls}.
\end{indpar}

{\tt function unswrd r =
    $ma$\QMARK{} \ttmkey{length of}{enumeration list} ($L$ ls)}
\begin{indpar}
Returns the length of the list {\tt ls} (number of elements in {\tt ls}).
\end{indpar}

{\tt function $E$ r = $ma$\QMARK{} ($L$ ls) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of enumeration list}
\begin{indpar}
Returns the {\tt i+1}'st list element of {\tt ls}.
It is an error if {\tt i => length of (ls)}.
\end{indpar}

{\tt function $L$ r = $L$ ($S$ s)}
\begin{indpar}
Convert the enumeration set {\tt s} to an enumeration list,
listing the elements of {\tt s} in order of their underlying values.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time enumeration
set and list variables.  If an implementation does
not implement run-time enumeration set and list variables,
enumeration set and list values computed at compile-time may
not be garbage collectible during the compilation.

\subsection{Type Values}
\label{TYPE-VALUES}

The type `\TT{type}' is a builtin enumeration type declared
by the builtin equivalent of:
\begin{indpar} \tt
define type \ttkey{std type} as unswrd with enum [0~..] \\
define abbreviation \ttkey{type} \ABV{} `std type' \\
type \ttkey{std missing type} = next enum // 0 \\
type \ttkey{std type} = next enum // 1 \\
function std type r = std \ttmkey{missing}{type}: \\
\hspace*{3em}r = std missing type
\end{indpar}
Each type is associated with a unique enumeration value
of type `\TT{type}', and this value can be used at both
compile and run time to test whether two `\TT{type}'s are
equal.

New types are declared by statements of the form:
\begin{center}
\tt \ttkey{define type} {\em type-name} \ldots{}
\end{center}
The {\em type-name} of a type can be used (1) before a {\em variable-name}
in a declaration, (2) as the name of an enumeration value in an
expression, or (3) as the name of a function in a {\em function-call}.

In general, values of one type $T1$ may be \key{explicitly converted} to another
type $T2$ if and only if an inline function with prototype:
\begin{center} \tt
function \ldots~$T2$ r = $T2$ ( \ldots~$T1$ v )
\end{center}
is defined, where the `\ldots{}' denote arbitrary qualifiers.
This function is not builtin, except in the case where
$T2$ and $T1$ are both names for the same type (and possibly the
same name), and in this
case the function just copies the value without changing its
type.

Given assignment statements
\begin{center}
\begin{tabular}{l}
\tt $Tw$ w = \ldots \\
\tt $Tu$ u = w \\
\end{tabular}
\end{center}

the compiler will make the assignment using
`\key{direct assignment}'\label{DIRECT-ASSIGNMENT} if possible, or
if not possible, will rewrite the second statement as
\begin{center}
\tt $Tu$ u = assign ( w )
\end{center}\label{EXPLICIT-ASSIGN}
in which case the assignment is said to be an
`\key{implicit conversion}'.  Direct assignment
can only be used if \skey{direct assignment rule}s are
satisfied, and one of these is
\begin{indpar}\begin{itemize}
\item[(DA1)]\label{DIRECT-ASSIGNMENT-TYPE-RULE}
In `{\tt u = w}' the types of {\tt u} and {\tt w}
must be identical.
\end{itemize}\end{indpar}
When direct assignment is used, the value of {\tt w} is copied
exactly to {\tt u} (or if there is no value because the common
type is derived from \TT{void}, nothing is done).
The other direct assignment rules involve qualifiers
(\pagref{DIRECT-ASSIGNMENT-QUALIFIER-RULES}) and cluster
members (\pagref{DIRECT-ASSIGNMENT-OF-CLUSTERS}).

The following is an example of an implied conversion {\tt assign}
function:

\begin{indpar}\begin{verbatim}
define type id as int32

// Allow id's to be implicitly converted to int32's:
//
function Qs int32 r = assign (| qualifiers Qs |) ( Qs id v ):
    *UNCHECKED* Qs r2 = int32 ( v )
    r = r2

// Example usage:
//
id file = ...
if file == 0:
    ...
\end{verbatim}\end{indpar}

Here {\tt Qs} is an implicit argument that copies the value qualifiers
(see \itemref{QUALIFIERS}) of the {\tt assign} prototype
result variable to the function
prototype result and prototype argument variables
(see \itemref{FUNCTION-PROTOTYPES-AND-CALLS}).
This code makes use of a builtin unchecked conversion from \TT{id} to \TT{int32}
that is created when by the {\tt define type} statement
(see \pagref{DEFINED-TYPE-UNCHECKED-CONVERSIONS}).

Implied {\tt assign}'s are not cascaded.  More specifically, in
\begin{center}
\tt $Tu$ u = assign ( w )
\end{center}
if {\tt assign} is explcitly written
and its result cannot be directly
assigned to {\tt u}, then an implied {\tt assign} would be added
making the statement
\begin{center}
\tt $Tu$ u = assign ( assign ( w ) )
\end{center}
But this is extra {\tt assign} is \underline{not} added
if the first {\tt assign} is implied.

Although the compiler cannot check this, it should be true
that if there are two different ways to implicitly convert from
one type to another, both ways should produce the same
result.  For example:
\begin{indpar}\begin{verbatim}
int16 v1 = ...
int32 v2 = v1
float64 v3 = v2
    // Implied conversions are v1 ---> v2 ---> v3.
float64 v4 = v1
    // Implied conversion is v1 ---> v4.

// v3 == v4 should be true.
\end{verbatim}\end{indpar}

There is a notion of one type being `\mkey{more specific}{type}' than
another type, and the relation of being more specific is required
to be a partial order compatible with implicit conversion.  Symbolically
we say that
\begin{center}
{\tt $T1~~\CNV~~T2$}
\end{center}%
\label{MORE-SPECIFIC-RELATION}
if $T1$ is more specific than $T2$, and that this is true if 
there exists some function with prototype of the form

\begin{center} \tt
function \begin{tabular}[t]{@{}l@{}}
	 \ldots{}~$T2$ r =
	 $ma$\QMARK{} \ttkey{assign}
	 ( \ldots{}~$T1$ v )
	 \end{tabular}
\end{center}
where \ldots{}~denotes possible qualifiers, and
the names {\tt r} and {\tt v} may be different
in the actual function prototype.
The notion of more specific
types is used by the
call-prototype matching rule
\ref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}
on page \pagref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}
to disambiguate function calls.

If for a set of types $\{T1,T2,\ldots\}$ there is a unique
type $T$ such that $T1\CNV T$, $T2\CNV T$, \ldots{}, then
$T$ is called the `\key{greatest lower bound}'\label{GREATEST-LOWER-BOUND}
of the set of types.

In general $T1~~\CNV~~T2$ implies that there is an implied conversion
of the above form from $T1$ to $T2$, but there are exceptions.
The builtin exceptions
are
\begin{center}
\begin{tabular}{lll}
\tt unswrd	& $\CNV$ & \tt intwrd \\
\tt intwrd	& $\CNV$ & \tt unsmax \\
\tt unsmax	& $\CNV$ & \tt intmax \\
\tt intmax	& $\CNV$ & \tt floatwrd \\
\end{tabular}
\end{center}
Note that this implies that
\begin{center}
\tt unswrd $\CNV$ intwrd $\CNV$ unsmax $\CNV$ intmax
           $\CNV$ floatwrd $\CNV$ floatmax
\end{center}
The only use of these exceptions is in
rule \ref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}
on page \pagref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}
by which the compiler favors function prototypes with
more specific argument types.

Functions can be overloaded based on the number and types
of their arguments, but also on the values of arguments that
are known at compile time.  For example, using this last,
many function declarations of the form
\begin{center}
\begin{tabular}{l}
{\tt function unsadr r = $ma$\QMARK{} size of ( type t == $T$ ):} \\
{\TS ~~~~r = $S$}
\end{tabular}
\end{center}
be coded, where $ma$ is the {\em module-abbreviation} of the
type name $T$, if any, and $S$ is the size in bytes of values of type $T$.
As a consequence `{\tt size of ($T$)}' can be used at compile
time to determine the size in bytes of values of an arbitrary type
$T$.

It is also possible to define a default function that is used when
function declarations with known prototypes are not applicable.
For example, the following declarations are builtin:
\begin{indpar}\begin{verbatim}
function bool r = std is uns ( type t == uns8 ):
    return true
function bool r = std is uns ( type t == uns16 ):
    return true
function bool r = std is uns ( type t == uns32 ):
    return true
function bool r = std is uns ( type t == uns64 ):
    return true
function bool r = std is uns ( type t == uns128 ):
    return true
function bool r = std is uns ( type t ):
    return false
\end{verbatim}\end{indpar}
where the last declaration is the default when none of the others
apply.  See
rule \ref{REQUIRED-ARGUMENTS-PREFERRED},
\pagref{REQUIRED-ARGUMENTS-PREFERRED}.
In this case we refer to the last declaration as the
`\key{default declaration}' and say that the default declaration
returns \TT{false}.

The following are defined automatically for a type $T$, where
$ma$ is the {\em module-abbreviation} of the module containing
the declaration of $T$, if $T$ has such a {\em module-abbreviation}.
Only some of these functions have a default declaration, but for
those that do, the default declaration is in the \TT{std} module.

\begin{indpar}
{\tt function bool r = std ( type t == $T$ ) \ttkey{is uns}} \\
{\tt function bool r = std ( type t == $T$ ) \ttkey{is int}} \\
{\tt function bool r = std ( type t == $T$ ) \ttkey{is float}} \\
{\tt function bool r = std ( type t == $T$ ) \ttkey{is numeric}} \\
{\tt function bool r = std ( type t == $T$ )
				\ttkey{is implemented numeric}}
\begin{indpar}
These functions test {\tt t} in the current scope to see if it is
an \TT{uns$x$} type, an \TT{int$x$} type, a \TT{float$x$} type,
any of these types, or any of these types for which arithmetic
and comparison operators are
`implemented' (see \pagref{IMPLEMENTED}).
The default declaration returns \TT{false}.
\end{indpar}
\end{indpar}

\begin{indpar}
{\tt function type r = $ma$\QMARK{} \ttkey{base type of} ( type t == $T$ )}
\begin{indpar}
Returns the base type of the type {\tt t}.  For defined and enumeration
types this is the associated base type from the defined type's
declaration.
The default declaration returns {\tt t} itself.
\end{indpar}

{\tt function type r = $ma$\QMARK{} \ttkey{underlying type of}
					( type t == $T$ )}
\begin{indpar}
If {\tt t} is a defined or enumeration type, returns
\begin{center}
{\tt underlying type of ( base type of ( t ) )}
\end{center}
The default declaration returns {\tt t} itself.
\end{indpar}

{\tt function unsadr r = $ma$\QMARK{} \ttkey{size of} ( type t == $T$ )}
\begin{indpar}
Returns the number of bytes in a value of type {\tt t}.
For defined and enumeration types it is the size of their underlying type
The size of \TT{void} is \TT{0}.
There is \underline{no} default declaration.
\end{indpar}

{\tt function unsadr r = $ma$\QMARK{} \ttkey{alignment of} ( type t == $T$ )}
\begin{indpar}
Returns the alignment of {\tt t}, a strictly positive integer.
The address of a value of type {\tt t} in RAM should
optimally be a multiple of the alignment.
The alignment of builtin types is their size.
For defined and enumeration types it is the alignment of their underlying type.
There is \underline{no} default declaration.
\end{indpar}

{\tt function bool r = $ma$\QMARK{} \ttkey{zero value OK} ( type t == $T$ )}
\begin{indpar}
Returns \TT{true} if a memory location holding a value of type $T$ can be
initialized to all zero bits.  Returns \TT{false} otherwise.
Must return \TT{false} if the underlying type of $T$ is \TT{void}.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{min value}} \\
{\tt function $T$ r = $ma$\QMARK{} \ttkey{max value}}
\begin{indpar}
Returns the minimum or maximum value of a type $T$.
These are defined only for number types and enumeration types,
and for enumeration types the values returned are the limits of
the type's {\em enum-range}.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{min unassigned value}} \\
{\tt function $T$ r = $ma$\QMARK{} \ttkey{max unassigned value}}
\begin{indpar}
Returns the minimum or maximum values not yet assigned to an
enumeration type $T$ by an {\em enum-assignment}.  Values
assigned by unchecked conversions are not considered.  If
no values have been assigned, the enumeration value corresponding
to {\em first-enum} is returned by `\TT{min unassigned value}'
and the enumeration value corresponding
to {\em last-enum} is returned by `\TT{max unassigned value}'.

These are defined only for enumeration types,

These values may change when more code is compiled or initialized.
You may only assume that constants of type $T$ whose values have
already been compiled or initialized are within
ranges bounded by these values, i.e., in the ranges:
\begin{center}
{\tt [ min value, min unassigned value )} \\
{\tt ( max unassigned value, max value ]}
\end{center}
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{missing value}}
\begin{indpar}
Returns a suitable missing value for type $T$.
Defined to return the largest possible value for builtin unsigned
integer types, the smallest (most negative) possible value for
builtin signed integer types, and \TT{NaN} for builtin
floating point number types.
May be defined by user for defined types.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{default value}}%
    \label{DEFAULT-VALUE-OF-TYPE}
\begin{indpar}
Returns a suitable default value for type $T$.
Defined to return \TT{0} for builtin number types.
May be defined by user for defined types.  For use by allocators,
such as a function that allocates a vector whose
elements are of type $T$, and the function wishes to give the elements an
initial default value.
\end{indpar}

{\tt function *UNCHECKED* $T$ r = $ma$\QMARK{} \ttkey{no value}}\label{NO-VALUE}
\begin{indpar}
Marks the result variable {\tt r} as not having any value.  An operation
that reads the variable value will have undefined behavior, hence the result is
{\tt *UNCHECKED*}, and the programmer is responsible for ensuring that
the value is never read (due to the values of other variables).
This function is builtin for \underline{all} types $T$.
\end{indpar}

\end{indpar}

The following function differs from the above in that it
consults an internal compiler database and does not depend
on multiple function declarations with specified argument values:

\begin{indpar}

{\tt function bool r = std ( type T1 ) "\ttkey{>}" ( type T2 )}
\begin{indpar}
Returns \TT{true} if and only if {\tt T1$\CNV$T2}, that is, $T1$ is
more specific than $T2$ (see \pagref{MORE-SPECIFIC-RELATION}).
\end{indpar}

\end{indpar}

\subsection{The Character Type}
\label{THE-CHARACTER-TYPE}

A `\key{character}' is a 32-bit UNICODE character.  It is
defined as the derived type:
\begin{indpar} \tt
define type~\ttkey{std character}~as uns32 \\
define abbreviation~\ttkey{character}~\ABV~`std character'
\end{indpar}

A character constant has the syntax:
\begin{indpar}
\emkey{character-constant}\label{CHARACTER-CONSTANT}
    :::= \TT{C"}{\em character-representative}\TT{"} \\
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}

This constant has type \TT{character} and value equal to the
single character represented.

The following functions are builtin:

\begin{indpar}

{\tt function character r = std \ttkey{character} ( uns32 c )}
\begin{indpar}
Returns the character with UNICODE character code equal to {\tt c}.
No check is made that {\tt c} is a legal UNICODE character code
or is non-zero.
\end{indpar}

{\tt function uns32 r = std \ttkey{code} ( character c )}
\begin{indpar}
Returns the UNICODE character code of the character {\tt c}.
\end{indpar}

function Qs~uns32 r =
		      \begin{tabular}[t]{@{}l@{}}
                      \ttmkey{assign}{of character} \\
                      \TS~~~~(| qualifiers Qs |) ( Qs~character c )
                      \end{tabular}
\begin{indpar}
Implied conversion (\pagref{IMPLIED-CONVERSION})
of character {\tt c} to its UNICODE character code.

Because of this implied conversion,
characters can be compared using \TT{<}, \TT{<=}, \TT{==},
\TT{!=}, \TT{=>}, or \TT{>}.
\end{indpar}

{\tt function character r = std \ttmkey{NUL}{character value}}
\begin{indpar}
Returns \TT{C"<0>"},
the character with UNICODE code \TT{0} that is conventionally
used to represent the missing \TT{character} value.
\end{indpar}

\end{indpar}

\subsection{The String Type}
\label{THE-STRING-TYPE}

A `\key{string}' is a vector of characters, that is,
of 32-bit UNICODE characters.
It is defined as a derived type:
\begin{indpar} \tt
define type \ttkey{std string} as adr \\
define abbreviation \ttkey{string} \ABV{} `std string'
\end{indpar}

A {\em quoted-string} lexeme is a constant of \TT{string} type
whose characters are those represented by the lexeme with
the addition of a \TT{NUL} character (code \TT{0}) at the end:
\begin{indpar}
\emkey{string-constant}\label{STRING-CONSTANT}
    :::= \TT{"}{\em character-representative\STAR{}}\TT{"} \\
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}


Strings are read-only, and their characters cannot be changed.

String variables and values are implemented at compile-time.
The following are compile-time functions involving strings:

\begin{indpar}

{\tt function string r =
    std \ttmkey{string}{of character} ( character c )}
\begin{indpar}
Returns the string containing the single character {\tt c}.
\end{indpar}

{\tt function string r =
    std \ttmkey{string}{of integer} ( intmax i )}
\begin{indpar}
Returns the string that is the decimal integer representation of
the integer {\tt i}.  The value returned contains no high order
zeros or commas.  Non-negative values have no sign.
\end{indpar}

{\tt function string r =
    std ( string s1 ) "\ttmkey{+}{of strings}" ( string s2 )}
\begin{indpar}
Returns the concatenation of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function bool r =
    std ( string s1 ) "\ttmkey{<}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{<=}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{==}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{!=}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{=>}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{>}{of strings}" ( string s2 )}
\begin{indpar}
Returns whether {\tt s1} is less than, less than or equal to,
equal to, not equal to, greater than or equal to, or greater than
{\tt s2}.  Ordering of strings is lexical (note ordering of
characters is by character code).
\end{indpar}

{\tt function string r = std \ttmkey{null}{string value}}
\begin{indpar}
Returns a particular zero length \TT{string} that is conventionally
used to represent the missing \TT{string} value.
Although the string is of zero length, it does have one character:
the \TT{NUL} character at its end.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{string} ( string s )}
\begin{indpar}
Returns the length of {\tt s}, the number of characters in {\tt s}
\underline{not counting} the \TT{NUL} character at the end.
\end{indpar}

{\tt function character r = std ( string s ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st character of {\tt s}.

It is a programming error if {\tt i > length of ( s )}.

If {\tt i == length of ( s )}
the \TT{NUL} at the end of the string is returned.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time string
variables.  If an implementation does
not implement run-time string variables,
string values computed at compile-time may
not be garbage collectible during the compilation.

\subsection{The Name Type}
\label{THE-NAME-TYPE}

A `\key{name}' value is a vector of strings.  If the value is
a legal name as defined in Section~\itemref{NAMES}, the
strings are its {\em name-items} with a \TT{null} string appended.
Note that {\em natural-number} {\em name-items} are represented
by strings of digits and not by integers.

An element of a name value may be any string, so name values
may not be legal source code {\em names} as defined on \pagref{NAME}.
When a name value is used as a {\em name} in a compilation,
it is a compilation error if the value is not a source code {\em name}.

The \TT{name} type is is defined as a derived type:
\begin{indpar} \tt
define type \ttkey{std name} as adr \\
define abbreviation \ttkey{name} \ABV{} `std name'
\end{indpar}

A sequence of {\em name-items} in \TT{`~'} quotes is a \TT{name}
constant whose strings are the {\em name-items}
with the \TT{null} string appended:
\begin{indpar}
\emkey{name-constant}\label{NAME-CONSTANT}
    ::= \TT{`}{\em name-item}\STAR{}\TT{'} \\
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

Name values are read-only, and their elements cannot be changed.

Name variables and values are implemented at compile-time.
The following are compile-time functions involving names:

\begin{indpar}

{\tt function name r = \ttmkey{name}{of string} ( string s )}
\begin{indpar}
Returns the name containing just {\tt s} as its only {\em name-item}.
A \TT{null} is appended to the end of the name.
No check is made that {\tt s} is a legal {\em name-item}.
\end{indpar}

{\tt function name r = ( name n1 ) "\ttmkey{+}{of names}" ( name n2 )}
\begin{indpar}
Returns the concatenation of {\tt n1} and {\tt n2}.
\end{indpar}

{\tt function bool r = ( name n1 ) "\ttmkey{<}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{<=}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{==}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{!=}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{=>}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{>}{of names}" ( name n2 )}
\begin{indpar}
Returns whether {\tt n1} is less than, less than or equal to,
equal to, not equal to, greater than or equal to, or greater than
{\tt n2}.  Ordering of names is lexical.
\end{indpar}

{\tt function name r = std \ttmkey{null}{name value}}
\begin{indpar}
Returns a particular zero length \TT{name} that is conventionally
used to represent the missing \TT{name} value.
Although the name is of zero length, it does have one string,
the \TT{null} string at its end.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{name} ( name n )}
\begin{indpar}
Returns the length of {\tt n}, the number of strings in {\tt n}
\underline{not counting} the \TT{null} string at the end.
\end{indpar}

{\tt function string r = std ( name n ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st string of {\tt n}.

It is a programming error if {\tt i > length of ( n )}.

If {\tt i == length of ( n )}
the \TT{null} at the end of the name is returned.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time name
variables.  If an implementation does
not implement run-time name variables,
name values computed at compile-time may
not be garbage collectible during the compilation.

\subsection{Name Sets and Lists}
\label{NAME-SETS-AND-LISTS}

A \key{name set} is a set of names.
A \key{name list} is a list of names.  The syntax
for name set and list constants is:
\begin{indpar}
\emkey{name-set-constant}\label{NAME-SET-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{~\}} \\
    $|$ &\TT{\{} {\em name-value}
                   \{ \TT{,} {\em name-value} \}\STAR{} \TT{\}} \\
    \end{tabular} \\
\emkey{name-list-constant}\label{NAME-LIST-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{[~]} \\
    $|$ &\TT{[} {\em name-value}
                   \{ \TT{,} {\em name-value} \}\STAR{} \TT{]} \\
    \end{tabular} \\
\emkey{name-value} ::= {\em compile-time-name-expression}
\end{indpar}

The order in which names are given in a {\em name-set-constant}
does not matter, and duplicate names in the set are eliminated.
Thus
\begin{center}
`{\tt \{`X1', `X2'\} == \{`X2', `X1'\}}'\\
and\\
`{\tt \{`X1', `X1'\} == \{`X1'\}}'.
\end{center}

The order in which values are given in an {\em name-list-constant}
does matter, and duplicates are not combined.
Thus
\begin{center}
`{\tt [`X1', `X2'] != [`X2', `X1']}'\\
and\\
`{\tt [`X1', `X1'] != [`X1']}'.
\end{center}

Name set and list values are used in code expansions.
For example,
\begin{indpar}\begin{verbatim}
include for n in [`x[1]', `x[2]', `x[3]' ]:
    int n = 0
\end{verbatim}\end{indpar}

Name sets and lists can be stored in variables of the builtin name set
or list types:
\begin{indpar} \tt
define types: \\
\TS~~~~\ttkey{std name set} as adr \\
\TS~~~~\ttkey{std name list} as adr \\
define abbreviations: \\
\TS~~~~\ttkey{name set} \ABV{} `std name set' \\
\TS~~~~\ttkey{name list} \ABV{} `std name list'
\end{indpar}

The following \TT{name set} functions are builtin:

\begin{indpar}
{\tt function name set r = std (name set s1)
                           "\ttmkey{+}{name set union}" ( name set s2 )}
\begin{indpar}
Returns the union of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function name set r = std ( name set s1 )
                           "\ttmkey{*}{name set intersection}" ( name set s2 )}
\begin{indpar}
Returns the intersection of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function name set r = std ( name set s1 )
                           "\ttmkey{-}{name set difference}" ( name set s2 )}
\begin{indpar}
Returns the set difference of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function bool r = std (name e) \ttmkey{is in}{name set} ( name set s )}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the set {\tt s}, and
\TT{false} otherwise.
\end{indpar}

{\tt function name set r = std (name n)
                           "\ttmkey{+}{name set union}" ( name set s )}
\begin{indpar}
Returns union of \{{\tt n}\} and {\tt s}.
\end{indpar}

{\tt function name set r = std ( name set s )
                           "\ttmkey{+}{name set union}" (name n)}
\begin{indpar}
Returns union of \{{\tt n}\} and {\tt s}.
\end{indpar}

{\tt function name set r = std ( name set s )
                           "\ttmkey{-}{name set difference}" (name n)}
\begin{indpar}
Returns the set difference of {\tt s} and \{{\tt n}\}.
\end{indpar}

{\tt function unswrd r = std \ttmkey{size of}{name set} ( name set s )}
\begin{indpar}
Returns the size of {\tt s}, the number of names in {\tt s}.
\end{indpar}

{\tt function name r = std ( name set s ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st name of {\tt s}, where names in {\tt s}
are taken in sorted order.

It is a programming error if {\tt i => size of ( s )}.
\end{indpar}

{\tt function name set r = std \ttkey{name set} ( name list ls )}
\begin{indpar}
Converts {\tt ls} from a list to a set, removing duplicate elements.
\end{indpar}

\end{indpar}

The following \TT{name list} functions are builtin:

\begin{indpar}
{\tt function \begin{tabular}[t]{@{}l@{}}
              name list r = \\
	      std (name list ls1)
                        "\ttmkey{+}{name list concatenation}" (name list ls2)
	      \end{tabular}}
\begin{indpar}
Returns the concatenation of {\tt ls1} and {\tt ls2}.
\end{indpar}

{\tt function \begin{tabular}[t]{@{}l@{}}
              name list r = \\
	      std (name list ls)
                        "\ttmkey{-}{name list difference}" (name set s)
	      \end{tabular}}
\begin{indpar}
Returns the list made by removing all elements from {\tt ls} that
appear anywhere in {\tt s}.
\end{indpar}

{\tt function bool r = std (name n) \ttmkey{is in}{name list} (name list ls)}
\begin{indpar}
Returns \TT{true} if {\tt n} is an element of the list {\tt ls}, and
\TT{false} otherwise.
\end{indpar}

{\tt function name list r = std (name n)
                        "\ttmkey{+}{name list prepend}" (name list ls)}
\begin{indpar}
Returns the list made by prepending {\tt n} to {\tt ls}.
\end{indpar}

{\tt function name list r = std (name list ls)
                        "\ttmkey{+}{name list append}" (name n)}
\begin{indpar}
Returns the list made by appending {\tt n} to {\tt ls}.
\end{indpar}

{\tt function name list r = std (name list s)
                        "\ttmkey{-}{name list remove}" (name n)}
\begin{indpar}
Returns the list made by removing the all occurrences of
{\tt n} in {\tt ls}.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{name list} ( name list ls )}
\begin{indpar}
Returns the length of {\tt ls}, the number of names in {\tt ls}.
\end{indpar}

{\tt function name r = std ( name list ls ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st name of {\tt ls}.

It is a programming error if {\tt i => length of ( s )}.
\end{indpar}

{\tt function name list r = std \ttkey{name list} ( name set s )}
\begin{indpar}
Converts {\tt s} from a set to a list, where elements of {\tt s}
are listed in sorted order in the result.
\end{indpar}

\end{indpar}

\subsection{Contexts}
\label{CONTEXTS}

Contexts (\pagref{CONTEXT}) exist at compile-time and can be
stored in compile-time variables.  A context value designates a point
in the program code, i.e., a `\key{code point}'.

The \TT{context} type is
defined by
\begin{indpar} \tt
define type \ttkey{std context} as adr \\
define abbreviation \ttkey{context} \ABV{} `std context'
\end{indpar}

{\em Block-assignment-statements} (\itemref{BLOCK-ASSIGNMENT-STATEMENTS})
can specify a \TT{context} in which to compile the statements of
their block.

The following functions compute contexts:

\begin{indpar}

{\tt function context r = std \ttkey{current context}}
\begin{indpar}
Returns the context in effect just before
the statement containing the function call.
\end{indpar}

{\tt function context r = std \ttkey{call context}}
\begin{indpar}
Returns the context in effect just before
the statement containing the {\em function-call} that
invoked the current inline function.
\end{indpar}

{\tt function context r = std \ttkey{declaration context}}
\begin{indpar}
Returns the context in effect just before
the statement containing the {\em function-declar\-a\-tion} of
inline function whose call is currently being compiled.
\end{indpar}

\end{indpar}

Context values will be needed at run-time if the program contains
compile-and-run statements.

In order for a context value to be available at run-time, it
must be returned by one of these functions or be the context of
a compile-and-run statement (\pagref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}).
If a context value is stored in a variable by one of these functions,
then it need not be available at run time if it can be proved that the
variable value will not be available at run time.  A variable value is
available at run time only if the variable is exported, or if the
variable is in a context that is
available at run time, or if the variable value is copied into another
variable that may be available at run time, or if the variable value is
written into memory.\footnote{With modern memories is it not unreasonable
to make all contexts available at runtime by storing them
in a disk file mapped into memory and paged in only as needed.}

\section{Qualifiers}
\label{QUALIFIERS}

Variables may be qualified by \skey{qualifier}s, which precede the
type when a variable is declared.  There are six builtin qualifiers:
\TT{*MEM*}, \TT{*WRITABLE*}, \TT{*STACK*}, \TT{*UNCHECKED*},
\TT{*DEFERRED*}, and \TT{*OPTIONAL*}.
Most of these have special effects
described in Section~\itemref{BUILTIN-QUALIFIERS}.
There is also a builtin method for defining trace qualifiers which
have special effects.
Other qualifiers that have no special effects
may be defined, and are typically used to add an
additional layer of type checking that is somewhat orthogonal to
types.

Syntactically {\em qualifier-names} immediately precede the {\em type-names}
that are before {\em variable-names}.  A simple example is:
\begin{indpar}\begin{verbatim}
protected value qualifier fee
function fee int32 result = F ( int32 value ):
    // Declares function F that computes a result of
    // with qualifier fee.
    //
    ... [Function body omitted] ...
function int32 result = G ( fee int32 value ):
    // Declares function G that requires its argument to
    // have qualifier fee.
    //
    ... [Function body omitted] ...

// Example usage:
//
int32 x1 = ...
fee int32 x2 = F ( x1 )      // Legal; F produces result
                             // with qualifier fee.
int32 x3 = F ( x1 )          // Legal; F attaches protected
                             // qualifier fee automatically
                             // to x3.
int32 y1 = G ( x1 )          // Illegal; G requires argument
                             // to have qualifier fee.
int32 y2 = G ( x2 )          // Legal; x2 has qualifier fee.
int32 y3 = G ( x3 )          // Legal; x3 has qualifier fee.

\end{verbatim}\end{indpar}

Qualifier definitions reference function prototypes and function
calls, which are described in detail later in this document
(\itemref{FUNCTION-PROTOTYPES-AND-CALLS}).  However for the
purposes of this section reference to the above example may suffice.
In this example
\begin{center}
{\tt function \ldots{} result = \ldots{} ( \ldots{} value )}
\end{center}
is a function prototype with one \underline{prototype} result variable
`{\tt result}' and one \underline{prototype} argument variable `{\tt value}'.
A statement like `{\tt int32 x3 = F ( x1 )}' includes a function
call with \underline{actual} result variable `{\tt x3}' and
\underline{actual} argument `{\tt x1}'.

Qualifiers may be declared by:
\begin{indpar}
\emkey{qualifier-declaration}\label{QUALIFIER-DECLARATION} \\
\hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define} {\em qualifier-attribute}\PLUS{} \ttkey{qualifier}
           {\em defined-qualifier-name} \\
    $|$ & {\em trace-qualifier-declaration}
    	  ~~~ [see \pagref{TRACE-QUALIFIERS}]
    \end{tabular} \\
\emkey{qualifier-attribute}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{value} \\
    $|$ & \ttkey{variable} \\
    $|$ & \ttkey{protected} \\
    $|$ & \ttkey{addable} \\
    $|$ & \ttkey{deletable} \\
    \end{tabular} \\
\emkey{defined-qualifier-name} ::= {\em qualifier-name} \\
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME}

where
\begin{enumerate}
\item
No {\em qualifier-name} may be a prefix of
any {\em type-name},
any {\em deferred-variable} (\pagref{DEFERRED-VARIABLE})
or any {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME}).
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.
\item
No qualifier name may begin with `\TT{next}'
or `\TT{previous}'.
\end{enumerate}
\end{indpar}

The builtin defined qualifiers are in effect declared by:
\begin{indpar}
{\tt protected variable qualifier~}\ttakey{MEM} \\
{\tt protected variable qualifier~}\ttakey{WRITABLE} \\
{\tt protected addable value qualifier~}\ttakey{STACK} \\
{\tt variable qualifier~}\ttakey{UNCHECKED}
\end{indpar}

In addition there are several builtin `\skey{prototype qualifier}s'
that can only be used in function prototypes:
\begin{center}
\TT{*DEFERRED*} \\
\TT{*OPTIONAL*} \\
\end{center}
These are qualifiers only syntactically, and have their own semantics
not related to that of the defined qualifiers.

Each qualifier is associated with a unique enumeration value,
and this value can be used at both
compile and run time to test whether two `\TT{qualifier}'s are
equal.
The type `\TT{qualifier}' is a builtin enumeration type declared
by:
\begin{indpar} \tt
define type \ttkey{std qualifier} as unswrd with enum [0~..] \\
define abbreviation \ttkey{qualifier} \ABV{} `std qualifier' \\
qualifier \ttkey{std missing qualifier} = next enum // 0 \\
function std qualifier r = std \ttmkey{missing}{qualifier}: \\
\hspace*{3em}r = std missing qualifier
\end{indpar}

The {\em qualifier-name} of a qualifier
can be used (1) before a {\em type-name}
in a declaration, or (2) as the name of an enumeration value in an
expression.

A `\key{variable qualifier}'\label{VARIABLE-QUALIFIER}
qualifies variables but not values.
If $Q$ is a variable qualifier attached to a variable {\tt v}, $Q$
does \underline{not} follow the value of {\tt v} when that value
is copied to another variable.

A `\key{value qualifier}'\label{VALUE-QUALIFIER}
qualifies values, although the qualifier
is attached to variables that hold these values.
If $Q$ is a value qualifier attached to a variable {\tt v}, $Q$
\underline{may} follow the value of {\tt v} to another variable
when that value is copied to that other variable.

A qualifier must be a variable qualifier or a value qualifier,
but can not be both.

Given an assignment statement `$v1$ \TT{=} $v2$', if $v1$ has
a qualifier that $v2$ does not have, that qualifier is said to
have been \mkey{added}{by assignment} by the assignment.
If $v1$ does not have a qualifier that $v2$ does have, then
that qualifier is said to have been \mkey{deleted}{by assignment}
by the assignment.
An \mkey{addable}{qualifier} qualifier is a qualifier that can be added by
assignments, and a \mkey{deletable}{qualifier} qualifier is a qualifier
that can be deleted by assignments.  A qualifier that is neither
addable or deletable must be attached to $v1$ if and only if it is
attached to $v2$.

A `\key{protected qualifier}' can be attached in source code
to an assignment result variable only if the assignment statement
takes the form of a function call and the assignment statement
result variable
matches a prototype result variable that has the qualifier.  Furthermore,
in this case, if the qualifier is not explicitly encoded for the
assignment statement result variable, it will be automatically added
to that variable.
This is the only way to attach a `\key{protected variable qualifier}'
to a variable.  However, as described below, protected value qualifiers
may also be propagated by assignments or implied conversion operations.

TBD

An assignment statement of the form
\begin{center}
\tt $Qvars$  $Qvals$ $T$ x = y
\end{center}
where {\tt y} is of type $T$, $Qvars$ is a possibly empty list
of variable qualifiers, and $Qvals$ is a possibly empty list of
value qualifiers, behaves as if it had the form
\begin{center}
\tt $Qvars$ $Qvals$ $T$ x = assign ( y )
\end{center}
The \TT{assign} function may be defined explicitly, as is necessary
for clusters (see \itemref{CLUSTERS}).  If not defined explicitly,
it behaves as if it has the function prototype
\begin{center} \tt
function ~$Qvals$ ~$T$ r = \ttkey{assign} ( $Qvals$~$T$ v )
\end{center}
and merely copies the value of {\tt v} to {\tt r}.
Thus the \underline{value} qualifiers of {\tt x} are treated
as prototype argument qualifiers with {\tt y} the actual argument
corresponding to {\tt v}.  The \underline{variable} qualifiers
of {\tt y} are ignored in these assignments.  Variable
qualifiers of {\tt x} are allowed only if they are addable and not
protected.

If {\tt y} does \underline{not} have type $T$, the statement
\begin{center}
\tt $Qvars$  $Qvals$ $T$ x = y
\end{center}
compiles as
\begin{center}
\tt $Qvars$  $Qvals$ $T$ x = assign ( y )
\end{center}
where the `{\tt assign}' function must be defined by
the user or builtin.  A typical implied conversion prototype
for converting values of type $T1$ to values of type $T2$ is:
\begin{center} \tt
function \ldots~Qs~$T2$ r =
		      \begin{tabular}[t]{@{}l@{}}
                      \ttkey{assign} \\
                      \TS~~~~(| qualifiers Qs |) ( Qs~$T1$ v )
                      \end{tabular}
\end{center}
which specifies that the $Qs$ argument is implicitly assigned
to the set of \underline{value} qualifiers of the actual
result variable (in this case $Qvals$).  See
the {\em qualifiers-argument-declaration} discussion on
\pagref{QUALIFIERS-ARGUMENT-DECLARATION-DISCUSSION}
for more details.

As a consequence, assignment statements and implied conversions
may remove required value qualifiers but not add them, and
may add prohibited value qualifiers
but not remove them.  Assignment statements and implied conversions
may remove variable qualifiers but may only add unprotected variable
qualifiers.

Required value qualifiers may be added and prohibited value qualifiers
removed by an unchecked builtin function with the following prototype:
\begin{center} \tt
function \begin{tabular}[t]{@{}l@{}}
         \TT{*UNCHECKED*}~Qrs~T r = \ttkey{re-qualify} \\
         \TS~~~~(| qualifiers Qrs, qualifiers Qvs, type T |) \\
	 \TS~~~~( Qvs~T v ) \\
	 \end{tabular}
\end{center}

This function copies the value of {\tt v} to {\tt r}.
This function \underline{cannot} add protected \underline{variable} qualifiers.

Some examples involving the \TT{*MEM*} and \TT{*UNCHECKED*}
builtin variable qualifiers are:
\begin{indpar}\begin{verbatim}
// Builtin declarations:
//     protected variable qualifier *MEM*
//     required variable qualifier *UNCHECKED*

// Function to read the int32 value at RAM address A.
// Not type safe as argument A not vetted.
//
function *MEM* int32 r, adr r.adr = read ( adr A ):
    r.adr = A
*MEM* int32 x = read (1000)
    // Creates variable adr x.adr = 1000.  The *MEM* variable
    // qualifier is special: x is not given a value by
    // assignment, but automatically gets its value by
    // reading location x.adr.
int32 y = read(2000)
    // Ditto but *MEM* qualifier is automatically added to y.
int32 z = x
    // The *MEM* variable qualifier on x is NOT propagated
    // to z.

*UNCHECKED* uns32 w = uns32 ( z )
    // *UNCHECKED* is a require variable qualifier and must
    // be written into code.  It is required to be on the
    // result variable of an unchecked conversion from
    // int32 to uns32 that just changes the type of the
    // 32 bit value without changing the value.
uns32 v = w
    // The *UNCHECKED* variable qualifier on w is NOT
    // propagated to v.
\end{verbatim}\end{indpar}

A call to {\tt read} returns a cluster of
two variables, with only the root {\tt r} of the cluster being
specified explicitly by the call, and the child {\tt r.adr} being
created implicitly by the call: see \itemref{CLUSTERS}.
The \TT{*MEM*} qualifier has the special property that a value of a \TT{*MEM*}
variable {\tt r} is not given explicitly, but is read implicitly from
RAM memory using the address in {\tt r.adr}: see \itemref{THE-MEM-QUALIFIER}.
As a protected variable qualifier, \TT{*MEM*} can only be attached to
a variable by making the variable a result variable of an inline
function call.

Some examples involving the \TT{*STACK*} prohibited protected value
qualifier are:
\begin{indpar}\begin{verbatim}
// Builtin declaration:
//     protected prohibited value qualifier *STACK*
//
// Assume:
//    function *UNCHECKED* *STACK* adr r = allocate to stack
//                                         ( unswrd size )
//        // Actual allocate to stack function returns more
//        // complex cluster.
//
*UNCHECKED* adr address of x =
               allocate to stack ( size of int32 )
    // address of x is automatically given the `*STACK*'
    // qualifier.

function *MEM* int32 r, adr r.adr = read ( adr A ):
    r.adr = A
function *MEM* int32 r, adr r.adr = read from stack 1
                                        ( *STACK* adr A ):
    *UNCHECKED* adr a = re-qualify ( A )
    r.adr = a
function *MEM* int32 r, *STACK* adr r.adr = read from stack 2
                                        ( *STACK* adr A ):
    r.adr = A

int32 x1 = read ( address of x )
    // Compiler error: `read' prototype argument does not
    // have prohibited `*STACK*' qualifier call argument has.
int32 x2 = read from stack 1 ( address of x )
int32 x3 = read from stack 2 ( address of x )
    // Both legal: `read from stack ...' prototype and call
    // arguments both have `*STACK*' qualifier.
\end{verbatim}\end{indpar}

The \TT{*STACK*} qualifier is special in that it is not allowed to qualify
values returned by an out-of-line function call.
This qualifier is then attached to addresses of data allocated
to the stack frame of the function call, because these addresses become
invalid when the call returns.  There are other situations where
a \TT{*STACK*} value cannot qualify a variable value because the
lifetime of the variable is longer than the lifetime of the
stack frame in used when the variable is set:
see \itemref{THE-STACK-QUALIFIER} for details.

\section{Expressions}
\label{EXPRESSIONS}

Expressions compute values and appear inside statements where a value is needed.
For example, in a {\em simple-assignment-statement} of the form
\begin{indpar}
{\em qualifier-name}\STAR{} ~ {\em type-name} ~ {\em variable-name}
	~ {\tt =} ~ {\em expression}
\end{indpar}
the {\em expression} computes a value to store in the variable.

The parser and compiler convert {\em expressions} and into statements
that have no {\em expressions} except for {\em variable-names}
and {\em function-calls} in statements of the form
\begin{indpar}
\ldots{} ~ {\tt =} ~{\em constant} \\
\ldots{} ~ {\tt =} ~{\em variable-name} \\
\ldots{} ~ {\tt =} ~{\em function-call}
\end{indpar}
where \ldots{} is a list of result variables (which is optional
for {\em function-calls}).

The builtin operators that can appear in an expression in approximate
precedence order (lowest precedence topmost) are:

\begin{center}

\begin{tabular}{c}
\TT{if ~ else} \\
selection operators
\end{tabular}

\medskip

\begin{tabular}{c}
\TT{and ~ or} \\
\TT{not} \\
logical operators
\end{tabular}

\medskip

\begin{tabular}{c}
\TT{== ~ != ~ > ~ =>\footnotemark ~ < ~ <=} \\
comparison operators
\end{tabular}
\footnotetext{L-language uses \TT{=>} so {\tt x => y}
whereas the C language uses \TT{>=} so {\tt x >= y}.}

\medskip

\begin{tabular}[t]{c}
\TT{+ ~ -} \\
summation (binary) operators
\\[2ex]
\TT{* ~ / ~ div ~ mod ~ rem } \\
product operators
\\[2ex]
\TT{\textasciicircum} \\
exponent operator
\\[2ex]
\TT{+ ~ -} \\
sign (unary) operators
\end{tabular}
~~~~~
\begin{tabular}[t]{c}
\TT{\& ~ | ~ xor ~ <{}< ~ >{}>} \\
\TT{!} \\
bitwise operators
\end{tabular}

\end{center}

However precedence is only a rough guide to the syntax of L-Language
operators.

Two operators are said to be mixed in an expression if both are outside
parenthesized subexpressions of the expression.
The logical operators other than `\TT{not}' cannot be mixed with
each other, and similarly for the product operators and the
bitwise operators other than \TT{!} (bitwise complement).  Bitwise
operators cannot be mixed with summation, product, exponent, or sign operators.

\subsection{Variable Names}

A {\em variable-name} names a variable that is allocated to
the current function frame.
The syntax is:

\begin{indpar}
\emkey{variable-name}
	::= {\em variable-base-name} {\em member-selector}\STAR{} \\
\emkey{variable-base-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript } \\
\emkey{member-name}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark}
			    or {\em quoted-separator}
			\end{tabular} \\
\emkey{member-subscript}\label{MEMBER-SUBSCRIPT}
    ::= {\em enum-list-constant} \\
{\em enum-list-constant} ::= see \pagref{ENUM-LIST-CONSTANT} \\
{\em name} ::= see \pagref{NAME}
\end{indpar}

Variables with names containing {\em member-selectors} are
cluster members (\itemref{CLUSTERS}) and can only be allocated
to memory by {\em function-prototypes} and {\em generic-prototypes}.
All other variables can be allocated by {\em assignment-statements}
(\itemref{ASSIGNMENT-STATEMENTS}).

L-language has an extension,
the \ikey{\LSTAR-language}{L*-language}\label{LSTAR-LANGUAGE},
that allows variables with {\em member-selectors} to be allocated
by {\em assignment-statements}.  The \LSTAR-language is significantly
less type-safe than the L-language, but is needed by the compiler
as the output language for expanding inline function calls.

\subsection{Expression Syntax}
\label{EXPRESSION-SYNTAX}

Parsing converts expressions into function calls in two steps.
The first step identifies operators.  The second step inserts
implied parentheses, thus identifying function call argument lists.
At the end all the operators are quoted converting them into
function terms (i.e., names of functions).

Insertion of impliled parentheses is driven by an operator
precedence table.  This in turn corresponds to operator
syntax equations, which in turn can be derived from parser
instructions.

\subsubsection{Operator Identification}
\label{OPERATOR-IDENTIFICATION}

The parser identifies operators by a left-to-right scan of
an expression, choosing the longest operator that matches the
beginning of the yet unscanned input at each stage, and skipping
the first lexeme of the yet unscanned input if no operator matches.
Then the parser parses expressions according to the syntax:

\begin{indpar}
\emkey{expression}\label{EXPRESSION} ::= \\
\hspace*{0.5in} {\em infix-operand}
	  \{ {\em infix-operator} {\em infix-operand} \}\STAR{}
\\[0.5ex]
\emkey{infix-operand} ::=
    {\em prefix-operator}\STAR{} {\em primary} {\em postfix-operator}\STAR{}
\\[0.5ex]
\emkey{primary}\label{PRIMARY}
    \begin{tabular}[t]{rl}
    ::= & {\em subexpression} \\
    $|$ & {\em argument-list}\STAR{}
	      \begin{tabular}[t]{l}
	      {\em primary-item}\PLUS{}\\
	      \{ {\em argument-list}\PLUS{}
		 {\em primary-item}\PLUS{} \}\STAR{} \\
	      {\em argument-list}\STAR{} \\
	      \end{tabular} \\
    $|$ & {\em argument-list} {\em argument-list}\PLUS{} \\
    $|$ & {\em bracketed-constant}
    \end{tabular}
\\[0.5ex]
\emkey{subexpression}
    \begin{tabular}[t]{rl}
    ::= & {\em module-abbreviation} ~ \TT{(} {\em expression} \TT{)} \\
    $|$ & \TT{(} {\em expression} \TT{)} \\
    \end{tabular}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
\emkey{primary-item}\label{PRIMARY-ITEM}
    ::= {\em word} $|$ {\em number} $|$ {\em quoted-string}
\\[0.5ex]
\emkey{argument-list}\label{ARGUMENT-LIST}
    \begin{tabular}[t]{rl}
    ::= & \TT{( )} \\
    $|$ & \TT{(} {\em expression} \{ \TT{,} {\em expression} \}\STAR{} \TT{)} \\
    $|$ & \TT{[ ]} \\
    $|$ & \TT{[} {\em expression} \{ \TT{,} {\em expression} \}\STAR{} \TT{]} \\
    $|$ & \TT{(| |)} \\
    $|$ & \TT{(|} {\em expression} \{ \TT{,} {\em expression} \}\STAR{}
          \TT{|)} \\
    \end{tabular}
\\[0.5ex]
\emkey{bracketed-constant}\label{BRACKETED-CONSTANT}
    \begin{tabular}[t]{rl}
    ::= & \TT{[ ]} \\
    $|$ & \TT{[} {\em range}
          \{ \TT{,} {\em range} \}\STAR{} \TT{]} \\
    $|$ & \TT{\{ \}} \\
    $|$ & \TT{\{} {\em range}
          \{ \TT{,} {\em range} \}\STAR{} \TT{\}} \\
    $|$ & \TT{`} {\em name-item}\STAR{} \TT{'}
    \end{tabular}
\\[0.5ex]
\emkey{range}\label{RANGE}
    \begin{tabular}[t]{rl}
    ::= & {\em expression} \\
    $|$ & {\em expression} \TT{..} {\em expression} \\
    $|$ & {\em expression} \TT{..} \\
    $|$ & \TT{..} {\em expression} \\
    \end{tabular}
\\[0.5ex]
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

Operators are classified as \key{infix}, \key{prefix}, or
\key{postfix}.  An operator can be more than one of these.
When a sequence of consecutive operators occurs, either
\begin{itemize}
\item[(1)] The sequence is before the first {\em primary}
in the expression and consists of just prefix operators.
\item[(2)] The sequence is between {\em primaries}
in the expression
and contains a single infix operator optionally
preceeded by just postfix operators and optionally followed by
just prefix operators.
\item[(3)] The sequence is after the last {\em primary}
in the expression and consists of
just postfix operators.
\end{itemize}

Then
\begin{indpar}[0.5in]
\begin{itemize}
\item[(Rule A)] If operator fixity cannot be assigned so the (1-3)
above are true, the expression is illegal and a compile error.
\item[(Rule B)] If operator fixity can be assigned in \underline{more than one}
way so the (1-3) above are true, the expression is illegal and a compile error.
\end{itemize}
\end{indpar}

\newcommand{\IX}[1]{$_{\bullet}$\TT{#1}$_{\bullet}$}
\newcommand{\RX}[1]{\TT{#1}$_{\bullet}$}
\newcommand{\LX}[1]{$_{\bullet}$\TT{#1}}

The fixity of an operator is considered to be part of
the identification of the operator, so prefix \TT{+}
and infix \TT{+} are different operators.
We denote the fixity of \TT{$o$} as follows:
\begin{center}
\begin{tabular}{ll}
\LX{$o$} & postfix \TT{$o$} \\
\IX{$o$} & infix \TT{$o$} \\
\RX{$o$} & prefix \TT{$o$} \\
\end{tabular}
\end{center}

Then \IX{+} and \RX{+} are builtin operators, but \LX{+}
is not builtin (the user could define it).  Suppose the
user defined \LX{@} and \IX{@}.  Then we would have the
following examples:

\begin{center}
\begin{tabular}{lcll}
\tt x + + y	& parses as & \tt x \IX{+} \RX{+} y \\
\tt x @ @ y	& parses as & \tt x \LX{@} \IX{@} y \\
\tt x + y +	& cannot parse & & and violates Rule A \\
\tt @ x @ y	& cannot parse & & and violates Rule A \\
\tt x @ + y	& parses as & \tt x \IX{@} \RX{+} y \\
		& or        & \tt x \LX{@} \IX{+} y
			    & and violates Rule B \\
\end{tabular}
\end{center}

\subsubsection{The Builtin Operator Precedence Table}
\label{THE-BUILTIN-OPERATOR-PRECEDENCE-TABLE}

\begin{figure}[p]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|}
\hline
first & \multicolumn{11}{c|}{second operator} \\
\cline{2-12}
operator 	& \IX{if} & \IX{else} & \IX{and} & \IX{or} & \RX{not}
                & \IX{<}  & \IX{<=}   & \IX{==}  & \IX{!=} & \IX{=>} & \IX{>}
\\\hline
\TT{\{}		& >x & > & > & > & > & > & > & > & > & > & > \\
\hline
\IX{if}		& x & < & > & > & > & > & > & > & > & > & > \\
\IX{else}	& > & > & > & > & > & > & > & > & > & > & > \\
\hline
\IX{and}	& < & x< & < & x & > & > & > & > & > & > & > \\
\IX{or}		& < & x< & x & < & > & > & > & > & > & > & > \\
\RX{not}	& < & x< & < & < & > & > & > & > & > & > & > \\
\hline
\IX{<}		& < & x< & < & < & x & < & < & < & < & < & < \\
\IX{<=}		& < & x< & < & < & x & < & < & < & < & < & < \\
\IX{==}		& < & x< & < & < & x & < & < & < & < & < & < \\
\IX{!=}		& < & x< & < & < & x & < & < & < & < & < & < \\
\IX{=>}		& < & x< & < & < & x & < & < & < & < & < & < \\
\IX{>}		& < & x< & < & < & x & < & < & < & < & < & < \\
\hline
\IX{+}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{-}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\hline
\IX{*}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{/}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{div}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{mod}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{rem}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\hline
\IX{\textasciicircum}
		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\hline
\RX{+}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\RX{-}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\hline
\IX{\&}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{|}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{xor}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{<{}<}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{>{}>}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\RX{!}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\hline

\end{tabular}
\end{center}
\caption{Builtin Operator Precedence Table: Part 1 of 3}
\label{BUILTIN-OPERATOR-PRECEDENCE-TABLE-1}
\end{figure}

\begin{figure}[p]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
\hline
first & \multicolumn{10}{c|}{second operator} \\
\hline
operator 	& \IX{+}  & \IX{-}    & \IX{*}   & \IX{/}
                & \IX{div} & \IX{mod} & \IX{rem} & \IX{\textasciicircum}
		& \RX{+} & \RX{-}
\\\hline
\TT{\{}		& > & > & > & > & > & > & > & > & > & > \\
\hline
\IX{if}		& >x & >x & >x & >x & >x & >x & >x & >x & >x & >x \\
\IX{else}	& > & > & > & > & > & > & > & > & > & > \\
\hline
\IX{and}	& >x & >x & >x & >x & >x & >x & >x & >x & >x & >x \\
\IX{or}		& >x & >x & >x & >x & >x & >x & >x & >x & >x & >x \\
\RX{not}	& >x & >x & >x & >x & >x & >x & >x & >x & >x & >x \\
\hline
\IX{<}		& > & > & > & > & > & > & > & > & > & > \\
\IX{<=}		& > & > & > & > & > & > & > & > & > & > \\
\IX{==}		& > & > & > & > & > & > & > & > & > & > \\
\IX{!=}		& > & > & > & > & > & > & > & > & > & > \\
\IX{=>}		& > & > & > & > & > & > & > & > & > & > \\
\IX{>}		& > & > & > & > & > & > & > & > & > & > \\
\hline
\IX{+}		& < & < & > & > & > & > & > & > & > & > \\
\IX{-}		& < & < & > & > & > & > & > & > & > & > \\
\hline
\IX{*}		& < & < & < & x & x & x & x & > & > & > \\
\IX{/}		& < & < & x & x & x & x & x & > & > & > \\
\IX{div}	& < & < & x & x & x & x & x & > & > & > \\
\IX{mod}	& < & < & x & x & x & x & x & > & > & > \\
\IX{rem}	& < & < & x & x & x & x & x & > & > & > \\
\hline
\IX{\textasciicircum}
		& < & < & < & < & < & < & < & x & > & > \\
\hline
\RX{+}		& < & < & < & < & < & < & < & < & > & > \\
\RX{-}		& < & < & < & < & < & < & < & < & > & > \\
\hline
\IX{\&}		& x & x & x & x & x & x & x & x & x & x \\
\IX{|}		& x & x & x & x & x & x & x & x & x & x \\
\IX{xor}	& x & x & x & x & x & x & x & x & x & x \\
\IX{<{}<}	& x & x & x & x & x & x & x & x & x & x \\
\IX{>{}>}	& x & x & x & x & x & x & x & x & x & x \\
\hline
\RX{!}		& x & x & x & x & x & x & x & x & x & x \\
\hline

\end{tabular}
\end{center}
\caption{Builtin Operator Precedence Table: Part 2 of 3}
\label{BUILTIN-OPERATOR-PRECEDENCE-TABLE-2}
\end{figure}

\begin{figure}[p]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
first & \multicolumn{7}{c|}{second operator} \\
\cline{2-8}
operator 	& \IX{\&} & \IX{|} & \IX{xor} & \IX{<{}<} & \IX{>{}>}
		& \RX{!} & \TT{\}}
\\\hline
\TT{\{}	& > & > & > & > & > & > & d \\
\hline
\IX{if}		& >x & >x & >x & >x & >x & >x & x< \\
\IX{else}	& > & > & > & > & > & > & < \\
\hline
\IX{and}	& >x & >x & >x & >x & >x & >x & < \\
\IX{or}		& >x & >x & >x & >x & >x & >x & < \\
\RX{not}	& >x & >x & >x & >x & >x & >x & < \\
\hline
\IX{<}		& > & > & > & > & > & > & < \\
\IX{<=}		& > & > & > & > & > & > & < \\
\IX{==}		& > & > & > & > & > & > & < \\
\IX{!=}		& > & > & > & > & > & > & < \\
\IX{=>}		& > & > & > & > & > & > & < \\
\IX{>}		& > & > & > & > & > & > & < \\
\hline
\IX{+}		& x & x & x & x & x & x & < \\
\IX{-}		& x & x & x & x & x & x & < \\
\hline
\IX{*}		& x & x & x & x & x & x & < \\
\IX{/}		& x & x & x & x & x & x & < \\
\IX{div}	& x & x & x & x & x & x & < \\
\IX{mod}	& x & x & x & x & x & x & < \\
\IX{rem}	& x & x & x & x & x & x & < \\
\hline
\IX{\textasciicircum}
		& x & x & x & x & x & x & < \\
\hline
\RX{+}		& x & x & x & x & x & x & < \\
\RX{-}		& x & x & x & x & x & x & < \\
\hline
\IX{\&}		& < & x & x & x & x & > & < \\
\IX{|}		& x & < & x & x & x & > & < \\
\IX{xor}	& x & x & < & x & x & > & < \\
\IX{<{}<}	& x & x & x & < & < & x & < \\
\IX{>{}>}	& x & x & x & < & < & x & < \\
\hline
\RX{!}	& < & < & < & < & < & > & < \\
\hline

\end{tabular}
\end{center}
\caption{Builtin Operator Precedence Table: Part 3 of 3}
\label{BUILTIN-OPERATOR-PRECEDENCE-TABLE-3}
\end{figure}

After assigning fixity as in \itemref{OPERATOR-IDENTIFICATION},
    the parser inserts parentheses so that
	each prefix or postfix operator has a single {\em primary} operand
    and each infix operator has two {\em primary} operands.  This is
done using the \key{operator precedence table}.  The builtin part of
this table is given in Figures
\itemref{BUILTIN-OPERATOR-PRECEDENCE-TABLE-1},
\itemref{BUILTIN-OPERATOR-PRECEDENCE-TABLE-2}, and
\itemref{BUILTIN-OPERATOR-PRECEDENCE-TABLE-3}.

Given the operator precedence table, parentheses are inserted as
follows:

\begin{center}
\begin{tabular}{llcl}
if $op1$ x $op2$ & $op1$ {\em primary}\QMARK{} $op2$
		 & & is a compile error \\
if $op1$ < $op2$ & $op1$ {\em primary}\QMARK{} $op2$
		 & rewrites as
                 & $op1$ {\em primary}\QMARK{} \TT{)} $op2$ \\
if $op1$ x< $op2$ & $op1$ {\em primary}\QMARK{} $op2$
		  & rewrites as
                  & $op1$ {\em primary}\QMARK{} \TT{)$\!_x$} $op2$ \\
if $op1$ > $op2$ & $op1$ {\em primary}\QMARK{} $op2$
		 & rewrites as
                 & $op1$ \TT{(} {\em primary}\QMARK{} $op2$ \\
if $op1$ >x $op2$ & $op1$ {\em primary}\QMARK{} $op2$
		 & rewrites as
                 & $op1$ $_x\!$\TT{(} {\em primary}\QMARK{} $op2$ \\
if $op1$ d $op2$ & $op1$ {\em primary}\QMARK{} $op2$
                 & \multicolumn{2}{l}{is the final result of the parse} \\
\end{tabular}
\end{center}

In the operator precedence tables the symbol \TT{\{} is treated as an
operator that appears only at the very beginning of the expression
and the symbol \TT{\}} is treated as an operator that appears only at
the very end of the expression.  After applying these rules as much
as possible to an expression,
if the expression contains a sequence `\TT{)}$\!_x$ $op$' the operand
preceding $op$ is illegal for $op$ and is a compile error, or
if the expression contains a sequence `$op$ $_x\!$\TT{(}' the operand
following $op$ is illegal for $op$ and is a compile error.
It is possible for the parse result to be
`\TT{\{} $_x\!$\TT{(} {\em primary} \TT{)}$\!_x$ \TT{\}}' in which case
the parse is not a legal expression (this can happen if the {\em primary}
topmost operator is `\TT{if}').

As an example, given the expression
\begin{center}
\tt \TT{\{}  x \IX{+} \RX{+} y \IX{*} z \TT{\}}
\end{center}
we get
\begin{center}
\begin{tabular}{llcl}
    & & initially & \tt \TT{\{} x \IX{+} \RX{+} y \IX{*} z \TT{\}} \\
(1) &
\TT{\{} > \IX{+}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \RX{+} y \IX{*} z \TT{\}}\\
(2) &
\IX{+} > \RX{+}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \TT{(} \RX{+} y \IX{*} z \TT{\}} \\
(3) &
\RX{+} < \IX{*}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \TT{(} \RX{+} y \TT{)} \IX{*} z \TT{\}} \\
(4) &
\IX{+} > \IX{*}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \TT{(} \TT{(} \RX{+} y \TT{)} \IX{*} z
          \TT{\}} \\
(5) &
\IX{*} < \TT{\}}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \TT{(} \TT{(} \RX{+} y \TT{)} \IX{*} z
          \TT{)} \TT{\}} \\
(6) &
\IX{+} < \TT{\}}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \TT{(} \TT{(} \RX{+} y \TT{)} \IX{*} z
          \TT{)} \TT{)} \TT{\}} \\
(7) &
\TT{\{} d \TT{\}}
    & \multicolumn{2}{l}{so this is the final result of the parse}
\end{tabular}
\end{center}

Notice that the step (4) above is possible because
{\tt \TT{(} \RX{+} y \TT{)}} became a {\em primary} after
the step (3),
step (6) is possible because
{\tt \TT{(} \TT{(} \RX{+} y \TT{)} \IX{*} z \TT{)} }
became a {\em primary} after step (5),
and step (7) is possible because
{ \tt \TT{(} x \IX{+} \TT{(} \TT{(} \RX{+} y \TT{)} \IX{*} z \TT{)} \TT{)} }
became a {\em primary} after step (6).
.

As another example, consider
\begin{center}
\tt \TT{\{} x \IX{if} \RX{+} y \IX{else} z \TT{\}}
\end{center}
we get
\begin{center}
\begin{tabular}{lcl}
    & initially
    & \tt \TT{\{} x \IX{if} \RX{+} y \IX{else} z \TT{\}} \\
\TT{\{} >x \IX{if}
    & so this rewrites as
    & \tt \TT{\{} $_x\!$\TT{(} x \IX{if} \RX{+} y \IX{else} z \TT{\}} \\
\IX{if} >x \RX{+}
   & so this rewites as
   & \tt \TT{\{} $_x\!$\TT{(} x \IX{if} $_x\!$\TT{(} \RX{+} y \IX{else} z
         \TT{\}} \\
\RX{+} x< \IX{else}
   & so this rewites as
   & \tt \TT{\{} $_x\!$\TT{(} x \IX{if} $_x\!$\TT{(} \RX{+} y \TT{)}$\!_x$
         \IX{else} z \TT{\}} \\
\IX{if} < \IX{else}
   & so this rewites as
   & \tt \TT{\{} $_x\!$\TT{(} x \IX{if} $_x\!$\TT{(} \RX{+} y \TT{)}$\!_x$
         \TT{)} \IX{else} z \TT{\}} \\
\TT{\{} < \IX{else}
   & so this rewites as
   & \tt \TT{\{} \TT{(} $_x\!$\TT{(} x \IX{if} $_x\!$\TT{(} \RX{+} y \TT{)}$\!_x$
         \TT{)} \IX{else} z \TT{\}} \\
\IX{else} < \TT{\}}
   & so this rewites as
   & \tt \TT{\{} \TT{(} $_x\!$\TT{(} x \IX{if} $_x\!$\TT{(} \RX{+} y \TT{)}$\!_x$
         \TT{)} \IX{else} z \TT{)} \TT{\}} \\
\TT{\{} d \TT{\}}
    & \multicolumn{2}{l}{so this is the final result of the parse, with
                         an error signalled by \IX{if} $_x\!$\TT{(}}
\end{tabular}
\end{center}

Notice that in the sequence \TT{)}$\!_x$ \TT{)} \IX{else}
the $_x$ has been hidded from the \IX{else} by a \TT{)} without
the $_x$, so this part of the expression is legal.  Similarly
\TT{\{} \TT{(} $_x\!$\TT{(} is legal. The builtin
operator precedence table dictates that the left operand of an \IX{else}
must have \IX{if} or \IX{else} as its `\mkey{topmost}{operator}'
operator or be a {\em primary}
in the initial expression, and also dictates that \IX{if} cannot be the topmost
operator in the entire expression.  These rules are satisfied by the example.
The builtin operator precedence table also dictates that the
right operand of an \IX{if} must contain a logical or comparison
operator as its `topmost' operator or be a {\em primary}
in the initial expression.  This is \underline{not} satisfied by the
example because the right operand is {\tt (+ y)},
so the example is a compile error.

In order for this algorithm to work properly, the operator
precedence table is required to obey the following rules
concerning prefix and postfix operators:
\begin{center}
\begin{tabular}{cccl}
\IX{$op1$}~~<~~\RX{$op2$} & and & \IX{$op1$}~~x<~~\RX{$op2$} & are never true \\
\RX{$op1$}~~<~~\RX{$op2$} & and & \RX{$op1$}~~x<~~\RX{$op2$} & are never true \\
\LX{$op1$}~~>~~\IX{$op2$} & and & \LX{$op1$}~~>x~~\IX{$op2$} & are never true \\
\LX{$op1$}~~>~~\LX{$op2$} & and & \LX{$op1$}~~>x~~\LX{$op2$} & are never true \\
\end{tabular}
\end{center}


\subsubsection{Builtin Operator Syntax Equations}
\label{BUILTIN-OPERATOR-SYNTAX-EQUATIONS}

The builtin operator precedence table encodes the following syntax equations:

\begin{indpar}
\emkey{expression} ::= \\
    \begin{tabular}[t]{rl}
        & {\em else-expression} \\
    $|$ & {\em value-expression} \\
    $|$ & {\em primary} \\
    \end{tabular}
\\[0.5ex]
\emkey{value-expression} ::= \\
    \begin{tabular}[t]{rl}
        & {\em logical-expression} \\
    $|$ & {\em summation-expression} \\
    $|$ & {\em product-expression} \\
    $|$ & {\em exponent-expression} \\
    $|$ & {\em arithmetic-prefix-expression} \\
    $|$ & {\em arithmetic-postfix-expression} \\
    $|$ & {\em bitop-expression} \\
    $|$ & {\em shift-expression} \\
    $|$ & {\em bitop-prefix-expression} \\
    $|$ & {\em bitop-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{else-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em else-left-operand} \ttkey{else} {\em else-right-operand} \\
    ::= & {\em else-left-operand} \ttkey{else} {\em else-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{else-left-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em if-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{else-right-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em value-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{if-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em if-left-operand} \ttkey{if} {\em if-right-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{if-left-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em value-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{if-right-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em logical-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{logical-expression}\label{LOGICAL-EXPRESSION}
    \begin{tabular}[t]{rl}
    ::= & {\em logical-and-expression} \\
    $|$ & {\em logical-or-expression} \\
    $|$ & {\em not-expression} \\
    $|$ & {\em compare-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-and-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em logical-operand} \ttkey{and} {\em logical-operand} \\
    $|$ & {\em logical-and-expression} \ttkey{and} {\em logical-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-or-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em logical-operand} \ttkey{or} {\em logical-operand} \\
    $|$ & {\em logical-or-expression} \ttkey{or} {\em logical-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em not-expression} \\
    $|$ & {\em compare-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{not-expression}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{not} {\em not-operand} \\
    $|$ & \ttkey{not} {\em not-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{not-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em compare-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{compare-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em compare-operand} {\em compare-operator} {\em compare-operand} \\
    $|$ & {\em compare-expression} {\em compare-operator}
                                   {\em compare-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{compare-operator}::=
    \ttkey{==} $|$ \ttkey{!=} $|$ \ttkey{>} $|$
    \ttkey{=>} $|$ \ttkey{<} $|$ \ttkey{<=}
\\[0.5ex]
\emkey{compare-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em summation-expression} \\
    $|$ & {\em product-expression} \\
    $|$ & {\em exponent-expression} \\
    $|$ & {\em arithmetic-prefix-expression} \\
    $|$ & {\em arithmetic-postfix-expression} \\
    $|$ & {\em bitop-expression} \\
    $|$ & {\em shift-expression} \\
    $|$ & {\em bitop-prefix-expression} \\
    $|$ & {\em bitop-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{summation-expression} \\
    \hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & {\em summation-operand} {\em summation-operator}
                                  {\em summation-operand} \\
    $|$ & {\em summation-expression} {\em summation-operator}
                                     {\em summation-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{summation-operator}::= \ttkey{+} $|$ \ttkey{-}
\\[0.5ex]
\emkey{summation-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em product-expression} \\
    $|$ & {\em exponent-expression} \\
    $|$ & {\em arithmetic-prefix-expression} \\
    $|$ & {\em arithmetic-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{product-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em product-*-expression} \\
    $|$ & {\em product-operand} \ttkey{/} {\em product-operand} \\
    $|$ & {\em product-operand} \ttkey{mod} {\em product-operand} \\
    $|$ & {\em product-operand} \ttkey{rem} {\em product-operand} \\
    $|$ & {\em product-operand} \ttkey{div} {\em product-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{product-*-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em product-operand} \ttkey{*} {\em product-operand} \\
    $|$ & {\em product-*-expression} \ttkey{*} {\em product-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{product-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em exponent-expression} \\
    $|$ & {\em arithmetic-prefix-expression} \\
    $|$ & {\em arithmetic-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{exponent-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em exponent-operand} \ttkey{\textasciicircum}
                                  {\em exponent-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{exponent-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em arithmetic-prefix-expression} \\
    $|$ & {\em arithmetic-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{arithmetic-prefix-expression} \\
    \hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & {\em arithmetic-prefix-operator} {\em arithmetic-prefix-operand} \\
    $|$ & {\em arithmetic-prefix-operator} {\em arithmetic-prefix-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{arithmetic-prefix-operator}::= \ttkey{+} $|$ \ttkey{-}
\\[0.5ex]
\emkey{arithmetic-prefix-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em reference-prefix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{bitop-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-\&-expression} \\
    $|$ & {\em bitop-|-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{bitop-\&-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-operand} \ttkey{\&} {\em bitop-operand} \\
    $|$ & {\em bitop-\&-expression} \ttkey{\&} {\em bitop-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{bitop-|-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-operand} \ttkey{|} {\em bitop-operand} \\
    $|$ & {\em bitop-|-expression} \ttkey{|} {\em bitop-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{bitop-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-prefix-expression} \\
    $|$ & {\em bitop-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{bitop-prefix-expression}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{!} {\em bitop-prefix-operand} \\
    $|$ & \ttkey{!} {\em bitop-prefix-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{bitop-prefix-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em reference-prefix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{shift-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em shift-left-operand} {\em shift-operator}
                                   {\em shift-right-operand} \\
    $|$ & {\em shift-expression} {\em shift-operator}
                                 {\em shift-right-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{shift-operator} ::= \TT{<{}<} $|$ \TT{>{}>}
\\[0.5ex]
\emkey{shift-left-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-prefix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{shift-right-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary} \\
    \end{tabular}
\\[0.5ex]
\emkey{reference-prefix-operand} ::= {\em reference-postfix-expression}

\end{indpar}

\subsubsection{Builtin Parser Instructions}
\label{BUILTIN-PARSER-INSTRUCTIONS}

The builtin syntax equations above, and the builtin operator
precedence table, can be computed from the following builtin
`\skey{parser instruction}s':

\begin{indpar}\begin{verbatim}
define asymetric right associative "else" operator "else"
include "else" expression in expresssion

define asymetric binary "if" operator "if"
include "if" expression in "else" left operand

include "logical" expression in "if" right operand
include "value" expression in "else" right operand
include "value" expression in "if" left operand
include "value" expression in expression

define left associative "logical" operator "and"
define left associative "logical" operator "or"
include "logical" expression in "if" right operand
include "logical" expression in "value" expression

define prefix "not" operator "not"
include "not" expression in "logical" operand
include "not" expression in "logical" expression

define left associative "compare" operators
       "<", "<=", "==", "!=", "=>", ">"
include "compare" expression in "logical" operand
include "compare" expression in "not" operand
include "compare" expression in "logical" expression

define left associative "summation" operators "+", "-"
include "summation" expression in "compare" operand
include "summation" expression in "value" expression

define left associative "product" operator "*"
define binary "product" operator "/"
define binary "product" operator "mod"
define binary "product" operator "rem"
define binary "product" operator "div"
include "product" expression in "summation" operand
include "product" expression in "compare" operand
include "product" expression in "value" expression

define binary "exponent" operator "^"
include "exponent" expression in "product" operand
include "exponent" expression in "summation" operand
include "exponent" expression in "compare" operand
include "exponent" expression in "value" expression

define prefix "arithmetic-prefix" operators "+", "-"
include "arithmetic-prefix" expression in
        "exponent" operand
include "arithmetic-prefix" expression in
        "product" operand
include "arithmetic-prefix" expression in
        "summation" operand
include "arithmetic-prefix" expression in
        "compare" operand
include "arithmetic-prefix" expression in
        "value" expression

include "arithmetic-postfix" expression in
        "exponent" operand
include "arithmetic-postfix" expression in
        "product" operand
include "arithmetic-postfix" expression in
        "summation" operand
include "arithmetic-postfix" expression in
        "compare" operand
include "arithmetic-postfix" expression in
        "value" expression

define left associative "bitop" operator "&"
define left associative "bitop" operator "|"
include "bitop" expression in "compare" operand
include "bitop" expression in "value" expression

define asymetric left associative
                      "shift" operators "<<", ">>"
include "shift" expression in "compare" operand
include "shift" expression in "value" expression

define prefix "bitop-prefix" operator "!"
include "bitop-prefix" expression in "shift" left operand
include "bitop-prefix" expression in "bitop" operand
include "bitop-prefix" expression in "compare" operand
include "bitop-prefix" expression in "value" expression

include "bitop-postfix" expression in "shift" left operand
include "bitop-postfix" expression in "bitop" operand
include "bitop-postfix" expression in "compare" operand
include "bitop-postfix" expression in "value" expression

include "reference-prefix" expression in
        "exponent" operand
include "reference-prefix" expression in
        "product" operand
include "reference-prefix" expression in
        "summation" operand
include "reference-prefix" expression in
        "shift" left operand
include "reference-prefix" expression in
        "bitop" operand
include "reference-prefix" expression in
        "compare" operand
include "reference-prefix" expression in
        "value" expression

include "reference-postfix" expression in
        "exponent" operand
include "reference-postfix" expression in
        "product" operand
include "reference-postfix" expression in
        "summation" operand
include "reference-postfix" expression in
        "shift" left operand
include "reference-postfix" expression in
        "bitop" operand
include "reference-postfix" expression in
        "compare" operand
include "reference-postfix" expression in
        "value" expression

include "reference-postfix" expression in
        "reference-prefix" operand
\end{verbatim}\end{indpar}

Note that the {\tt "else"} operator is right associative and not
left associative.  However, because it defers evaluation of its
right operand, it evaluates its subexpressions in left to
right order.  See the example on \pagref{IF-ELSE-EXAMPLE}.

The user may add {\em parser-instructions} to those that
are builtin using {\em parser-blocks} (\itemref{PARSER-BLOCKS}).

There are several builtin expression types that have no builtin
operators, but are defined purely for the convenience of users
adding operators.  These are
\begin{center}
"arithmetic-postfix" expression \\
"bitop-postfix" expression \\
"reference-prefix" expression \\
"reference-postfix" expression
\end{center}

The builtin parser instructions respect the convention that
prefix and postfix operators should not be mixed with each other,
except that {\em reference-prefix} and {\em reference-postfix}
operators may be mixed, with the {\em reference-postfix} operators
being executed first.  An example of using this latter is:

\begin{indpar}\begin{verbatim}
define prefix "reference-prefix" operator "*"
define postfix "reference-postfix" operator "++"
\end{verbatim}\end{indpar}

which allows one to write `{\tt * x ++}' and get the parse
`{\tt * (x ++)}'.

\subsubsection{Parser Instruction Syntax}
\label{PARSER-INSTRUCTION-SYNTAX}

\ikey{Parser-instructions}{parser-instruction}\label{PARSER-INSTRUCTION}
have the syntax:

\begin{indpar}
\emkey{parser-instruction}
    \begin{tabular}[t]{rll}
    ::= & {\em parser-define-instruction} \\
    $|$ & {\em parser-include-instruction} \\
    $|$ & {\em parser-import-instruction}
        & [see \pagref{PARSER-IMPORT-INSTRUCTION}]\\
    $|$ & {\em parser-delete-instruction}
        & [see \pagref{PARSER-DELETE-INSTRUCTION}]\\
    \end{tabular}
\\[0.5ex]
\emkey{parser-define-instruction} \\
\hspace*{0.3in}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{define} ~ {\em operator-type} ~ {\em expression-type}
    		   ~ \ttkey{operator} ~ {\em operator-name} \\
    $|$ & \ttkey{define} ~ {\em operator-type} ~ {\em expression-type}
    		   ~ \ttkey{operators} ~ {\em operator-name-list} \\
    \end{tabular}
\\[0.5ex]
\emkey{parser-include-instruction} \\
\hspace*{0.3in}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{include} ~ {\em expression-type}
    		   ~ \ttkey{expression in expression} \\
    $|$ & \ttkey{include} ~ {\em expression-type}
    		   ~ \begin{tabular}[t]{@{}l@{}}
		     \ttkey{expression in} \\
		     {\em expression-type} ~ {\em expression-kind}
		     \end{tabular}
    \end{tabular}
\\[0.5ex]
\emkey{operator-type}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{prefix} $|$ \ttkey{postfix} \\
    $|$ & \ttkey{asymetric}\QMARK{} ~ \ttkey{binary} \\
    $|$ & \ttkey{asymetric}\QMARK{} ~ \ttkey{left associative} \\
    $|$ & \ttkey{asymetric}\QMARK{} ~ \ttkey{right associative} \\
    \end{tabular}
\\[0.5ex]
\emkey{expression-type} ::= {\em quoted-string}
\\[0.5ex]
\emkey{operator-name} ::= {\em quoted-string}
\\[0.5ex]
\emkey{operator-name-list} ::= {\em operator-name}
			   \{ \TT{,} {\em operator-name} \}\PLUS{}
\\[0.5ex]
\emkey{expression-kind}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{expression} \\
    $|$ & \ttkey{operand} \\
    $|$ & \ttkey{left operand} \\
    $|$ & \ttkey{right operand} \\
    \end{tabular}

\end{indpar}

The \skey{syntax unit}s defined by {\em parser-instructions}
have names of the forms:
\begin{center}
{\em expression-type}-expression \\
{\em expression-type}-operand \\
{\em expression-type}-left-operand \\
{\em expression-type}-right-operand \\
\end{center}
where the {\em expression-type} is unquoted.  In {\em parser-instructions}
{\em expression-types} are quoted because they are sometimes operators,
such as {\tt "and"}, but the syntax equations are not L-Language expressions.

The operators defined by parser instructions have one of three fixities:
\key{prefix}, or \key{postfix}, or \key{infix}.  The syntax of the
parser instruction specifies the operator fixity are follows:
\begin{center}
\begin{tabular}{ll}
\tt define prefix \ldots{} operator\ldots & specifies prefix operators \\
\tt define postfix \ldots{} operator\ldots & specifies postfix operators \\
\tt define \ldots{} binary \ldots{} operator\ldots
    & specifies infix operators \\
\tt define \ldots{} associative \ldots{} operator\ldots
    & specifies infix operators \\
\end{tabular}
\end{center}

Operators of different fixities are different operators from the point
of view of the operator precedence table:
see \itemref{THE-BUILTIN-OPERATOR-PRECEDENCE-TABLE}.  For example,
prefix {\tt +} and infix {\tt +} are distinct builtin operators from
this point of view.  The single operator lexeme sequence {\tt +} thus
has two fixities: prefix and infix.

A single operator lexeme sequence is \underline{not} permitted to have
all three fixities.

\subsubsection{Parser Instruction Semantics}
\label{PARSER-INSTRUCTION-SEMANTICS}

The {\em parser-define-instructions} act as follows:

\begin{indpar}

{\tt define \TT{prefix} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & $N$ {\em E-operand} \\
                            $|$ & $N$ {\em E-N-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{prefix} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-N1-operator} {\em E-operand} \\
                            $|$ & {\em E-N1-operator} {\em E-N1-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{postfix} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} $N$ \\
                            $|$ & {\em E-N-expression} $N$ \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{postfix} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} {\em E-N1-operator} \\
                            $|$ & {\em E-N1-expression} {\em E-N1-operator} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{binary} "$E$" operator "$N$"}
\begin{indpar}
creates: {\em E-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} $N$ {\em E-operand} \\
                            \end{tabular}
\end{indpar}

{\tt define \TT{binary} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} {\em E-operator}
			          {\em E-operand} \\
                            \end{tabular} \\
         {\em E-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{asymetric binary} "$E$" operator "$N$"}
\begin{indpar}
creates: {\em E-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} $N$
			          {\em E-right-operand} \\
                            \end{tabular}
\end{indpar}

{\tt define \TT{asymetric binary} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} {\em E-operator}
			          {\em E-right-operand} \\
                            \end{tabular} \\
         {\em E-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{left associative} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} $N$ {\em E-operand} \\
                            $|$ & {\em E-N-expression} $N$ {\em E-operand} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{left associative} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} {\em E-N1-operator}
			          {\em E-operand} \\
                            $|$ & {\em E-N1-expression} {\em E-N1-operator}
			          {\em E-operand} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{asymetric left associative} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} $N$
			          {\em E-right-operand} \\
                            $|$ & {\em E-N-expression} $N$
			          {\em E-right-operand} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{asymetric left associative} \begin{tabular}[t]{l}
                                             "$E$" operators \\
					     "$N1$"\TT{,} "$N2$" \ldots \\
					     \end{tabular}}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} {\em E-N1-operator}
			          {\em E-right-operand} \\
                            $|$ & {\em E-N1-expression} {\em E-N1-operator}
			          {\em E-right-operand} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{right associative} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} $N$ {\em E-operand} \\
                            $|$ & {\em E-operand} $N$ {\em E-N-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{right associative} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} {\em E-N1-operator}
			          {\em E-operand} \\
                            $|$ & {\em E-operand} {\em E-N1-operator}
			          {\em E-N1-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{asymetric right associative} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} $N$
			          {\em E-right-operand} \\
                            $|$ & {\em E-left-operand} $N$
			          {\em E-N-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{asymetric right associative} \begin{tabular}[t]{l}
                                             "$E$" operators \\
					     "$N1$"\TT{,} "$N2$" \ldots \\
					     \end{tabular}}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} {\em E-N1-operator}
			          {\em E-right-operand} \\
                            $|$ & {\em E-left-operand} {\em E-N1-operator}
			          {\em E-N1-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

\end{indpar}

The {\em parser-include-instructions} act as follows:

\begin{indpar}

{\tt include "$E$" expression in expression}
\begin{indpar}
creates: {\em expression} ::= {\em $E$-expression}
\end{indpar}

{\tt include "$E1$" expression in "$E2$" expression}
\begin{indpar}
creates: {\em $E2$-expression} ::= {\em $E1$-expression}
\end{indpar}

{\tt include "$E1$" expression in "$E2$" operand}
\begin{indpar}
creates: {\em $E2$-operand} ::= {\em $E1$-expression}
\end{indpar}

{\tt include "$E1$" expression in "$E2$" left operand}
\begin{indpar}
creates: {\em $E2$-left-operand} ::= {\em $E1$-expression}
\end{indpar}

{\tt include "$E1$" expression in "$E2$" right operand}
\begin{indpar}
creates: {\em $E2$-right-operand} ::= {\em $E1$-expression}
\end{indpar}

\end{indpar}

In general, creating the syntax equations
\begin{center}
$X$ ::= $Y$ \ldots \\
and \\
$X$ ::= $Z$ \ldots \\
\end{center}
is equivalent to creating
\begin{center}
$X$ \begin{tabular}[t]{rl}
    ::= & $Y$ \ldots \\
    $|$ & $Z$ \ldots \\
    \end{tabular}
\end{center}

In addition, whenever a syntax unit with a name of the
form {\em \ldots-operand} is created, the syntax equation
\begin{center}
{\em \ldots-operand} ::= {\em primary}
\end{center}
is created.  So a {\em primary} can be used as any operand.
The syntax equation
\begin{center}
{\em expression} ::= {\em primary}
\end{center}
is also created, so an {\em expression} can be a {\em primary} by itself.

\subsubsection{Computing Operator Precedence}
\label{COMPUTING-OPERATOR-PRECEDENCE}

The {\em parser-instructions} are used to compute the parser
syntax equations and from these the operator
precedence table.  The procedure is roughly as follows.

In general an infix operator $N$ ends up in a syntax equation equivalent to
\begin{center}
{\em $N$-expression} ::= {\em l-operand} $N$ {\em r-operand}
\end{center}
where just one of the following holds:
\begin{center}
{\em l-operand} ::= {\em $N$-operand} \\
{\em l-operand} ::= {\em $N$-left-operand} \\
{\em l-operand} ::= {\em $N$-operand} $|$ {\em $N$-expression } \\
{\em l-operand} ::= {\em $N$-left-operand} $|$ {\em $N$-expression }
\end{center}
and similarly for {\em r-operand}.
From the equations for the components of {\em l-operand} the following
are computed:
\begin{center}
\begin{tabular}{l}
$N_{top}$ = set of possible topmost operators in {\em l-operand} \\
$N_{all}$ = set of all possible operators outside parentheses
           in {\em l-operand}
\end{tabular}
\end{center}

Then for each $M\in{}N_{top}$ the operator precedence relation
`$M$~<~$N$' is generated, and for each $M\in(N_{all}-N_{top})$
the operator precedence relation
`$M$~x<~$N$' is generated.  A similar procedure involving {\em r-operand}
generates relations `$N$~>~$M$' and `$N$~>x~$M$'.

It is possible for this procedure to generate
both $M$~<~$N$ and $N$~<~$M$, or
both $N$~>~$M$ and $M$~>~$N$.
These are called `\skey{precedence loop}s' and are
compilation errors.  For example, the following
{\em parser-instructions} will trigger these errors:
\begin{indpar}\begin{verbatim}
define binary "N" operator "++"
define binary "M" operator "--"
include "N" expression in "M" operand
include "M" expression in "N" operand
\end{verbatim}\end{indpar}
These instructions generate the parser syntax equations:
\begin{center}
\begin{tabular}{l}
{\em N-expression} ::= {\em N-operand} ~ {\tt ++} ~ {\em N-operand} \\
{\em M-expression} ::= {\em M-operand} ~ {\tt -{}-} ~ {\em M-operand} \\
{\em M-operand} ::= {\em N-expression} \\
{\em N-operand} ::= {\em M-expression} \\
\end{tabular}
\end{center}
from which the following are derived:
\begin{center}
\begin{tabular}{l}
$N_{top}$ = \{ -{}- \} \\
$M_{top}$ = \{ +{}+ \} \\
{\tt -{}- < ++} ~~ and ~~ {\tt ++ > -{}-} \\
{\tt ++ < -{}-} ~~ and ~~ {\tt -{}- > ++} \\
\end{tabular}
\end{center}

According to the above rules, the {\em parser-instruction}:
\begin{center}
{\tt define prefix "not" operator "not"}
\end{center}
should produce the syntax equations:
\begin{center}
\begin{tabular}{l}
{\em not-not-expression} \begin{tabular}[t]{rl}
		     ::= & \TT{not} {\em not-operand} \\
		     $|$ & \TT{not} {\em not-not-expression} \\
		     \end{tabular} \\
{\em not-expression} ::= {\em not-not-expression} \\
\end{tabular}
\end{center}
However, because {\tt "not"} is the \underline{only} operator in
a {\em not-expression}, these equations can be simplified to
\begin{center}
\begin{tabular}{l}
{\em not-expression} \begin{tabular}[t]{rl}
		     ::= & \TT{not} {\em not-operand} \\
		     $|$ & \TT{not} {\em not-expression} \\
		     \end{tabular} \\
\end{tabular}
\end{center}
This simplification has been applied in section 
\itemref{BUILTIN-OPERATOR-SYNTAX-EQUATIONS} to simplify the following:
\begin{center}
{\em else-expression} \\
{\em not-expression} \\
{\em compare-expression} \\
{\em summation-expression} \\
{\em arithmetic-prefix-expression} \\
{\em shift-expression} \\
{\em bitop-prefix-expression}
\end{center}

Another implication of the above rules is what happens when
there are {\em parser-instructions} such as:
\begin{center}
\tt
\begin{tabular}{l}
define prefix "P" operators "+", "-"  \\
define prefix "P" operators "++", "-{}-"  \\
\end{tabular}
\end{center}
There produce the equations:
\begin{center}
\begin{tabular}{l}
{\em P-+-expression} \begin{tabular}[t]{rl}
		     ::= & {\em P-+-operator} {\em P-operand} \\
		     $|$ & {\em P-+-operator} {\em P-+-expression} \\
		     \end{tabular} \\
{\em P-expression} ::= {\em P-+-expression} \\
{\em P-+-operator} ::= \TT{+} $|$ \TT{-} \\
{\em P-++-expression} \begin{tabular}[t]{rl}
		     ::= & {\em P-++-operator} {\em P-operand} \\
		     $|$ & {\em P-++-operator} {\em P-++-expression} \\
		     \end{tabular} \\
{\em P-expression} ::= {\em P-++-expression} \\
{\em P-++-operator} ::= \TT{++} $|$ \TT{-{}-} \\
\end{tabular}
\end{center}
and the precedence table entries:
\begin{center}
\begin{tabular}{llll}
\RX{+} > \RX{+} & \RX{+} > \RX{-} & \RX{-} > \RX{+} & \RX{-} > \RX{-} \\
\RX{++} > \RX{++} & \RX{++} > \RX{-{}-} & \RX{-{}-} > \RX{++}
                                        & \RX{-{}-} > \RX{-{}-} \\
\RX{+} x \RX{++} & \RX{+} x \RX{-{}-} & \RX{-} x \RX{++} & \RX{-} x \RX{-{}-} \\
\RX{++} x \RX{+} & \RX{++} x \RX{-} & \RX{-{}-} x \RX{+} & \RX{-{}-} x \RX{-} \\
\end{tabular}
\end{center}
from which we derive that:
\begin{center}
\begin{tabular}{lll}
\tt + + x	& is legal & because \RX{+} > \RX{+} \\
\tt + - x	& is legal & because \RX{+} > \RX{-} \\
\tt ++ ++ x	& is legal & because \RX{++} > \RX{++} \\
\tt ++ -{}- x	& is legal & because \RX{++} > \RX{-{}-} \\
\tt + ++ x	& is \underline{not} legal & because \RX{+} x \RX{++} \\
\tt + -{}- x	& is \underline{not} legal & because \RX{+} x \RX{-{}-} \\
\tt ++ + x	& is \underline{not} legal & because \RX{++} x \RX{+} \\
\tt ++ - x	& is \underline{not} legal & because \RX{++} x \RX{-} \\
\end{tabular}
\end{center}

Contrast this with what happens with the {\em parser-instruction}:
\begin{center}
\tt
\begin{tabular}{l}
define prefix "P" operators "+", "-", "++", "-{}-"  \\
\end{tabular}
\end{center}
In this case `{\tt + ++ x}', etc. are legal.

The underlying idea is that operators of the same `precedence' can be
mixed only if they occur in the same {\em parser-instruction}.

\subsubsection{Parsing vs Type Checking}

The parser cannot identify as erroneous expressions such as
\begin{center}
\tt {\em if-expression} else ( {\em if-expression} )
\end{center}
in which the second `\TT{if}' is hidden inside parentheses.

In this case type checking will catch the error later in the
compilation, after parsing.

There are other possible cases where the parser cannot catch
errors that must be caught later by type checking.
For example, consider the {\tt "else"} operator
which is `{\tt asymetric right associative}'.  This means
that in a sequence of operands and alternating {\tt "else"}
operators, the parser can make the rightmost operand different
from the other operands.  But because it is based on an
operator hierarchy table, the parser cannot
make the leftmost operand distinct from all the other operands.
It seems pure luck that the parser can do the right thing
for the {\tt "else"} operator, which is right associative only
because it defers the evaluation of its right operand.

\subsubsection{Parser Blocks}
\label{PARSER-BLOCKS}

{\em Parser-instructions} can only be included in {\em parser-blocks}
which themselves can only be included as {\em module-clauses} in
{\em module-declarations} (\pagref{MODULE-DECLARATION})
or {\em body-clauses} in {\em body-declarations} (\pagref{BODY-DECLARATION})
at the beginning of a file.

The {\em parser-instructions} at the beginning of a file are
added to the builtin {\em parser-instructions} to define the
operator precedence table used in the file.  The parsing
instructions in a module file also apply the files of bodies of that
module.

It is possible to export a block of {\em parser-instructions}.  This is
done by labelling a {\em parser-block} `\ttmkey{external}{parser-block}'
in a {\em module-declaration}.  The instructions in the external
{\em parser-blocks} of an exporting module can be imported by a
\begin{indpar}
\emkey{parser-import-instruction}\label{PARSER-IMPORT-INSTRUCTION} ::=
    \TT{import} ~ {\em module-name} ~ \TT{parsing}%
    \ttindex{import \ldots{} parsing}
\end{indpar}
in a {\em parser-block}.  This adds the {\em parser-instructions}
from the external {\em parser-block} of the named module to the
builtin {\em parser-instructions}.

The ordering of {\em parser-instructions} within a single {\em parser-block}
makes \underline{no} difference.  No two such instructions may define the same
operator with the same fixity.

The ordering of {\em parser-blocks} \underline{does} make a difference.
If {\em parser-block} X imports {\em parser-block} Y, or if X is in 
the body of a module and Y is the {\em parser-block} of the module, or if
Y is the block of builtin parser instructions, then
we say that Y is a parent of X.  The graph of parser blocks with the
parent relation must be acyclic.  The {\em parser-instructions} in the
ancestors of X in this graph are said to be \mkey{ancestor}{parser instruction}
{\em parser-instructions} of X.

Note that a module or body can contain at most one {\em parser-block}.
A module that contains nothing but a single exported {\em parser-block}
can be used to define {\em parser-instructions} that can be imported.

If a {\em parser-instruction} defines an operator with a given fixity,
then that operator is removed from all ancestor {\em parser-instructions}
in which it occurs with the same fixity.
For example, there are builtin {\em parser-instructions}
\begin{center}
\tt
\begin{tabular}{l}
define left associative "summation" operators "+", "-" \\
define prefix "arithmetic-prefix" operators "+", "-" \\
\end{tabular}
\end{center}
If a body {\em parser-block} contains the instruction
\begin{center}
define binary "foo" operator "+" \\
\end{center}
the first builtin instruction only will be modified to become
\begin{center}
\tt
\begin{tabular}{l}
define left associative "summation" operator "-" \\
\end{tabular}
\end{center}
If the body {\em parser-block} also contains the instruction
\begin{center}
define left associative "bar" operator "-" \\
\end{center}
that builtin instruction would be deleted entirely.  However the builtin
instruction
\begin{center}
\tt
\begin{tabular}{l}
define prefix "arithmetic-prefix" operators "+", "-" \\
\end{tabular}
\end{center}
would \underline{not} be modified by any of this.

The parser instruction 
\begin{indpar}
\emkey{parser-delete-instruction}\label{PARSER-DELETE-INSTRUCTION}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{delete}{operator} {\em operator-type}
          \TT{operator} {\em operator-name} \\
    $|$ & \ttmkey{delete}{operator} {\em operator-type}
          \TT{operators} {\em operator-name-list} \\
    \end{tabular}
\end{indpar}
may be used to delete operators from ancestor
{\em parser-instructions}.
An operator listed in a
{\em parser-delete-instruction} cannot be listed in
any other {\em parser-instruction} in the same {\em parser-block}.
The {\em operator-type} in a
{\em parser-delete-instruction} is only used to specify
the operator fixity, and need not otherwise match the {\em operator-type}
in the ancestor {\em parser-instruction} that is affected.
For example, {\tt binary} may be used in the {\em parser-delete-instruction}
where {\em associative} is used in the affected ancestor
{\em parser-instruction}.

\subsubsection{Primaries}
\label{PRIMARIES}



It is the compiler, and not the parser, that analyzes {\em primaries},
because knowledge of the {\em names} in scope is required.  To the
compiler, a {\em primary} has the following syntax:
\begin{indpar}
\emkey{primary}\label{COMPILER-PRIMARY}
    \begin{tabular}[t]{rl@{\hspace*{0.4in}}l}
    ::= & {\em constant} \\
    $|$ & {\em variable-name} 		& [see \pagref{VARIABLE-NAME}] \\
    $|$ & {\em variable-declaration} \\
    $|$ & {\em qualifier-conversion} \\
    $|$ & {\em type-conversion} \\
    $|$ & {\em function-call}		& [see \pagref{FUNCTION-CALL}] \\
    \end{tabular}
\\[0.5ex]
\emkey{constant}\label{CONSTANT}
    \begin{tabular}[t]{rl@{\hspace*{0.5in}}l}
    ::= & {\em number-constant} 	& [see \pagref{NUMBER-CONSTANT}] \\
    $|$ & {\em character-constant} 	& [see \pagref{CHARACTER-CONSTANT}]  \\
    $|$ & {\em string-constant} 	& [see \pagref{STRING-CONSTANT}]  \\
    $|$ & {\em name-constant} 		& [see \pagref{NAME-CONSTANT}]  \\
    $|$ & {\em enum-set-constant}	& [see \pagref{ENUM-SET-CONSTANT}]  \\
    $|$ & {\em enum-list-constant}	& [see \pagref{ENUM-LIST-CONSTANT}]  \\
    $|$ & {\em name-set-constant}	& [see \pagref{NAME-SET-CONSTANT}]  \\
    $|$ & {\em name-list-constant}	& [see \pagref{NAME-LIST-CONSTANT}]  \\
    \end{tabular}
\\[0.5ex]
\emkey{variable-declaration} ::= {\em qualifier-name}\STAR{}
                                 {\em type-name} {\em variable-name}
\\[0.5ex]
\emkey{qualifier-conversion}
    ::= {\em qualifier-name}\PLUS{} \TT{(} {\em expression} \TT{)}
\\[0.5ex]
\emkey{type-conversion}
    ::= {\em qualifier-name}\STAR{} {\em type-name}
        \TT{(} {\em expression} \TT{)}
\end{indpar}

If the {\em primary} is not a {\em constant}, the compiler
checks the scope to see if it is a {\em variable-declaration},
{\em variable-name}, {\em qualifier-conversion}, or
{\em type-conversion}.  If it is none of these, the
compiler applies the {\em function-call} matching rules of
\itemref{MATCHING-CALLS-TO-PROTOTYPES}
to match the {\em primary} to a {\em function-prototype}.

\subsection{Expression Semantics}

Expressions provide standard operators.  Expressions are compiled
into function calls, and builtin functions
implement logical and numeric operators.

\subsubsection{Expression Typing}
\label{EXPRESSION-TYPING}

L-Language uses a top-down method of assigning types to operator arguments.
Generally given the statement
\begin{center}
$T$ $v$ ~ \TT{=} ~ $e1$ ~ $op$ ~ $e2$
\end{center}
where $T$ is a type of a variable $v$,
$op$ is a builtin arithmetic operator,
and $e1$, $e2$ are subexpressions that are the operands of $op$, then
the subexpression values are implicitly converted to type $T$
before the operation is done.  Here $T$ is called the `\key{target type}'
of the expression `$e1$ $op$ $e2$', and for builtin arithmetic operators
usually becomes the target type of the operand subexpressions.

An example is:

\begin{indpar}\begin{verbatim}
float64 w = 1.5
int64 x = 9,568
uns64 y1 = 0xFF00
uns32 y2 = 0xFF00
int64 z1 = x + y1
    // Compile error:
    //     y1 is not implicitly convertible to int64
int64 z2 = x + y2
    // OK, y2 IS implicitly convertible to int64
int64 z3 = x + y2 * w
    // Compile error:
    //     Target type of x + ( y2 * w ) is int64, so
    //     target type of y2 * w is int64, target type
    //     of y2 is int64 which is OK, and target type
    //     of w is also int64, but w is not implicitly
    //     convertible to int64.
\end{verbatim}\end{indpar}

More explicitly, the mechanism by which this all works is as
follows.  Given the statement
\begin{center}
\tt $T$ $v$ = $e1$ $op1$ $e2$ $op2$ $e3$
\end{center}
where $T$ is a type of a variable $v$, $e1$, $e2$, $e3$ are
operand subexpressions, and $op1$, $op2$, \ldots{} are builtin arithmetic
operators with the
same precedence like \TT{+} and \TT{-}, then
after parsing and compilation the statement is translated to
\begin{center}
\begin{tabular}{l}
\tt $T1$ tmp1 = $e1$ \\
\tt $T2$ tmp2 = $e2$ \\
\tt $T3$ tmp3 = tmp1 "$op1$" tmp2 \\
\tt $T4$ tmp4 = $e3$ \\
\tt $T$ $v$ = tmp3 "$op2$" tmp4 \\
\end{tabular}
\end{center}
For builtin arithmetic operators like \TT{+} and \TT{-} the function
prototype is equivalent to
\begin{center}
\tt $T$ r = ( $T$ arg1 ) "$op$" ( $T$ arg2 )
\end{center}
in which the arguments are given the same type as the result,
so the target type of the function call becomes the target type
of each argument.  Therefore in the example $T3\equiv T$ and
$T4\equiv T$.  The function call for computing {\tt tmp3} is
similar and results in $T2\equiv T$, $T1\equiv T$.  Therefore
all operands are converted to the target type $T$ of the final
result variable $v$.

The target type of an expression is usually provided by the
type of the variable being set by an assignment statement, or in the
case of function arguments, by the argument type specified in the
function prototype.

The target type of a {\em logical-expression} or a {\em comparison-expression}
is \TT{bool}.

In some cases the target type is specified by special rules.  The
target type of {\em comparison-operands} is specified by special
rules given in \itemref{COMPARISON-EXPRESSIONS}.

Some special rules
make use of the `\key{natural type}'\label{NATURAL-TYPE}
that some subexpressions have.
The natural type of a variable is its type.
For an expression of the form `\TT{$Qs$ $T$ ( \ldots{} )}'
where $Qs$ is a list of qualifiers and $T$ is a type name, the
natural type is $T$.
The natural type of a {\em function-call} is the type found by matching
the call to {\em function-prototypes}
(\itemref{MATCHING-CALLS-TO-PROTOTYPES}), if an unambiguous
match can be found under the assumption that
the call has a result variable of unknown type.
No other expression has a natural type.

When an expression has a natural type, it also has natural qualifiers
that are found with the natural type.

If there is no target type because an expression is being used
as a {\em simple-assignment-statement} with no result variables, then
the expression must be a {\em function-call} and can only match
{\em function-prototypes} that have no result variables.

\subsubsection{Evaluation Order}
\label{EVALUATION-ORDER}

All builtin operators evaluate operands and operators from
left to right.  All that are associative are left associative,
except the `\TT{else}' operator, which evaluates from left
to right because it has a deferred second operand, even though
it is right associative.

For example, `{\tt x <{}< s1 >{}> s2}' is
equivalent to `{\tt (x <{}< s1) >{}> s2}'.

The `\TT{if} operator defers its first operand, while
the `\TT{else}', `\TT{and}' and `\TT{or} operators, and sometimes the
6 builtin comparison operators (\TT{<}, \TT{==}, etc.),
defer their second operand.  Usually operands are evaluated
before the operator executes, but a deferred operand is not
evaluated until inspection of other operand values determines
that the deferred operand value will be needed.  Furthermore,
if the other operand values are available at compile time,
and inspecting them at compile time determines that the deferred
operand value will not be needed, the deferred operand is not
even compiled.  Such an uncompiled deferred operand might have
compile errors were it compiled, but it will cause no compile
errors if it is not compiled.

For example, if in `\TT{$e1$~and~$e2$}' the subexpression $e1$
evaluates to \TT{false}, the subexpression $e2$ is never evaluated.
If $e1$ evaluates at compile-time to \TT{false},
$e2$ is not compiled, and any compile errors it contains
are not detected.  Similarly in `\TT{$e1$~if~$b$~else~$e2$}' if the
conditioning expression $b$ evaluates to \TT{true}, $e2$ is
never evaluated, and if $b$ evaluates to \TT{true} at compile
time, $e2$ is never compiled.  However all subexpressions are parsed and
parsing errors are always detected.

Deferred operands are just a particular case of deferred function arguments,
as operators are translated by the parser into function calls.
For example, the `\TT{and}' operator, which the parser translates
into the {\tt "and"} function, is implemented by the function
declaration:

\begin{indpar}\begin{verbatim}
function bool r =
        ( bool arg1 ) "and" ( *DEFERRED* bool arg2 ):
    if:
        arg1:
            r = do ( std call context ):
                r = arg2
        else:
            r = false
\end{verbatim}\end{indpar}

The assignment statement `{\tt bool v = $e1$ and $e1$}' is
translated by the parser into `{\tt bool v = $e1$ "and" $e2$}' which
given the above function declaration compiles to:\label{AND-EXAMPLE}
\begin{indpar}
\begin{tabular}{l}
\tt std context tmp0 = std current context \\
\tt // tmp0 is call(er) context \\
\tt // and-context is context of "and" function declaration \\
\tt // \\
\tt // Evaluate $e1$ - left operand of "and"\\
\tt bool tmp1 = $e1$ \\
\tt // \\
\tt // Evaluate ($e1$ "and" $e2$) \\
\tt bool v = do ( and-context ): \\
\tt ~~if: \\
\tt ~~~~tmp1: \\
\tt ~~~~~~do ( tmp0 ): \\
\tt ~~~~~~~~v = $e1$ \\
\tt ~~~~else: \\
\tt ~~~~~~v = false \\
\end{tabular}
\end{indpar}

There are context issues here.  For details on contexts,
see \itemref{SCOPE},
\itemref{CONTEXTS}, and the context option of the
{\em block-assignment-statement} in 
\itemref{BLOCK-ASSIGNMENT-STATEMENTS}).

\subsubsection{If/Else Expressions}

The expression
\begin{center}
\tt $e1$ if $b1$ else $e2$ if $b2$ \ldots{} else $e$
\end{center}
is evaluated as follows.
$b1$ is evaluated first.  If it is \TT{true}, $e1$ is evaluated and its
value is returned.  If it is \TT{false}, $e1$ is \underline{not}
evaluated, and instead $b2$ is evaluated.  If that is \TT{true}
$e2$ is evaluated and its value is returned.  But if $b2$ is \TT{false}
evaluation of the expression continues.  If none of
the $bI$ evaluate to \TT{true}, $e$ is evaluated and returned as the result.

The target type of each $bI$ is \TT{bool} and the target type of each
$eI$ is the target type of the whole expression.
Only one of the $eI$ is evaluated.

If any $bI$ is a compile time
\TT{false} value, the associated $eI$ is not compiled or checked
for compile errors.
If any $bI$ is a compile time
\TT{true} value, the subsequent $bJ$'s and their associated $eJ$'s,
and also $e$,
are not compiled or checked
for compile errors.

In the rest of this section we consider the details of
how all the above happens.

A statement such as
\begin{center}
\tt $T$ $v$ = $e1$ if $b1$ else $e2$ if $b2$ else $e3$
\end{center}
is parsed to become
\begin{center}
\tt $T$ $v$ = ($e1$ "if" $b1$) "else" ( ($e2$ "if" $b2$) "else" $e3$ )
\end{center}

Here {\tt "else"} is parsed as a right associative operator,
but because it defers the evaluation of its right operand,
it evaluates its operands left to right.

The following are the builtin function definitions for
the {\tt "if"} and {\tt "else" } functions:

\begin{indpar}\label{IF-ELSE-IMPLEMENTATION}\begin{verbatim}
define type std *IF-VALUE* as void
    // The expression `e "if" b' has as its value an
    // *IF-VALUE* r that is a root of a cluster with members:
    //
    //    bool r.valid  Value of b.
    //    T r.value     Value of e if r.valid true.
    //                  *UNCHECKED* no value of type T
    //                  if r.valid false.
    //
    // where T is the type of the e value and cannot itself
    // equal *IF-VALUE*.

function *IF-VALUE* r, T r.value, bool r.valid =
        (| type T |)
        ( *DEFERRED* T arg1 ) "if" ( bool arg2 )
        [| T != std *IF-VALUE* |]:
    if:
        arg2:
                do ( std call context ):
                    r.value = arg1
                r.valid = true
        else:
            r.value = *UNCHECKED* ( no value )
            r.valid = false

function T r =
        (| type T |)
        ( *IF-VALUE* arg1, T arg1.value, bool arg1.valid )
        "else"
        ( *DEFERRED* T arg2 )
        [| T != std *IF-VALUE* |]
    if:
        arg1.valid:
            r = arg1.value
        else:
            do ( std call context ):
                r = arg2
\end{verbatim}\end{indpar}

These functions use an {\tt *IF-VALUE*} cluster (see
\itemref{CLUSTERS} for details of clusters) to record
whether the {\em logical-expression} input to the {\tt "if"}
function was \TT{true} or \TT{false} and also record
the value of the other expression input to the {\tt "if"}
function when the {\em logical-expression} was \TT{true}.
These functions use the {\em if-assignment} statement
descripted in \itemref{CONDITIONAL-ASSIGNMENT-STATEMENTS}.

Given these definitions the compiler expands the example
\begin{center}\label{IF-ELSE-EXAMPLE}
\tt $T$ $v$ = ($e1$ "if" $b1$) "else" ( ($e2$ "if" $b2$) "else" $e3$ )
\end{center}

to the following \LSTAR-language (\pagref{LSTAR-LANGUAGE}) code:

\begin{indpar}
\begin{tabular}{l}
\tt std context tmp0 = std current context \\
\tt // tmp0 is call(er) context \\
\tt // if-context is context of "if" function declaration \\
\tt // else-context is context of "else" function declaration \\
\tt // \\
\tt // Evaluate $b1$ - right operand of first "if"\\
\tt bool tmp1 = $b1$ \\
\tt // \\
\tt // Evaluate ($e1$ "if" $b1$) - left operand of first "else" \\
\tt *IF-VALUE* tmp2, $T$ tmp2.value, bool tmp2.valid = \\
\tt ~~~~do ( if-context ): \\
\tt ~~if: \\
\tt ~~~~tmp1: \\
\tt ~~~~~~do ( tmp0 ): \\
\tt ~~~~~~~~tmp2.value = $e1$ \\
\tt ~~~~~~tmp2.valid = true \\
\tt ~~~~else: \\
\tt ~~~~~~tmp2.value = *UNCHECKED* ( no value ) \\
\tt ~~~~~~tmp2.valid = false \\
\end{tabular}

\begin{tabular}{l}
\tt // Evaluate first "else" \\
\tt $T$ $v$ = do ( else-context ): \\
\tt ~~if: \\
\tt ~~~~tmp2.valid: \\
\tt ~~~~~~$v$ = tmp2.value \\
\tt ~~~~else: \\
\tt ~~~~~~do ( tmp0 ): \\
\end{tabular}

\begin{tabular}{l}
\tt ~~~~~~~~// Evaluate (($e2$ "if" $b2$) "else" $e3$") \\
\tt ~~~~~~~~// - deferred right operand of first "else" \\
\tt ~~~~~~~~// Evaluate $b2$ \\
\tt ~~~~~~~~// - right operand of second "if" \\
\tt ~~~~~~~~bool tmp3 = $b2$ \\
\tt ~~~~~~~~// Evaluate ($e2$ "if" $b2$) \\
\tt ~~~~~~~~// - left operand of second "else" \\
\tt ~~~~~~~~*IF-VALUE* tmp4, $T$ tmp4.value, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~bool tmp4.valid = \\
\tt ~~~~~~~~~~do ( if-context ): \\
\tt ~~~~~~~~~~~~if: \\
\tt ~~~~~~~~~~~~~~tmp3: \\
\tt ~~~~~~~~~~~~~~~~do ( tmp0 ): \\
\tt ~~~~~~~~~~~~~~~~~~tmp4.value = $e2$ \\
\tt ~~~~~~~~~~~~~~~~tmp4.valid = true \\
\tt ~~~~~~~~~~~~~~else: \\
\tt ~~~~~~~~~~~~~~~~tmp4.value = *UNCHECKED* ( no value ) \\
\tt ~~~~~~~~~~~~~~~~tmp4.valid = false \\
\end{tabular}

\begin{tabular}{l}
\tt ~~~~~~~~// Evaluate second "else" \\
\tt ~~~~~~~~do ( else-context ): \\
\tt ~~~~~~~~~~if: \\
\tt ~~~~~~~~~~~~tmp4.valid: \\
\tt ~~~~~~~~~~~~~~v = tmp4.value \\
\tt ~~~~~~~~~~~~else: \\
\tt ~~~~~~~~~~~~~~do ( tmp0 ): \\
\tt ~~~~~~~~~~~~~~~~v = $e3$ \\
\end{tabular}

\end{indpar}

In this code the type $T$ of the result variable $v$ becomes
the type of the result of the first {\tt "else"} whose
first argument then assumes the types given in
\begin{center}
\tt *IF-VALUE* tmp2, $T$ tmp2.value, bool tmp2.valid
\end{center}
and whose second argument gets type $T$.  The second argument
is the second {\tt "else"} subxpression, and as it has
target type $T$, the arguments of the second {\tt "else"}
have the same types as the arguments of the first {\tt "else"}.

The first argument of {\tt "if"} and the second argument of {\tt "else"}
are {\tt *DEFERRED*}, which means that they are not computed before
the functions are called, but instead the expressions computing them
are inserted in the code expanded from the functions (which are
inline).  See the discussion at the end of the Evaluation Order section
\itemref{EVALUATION-ORDER}.

\subsubsection{Logical (And/Or/Not) Expressions}

In logical expressions the `\TT{not}' operator is moved inside
`\TT{and}' and `\TT{or}' operators before further evaluation.
Also double negations are deleted.

Thus the following example:
\begin{center}
\begin{tabular}{lcl}
	  &			& \tt not ( x and not y and z ) \\
parser:	  & $\Longrightarrow$ 	& \tt not ( ( x and ( not y ) ) and z ) \\
compiler: & $\Longrightarrow$ 	& \tt ( not ( x and ( not y ) ) ) or
                                                        ( not z ) \\
compiler: & $\Longrightarrow$ 	& \tt ( ( not x ) or (not ( not y ) ) ) or
                                                        ( not z ) \\
compiler: & $\Longrightarrow$ 	& \tt ( ( not x ) or y ) or ( not z ) \\
\end{tabular}
\end{center}

The target type for logical expressions and their operands
is always \TT{bool}.

The expression\\
\centerline{\tt $b1$ and $b2$ and $b3$ and \ldots{}}\\[1ex]
is evaluated from left to right and if any $bI$ evaluates to \TT{false},
evaluation of later $bI$ is skipped.
If any $bI$ is a
compile time \TT{false} value, the remaining $bI$ are not compiled
or checked for compile errors.

Similarly the expression\\
\centerline{\tt $b1$ or $b2$ or $b3$ or \ldots{}}\\[1ex]
is evaluated from left to right and if any $bI$ evaluates to \TT{true},
evaluation of later $bI$ is skipped.
If any $bI$ is a
compile time \TT{true} value, the remaining $bI$ are not compiled
or checked for compile errors.

This is implemented by defining
the {\tt "and"} and {\tt "or" } functions as follows:

\begin{indpar}\begin{verbatim}
function bool r =
        ( bool arg1 ) "and" ( *DEFERRED* bool arg2 ):
    if:
        arg1:
            do ( std call context ):
                r = arg2
        else:
            r = false

function bool r =
        ( bool arg1 ) "or" ( *DEFERRED* bool arg2 ):
    if:
        arg1:
            r = true
        else:
            do ( std call context ):
                r = arg2
\end{verbatim}\end{indpar}

Here the right operands are {\tt *DEFERRED*} and if needed are
evaluated in the context of the caller of the {\tt "and"} or
{\tt "or"} functions.
See the discussion at the end of the Evaluation Order section
\itemref{EVALUATION-ORDER}.


\subsubsection{Comparison (</<=/==/!=/=>/>) Expressions}
\label{COMPARISON-EXPRESSIONS}

The target type for comparison expressions is always \TT{bool}.

There is no given target type for operands of comparison operators.
So the target type of these must be specified by rules.

For numeric operands of comparison operators
the target type is the most specific type (\pagref{MORE-SPECIFIC-RELATION})
in the following set that is such that all operands
can be implicitly converted to that type:
\begin{center}
\TT{unswrd} ~ \TT{intwrd} ~ \TT{unsmax} ~ \TT{intmax}
           ~ \TT{floatwrd} ~ \TT{floatmax}
\end{center}

An example assuming:


\begin{indpar}\begin{verbatim}
unswrd      is 32 bits
intwrd      is 32 bits
unsmax      is 64 bits
intmax      is 64 bits
\end{verbatim}\end{indpar}

is:

\begin{indpar}\begin{verbatim}
int64 x = 9,568
uns64 y1 = 0xFF00
uns32 y2 = 0xFF00
bool z1 = x < y1
    // Compile error:
    //     x and y1 cannot be implicitly converted
    //     to the same target type
bool z1 = x < y2
    // OK, x and y2 are implicitly convertible to
    // intmax (int64)
\end{verbatim}\end{indpar}

Non-numeric comparison operators require that one or more of
the operands have a natural type (\pagref{NATURAL-TYPE}) that
cannot be converted to one of the numeric types listed above.
In this case the target type is
the greatest lower bound (\pagref{GREATEST-LOWER-BOUND})
of all these natural types.
It is a compile error if this greatest lower bound does
not exist, or if comparison operators are not defined for this
type.
For example, given the expression `{\tt v == missing}', where \TT{v}
is of `\TT{qualifier}' type, {\tt missing}, which has no natural type, will be
evaluated with `\TT{qualifier}' target type.

Note that a comparison operator may not have a negation that is
also simply a comparison operator, e.g., \TT{=>} may not be the
negation of \TT{<}.  For example, both return \TT{false} if an
operand is \TT{NaN}.  For this reason `{\tt x => y}' and
`{\tt not ( x < y )}' are semantically different expressions.

Comparison expressions are evaluated from left to right and are
true if and only if all the comparisons are true.  Middle
arguments are shared between two comparison operators, e.g.,
in `{\tt x < y < z}' the middle argument {\tt y} is evaluated
once and shared between `{\tt x < y}' and `{\tt y < z}'.
An example is:

\begin{indpar}\begin{verbatim}
// Assume intwrd is int64, unswrd is uns64.
//
int64 x = 9,568
uns16 y1 = 0xFF00
uns32 y2 = 0xFF01
bool z1 = x < y1 < y2
    // x, y1, y2 are all converted to intwrd (int64).
    // y2 is only converted if x < y1 is true.
bool z2 = x < y1 and y1 < y2
    // y1 is converted to intwrd to compare it with x
    // and then if x < y1 is true, y1 is separately
    // converted to unswrd (uns64) to compare it with y2.
\end{verbatim}\end{indpar}

If one comparison in a sequence of comparisons evaluates
to \TT{false}, operands following those of this comparison
are not evaluated.  If one comparison in a sequence of comparisons
evaluates to \TT{false} at compile time,
the operands following those of this comparison are not compiled.

This is implemented by the following builtin code:

\begin{indpar}\label{COMPARE-IMPLEMENTATION}\begin{verbatim}
define type std *COMPARE-VALUE* as void
    // The expression `e1 "cop" e2' where cop is a comparison
    // opertor has as its value a *COMPARE-VALUE* r that is a
    // root of a cluster with members:
    //
    //    bool r.value  Result of comparison.
    //    T r.right op  Value of e2 (i.e., right operand) if
    //                  r.value is true.  *UNCHECKED* no
    //                  value if r.value is false.
    //
    // where T is the type of the operands and cannot itself
    // equal *COMPARE-VALUE*.
    //
    // *COMPARE-VALUE*s are implicitly convertable to bool's.

function Qs bool r = assign
                     (| qualifiers Qs |)
                     ( Qs *COMPARE-VALUE v, bool v.value ):
    r = v.value

// The following are defined separately for various types T
// and for comparison operators other than "<".
// 
function *COMPARE-VALUE* r, T r.right op, bool r.value =
        ( T arg1 ) "<" ( T arg2 ):
    r.right op = arg2
    r.value = arg1.right op "<" r.right op

function *COMPARE-VALUE* r, T r.right op, bool r.value =
        ( *COMPARE-VALUE* arg1, T arg1.right op,
                                bool arg1.value )
        "<" ( *DEFERRED* T arg2 ):
    if:
        arg1.value:
            do ( std call context ):
                r.right op = arg2
            r.value = arg1.right op "<" r.right op
        else:
            r.right op = *UNCHECKED* ( no value )
            r.value = false

function bool r = ( T arg1 ) "<" ( T arg2 ):
    r = [[[code to implement compare of arg1 and arg2]]]
\end{verbatim}\end{indpar}

Compare operations are left associative.

Given these definitions the parser expands the example
\begin{center}\label{COMPARE-EXAMPLE}
\tt bool $v$ = $e1 "<" $e2 "<" $e3$
\end{center}
to
\begin{center}
\tt bool $v$ = ( $e1 "<" $e2 ) "<" $e3$
\end{center}
and the compiler expands this to the following
\LSTAR-language (\pagref{LSTAR-LANGUAGE}) code:

\begin{indpar}
\begin{tabular}{l}
\tt std context tmp0 = std current context \\
\tt // tmp0 is call(er) context \\
\tt // lt-context is context of "<" function declaration \\
\tt // implied-conversion-context is context of the \\
\tt // ~~~~~~~~`assign' function declaration \\
\end{tabular}

\begin{tabular}{l}
\tt // Evaluate $e1$ and $e2$ - operands of first "<" \\
\tt T tmp1 = $e1$ \\
\tt T tmp2 = $e2$ \\
\end{tabular}

\begin{tabular}{l}
\tt // Evaluate `($e1$ "<" $e2$ )' \\
\tt // - right operand of second "<" \\
\tt *COMPARE-VALUE* tmp3, $T$ tmp3.right op, bool tmp3.value = \\
\tt ~~~~~~~~do ( lt-context ): \\
\tt ~~~~tmp3.right op = tmp2 \\
\tt ~~~~tmp3.value = tmp1 "<" tmp2 \\
\end{tabular}

\begin{tabular}{l}
\tt // Evaluate second "<" \\
\tt *COMPARE-VALUE* tmp4, $T$ tmp4.right op,\\
\tt ~~~~~~~~~~~~~~~~~~~~~~bool tmp4.value = \\
\tt ~~~~do ( lt-context ): \\
\tt ~~~~~~~~if: \\
\tt ~~~~~~~~~~~~tmp3.value: \\
\tt ~~~~~~~~~~~~~~~~do ( tmp0 ): \\
\tt ~~~~~~~~~~~~~~~~~~~tmp4.right op = $e3$ \\
\tt ~~~~~~~~~~~~~~~~tmp4.value = \\
\tt ~~~~~~~~~~~~~~~~~~~~tmp3.right op "<" tmp4.right op \\
\tt ~~~~~~~~~~~~else: \\
\tt ~~~~~~~~~~~~~~~~tmp4.right op = *UNCHECKED* ( no value ) \\
\tt ~~~~~~~~~~~~~~~~tmp4.value = false \\
\end{tabular}

\begin{tabular}{l}
\tt // Evaluate bool $v$ = assign ( ... ) \\
\tt bool v = do ( implied-conversion-context ): \\
\tt ~~~~v = tmp4.value \\
\end{tabular}

\end{indpar}

Typing of comparison expressions, as described above, is a
consequence of the rules for matching function calls to
prototypes, and specifically of the rule that more restrictive
argument types are preferred to less restrictive ones
(rule \ref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED} on
\pagref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}).
A function like {\tt "<"} is only defined for
some second operand types.  Given the type $T$ of the second operand
of the rightmost compare operator in a sequence of several compare operators,
the type of the first operand is a {\tt *COMPARE-VALUE*}
whose {\tt right op} member has type $T$.  Then the target types
of the remaining operands in the compare operator sequence are determined.
So if we have two candidates
for $T$, $T1$ and $T2$, we only need to choose the correct one.
By the rule cited, if $T1$ is implicitly convertable to $T2$, then
the types of both operands of the rightmost compare operator
in the $T1$ case will be
implicitly convertable to the types of the operands in the $T2$ case
and the rule will apply to reject $T2$.  Note that we do not need
an `{\tt assign}' function for {\tt *COMPARE-VALUE*}
values, as it suffices for the $T1$ `{\tt right op}' member to be
implicitly convertable to the $T2$ `{\tt right op}' member.

Importantly comparison operators, such as \TT{==}, are
\underline{not} defined for \TT{bool} operands.  Since many
types are implicitly convertable to \TT{bool}
(see \pagref{IMPLIED-BOOL-CONVERSION}), defining comparison
operators for \TT{bool} values would badly compromise compile time
detection of programming errors.\footnote{Another difficulty
with allowing comparison of \TT{bool} values is that in
`{\tt $e1$ < $e2$ < $e3$}' the first {\tt <} could evaluate
to a \TT{bool} and not a \TT{*COMPARE-VALUE*}.}

In order to implement a comparison operator $cop$ with optional
module abbreviation $ma$ for a new
type $T$, one defines a function with the prototype:
\begin{center}
\tt function bool r = $ma$\QMARK{} ( $T$ arg1 ) "$cop$" ( $T$ arg2 )
\end{center}
and then you add the line
\begin{center}
\tt define compare operator [$ma$]\QMARK{} ( $T$, "$cop$" )
\end{center}
This last line invokes the builtin generic:

\label{DEFINE-COMPARE-OPERATOR}%
\begin{indpar}\begin{verbatim}
generic std define compare operator ( type T, name OP )
            [| export if T exported |]:

    include ( T, OP ):

        function ..ma *COMPARE-VALUE* r, T r.right op,
                                       bool r.value =
                ( T arg1 ) OP ( T arg2 ):
            r.right op = arg2
            r.value = M ( arg1 op OP r.right op )

        function ..ma *COMPARE-VALUE* r, T r.right op,
                                       bool r.value =
                ( *COMPARE-VALUE* arg1, T arg1.right op,
                                        bool arg1.value )
                OP ( *DEFERRED* T arg2 ):
            if:
                arg1.value:
                    r.right op = do ( std call context ):
                        r.right op = arg2
                    r.value =
                        M ( arg1.right op OP r.right op )
                else:
                    r.right op = *UNCHECKED* ( no value )
                    r.value = false
\end{verbatim}\end{indpar}

\subsubsection{Integer Arithmetic Expressions}

If an integer arithmetic operator is being evaluated with
operand and target type \TT{uns$x$} or \TT{int$x$}, the
exact arithmetic result is computed and truncated to
$x$ bits, i.e., is taken modulo $2^x$ before being presented
as the result.

Some exceptions to this are made for integer division operations.
If the divisor is zero, the results are undefined.  If the
target type is \TT{int$x$}, the dividend is $-2^{x-1}$, and
the divisor is $-1$, the result is undefined.  In both these
cases the result may be a program terminating error.

Except for the right operands of
shift operators, the operand types of builtin
integer arithmetic operators are the target type of the result.

The arithmetic operators \TT{+}, \TT{-}, and \TT{*} are builtin.

The builtin bitwise operators are:
\begin{center}
\begin{tabular}{ll}
\TT{\&}		& bitwise AND \\
\TT{|}		& bitwise OR \\
\TT{xor}	& bitwise EXCLUSIVE OR \\
\TT{!}		& bitwise complement \\
\TT{<{}<}	& bitwise shift left \\
\TT{>{}>}	& bitwise shift right \\
\end{tabular}
\end{center}

In `{\tt v >{}> s}' and `{\tt v <{}< s}', {\tt v} is converted to the
target type which may be any integer type $T$, but {\tt s} is converted
to \TT{unswrd} and only its low order $x$ bits are used as the
shift amount, where $x$ is the size of $T$.
In other words, the shift amount is {\tt s mod 2$^x$}.

The builtin integer division operators are:
\begin{center}
\begin{tabular}{ll}
\TT{div}	& quotient rounded towards zero \\
\TT{mod}	& modulo; remainder when quotient is rounded
                  toward negative infinity \\
\TT{rem}	& remainder when quotient is rounded toward zero \\
\end{tabular}
\end{center}

The operator \TT{/} is strictly floating point.  The operator
\TT{\textasciicircum} is \underline{not} builtin and must be
defined by library code.

\subsubsection{Floating Point Arithmetic Expressions}
\label{FLOATING-POINT-ARITHMETIC-EXPRESSIONS}

There is a `\key{floating point error register}' that holds
floating point error flags that may be set by floating point
arithmetic and comparison operations.  These flags are `\key{sticky}', in that
arithmetic and comparison
operations may set them but may never clear them.  There are also
special builtin functions to manipulate these flags
(\itemref{FLOATING-POINT-ERROR-FLAG-FUNCTIONS}).

The flags and operation results when the flags are set are as follows:
\begin{indpar}
\mkey{Invalid Operand}{floating point error flag}
\begin{indpar}
Set upon one of the following:
\begin{center}
\begin{tabular}{l}
Compare operand is a \TT{NaN}. \\
Adding \TT{+Inf} and \TT{-Inf}. \\
Subtracting \TT{+Inf} from \TT{+Inf}. \\
Subtracting \TT{-Inf} from \TT{-Inf}. \\
Multiplying \TT{0} by \TT{+Inf} or \TT{-Inf}. \\
Dividing \TT{+Inf} or \TT{-Inf} by \TT{+Inf} or \TT{-Inf}. \\
Dividing \TT{0} by \TT{0}. \\
\end{tabular}
\end{center}

Except for compares, the result is \TT{NaN}.
For compares, the result is \TT{false}.
\end{indpar}

\mkey{Divide By Zero}{floating point error flag}
\begin{indpar}
Set by a floating point division with a \TT{+0} or
\TT{-0} divisor and a non-zero dividend.

The result is \TT{+Inf} if both operands have the
same sign and \TT{-Inf} if they have opposite signs.
\end{indpar}

\mkey{Result Overflow}{floating point error flag}
\begin{indpar}
Set if result has magnitude too large to store in a target type value.

If the result is positive, \TT{+Inf} is stored, and if negative,
\TT{-Inf} is stored.
\end{indpar}

\mkey{Result Underflow}{floating point error flag}
\begin{indpar}
Set if the result is too small to be stored, even as a denormalized
number, in a target type value.

The result is stored as \TT{+0} if it is positive and as
\TT{-0} if it is negative.
\end{indpar}

\mkey{Result Inexact}{floating point error flag}
\begin{indpar}
Set if result cannot be exactly stored in a target type value.
This happens frequently and is not normally considered a
real error.

The result is rounded to the nearest value, with ties to even.
\end{indpar}
\end{indpar}

Except for compares, \TT{NaN} operands cause \TT{NaN} results and
do \underline{not} set the invalid operand flag.

Results may be denormalized numbers.  Except for compares,
when an operand to an arithmetic operation is a denormalized
number, it is treated as a signed zero.

The builtin arithmetic floating point
operators are \TT{+}, \TT{-}, \TT{/}, and \TT{mod}.
The operand types of these operators are the target type of their result.
The operator
\TT{\textasciicircum} is \underline{not} builtin and must be
defined by library code.

\subsubsection{Qualifier/Type Subexpressions}
\label{QUALIFIER/TYPE-SUBEXPRESSIONS}

An expression of the form
\begin{center}
\tt $Q1s$ $T1$ ( $e$ )
\end{center}
where $Q1s$ are zero or more {\em qualifier-names}
and $T1$ is a {\em type-name},
when compiled in a statement of the form 
\begin{center}
\tt $Q2s$ $T2$ v = $Q1s$ $T1$ ( $e$ )
\end{center}
is compiled as
\begin{center}
\begin{tabular}{l}
\tt $Q1s$ $T1$ tmp = $e$ \\
\tt $Q2s$ $T2$ v = tmp
\end{tabular}
\end{center}
where {\tt tmp} is a temporary variable.

Similarly an expression of the form
\begin{center}
\tt $Q1s$ ( $e$ )
\end{center}
where $Q1s$ are one or more {\em qualifier-names},
when compiled in a statement of the form 
\begin{center}
\tt $Q2s$ $T2$ v = $Q1s$ ( $e$ )
\end{center}
is compiled as
\begin{center}
\begin{tabular}{l}
\tt $Q1s$ $T2$ tmp = $e$ \\
\tt $Q2s$ $T2$ v = tmp
\end{tabular}
\end{center}

\subsubsection{Module Abbreviation Subexpressions}
\label{MODULE-ABBREVIATION-SUBEXPRESSIONS}

An expression of the form
\begin{center}
\tt $ma$ ( $e$ )
\label{MODULE-ABBREVIATION-SEMANTICS}
\end{center}
where $ma$ is a {\em module-abbreviation} is modified
by the parser (not the compiler).  The parser prefixes
$ma$ to the unparenthesized operators in the the subexpression $e$.

For example,
\begin{center}
\begin{tabular}{c}
\tt $ma$ ( x + ( y1 + y2 ) + ( z1 * z2 ) ) \\
becomes \\
\tt $ma$ ( $ma$ x "+" ( y1 "+" y2 ) ) "+" ( z1 "*" z2 )
\end{tabular}
\end{center}
and
\begin{center}
\begin{tabular}{c}
\tt $ma$ ( x + ( y1 + y2 ) + z1 * z2 ) \\
becomes \\
\tt $ma$ ( $ma$ x "+" ( y1 "+" y2 ) ) "+" ( $ma$ z1 "*" z2 )
\end{tabular}
\end{center}

\subsubsection{User Defined Standard Operators}
\label{USER-DEFINED-STANDARD-OPERATORS}

The standard operators for comparison and arithmetic can be overloaded
for a non-builtin type $T$ with an optional module abbreviation
$ma$ by defining functions with the following prototypes:
\begin{indpar}
{\tt function bool r = $ma$\QMARK{} ( $T$ $v1$ ) "$op$" ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of \TT{<}, \TT{<=}, \TT{==}, \TT{!=}, \TT{=>}, or \TT{>}

In addition, to allow sequences of compare operators with operands
of type $T$, for each compare operator $op$ you must include the line
\begin{center}
\tt define compare operator ( $T$, "$op$" )
\end{center}
as described on \pagref{DEFINE-COMPARE-OPERATOR}.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} ( $T$ $v1$ ) "$op$" ( unswrd $v2$ )}
\begin{indpar}
where $op$ is one of \TT{<{}<} or \TT{>{}>}
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} "$op$" ( $T$ $v1$ )}
\begin{indpar}
where $op$ is one of \TT{-}, \TT{+}, or \TT{!}
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} ( $T$ $v1$ ) "$op$" ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of
    \TT{+}, \TT{-},
    \TT{*}, \TT{/}, \TT{div}, \TT{mod}, \TT{rem}, \TT{\textasciicircum},
    \TT{\&}, \TT{|}, \TT{xor}
\end{indpar}

\end{indpar}


The operators {\tt "if"}, {\tt "else"}, {\tt "and"},
{\tt "or"} and {\tt "not"} should not be overloaded.

\section{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

Variables are allocated to the current function frame
and are also given their values by assignment statements.
After the assignment statement allocating a variable,
the value of the variable cannot be changed.  However,
a new variable of the same name can be allocated via
the `\TT{next}' construction which we describe below.

Assignment statements have the syntax:
\begin{indpar}
\emkey{assignment-statement}
    ::= \{ {\em result-variable-list} \TT{=} \}\QMARK{}
    		{\em assignment-right-side}
\\[0.5ex]
\emkey{result-variable-list}\label{RESULT-VARIABLE-LIST}
    ::= {\em result-variable}
	  \{ \TT{,} {\em result-variable} \}\STAR{}
\\[0.5ex]
\emkey{result-variable}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em result-variable-declaration} \\
    $|$ & {\em next-variable-declaration} \\
    $|$ & {\em deferred-variable}
    		& [see \pagref{DEFERRED-VARIABLE}] \\
    $|$ & {\em iteration-result-variable}
    		& [see \pagref{ITERATION-RESULT-VARIABLE}] \\
    \end{tabular}
\\[0.5ex]
\emkey{result-variable-declaration}\label{RESULT-VARIABLE-DECLARATION}
    ::= {\em qualifier-name}\STAR{}~{\em type-name}~{\em result-variable-name}
\\[0.5ex]
\emkey{next-variable-declaration}\label{NEXT-VARIABLE-DECLARATION}
    ::= \ttkey{next}~{\em result-variable-name}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
\emkey{result-variable-name}\label{RESULT-VARIABLE-NAME}
    ::= \begin{tabular}[t]{l}
        {\em variable-name} without {\em member-selectors} \\
	(in the \LSTAR-Language (\pagref{LSTAR-LANGUAGE})
	 {\em member-selectors} are allowed)
	\end{tabular}
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{assignment-right-side}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em expression-list}
    		& [see \pagref{EXPRESSION-LIST}] \\
    $|$ & {\em function-call}
    		& [see \pagref{FUNCTION-CALL}] \\
    $|$ & {\em generic-call}
    		& [see \pagref{GENERIC-CALL}] \\
    $|$ & {\em block}
	        & [see kinds of assignment statement below] \\
    \end{tabular}
\end{indpar}

where the {\em assignment-right-side}
depends on the kind of assignment statement.
The kinds of assignment statements are:
\begin{indpar}
\emkey{assignment-statement}
    \begin{tabular}[t]{rll}
    ::= & {\em simple-assignment-statement}
	& \itemref{SIMPLE-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em block-assignment-statement}
	& \itemref{BLOCK-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em conditional-assignment-statement}
	& \itemref{CONDITIONAL-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em loop-assignment-statement}
	& \itemref{LOOP-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em call-assignment-statement}
	& \itemref{CALL-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em out-of-line-assignment-statement}
	& \itemref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em compile-and-run-assignment-statement}
	& \itemref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em compile-time-assignment-statement}
	& \itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em assembly-assignment-statement}
	& \itemref{ASSEMBLY-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em function-call}
	& \itemref{FUNCTION-PROTOTYPES-AND-CALLS} \\
    $|$ & {\em generic-call}
	& \itemref{GENERICS} \\
    \end{tabular}
\end{indpar}

If an {\em assignment-statement} has {\em result-variable-declarations}
that give {\em variable-names} with types and qualifiers,
these result variables are allocated to the current function frame, and
values produced by evaluating the {\em assign\-ment-right-side} are stored in
these variables.

The {\em assignment-right-side} may produce a list of values which can be
used to set multiple {\em result-variables}.  The {\em assignment-right-side}
is completely evaluated before any {\em result-variables} are set.

When a variable value is set, the value is implicitly first
computed in a register, then stored in the current function
frame, and for some time
afterwards the value is left in the register which becomes a cache
on the frame value.  This caching is hidden from the programmer.

If a variable value is copied from another variable, usually the
new variable simply becomes a compile-time alias for the old variable.
No executable copy code is created, no new register is allocated, and no new
value is pushed into the stack.

Similarly if a variable value can be easily computed from previous variable
values by in-line code, 
its value may not be stored into the function frame.  Instead its
value can be recovered at any time by repeating the computation
of the variable from the other values.

The value assigned to each result variable must be implicitly convertible to
the variable's type.  In some cases the type of a result variable is
the target type of an {\em expression} in a {\em assignment-right-side}
that is an {\em expression-list}
(\itemref{SIMPLE-ASSIGNMENT-STATEMENTS}).
In some cases the result variable type is matched to
the type of a {\em function-prototype} result variable
for a {\em function-call} that is the {\em assignment-right-side}
(\itemref{MATCHING-CALLS-TO-PROTOTYPES}).

A {\em result-variable-declaration} acts
as a declaration of its variable,
and the scope of the declarations includes any {\em subblock} that may
constitute the {\em assignment-right-side}.
Result variables are not allowed to hide (\pagref{HIDE})
other {\em name} declarations with exceptions listed on
\pagref{HIDING-EXCEPTIONS}.

A {\em next-variable-declaration} is similar to a
{\em result-variable-declaration}, but uses the word
`\ttkey{next}'\label{NEXT} in
place of the {\em qualifier-names} and {\em type-name}
of a result variable being assigned a value.  The named result variable must
have been previously assigned a value within the same smallest containing block.
A new variable with the same qualifiers, type, and name
as that previous variable is allocated,
and the new variable supersedes that previous variable
in subsequent code within the block.  Thus if {\tt v} is the name
of a variable declared in a block, then after `{\tt next v}' is
assigned, {\tt v} refers to the value assigned to `{\tt next v}'.

See the example in \itemref{SIMPLE-ASSIGNMENT-STATEMENTS}, and
the more detailed discussion in 
\itemref{BLOCK-ASSIGNMENT-STATEMENTS}.

Note that `\TT{next}' behaves differently when it used as part of
the name of
a {\em deferred-variable} (\pagref{DEFERRED-VARIABLE})
or an {\em iteration-result-variable} (\pagref{ITERATION-RESULT-VARIABLE}).

The {\em result-variables} may be completely omitted if the
{\em assignment-right-side} is a {\em subblock}, is a
{\em function-call} matching a {\em function-prototype} that has
no result variables (\itemref{MATCHING-CALLS-TO-PROTOTYPES}),
or is a {\em generic-call} (\itemref{GENERICS}).
Because such statements still have
the form and semantics of statements that could have result variables,
we call them `{\em assignment-statements}' even though they allocate
and assign no result variables.

Also there are statements with the form:
\begin{center}
{\em function-call} ~ \TT{=} ~ {\em expression-list}
\end{center}
which are syntactic sugar for a {\em function-call}
in which the {\em expression-list} has been made into a function argument
list and there are no result variables.
{\em Function-calls} \underline{cannot} be used as result variables.
See \itemref{MATCHING-CALLS-TO-PROTOTYPES}.

The \LSTAR-language (\pagref{LSTAR-LANGUAGE}) extends the L-Language
by allowing {\em result-variable-names} to contain {\em member-selectors}.

\subsection{Simple Assignment Statements}
\label{SIMPLE-ASSIGNMENT-STATEMENTS}

The simplest \skey{assignment statement}s have the syntax:

\begin{indpar}
\emkey{simple-assignment-statement}
    ::= {\em result-variable-list} \TT{=} {\em expression-list}
\\[0.5ex]
\emkey{expression-list}\label{EXPRESSION-LIST}
    ::= {\em expression} \{ \TT{,} {\em expression} \}\STAR{}
\end{indpar}

If there is more than one {\em expression} in the {\em expression-list},
or if there is a single {\em expression} that is \underline{not}
a {\em function-call},
then each {\em expression} produces a single value, and the list of these
values is the list of values assigned to the list of result variables.
The {\em expressions} are evaluated in left to
right order, and all the {\em expressions} are evaluated before any of
the result variables are given values.
In this case there must be the same number of {\em expressions}
in the {\em expression-list} as there are result variables.

If the {\em expression-list} is a single {\em expression} that
is a {\em function-call} which
returns a list of values, this list of values is used.
In this case the {\em function-call} may produce more values than
there are result variables, and the excess values are discarded,
as long as there is at least one result variable.
if there are no result variables, the
{\em function-call} must match a {\em function-prototype} that has
no result variables (\itemref{MATCHING-CALLS-TO-PROTOTYPES}).

If an {\em expression-list} contains more than one {\em expression},
and one of the {\em expressions} is a {\em function-call}, only the
first value returned by the function is used, and any other values
returned by the function are discarded.

An {\em expression} may only input values that are constants,
the values of variables in the same function execution
frame (including arguments passed to the function execution), 
or the values of global variables.  In particular,
no input can come \underline{directly}
from RAM memory outside the current function execution frame or
global memory,
but see \pagref{MEM} and Section~\itemref{THE-MEM-QUALIFIER}
for ways to load RAM values into function frame variables.
See Section~\itemref{STACK-MANAGEMENT} for more information about
function frames.

The value assigned to each result variable must be implicitly convertible to
the variable's type.
In the case that an {\em expression} is producing
only a single value, the type of its associated result variable is the target
type of the {\em expression}.  If there is only one {\em expression}
and that is a {\em function-call}, the types the result variables
are matched to the types of the {\em function-prototype} result
variables (\itemref{MATCHING-CALLS-TO-PROTOTYPES}).

Some examples of {\em simple-assignment-statements} are:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = x + 1         // y == 2
next x = 10 * x         // Now x == 10
next y = x + y          // Now y == 12
int32 z = 256 + y       // z == 268
int8 u = z              // ILLEGAL!  Undefined implied
                        // conversion from int32 to int8.
int8 v = truncate ( z ) // Now v == 12
int8 w = v + 257        // ILLEGAL!  Constant out of range
                        // of target type int8.
float32 m = 1.7
int64 i = m             // ILLEGAL!  Undefined implied
                        // conversion from float32 to int64.
int32 j = nearest ( m ) // now j == 2 (round to nearest)
int32 y = x + y         // ILLEGAL! y hides y.
\end{verbatim}\end{indpar}

\subsection{Block Assignment Statements}
\label{BLOCK-ASSIGNMENT-STATEMENTS}

Another variant of the assignment statement is\index{block assignment}:

\begin{indpar}
\emkey{block-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \\
	\TT{~~~~}\{ \ttkey{do} {\em block-name}\QMARK{}
	              \{ \TT{(} {\em context-expression} \TT{)} \}\QMARK{}
	              \}\QMARK{} \TT{:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{}
	\end{tabular}
\\
\emkey{block-name} ::=
    \begin{tabular}[t]{l}
    {\em name} ~~~~~ [see \pagref{NAME}] \\
    \underline{not} containing
	`\TT{.}',~ {\em quoted-marks},~ or {\em quoted-separators} \\
    \end{tabular}
\end{indpar}

where `\TT{do} {\em block-name}\QMARK{}
	              \{ \TT{(} {\em context-expression} \TT{)} \}\QMARK{}'
may be omitted as long as \TT{=} is not omitted.

The {\em statements} within the {\em block-assignment-statement}
comprise a `\key{block}' of code.

Unless `\TT{(} {\em context-expression} \TT{)}' is given,
a {\em block-assignment-statement} is
compiled in the current context (\pagref{CONTEXT}),
and {\em names} declared within the block are \underline{not} permitted
to hide (\pagref{HIDE}) {\em names} declared before the block.
But if `\TT{(} {\em context-expression} \TT{)}' is given,
the {\em block-assignment-statement} is
compiled in the context given by {\em context-expression},
and names declared within the block
are permitted to hide names in the specified context.

Any result variables in a {\em block-assignment-statement}
are called `\skey{deferred variable}s' because they do not
immediately get a value.  They are assigned values by
{\em assignment-statements} within the block
whose {\em result-variable-lists}
include {\em deferred-variables}:
\begin{indpar}
\emkey{deferred-variable}\label{DEFERRED-VARIABLE}
    \begin{tabular}[t]{rl}
    ::= & {\em result-variable-name} \\
    $|$ & \TT{next} ~ {\em result-variable-name} \\
    $|$ & {\em prototype-result-variable-name} \\
    \end{tabular}
\\[1ex]
\emkey{prototype-result-variable-name} ::= {\em variable-name}
\end{indpar}
{\em Deferred-variables} of the first two forms are names of
{\em result-variables} of containing {\em assignment-blocks},
while {\em prototype-result-variable-names} are names of
result variables of the prototype of a containing
{\em function-delcaration} or {\em generic-declaration}
(\pagref{FUNCTION-PROTOTYPE}).  These latter can contain
{\em member-selectors}.

{\em Assignment-statements} that set {\em deferred-variables}
are called `\skey{deferred assignment}s'.

No {\em qualifier-name} or {\em type-name} may be a prefix of
a {\em variable-name} used as a
{\em deferred-variable}.
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.

Variables declared in the block may not hide (\pagref{HIDE})
variables declared outside the block, including the result
variables of the block, with exceptions listed on
\pagref{HIDING-EXCEPTIONS}.

The code must be such that every deferred variable is given a value
by at most one deferred assignment, and if not a `\TT{next}' variable,
is given a value by a deferred assignment before the variable is read.
If a deferred variable is of the form `{\tt next v}', then {\tt v}
may be used in the block to refer to the variable value assigned
outside and before the {\em block-assignment-statement}, up to
the point where `{\tt next v}' is assigned a value in the block.
After that point {\tt v} refers to the value assigned to `{\tt next v}'.

An example of a {\em block-assignment-statement} is:
\begin{indpar}\begin{verbatim}
int32 x = 1
float64 y = 1.67
int64 z, uns8 w, next x =:

    z = 16,777,216   // Legal, z is deferred variable
    x = 265          // ILLEGAL, x is NOT deferred variable
    float64 y = 2.6  // ILLEGAL, y is visible outside block
    uns8 v = 55      // Legal, v is NOT visible outside block
    next x = 265 + x // Legal, next x is deferred variable,
                     //        now x == 266
    next y = 2.6     // ILLEGAL, y is visible outside block
                     //          and next y is not deferred
                     //          variable
    w = truncate ( x )  // Legal, w is deferred variable,
                     // sets w to 10 as x is now 266
\end{verbatim}\end{indpar}

An exit statement may be used to jump from within a block to
the end of the block:

\begin{indpar}
\emkey{exit-statement} ::=
        \ttkey{exit} ~ {\em block-name}\QMARK{} ~
	    \{ \TT{if} ~ {\em condition-expression} \}\QMARK{}
\end{indpar}

If the {\em block-name} is not given, the smallest block containing
the {\em exit-statement} is exited.

The block exit may be conditional.  The compiler checks that
if non-conditional exits are taken and conditional
exits are either taken or not, each one of the block's
deferred variables is given a value by a single deferred assignment statement.
However, if a {\em block-name} is given and the exit statement is in
a subblock of the named block,
the deferred variables of this subblock
need not be given values.

Examples of {\em exit-statements} are:

\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
bool v = do BLOCK1:
    // sets v = ( x <= 10 or y => 10 )
    //
    do BLOCK2:
        exit BLOCK2 if not x <= 10
        v = true
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3 if not y => 10
        v = true
        exit BLOCK1
    v = false

next v = do BLOCK1:
    // attempts to set next v = ( x <= 20 or y => 20 )
    next v = true
    exit BLOCK1 if x <= 20
    exit BLOCK1 if y => 20
    next v = false          // ILLEGAL: next v set twice
\end{verbatim}\end{indpar}

L-Language parses all code, but does not compile statements that
cannot be reached from the beginning of the current top level
statement (e.g., out-of-line function declaration).  Because
of unconditional \TT{exit} statements, or \TT{exit} statements
whose conditions evaluate to \TT{true} at compile time,
some statements will be unreachable and will not be compiled.
Unreachable statements are not checked for non-parsing compile
errors.

For example, the code
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
int32 z = do BLOCK1:
    do BLOCK2:
        exit BLOCK2 if not x <= 10
        z = 55
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3 if not y => 10
        z = "hot dog"    // Illegal conversion
        exit BLOCK1
    z = "cold dog"       // Illegal conversion
\end{verbatim}\end{indpar}

becomes after eliminating unreachable statements:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
int32 z = do BLOCK1:
    do BLOCK2:
        exit BLOCK2 if false
        z = 55
        exit BLOCK1
\end{verbatim}\end{indpar}

and therefore has no compiler errors.


\subsection{Conditional Assignment Statements}
\label{CONDITIONAL-ASSIGNMENT-STATEMENTS}

\ikey{Conditional assignment statements}{conditional assignment}
are syntactic sugar for block assignment statements
with exits (\pagref{BLOCK-ASSIGNMENT-STATEMENTS}).
Conditional assignment statements have the syntax:

\begin{indpar}
\emkey{conditional-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \ttkey{if}\TT{:} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	\TT{~~~~}\ttkey{else}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

In this case the {\em condition-expressions} are evaluated in order
until either one evaluates to true or the `\TT{else}' condition is
reached, and then the {\em statements} subject to the
first true condition (a.k.a the \key{subblock} of that condition)
are executed, or if no condition is true, the {\em statements}
of the `\TT{else}' subblock are executed.

Every variable in the {\em result-variable-list} \underline{must} be set by the
single subblock that executes, unless that subblock exits a block
that contains the {\em conditional-assignment-statement}.  A variable in the
{\em result-variable-list} cannot be read by a subblock {\em statement}
unless it is set by a previous {\em statement} in the
same subblock.

An example is:
\begin{indpar}\begin{verbatim}
function float64 result =
        max ( float64 x, float64 y, float64 z ):
    result = if:
        y <= x => z:
            result = x
        z <= y => x:
            result = y
        y <= z => x:
            result = z
        else:
            result = NaN
\end{verbatim}\end{indpar}

where \TT{NaN} means `\key{not-a-number}' and is the missing
value for \TT{float64} variables.  {\tt x~=>~y} is true if
and only if neither {\tt x} nor {\tt y} is a \TT{NaN} and
{\tt x} is equal to or greater than {\tt y}.  Thus if any of
{\tt x}, {\tt y}, or {\tt z} in the above conditional assignment
is a \TT{NaN}, none of the {\em conditional-expressions}
will be \TT{true}, and the \TT{else} subblock will be evaluated to set
the {\tt result} to a \TT{NaN}.

The following special rule applies to
{\em conditional-assignment-statements}:\label{CONDITIONAL-SPECIAL-RULE}

\begin{itemize}
\item
If some of the {\em conditional-expressions} can be computed at compile
time, subblocks that the compiler determines cannot execute are not
compiled or checked for compiler errors (but the subblocks are parsed
and checked for parsing errors).

Specifically, if a {\em conditional-expression} evaluates to \TT{true}
at compile time, subblocks beyond the subblock
of this {\em conditional-expression}
are not compiled.  And if a remaining {\em conditional-expression}
evaluates to \TT{false} at compile time, the subblock of this
{\em conditional-expression} is not compiled.
\end{itemize}

For example, if a {\em conditional-assignment-statement}
contained
\begin{indpar}\begin{verbatim}
    x => 1,000,000:
        result = NaN
\end{verbatim}\end{indpar}
where {\tt x} is a variable with value known at compile time
that is less than {\tt 1,000,000}, then
`{\tt result = NaN}' will not compile
and will not be checked for compile time errors.

The \TT{else} subblock cannot be omitted unless one of the
other subblocks has a conditional that evaluates to \TT{true}
at compile time.  For
example, the following has a compile time error unless
one of the conditionals evaluates to \TT{true} at compile time:
\begin{indpar}\begin{verbatim}
    result = if:
        x <= y:
            result = x
        y <= x:
            result = y
        // ILLEGAL because result is not set if there
        // is no else subblock.
\end{verbatim}\end{indpar}
Possible \TT{else} subblocks for this example are:
\begin{indpar}\begin{verbatim}
        else:
            result = default value
\end{verbatim}\end{indpar}
or
\begin{indpar}\begin{verbatim}
        else:
            result = *UNCHECKED* ( no value )
\end{verbatim}\end{indpar}
or
\begin{indpar}\begin{verbatim}
        else:
            program stop
\end{verbatim}\end{indpar}

\subsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

\ikey{Loop assignment statements}{loop assignment}
are similar to block assignment
and conditional assignment statements.  An example is:
\begin{indpar}\begin{verbatim}
// Calculate the sum of i for i == 1 to i == n.
//
int64 n = . . .
int64 sum = loop:
    initially:
        int64 i = 1
        int64 partial sum = 0
    while i <= n:
        next partial sum = partial sum + i
        next i = i + 1
    finally:
        sum = partial sum
\end{verbatim}\end{indpar}



The general syntax of loop assignment statements is:

\begin{indpar}
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	          \ttkey{loop:} \\
	\TT{~~~~}\ttkey{initially}\TT{:} \\
	\TT{~~~~~~~~~}{\em iteration-variable-assignment-statement}\STAR{} \\
	\TT{~~~~}\{ \ttkey{while} $|$ \ttkey{until} \}
	         {\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ttkey{finally}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{iteration-variable-assignment-statement} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    {\em assignment-statement} in which all {\em result-variables} \\
    are {\em result-variable-declarations}
    \end{tabular}
\end{indpar}

This is somewhat like the conditional assignment statement
except the `\TT{while}' or `\TT{until}'
subblock is iterated and there are iteration
variables defined by the `\TT{initially}' subblock.

The `\TT{initially}' subblock is call the `\key{initialization subblock}',
the `\TT{while/until}' subblock is call the `\key{iteration subblock}',
and the `\TT{finally}' subblock is call the `\key{finalization subblock}'.

The \skey{iteration variable}s are the
{\em result-variables} declared by the
{\em iteration-variable-assignment-statements} executed by the initialization subblock.
Each iteration of the loop gives these variables new values using
`{\tt next v}' to refer to the value of {\tt v} in the next iteration,
where {\tt v} is an iteration variable.  In the example `{\tt i}' and
`{\tt partial sum}' are iteration variables.

An iteration subblock qualified by `\ttkey{while}'
{\em condition-expression}' only executes if the
{\em condition-expression} evaluates to \TT{true},
whereas an iteration subblock qualified by `\ttkey{until}'
{\em condition-ex\-pres\-sion}' only executes if the
{\em condition-expression} evaluates to \TT{false}.

Lastly, when the {\em condition-expression} evaluates so the iteration
subblock is not executed, the finalization subblock
executes, and it must set all the variables in the
loop statement's {\em result-variable-list}.  At this point the loop stops
executing.

Loops are always in effect unraveled so multiple copies of
the iteration subblock exist at one time.

Within the initialization and iteration subblocks assignment
statements may set iteration variables in adjacent subblocks
using the following syntax for assignment statement result variables:
\begin{indpar}
\emkey{iteration-result-variable}\label{ITERATION-RESULT-VARIABLE}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{next}{iteration result variable} ~
                      {\em result-variable-name} \\
    $|$ & \ttmkey{next next}{iteration result variable}
                      {\em result-variable-name} \\
    \end{tabular}
\end{indpar}
{\em Assignment-statements} that set {\em iteration-result-variables}
are called `\skey{iteration assignment}s'.

Let {\tt v} be an iteration variable.  After it is set in the initialization
subblock, `{\tt v}' refers to the value of the variable in both
the initialization subblock and the first iteration.
`{\tt next v}' refers to the value of the variable in the second
iteration.  In order to prevent confusion, `{\tt v}' cannot
be used in the initialization subblock after `{\tt next v}' has
been assigned, `{\tt next v}' cannot be used in the subblock
except as a result variable when it is assigned, and
`{\tt next next v}' cannot be used in the initialization subblock.

Within the iteration
subblock, `{\tt v}' refers to the value of the variable in the
current iteration, `{\tt next v}' refers to the value of the variable
in the next iteration, and `{\tt next next v}' refers to the
value of the variable in the next iteration after the next iteration.
In order to prevent confusion, `{\tt v}' cannot
be used in the iteration subblock after `{\tt next v}' or
`{\tt next next v}' has been assigned,
and `{\tt next v}' and `{\tt next next v}'
cannot be used in the subblock
except as a result variables when they are assigned.

Within the finalization
subblock, `{\tt v}' refers to the value the variable would have
for an additional iteration if such an iteration existed.
Within the finalization subblock `{\tt next v}' and
`{\tt next next v}' cannot be used.

For a given iteration variable {\tt v},
either the initialization subblock sets {\tt v}
and the iteration subblock sets `{\tt next v}',
or the initialization subblock sets both {\tt v} and `{\tt next v}'
and the iteration subblock sets `{\tt next next v}'.

There are always at least 4 iterations of the loop with variables
simultaneously in the current function frame: the current iteration,
the previous iteration (if any), and the next two iterations.
When the third iteration of the loop starts, the first
iteration can be discarded, and so forth.

Code in an initialization or iteration subblock cannot set
deferred result variables outside the subblock (including loop block
result variables), or contain \TT{exit} statements that have
no block label (however such statements may be in subblocks 
of the initialization or iteration subblock).

\subsection{Call Assignment Statements}
\label{CALL-ASSIGNMENT-STATEMENTS}

Note that most functions are inline, and not out-of-line.
Inline functions are described later
in Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS}.

\ikey{Call assignment statements}{call assignment}
are used to call out-of-line functions:

\begin{indpar}
\emkey{call-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em call-assignment-option}\STAR
		~\ttkey{call}~ {\em function-expression} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{}
	\end{tabular}
\\[1ex]
\emkey{call-assignment-option}
	\begin{tabular}[t]{rl}
	::= & \ttakey{UNCHECKED} $|$ \ttakey{REVERSE}
	                          $|$ \ttakey{NO-RELOAD} \\
	$|$ & \ttakey{COMPILE-TIME} $|$ \ttakey{COMPILE-TIME-ONLY}
	\end{tabular}
\\[1ex]
\emkey{argument-assignment-statement} ::=
    \begin{tabular}[t]{l}
    {\em assignment-statement} in which all {\em result-variables} \\
    are {\em result-variable-declarations}
    \end{tabular}
\end{indpar}

The {\em function-expression} evaluates to a function to be called,
and must have a natural type (\pagref{NATURAL-TYPE})
$T$ that has \TT{adr} as its underlying type.

The values of the variables created by the {\em argument-assignment-statements}
are the arguments to the function.
The results of the function call are stored in the
{\em result-variable-list} variables.

A call assignment must have the \TT{*UNCHECKED*} option
unless $T$ is declared by an out-of-line
function type declaration described below.  If there is no
such declaration, the arguments are presented to the out-of-line
function in the order they are listed in the {\em call-assignment-statement},
unless the \TT{*REVERSE*} option is given, in which case this order
is reversed.

If there is an out-of-line function type declaration, arguments in the
call are matched by name to arguments in the type declaration,
and then ordered as per the type declaration.  In this case
the \TT{*REVERSE*} option is not permitted.

Normally a `\TT{reload *MEM*, *MEM* dependent}'
statement (see \itemref{THE-RELOAD-COMMAND})
is executed automatically
upon returning from the called function, but the
\ttakey{NO-RELOAD} option suppresses this.
If the \TT{*NO-RELOAD*} is given, the \TT{*UNCHECKED*} option must
also be given.

If the \TT{*COMPILE-TIME*} option is given, the call
will be made at compile time only if the argument values are available
at compile time, and will otherwise be made at run time.  When the call
is made determines whether any result variable values are determined
at compile time.  If the \TT{*COMPILE-TIME-ONLY*} option is given,
the call is made at compile time, and the argument values must be
available at compile time.

An out-of-line function type declaration has the form:

\begin{indpar}
\emkey{function-type-declaration}\label{FUNCTION-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function type}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{}
		    {\em defined-type-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{}
	\end{tabular}
\\[0.5ex]
\emkey{argument-variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{function-declaration-option}
	\begin{tabular}[t]{rl}
	::= & \ttakey{COMPILE-TIME} \\
	$|$ & \ttakey{COMPILE-TIME-ONLY}
	\end{tabular}
\end{indpar}

This makes \TT{adr} the base type of the new
defined type, and declares the prototype
for the out-of-line function.
Then a call assignment block is type-checked by matching
the variable names in the call assignment block
to those in the prototype.  Thus in this case the order of variables
in the call block does not matter as they will be matched by
variable name to the prototype and then their values will be
reordered according to the prototype.  Also, in this case
a call block argument
may be of different
type than corresponding prototype argument if there is an implied
conversion from the call block
argument type to the prototype argument type,
in which case the implied conversion will be invoked.
Similarly a prototype result variable may be converted to
a call block result variable by an implied conversion.

The result and argument variables in a 
{\em function-type-declaration} are permitted to hide (\pagref{HIDE})
names in the context of the declaration, but the {\em defined-type-name}
may not.

A function type may be declared multiple times.  All these declarations
must be identical except for ordering of options and qualifiers.

Out-of-line functions may be declared by
an assignment statement of the form:
\begin{indpar}
\emkey{out-of-line-function-deferred-assignment}%
\label{OUT-OF-LINE-FUNCTION-DEFERRED-ASSIGNMENT} ::= \\
\hspace*{0.5in}{\em function-type-name}~{\em function-name} \TT{=}
    \ttmkey{deferred}{function}
\end{indpar}

The {\em function-name} is referred to as a `\key{deferred function}'.
This specifies that the body of the out-of-line function
with the given {\em function-name} will be provided later
during program initialization.  It is an error to call an uninitialized
deferred function.

An out-of-line function may be declared by
an assignment statement of the form:
\begin{indpar}
\emkey{out-of-line-function-assignment}%
\label{OUT-OF-LINE-FUNCTION-ASSIGNMENT} ::= \\
\hspace*{0.5in}{\em function-type-name}~~{\em function-name} \TT{=:} \\
\hspace*{1.0in}{\em statement}\STAR{}
\end{indpar}

The argument and result variable names used by the {\em statements}
are those given in the {\em function-type} declaration.
These names
and names declared within the {\em statements} of the assignment,
are permitted to hide (\pagref{HIDE})
names in the context of the assignment, but the {\em function-name}
may not.  The {\em statements} of the assignment may reference
variables in the context of the assignment, which will have
the values they have been given when the assignment executes, except
for deferred variables (\pagref{DEFERRED-ASSIGNMENT-STATEMENTS}),
which must be given values before the function is called.


If the {\em function-name} is deferred, the {\em function-type}
name given in the {\em out-of-line-function-deferred-assignment}
and that given in the {\em out-of-line-function-assignment}
must be identical.  It is an error if the statement initializing
a deferred function is not in the same extended module as the function's
{\em out-of-line-deferred-assignment}.

Out-of-line functions may also be declared by:

\begin{indpar}
\emkey{out-of-line-function-declaration}%
\label{OUT-OF-LINE-FUNCTION-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{}
		             ~ {\em function-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
		\TT{~~~~do:} \\
		\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}\label{OUT-OF-LINE-FUNCTIONS}

This is equivalent to defining a function type with a hidden name
and then defining {\em function-name} to be a function of that type.
The result and argument variables in a
{\em out-of-line-function-declaration},
and names declared within the {\em statements} of the declaration,
are permitted to hide (\pagref{HIDE})
names in the context of the declaration, but the {\em function-name}
may not.

For the function to be callable at compile time, the
\TT{*COMPILE-TIME*} or \TT{*COMPILE-\EOL TIME-\EOL ONLY*} options must be given.
See Section~\itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS}.
A \TT{*COMPILE-\EOL TIME*} out-of-line function will also be callable at
run time, but a \TT{*COMPILE-\EOL TIME-\EOL ONLY*}
out-of-line function will only be callable
at compile time.

Normally the standard call linkage for the computer environment of
the program is used.  Other implementation specific call options
may alter the call linkage used.

\subsection{Out-of-Line Assignment Statements}
\label{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}

An \key{out-of-line assignment statement} is like a combination of
a {\em call-assignment-statement} with
an {\em out-of-line-function-declaration} for a function
specific to the call:

\begin{indpar}
\emkey{out-of-line-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em function-declaration-option}\STAR
		~\ttkey{out-of-line} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

An {\em out-of-line-function-declaration} is constructed from this statement
by replacing the `\TT{out-\EOL of-\EOL line}' keyword by
an internally generated
{\em function-name}, and converting each {\em argument-assignment-statement}
to an {\em argument-variable-declaration}.

Then this statement is executed as a {\em call-assign\-ment-statement}
using the {\em function-name} and deleting the `\TT{do}' subblock.

{\em Out-of-line-assignment-statements} are generally included in
inline functions which preprocess arguments and may use various
{\em out-of-line-assignment-statements} to handle complex subcases.
When compiled multiple times in different contexts, the same
{\em out-of-line-assignment-statement} may be optimized in different
ways, and produce different out-of-line functions.  When it produces
the same out-of-line function more than once, this out-of-line function will
\underline{not} be duplicated.


\subsection{Compile-and-Run Assignment Statements}
\label{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}

A \key{compile-and-run assignment statement} computes a set of
variables that have values constant in a block, then compiles
the block using these constant values to optimize the compilation,
and lastly runs the block:

\begin{indpar}
\emkey{compile-and-run-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \\
	\TT{~~~~}\ttkey{compile-and-run}
		 \{ {(} {\em context-expression} \TT{)} \}\QMARK{}
		 \TT{:} \\
	\TT{~~~~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~~~~do} {\em block-name}\QMARK{} \TT{:} \\
	\TT{~~~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

The variable values are set by the {\em argument-assignment-statements}.
Then the `\TT{do}' subblock {\em statements} are compiled, using
the variable values to optimize the compilation.

Normally the
{\em compile-and-run-assignment-statement} is
compiled in its context (\pagref{CONTEXT}),
but if `\TT{(} {\em context-expression} \TT{)}'
is given, it is compiled in the context given by the
{\em context-expres\-sion}.
If the {\em context-expression}
specifies a context other than the context of the
{\em compile-and-run-assignment-statement}, the result variable names
and names declared within the block {\em statements}
are permitted to hide (\pagref{HIDE})
names in the specified context.

After it is compiled, the `\TT{do}' subblock is executed.
The variables in the {\em result-variable-list}
may be set by either {\em argument-assignment-statements} or
`\TT{do}' subblock {\em statements} as for
a block assignment statement (see \itemref{BLOCK-ASSIGNMENT-STATEMENTS}).
If a variable \TT{v} not in the {\em result-variable-list}
is set by an {\em argument-assignment-statement},
`\TT{next v}' can be set by a `\TT{do}' subblock {\em statement}, but
this will be a new variable whose value may not be available during
the compilation.

When the compile-and-run assignment statement is executed, the compiled
code will be saved in a table indexed by the values of the
variables set by the {\em argument-assignment-statements} and the context
used in compilation.  When the
compile-and-run assignment statement is re-executed, if these
variables have the same values they had during a previous execution,
and if the same context is being used,
the compilation will be bypassed and the previously compiled code used.
This optimization is required, but such previously compiled code
may be discarded if it has not been used in a long time.

The {\em statements} of the {\em compile-and-run-assignment-statement}
may reference to variables in the context of the assignment statement.
These variables act as arguments to the compiled code that may
vary from one execution to another, and are not used to optimize or
index the code.


\subsection{Compile-Time Assignment Statements}
\label{COMPILE-TIME-ASSIGNMENT-STATEMENTS}

\ikey{Compile-time assignment statements}{compile-time assignment statement}
run only once, when they are compiled, and produce variable values
at compile time:

\begin{indpar}
\emkey{compile-time-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~~~ \ttkey{compile-time:} \\
	\TT{~~~~}{\em statement}\STAR{}
	\end{tabular}
\end{indpar}

A compile-time block has its own stack, which is freed when the
block finishes executing.

Compile time blocks may only use compile time variables and values,
but may use visible inline functions, out-of-line functions
that have been declared to be compile-time, and global areas
that have been declared to be compile-time.

\subsection{Deferred Assignment Statements}
\label{DEFERRED-ASSIGNMENT-STATEMENTS}

\ikey{Deferred assignment statements}{deferred assignment statement}
specifies that assignment of its result variables is deferred until later:

\begin{indpar}
\emkey{deferred-assignment-statement} ::=  \\
\hspace*{0.5in}{\em result-variable-list} \TT{=} \ttkey{deferred}
\end{indpar}


The result variables of 
a {\em deferred-assignment-statement} are called `\mkey{deferred}{variable}'.

A {\em deferred-assignment-statement} must be top level.
The statement that assigns its values later must be an assignment
statement with identical {\em result-variable-list}
that is in the same extended module as the {\em deferred-assignment-statement}.
It is a detected program error to read a deferred variable before it has
been assigned a value (this error can only occur in the same extended
module as the {\em deferred-assignment-statement}).

\subsection{Assembly Assignment Statements}
\label{ASSEMBLY-ASSIGNMENT-STATEMENTS}

\ikey{Assembly assignment statements}{assembly assignment statement}
are used to embed assembler instructions in compiled code:

\begin{indpar}
\emkey{assembly-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~\TT{*UNCHECKED*}~\ttakey{ASSEMBLY}\TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em assembler-instruction}\STAR{} \\
	\end{tabular}
\end{indpar}

The variables, those produced by the {\em argument-assignment-statements},
the {\em argument-variable-declarations},
and the result variables, are placed in machine registers
and their names become machine register names for the assembler instructions.
Assembler instructions are only permitted to reference these
machine registers, but load and store assembler instructions may be used.
The assembler instructions are written in the syntax of one of the
target machine assemblers.

The variables may have additional qualifiers which
are names of machine registers or groups of machine registers.  In this case
the variables will be allocated to the specified machine registers or
machine register groups.  Otherwise they will be allocated to target
machine specified register groups based on variable type.

The {\em argument-variable-declarations} list intermediate
variables.  Only the variables named in the {\em argument-assignment-statements}
are given initial values.  Unlike normal code, values of variables
of an {\em assembly-assignment-statement} can be overwritten by the
{\em assembler-instructions}, and there is no check to be sure that
result variables receive any value.

\section{Function Prototypes and Calls}
\label{FUNCTION-PROTOTYPES-AND-CALLS}

Inline functions are declared by {\em function-declarations}
that contain a {\em function-prototype} and the code body of the
function.  Note that inline functions cannot be called recursively.

The syntax is:

\begin{indpar}
\emkey{function-declaration}\label{FUNCTION-DECLARATION}
    ::= \begin{tabular}[t]{l}
        {\em function-prototype} \TT{:} \\
	\TT{~~~~~}{\em statement}\PLUS{}
	\end{tabular}
\\[2ex]
\emkey{function-prototype}\label{FUNCTION-PROTOTYPE}
    \begin{tabular}[t]{@{}rl}
    ::= & \ttkey{function} ~
          {\em prototype-result-variable-list} ~ \TT{=} \\
        & \TT{~~~~~}{\em module-abbreviation}\QMARK{}
	                ~ {\em prototype-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em prototype-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em prototype-pattern} ~ \TT{=} \\
        & \TT{~~~~~}{\em input-variable-list} \\
    $|$ & {\em function-prototype} \TT{[|} {\em conditioner} \TT{|]}
    \end{tabular}
\\[0.5ex]
\emkey{prototype-result-variable-list} ::= \\
\hspace*{0.5in}
    {\em prototype-result-variable-declaration}
    \{ \TT{,} {\em prototype-result-variable-declaration} \}\STAR{}
\\[0.5ex]
\emkey{prototype-result-variable-declaration}
    \begin{tabular}[t]{rl}
    ::= & {\em qualifier-name}\STAR{} ~
          {\em type-name} ~ {\em variable-name} \\
    $|$ & \ttmkey{next}{prototype result variable} ~
          {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
{\em type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
{\em variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{input-variable-list}
    ::= {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{}
\\[0.5ex]
\emkey{argument-declaration}\label{ARGUMENT-DECLARATION}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
          \TT{?=} {\em default-value} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
          \TT{??} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
          \TT{==} {\em required-value} \\
    \end{tabular}
\\[0.5ex]
\emkey{default-value} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[0.5ex]
\emkey{required-value} ::= {\em expression} with compile time value
\\[0.5ex]
\emkey{prototype-pattern}\label{FUNCTION-PATTERN}
    \begin{tabular}[t]{rl}
    ::= & {\em first-pattern-term} ~ {\em pattern-term}\STAR{} \\
    $|$ & {\em pattern-argument-list} {\em pattern-argument-list}\PLUS{}
    \end{tabular}
\\[0.5ex]
\emkey{first-pattern-term} ::= {\em pattern-argument-list}\STAR{} ~
				{\em pattern-term}
\\[0.5ex]
\emkey{pattern-term}
    ::= {\em term-name} ~ {\em pattern-argument-list}\STAR{}
\\[0.5ex]
\emkey{term-name} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\\[0.5ex]
\emkey{function-variable-name}\label{FUNCTION-VARIABLE-NAME} ::=
    \begin{tabular}[t]{@{}p{4in}@{}}
    {\em term-name} $N$ that appears in a {\em function-prototype}
    of the form `{\tt function $N$ = \ldots}'
    \end{tabular}
\\[0.5ex]
\emkey{pattern-argument-list} ::= {\em regular-argument-list}
                              $|$ {\em qualifiers-type-argument-list}
\\[0.5ex]
\emkey{regular-argument-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{qualifiers-type-argument-list} ::= \\
\hspace*{0.2in}\TT{(|} {\em qualifiers-type-argument-declaration}
	 \{ \TT{,} {\em qualifiers-type-argument-declaration} \}\STAR{} \TT{|)}
\\[0.5ex]
\emkey{qualifiers-type-argument-declaration} ::= \\
\hspace*{0.2in}{\em qualifiers-argument-declaration}
               $|$ {\em type-argument-declaration}
\\[0.5ex]
\emkey{qualifiers-argument-declaration} ::= \\
\hspace*{0.2in}\TT{qualifiers} {\em variable-name}
               \{ \TT{?=} {\em default-value} \}\QMARK{}
\\[0.5ex]
\emkey{type-argument-declaration} ::= \\
\hspace*{0.2in}\TT{type} {\em variable-name}
               \{ \TT{?=} {\em default-value} \}\QMARK{}
\\[0.5ex]
\emkey{conditioner}\label{CONDITIONER}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em logical-conditioner} \\
    $|$ & {\em qualifiers-conditioner} \\
    $|$ & {\em type-conditioner} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-conditioner}\label{LOGICAL-CONDITIONER}
    ::= {\em logical-expression} ~~~~~ [see \pagref{LOGICAL-EXPRESSION}]
\\[0.5ex]
\emkey{qualifiers-conditioner}\label{QUALIFIERS-CONDITIONER}
    ::= \TT{qualifiers} {\em variable-name} \TT{=} {\em expression}
\\[0.5ex]
\emkey{type-conditioner}\label{TYPE-CONDITIONER}
    ::= \TT{type} {\em variable-name} \TT{=} {\em expression}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[4ex]
\emkey{function-call}\label{FUNCTION-CALL}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em module-abbreviation}\QMARK{} ~ {\em first-call-term}
          ~ {\em call-term}\STAR{} \\
    $|$ & {em module-abbreviation}\QMARK{}
          {\em call-argument-list} {\em call-argument-list}\PLUS{}
    \end{tabular}
\\[0.5ex]
\emkey{first-call-term} ::= {\em call-argument-list}\STAR{}
				{\em call-term}
\\[0.5ex]
\emkey{call-term}
    ::= {\em term-name} {\em call-argument-list}\STAR{}
\\[1ex]
\emkey{call-argument-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{]} \\
    $|$ & \TT{(|} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{|)} \\
    $|$ & \TT{()} $|$ \TT{[]} $|$ \TT{(|~|)} \\
    $|$ & {\em primary-argument}
    \end{tabular}
\\[0.5ex]
\emkey{actual-argument} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[0.5ex]
\emkey{primary-argument} ::= {\em primary-item}\PLUS{}
                         $|$ {\em bracketed-constant}
\\[0.5ex]
{\em primary-item} ::= {\em word} $|$ {\em number}
                   $|$ {\em quoted-string} ~~~~~ [see \pagref{PRIMARY-ITEM}]
\\[0.5ex]
{\em bracketed-constant} ::= see \pagref{BRACKETED-CONSTANT}

\begin{itemize}
\item
A {\em prototype-pattern} or {\em function-call}
must have either a {\em term-name}
or at least two {\em argu\-ment-lists}.
\item
A {\em prototype-pattern} {\em term-name} must not be
an initial segment of any other {\em term-name}
in the same {\em prototype-pattern}.
\item
A {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME})
should not have a {\em qualifier-name} or {\em type-name} as an initial segment.
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.
\item
A {\em prototype-result-variable-declaration} {\em variable-name}
can have {\em member-selectors},
unlike an {\em assignment-statement} {\em result-variable-name}
(\pagref{RESULT-VARIABLE-NAME}).  See Clusters \itemref{CLUSTERS}.
\item
For a {\em prototype-result-variable-declaration} of the form `\TT{next} $v$',
$v$ must be the {\em vari\-able-name} in an {\em argument-declaration}
of the form `{\em qualifier-name}\STAR{} {\em type-name} $v$', and
any actual argument associated to the {\em argument-declaration}
must be a {\em variable-name} $w$ for which `\TT{next} $w$' is a legal
{\em assignment-statement} {\em result-variable-declaration} in the
\LSTAR-language (i.e., with {\em member-selectors} allowed for $v$ and
$w$).  If $v$ or $w$ have {\em member-selectors}, these must be identical.
\item
\TT{"="} cannot be used as a {\em term-name}
in a {\em prototype-pattern}.
\item
The first {\em argument-declaration} in an {\em input-variable-list}
must not have a {\em default-value} or end in \TT{??}.
\item
All the result and argument {\em variable-names}
in a {\em function-prototype} must
be distinct.
\item
{\em Argument-declarations} appear inside `\TT{()}' or `\TT{[]}'
bracketed {\em argument-lists} and are \underline{not}
{\em qualifiers-type-argument-declarations} even if they have
the same form.  {\em Qualifiers-type-argument-declarations} appear
inside `\TT{(|\,|)}' bracketed {\em qualifiers-type-argument-lists}.
\item
The {\em variable-name} in a {\em qualifiers-argument-declaration}
or a {\em qualifiers-conditioner} is treated as a {\em qualifier-name}
within the rest of the {\em function-prototype}.  The value of the
{\em variable-name} must be computable at compile-time when the
function is called.
\item
The {\em variable-name} in a {\em type-argument-declaration}
or a {\em type-conditioner} is treated as a {\em type-name}
within the rest of the {\em function-prototype}.  The value of the
{\em variable-name} must be computable at compile-time when the
function is called.
\item
In a {\em pattern-argument-list} or {\em input-variable-list}
an {\em argument-declaration} with no {\em de\-fault-value} cannot
follow an {\em argument-declaration} with a {\em default-value}.
An {\em argument-declaration} that ends with `\TT{??}' is considered
to have a \TT{bool} {\em default-value}: see \pagref{BOOL-DEFAULT}.
\item
Variable qualifiers (\pagref{VARIABLE-QUALIFIER}) can appear
in {\em prototype-result-variable-declarations}, but with the
exception of the \ttamkey{DEFERRED}{in {\em argument-declarations}}
qualifier cannot appear in {\em argument-declarations}.
\item
Note that prototype result variable names and argument variable names
may have {\em mem\-ber-selectors} in the L-language, unlike
variable names declared by {\em assignment-stat-ments}.  See
Clusters, \itemref{CLUSTERS}.



\end{itemize}
\end{indpar}

The result and argument variables in a
{\em function-declaration},
and names declared within the {\em statements} of the declaration,
are permitted to hide (\pagref{HIDE})
names in the context of the {\em function-declara\-tion}.

A {\em function-call} with a {\em result-variable-list}
is replaced by an \LSTAR-language (\pagref{LSTAR-LANGUAGE})
{\em block-assignment-statement} (\itemref{BLOCK-ASSIGNMENT-STATEMENTS})
with an context option specifying the context of the
{\em function-declaration}.
The result and argument variables in the {\em function-declaration}
are effectively replaced by compiler generated temporary variable names to
avoid conflicts, and variables declared inside the replacing
{\em block-assignment-statement} are permitted to hide variables outside
the statement (\pagref{HIDE}).  The values of the non-{\tt *DEFERRED*}
argument temporary variables are computed before the block, while
the values of the {\tt *DEFERRED*}
argument temporary variables are computed where they are used
inside the block, but within their own subblock that has the
{\em function-call} context and not the {\em function-declaration}
context.
Default values for arguments are computed
at the beginning of the block, which makes them similar to other
non-{\tt *DEFERRED*} argument values except that they are computed
in the context of the {\em function-declaration} and not the context
of the {\em function-call}.
The values of the result
temporary variables are assigned to the {\em function-call} result
variables after the block.
There are examples on pages \pageref{AND-EXAMPLE}, \pageref{IF-ELSE-EXAMPLE},
and \pageref{COMPARE-EXAMPLE}.

If there is a {\em prototype-result-variable-declaration}
of the form `\TT{next} $v$' for some variable name $v$, there must
be a prototype
argument named $v$.
In this case any function call must have an actual argument $w$ that
is a {\em variable-name} for which `\TT{next} $w$' is legal
(in the \LSTAR-language) in the context
of the function call, and the types of the prototype argument variable $v$
and the actual argument $w$ must be identical.  The function call
expands to an assignment block that places the
result value in a temporary variable,
and `\TT{next} $w$' is then set from the temporary variable.

An example using this is:
\begin{indpar}\begin{verbatim}
function int32 r, next v = post increment ( int32 v ):
    r = v
    next v = v + 1

int32 x = 1
int32 y = post increment ( x )     // y == 1
int32 z = x                        // z == 2
\end{verbatim}\end{indpar}

A {\em function-call} with an {\em input-variable-list} is just syntactic
sugar for a {\em function-call} with neither a {\em result-variable-list}
or {\em input-variable-list}.  Specifically
\begin{center}
{\tt F(a1,a2,...)~=~b1,b2,...} \\
is syntactic sugar for \\
{\tt F(a1,a2,...)~"="~(b1,b2,...)} \\
\end{center}

in which a term with \TT{"="} as its {\em term-name} is
placed at the end of the {\em function-call}.

{\em Call-terms} correspond to {\em pattern-terms}.  {\em Call-terms}
other than the first may be in a different order than their matching
{\em pattern-terms}.  {\em Call-terms} other than the first may be
omitted, and if omitted, will be inserted with empty {\em call-argument-lists}.
{\em Call-argument-lists} may be omitted, and if omitted, empty
lists will be inserted if this can be done unambiguously.
If a {\em pattern-argument-list} has \TT{()} brackets and a single
argument, and the corresponding {\em call-argument-list} has a single
{\em actual-argument} that
is a {\em primary-argument} ( sequence of {\em words}, {\em numbers},
and {\em quoted-strings}, or a {\em bracketed-constant}), then
the \TT{()} parentheses may be omitted in the {\em function-call}
if there is no ambiguity involving overlap with {\em term-names} or
other argument lists.

Examples are:
\begin{indpar}\begin{verbatim}
function int32 r =
        fee ( int32 x ) fie ( int32 y ) foe ( int32 z ):
    ... function body omitted ...

int32 b 1 = ...
int32 c 2 = ...
int32 d 3 = ...
int32 f = fee ( b 1 ) foe ( c 2 ) fie ( d 3 )
    // Same as:
    //   int32 f = fee ( b 1 ) fie ( d 3 ) foe ( c 2 )
int32 g = fee ( b 1 ) foe ( c 2 )
    // Same as:
    //   int32 g = fee ( b 1 ) fie () foe ( c 2 )
    // Erroneous: actual argument missing
int32 h = fee b 1 foe c 2 fie d 3
    // Same as:
    //   int32 h = fee ( b 1 ) fie ( d 3 ) foe ( c 2 )
\end{verbatim}\end{indpar}

If an argument has a {\em required-value} in a {\em pattern-argument-list},
then there must be a corresponding {\em actual-argument} in the
{\em function-call} whose value is a compile-time value that equals the
{\em required-value}, which must also be a compile-time value.  An example is:
\begin{indpar}\begin{verbatim}
define types:
    my type as int32
    your type as uns32
function type r = companion type of ( type t == my type ):
    r = your type
function type r = companion type of ( type t == your type ):
    r = my type
\end{verbatim}\end{indpar}

{\em Actual-arguments} may be omitted at the end of a {\em call-argument-list}
if their corresponding
{\em argu\-ment-declaration} contains a {\em default-value}.
\label{DEFAULT-VALUE}
The \emkey{default-value} will be used as the actual argument
for such an omitted actual argument.

If the {\em argument-declaration} ends in `\TT{??}'\label{BOOL-DEFAULT}
with no explicit {\em default-value}, the
argument must have \TT{bool} type and the
{\em default-value} is taken to be \TT{true} if the
corresponding {\em call-term} was originally present, and \TT{false} if the
{\em call-term} was originally omitted and automatically inserted.

An example is:
\begin{indpar}\begin{verbatim}
int32 B = ...
int32 C = ...
context fooC = current context
function int32 r =
        foo ( int32 x ) bar ( int32 y ?= B + C, bool z ?? )
    ... function body omitted ...

int32 b 1 = ...
int32 f = foo ( b 1 )
    // Call has same effect as:
    //     int32 tmp y, bool tmp z = do ( fooC ):
    //         tmp y = B + C
    //         tmp z = false
    //     int32 f = foo ( b 1 ) bar ( tmp y, tmp z )
\end{verbatim}\end{indpar}

A {\em type-argument-declaration} inside `\TT{(|\,|)}' brackets or
a {\em type-conditioner} inside `\TT{[|\,|]}' brackets has the
form `{\tt type T \ldots}' for some {\em variable-name} {\tt T}.
This makes {\tt T} into a {\em type-name} within the {\em function-declaration}
containing the {\em type-argument-declaration}.
For a {\em type-argument-declaration}
in `\TT{(|\,|)}' brackets,
the actual value of {\tt T} can be implied by a {\em function-call}.
If an explicit or default value of {\tt T} is given by the call, that is used.
Otherwise if {\tt T} is the type of a prototype result variable, and there
is a corresponding {\em function-call} result variable with a known type,
the type of the leftmost such {\em function-call} result variable
is assigned as the value of {\tt T}.  Otherwise
if {\tt T} is the type of a prototype argument variable, and
the {\em actual-argument} corresponding to the variable in the call has
a natural type (\pagref{NATURAL-TYPE}), {\tt T} is assigned the natural type
corresponding to the leftmost such variable in the prototype.


For example,
\begin{indpar}\begin{verbatim}
function T result = add (| type T |) ( T v1, T v2 ):
    result = v1 + v2

// Example usage
//
int32 x = ...
int32 y = ...
int32 z = add (| int32 |) ( x, y )
    // T is explicitly given.
next z = add ( x, y )
    // T = int32 is implied because that is the type of
    // `next z'.
\end{verbatim}\end{indpar}

A {\em qualifiers-argument-declaration}
\label{QUALIFIERS-ARGUMENT-DECLARATION-DISCUSSION}
inside `\TT{(|\,|)}' brackets or
a {\em qualifiers-conditioner} that is inside `\TT{[|\,|]}' brackets has the
form `{\tt qualifiers Qs \ldots}' for some {\em variable-name} {\tt Qs}.
This makes {\tt Qs} into a {\em qualifier-name}
within the {\em function-de\-clar\-a\-tion}
containing the {\em qualifiers-argument-de\-clar\-a\-tion}.  Note that {\tt Qs}
is used like a {\em qualifier-name}, but its value is a set of
zero or more qualifiers.

For a {\em qualifiers-argument-declaration}
within `\TT{(|\,|)}' brackets,
the actual value of {\tt Qs} may be implied by a {\em function-call}.
If an explicit or default value of {\tt Qs} is given by the call, that is used.
Otherwise if {\tt Qs} is the given as the \underline{only} qualifier
of a prototype result variable that is \underline{not} a variable
qualifier and is not {\tt protected},
and there is a corresponding {\em function-call}
result variable with known type,
the \underline{value} qualifiers of the leftmost such {\em function-call}
result variable are
assigned as the value of {\tt Qs}.  Otherwise
if {\tt Qs} is given as the \underline{only} qualifier
of a prototype argument variable that is \underline{not} a variable
qualifier,
and the {\em actual-argument} corresponding to the
variable has a natural type (\pagref{NATURAL-TYPE}),
{\tt Qs} is assigned the \underline{value} qualifiers of the
{\em actual-argument} corresponding to the
leftmost such variable in the prototype.

For example,
\begin{indpar}\begin{verbatim}
define protected required value qualifier in-range
define prohibited value qualifier ouch
function Qs in-range T r =
        check (| qualifiers Qs, type T |) ( Qs T v ):
        // in-range is protected so Qs is implied to
        // be the non-protected value qualifiers of
        // the actual result variable
    if:
        v < 0:
            error "argument < 0"
        v > 100:
            error "argument > 100"
        else:
            result = v

function F ( in-range ouch v ):
    ... function body omitted ...

// Example usage
//
ouch int32 x = ...
ouch int32 y1 = check ( x )
           // Legal: check prototype becomes:
           //   ouch in-range r = check ( ouch int32 v )
           // so argument can have qualifier ouch.
           // Also y1 is given protected qualifier
           // `in-range'.
int32 y2 = check ( x )
           // Illegal: check prototype becomes:
           //   in-range r = check ( int32 v )
           // so argument CANNOT have qualifier ouch.
F ( x )    // Illegal, x does not have required in-range
F ( y1 )   // Legal, y1 has required in-range
\end{verbatim}\end{indpar}

{\em Conditioners} bracketed by `\TT{[|\,|]}'
can be written at the end of a {\em function-prototype},
as in:
\begin{indpar}\begin{verbatim}
types signed-integer-types =
    { int8, int16, int32, int64, int128 }

function T result = add (| type T |) ( T v1, T v2 )
    [| T is in signed-integer-types |]:
    result = v1 + v2
\end{verbatim}\end{indpar}

which would define `{\tt add}' only for signed integer types.
Here the conditioner is a {\em logical-ex\-pres\-sion} that must
be evaluatable whenever a call to the function is compiled.

Another example is:
\begin{indpar}\begin{verbatim}
function Qs2 T r = inc (| qualifiers Qs1, type T |)
                       ( Qs1 T v )
    [| qualifiers Qs2 = Qs1 - { *STACK* } |]:
    return v + 1
\end{verbatim}\end{indpar}

which returns {\tt v+1} with the same qualifiers as {\tt v}
except for the `{\tt *STACK*}' qualifier which is removed.
Here the rightside of the {\em qualifiers-conditioner}
must be evaluatable when a call to the function is compiled.

The body of an inline function is parsed, but it is not checked for
errors before the function is called.  When the function is called,
compile time values passed as arguments may cause parts of the body
to never be compiled or checked for compilation errors.  If a function
is never called, it may contain code that would have compilation errors
were the function called, such as calls to non-existent functions.

\subsection{Matching Calls to Prototypes}
\label{MATCHING-CALLS-TO-PROTOTYPES}

To compile a {\em function-call}
or {\em generic-call} it must be matched to a
single {\em function-prototype} or {\em generic-prototype}.
If the call matches more than one
prototype, the call is ambiguous and is a compilation error.

Calls that are {\em statements} by themselves, with no
result variables, are matched to both {\em function-prototypes}
with no result variables, and to
{\em generic-prototypes} (\pagref{GENERIC-PROTOTYPE}),
and no distinction is made during
matching between these two kinds of prototypes.

The matching algorithm, given a call and a
prototype, matches the call
to the {\em prototype-pattern} in the prototype,
and matches any call result variables to
the {\em prototype-result-variable-list}
of the prototype.  The call may have one or more result
variables of known types, or a single result variable of unknown
type, or no result variables (as in a call that is
a {\em statement} by itself).  The matching algorithm is as follows:

\begin{enumerate}

\item
If the call is in a statement of the form
\begin{center}
{\em function-call} ~ \TT{=} ~ {\em expression-list}
\end{center}
the prototype must be of the form
\begin{center}
{\tt function} ~ {\em prototype-pattern} ~ {\tt =} ~ {\em input-variable-list} \\
\end{center}
and the following will be done:
\begin{enumerate}
\item `\TT{=}' will be treated in the following as if it were the
{\em term-name} \TT{"="}.
\item{\em expression-list} is parenthesized.
\item {\em input-variable-list} is parenthesized.
\end{enumerate}

For example, the prototype
\begin{center}
\tt function F ( int64 i ) = int32 x, int32 y
\end{center}
behaves as if it were
\begin{center}
\tt function F ( int64 i ) "=" ( int32 x, int32 y )
\end{center}
and the assignment statement
\begin{center}
\tt F ( i ) = x, y
\end{center}
behaves as if it were the function call with no result variables
\begin{center}
\tt F ( i ) "=" ( x, y )
\end{center}

\item If the call begins with a {\em module-abbreviation}
(see \pagref{MODULE-ABBREVIATION}), the {\em prototype-pattern}
must begin with a {\em module-abbreviation}, and the two
{\em module-abbreviations} must reference the same {\em module-name}
(i.e., module file, see \itemref{MODULES}), else the
call-prototype match fails.

\item If the call does \underline{not} begin
with a {\em module-abbreviation}, but the {\em prototype-pattern}
does begin with a {\em module-abbreviation}, the match is marked
as `\key{module deficient}'\label{MODULE-DEFICIENT},
and will be disallowed later if there is
another match that is not module deficient.

\item
The {\em term-names} in the call are located by
matching segments of the call to
{\em term-names} in the {\em prototype-pattern}.
If a {\em term-name} matches more than one segment,
the call-prototype match fails.  If the first {\em term-name}
in the {\em prototype-pattern} does not match any segment,
or does not match the first matched segment, the call-prototype match fails.
(Note that {\em term-names} in the {\em prototype-pattern}
cannot be initial segments of each other, but unparenthesized
{\em variable-names} may appear in the call and be
mistaken for parts of {\em term-names}.)

\item The {\em call-terms} after the first in the call
are reordered so the {\em term-names} in the call,
taken in order, are a subsequence of the {\em term-names} in the
{\em prototype-pattern}.
If this cannot be done, the call-prototype match fails.
(Note that {\em call-terms} other than the first all begin with
a {\em term-name} and extend until the next {\em term-name}
or the end of the call.)

\item\label{ADD-TERMS}
If some of the {\em term-names} in the {\em prototype-pattern}
are missing from the call,
new {\em call-terms} without argument lists
are inserted in the call to match the missing
{\em pattern-terms}.  At this point there is a 1-1 ordered correspondence
between {\em call-terms} and {\em pattern-terms}.

\item
If some of the {\em pattern-terms} have argument lists that
have a single parenthesized argument, the parentheses may be omitted
in the call if the actual argument is a sequence of
{\em primary-items} or a {\em bracketed-constant}.
Also {\em argument-lists}
may be completely omitted in the call.  At this point
missing parentheses and missing {\em argument-lists} are added to
each {\em call-term} to make it match the corresponding
{\em pattern-term}.
The {\em argument-lists} added are empty and have the same type of
bracket, \TT{()}, \TT{[]}, or \TT{(|~|)}, as the {\em pattern-term}
{\em argument-lists} they match.

If this cannot be done \underline{uniquely}
so each {\em pattern-term} {\em argument-list}
is matched to a {\em call-term} {\em argument-list}
that has the same type of bracket, then the call-prototype match fails.

\item
If the prototype
has cluster member arguments or result variables,
these are implied in the call, and they are added to the call
at this point.  If this cannot be done because some of the required
cluster members
do not exist in the context of the call, the call-prototype
match fails.  See \itemref{CLUSTERS} for details.

The modified call now matches
the {\em prototype-pattern} in {\em term-names},
location and number of {\em argument-lists}, and type of bracket (\TT{()},
\TT{[]}, or \TT{(|~|)}) for each {\em argument-list}.  Some
{\em call-argument-lists} may be shorter than the corresponding
{\em pattern-argument-lists}.

\item
If a pattern {\em argument-declaration} has a {\em required-value},
there must at this point be a matching call {\em actual-argument}
with a compile-time value equal to the {\em required-value},
else the call-prototype match fails.

\item
If some of the {\em call-argument-lists} are now too long, the call-prototype
match fails.

\item
If some of the {\em call-argument-lists} are now too short, they are extended
by adding the {\em default-values} from
their matching {\em pattern-argument-lists}.
As a special case, if a prototype {\em arg\-u\-ment-de\-clar\-a\-tion} ends in
`\TT{??}' and has no {\em default-value}, then the actual
{\em default-value} used is \TT{true} if the {\em term-name}
appeared in the original function call and was not added in
Step~\ref{ADD-TERMS} above, or is \TT{false} if the {\em term-name}
did not appear in the original function call, but was added in
Step~\ref{ADD-TERMS}.

If any of the arguments that need to be inserted in a
{\em call-argument-list} matched to a {\em regular-argument-list}
(lists with \TT{()} or \TT{[]} brackets)
do not have {\em default-values}, the call-prototype match fails.

Now the modified call matches
the {\em prototype-pattern} in {\em term-names},
location and number of {\em argument-lists}, and type of bracket (\TT{()},
\TT{[]}, or \TT{(|~|)}) for each {\em argument-list}.  The number of
arguments also match for \TT{()} and \TT{[]} {\em argument-lists},
and number of actual arguments in each \TT{(|~|)} {\em call-argument-list}
is not greater than the number of arguments in the corresponding
{\em pattern-argument-list}.

Note that any {\em default-values} inserted in the call
are evaluated in the context of the prototype.  For
matching purposes, this is relevant only if the {\em default-values}
are {\em expressions} with compile-time values, and such
{\em default-values} can be replaced by constants when the
prototype is first compiled.

\item
If any {\em qualifiers-argument-declaration} in a {\em prototype-pattern}
{\em qualifiers-type-argument-list} has a corresponding
actual argument, the actual argument expression
is evaluated with the `\TT{qualifiers}' target type,
and must have a compile time value which is a set of qualifiers, else
the call-prototype match fails.  If the match does not fail,
the set of qualifiers becomes the value of the {\em variable-name}
in the {\em qualifiers-argument-declaration} and
is substituted for the {\em variable-name} throughout the rest of the
prototype.

\item
If any {\em type-argument-declaration} in a {\em prototype-pattern}
{\em qualifiers-type-argument-list} has a corresponding
actual argument, the actual argument expression
is evaluated with the `\TT{type}' target type,
and must have a compile time value which is a type, else
the call-prototype match fails.  If the match does not fail,
the type value becomes the value of the {\em variable-name}
in the {\em type-argument-declaration} and
is substituted for the {\em variable-name} throughout the rest of the
prototype.

\item
If any {\em qualifiers-argument-declaration} in a {\em prototype-pattern}
{\em qualifiers-type-argument-list} does \underline{not} have
a corresponding actual or default argument, the value of the
{\em variable-name} in the {\em qual\-i\-fiers-argument-declaration}
is implied.

If the {\em variable-name} in the {\em qualifiers-argument-declaration}
is used as a {\em qualifier-name}
of a prototype result variable, and any other {\em qualifier-names}
of that prototype result variable name \underline{variable}
or \underline{protected value}
qualifiers in the context of the prototype, and if the
the matching call result has known type and qualifiers,
the \underline{unprotected value} qualifiers of the leftmost such call result
are assigned as the elements of the
value of the {\em variable-name}.

Otherwise if the {\em variable-name} in the
{\em qualifiers-argument-declaration}
is used as a {\em qualifier-name}
of a prototype argument variable, and any other {\em qualifier-names}
of that prototype argument variable name \underline{variable}
qualifiers in the context of the prototype, and if the
the matching call actual argument has a
natural type (\pagref{NATURAL-TYPE}) and qualifiers,
the \underline{variable} qualifiers of the leftmost such call argument
are assigned as the elements of the
value of the {\em variable-name}.

If no value can be assigned to the {\em variable-name} by these rules,
the call-prototype match fails.

If a value is assigned,
the set of qualifiers that is the assigned value
is added as an actual argument
in the {\em call-argument-list} that corresponds
to the {\em qualifiers-argument-declaration}, and
is substituted for the {\em variable-name} throughout the rest of the
prototype.

\item
If any {\em type-argument-declaration} in a {\em prototype-pattern}
{\em qualifiers-type-argument-list} does \underline{not} have
a corresponding actual or default argument, the value of the
{\em variable-name} in the {\em type-argument-declaration}
is implied.

If the {\em variable-name} in the {\em type-argument-declaration}
is used as the {\em type-name} of prototype result variables
with a matching call results with known type,
the type of the leftmost such call result is assigned as the
value of the {\em variable-name}.

Otherwise if the {\em variable-name}
is used the {\em type-name} of a prototype argument whose matching
actual argument has a natural type (\pagref{NATURAL-TYPE}),
the type of the leftmost
of these arguments is assigned as the
value of the {\em variable-name}.

If no value can be assigned to the {\em variable-name} by these rules,
the call-prototype match fails.

If a value is assigned,
the type that is the assigned value is added as an actual argument
in the {\em call-argument-list} that corresponds
to the {\em type-argument-declaration}, and
is substituted for the {\em variable-name} throughout the rest of the
prototype.

\item
The modified call now matches the {\em prototype-pattern}
precisely in {\em term-names},
location and number of {\em argument-lists}, type of bracket, i.e. \TT{()},
\TT{[]}, or \TT{(|~|)} for each {\em argument-list}, and number of
arguments in each {\em argument-list}.
This modified function call is referred to as the
`\mkey{unfolded}{call}' call.

If any actual argument value needs to be a compile-time value in what
follows, the actual argument expression is compiled at this
time with its target type taken from the corresponding
{\em prototype-pattern} {\em argument-declaration}.
If the result is not a compile-time value, the call-prototype
match fails.

\item
The {\em conditioners} in the prototype are evaluated
in order.  If any of the expressions in them do not have compile-time
values, the call-prototype match fails.
If any {\em logical-conditioner} evaluates
to \TT{false}, the call-prototype match fails.

If the value assigned to the {\em variable-name} of a
{\em type-conditioner} is not a type, the call-prototype match fails.
Otherwise this type value is substituted for the {\em variable-name}
throughout the prototype.

If the value assigned to the {\em variable-name} of a
{\em qualifiers-conditioner} is not a (possibly empty) set of
qualifiers, the call-prototype match fails.
Otherwise this qualifiers set value is substituted for the {\em variable-name}
throughout the prototype.

\item\label{NEXT-CALL-PROTOTYPE-MATCHING}
If the prototype has a `\TT{next} $v$' result variable and a prototype
argument named $v$, the {\em actual-argument} matched to the argument $v$
must be a variable name $w$ for which `\TT{next} $w$' is a legal
\LSTAR-Language (\pagref{LSTAR-LANGUAGE})
{\em next-variable-declaration} (\pagref{NEXT-VARIABLE-DECLARATION})
in the call context, $v$ and $w$ must have identical types, $v$ and $w$ must
have identical {\em member-selectors} (or both can have none),
and if $v$ and $w$ do have {\em member-selectors}, the types of their
root variables must be identical,
else the call-prototype match fails.
As an exception, $w$ need not exist in the call context if $v$ has
{\em member-selectors} and a default value, in which case the call will
be treated as if $w$ did pre-exist the call and had the default value
(this can only happen if $v$ and $w$ have {\em member-selectors}).

\item\label{ARGUMENT-CALL-PROTOTYPE-MATCHING}
If the unfolded call has {\em actual-argument}
expressions $e1$, $e2$, \ldots{} read from left to right
(including {\em default-values}),
and the {\em prototype-pattern} has
{\em argument-declarations} `$Qs1$ $T1$ $v1$', `$Qs2$ $T2$ $v2$', \ldots{}
read from left to right,
then the statement containing the
revised call is replace by:
\begin{indpar}
{\tt $Qs1$ $T1$ $tmp1$ = $e1$} \\
{\tt $Qs2$ $T2$ $tmp2$ = $e2$} \\
\ldots\ldots\ldots\ldots \\
statement containing call
with each {\em actual-argument} $eI$ replaced by $tmpI$
\end{indpar}

Here the $Qs\ldots$ are possibly empty qualifier sets,
the $T\ldots$ are types, the $v\ldots$ are argument variable
names, and the $tmp\ldots$ are
\skey{temporary variable name}s (names of the form \TT{T\$}$n$
for a natural number $n$ manufactured by the compiler and
guaranteed to a unique among all {\em names}.)

If any $eI$ is a {\em default-value}, then in the above
\begin{indpar}
{\tt $QsI$ $TI$ $tmpI$ = $eI$}
\end{indpar}
is replaced by
\begin{indpar}
{\tt $QsI$ $TI$ $tmpI$ = do ( }{\em prototype-context}{\tt ~):} \\
\hspace*{0.5in}{\tt $tmpI$ = $eI$}
\end{indpar}

If any the statements `{\tt $QsI$ $TI$ $tmpI$ = \ldots}' cannot be compiled
for reasons other than an ambiguity error, the call-prototype match fails.

If any of the statements `{\tt $QsI$ $TI$ $tmpI$ = \ldots}' cannot be compiled
because of an ambiguity error, the call-prototype match
is `\key{ambiguity deficient}' (and will be
rejected later, possibly for another reason).

In applying this rule, \TT{*DEFFERED*} prototype arguments are treated
as if they were not deferred, as the location of evaluation has no
effect on whether an implicit conversion exists or not.

\item If the call has no result variables, the
prototype must have no result variables,
else the call-prototype match fails.

\item If the call has one result variable of
unknown type, the prototype must have result variables
else the call-prototype match fails.
The type and qualifiers of the first
prototype result variable become the natural
type and qualifiers (\pagref{NATURAL-TYPE})
of the call expression if
the match ultimately is accepted according to the rules below.

\item \label{FUNCTION-CALL-ASSIGNMENT-COMPILATION}
If the call has result variables of known type
as in a statement of the form
\begin{center}
{\tt $QCs1$ $TC1$ $vc1$, $QCs2$ $TC2$ $vc2$, \ldots{}~=~}{\em function-call}
\end{center}
with at least one result variable of known type,
the prototype must be of the form
\begin{center}
{\tt function $QRs1$ $TR1$ $vr1$, $QRs2$ $TR2$ $vr2$,
     \ldots{}~=~}{\em prototype-pattern}
\end{center}
with at least as many result variables in the prototype as in
the call statement.  If all the qualifiers are value qualifiers,
and none are variable qualifiers, the statement is
replaced by:
\begin{indpar}
{\tt $QRs1$ $TR1$ $tmp1$, $QRs2$ $TR2$ $tmp2$,
    \ldots{}~=~}{\em function-call} \\
{\tt $QCs1$ $TC1$ $vc1$ = $tmp1$} \\
{\tt $QCs2$ $TC2$ $vc2$ = $tmp2$} \\
\ldots\ldots\ldots\ldots
\end{indpar}
If any of the `{\tt $QCsI$ $TCI$ $vc1$ = $tmpI$}' statements cannot be
compiled because $QRsI$ $TRI$ is not implicitly convertible
to $QCsI$ $TCI$, the call-prototype match fails.
Note that extra prototype result variables
are never used and are ultimately ignored.

In this process, if instead of `$QRsI$ $TRI$ $vrI$' for some $I$ one has
`{\tt next} $vrI$', then
`$QCsI$ $TCI$ $vcI$' is not given explicitly by the call.
In this case, if $vcI$ is the variable matched to the appropriate argument by 
Step~\ref{NEXT-CALL-PROTOTYPE-MATCHING} above, the
statement `$QCsI$ $TCI$ $vcI$ = $tmpI$' is replaced by
statement `{\tt next} $vcI$ = $tmpI$', and
$QRsI$ and $TRI$ are taken to be the the qualifiers and type
of $vcI$ in the context of the call.

If some of the qualifiers are variable qualifiers, they are
ignored in the computation of the $tmp\ldots$ values, but
the rules of \itemref{QUALIFIERS} are applied to
the prototype result variable qualifiers and the $vc\ldots$
call result variable qualifiers, and if these rules fail, the
call-prototype match fails.

If $QRs1$ $TR1$ and $QCs1$ $TC1$ are not exactly equal after protected
qualifiers have been added to $QCs1$,
the match is marked
`\key{conversion deficient}'\label{CONVERSION-DEFICIENT},
and will be disallowed later
if there is another match that is not conversion deficient.
Note that only the first result variable is considered by this rule.

\end{enumerate}


The first step in compiling a call is to compute the
set of matches of that call.  Then the following is done in order:

\begin{enumerate}

\item If there is any match that is not conversion deficient, then
all conversion deficient matches are discarded.

\item If there is any remaining match that is not module deficient, then
all module deficient matches are discarded.

\item\label{REQUIRED-ARGUMENTS-PREFERRED}
Let $e1$, $e2$, \ldots{}~be the argument expressions of
the not-unfolded original call, read from left to right.
If there are two matches $X$ and $Y$ such that
some of the $eI$ have
have {\em required-values} in $X$ but not in $Y$, and none of the $eI$
have {\em required-values} in $Y$ but not in $X$,
then the $Y$ match is discarded.

\item\label{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}
Let $e1$, $e2$, \ldots{}~be the argument expressions of
the not-unfolded original call, read from left to right.
If there are two matches $X$ and $Y$ such that
$TX1$, $TX2$, \ldots{}~are the types of the $X$ prototype argument
variables assigned to $e1$, $e2$, \ldots{}~in order, and
$TY1$, $TY2$, \ldots{}~are the types of the $Y$ argument
variables assigned to $e1$, $e2$, \ldots{}~in order,
and type $TXi$ is more specific (\pagref{MORE-SPECIFIC-RELATION})
than type $TYi$ for
every $i$, but not vice versa (which can only happen if
all the types are the same),
then the $Y$ match is discarded.

\item If after discarding matches as above, there are no matches,
the call is `\key{unmatched}' and cannot be compiled.

\item If after discarding matches as above, there is more than one
match left,
the call is `\key{ambiguous}' and cannot be compiled.

\item If the remaining match has
an ambiguity deficiency,
the call is `\key{ambiguous}' and cannot be compiled.

\item Otherwise there is just one match left, and that
match has no ambiguity deficiency.  That match
is accepted and used to compile the call.

\end{enumerate}

\section{Special Functions}
\label{SPECIAL-FUNCTIONS}

Note that in this section `\TT{std}' is used as the
{\em module-abbreviation} (\pagref{MODULE-ABBREVIATION})
of the \TT{"standard"} module.
This {\em module-abbreviation} is commonly omitted when
a function is called.

\subsection{Memory Functions}
\label{MEMORY-FUNCTIONS}

The following functions allocate memory and compute addresses.

\begin{indpar}

{\tt function *UNCHECKED* adr r = std \ttkey{NULL}}\label{NULL}

\begin{indpar}
Returns the address of a block of N bytes of virtual memory that is
inaccessible and will cause a segmentation fault if referenced.
N is at least 1 megabyte if addresses are 32 bits, and is at least
1 gitabyte if addresses are 64 bits.  The same value is returned for
all calls to {\tt NULL} within a run-time environment, or for all compile-time
calls within a compilation,  though the run-time and compile-time values
may differ.
\end{indpar}

{\tt function *UNCHECKED* adr r = std \begin{tabular}[t]{@{}l@{}}
				  \ttkey{allocate to static} \\
				  ( unsadr size, \\
				  ~~unswrd alignment ?=~0 )
				  \end{tabular}}

\begin{indpar}
Allocate {\tt size} bytes of memory with the given
{\tt alignment} in bytes to static memory, the memory
allocated when the program is initialized.  Return
the address of this memory.  The address viewed as an
integer is an exact multiple of the {\tt alignment}.

If the
{\tt alignment} is omitted or is given as 0 it is taken
to be equal to the \TT{size} if that is a power of 2
no greater than 16 (the size of a 128 bit value).
Otherwise it is an error if the {\em alignment} is 0 or
is not a power of 2.

The memory bytes are initialized to zero.

This function executes at compile-time only if it is included
in a {\em compile-time-assign\-ment-\EOL statement}
(\itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS}).
Otherwise it executes at run time.
\end{indpar}

{\tt function *UNCHECKED* adr r = std \ttkey{allocate to static} ( $T$ v )}
\begin{center}
where $T$ is any number type
\end{center}

\begin{indpar}
Allocate static memory and set it equal to {\tt v}.  
The alignment of the memory is equal to the alignment of $T$.
Return the address of this memory.  The address viewed as an
integer is an exact multiple of the alignment.

This function executes at compile-time only if it is included
in a {\em compile-time-assign\-ment-\EOL statement}
(\itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS}).
Otherwise it executes at run time.
\end{indpar}

{\tt function *UNCHECKED* adr r =} \\
{\TS ~~~~~~~~~std \ttkey{allocate UTF-8 to static} ( string s )}

\begin{indpar}
Allocate static memory and set it equal to the UTF-8 representation of the
value of {\tt s} with a \TT{NUL} appended.  The memory allocated may be
read-only, meaning that trying to write it will cause a program memory
fault error.

This function executes at compile-time only if it is included
in a {\em compile-time-assign\-ment-\EOL statement}
(\itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS}).
Otherwise it executes at run time.
\end{indpar}

\end{indpar}

The following function can be used to embed addresses in 
floating point NaNs or other numeric values.

\begin{indpar}

{\tt function *UNCHECKED* adr r =} \\
{\TS~~~~~~~~~std \ttkey{extract adr}\label{EXTRACT-ADR}} \\
{\TS~~~~~~~~~~~~~ ( uns64 v,} \\
{\TS~~~~~~~~~~~~~~~ unswrd L, unswrd S ?= 0 )}

\begin{indpar}
Take the low order {\tt L} bits of {\tt v}, shift them left by {\tt S},
and return the result as a usable byte address.
If the target machine only uses the low order $k$ bits of a 64-bit
address, the high order $64-k$ bits of the result are set according
to the requirements of the target machine, or are undefined if there
are no such requirements.  If $k>${\tt L+S},
the {\tt L} bits are padded on the left with zero bits.

For example, for an x86 target machine $k=48$ and the high order
17 bits of the returned address must be equal (all 0's or all 1's).
If {\tt L = 40} and {\tt S = 4} then 64-40-4=20 zero bits of padding are
added on the left.  If {\tt L = 44} and {\tt S = 4}, the high order
bit of the low {\tt L} bits of {\tt v} is sign extended to become
the high order 17 bits of the returned address.
\end{indpar}

\end{indpar}



\subsection{Floating Pointer Error Flag Functions}
\label{FLOATING-POINT-ERROR-FLAG-FUNCTIONS}

The \skey{floating point error flag}s of
section~\itemref{FLOATING-POINT-ARITHMETIC-EXPRESSIONS}
are located in the `\key{floating point error register}' which
is a special register of \TT{unswrd} type.  The following
builtin functions test and manipulate this register.

\begin{indpar}
{\tt function unswrd r = std \ttkey{fp error flags}} \\
{\tt function std \ttkey{clear fp error flags}} \\
{\tt function std \ttkey{clear fp error flags} ( unswrd mask ) } \\
{\tt function std \ttkey{set fp error flags} ( unswrd mask ) }

\begin{indpar}
The first function
above reads the register, the second clears the floating point
error flags in the register, the third clears just the floating point
error flags selected by the bits of {\tt mask}, and the fourth sets just the
flags selected by the bits of {\tt mask}.  The value read from the register
may contain non-zero bits other than the floating point error flags.
\end{indpar}
\end{indpar}

The following functions with no arguments
return compile time constants that are
masks for the floating
point error flags in the floating point error
register.  Each mask has a single bit on.
\begin{center}
\begin{tabular}{ll}
{\tt function unswrd r = std \ttkey{FP INVALID}}	& Invalid operand. \\
{\tt function unswrd r = std \ttkey{FP DIVIDE BY ZERO}}	& Divide by zero. \\
{\tt function unswrd r = std \ttkey{FP OVERFLOW}}	& Result overflow. \\
{\tt function unswrd r = std \ttkey{FP UNDERFLOW}}	& Result underflow. \\
{\tt function unswrd r = std \ttkey{FP INEXACT}}	& Result inexact. \\
\end{tabular}
\end{center}
The value of {\tt mask} above should be a bitwise OR's of these constants.

\subsection{Abbreviation Testing Functions}
\label{ABBREVIATION-TESTING-FUNCTIONS}

The following functions provide information
about regular abbreviations (\pagref{ABBREVIATION-DECLARATION}).

It is a compile error if any argument to these
functions is not a compile time value.  The results returned by these
functions are compile time values.

\begin{indpar}
{\tt function bool r = std ( name N ) \ttkey{is abbreviation}} \\
{\tt function name r = std \ttkey{replacement of} ( name N )} \\
{\tt function name r = std \ttkey{final replacement of} ( name N )}
\begin{indpar}
The first function returns \TT{true} if and only if {\tt N} names
an abbreviation (\pagref{ABBREVIATION-DECLARATION}).

The second function returns the replacement name from the
{\em abbreviation-declaration} of {\tt N}, or returns {\tt N} itself
if {\tt N} is not an abbreviation.  The replacement name may itself
be an abbreviation.

The third function applies the second function recursively until
the name returned is not an abbreviation.
\end{indpar}
\end{indpar}

\subsection{Compiler Functions}
\label{COMPILER-FUNCTIONS}

The following function can be used to produce compile-time
generated names like `\TT{T\TMP$n$}', which are most likely
to be useful in generics (\pagref{GENERICS}).

\begin{indpar}
{\tt function name r = std \ttkey{generated name} ( character c )}%
\label{GENERATE-NAME}

\begin{indpar}
Returns the name `\TT{$c$\TMP$n$}' where $c$ is the value of the
argument and $n$ is a natural-number such that the returned name
is unique among all names generated during the compilation, either
by this function or by the compiler.  $c$ must be an ASCII
letter.
\end{indpar}
\end{indpar}

\subsection{Program Termination Functions}
\label{PROGRAM-TERMINATION-FUNCTIONS}

The following function is used to terminate program execution
when a programming error is discovered.

\begin{indpar}

{\tt function std \ttkey{program stop}}
\begin{indpar}
This function terminates the program abnormally.  It has
the special property that deferred variables that normally
must be set in the block need not be set in an execution
path that includes a call to this function.
\end{indpar}

\end{indpar}


The following functions can be used before program termination
to diagnose the location of a programming error.  They reference
a table of call locations which is builtin.

\begin{indpar}

{\tt function string r = std \ttkey{call location} ( unswrd i )}
\begin{indpar}
Returns the call location described by the {\tt i}'th entry in the
call locations table.  This call location is a string of the form:
\begin{center}
{\em file-name}\TT{:~line~}{\em line-number}
\end{center}
specifying the location in a source code file of the
first line of the statement
containing the function call described by the {\tt i}'th entry.
Here {\em file-name} is either
the {\em module-name} (\pagref{MODULES}) or {\em body-name}
(\pagref{BODIES}) of the file; that is, it is the name of
the file containing the statement
relative to one of several directories
specified separately to the compiler.
{\em Line-number} is the number (1, 2, 3, \ldots) of the
line in which the statement begins.
\end{indpar}

{\tt function unswrd r = std \ttkey{call parent} ( unswrd i )}
\begin{indpar}
Returns the call parent $P$ of the {\tt i}'th entry in the
call locations table.
If $P$ is not 0, the {\tt i}'th entry is for a location
in an inline function call that was called from the location
described by the $P$'th entry of the call locations table.
If $P$ is 0, the call location described by  the {\tt i}'th entry
is not inside an inline function
call, but is inside an out-of-line function.
\end{indpar}

{\tt function unswrd r = std \ttkey{call entry}}
\begin{indpar}
Returns the index in the call locations
table of the entry describing
the location of the statement containing the call
to this function.
\end{indpar}

{\tt function unswrd r = std \ttkey{call entry} ( unswrd i )}
\begin{indpar}
Returns the index in the call locations
table of entry describing the location of the statement
containing the {\tt i+1}'st
active out-of-line call recorded in the program stack, counting
from the top of the stack (most recent entry).  For
{\tt i == 0} this is the out-of-line call that called the
out-of-line function which in turn called this builtin
{\tt call entry} function.  If 0 is returned, {\tt i} equals
or exceeds the number of out-of-line calls in the stack.
\end{indpar}

\end{indpar}

\section{Generics}
\label{GENERICS}

A \key{generic} is an inline function that is completely
evaluated at compile time and that contains special
`\skey{include-statement}s' which generate code that replaces the generic call
in the program.  Within the included code compile time values are substituted
for `\skey{include-argument}s'.

An example is:
\begin{indpar}\begin{verbatim}
generic min-max ( name F, name C )
    include (F, C):
        function T result = F (| type T |) ( T x, T y ):
            result = if:
                (x) C (y):
                    result = x
                (y) C (x):
                    result = y
                T is float:
                    result = NaN
                else:
                    program stop

min-max functions ( `min', `"<="' )
int64 u = ...
int64 v = min ( u, -1,000,000 )
min-max functions ( `max', `"=>"' )
float64 w = ...
next w = max ( w, -1,000,000 )
\end{verbatim}\end{indpar}

Note that {\tt C} is a function call {\em term-name} and not
an operator.
Also if `{\tt T is float}' is \TT{false} the assignment of \TT{NaN}
to `{\tt result}' will not be compiled or checked for errors
(\pagref{CONDITIONAL-SPECIAL-RULE}), while if it is \TT{true}
the `\TT{else}' subblock will not be compiled.

The general syntax is:
\begin{indpar}
\emkey{generic-declaration}\label{GENERIC-DECLARATION}
    ::= \begin{tabular}[t]{l}
        {\em generic-prototype}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{generic-prototype}\label{GENERIC-PROTOTYPE}
    \begin{tabular}[t]{rl}
    ::= & \TT{generic} ~ {\em module-abbreviation}\QMARK{}
                       ~ {\em prototype-pattern} \\
    $|$ & {\em generic-prototype} \TT{[|} {\em generic-conditioner} \TT{|]}
    \end{tabular}
\\[0.5ex]
{\em prototype-pattern} ::= see \pagref{FUNCTION-PATTERN}
\\[0.5ex]
\emkey{generic-conditioner}\label{GENERIC-CONDITIONER}
    \begin{tabular}[t]{rl}
    ::= & {\em conditioner} ~~~~~ [see \pagref{CONDITIONER}] \\
    $|$ & {\em external-conditioner}
    \end{tabular}
\\[0.5ex]
\emkey{external-conditioner}\label{EXTERNAL-CONDITIONER}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{external}{conditioner} \\
    $|$ & \TT{external if} ~ {\em logical-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{generic-call}\label{GENERIC-CALL}
    ::= {\em function-call} ~~~~~ [see \pagref{FUNCTION-CALL}]
\\[0.5ex]
\emkey{include-statement}\label{INCLUDE-STATEMENT} ::=
    \begin{tabular}[t]{rl}
    ::= & {\em include-if-statement} \\
    $|$ & {\em include-for-statement} \\
    \end{tabular}
\\[0.5ex]
\emkey{include-if-statement}\label{INCLUDE-IF-STATEMENT} ::= \\
\hspace*{1in}
    \begin{tabular}[t]{l}
    \ttkey{include} ~ \begin{tabular}[t]{@{}l@{}}
                      {\em include-name}\QMARK{}
                          ~ {\em include-argument-list}\QMARK{} \\
		      \{ \TT{if} ~ {\em logical-expression}
		                 ~ \}\QMARK{} ~ \TT{:} \\
		      \end{tabular} \\
    \TT{~~}{\em statement}\STAR{}
    \end{tabular}
\\[0.5ex]
\emkey{include-for-statement}\label{INCLUDE-FOR-STATEMENT} ::= \\
\hspace*{1in}
    \begin{tabular}[t]{l}
    \TT{include}\ttindex{include for}
        ~ \begin{tabular}[t]{@{}l@{}}
	  {\em include-name}\QMARK{}
	      ~ {\em include-argument-list}\QMARK{} \\
	  \TT{for} ~ {\em include-argument-type}
	           ~ {\em include-argument-name} \\
	  \TT{in} ~ {\em list-expression} ~ \TT{:} \\
	  \end{tabular} \\
    \TT{~~}{\em statement}\STAR{}
    \end{tabular}
\\[0.5ex]
{\em logical-expression} ::= see \pagref{LOGICAL-EXPRESSION}
\\[0.5ex]
{\em list-expression} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[0.5ex]
\emkey{include-name} ::=
    \begin{tabular}[t]{l}
    {\em name} ~~~~~ [see \pagref{NAME}] \\
    \underline{not} containing
	`\TT{.}',~ {\em quoted-marks},~ {\em quoted-separators},`\TT{if}',
		or `\TT{for}'
    \end{tabular}
\\[0.5ex]
\emkey{include-argument-list} ::=
    \TT{(} {\em include-argument-name}
           \{ \TT{,} {\em include-argument-name} \}\STAR{}
    \TT{)}
\\[0.5ex]
\emkey{include-argument-name} ::= {\em word} not containing `\TT{.}'
\\[0.5ex]
\emkey{include-argument-type} ::= {\em type-name} referencing
	an include argument type
\\[0.5ex]
\ikey{Include Argument Type}{include argument type} - One of:
    \begin{tabular}[t]{l}
    \TT{name} ~~~ \TT{character} ~~~ \TT{string} \\
    \TT{uns$x$} ~~~ \TT{int$x$} ~~~ \TT{float$x$} \\
    \TT{type} ~~~ \TT{qualifier} ~~~ \TT{qualifiers}
    \end{tabular}
\end{indpar}

A {\em generic-prototype} is like a {\em function-prototype} without
result variables, and a {\em generic-call} is like a {\em function-call}
without result variables.  {\em Function-calls} without result variables
are matched to both {\em function-prototypes} without result variables
and to {\em generic-prototypes}, and those that end up matching just a
{\em generic-prototype} are {\em generic-calls}.

A {\em generic-call} is executed at compile-time and generates a list
of `\skey{included statement}s' that replace the {\em generic-call} in
the compilation.  The included statements are the {\em statements}
of the subblocks at the end of the {\em include-statements} executed
by the called generic function.  If several {\em include-statements}
are executed, the included statement lists they generate are concatenated
in execution order.

Within the included statements generated by an {\em include-statement}
the values of the {\em include-state\-ment}'s arguments
are substituted for the {\em include-argument-names} of these
arguments.  These values are the values of variables named by
the {\em include-argument-names} within the scope
of the {\em include-statement}, and these variables
must have {\em include-argument-types}.
The substitutions depend on the {\em include-argument-types}
of the variables as follows:
\begin{indpar}[0.5in]
\hspace*{-0.3in}\ttmkey{name}{include argument}
The include argument name is replace by the sequence of lexemes represented by
the \TT{name}.  A {\em name-item} that has the syntax of a {\em word}
or {\em number} lexeme is represented by that lexeme, and all other
{\em name-items} are represented by {\em quoted-strings}.

\hspace*{-0.3in}\ttmkey{character}{include argument}
The include argument name is replaced by the two lexeme
character constant representing the value. 

\hspace*{-0.3in}\ttmkey{string}{include argument}
The include argument name is replaced by a single quoted string lexeme
representing the value.

\hspace*{-0.3in}\ttmkey{uns$x$}{include argument}
The include argument name is replace by a single natural number lexeme.

\hspace*{-0.3in}\ttmkey{int$x$}{include argument}
The include argument name is replace by a single decimal integer lexeme.

\hspace*{-0.3in}\ttmkey{float$x$}{include argument}
The include argument name is replace by a single decimal floating point
number lexeme if the value can be represented exactly by that
lexeme.  Otherwise the include argument name is replaced by the two lexeme
hexadecimal number constant representing the value exactly. 

\hspace*{-0.3in}\ttmkey{type}{include argument}
The include argument name is replaced by a type name referencing the
value.  If no type name has been defined for the \TT{type} value, the
compiler generates a {\em type-name} that is unique among all names
within the current compilation (of a module or body)
and can be used within this compilation to refer to the type.

\hspace*{-0.3in}\ttmkey{qualifier}{include argument}
The include argument name is replaced by a qualifier name referencing the
value.  If no qualifier name has been defined for the \TT{qualifier} value, the
compiler generates a {\em qualifier-name} that is unique among all names
within the current compilation (of a module or body)
and can be used within this compilation to refer to the type.

\hspace*{-0.3in}\ttmkey{qualifiers}{include argument}
The include argument name is replaced by a list of qualifier names referencing
the qualifiers listed in the value, which must be a qualifier list or a
qualifier set.  If one of these qualifiers has no name, the
compiler generates a {\em qualifier-name} that is unique among all names
within the current compilation (of a module or body)
and can be used within this compilation to refer to the qualifier.

\hspace*{-0.3in}Also the name `\ttkey{..ma}' is treated by the parser
as a module abbreviation, and if it appears in the included code,
refers to either the current module or to no module (as for a non-external
name), as determined by {\em external-conditioners}
(\pagref{EXTERNAL-CONDITIONER-EXPLANATION}).
\end{indpar}

An example is:
\begin{indpar}\begin{verbatim}
module "my module" as mymod
generic goo ( name N, name OP,
              character C, string S,
              int32 X, float64 Y, float64 Z,
              type T )
        [| external if T is external |]
    include ( N, OP, C, S, X, Y, Z, T ):
        define abbreviation n ---> `N'
        int64 N = 0
        character c = C
        string ..ma s = S
        int32 x = X
        float64 y = Y
        float64 z = Z
        T v = x OP y
        T w = x * z OP y

goo ( `my variable', `"+"', C"<LF>", "Hi There",
      1,234, 1.5, 0.3, float64 )
    // Equivalent to:
    //    define abbreviation n ---> `my variable'
    //    int64 my variable = 0
    //    character c = C"<LF>"
    //    string mymod s = "Hi There"
    //    int32 x = 1,234
    //    float64 y = 1.5
    //    float64 z = X"0.4CCCCCCCCCCCCC"
    //    std float64 v = x "+" y
    //    std float64 w = x "*" ( z "+" y )
\end{verbatim}\end{indpar}

The {\em generic-declaration} is parsed when first encountered
by the compiler, but the included statements are not
compiled.
This means that operators in unparsed form cannot be substituted
in included statements.  So the computation of {\tt w} in the
example substitutes in the parsed expression `{\tt (x) "*" (z OP y)}'
where {\tt OP} has not been identified as an operator by the parser.

Also note that substitution inside name constant brackets such as
\TT{`'} is allowed.

The word `\key{..ma}' is treated as a module abbreviation by the
parser.\label{EXTERNAL-CONDITIONER-EXPLANATION}
If no `\ttkey{external}' {\em generic-conditioner} is present, or
if this is a compilation of a body file, `\TT{..ma}'
is deleted (replaced by an empty lexeme sequence).
If an `\TT{external}' {\em generic-conditioner} is present and a module
is being compiled, `\TT{..ma}'
is replaced by the abbreviation of the module.
If the {\em generic-conditioner} has the form `\TT{external if $e$}',
the expression $e$ is evaluated at the beginning of the evaluation of
the generic, and if \TT{true}, the effect is as if just `\TT{external}'
were the conditioner, but if \TT{false}, the effect is as if there
was no conditioner.

The `\TT{if }{\em logical-expression}' option
causes the {\em statements} to be included if and only if the
{\em logical-expression} evaluates to \TT{true}.  An example use is:
\begin{indpar}\begin{verbatim}
generic min-max ( type T, name F, name C )
    include ( T, F, C ):
        function T result = F ( T x, T y ):
            include if not T is float:
                result = if:
                    (x) C (y):
                        result = x
                    (y) C (x):
                        result = y
                    else:
                        program stop
            include if T is float:
                result = if:
                    (x) C (y):
                        result = x
                    (y) C (x):
                        result = y
                    else:
                        result = NaN
\end{verbatim}\end{indpar}

Only whole {\em statements} can be included, but {\em include-statements}
can be nested.  A nested {\em include-if-statement} does not have an
{\em include-argument-list} but instead inherits the {\em include-arguments}
of its containing {\em include-statement}.  The values of include arguments,
{\em logical-expressions}, and {\em list-expressions} in a set of
nested {\em include-statements} are computed at compile-time
just before the outermost of the {\em include-statements}.
No substitutions are made in {\em logical-expressions} or {\em list-expressions}
before they are evaluated.  Thus in the example, `{\tt not T is float}'
is evaluate as is, without any substitution for {\tt T},
just before `{\tt include ( T, F, C )}'.

The {\em include-for-statement} introduces a new {\em include-argument-name}
and assigns to it values from the list produced by a {\em list-expression}.
The {\em statements} in its subblock are included once for each value
from the list.  The {\em include-argument-name} introduced after the
`\TT{for}' is \underline{not} included in the {\em include-argument-list}
of the statement.  An example is:
\begin{indpar}\begin{verbatim}
generic min-max functions ( name F, name C ):
    include (F, C ) for T in [uns32, int32, uns64, int64]:
        min-max function ( T, F, C )
min-max function ( `max', `"=>"' )
    // Equivalent to:
    //
    // min-max function ( uns32, `max', `"=>"' )
    // min-max function ( int32, `max', `"=>"' )
    // min-max function ( uns64, `max', `"=>"' )
    // min-max function ( int64, `max', `"=>"' )
\end{verbatim}\end{indpar}

If an {\em include-statement} $S$ has an {\em include-name} $N$, then
{\em include-statements} nested inside $S$ that do \underline{not}
have the {\em include-name} $N$ are treated as ordinary statements
and not as nested {\em include-statements}.  An example is:
\begin{indpar}\begin{verbatim}
generic min-max functions ( type T ):
    include X ( T ):
        generic min-max function ( name F, name C ):
            include ( F, C ):
                function T r = F ( T x, T y ):
                    include X if T is float:
                        if:
                            x C y:
                                r = x
                            y C x:
                                r = y
                            else:
                                r = NaN
                    include X if not T is float:
                        if:
                            x C y:
                                r = x
                            y C x:
                                r = y
                            else:
                                program stop
        min-max function ( `min', `"<="' )
        min-max function ( `max', `"=>"' )
min-max functions ( uns32 )
    // Equivalent to:
    //
    // generic min-max function ( name F, name C )
    //     include ( F, C ):
    //         function std uns32 r =
    //                 F ( std uns32 x, std uns32 y ):
    //             if:
    //                 x C y:
    //                     r = x
    //                 y C x:
    //                     r = y
    //                 else:
    //                     program stop
    // min-max function ( `min', `"<="' )
    // min-max function ( `max', `"=>"' )
\end{verbatim}\end{indpar}

{\em Include-statements} without {\em include-names} are treated
as if they all had the same {\em include-name} that is different
from every other {\em include-name}.

The included statements that replace a generic call are compiled in the
current context, and \underline{not} the context of the
generic declaration.  The statements of the generic function
itself, and any default values in the generic prototype,
are compiled in the context of the generic declaration,
just as for an inline function.

If you want code compiled in another
context (\pagref{CONTEXT}), wrap that code in the body of an inline function
declared in that other context.  An example that implements a writable
parameter is:
\begin{indpar}\begin{verbatim}
module "my_module" as mymod
*UNCHECKED* adr p = allocate to static ( float64 ( 0 ) )
// Parameter is float64 stored at address p
// P is not visible in other modules.

// function to allow reading of parameter
// by other modules.  Usage is:
//
//    float64 v = mymod my parameter
//
function *MEM* float64 r, adr r.adr = mymod my parameter:
    r.adr = p
\end{verbatim}\end{indpar}

As an additional feature of generics, whenever the word
`\TT{G\TMP*}' appears in the included code, it is replaced
by `\TT{G\TMP$n$}', where $n$ is a natural number unique
to the generic call within the compilation.  This allows
creation of names unique to the generic call.  Note that
`\TT{G\TMP*}' can be part of a name, and not the entire name,
so its replacement is not like the replacement of abbreviations.

The \TT{generate name} function (\pagref{GENERATE-NAME})
may be used to generate other names which can be substituted
for include arguments.

\section{Clusters}
\label{CLUSTERS}

A \key{cluster} is a group of related variables.  One variable of
the cluster is the \mkey{base variable}{of cluster} of the cluster, and the
other variables have names that are derived from the
name of the base variable by adding {\em member-selectors}
to the end of the base variable name.  See \pagref{NAMES}.

Thus a cluster
is like a C/C++ structure, but it is a set of variables and not a
piece of memory.

More specifically, the members of the cluster can be named by
adding either a member name beginning with a `\TT{.}' or a
`\TT{[]}' bracketed list of
integer indices to
either the base variable name of the cluster or to another member name
of the cluster.  Two variable names with different base variable names
belong to different clusters.  The indices must be compile time
constants when the member is allocated and written, but may be expression
run time values when the member is read.

Variables in clusters are thus organized into trees, with clusters
that have different bases being in disjoint trees.  Any variable in a cluster
can be considered
as the \mkey{root}{of subcluster} of a subtree of cluster members, and
the subtree is called a \key{subcluster}.

The main feature of clusters and subclusters
is that members are passed to or returned
from functions implicitly when their the root variable is named
explicitly.  Furthermore, non-root cluster members \underline{cannot}
be created except as implied results of function calls.

More specifically, non-root cluster members \underline{cannot}
be created or updated (via `\TT{next}')
by using them as result variable names in an
{\em assignment-statement}.  They can only be created or updated
when their root is given as an actual result or actual argument
to an inline function call, and the prototype of the function
specifies that the non-root cluster members should be implicitly created
or updated.

For example:
\begin{indpar}\begin{verbatim}
// The module has an exported parsing block containing:
//
//     define prefix "reference-prefix" operator "*"
//     define prefix "reference-postfix" operator "++"

define type pointer pair as void
    // if pp is a pointer pair then:
    //   unsadr pp.begin is the offset of the first element
    //   unsadr pp.end is the offset just AFTER the
    //                 last element
    //   *MEM* adr pp.base is the base address that
    //                     is added to the offsets
    //   adr pp.base.adr is the address of pp.base
    //   type pp.type is type of elements pointed at

// Function to allocate a vector of n T's to the stack.
//
function *STACK* pointer pair pp,
         unsadr pp.begin,
         unsadr pp.end,
         *MEM* adr pp.base,
         adr pp.base.adr,
         type pp.type =
      allocate to stack ( type T, uns32 n ):
    require ( zero value OK ( T ) )
    pp.type = T
    unsadr size = size of ( T ) * n
    *UNCHECKED* void p = allocate to stack ( size )
    pp.base.adr = p.base.adr
    *UNCHECKED* unsadr offset = re-qualify ( p.offset )
        // Gets rid of *STACK* qualifier
    pp.begin = offset
    pp.end = pp.begin + size

// Assignment operator for pointer pairs.
//
function Qs pointer pair pp2,
         unsadr pp2.begin,
         unsadr pp2.end,
         *MEM* adr pp2.base,
         adr pp2.base.adr,
         type pp2.type

       = assign (| qualifiers Qs |)
                (  Qs pointer pair pp,
                   type pp.type,
                   unsadr pp.begin,
                   unsadr pp.end,
                   adr pp.base.adr ):

    pp2.begin = pp.begin
    pp2.end = pp.end
    pp2.base.adr = pp.base.adr
    pp2.type = pp.type

// Operator to dereference a point returning the value
// pointed at.
//
function *MEM* pp.type out,
         unsadr out.offset,
         *MEM* adr out.base,
         adr out.base.adr =

      "*" ( *STACK* pointer pair pp,
            type pp.type,
            unsadr pp.begin,
            unsadr pp.end,
            adr pp.base ):
    if:
        pp.begin < pp.end:
            out.offset   = pp.begin
            out.base.adr = pp.base.adr
        else:
            fatal error
                ( "Dereferencing empty pointer pair." )

// Postfix operator to increment the begin pointer of a
// pointer pair while returning the original pointer
// pair.
//
function Qs pointer pair pp2,
         unsadr pp2.begin,
         unsadr pp2.end,
         *MEM* adr pp2.base,
         adr pp2.base.adr,
         type pp2.type,
         next pp.begin

       = (| qualifiers Qs |)
         (  Qs pointer pair pp,
            type pp.type,
            unsadr pp.begin,
            unsadr pp.end,
            adr pp.base.adr )
         "++":

    pp2.begin = pp.begin
    pp2.end = pp.end
    pp2.base.adr = pp.base.adr
    pp2.type = pp.type

    unsadr r = pp.begin + size of ( pp.type )
    if:
        r < pp.begin:
            fatal error ( "Pointer pair adr overflow." )
            // adr address arithmetic overflow
        else:
            next pp.begin = pp.begin + size of ( pp.type )

// Example usage:
//
function ...

    // Vector of 2 int32's is allocated and the elements
    // are set equal to 100 and 101.
    //
    pointer pair pp = allocate to stack ( int32, 2 )
    * pp ++ = 100
    * pp ++ = 101
    . . . .
    // Vector of 1000 float64's is summed.
    //
    pointer pair ppf = allocate to stack ( float64, 1000 )
    ... set 1000 elements ...
    float64 sum = loop:
        initially:
            float64 partial sum = 0
            pointer pair ppf2 = ppf
        while ppf2.begin < ppf2.end:
            next partial sum = partial sum + * ppf2 ++
        finally:
            sum = partial sum
\end{verbatim}\end{indpar}\label{NEXT-CLUSTER-BASE-EXAMPLE}

Note that although the functions defining operations on a pointer pairs
are a long winded, usage of pointer pairs is compact and easy.
This is a general characteristic of the L-Language, and derives
from the fact that the functions automatically manage the members
of a cluster.

In this example \TT{*MEM*}\label{MEM} is a special builtin variable qualifier.
Its special property is if a variable
{\tt v} of qualifier \TT{*MEM*} is allocated,
and if a cluster members  {\tt v.base} of type \TT{adr}
and {\tt v.offset} of type \TT{unsadr}
are allocated and assigned values, then
the cluster root {\tt v} is automatically
assigned the value read from the RAM address {\tt v.base + v.offset}.
It is an error in this case to explicitly assign a value to {\tt v}.
This is how {\tt out} gets its value from
{\tt out.base}, and {\tt out.offset} in the {\tt "*"} prototype.

Similarly if {\tt v} and {\tt v.adr} are allocated, {\tt v} has qualifier
\TT{*MEM*}, and {\tt v.adr} is assigned a value, then
the cluster root {\tt v} is automatically
assigned the value read from the RAM address {\tt v.adr}.
This is how {\tt out.base} gets its value from
{\tt out.base.adr} in the {\tt "*"} prototype, and
how {\tt pp.base} gets its value from
{\tt pp.base.adr} in the {\tt allocate to stack} prototype.

For details on the \TT{*MEM*} qualifier see \itemref{THE-MEM-QUALIFIER}.

The \TT{*STACK*} value qualifier in the example has the special property
that values with
this qualifier may not be passed out of a block with a free
stack.  This keeps stack addresses from escaping contexts in
which they are valid.  See Sections~\itemref{THE-STACK-QUALIFIER} and
\itemref{STACK-MANAGEMENT}.

Other examples of the use of clusters are the implementation of
\TT{if/else} expressions (\pagref{IF-ELSE-IMPLEMENTATION})
and \TT{</<=/==/!=/=>/>} expressions (\pagref{COMPARE-IMPLEMENTATION}).

The actual arguments and result variables of a function call are
matched to corresponding prototype arguments and result variables in
a function prototype, but when these are cluster members that are
not cluster roots, the matching process is modified.

When a cluster member name $v.m$ is used as prototype argument name,
the root $v$ of the member name must also be a prototype argument name.
An actual call argument $w$ must correspond to the prototype root $v$, but
\underline{no actual} argument may correspond to the prototype member $v.m$.
Instead, the cluster member $w.m$ of the actual root argument is implicitly
matched to the prototype member $v.m$.  If $w.m$ does not exist,
the call/prototype match fails unless the prototype $v.m$ has a
default value (see \pagref{DEFAULT-VALUE} ).

Here $v$ denotes a variable name without any {\em member-selectors},
and $.m$ denotes any sequence of {\em member-selectors}, including possibly
{\em member-subscripts}.

When a cluster member name $v.m$ is used as prototype result name in
a {\em prototype-result-variable-declaration} that is \underline{not}
of the form `{\tt next $v.m$}',
the root $v$ of the member name must also be either a prototype result name
or a prototype argument name.
An actual call argument or result variable
$w$ must correspond to the prototype root $v$, but
\underline{no actual} result variable
may correspond to the prototype member $v.m$.
Instead, the cluster member $w.m$ of the actual root is implicitly
matched to the prototype member $v.m$.  This implies that $w.m$ must
not pre-exist the call.  If it does, the call/prototype match fails.

When a cluster member name $v.m$ is used as prototype result name in
a {\em prototype-result-variable-declaration} that \underline{is}
of the form `{\tt next $v.m$}', the cluster member name $v.m$ itself
must be a prototype argument name.  This implies that $v$ must also
be a prototype argument name with a matching actual argument $w$.
Either $w.m$ must pre-exist the call, or if $v.m$ has a default
value, then $w.m$ will be created with the default value before
the call is made.  The call will create a new variable of the
same name $w.m$ to supercede the pre-call $w.m$.
If $w.m$ does not pre-exist the call the $v.m$ has no default
value, the call/prototype match fails.

The following is an example:
\begin{indpar}\begin{verbatim}
function bool v.nonneg = test sign ( int32 v ):
    if:
        v => 0:
            v.nonneg = true
        else:
            v.nonneg = false

function test sign ( int32 v, bool v.nonneg ):
    // Do nothing

int32 x = 89
int32 y = -5
test sign ( x )    // Creates x.nonneg = true
test sign ( y )    // Creates y.nonneg = false
test sign ( x )    // Does nothing
\end{verbatim}\end{indpar}

A variable whose underlying type is \TT{void} has no actual value
and must not be assigned one.  Such variables are only useful
as cluster and subcluster roots.  The `\TT{allocate to stack}'
function requires that its result be a variable whose underlying
type is \TT{void} (see \pagref{ALLOCATE-TO-STACK}).

A cluster member may be used as an actual argument if
the corresponding prototype argument is
\underline{not} a cluster member.  A cluster member may \underline{not}
be used as an actual result.

Importantly, cluster members may only be created or updated
(via `\TT{next}')
as inline function call results.  Thus if
the inline functions are written correctly, the program will be type-safe.

\section{Builtin Qualifiers}
\label{BUILTIN-QUALIFIERS}

The builtin qualifiers are \TT{*MEM*}, \TT{*WRITABLE*}, \TT{*UNCHECKED*},
\TT{*STACK*}, \TT{*DEFERRED*}, and \TT{*OPTIONAL*}.
There is also a special class of qualifiers called trace qualifiers.

\subsection{The \TT{*MEM*} Memory Qualifier}
\label{THE-MEM-QUALIFIER}

The \ttakey{MEM} qualifier is a protected variable qualifier that behaves
in a special way when it is given to a variable {\tt v}.
In this situation {\tt v} is a copy of a RAM memory value and
must be in a cluster that
has either:
\begin{enumerate}
\item
A member {\tt v.adr} of type \TT{adr} 
that is the RAM address of {\tt v}.

\item
Members {\tt v.offset} of type \TT{intadr} or \TT{unsadr} and
{\tt w.base} of type \TT{adr}, where
{\tt w} is either {\tt v} or an ancestor
of {\tt v} in the cluster (if there are several such ancestors, the
closest to {\tt v} is selected).
In this case the RAM address of {\tt v} is {\tt v.offset+w.base}.

\item
It is possible for any of the cluster members mentioned above,
i.e., {\tt v.adr}, {\tt v.offset}, or {\tt w.base}, to have the
\TT{*MEM*} qualifier, in which case they must obey these rules recursively.
E.g., if {\tt w.base} has the \TT{*MEM*} qualifier there must be either
{\tt w.base.adr}, or there must be both
{\tt w.base\EOL .offset} and {\tt w.base.base} (in this case
{\tt w.base.base} must exist and {\tt w.base} cannot be used as its
own {\tt .base}).
\end{enumerate}

A variable {\tt v} with \TT{*MEM*} qualifier
must \underline{not} be given a value by an
assignment statement, but will instead be loaded with a value
from its RAM address.  It is called a `\key{RAM cache variable}'.

The type of the variable {\tt v} must \underline{not} have \TT{void} as its
underlying type.

An example is:

\begin{indpar}\begin{verbatim}
// In C/C++:
//     struct foo_struct { int a, b, c }
//     typedef foo_struct * foo
//
// Here a cluster foo, foo.a, foo.b, foo.c
// where foo is an address.
//
define types:
    foo as void
    foo_ptr as adr
function foo x, adr x.base,
         *MEM* *WRITABLE* int32 x.a, x.a.offset,
         *MEM*            int32 x.b, x.b.offset,
         *MEM* *WRITABLE* int32 x.c, x.c.offset
        = "*" ( foo_ptr y ):
    x.base = y
    x.a.offset = 0
    x.b.offset = 4
    x.c.offset = 8
function next x.a = update a
        ( foo x, *MEM* *WRITABLE* int32 x.a, int32 v ):
    next x.a = v

// Usage:
//
foo_ptr zp = ...        // assign adr to zp
foo z = * zp            // Assign to z.base, z.a.offset, ...
... z.a ...             // Use z.a
update a ( z, ... )    // Write z.a

\end{verbatim}\end{indpar}

If {\tt v} is a \TT{*WRITABLE*}
RAM cache variable, assigning a value to `{\tt next v}'
writes the value to RAM.  For example:

\begin{indpar}\begin{verbatim}
    function *MEM* *WRITABLE* r, adr r.adr = foo ( ... ):
        . . . . . . . . . .
    int32 v = foo ( ... )
    next v = ...       // Writes value to v.adr and updates v
\end{verbatim}\end{indpar}

If a RAM cache variable {\tt v}'s value is not used,
it will not actually be loaded from RAM, even if {\tt v} is written
by assigning a value to `{\tt next v}'.

Because \TT{*MEM*} and \TT{*WRITABLE*} are protected qualifiers,
RAM cache variables can only be created as
results of inline function calls.
So only inline functions can effect a read or write
of RAM contents.

There is a special unchecked function of zero arguments, \TT{NULL}, of result
type \TT{adr}, that
references a block of virtual memory that is
inaccessible and will cause a segmentation fault if referenced
(\pagref{NULL}).


\subsection{The \TT{*STACK*} Qualifier}
\label{THE-STACK-QUALIFIER}

The `\ttakey{STACK}' qualifier is a prohibited,
protected, value qualifier
attached to clusters containing offsets and addresses
returned by the builtin `\TT{allocate to stack}'
function (\pagref{ALLOCATE-TO-STACK}).
It is used to keep a stack address or offset from being stored in
non-stack memory and in stacks who lifetime exceeds that of the
memory the stack the address or offset points into.

The special property of the \TT{*STACK*} qualifier is that it cannot
be used to qualify variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
or iteration variables in a {\em loop-assignment-statement}.
This is so that stack addresses and offsets pointing into a free stack
cannot outlive the free stack.
See Section~\itemref{STACK-MANAGEMENT} for more information.

Also, as a prohibited qualifier, a \TT{*STACK*} value cannot be
passed as an argument to a function that does not expect a
\TT{*STACK*} value.  For example:
\begin{indpar}\begin{verbatim}
*STACK* adr sa = ...
adr ta = ...
function adr result = F ( adr arg ):
    . . . . . . . . . .
function adr result = G ( *STACK* adr arg ):
    . . . . . . . . . .
adr xa = F ( sa ) // Illegal; F's arg does not have
                  // *STACK* qualifier.
adr ya = G ( sa ) // Legal; G's arg has *STACK* qualifier.
adr za = G ( ta ) // Legal; G's arg's *STACK* qualifier has
                  // no effect (its not required).
\end{verbatim}\end{indpar}

\subsection{The \TT{*UNCHECKED*} Qualifier}
\label{THE-UNCHECKED-QUALIFIER}

The \ttakey{UNCHECKED} qualifier is a
required, prohibited variable qualifier that marks actual result variables
whose values are computed by functions that
break type checking or other language rules.

For example, the actual result variables of unchecked conversions
must have the \TT{*UNCHECKED*} qualifier.

It is possible for two functions to have identical prototypes
except that one has the \TT{*UNCHECKED*} qualifier on its
result variable and the other does not.  The function selected by
call-prototype matching will depend upon whether the actual
result variable of the call has the \TT{*UNCHECKED*} qualifier,
because the qualifier is \underline{both} required and prohibited.
An example is given on page \pageref{NOT-UNCHECKED-CONVERSION-DEFINITION}.

The \TT{*UNCHECKED*} lexeme is also used as the initial part some
names. An example is the \TT{*UNCHECKED* *ASSEMBLY*} assignment statement.

\subsection{Trace Qualifiers}
\label{TRACE-QUALIFIERS}

A \key{trace qualifier} permits values to be marked so that they
can be found (i.e., `traced') by garbage collectors
(and occasionally debuggers)
when they are stored in the
stack.  A trace qualifier may be declared by:

\begin{indpar}
\emkey{trace-qualifier-declaration}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{trace qualifier}
           {\em defined-qualifier-name} \\
        & ~~~~~ \TT{with base type}~~{\em type-name}
    \end{tabular}
\end{indpar}

The base type of a trace qualifier may be determined by the
function with the prototype:
\begin{center}
{\tt (type T) = \ttkey{base type of} ( qualifier Q )}
\end{center}
The value of any variable with the trace qualifier must be
\TT{*UNCHECKED*} convertible to a value of the base type.

It is common to add a trace qualifier to the statement that
defines a type you want to trace.  An example in which the
qualifier is \TT{Q} and the type is \TT{T} is:
\begin{indpar}\begin{verbatim}
trace qualifier Q with base type adr
define type Q T as adr
\end{verbatim}\end{indpar}
which causes all values of type \TT{T} in the stack to be
traced.

More specifically, when a value \TT{V} of a variable with the trace
qualifier \TT{Q} and base type \TT{B} is added to a stack,
\TT{V} converted to type \TT{B} is also
pushed into a (virtual or physical) \TT{Q}-stack of values of
type \TT{B}.
When the stack containing \TT{V} is freed, the corresponding
value in the \TT{Q}-stack is popped.  There is a \TT{Q}-stack
associated with every process and every global area.
Using functions in the
subroutine library (see TBD), these \TT{Q}-stacks can be read.

While a value may be pushed into a stack more than once,
a value will not be pushed if the compiler can prove it is already
in the stack.  Thus given the definitions above, in
\begin{indpar}\begin{verbatim}
T v = ...
T w = v
\end{verbatim}\end{indpar}
the first statement may push the value of \TT{v} to the \TT{Q} stack
but the second statement will not push the value of \TT{w} on
the grounds that it is already in the stack.

\subsection{The Reload Statement}
\label{THE-RELOAD-COMMAND}

The reload statement has the syntax:
\begin{indpar}
\emkey{reload-statement} ::=
    \ttkey{reload} {\em qualifiers} \{ \TT{,} {\em qualifiers} \}\STAR{} \\
\emkey{qualifiers} ::= {\em qualifier} $|$ {\em qualifier-set} \\
\emkey{qualifier} ::= {\em expression} evaluating to a qualifier \\
\emkey{qualifier-set} ::= {\em expression} evaluating to a qualifier set
\end{indpar}

This statement declares the values of all variables with the designated
qualifiers to be out-of-date and unusable.  If any of these variables
is used subsequently, statements to recompute the variable value
will be inserted automatically into the code at the point of the
\TT{reload} statement.  If this is not possible the compilation will
be in error.

As a special case, if a variable that is declared to be out-of-date,
\TT{v}, has the \TT{*MEM*} qualifier, and is in
a cluster that causes \TT{v} to be loaded from memory
(as per Section~\itemref{THE-MEM-QUALIFIER}), then if \TT{v} is declared
to be out-of-date, recomputing \TT{v} just means that \TT{v}
is reloaded from RAM.  The possibility that software cache
variables (with the \TT{*MEM*} qualifier) will become out-of-date because
the RAM locations they cache have changed is the reason the \TT{reload}
statement exists.

The statement
\begin{center}
\TT{reload *MEM*, *MEM* dependent}
\end{center}
is commonly used to declare all
variables that act as software caches of memory, and all variables
that should be updated when the caches are updated, to be out-of-date.

Note that variables computed from out-of-date variables are \underline{not}
declared to be out-of-date.

If an out-of-date variable value is not used after the \TT{reload} statement,
it is not recomputed.

Variable values are recomputed in the same order as they were
originally computed.  How each variable is recomputed depends upon
how it was originally computed.

If a variable \TT{v} was originally computed by
a {\em simple-assignment-statement}
of the form `{\em type} \TT{v =} {\em expression}', then if
no input to {\em expression} has been recomputed, \TT{v} does not
need to be recomputed.  Otherwise \TT{v} is recomputed by re-executing
the assignment statement.

If a variable without a \TT{*MEM*} qualifier needs to be
recomputed and was computed by other than
a {\em simple-assignment-statement}, it is a compile error if the
variable is marked out-of-date and later used.

The \TT{reload} statement behaves like an executable statement but
it has some unusual properties when it is executed inside a
nested subblock.  First, it declares out-of-date any variable with
the given qualifiers that is visible in its subblock \underline{and any
containing block}.
Second, it will recompute any out-of-date variable in its subblock
\underline{or any containing block} that may be used after the
\TT{reload} statement executes.
Third, when it recomputes variables, it overwrites
the place the variable is stored, rather than allocating a new
place as would a `\TT{next~}{\em variable-name}' expression.
These properties allow `\TT{reload Q}' to appear in an inline
or conditional subblock.

\section{Memory Write Statements}
\label{MEMORY-WRITE-STATEMENTS}

Statements that write memory make use of cluster structures
similar to those used with
\TT{*MEM*} qualifier variables:
see Section~\itemref{THE-MEM-QUALIFIER}.

Specifically, memory needs to be addressed.  This is done by either
of the following methods of specifying a RAM address:
\begin{enumerate}
\item
An `\key{address variable} \TT{va}
of type \TT{adr} with either of the qualifiers
\TT{*MEM*} or \TT{*UNCHECKED*} that contains the RAM address.
If \TT{va} has qualifier \TT{*MEM*} it must obey
the rules of Section~\itemref{THE-MEM-QUALIFIER}.


\item
An `\key{address variable}' \TT{vo} of type \TT{intadr} or \TT{unsadr} and
qualifier \TT{*UNCHECKED*} in a cluster, and
a variable \TT{vb.base} of type \TT{adr} and qualifier \TT{*MEM*}
or \TT{*UNCHECKED*} where \TT{vb} is either \TT{vo} or an ancestor
of \TT{vo} in its cluster.
In this case the RAM address is \TT{vo+vb.base}.
If \TT{vo.base} has qualifier \TT{*MEM*} it must recursively obey
the rules of Section~\itemref{THE-MEM-QUALIFIER}.

\end{enumerate}

An address variable may be the member \TT{v.adr} or \TT{v.offset}
of a cluster with RAM cache variable \TT{v}.  In this case the
address variable is said to be the `\mkey{address}{of RAM cache variable}'
of the RAM cache variable \TT{v}.

\subsection{Single Value Write Statements}
\label{SINGLE-VALUE-WRITE-STATEMENTS}

The form of a single valued write statement is:

\begin{indpar}
\emkey{single-value-write-statement} ::=
    \TT{*WRITE*} {\em value-variable} {\em address-variable}
\end{indpar}

The value in the {\em value-variable} is written to the RAM address
in the {\em address-variable}.  If the {\em address-variable} is the
address of a RAM cache variable \TT{v}, the write statement does
\underline{not} update \TT{v} or create `\TT{next v}'.

\subsection{Memory Copy Statements}
\label{MEMORY-COPY-STATEMENTS}

The form of a memory copy statement is:

\begin{indpar}
\emkey{memory-copy-statement} ::=
    \TT{*COPY*} {\em source-variable} {\em destination-variable}
    		{\em length-variable}
\end{indpar}
Bytes are copied from the RAM address in the {\em source-variable}
to the RAM address in the {\em destin\-ation-\EOL variable}.
The number of bytes copied is in the {\em length-variable},
which must be of the \TT{unsadr} type.

If the source address is greater than the destination address,
the bytes are copied in ascending address order.  If the
source address is less than the destination address,
bytes are copied in descending address order.  If the two
addresses are equal, bytes may or may not be copied.  The effect of
all this is to copy regions of memory correctly even if they
overlap.


\subsection{Memory Set Statements}
\label{MEMORY-SET-STATEMENTS}

The form of a memory set statement is:

\begin{indpar}
\emkey{memory-set-statement} ::=
    \TT{*SET*} {\em value-variable} {\em address-variable}
    		{\em length-variable}
\end{indpar}
The `set length' is stored in the {\em length-variable} which must
be of \TT{unsadr} type.  As long as the set length is not zero,
this statement performs a \TT{*WRITE*} operation on its
first two arguments, and then increments the address by
the length of the type of the value, and decrements the set length
by one.

\subsection{Atomic Memory Statements}
\label{ATOMIC-MEMORY-STATEMENTS}

An \key{atomic-memory-statement} is a generalization of
the classic compare-and-set instruction.  It is a block assignment
statement that executes a sequence of specialized instructions:

\begin{indpar}
\emkey{atomic-memory-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \TT{( uns32 count, adr bad address ) = }\ttakey{ATOMIC} \TT{:} \\
	\TT{~~~~}{\em lock-instruction}\STAR{} \\
	\TT{~~~~}{\em compare-instruction}\STAR{} \\
	\TT{~~~~}{\em write-instruction}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{lock-instruction} ::= \ttakey{LOCK} {\em lock-variable} \\
\emkey{compare-instruction} ::= \ttakey{COMPARE} {\em compare-variable}
						  {\em address-variable} \\
\emkey{write-instruction} ::= \\
\hspace*{0.2in}\begin{tabular}[t]{rl}
        & \TT{*WRITE*} {\em value-variable} {\em address-variable} \\
    $|$ & \TT{*COPY*} {\em source-variable} {\em destination-variable}
    		      {\em length-variable} \\
    $|$ & \TT{*SET*} {\em value-variable} {\em address-variable}
    		     {\em length-variable} \\
    \end{tabular}
\end{indpar}

The special instructions,
which make use of clusters (Section~\itemref{CLUSTERS}),
and are as follows:
\begin{indpar}[0.4in]
\hspace*{-0.2in}{\em \bf Lock-Instruction}.
The {\em lock-variable} is of type \TT{uns32}
and identifies the lock.
The lock is a binary test-and-set lock provided by the
underlying system.  Locks are allocated to sets of processes
that share memory, so that if any process in the set gets
the lock, other processes in the set cannot.

The lock instruction sets the lock and succeeds if the lock
was not already set, and otherwise just fails.

When the {\em atomic-assignment-statement} terminates, either
successfully or when it fails, all locks gotten are released in
reverse order.

\hspace*{-0.2in}{\em \bf Compare-Instruction}.
The compare
instruction reads the value at the {\em address-variable} designated
address and compares
it to the value of the {\em compare-variable}.  The instruction
succeeds if the values are equal, and fails otherwise.

The {\em compare-variable} may be a RAM cache variable whose
address is the {\em address-variable}.  The RAM cache variable
is not changed even if the value read does not match its value.

\hspace*{-0.2in}{\em \bf Write-Instructions}.
These do what they normally do, except they are all dry-run 
before any actually execute.  During the dry-run one of these
instruction fails if any memory reference it makes would fail
were the instruction actually executed.  In particular, if any
piece of memory is paged out or not in RAM, the dry-run fails.
\end{indpar}

The `\TT{count}' value returned by the {\em atomic-memory-statement}
equals \TT{0} if the statement succeeds, or is the number of the
first failed instruction in the statement block if the statement
fails (the first instruction is number \TT{1}).
The `\TT{bad address}' value is \TT{0} unless the block
fails because of a memory fault, in which case the `\TT{bad address}'
value is set to the faulting address.  One usually deals with a faulting
address by reading it with a normal instruction if it is a read fault,
or writing it with a normal instruction that does not change its
value if it is a write fault (this may require a compare and set
assembly instruction),
and then retrying the \TT{*ATOMIC*} block.

Interrupts of all kinds are disabled during the execution of an
{\em atomic-memory-statement} so the statement will execute as
fast as the underlying hardware will allow.  However, this means
that memory paging is disabled, so instructions will fail if
they page fault.  This is the reason for the dry-run of the
{\em write-instructions}, to be sure they will not fail
when they actually write data.

A system may put restrictions on the size of the value in
a {\em length-variable}, and on the number of instructions
in an \TT{*ATOMIC*} block, in order to ensure that interrupts
are not disabled for very long.  Violation of these restrictions
causes a \TT{*ATOMIC*} block instruction fault that is distinct
from \TT{*ATOMIC*} block failures described above (such violations
are not recoverable).

\section{Stack Management}
\label{STACK-MANAGEMENT}

Each execution thread has a stack that is not in any other
stack.  Each out-of-line function
execution is a block execution that has a stack which is
by default a substack of the thread in which the function
execution is running.  Each subblock in turn has a stack
which is by default a substack of the stack of its containing block.
And each global area has a stack that is not in any other stack.

Conceptually, the assignment statements in a block each allocate memory for
their variable to the current block stack and copy values to these
variables.  As noted above (Section~\itemref{ASSIGNMENT-STATEMENTS}),
the memory and associated copies may be
optimized away in some cases.

Stacks are either free or bound.\label{FREE-STACK}
A bound stack is a substack that is
not deallocated from memory until its smallest containing free stack is
deallocated.  The main reason this is important is that stack addresses
can be passed out of a block with a bound stack to its containing block,
but cannot be passed out of a block with a free stack to its containing
or calling block.  This is implemented by giving certain
variables the \TT{*STACK*} qualifier: see
Section~\itemref{THE-STACK-QUALIFIER}.

Stacks of out-of-line function executions
(\pagref{OUT-OF-LINE-FUNCTIONS}),
out-of-line assignment statement blocks
(\pagref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}),
and
compile-time assignment statement blocks
(\pagref{COMPILE-TIME-ASSIGNMENT-STATEMENTS})
are free, and variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
may \underline{not} have the \TT{*STACK*} qualifier.

Stacks of loop iteration subblocks are free, and
variables in the {\em result-variable-list}
and iteration variables
of a {\em loop-assignment-statement} may not have the \TT{*STACK*}
qualifier.  However, stacks of loop `\TT{initially}' and `\TT{finally}'
subblocks are not free.

Global area stacks (see Section~\itemref{GLOBAL-AREAS}) are free,
but are never deallocated and make no use of the \TT{*STACK*}
qualifier.

All other stacks are bound.  Memory allocated to them
by the `\TT{allocate to stack}' function (\pagref{ALLOCATE-TO-STACK})
is actually
allocated to their smallest containing free stack, and not deallocated
until that free stack is deallocated.

Free stacks are relocatable and can be moved.
Substacks cannot move independently,
but move whenever their smallest containing free stack moves.
Any stack address is relative to its containing free stack,
which is the current free stack at the time executable code uses
the stack address.  To accommodate this builtin memory read-write
functions will not only accept an \TT{adr} value as a RAM address,
but also accept a RAM address consisting of an \TT{unsadr}
offset within the stack and a stack base address that is itself
stored in RAM.  See Sections~\itemref{THE-MEM-QUALIFIER}
and \itemref{STACK-MEMORY-ALLOCATION}
for details.

There are a couple of situations in which free stacks move.

Memory of runtime determined size can be allocated to the end of
a stack by the `\TT{allocate to stack}' and `\TT{allocate to global}'
functions described below, and such may
require that the smallest containing free stack
be moved to a memory region where there is more free memory available.

In a program being debugged, free stacks may be saved after they are no
longer needed by the program, in order to permit them to be analyzed
by a debugger if the program detects an error.  In this situation
free stacks are allocated to a very big circular buffer, and overwritten
after they are no longer needed by the program.  It may happen that
a free stack whose block is still running is in the way of allocating
a new stack to the circular buffer, in which case the still running
block's free stack may be moved.

Lastly, global area stacks (\pagref{GLOBAL-AREAS})
may be deallocated when programs that
can reference them are still running, or may not yet be allocated
when these programs run.  Deallocated global area stacks are treated as if
they were allocated to inaccessible memory, so deallocating these stacks
is like moving them to inaccessible memory, and referencing
them when they are deallocated gives a memory fault.


\subsection{Unwind Blocks}
\label{UNWIND-BLOCKS}

\ikey{Unwind blocks}{unwind block} are executed only when their
containing block terminates:

\begin{indpar}
\emkey{unwind-block}
    ::= \begin{tabular}[t]{l}
	\ttakey{UNWIND}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

Specifically, when an unwind block is encountered while
executing its containing block, the unwind block is marked
as enabled, but is skipped.  Then when the containing block
terminates, all its enabled unwind blocks are executed in
the reverse order of that in which they were enabled.

Unwind blocks are used to close or deallocate things that were opened.
For example, right after a statement that opens a file there may be
an unwind block that closes the file.  This ensures that the file
will be closed even if the block that opened it terminates later
prematurely with an error, such as a memory fault.

\subsection{Throw and Catch}
\label{THROW-AND-CATCH}

\TT{*THROW*} and \TT{*CATCH*} statements are used to implement
exceptions, i.e., abnormal termination.

\begin{indpar}
\emkey{throw-statement} ::= \TT{*THROW*} \\[1ex]
\emkey{catch-statement} ::= \TT{*CATCH*}
\end{indpar}

The \TT{*THROW*} statement causes its containing block to
\ikey{terminate abnormally}{abnormal termination}.
When a block terminates abnormally, its containing
block is also terminated abnormally.

\ikey{Normal termination}{normal termination}
of a block occurs at the end of the block if
the block has not executed a \TT{*THROW*} or an abnormally
terminating subblock.

Any enabled \TT{*UNWIND*} subblocks of an abnormally terminating
block are executed in reverse order, just as they would be if
the block were terminating normally.  No other part of the block
is executed.

If an \TT{*UNWIND*} subblock executing in an abnormally terminating
containing block \TT{B}
executes a \TT{*CATCH*} statement, the termination of this
containing block \TT{B}
is changed from abnormal to normal.  This means
that \TT{B}'s containing block \TT{C} will resume when the now
normally terminating block \TT{B} finishes terminating.
However, \TT{B} will not execute anything but enabled \TT{*UNWIND*}
subblocks, as it is still terminating.

Machine errors, i.e. memory segment faults, invoke callable functions
which can record error information and execute a \TT{*THROW*}.
Similarly detected programming or data errors can record
error information and execute a \TT{*THROW*}.  An \TT{*UNWIND*}
block can look at recorded error information and decide whether
or not to execute a \TT{*CATCH*}.

If a block has result variables it must assign, then these need not be
assigned if the block terminates abnormally, as they will not
be visible to enabled \TT{*UNWIND*} blocks.  However, if a block \TT{B}
that is terminating abnormally executes a \TT{*CATCH*} statement in
one of its \TT{*UNWIND*} subblocks,
all result variables that block \TT{B} must assign must be given values, even
though part of block \TT{B} may not have executed.  The compiler
will check this, and will only permit code that passes straight forward
compiler checks.

There are two ways to ensure correct code.  The first is to 
set all block result variables either in or before the
\TT{*UNWIND*} block that contains the \TT{*CATCH*} statement.
The second is to use the special variable
\ttakey{LAST-ENABLED-UNWIND} inside the \TT{*UNWIND*} block.
This variable is \TT{true} if and only if the \TT{*UNWIND*}
block is the last \TT{*UNWIND*} block enabled in its containing
block, and so if the variable is \TT{true}, any containing
block result variables set after the \TT{*UNWIND*} block need to be
set.  The compiler will accept a statement of the form:
\begin{indpar}\begin{verbatim}
if:
    *LAST-ENABLED-UNWIND*:
        result-variable-1 = ...
        result-variable-2 = ...
	. . . . . . . . . . . .
\end{verbatim}\end{indpar}
where the result variables set are those set after the \TT{*UNWIND*}
block, thus satisfying the requirement that all result variables be set.

[TBD: Maybe default clauses should exist for all block style
assignment statements and execute at the beginning, setting
values for result variables that will be available outside
the block if the block does not set any values itself.]

\subsection{Stack Memory Allocation}
\label{STACK-MEMORY-ALLOCATION}

The `\ttkey{allocate to stack}' function allocates \TT{N} bytes of
memory to the current free stack and returns its offset within
the stack and the address of the stack base address:

\begin{indpar}\tt\begin{tabular}{l}
function *UNCHECKED* *STACK* T result, \\
~~~~~~~~~unsadr result.offset, \\
~~~~~~~~~*MEM* adr result.base, \\
~~~~~~~~~adr result.base.adr = \\
~~~~\ttkey{allocate to stack} ( type T, unsadr N ) \\
~~~~~~~~[| underlying type of T == void |]
\end{tabular}\end{indpar}\label{ALLOCATE-TO-STACK}

Here \TT{result.offset} is the offset of the \TT{N} bytes within the
stack, \TT{result.base} is the base address of the stack, and
stack, \TT{result.base.adr} is the address of where this
base address is stored in RAM.  The first and last of these
are fixed but \TT{result.base} may change when the stack is
moved.

The returned cluster has
the \TT{*STACK*} qualifier (see \itemref{THE-STACK-QUALIFIER}),
so that \TT{result.offset} and \TT{result.base.adr} cannot be
stored in places whose lifetime exceeds that of the current
free stack.

The memory is freed when the free stack to which it is allocated
is freed (\itemref{STACK-MANAGEMENT}).
The memory containing the \TT{base} value may also be
freed at this time. 

The memory allocated is always aligned on an \TT{8} byte boundary.

If you want a different alignment you can use:

\begin{indpar}\tt\begin{tabular}{l}
function *UNCHECKED* *STACK* T result, \\
~~~~~~~~~unsadr result.offset, \\
~~~~~~~~~*MEM* adr result.base, \\
~~~~~~~~~adr result.base.adr = \\
~~~~\ttkey{allocate to stack} \\
~~~~~~~~~~~~( type T, unsadr N, unsadr O, unsadr A ) \\
~~~~~~~~[| underlying type of T == void |]
\end{tabular}\end{indpar}

where \TT{A} must be a power of \TT{2} not greater than \TT{64}.
This will align the \TT{O+1}'st
byte of the allocated memory block
at an address which is a multiple of \TT{A}\,.
Free stacks are always allocated on a \TT{64} byte boundary.

The `\TT{allocate to stack}' inline functions may move stacks.
Therefore it executes a
\begin{center}
\TT{reload *MEM*, *MEM* dependent}
\end{center}
statement.


\subsection{Global Areas}
\label{GLOBAL-AREAS}

A global area is like the stack frame of a function that has no
arguments or return value, except that after this function executes,
the global area remains allocated and its variables can be referenced
by other code.  The syntax is:
\begin{indpar}
\emkey{global-area-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	{\em global-area-option}\STAR{}
	\TT{global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular} \\
\emkey{global-area-option} ::= \ttakey{COMPILE-TIME}
                           $|$ \ttakey{COMPILE-TIME-ONLY}
\end{indpar}

Several such blocks may have the same {\em global-area-name},
as long as no {\em variable-name} appears in more than one of these blocks.

In order to be accessed a global area must be named in an `\TT{extern}'
statement:
\begin{indpar}
\emkey{extern-global-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	\TT{extern} {\em global-area-abbreviation}
	            \TT{is global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em extern-variable-statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{extern-variable-statement} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & {\em variable-abbreviation} \TT{is}
          {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\end{indpar}

A variable with {\em variable-name}
\TT{V} in a global area with {\em global-area-abbreviation}
\TT{A} may be named as \TT{A.V}, or if the variable has its own
{\em variable-abbreviation} \TT{VA},
this by itself (and \underline{not} \TT{A.VA})
may be used to name the variable.  An abbreviation is only effective
withing the scope of the `\TT{extern}' statement that defines it.

A variable in an
{\em extern-variable-statement} must match its corresponding
{\em global-area-block} variable with respect to type and qualifiers
in the same manner as a function prototype argument variable
matches a function call variable.

The {\em global-area-block} containing \TT{A.V} need not be compiled
or loaded before the {\em extern-global-block} referencing
\TT{A.V} is compiled or loaded.  This means a runtime reference
can be made to \TT{A.V} when it does not exist.  Such a reference
will incur a runtime error, typically a segmentation fault.

Memory within a global area can be allocated by:

\begin{indpar}\tt\begin{tabular}{l}
( T result, \\
~~global unsadr result.offset, \\
~~*MEM* adr result.offset.base, \\
~~global adr result.offset.base.adr  ) = \\
~~~~\ttkey{allocate to global} ( type T, unsadr N ) \\
~~~~~~~~[| underlying type of T == void |]
\\[1ex]
( T result, \\
~~global unsadr result.offset, \\
~~*MEM* adr result.offset.base, \\
~~global adr result.offset.base.adr  ) = \\
~~~~\ttkey{allocate to global} \\
~~~~~~~~~~~~( type T, unsadr N, unsadr O, unsadr A ) \\
~~~~~~~~[| underlying type of T == void |]
\end{tabular}\end{indpar}\label{ALLOCATE-TO-GLOBAL}

Here \TT{A} must a power of \TT{2} not greater than \TT{64}.
Global areas are allocated on a \TT{64} byte boundary and
may be moved during execution.

Global area variables \underline{cannot} be written to, but memory allocated
by `\TT{allocate to global}' can be.

The `\TT{allocate to global}' function plays the same role for
global areas as the `\TT{allocate to stack}' function does for
stacks, accept that the address gets the \TT{global} qualifier
instead of the \TT{*STACK*} qualifier.  The \TT{global} qualifier
is a protected, inherited qualifier
with \underline{none} of the special \TT{*STACK*}
qualifier properties, and normally has no effect on code.

The `\TT{allocate to global}' inline functions may move
global areas and therefore executes a
\begin{center}
\TT{reload *MEM*, *MEM* dependent}
\end{center}
statement.

Global areas are run time by default.
The code of a run time
global area block is executed when the file containing it is
loaded, and the stack of the area is allocated and defined when
the global area block is executed.
Global areas may be deallocated or moved during execution.
References to a global area
that is not yet allocated or that has been deallocated cause runtime
errors (typically segmentation faults).

Global areas may also be made compile time, or both compile and run time,
by use of the \TT{*COM\-PILE-\EOL TIME-\EOL ONLY*} or \TT{*COMPILE-\EOL TIME*}
{\em global-\EOL area-\EOL options} above.  For a compile time
global area, global area blocks are executed in the compiler immediately
after the block compiles, and the global area stack exists in the compiler.
If the global area is also run time, its
block code will be re-executed in the run time environment when the
file containing it is loaded, and might produce different stack contents
for the area than the compile time version of the area.

\section{Memory Channels}
\label{MEMORY-CHANNELS}

OLD STUFF: REVISE.

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
structured set of elements each associated with a member of
some data set.  Each window element contains a
\key{block descriptor} that holds the address and length of the
memory block that contains the data associated with the element.
Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
The window has a \key{reference point}, and window elements are addressed
relative to this reference point.  There are shift operations that move
the reference point to a nearby window element.

Although we talk about blocks here, a block can be just a numeric array
element, and can be as small as a single bit.  Although we talk about
each element of a memory channel window having its own block descriptor,
an actual memory channel may use only block group descriptors, each of
which functions as a group of more than one individual element
block descriptor.

A memory channel is stored in a cluster.  As such it is mostly an
inline construction, though it can be passed to or returned from a
function, and the function can be all or partly out-of-line.

The most common type of memory channel has a window that appears to be
an array with \ttikey{.di\-men\-sions}{dimensions!of memory channel},
\ttdmkey{lower\_bound}{of memory channel}\TT{[}$i$\TT{]},
and \ttdmkey{upper\_bound}{of memory channel}\TT{[}$i$\TT{]}
being memory channel members.  Such are called
\key{array windows}.
If the memory channel cluster name is $M$, the window elements are
referred to by $M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]},
with $M$\TT{[0,0,}\ldots\TT{]} being the \key{reference point}.

The reference point can be shifted along any of the window's
dimensions by the command
\begin{center}
$M$\ttdkey{center}\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]}
\end{center}
This shifts
the window so that what was
$M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]} becomes
$M$\TT{[0,0,}\ldots\TT{]}.

Creating memory channels and completely resetting their reference points
are specific to the type of memory channel, and are not covered in
this section.

For most kinds of memory channels, block descriptors are computed
automatically when channel is created, when the window is
shifted, or when the data of
a neighboring window element is arrives from memory.
Immediately after a block descriptor is created, a read-ahead of
the block is initiated.  This read-ahead overlaps computation that
does not use the block contents.

If a memory channel accesses arrays stored in memory,
the channel block descriptors can be computed from the array coordinates
of the reference point.  Other memory channels use the contents
of a block to compute the block descriptors of neighboring blocks
in the window.

An example of the latter is a binary tree memory channel.
Let $M$ be such a channel, and let `\TT{.L}' denote the left
child of a binary tree element, `\TT{.R}' the right child, and
`\TT{.P}' the parent.  Then $M\!$\TT{.L.R} denotes the right
child of the left child of the reference point, $M\!$\TT{.P.L}
denotes the left child of the parent of the reference point,
and $M\!$\TT{.P.L.center} moves the reference point to this last element.
The window of such a memory channel might contain the depth 2
subtree of the reference point plus that closest 4 ancestors of the
reference point if these have been visited.  When the reference
point is moved, as soon as the reference point element has been
read from memory, the descriptors for its children are built and
the read of the children is initiated in parallel with other
computation.  When the children arrive from memory, the descriptors
of their children are built and reads of the data pointed at
are initiated.\footnote{All this can actually be done with modern
hardware: code is executed to read the reference point children and initiate the
reads of their children, and a modern processor will automatically
save the code that
executes when a read of a reference point child completes and execute
other code in parallel until the read does complete.}

Some standard memory channel types are built into the L-Language.
Others can be defined by users.

\section{To Do}

How can dynamically initialized locations be static.

Indirect address protocol.

Define `compile-time function' as a function that can only be
called at compile-time.

Add `\TT{no} {\em prototype-term}' as a way of saying
`{\em prototype-term} \TT{( false )}'.

If \TT{V} is the name of a repeatable variable (that may also
be omittable), then:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt unsadr V.\ttmkey{count}{of {\tt variable name}} } \\
Number of of times the variable name \TT{V} appears in the unfolded
pattern.  This is the number of times the {\em pattern-term} containing
the variable appears.  It is \TT{1} if the term is neither
replicated or omitted, and \TT{0} if it is omitted.

\hspace*{-0.3in}{\tt $T$ V\ttmkey{[$i$]}{of {\tt variable name}} } \\
The value of the $i$+1'st occurrence of \TT{V} in the unfolded pattern.
The index $i$ may be computed at run time, and has the range
\TT{0~..~V.count-1}.
$T$ is the type of the variable given in the {\em pattern-term}.
It is an error to use an index value that is out of range.


\end{indpar}

If \TT{V} is the name of a variable that may be omitted but not
repeated, then:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt bool V.\ttmkey{present}{of {\tt variable name}} } \\
True if the variable is present, and false if not.

\end{indpar}

In addition, if a variable can be omitted but not repeated, a default expression
must be given for the variable in a `\ttkey{defaults to}'
{\em conditioning-expression}.%
\label{DEFAULTS-TO}
If the variable \TT{V} is omitted, this
expression will be used at run time to compute the variable's value,
and `\TT{V.present}' will be set to `\TT{true}'.

\label{INDIRECT-ADDRESS-PROTOCOL}

Threads.
\label{THREADS}

\appendix

\section{Aliasing Hardware}
\label{ALIASING-HARDWARE}

The ultimate solution to the aliasing problem is new hardware.
At its simplest, registers, which currently hold a datum,
are replaced by triples of registers which hold a datum,
an address, and selection codes.  The register datum equals the value
of the memory location at the register address.  The selection
codes determine which part of this memory location is read or written
when the register is read or written.  If any memory location is
changed, the address of the location is checked against all the
register addresses, and if any match, the corresponding register
data are changed.

This is, however, not sufficient, because sometimes one register
address is a function of another register's datum.  For example,
consider the unchecked code:
\begin{indpar}[0.5em]\begin{verbatim}
struct S { ...; int32 m; ... }
S * * x
S * *& y = * x
int32 *& z = y->m
\end{verbatim}\end{indpar}
If we consider \TT{x}, \TT{y}, and \TT{z} to be registers,
the address of \TT{y} equals the value of \TT{x}, and the
address of \TT{z} equals the value of \TT{y} plus the offset of
\TT{m} in \TT{S}.

If the value of \TT{x} changes, this changes the address of \TT{y},
which may change the datum of \TT{y} and that may change the value
of \TT{y}.  If the value of \TT{y} changes, this changes the address
of \TT{z}, which may change the datum and value of \TT{z}.

The way we accommodate this is to use the selection codes of \TT{y}
to specify that the address of \TT{y} contains the value of \TT{x}
as an additive component, so
that if the value of \TT{x} is changed by adding $\Delta$\TT{x}
then the address of \TT{y} should be changed by adding $\Delta$\TT{x}.
And similarly the selection codes
of \TT{z} specify that the address of \TT{z}
contains the value of \TT{y} as an additive component.

So why should we bother with automatically updating
additive inclusions of one value in the
address of another value, and not bother with other expressions.
The reason is that expressions such as
`\TT{(*x)->m}' are likely to be reused frequently in code (actually,
in automatically generated code) and
therefore need to be cached, whereas an expressions of the form
`\TT{c*d}' will be reused comparatively rarely code
and therefore are not worth special hardware.


\bibliographystyle{plain}
\bibliography{layered-l-2012-language}

\printindex

\end{document}

