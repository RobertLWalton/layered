% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\LSTAR}{L$^\star$}
\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttakey}[1]{\TT{*#1*}\index{#1@{\tt *#1*}}}
\newcommand{\ttalkey}[2]{\TT{*#1* *#2*}\index{#1 #2@{\tt *#1* *#2*}}}
\newcommand{\ttamkey}[2]{\TT{*#1*}\index{#1@{\tt *#1*}!#2}}
\newcommand{\ttstdkey}[1]{\TT{std #1}\index{#1@{\tt std #1}}}
\newcommand{\ttstdakey}[1]{\TT{std *#1*}\index{#1@{\tt std *#1*}}}
\newcommand{\ttstdlkey}[2]{\TT{std #1 #2}\index{#1@{\tt std #1}!#2@{\tt #2}}}
\newcommand{\ttstdmkey}[2]{\TT{std #1}\index{#1@{\tt std #1}!#2}}
\newcommand{\ttstdindex}[1]{\index{#1@{\tt std #1}}}
\newcommand{\ttstdlindex}[2]{\index{#1@{\tt std #1}!#2@{\tt #2}}}
\newcommand{\ttstdmindex}[2]{\index{#1@{\tt std #1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{\,\textsuperscript{p\pageref{#1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\TS}{\hspace*{0in}\tt}

\newcommand{\TMP}{\$}			% Compiler Temporary
\newcommand{\ABV}{-{}-{}->}		% Abbreviates
\newcommand{\CNV}{\longrightarrow}	% Converts to

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

January 14, 2019
 
\end{center}

{\small \tableofcontents}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language, which is similar to the C programming language
but differs in the following ways:

\begin{enumerate}

\item
L-Language facilitates isolating non-type-safe code into small inline functions.

\item
All L-Language data types are builtin number types or subtypes of
builtin number types.  All data managed directly by L-Language consists
of single numbers allocated to the stack.

\item
Memory references other than those to single stack allocated numbers
are handled by code
encapsulated in small inline functions written by the programmer.
These memory references
are treated in a manner reminiscent of input/output.
The bodies of these inline functions are not type-safe, but if
there are written correctly, usage of these functions is type-safe.

\item
There is no concept of a memory structure in the L-Language.  There
is a new concept, the `cluster', which is a collection of stack
variables that can be passed to inline functions
and returned from inline functions as a syntactic unit.

\item
The type `\TT{type}' is first class, is a subtype of integers, and
each `\TT{type}' value is assigned
a unique constant small integer value.  Constant
argument values, such as the value of a `\TT{type}' valued
argument, can be used to select overloaded functions.

\item
Most L-Language functions are inline.  Out-of-line functions can be
called using a block syntax that mirrors the overhead involved in
manipulating an argument stack in memory.

\item
L-Language uses a single-assignment style of program structure
to encourage
efficient code that leaves an audit trail for debugging in the stack.
Partial evaluation of expressions and inline code is supported without
compromising debuggability.

\item
L-Language allows code to be compiled at run-time just before
it is run, for extra efficiency.

\item
L-Language allows code to be compiled into the compiler, to support
language enhancements.

\item
L-Language has module structure to manage
multi-file source code in a well-ordered and type-safe manner.


\end{enumerate}


\section{Lexemes}
\label{LEXEMES}

An L-Language source file is a sequence of bytes that is a UTF-8 encoding
of a sequence of UNICODE characters.  This is scanned into a sequence
of \skey{lexeme}s.

Unless otherwise specified, the term `\key{character}' in this
document means a 32-bit UNICODE character.

Lexemes are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes ASCII single space) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} :::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::=
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe}, \\
    and \TT{Pf}; includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{decimal-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em decimal-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment}\label{COMMENT} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

The following is a special virtual lexeme:
\begin{indpar}
\emkey{indent}\label{INDENT} ::=
        virtual lexeme inserted just before the first
	{\em graphic} character on a line
\end{indpar}

\ikey{Indent lexemes}{indent lexeme} have no characters, but
do have an \mkey{indent}{of indent lexeme}, which is the indent of
the graphic character after the indent lexeme.
The \mkey{indent}{of character} of a character is the number
of columns that precede the character in the character's physical line.
Indent lexemes are used to form logical lines and blocks
(\itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break}\label{LINE-BREAK} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::=
    \begin{tabular}[t]{l}
    {\em horizontal-space-character}, other than \\
    ASCII single space
    \end{tabular}
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= {\em vertical-space-character}
	other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::=
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} \\
    or {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::=
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these sequences generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

\begin{boxedfigure}[!p]
\begin{indpar}

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em word} $|$ {\em mark} $|$ {\em number} $|$
	      {\em separator} $|$ {\em quoted-string} $|$ {\em indent} \\
	$|$ & {\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}\label{CHARACTER-REPRESENTATIVE}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em ASCII-single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{number} \begin{tabular}[t]{rl}
    ::= & {\em middle-lexeme} with a {\em digit} before any {\em letter} \\
    $|$ & {\em middle-lexeme} with a {\em digit} immediately after
                               a `\TT{+}' or `\TT{-}' \\
	\end{tabular}
\\[0.5ex]
\emkey{natural-number}\label{NATURAL-NUMBER}
	:::= {\em decimal-digit}\PLUS{} not beginning with \TT{0} $|$ \TT{0}
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme} containing a {\em letter} that is not
                  a {\em number}
\\[0.5ex]
\emkey{mark} :::= {\em middle-lexeme} that is not a {\em word} or
		  {\em number}
\\[0.5ex]
{\em indent} ::= see \pagref{INDENT}
\\[0.5ex]
{\em line-break} ::= see \pagref{LINE-BREAK}
\\[0.5ex]
{\em comment} ::= see \pagref{COMMENT}
\\[0.5ex]
{\em end-of-file} ::= see \pagref{END-OF-FILE}

\end{indpar}
\caption{L-Language Program Lexemes}
\label{L-LANGUAGE-PROGRAM-LEXEMES}
\end{boxedfigure}

The lexemes in a L-Language program are specified in
Figure~\itemref{L-LANGUAGE-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see page \pageref{ILLEGAL-CHARACTERS}
above to account for such characters.

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file}\label{END-OF-FILE}
lexeme that occurs only at the end of a file.

Files are scanned into sequences of lexemes which are then divided
into logical lines as per \itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}.
After each logical line is formed,
{\em indent}, {\em comment},
{\em line-break}, and {\em end-of-file} lexemes are deleted
from the logical line.

\ikey{Quoted string lexemes}{quoted strings!concatenated}
separated by the `\TT{\#}' mark
are glued together if they are in the
same logical line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence" #
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

A \emkey{special-character-representative} can consist of
a UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.

A {\em special-character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.

\section{Logical Lines, Blocks, and Statements}
\label{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}

Each non-blank physical line begins with an {\em indent} lexeme
that is followed by a
lexeme that is not an {\em indent}, {\em line-break}, or
{\em end-of-file}.

Lexemes are organized into \skey{logical line}s.  A logical line
begins immediately after an {\em indent} lexeme, and the
\mkey{indent}{of logical line} of the logical line is the
indent of this {\em indent} lexeme (i.e., the indent of the
first graphic character of the logical line).

A logical line ends with the next {\em indent} lexeme whose indent
is not greater than the indent of the logical line, or with an
{\em end-of-file}.  Thus physical
lines with indent greater than that of the current logical line
are \skey{continuation line}s for that logical line.

A code file is a sequence of `\key{top level}' logical lines that
are required to have indent \TT{0}.

A logical line may end with a \key{block} that is itself a sequence of
logical lines that have indents greater than the indent of the
logical line containing the block.
The block is introduced by a `\TT{:}' at the end
of a physical line.  If the first {\em indent} lexeme after the
`\TT{:}' has an indent that is \underline{not} greater than the indent
of the logical line containing the `\TT{:}', the block is empty.
Otherwise the indent of this {\em indent} lexeme becomes the
\mkey{indent}{of block} of the block and the indent of all the
logical lines in the block.  The first logical line of the block
starts immediately after this {\em indent} lexeme.
The block ends just before the first
logical line with lesser indent than the block indent, or the end of file.
More specifically, the last logical line of the block ends with an
{\em indent} whose indent is less than the block indent, or with an
{\em end-of-file}.

Examples are:
\begin{indpar}\begin{verbatim}
this is a top level logical line ending with a block:
    this is the first line of the block
    this is the
         second line of the block
    this is the third line of the block:
        this is the first line of a subblock
        this is the second line
                of the subblock:
            this is the only line of a sub-subblock
        this is the third line of the subblock
    this is the fourth line
            of the block:
        this is the only line of the second subblock
    this is the fifth line of the block
         and it ends with an empty subblock:
this is the second top level
     logical line
\end{verbatim}\end{indpar}

A warning message is output if two indents that are being compared
differ by more than \TT{0} and
less than \TT{2} columns, in order to better detect
indentation mistakes.

{\em Line-break} lexemes are effectively ignored.  A sequence
of {\em line-break} lexemes is followed by an {\em indent}
or {\em end-of-file} which is not ignored.
Blank physical lines are represented by sequences of
more than one {\em line-break} lexeme, and are effectively
ignored.

A logical line that contains {\em comments}, but no
lexemes other than {\em comments}, {\em line-breaks}, {\em indents}
and a possible {\em end-of-file}, is
a `\key{comment line}', and is ignored.

It is an error to begin non-comment logical lines with
a {\em comment}.
{\em Comments} can be used freely in the middle of or at the
end of any logical line, or at the beginning of a comment line.

It is an error for the first logical line of a file
to have an indent that is greater than \TT{0}, the top level
indent.

It is an error for a block to be in the middle of a logical
line.  This means that the first {\em indent} following the
block must have an indent no greater than that of the logical
line containing the block.

Examples are:
\begin{indpar}\begin{verbatim}
// this is a logical line that is a single comment

// this is a logical line that has two
    // comments

this is a logical line // with a comment
     // and another comment
     with three comments // and a last comment

this is a logical line ending with a block:
     First line of the block
     Second line of the block
// Comment that ends block
// Comment that is in error because
    it begins a logical line that this continues

this is a logical line with a block:
     First line of the block
     Second line of the block
  but the block is in error because it is before
  this continuation of the logical line that contains
  the block

this is a logical line ending with a block:
        First line of the block
        Second line of the block
  // comments that end the block, but are in error,
  // because they continue the logical line
  // containing the block
\end{verbatim}\end{indpar}

After a logical line
has been formed, any {\em indent},
{\em comment}, {\em line-break}, and {\em end-of-file}
lexemes in the logical line
are removed from the logical line.  If the result is
empty, i.e., the logical line is a comment line, it is discarded.
Otherwise the
modified logical line becomes a L-Language `\emkey{statement}'.

Therefore a file is a sequence of top-level statements.

Since a logical line can end with a block that itself consists
of a sequence of logical lines, a statement can end with
a block that itself consists of a sequence of statements.


\section{Names}
\label{NAMES}

A \key{name} is a sequence of lexemes used to name things like
variables and functions.

\begin{indpar}
\emkey{name}\label{NAME} ::=
    {\em initial-name-item} {\em continuing-name-item}\STAR{} \\
\emkey{initial-name-item} ::= {\em name-item} other than {\em natural-number} \\
\emkey{continuing-name-item} ::= {\em name-item} not containing `\TT{.}' \\
\emkey{name-item}\label{NAME-ITEM}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} containing no `\TT{.}' following a character
                     that is not a `\TT{.}' \\
        & [see text about splitting words with embedded `\TT{.}'s] \\
    $|$ & {\em natural-number} \\
    $|$ & {\em quoted-mark} not containing `\TT{.}'s \\
    $|$ & {\em quoted-separator} not containing `\TT{.}'s \\
    \end{tabular} \\
\emkey{quoted-mark} :::= \TT{"} {\em mark} \TT{"} \\
\emkey{quoted-separator} :::= \TT{"} {\em separator} \TT{"}
\end{indpar}

{\em Words} containing embedded `\TT{.}'s are split into
{\em name-items} which can only contain `\TT{.}'s at their beginning.
Thus
\begin{center}
\TT{bills.wife.1.weight..size}
\end{center}
is split into
\begin{center}
\TT{bills~~~.wife~~~.1~~~.weight~~~~..size}
\end{center}
However, `\TT{.1}' is not a legal {\em name-item} and so cannot
be part of a legal {\em name}.

Name items beginning with more than one `\TT{.}' are reserved
for use by systems and compilers (e.g., \TT{..size} in the example).
Name items beginning and ending with `\TT{*}' are
similarly reserved.

Words ending with `\TT{\TMP$n$}', where $n$ is a {\em natural-number}, are
reserved for use by the compiler and may not be used in names by the
L-Language user.  For example, names of the form \TT{T\TMP$n$} are used as
temporary variables introduced during compilation.

Names can be computed at compile time:
see~\itemref{THE-NAME-TYPE}.
One name can be used to abbreviate another:
see~\itemref{ABBREVIATIONS}.
A name may begin with a {\em word} that is a {\em module-abbreviation}
that designates a code module: see~\itemref{MODULES}.

The builtin names in this document are implicitly in the
\TT{"standard"} module whose {\em module-abbreviation} is `\TT{std}'.
See the section on modules (\itemref{MODULES}) for details.
For example the name `\TT{bool}' of the boolean data type is actually a builtin
abbreviation defined by:
\begin{center}
\TT{define abbreviation bool {\ABV} `std bool'}
\end{center}
and the builtin type name proper is `\TT{std bool}' and not `\TT{bool}'.


Similarly the  builtin function such as \TT{round} as used in:
\begin{center} \tt
\begin{tabular}{l}
float$x$ v = \ldots{} \\
float$x$ r = round ( v ) \\
\end{tabular}
\end{center}
actually has the function prototype (\pagref{FUNCTION-PROTOTYPE}):
\begin{center}
{\tt function std float$x$ r = std round ( std float$x$ v )} \\
\end{center}
so its proper name is `\TT{std round}' and not `\TT{round}',
but in this case it is not necessary (or desirable) to make `\TT{round}'
an abbreviation because its module can be implied in a function call
(see `module deficient' on \pagref{MODULE-DEFICIENT}).

\subsection{Kinds of Names}
\label{KINDS-OF-NAMES}

The L-Language uses several kinds of names:

\begin{indpar}
\emkey{module-abbreviation}
	::= \TT{word} not containing any `\TT{.}'s \\
\emkey{type-name}\label{TYPE-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{qualifier-name}\label{QUALIFIER-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{variable-base-name}\label{VARIABLE-BASE-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{variable-name}\label{VARIABLE-NAME}
	::= {\em variable-base-name} {\em member-selector}\STAR{} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript } \\
\emkey{member-name}\label{MEMBER-NAME}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark}
			    or {\em quoted-separator}
			\end{tabular} \\
\emkey{member-subscript} ::= see \pagref{MEMBER-SUBSCRIPT} \\
\emkey{term-name} ::= {\em name} \\
\emkey{function-variable-name} ::=
    \begin{tabular}[t]{@{}p{4in}@{}}
    {\em term-name} $N$ that appears in a {\em function-prototype}
    of the form `{\tt function $N$ = \ldots};
    see \pagref{FUNCTION-VARIABLE-NAME}
    \end{tabular} \\
\emkey{block-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{include-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator}

where
\begin{enumerate}
\item
A {\em qualifier-name} must not be an initial segment
of a {\em type-name}.  See text below.
\item
A {\em qualifier-name} or {\em type-name} must not be an initial segment
of a {\em name} $N$ that might begin a {\em statement} of
the form `{\tt $N$ = \ldots}'.  Examples of such names $N$
are {\em deferred-variables} (\pagref{DEFERRED-VARIABLE})
and {\em function-variable-names} (\pagref{FUNCTION-VARIABLE-NAME}).
See text below.
\label{TYPE-NAME-RULE}
\item
A {\em type-name}, {\em qualifier-name}, {\em variable-base-name},
{\em block-name}, or {\em include-name}
may not begin with the word `\TT{next}' or `\TT{previous}' or
contain the words `\TT{is}', `\TT{as}', `\TT{with}', `\TT{without},
or `\TT{if}'.
\item
{\em Name-items} ending with `\TT{\TMP$n$}',
where $n$ is a {\em natural-number}, are
reserved for use by the compiler.
\item
{\em Name-items} beginning with `\TT{..}' (possibly followed by more
`\TT{.}'s) are reserved
for use by systems and compilers (e.g., `\TT{..size}').
\item
{\em Name-items} beginning \underline{and} ending
with `\TT{*}' are reserved
for use by systems and compilers (e.g., \TT{*UNCHECKED*}).
\end{enumerate}
\end{indpar}

The first two rules are not enforced as such.  Instead the parser
parses statements into abstract syntax trees that contain
sequences of names, without separating the names in each sequence.
Then as a first step in compilation after parsing,
any name sequence that might be of the form
\begin{center}
{\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
\end{center}
is scanned left to right to first remove any {\em qualifier-names}
and then a {\em type-name}, leaving a non-empty {\em variable-name}.
At any point, if several suitable {\em qualifier-names} or
{\em type-names} match the
beginning of the remaining part of the name sequence, the longest
is chosen.  If this process succeeds without backup, the name
sequence is of the above form.  Otherwise it is not -- there is
no backup.  If the process does not succeed, in some
cases the name sequence may still be a single {\em variable-name}
by itself, and in other cases it might be a sequence of one or
more {\em term-names}.
Also the {\em qualifier-name} and {\em type-name}
candidates are those of the current scope (\pagref{SCOPE}).

Name sequences that might be of the above form can only occur at
the beginning of a statement or as a {\em result-variable-declaration}
(\pagref{RESULT-VARIABLE-DECLARATION})
or an {\em argument-declaration} in a {\em function-prototype}
or {\em generic-prototype}
(\pagref{ARGUMENT-DECLARATION}).

In addition, non-empty name sequences
may appear in abstract tree subexpressions of the form
\begin{center}
{\em qualifier-name}\STAR{} {\em type-name}\QMARK{} {\tt (~\ldots{}~)}
\end{center}
and are treated similarly.


\subsection{Abbreviations}
\label{ABBREVIATIONS}


An \key{abbreviation} is a {\em name} that is replaced
by another {\em name}.  There are separate abbreviations for
{\em qualifier-names}, {\em type-names}, {\em variable-base-names},
and {\em member-names}.

Abbreviations are declared by:
\begin{indpar}
\emkey{abbreviation-declaration}\label{ABBREVIATION-DECLARATION} \\
\hspace*{0.5in}\begin{tabular}{@{}rl@{}}
    ::= & \ttkey{define abbreviation}\TT{~}{\em abbreviation}\TT{~}%
          \ttkey{\ABV}\TT{~}{\em abbreviation-replacement} \\
    $|$ & \TT{define abbreviations:} \\
        & {\TS ~~~~}{\em abbreviation}\TT{ \ABV{} }
		  {\em abbreviation-replacement} \\
        & {\TS ~~~~}{\em abbreviation}\TT{ \ABV{} }
		  {\em abbreviation-replacement} \\
        & {\TS ~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
    \end{tabular}
\\[1ex]
\emkey{abbreviation} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\\[1ex]
\emkey{abbreviation-replacement} ::= \\
\hspace*{0.5in}
    {\em expression} that evaluates at compile time to a \TT{name};
    see \itemref{THE-NAME-TYPE}
\end{indpar}

The most common {\em abbreviation-replacement} is a {\em name-constant}:

\begin{indpar}
\emkey{name-constant}
    ::= \TT{`}{\em name-item}\STAR{}\TT{'} \\
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

The only {\em names}
that can be abbreviated are {\em qualifier-names},
{\em type-names}, {\em variable-base-names}, and
{\em member-names}.

If the replacement name of an {\em abbreviation} is a {\em qualifier-name}
in the context of the {\em abbreviation-declaration},
the {\em abbreviation} becomes a {\em qualifier-name}, and
must have they syntax of a {\em qualifier-name}.
Similarly, if the replacement name of an {\em abbreviation} is a {\em type-name}
in the context of the {\em abbreviation-declaration},
the {\em abbreviation} becomes a {\em type-name}, and
must have they syntax of a {\em type-name}.
In other cases, the {\em abbreviation} must have the syntax of
a {\em variable-base-name} if its replacement does, and the syntax of
a {\em member-name} if its replacement does.

The rules in \itemref{KINDS-OF-NAMES}
apply to {\em abbreviations}.  For example, the rule regarding
{\em type-names} applies to {\em abbreviations}
of {\em type-names}.

Abbreviation replacement occurs after
{\em qualifier-names},
{\em type-names}, {\em variable-base-names}, and
{\em member-names} have been identified by the compiler.

Abbreviations are internal and never external (\pagref{EXTERNAL}),%
\label{ABBREVIATIONS-ARE-INTERNAL}
even if they begin with a {\em module-abbreviation}.
They do have scope (\pagref{SCOPE}) like other declarations, but their scope
is limited to the extended module (\pagref{EXTENDED-MODULE}) in
which they are declared.

Some examples are:
\begin{indpar}\begin{verbatim}
define abbreviations:
    int32 ---> `std int32'
    uns64 ---> `std uns64'
        // Builtin type abbreviations
    *UNCHECKED*  ---> `std *UNCHECKED*'
        // Builtin qualifier abbreviation

*UNCHECKED* int32 x 1 = 99
    // Same as: std *UNCHECKED* std int32 x 1 = 99
define abbreviations:
    .foo ---> `fee'
        // Illegal: `fee' does not begin with `.'.
    "+" ---> `std int64'
        // Illegal: `"+"' is not allowed as a type-name
        // (or a qualifier name, variable-base-name, or
        // member-name).

define abbreviation int64 unsigned ---> `uns64'
int64 unsigned z = 9 + 7
    // Legal, same as: std uns64 z = (9) "+" (7)
    // Matches builtin function prototype:
    //   function std uns64 r =
    //       std (std uns64 v1) "+" (std uns64 v2)
    // unless another function with prototype:
    //   function std uns64 r =
    //       (std uns64 v1) "+" (std uns64 v2)
    // is defined.

define abbreviations:
    x 1 ---> `x'
    .foo ---> `.fee'
int64 y = x 1 .foo + 10
    // Same as: std int64 y = (x.fee) "+" (10)
\end{verbatim}\end{indpar}

Abbreviation is recursive: an {\em abbreviation-replacement} can
itself be an abbreviation.
Abbreviation loops are possible and result in compile errors when
the abbreviation is used.
For example:
\begin{indpar}\begin{verbatim}
    define abbreviation X ---> `Y'
    int64 X = 5       // Same as: std int64 Y = 5
    define abbreviation Y ---> `Z'
    int64 X = 5       // Same as: std int64 Z = 5
    define abbreviation Z ---> `X'
    int64 X = 5       // Compile error replacing X.
\end{verbatim}\end{indpar}


\section{Program Organization}
\label{PROGRAM-ORGANIZATION}

Code is organized into two kinds of files: \skey{module}s
and \ikey{bodies}{body}.
Each body is associated
with a particular module, the `\key{module of the body}',
and extends that module.  A module
may have zero or more bodies.
A module and all its bodies together form
an `\key{extended module}'\label{EXTENDED-MODULE}.

Modules and bodies consist of a sequence
of \skey{declaration}s:
\begin{indpar}
\emkey{declaration}
    \begin{tabular}[t]{rll}
    ::= & {\em module-declaration}
        & [see \pagref{MODULE-DECLARATION}] \\
    $|$ & {\em body-declaration}
        & [see \pagref{BODY-DECLARATION}] \\
    $|$ & {\em defined-type-declaration}
        & [see \pagref{DEFINED-TYPE-DECLARATION}] \\
    $|$ & {\em type-name-declaration}
        & [see \pagref{TYPE-NAME-DECLARATION}] \\
    $|$ & {\em enum-type-declaration}
        & [see \pagref{ENUM-TYPE-DECLARATION}] \\
    $|$ & {\em qualifier-declaration }
        & [see \pagref{QUALIFIER-DECLARATION}] \\
    $|$ & {\em function-type-declaration }
        & [see \pagref{FUNCTION-TYPE-DECLARATION}] \\
    $|$ & {\em out-of-line-function-declaration }
        & [see \pagref{OUT-OF-LINE-FUNCTION-DECLARATION}] \\
    $|$ & {\em function-declaration }
        & [see \pagref{FUNCTION-DECLARATION}] \\
    $|$ & {\em generic-declaration }
        & [see \pagref{GENERIC-DECLARATION}] \\
    $|$ & {\em abbreviation-declaration }
        & [see \pagref{ABBREVIATION-DECLARATION}] \\
    $|$ & {\em assignment-statement }
        & [see \pagref{ASSIGNMENT-STATEMENTS}] \\
    \end{tabular}
\end{indpar}

Declarations declare {\em names}, {\em function-prototypes},
and {\em generic-prototypes}.
An {\em assignment-state\-ment} may also be a {\em declaration} of
its result {\em variable-names}.

{\em Names} shared between modules begin with {\em module-abbreviations}
that designate the module in which the name is declared.
Such names are called `\key{external}'.\label{EXTERNAL}
Similarly the pattern of a {\em function-prototype}
(\pagref{FUNCTION-PROTOTYPE})
or {\em generic-prototype}
(\pagref{GENERIC-PROTOTYPE})
may begin with the {\em module-abbreviation} of the module in
which the prototype is declared,
and such prototypes are `\key{external}'.

External names and prototypes can only be declared in modules, and
never in bodies.  External names and prototypes cannot be declared inside
statement blocks, but must be declared at `top level' outside
blocks.

As an exception, abbreviations are internal, and never external, even if
they begin with a {\em module-abbreviation}
(\pagref{ABBREVIATIONS-ARE-INTERNAL}).

In {\em function-calls} and {\em generic-calls} the
{\em module-abbreviation} may be omitted
if the {\em function-proto\-type} or {\em generic-prototype} matching the call
can be unambiguously determined: see
`module deficient' on \pagref{MODULE-DEFICIENT}.
This may \underline{not} be done
for names (e.g., external types, external variables).

An example is:
\begin{indpar}\begin{verbatim}
module "lib/math" as math

define type math complex as void
    // Given `math complex x', x[0] is the real part of a
    // complex number and x[1] is the imaginary part.

function math complex r, float64 r[0], float64 r[1] =
    math complex ( float64 real, float64 imaginary ):
    r[0] = real
    r[1] = imaginary

function math complex r, float64 r[0], float64 r[1] =
    math ( math complex a1, float64 a1[0], float64 a1[1] )
    "+"  ( math complex a2, float64 a2[0], float64 a2[1] ):
    r[0] = a1[0] + a2[0]
    r[1] = a1[1] + a2[1]

---------------------------------------------
module "my-module" as mine
    import "lib/math" as math

.............................
math complex x = math complex ( 1, 0 )
math complex y = complex ( 0, 1 )
    // The second `complex' in each line is a function name
    // so `math' may be omitted.  In this case the function
    // prototype that applies is selected by the y result
    // variable type.
math complex z1 = x + y
    // Parses to `math complex z1 = ( (x) "+" (y) )'.
    // Standard "+" does not apply because it does not match
    // result type.  `math' module abbreviation is implied so
    // that `math' module "+" applies.
math complex z2 = math ( x + y )
    // Parses to `math complex z2 = ( math (x) "+" (y) )'.
    // `math' module abbreviation for "+" is explicit and
    // NOT implied.
\end{verbatim}\end{indpar}

\subsection{Modules}
\label{MODULES}

A \key{module} is a file that begins with a {\em module-declaration}:

\begin{indpar}
\emkey{module-declaration}\label{MODULE-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= & {\em simple-module-declaration} \\
    $|$ & {\em simple-module-declaration}\TT{:} \\
	& \TT{~~~~}{\em module-clause}\STAR{} \\
    \end{tabular} \\
\emkey{simple-module-declaration} ::= \TT{module} {\em module-name}
        \TT{as} {\em module-abbreviation} \\
\emkey{module-name} ::= {\em quoted-string} \\
\emkey{module-abbreviation}\label{MODULE-ABBREVIATION}
	::= \TT{word} not containing any `\TT{.}'s \\
\emkey{module-clause}\label{MODULE-CLAUSE} ::=
    {\em import-clause} $|$ {\em parser-block} \\
\emkey{import-clause}\label{IMPORT-CLAUSE}
    ::= \TT{import} {\em module-name} \TT{as} {\em module-abbreviation} \\
\emkey{parser-block}\label{PARSER-BLOCK} ::=
    \begin{tabular}[t]{@{}l}
    \TT{external}\QMARK{} \TT{parsing:} \\
    \TT{~~~~}{\em parser-instruction}\STAR{} \\
    \end{tabular} \\
{\em parser-instruction} ::= see \pagref{PARSER-INSTRUCTION}

\begin{itemize}

\item
A {\em module-declaration} may only appear at the very beginning
of a module file.

\item
In a {\em module-declaration} all {\em module-abbreviations} must be
distinct, and all {\em module-names} must be distinct.

\item
There may be at most one {\em parser-block} in a {\em module-declaration}.
\end{itemize}
\end{indpar}

A {\em module-name} is a POSIX file name.
The {\em module-name} of a {\em module-declaration} must match the
name of the file containing the
{\em module-declaration}, relative to one of several directories
specified separately to the compiler.

The {\em module-abbreviation} associated with a {\em module-name}
may differ in different files.  Specifically, the {\em module-abbreviation}
for a module used in the module's own module file need not be the same
as the {\em module-abbreviations} used for the module in files
that import the module.

The conceptual directed graph whose nodes are modules and whose
arrows connect each module to the modules it or its bodies import is called
the `\key{module graph}'.\label{MODULE-GRAPH}
This graph \underline{must be acyclic}.

The module \TT{"standard"}\index{standard@\TT{"standard"}} with
module abbreviation \ttkey{std} is builtin and contains the builtin types and
functions.  The {\em import-clause}
\begin{center}
{\tt import }\TT{"standard"}\ttindex{standard@\TT{"standard"}}{\tt{}
    as \ttkey{std}}
\end{center}
is implied in every {\em module-declaration} and
{\em body-declaration} (see \itemref{BODIES}).

When a type is declared, functions with arguments or result
values of that type are automatically declared.  For example,
the declaration
\begin{center}
{\tt define type $T1$ as $T2$}
\end{center}
automatically declares
\begin{center}
\begin{tabular}{l}
{\tt function bool r = ( $T1$ x ) "==" ( $T1$ y ):} \\
{\tt ~~~~r = ( $T2$ ( x ) ) "==" ( $T2$  ( y ) )}
\end{tabular}
\end{center}

If the declared type begins with module abbreviation $ma$, the function
will also be given this module abbreviation.  Thus if $T1$ begins with
$ma$, the function will be
\begin{center}
\begin{tabular}{l}
{\tt function bool r = $ma$ ( $T1$ x ) "==" ( $T1$ y ):} \\
{\tt ~~~~r = ( $T2$ ( x ) ) "==" ( $T2$  ( y ) )}
\end{tabular}
\end{center}


\subsection{Scope}
\label{SCOPE}

A {\em declaration} has a \key{scope},
that is the set of statements in which any
names or prototypes defined by the {\em declaration}
are recognized.  The scope of a {\em declaration}
begins just after the {\em declaration}
itself, and
lasts to the end of smallest block containing the {\em declaration},
or until the end of the file containing the {\em declaration} if
the {\em declaration} is not inside any block.
If the {\em declaration} is at top level in a module, the scope of the
{\em declaration} is extended to include all the bodies of that
module.
If the {\em declaration} is external, the scope of the
{\em declaration} is extended to include all modules and
bodies that import the module containing the {\em declaration}.

Some statement subblocks are not considered to be blocks for
the purposes of defining scope.  These include subblocks inside
{\em abbreviation-declarations} (\pagref{ABBREVIATION-DECLARATION}),
{\em type-declarations} (\pagref{TYPE-DECLARATION}),
and {\em in\-clude-statements} (\pagref{INCLUDE-STATEMENT}).
These subblocks are considered to be syntactic sugar for
sequences of statements that do not contain the subblocks.

The scope of a {\em name}, {\em function-prototype}, or
{\em generic-prototype}
is the scope of the declaration that defines it.

The scope of a {\em block-name} is the block it names
(see \itemref{BLOCK-ASSIGNMENT-STATEMENTS}).

The \key{context}\label{CONTEXT} of a statement is the set of declarations
whose scope the statement is in.

When a {\em function-call} to an inline function
or a {\em generic-call} to a generic is compiled,
the context of the compilation is \underline{not} the current context but
rather the context of the inline function or generic
declaration.
Also the context in which any {\em default-value} expression
provided by a declaration
is compiled is the \underline{not} the current context but
rather the context of that declaration.

Code included by a generic
(\itemref{GENERICS}), however, \underline{is} compiled in the current context.

If two different declarations of the same {\em name} have overlapping
scope, one of these scopes must include the other,
and the declaration with the smaller scope is said to 
`\mkey{hide}{declaration}'\label{HIDE} the other declaration.
Such hiding is a compiler error unless the smaller scope
is within one of the following kinds of statements, and
the larger scope includes the whole statement:
\begin{center}
\begin{tabular}{ll}
{\em function-type-declaration}
    & [see \pagref{FUNCTION-TYPE-DECLARATION}] \\
{\em out-of-line-function-assignment}
    & [see \pagref{OUT-OF-LINE-FUNCTION-ASSIGNMENT}] \\
{\em out-of-line-function-declaration}
    & [see \pagref{OUT-OF-LINE-FUNCTION-DECLARATION}] \\
{\em function-declaration}
    & [see \pagref{FUNCTION-DECLARATION}] \\
{\em generic-declaration}
    & [see \pagref{GENERIC-DECLARATION}] \\
{\em block-assignment-statement} with context option
    & [see \pagref{BLOCK-ASSIGNMENT-STATEMENTS}] \\
{\em compile-and-run-assignment-statement} with context option
    & [see \pagref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}] \\
\end{tabular}\label{HIDING-EXCEPTIONS}
\end{center}

As an exception to the last rule, the declaration with the
smaller scope may be an assignment statement declaring
a variable name `\TT{next} {\tt v}' when the declaration
with the larger scope is an assignment statement
declaring `{\tt v}', and the two declarations have the
same smallest containing block.
Within the smaller scope `{\tt v}' refers to the
`\TT{next} {\tt v}' declaration: see \pagref{NEXT}.

By the last rule,
`\TT{next} {\tt v}' cannot be declared in a block $B$ if `{\tt v}' was
declared outside $B$ and $B$ is completely within
the scope of `{\tt v}', so the smallest containing block of
`{\tt v}' is not the same as the smallest containing block of
`\TT{next} {\tt v}'.

Prototypes cannot hide each other.  If the
current scope contains two declarations whose prototypes
both match a {\em function-call} or {\em generic-call},
the call is ambiguous and
in error, even if the scope of one declaration is within
a subblock of the scope of the other.
As a consequence, it may be unwise to place {\em function-declarations}
or {\em generic-declarations}
within assignment statements that have the context option.

A call that is a statement by itself
is matched against both {\em generic-prototypes}
and {\em function-proto\-types}, and will be ambiguous if it matches
one of each kind.

A declaration not inside a block is said to be `\key{top level}'.
The scope of a top level declaration in a module file is
extended to include the
bodies of that module.  External declarations must be top level in a
module file,
and their scope is extended to the modules and bodies that import the module.

A top level declaration
may \underline{not} have `\TT{next} {\em variable-name}' as
a result variable.

A top level assignment statement in a module may not include references to
out-of-line functions or to inline functions that in turn include
references to out-of-line functions.  This implies that all code needed
to initialize a top level variable will be initialized before the
variable is initialized.

However a top level assignment statement may have a
\key{deferred value} (\pagref{DEFERRED-ASSIGNMENT-STATEMENTS}) indicating
that its result variable values will not be assigned until later.
The statement
assigning the values must be in the same extended module
as the deferred assignment statement, but may be in a body
of that module, and if it is in a body,
may use out-of-line functions.
It is a programming error to access
deferred result variable values before they are assigned.

A name or prototype pattern
declared by a top level declaration in a module may begin with
the {\em module-abbreviation} of the module.  In this case the
name or prototype is `\key{external}',
unless it is an abbreviation.
The scope of external names and prototypes is extended
to include modules and bodies that import the declaring module.
All other names and prototypes declared in the module or
its bodies are `\key{internal}',
and these names and prototype patterns may not begin
with any {\em module-abbreviation}.

{\em Abbreviations} are always internal (\pagref{ABBREVIATIONS-ARE-INTERNAL}),
even when they begin with a {\em module-abbreviation}.

Any name or prototype declared to be external in an imported module is
said to be `\key{imported}'.  The name or prototype is said to be
`\key{exported}' by the module that contains its declaration,
and `\key{imported}' by modules and bodies that import that module.

Imported names can be used only if they begin
with the {\em module-abbreviation} that references the module in which
they are declared.  Imported prototypes may be used by calls beginning with
the {\em module-abbreviation} that references the module in which
they are declared, or if there is no ambiguity the {\em module-abbreviation}
may be omitted from the calls.

An example is:
\begin{indpar}\begin{verbatim}
module "my_own_module" as mom:
    // `import "standard" as std' is implied
    import "George's_own_module" as gom
    // gom contains:
    //    function int32 z = gom ( int32 x ) "+" ( int32 y )

int32 mom my external constant = ...
int32 my internal constant = ...

function int32 y = mom my external function ( int32 x ):
    ... function body omitted ...
function int32 y = my internal function ( int32 x ):
    ... function body omitted ...

function int32 z = my inline function ( int32 x, int32 y ):
    int32 z1 = gom ( x + y )
        // Uses gom's + operator.
        // Compiles as as `gom (x) "+" (y)'.
    int32 z2 = std ( x + y )
        // Uses builtin std's + operator.
        // Compiles as as `std (x) "+" (y)'.
    z  = z1 + z2 
        // Compiles as `z = ( (x) "+" (y) )'.
        // Compile error, ambiguous: both std + operator
        // and gom's + operator match the call to "+".
\end{verbatim}\end{indpar}\label{EXTERNAL-INTERNAL-EXAMPLE}

More specifically,
when a function declaration is used, the {\em module-abbreviation}
beginning the function call may be omitted if the function declaration is
the only function declaration within scope that matches the usage,
according to the module deficiency rules of
section~\itemref{MATCHING-CALLS-TO-PROTOTYPES}.
Thus in the context of the above example the lines:
\begin{indpar}\begin{verbatim}
int32 y = mom my external function ( x )
int32 y = my external function ( x )
\end{verbatim}\end{indpar}
are equivalent if no {\em function-prototype}
\begin{center}
\tt function int32 r = $ma$\QMARK{} my external function ( int32 v )
\end{center}
is in scope, where $ma$ is a module abbreviation other than `{\tt mom}'.

\subsection{Bodies}
\label{BODIES}

A \key{body}
is a file that begins with an {\em body-declaration}:

\begin{indpar}
\emkey{body-declaration}\label{BODY-DECLARATION} ::=
    \begin{tabular}[t]{l}
    \TT{body }{\em body-name}\TT{ of }{\em module-name}\TT{:} \\
    \TT{~~~~}{\em body-clause}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{body-name} ::= {\em quoted-string}
\\[0.5ex]
{\em body-clause} ::= {\em import-clause} $|$ {\em after-clause} $|$
                      {\em internal-parser-block}
\\[0.5ex]
{\em import-clause} ::= see \pagref{IMPORT-CLAUSE}
\\[0.5ex]
{\em after-clause} ::= \TT{initialize after }{\em body-name}
\\[0.5ex]
\emkey{internal-parser-block} ::=
{\em parser-block} without \TT{external} option
\\[0.5ex]
{\em parser-block} ::= see \pagref{PARSER-BLOCK}


\begin{itemize}

\item
A {\em body-declaration} may only appear at the very beginning
of a body file.

\item
In a {\em body-declaration} all {\em module-abbreviations} must be
distinct, and all {\em module-names} and {\em body-names}
must be distinct.

\item
There may be at most one {\em parser-block} in a {\em body-declaration}.
\end{itemize}

\end{indpar}

A {\em body-name} is a POSIX file name.
The {\em body-name} of a {\em body-declaration} must match the
name of the file containing the
{\em body-declaration}, relative to one of several directories
specified separately to the compiler.

A \key{body} is an extension of the module named in the first
line of the {\em body-declaration}.  The body cannot itself
contain external declarations.  It can provide
assignments for variables and out-of-line functions deferred in the
module it extends, and can call out-of-line functions in these
assignments.
It can also declare internal names and functions used only in the
body.

A body implicitly imports the module it extends.  Within the
body that module has the same {\em module-abbreviation} that it
had in the module's own file.  The other modules imported in the
module's own file are \underline{not} implicitly imported
to the body.  The body must import whatever other modules it uses
explicitly.

The {\em after-clauses} name other bodies that extend the same
module, and control initialization: see \itemref{PROGRAM-INITIALIZATION}.

\subsection{Program Initialization}
\label{PROGRAM-INITIALIZATION}

Modules must be initialized.  A module is initialized after every
module that it imports is initialized.  Otherwise the order of
initializing modules is indeterminate.  Because the module graph
(\pagref{MODULE-GRAPH}) is acyclic, it is always possible to
initialize imported modules before the importing module.

A module is initialized by executing top level assignment statements
in the module file, and then initializing
bodies that extend the module.  A body is initialized
by executing top level assignment statements in the body.
Top level statements in a file are executed in order.
Note that some of these assignment statements may not have
result variables.

A module is initialized before any bodies that extend it.
Unless specified by {\em after-clauses}, the order of initializing the
bodies that extend a module is indeterminate.
An `\TT{initialized after "$B1$"}' clause for module \TT{"$B2$"} causes
\TT{"$B2$"} to be initialized after \TT{"$B1$"}.

Each module has a `\key{body graph}'\label{BODY-GRAPH}
whose nodes are bodies that extend
the module and whose arrows connect each body to the bodies it
initializes after.  This graph must be acyclic.

All {\em deferred-assignment-statements}
(\pagref{DEFERRED-ASSIGNMENT-STATEMENTS})
and {\em out-of-line-function-deferred-assignments}
(\pagref{OUT-OF-LINE-FUNCTION-DEFERRED-ASSIGNMENT}) must be executed
before statements initializing their deferred variables or deferred functions.
Statements initializing deferred variables and functions must be executed
during initialization of the extended module containing the
deferred variables and functions, and
before the deferred variable values or deferred functions are used.

\subsection{Parsing}

The parser converts each statement to an abstract syntax tree,
using the language syntax equations and the {\em module-abbreviations}
and {\em parser-clauses}
of the current module's {\em module-declaration} or body's
{\em body-declaration}.  The abstract syntax
tree of a statement can be represented by inserting implied
parentheses into the statement and quoting operators.

For example, the statement
\begin{center}
\tt int64 x 1 = y 5 b + sin (w) * cos z
\end{center}
becomes the abstract syntax tree represented by
\begin{center}
\tt (int64 x 1) = ((y 5 b) "+" ((sin (w)) "*" (cos z)))
\end{center}
Note that the abstract tree representation is not legal
program code as it has parentheses around the result
variable declaration `{\tt int64 x 1}'.

Operators in the original statement are replaced by quoted
versions of the operators in the abstract
syntax tree, e.g., {\tt +} is replaced by {\tt "+"}, so that
the operators become {\em term-names}.

The parser does not process {\em result-variable-declarations} or
{\em argument-declarations}.  Thus
\begin{center}
\tt function int64 r = ( int64 a 1 ) "+" ( int64 a 2 )
\end{center}
becomes
\begin{center}
\tt function (int64 r) = (( int64 a 1 ) "+" ( int64 a 2 ))
\end{center}

Since the parser has only syntax information and {\em module-abbreviations}
available to
it, the parser does not know the {\em qualifier-names}
and {\em type-names} in a given scope, and in fact the parser
has no notion of scope.

The parser does know about {\em module-abbreviations} and
converts a statement of the form:
\begin{center}
{\em module-abbreviation} {\tt (~\ldots~)}
\end{center}
to
\begin{center}
{\tt (~}{\em module-abbreviation}{\tt ~\ldots~)}
\end{center}
after parsing `{\tt \ldots}'.  Thus if $ma$ is a {\em module-abbreviation},
\begin{center}
\tt int64 x 1 = $ma$ ( y 5 b + sin (w) * cos z )
\end{center}
becomes the abstract syntax tree represented by
\begin{center}
\tt (int64 x 1) = ($ma$ (y 5 b) "+" ((sin (w)) "*" (cos z)))
\end{center}

The parser also does a bit of expression rewriting
(\itemref{PARSER-REWRITE-RULES}).  For example, the expression
\begin{center}
\tt not ( x and y )
\end{center}
gets rewritten to become
\begin{center}
\tt ( not ( x ) ) and ( not ( y ) )
\end{center}
and in general, the parser moves {\tt "not"} inside {\tt "and"}
and {\tt "or"} and eliminates double negations,
and similarly moves the bitwise complement operator {\tt "!"}
inside the bitwise operators {\tt "\&"} and {\tt "|"}
and eliminates double complements.

\section{Types}
\label{TYPES}

The basic builtin types are the number types and the \TT{void} type.
All defined types are subtypes of these types.
One of the builtin defined subtypes is the `\TT{type}' type.

A type is denoted by its {\em type-name}.  New types are
defined by statements of the form:

\begin{indpar}
\emkey{type-declaration}\label{TYPE-DECLARATION} \\
\hspace*{0.5in}\begin{tabular}{@{}rl@{}}
    ::= & \ttkey{define type}\TT{~}{\em type-name}\TT{~as~}\ldots \\
    $|$ & \TT{define types:} \\
        & {\TS ~~~~}{\em type-name}\TT{ as }\ldots \\
        & {\TS ~~~~}{\em type-name}\TT{ as }\ldots \\
        & {\TS ~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
    \end{tabular}
\\[1ex]
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\end{indpar}

\subsection{Number Types}
\label{NUMBER-TYPES}

Numbers are sequences of bits, and each number is one of
four kinds, unsigned integer, signed integer, floating point number,
or address:

\begin{indpar}
\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\bf Name & \bf Kind & \bf Size \\[2ex]
\TT{std}~~~\ttkey{uns8}		& unsigned integer & 8 bits \\
\TT{std}~~~\ttkey{uns16}	& unsigned integer & 16 bits \\
\TT{std}~~~\ttkey{uns32}	& unsigned integer & 32 bits \\
\TT{std}~~~\ttkey{uns64}	& unsigned integer & 64 bits \\
\TT{std}~~~\ttkey{uns128}	& unsigned integer & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{int8}		& signed integer & 8 bits \\
\TT{std}~~~\ttkey{int16}	& signed integer & 16 bits \\
\TT{std}~~~\ttkey{int32}	& signed integer & 32 bits \\
\TT{std}~~~\ttkey{int64}	& signed integer & 64 bits \\
\TT{std}~~~\ttkey{int128}	& signed integer & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{float16}	& IEEE floating point number & 16 bits \\
\TT{std}~~~\ttkey{float32}	& IEEE floating point number & 32 bits \\
\TT{std}~~~\ttkey{float64}	& IEEE floating point number & 64 bits \\
\TT{std}~~~\ttkey{float128}	& IEEE floating point number & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unsadr}	& unsigned integer & size of address \\
\TT{std}~~~\ttkey{intadr}	& signed integer & size of address \\
\TT{std}~~~\ttkey{adr}		& address
                                & size of address \\
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unswrd}	& unsigned integer & size of integer register \\
\TT{std}~~~\ttkey{intwrd}	& signed integer & size of integer register \\
\TT{std}~~~\ttkey{floatwrd}	& IEEE floating point number
                                & size of floating point register
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unsmax}	& unsigned integer & max implemented size \\
\TT{std}~~~\ttkey{intmax}	& signed integer & max implemented size \\
\TT{std}~~~\ttkey{floatmax}	& IEEE floating point number
                                & max implemented size
\end{tabular}

\end{indpar}

These are the \key{built in number types}.  The \TT{adr} type is a
signed or unsigned integer used as an address, and is differentiated
from other integers in case hardware differentiates addresses from
integers.
The \TT{\ldots{}wrd} types
are the sizes that execute fastest, while the \TT{\ldots{}max} types
may be larger sizes for which all arithmetic and comparison
operations are \key{implemented}\label{IMPLEMENTED}.
Copying and conversion of values is always implemented for
\underline{all}
number types, except for implementations
that do not implement \underline{any} floating point types.

It is required that the sizes of {\tt unswrd} and {\tt intwrd} be the
same, and that the sizes of {\tt unsmax} and {\tt intwrd} be the
same.  It is required that the size of {\tt unsmax} be at least
as large as the size of {\tt unswrd}, and similarly for {\tt int\ldots}
and {\tt float\ldots}.

Here `\TT{std}' is the module abbreviation for the \TT{"standard"}
module to which builtin types and functions belong.  For convenience
the following abbreviations are builtin:
\begin{indpar}
{\tt define abbreviations:}
\begin{indpar}[0.3in]

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{uns8} & {\tt `std~uns8'} \\
\ttkey{uns16} & {\tt `std~uns16'} \\
\ttkey{uns32} & {\tt `std~uns32'} \\
\ttkey{uns64} & {\tt `std~uns64'} \\
\ttkey{uns128} & {\tt `std~uns128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{int8} & {\tt `std~int8'} \\
\ttkey{int16} & {\tt `std~int16'} \\
\ttkey{int32} & {\tt `std~int32'} \\
\ttkey{int64} & {\tt `std~int64'} \\
\ttkey{int128} & {\tt `std~int128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{float16} & {\tt `std~float16'} \\
\ttkey{float32} & {\tt `std~float32'} \\
\ttkey{float64} & {\tt `std~float64'} \\
\ttkey{float128} & {\tt `std~float128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unsadr} & {\tt `std~unsadr'} \\
\ttkey{intadr} & {\tt `std~intadr'} \\
\ttkey{adr} & {\tt `std~adr'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unswrd} & {\tt `std~unswrd'} \\
\ttkey{intwrd} & {\tt `std~intwrd'} \\
\ttkey{floatwrd} & {\tt `std~floatwrd'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unsmax} & {\tt `std~unsmax'} \\
\ttkey{intmax} & {\tt `std~intmax'} \\
\ttkey{floatmax} & {\tt `std~floatmax'} \\
\end{tabular}

\end{indpar}
\end{indpar}

Here
\begin{center}
{\em abbreviation-name}~~\TT{\ABV}~~\TT{`}{\em replacement-name}\TT{'}
\end{center}
specifies that whenever the {\em abbreviation-name} occurs it is to be
replaced by the {\em replacement-name}.  See \itemref{ABBREVIATIONS} for
more abbreviation details.

In this document we will use these abbreviations as the
`\skey{builtin number type}s':

\begin{indpar}
{\em builtin-number-type-name}\label{BUILTIN-NUMBER-TYPE-NAME}
    \begin{tabular}[t]{@{}cl}
    ::= & \TT{uns8} $|$ \TT{uns16} $|$ \TT{uns32} $|$ \TT{uns64}
                    $|$ \TT{uns128} \\
    $|$ & \TT{int8} $|$ \TT{int16} $|$ \TT{int32} $|$ \TT{int64}
                    $|$ \TT{int128} \\
    $|$ & \TT{float16} $|$ \TT{float32} $|$ \TT{float64} $|$ \TT{float128} \\
    $|$ & \TT{unsadr} $|$ \TT{intadr} $|$ \TT{adr} \\
    $|$ & \TT{unswrd} $|$ \TT{intwrd} $|$ \TT{floatwrd}  \\
    $|$ & \TT{unsmax} $|$ \TT{intmax} $|$ \TT{floatmax}  \\
    \end{tabular}
\end{indpar}

\subsubsection{Integer Number Types}

The \mkey{size}{of number}
of a number is the number of its bits.  Numbers can have
different sizes: for example, unsigned integers can have
sizes of 8, 16, 32, 64, or 128 bits.

Numbers are stored in registers or in random access memory (RAM).

An \key{unsigned integer} of size $S$ is a binary integer with
$S$ binary digits (\skey{bit}s) and range from $0$ to $2^S-1$.

A \key{signed integer} of size $S$ is a two's complement integer
of size $S$ and range from $-2^{S-1}$ to $+2^{S-1}-1$.
This represents the integer $I$ in the given range
by the unsigned $S$-bit integer equal to $I~\mbox{modulo}~2^S$.

An \key{address} holds a RAM byte address.
An address is a 32-bit or 64-bit signed or unsigned integer whose size
and signage are determined by the target machine.
Some of high order bits may be
required to be all 0's or all 1's, depending upon
the target machine.  The \TT{unsadr} and \TT{intadr}
unsigned and signed integer types of the same size
as an address are provided for storing indices and offsets.

A reasonable assumption for 64-bit addresses is that only the low
order 48-bits of the address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing an address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The L-Language does
\underline{not} depend upon this assumption, but does provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$ (see {\tt extract adr}, \pagref{EXTRACT-ADR}).
The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.\footnote{The I86 64-bit architecture
uses only the low order 48 bits of an address, but \underline{requires}
the high order 17 bits to all be the same, either all 1's or all 0's.
However, as it is unlikely that there will ever be an allocated memory region
that includes address 0 in its interior, it makes no significant difference
whether we consider addresses to be unsigned or signed.}

\subsubsection{Floating Point Number Types}

A \key{floating point number} of size $S$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes are as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}r@{~~~~~~}r}
                   &              &              &             & \bf Maximum \\
\bf Floating Point & \bf Exponent & \bf Mantissa & \bf Decimal & \bf Decimal\\
\bf Number Size    & \bf Size     & \bf Size     & \bf Digits  & \bf Exponent
\\[2ex]
16 bits & 5 bits & 10 bits & 3.31 & 4.51 \\
32 bits & 8 bits & 23 bits & 7.22 & 38.23 \\
64 bits & 11 bits & 52 bits & 15.95 & 307.95 \\
128 bits & 15 bits & 112 bits & 34.02 & 4931.77 \\
\end{tabular}
\end{center}

There are also three special floating point values:
\TT{+Inf} denoting positive infinity,
\TT{-Inf} denoting negative infinity,
and \TT{NaN} denoting `\key{not-a-number}' which is a value produced
when, for example, \TT{0} is divided by \TT{0}.
In this document \ttkey{NaN}\label{NAN} denotes the particular non-signaling
not-a-number value
produced by arithmetic operations that cannot produce a number.%
\footnote{For example, the x86 architecture generates a
`\key{floating indefinite NaN}' as output of such operations.}
Floating point variables can store many other not-a-number values.

\subsubsection{Number Conversion Functions}

In the following we specify builtin conversion functions using
function prototypes of the form:
\begin{center}
\tt function $T1$ r = std $F$ ( $T2$ v )
\end{center}
This says that if you apply the function $F$ to the value \TT{v} which
is of type $T2$, the function will return a value \TT{r} of type $T1$.
See \itemref{FUNCTION-PROTOTYPES-AND-CALLS} for more function prototype details.

If a conversion from type $T2$ to type $T1$ may be implied, then
in code of the form
\begin{center} \tt
\begin{tabular}{l}
$T2$ v = \ldots \\
$T1$ r = v
\end{tabular}
\end{center}
the second statement will automatically invoke the implied conversion.

The following builtin conversion functions are defined:

\begin{indpar}
{\tt function uns$x$~~~r = \ttstdkey{uns$x$}~~~( uns$y$ v )} \\
{\tt function int$x$~~~r = \ttstdkey{int$x$}~~~( uns$y$ v )} \\
{\tt function float$x$~r = \ttstdkey{float$x$}~( uns$y$ v )} \\
{\tt function int$x$~~~r = \ttstdkey{int$x$}~~~( int$y$ v )} \\
{\tt function float$x$~r = \ttstdkey{float$x$}~( int$y$ v )} \\
{\tt function float$x$~r = \ttstdkey{float$x$}~( float$y$ v )}
\begin{center}
for any $x>y$ for which the types are builtin
\end{center}
\begin{indpar}
For these conversion functions, no information is lost from
the value when it is converted to the new type.  These conversions
can be \ikey{implied}{implied conversion}.
\end{indpar}

{\tt function uns$x$~~~r = \ttstdkey{truncate}~~~( uns$y$ v )} \\
{\tt function uns$x$~~~r = \ttstdkey{truncate}~~~( int$y$ v )} \\
{\tt function int$x$~~~r = \ttstdkey{truncate}~~~( uns$y$ v )} \\
{\tt function int$x$~~~r = \ttstdkey{truncate}~~~( int$y$ v )}
\begin{center}
for any $x$ and $y$ for which the types are builtin
\end{center}
\begin{indpar}
These functions return a value equal to the argument
modulo $2^x$.
\end{indpar}

{\tt function uns$x$~~~~~r = \ttstdkey{nearest}~~~( uns$y$ v )} \\
{\tt function uns$x$~~~~~r = \ttstdkey{nearest}~~~( int$y$ v )} \\
{\tt function uns$x$~~~~~r = \ttstdkey{nearest}~~~( float$y$ v )} \\
{\tt function int$x$~~~~~r = \ttstdkey{nearest}~~~( uns$y$ v )} \\
{\tt function int$x$~~~~~r = \ttstdkey{nearest}~~~( int$y$ v )} \\
{\tt function int$x$~~~~~r = \ttstdkey{nearest}~~~( float$y$ v )} \\
{\tt function float$x$~~~r = \ttstdkey{nearest}~~~( uns$y$ v )} \\
{\tt function float$x$~~~r = \ttstdkey{nearest}~~~( int$y$ v )} \\
{\tt function float$x$~~~r = \ttstdkey{nearest}~~~( float$y$ v )}
\ttindex{nearest}
\begin{center}
for any $x$ and $y$ for which the types are builtin
\end{center}
\begin{indpar}
These functions round the argument to the nearest value (ties to even)
of the result type if the result must have less precision than the argument.
If the value overflows the result type, the result is \TT{+Inf} or \TT{+Inf}
for floating point results, and the largest or smallest possible result
value for integer results.
\end{indpar}

\end{indpar}

Note the difference between \TT{truncate} and \TT{nearest} when applied to
integers outside the range of the target type:
\begin{center}
\begin{tabular}{l}
{\tt uns8 ( truncate ( 257 ) ) == 1} \\
{\tt uns8 ( nearest ( 257 ) ) == 255} \\
\end{tabular}
\end{center}

Floating point numbers can be converted to integer valued floating point
numbers via:

\begin{indpar}
{\tt function float$x$~~~r = \ttstdkey{round}~~~~~( float$x$ v )} \\
{\tt function float$x$~~~r = \ttstdkey{ceiling}~~~( float$x$ v )} \\
{\tt function float$x$~~~r = \ttstdkey{floor}~~~~~( float$x$ v )}

\begin{center}
for any $x$ for which the types are builtin
\end{center}
\begin{indpar}
These functions round to nearest (ties to even),
round up, and round down respectively.
\end{indpar}
\end{indpar}


\subsubsection{Unchecked Number Conversions}
\label{UNCHECKED-NUMBER-CONVERSIONS}

The following \underline{unchecked} conversion functions are defined.
Note that here \TT{*UNCHECKED*} is a qualifier; see \itemref{QUALIFIERS}
for qualifier details.

\begin{indpar}
{\tt function \TT{*UNCHECKED*} uns$x$~~~r =~%
	\ttmkey{uns$x$}{conversion function}~~~( int$x$ v )} \\
{\tt function \TT{*UNCHECKED*} uns$x$~~~r =~%
	\ttmkey{uns$x$}{conversion function}~~~( float$x$ v )} \\
{\tt function \TT{*UNCHECKED*} int$x$~~~r =~%
	\ttmkey{int$x$}{conversion function}~~~( uns$x$ v )} \\
{\tt function \TT{*UNCHECKED*} int$x$~~~r =~%
	\ttmkey{int$x$}{conversion function}~~~( float$x$ v )} \\
{\tt function \TT{*UNCHECKED*} float$x$~r =~%
	\ttmkey{float$x$}{conversion function}~( uns$x$ v )} \\
{\tt function \TT{*UNCHECKED*} float$x$~r =~%
	\ttmkey{float$x$}{conversion function}~( int$x$ v )}

\begin{center}
for any $x$ for which the types are builtin
\end{center}
\begin{indpar}
These functions just return the $x$-bit value of \TT{v}
unchanged except for giving it a different type.
\end{indpar}
\end{indpar}

\subsubsection{Number Constants}
\label{NUMBER-CONSTANTS}

A \key{number-constant} is a {\em number} lexeme with specific syntax
that is used to denote a number.  The syntax is:

\begin{indpar}
\emkey{number-constant}\label{NUMBER-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em decimal-constant} \\
    $|$ & {\em binary-constant} \\
    $|$ & {\em hexadecimal-constant} \\
    $|$ & \TT{+Inf}\index{Inf@\TT{+Inf}}
          ~$|$~ \TT{-Inf}\index{Inf@\TT{-Inf}}
          ~$|$~ \ttkey{NaN}
    \end{tabular}
\\[0.5ex]
\emkey{sign} :::= \TT{+} $|$ \TT{-} \\
\emkey{exponent} :::=
	\{ \TT{e} $|$ \TT{E} \} {\em sign}\QMARK{} {\em dit}\PLUS{}
\\[0.5ex]
\emkey{decimal-constant} \begin{tabular}[t]{@{}rl@{}}
                         ::= & {\em decimal-lexeme} \\
			 $|$ & {\em decimal-constant-prefix} ~
			       {\em decimal-quoted-body} ~
			       {\em exponent}\QMARK{}
			 \end{tabular}
\\[0.5ex]
\emkey{decimal-lexeme} :::= {\em sign}\QMARK{} ~ {\em decimal-integer} ~
			    {\em decimal-fraction}\QMARK{} ~
                            {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{decimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{D}
\\[0.5ex]
\emkey{decimal-quoted-body} :::= \TT{"} {\em decimal-integer} ~
				 {\em decimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{decimal-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em dit}\PLUS{} \\
     $|$ & {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
     $|$ & {\em dit} {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
     $|$ & {\em dit} {\em dit} {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
    \end{tabular} \\
\emkey{decimal-fraction} :::= \TT{.} {\em dit}\PLUS{} \\
\emkey{dit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
 \\[0.5ex]
\emkey{binary-constant} ::= {\em binary-constant-prefix} ~
                              {\em binary-quoted-body} ~
			      {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{binary-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{B}
\\[0.5ex]
\emkey{binary-quoted-body} :::= \TT{"} {\em binary-integer} ~
				{\em binary-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{binary-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em bit}\PLUS{} \\
     $|$ & {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
     $|$ & {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
     $|$ & {\em bit} {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
     $|$ & {\em bit} {\em bit} {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
    \end{tabular} \\
\emkey{binary-fraction} :::= \TT{.} {\em bit}\PLUS{} \\
\emkey{bit} :::= \TT{0} $|$ \TT{1}
 \\[0.5ex]
\emkey{hexadecimal-constant} ::= \\
\hspace*{0.5in}{\em hexadecimal-constant-prefix} ~
               {\em hexadecimal-quoted-body} ~
	       {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{hexadecimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{X}
\\[0.5ex]
\emkey{hexadecimal-quoted-body} :::= \TT{"} {\em hexadecimal-integer} ~
				     {\em hexadecimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{hexadecimal-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em hit}\PLUS{} \\
     $|$ & {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
     $|$ & {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
     $|$ & {\em hit} {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
     $|$ & {\em hit} {\em hit} {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
    \end{tabular} \\
\emkey{hexadecimal-fraction} :::= \TT{.} {\em hit}\PLUS{} \\
\emkey{hit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
	     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
	     $|$ \TT{a} $|$ \TT{b} $|$ \TT{c} $|$ \TT{d} $|$ \TT{e} $|$ \TT{f}
	     $|$ \TT{A} $|$ \TT{B} $|$ \TT{C} $|$ \TT{D} $|$ \TT{E} $|$ \TT{F}
\end{indpar}

The integer part of decimal constants may have commas
every 3 digits, and the integer part of binary and hexadecimal constants
may have commas every 4 digits.
If there is a decimal point, there \underline{must}
be at least one integer digit and
one fraction digit.

\TT{NaN} denotes a canonical non-signaling NaN such
at that produced by hardware on the target machine
(\pagref{NAN}).
\TT{+Inf} denotes positive infinity; \TT{-Inf} denotes negative infinity.

{\em Number-constants} have no type.  They can be converted to
values of number type as follows.

A {\em number-constant} can be implicitly converted to any number
type that can represent the number exactly.

A {\em number-constant} can be implicitly converted to any
floating point number type.  If it is too large, it is converted to
\TT{+Inf}, and if it is too small, it is converted to \TT{-Inf}.
If it cannot be represented exactly, it is rounded (ties to even).

A {\em number-constant} can be explicitly converted to any number
type by either the \TT{truncate} or \TT{nearest} functions.
It may be explicitly
converted by \TT{uns$x$}, \TT{int$x$}, or \TT{float$x$} functions only
if it may be implicitly converted to the desired type.

{\em Number-constants} are compile time values and can be combined by
the standard operators to produce compile time values.

\subsubsection{Error Values}
\label{ERROR-VALUES}

All number types have \skey{error value}s that can be returned by
functions to indicate an error.  Error values are typically legal
number values that cannot be normal return values in a particular context.
For example, an allocation function would never return the address
of inaccessible memory if there was no error, so values pointing at
inaccessible memory can be used as error values.

Each error value contains an \key{error code}, which is a small
non-negative integer that give some information as to the kind of error.

The following builtin functions manipulate error values for a given type $T$:
\begin{indpar}
{\tt function $T$ r = \ttstdkey{ERROR} ( unswrd code )}
\begin{indpar}
Returns the type $T$ error value with given error code.
\end{indpar}
{\tt function $T$ r = \ttstdkey{NULL}}\label{NULL}
\begin{indpar}
Returns {\tt ERROR(0)}.  Used to indicate a value that is missing,
but is not necessarily associated with any error.
\end{indpar}
{\tt function bool r =
    \TT{std} ( $T$ value ) \TT{is error}\ttstdindex{is error} }
\begin{indpar}
Returns \TT{true} if and only if {\tt value} is an error value.
\end{indpar}
{\tt function unswrd r = \ttstdkey{error code of} ( $T$ value ) }
\begin{indpar}
Returns error code of {\tt value} if that is an error value, or
returns {\tt unswrd(ERROR(BAD RANGE))} if {\tt value} is not
an error value.
\end{indpar}
{\tt function unswrd r = \ttstdkey{MAX ERROR CODE} ( type t == $T$ )}
\begin{indpar}
Returns the maximum allowed error code for type $T$.  For builtin number
types $T$, this is at least $2^s-1$ where $s$ is the size in bits of
numbers of type $T$, with the exception of the \TT{adr} type.  For
the \TT{adr} type the maximum allowed error code is $2*{20}-1$ for 32-bit
values and $2^{30}-1$ for 64-bit values.

\end{indpar}
\end{indpar}

For a builtin unsigned integer type $T$ and an error code c not greater
than the maximum allowed for $T$,
\begin{center}
\tt ERROR(c) == $T$(max value) - c
\end{center}

For a builtin signed integer type $T$ and an error code c not greater
than the maximum allowed for $T$,
\begin{center}
\tt ERROR(c) == $T$(min value) + c
\end{center}

The \TT{adr} type is an exception.  For this type, \TT{NULL} is the address
of a block of unimplemented memory that is at least 1 megabyte on computers
with 32 bit virtual addresses and at least 1 gigabyte on computers
with 48 or more bit virtual addresses.  Error codes for the \TT{adr} type
are:
\begin{center}
\tt ERROR(c) == adr(NULL) + c
\end{center}

For a builtin floating point number type $T$ whose values are of size
$s$ bits, the high order $s/2$ bits of every error value of type $T$
is the same and this value designates the error value as a non-signaling NaN.

The following are standard error code values:
\begin{indpar}

{\tt function unswrd r = \ttstdkey{INSUFFICIENT MEMORY}} ~~~ (== 0)
\begin{indpar}
Not enough memory is available.
\end{indpar}
{\tt function unswrd r = \ttstdkey{BAD RANGE}} ~~~ (== 1)
\begin{indpar}
Argument is out of range.
\end{indpar}
{\tt function unswrd r = \ttstdkey{BAD ALIGNMENT}} ~~~ (== 2)
\begin{indpar}
Alignment argument is out of range.
\end{indpar}

\end{indpar}




\subsection{The Void Type}
\label{THE-VOID-TYPE}

A \ttkey{void} type variable has no value.  No value can be
assigned to such a variable.  Nevertheless such variables have
uses, for example, as base variable in clusters (\pagref{CLUSTERS}).
When used as the base variable of a cluster, an assignment statement
may appear to be assigning a value to a \TT{void} variable, but
in fact it is assigning values to cluster members.

\subsection{Defined Types}
\label{DEFINED-TYPES}

A declaration statement of the following form defines a new type and
specifies a {\em type-name} for that type:
\begin{indpar}
\emkey{defined-type-declaration}\label{DEFINED-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
\TT{define type}
          {\em qualifier-name}\STAR{} {\em defined-type-name}
          \TT{as} {\em base-type-expression} \\
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME} \\
\emkey{defined-type-name} ::= {\em type-name} ~~~~~ [see \pagref{TYPE-NAME}] \\
\emkey{base-type-expression} ::= {\em expression} evaluating at compile-time
				 to a \TT{type} value \\
{\em expression} ::= see \pagref{EXPRESSION}
\end{indpar}

A \TT{type} value is an enumeration value (\pagref{ENUMERATION-TYPES}),
which is basically a small integer that identifies the type.
Types can be computed
by compile-time expressions, just like integers.
A \TT{type} value can be associated with zero or more {\em type-names},
which can be used in various ways, including as the name of a constant
equal to the \TT{type} value.

In a {\em defined-type-declaration}
the {\em base-type-expression} specifies
the `\key{base type}' of the new type defined
by the {\em defined-type-declaration}.
The {\em defined-type-name} names a new `\key{defined type}'.
The simplest {\em base-type-expres\-sion} is just a {\em type-name} of the
base type.

Any {\em qualifiers} in the declaration are attached to every
variable or argument declared with the {\em defined-type-name} (see
section \itemref{QUALIFIERS} for more on {\em qualifiers}).
Such {\em qualifiers} are associated with {\em type-names} and not
with \TT{type} values.

No {\em type-name} may be a prefix of
any {\em deferred-variable} (\pagref{DEFERRED-VARIABLE})
or any {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME}).
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.

Consider the example:
\begin{indpar}\begin{verbatim}
define type T1 as int32
type T2 = int32
define type T3 as T2  // Same as `define type T3 as int32'
int32 x = 1
*UNCHECKED* T1 x1 = T1 ( x )
*UNCHECKED* T2 x2 = x        // Compile error:
                             // T2 is not a type-name
*UNCHECKED* T3 x3 = T3 ( x )
\end{verbatim}\end{indpar}

A `{\tt \ttkey{define type} T as \ldots}'
statement defines {\tt T} to be a {\em type-name} that can be used in
a declaration of the form `{\tt T v}',
or can be used to name a constant equal a \TT{type} value
as in `{\tt T == int32}',
or can be used
as a function of one argument to convert the argument to the
type, as in `{\tt T(v)}', provided the result is a variable with
the \TT{*UNCHECKED*} qualifier.
However a statement of the form `{\tt type T = \ldots}'
declares {\tt T} to be a mere variable name that can only be
use as a constant equal a \TT{type} value.

A defined type has an
`\mkey{underlying type}{of defined type}'\label{UNDERLYING-TYPE} that
is a builtin type.  Underlying types are defined recursively:
the underlying type of a defined type is the underlying type of
its base type, and the underlying type of a builtin type is
the builtin type itself.

The following builtin unchecked conversion functions are defined:
\begin{indpar}\label{DEFINED-TYPE-UNCHECKED-CONVERSIONS}
{\tt function \TT{*UNCHECKED*} $T$ r = $T$ ( $B$ v )} \\
{\tt function \TT{*UNCHECKED*} $B$ r = $B$ ( $T$ v )}

where $T$ is a {\em defined-type-name} and $B$ is any {\em type-name}
for the base type of $T$

\begin{indpar}
These functions do not change the actual value, but merely its
compile-time type.
\end{indpar}\label{DEFINED-TYPE-UNCHECKED-CONVERSION}

\end{indpar}

The \TT{*UNCHECKED*} qualifier
(\itemref{QUALIFIERS} and \pagref{THE-UNCHECKED-QUALIFIER})
may be attached to variables and must be attached to the result
variables of an unchecked type conversion.  An example of
their use to define type and \underline{explicit} conversion from
type {\tt T1} to type {\tt T2} that is \underline{not} unchecked is:
\begin{indpar}\label{NOT-UNCHECKED-CONVERSION-DEFINITION}\begin{verbatim}
define type T1 as T2
function T2 r = T2 ( T1 v ):
    *UNCHECKED* r2 = T2 ( v )
    r = r2
\end{verbatim}\end{indpar}
They can also be used to define an implied conversion from type
{\tt T1} to type {\tt T2}, as in the
following example:
\begin{indpar}\begin{verbatim}
define type T1 as T2
function Qs T2 r = assign (| qualifiers Qs |) ( Qs T1 v ):
    *UNCHECKED* Qs r2 = T2 ( v )
    r = r2
\end{verbatim}\end{indpar}
See \itemref{IMPLIED-CONVERSION} implied conversion details.

The following builtin functions are also defined:

\begin{indpar}
{\tt function type r = \ttstdkey{base type of} ( type t )}

\begin{indpar}
Returns the base type of the defined type {\tt t}.
\end{indpar}

{\tt function type r = \ttstdkey{underlying type of} ( type t )}

\begin{indpar}
Returns the underlying type of the defined type or builtin type {\tt t}.
\end{indpar}
\end{indpar}

A type may have zero or more type names associate with it.
An additional name may be associated with a type by the statement:
\begin{indpar}
\emkey{type-name-declaration}\label{TYPE-NAME-DECLARATION} ::= \\
\hspace*{0.5in}
\TT{define type}
          {\em qualifier-name}\STAR{} {\em type-name}
          \TT{as type name of} {\em type-expression} \\
\emkey{type-expression} ::= {\em expression} evaluating at compile-time
				 to a \TT{type} value \\
{\em expression} ::= see \pagref{EXPRESSION}
\end{indpar}

Unlike the {\em defined-type-declaration}, the {\em type-name-declaration}
does \underline{not} define a new type.  It merely defines a new
{\em type-name} that references an old type.
The {\em qualifier-names} in either declaration are associated
with the {\em type-name}, and not the type, and are applied whenever
the {\em type-name} is used to declare a variable.

An example is:
\begin{indpar}\begin{verbatim}
define type T4 as type name of int32
    // Now T4 == int32
T4 x = 1              // Same as `int32 x = 1'
int32 y = T4 ( x )    // Same as `int32 y = int32 ( x )'
define type T5 as int32
    // Now T5 != int32 and T5 != T4
define *UNCHECKED* T6 as type name of int32
    // *UNCHECKED* is a builtin qualifier
    // Now T6 == int32
T6 x = 1              // Same as `*UNCHECKED* int32 x = 1'
\end{verbatim}\end{indpar}

There is one builtin defined type:
\begin{indpar} \tt
define type \ttstdkey{bool}\label{BOOL} as unswrd \\
define abbreviation \ttkey{bool} \ABV{} `std bool' \\
function std bool r = \ttstdkey{false}: \\
\TS~~~~*UNCHECKED* r2 = std bool ( 0 ) \\
\TS~~~~r = r2 \\
function std bool r = \ttstdkey{true}: \\
\TS~~~~*UNCHECKED* r2 = std bool ( 1 ) \\
\TS~~~~r = r2 \\
function std intwrd r = \ttstdmkey{int}{of {\tt bool}} ( bool v ): \\
\TS~~~~r = 1 if v else 0
\end{indpar}

In statements that test \TT{bool} values to determine control
flow, \TT{false} (derived by converting the integer zero)
denotes false, and any \TT{bool} value derived by converting
a non-zero integer denotes true.

Implied conversions from any type of value to a \TT{bool}%
\label{IMPLIED-BOOL-CONVERSION} may
be defined as a shorthand for testing the validity of the value.
Because of this, it is important that \TT{bool} values \underline{not} be
acceptable as operands of builtin operators, e.g., comparison
operators.  This in turn makes it impossible to define \TT{bool}
as an enumeration type as per Section~\itemref{ENUMERATION-TYPES}.

\subsection{Enumeration Types}
\label{ENUMERATION-TYPES}

An \key{enumeration type} is a defined type whose values are
integers assigned to \skey{enumeration constant}s.
Each enumeration constant is assigned a value during compilation
that is an integer unique relative to all enumeration
constants of its enumeration type that are being compiled together.
Then during program initialization
the enumeration constant is assigned a possibly
different value that is an integer unique relative to all enumeration
constants of its enumeration type that are being initialized by
the program.

A declaration statement of the following form defines an \key{enumeration type}:
\begin{indpar}
\emkey{enum-type-declaration}\label{ENUM-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
    \TT{define type} {\em qualifier-name}\STAR{}
    \begin{tabular}[t]{@{}l@{}}
    {\em enum-type-name} \TT{as}~~~{\em enum-base} \\
    \TT{with enum range}~~~{\em enum-range} \\
    \end{tabular}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
\emkey{enum-type-name} ::= {\em type-name} ~~~~~ [see \pagref{TYPE-NAME}]
\\[0.5ex]
\emkey{enum-base}
    \begin{tabular}[t]{rl}
    ::= & {\em integer-type-expression} \\
    $|$ & {\em enum-direction}~~~{\em enum-type-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{integer-type-expression} ::= {\em expression} evaluating at compile-time
				 to a builtin integer \TT{type}
\\[0.5ex]
\emkey{enum-direction} ::= \TT{next} $|$ \TT{previous}
\\[0.5ex]
\emkey{enum-type-expression} ::= {\em expression} evaluating at compile-time
				 to an enumeration \TT{type}
\\[0.5ex]
\emkey{enum-range}
    \begin{tabular}[t]{rl}
    ::= & \TT{[} {\em first-enum} \TT{..} {\em last-enum} \TT{]} \\
    $|$ & \TT{[} {\em first-enum} \TT{..} \TT{]} \\
    $|$ & \TT{[} \TT{..} {\em last-enum} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{first-enum} ::=
    {\em expression} evaluating at compile-time to an integer
\\[0.5ex]
\emkey{last-enum} ::=
    {\em expression} evaluating at compile-time to an integer
\\[0.5ex]
\emkey{expression} ::= see \pagref{EXPRESSION}
\end{indpar}

Here {\em first-enum} and {\em last-enum} are compile time integer
values assigned to the newly defined enum type.
{\em First-enum} must be less than or equal to {\em last-enum}.
If {\em last-enum} is not given, it is assumed to be the maximum
value permitted by the {\em enum-base} that conforms to the
rules given below.
Similarly if {\em first-enum} is not given, it is assumed to be the minimum
value permitted by the {\em enum-base}.

The {\em enum-base} specifies the `\mkey{base type}{of enumeration type}'
of the enumeration type
which is either the type given by an {\em integer-type-expression} or
the type given by an {\em enum-type-expression}.
The `\mkey{underlying type}{of enumeration type}'
of the enumeration type
is the base type if that is an integer type, or is the
underlying type of the base type otherwise.
This definition is recursive, so the underlying type of an enumeration
type is always an
integer type.

Information about
an enumeration type
can be discovered by the functions:

\begin{indpar}

{\tt function type r = \ttstdkey{base type of} ( type t )} \\
{\tt function type r = \ttstdkey{underlying type of} ( type t )}

\begin{indpar}
Returns the base type or underlying type of the enumeration type {\tt t}.
\end{indpar}

{\tt function intwrd r = \ttstdkey{enum direction of} ( type t )}

\begin{indpar}
Returns the {\em enum-direction} of the enumeration type {\tt t}.
{\tt -1} is returned if the direction is `{\tt previous}',
{\tt +1} is returned if the direction is `{\tt next}',
and {\tt 0} is returned if the direction is not given.
\end{indpar}

{\tt function $I$ r = \ttstdkey{first enum of} ( type t )} \\
{\tt function $I$ r = \ttstdkey{last enum of} ( type t )}

\begin{center}
where $I$ is the most specific type (\pagref{MORE-SPECIFIC-RELATION})
in the set \\
\TT{unswrd     intwrd     unsmax     intmax} \\
such that both the {\em first-enum} and the {\em last-enum} \\
of enumeration type {\tt t} are convertible to $I$
\end{center}

\begin{indpar}
Returns the {\em first-enum} or {\em last-enum} of the enumeration type {\tt t}.
\end{indpar}

\end{indpar}

Enumeration values can be assigned by assignment statements of the form
\begin{indpar}
\emkey{enum-assignment}
    \begin{tabular}[t]{rl}
    ::= & {\em enum-type-name} ~ {\em enum-constant-name}\TT{ = next enum} \\
    $|$ & {\em enum-type-name} ~ {\em enum-constant-name}\TT{ = previous enum}
    \end{tabular}
\\[0.5ex]
\emkey{enum-constant-name} ::= {\em variable-name}
		~~~~~ [see \pagref{VARIABLE-NAME}]
\end{indpar}

These statements invoke one of the builtin functions:
\begin{indpar}
{\tt function $T$ r = $ma$\QMARK{} \ttkey{next enum}} \\
{\tt function $T$ r = $ma$\QMARK{} \ttkey{previous enum}}
\begin{center}
where $T$ is the {\em enum-type-name} and $ma$ is its
{\em module-abbreviation}, if any
\end{center}


\end{indpar}

Within a compilation the compiler assigns the value {\em first-enum}
to the first constant named in a `\TT{next enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in increasing order.
It is an error if `\TT{next~enum}'
would return a value beyond the {\em last-enum} value in a range.

Similarly the compiler assigns the value {\em last-enum}
to the first constant named in a `\TT{previous enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in decreasing order.
It is an error if `\TT{previous~enum}'
would return a value below the {\em first-enum} value in a range.

It is also an error if for a given type the same value is returned
by some \TT{next~enum} and also by some \TT{previous~enum}.

In memory an enumeration value is represented by an integer value
of the underlying type of the enumeration value's enumeration type.
This is called the `\mkey{underlying value}{of enumeration value}'
of the enumeration value.

The following unchecked conversions between enumeration values are builtin:
\begin{indpar}

{\tt function \TT{*UNCHECKED*} $E1$ r = $E1$ ( $E2$ v )}
\begin{center}
where $E1$ and $E2$ are both enumeration types
and $E1$ and $E2$ have the same underlying type
\end{center}
\begin{indpar}
These conversions do nothing but change the type of the value.
\end{indpar}

\end{indpar}

The enumeration value also has a
numeric value in the range
{\tt [}{\em first-enum}{\tt ,} {\em last-enum}{\tt ]}, which is
called the `\mkey{range value}{of enumeration value}' of the
enumeration value.  The difference between the underlying value
and the range value of an enumeration value is a constant
called the `\mkey{enumeration offset}{of enumeration type}' of
the enumeration type.

In order to represent range values the `\mkey{range type}{of enumeration type}'
is used.
This is the most specific type (\pagref{MORE-SPECIFIC-RELATION})
$R$ in the set \\
\centerline{\TT{unswrd     intwrd     unsmax     intmax}}
such that both the {\em first-enum} and the {\em last-enum}
of the enumeration type are implicitly convertible to $R$.

In order to represent enumeration offset the
`\mkey{offset type}{of enumeration type}' is used.
This is the most specific type (\pagref{MORE-SPECIFIC-RELATION})
$O$ in the set \\
\centerline{\TT{unswrd     intwrd     unsmax     intmax}}
such that values of either the underlying type or the range type
of the enumeration type are implicitly convertible to $O$.

The following builtin functions can be used to find
these values:

\begin{indpar}

{\tt function $U$ r = $ma$\QMARK{} \ttkey{underlying value of} ( $E$ v )} \\
{\tt function $R$ r = $ma$\QMARK{} \ttkey{range value of} ( $E$ v )}

\begin{center}
where $E$ is an {\em enum-type-name}, 
$ma$ is the {\em module-abbreviation} of $E$ if any, \\
$U$ is the underlying type of $E$,
and $R$ is the range type of $E$
\end{center}
\begin{indpar}
The underlying value or range value of {\tt v} is returned.
\end{indpar}

{\tt function $O$ r = \ttstdkey{enumeration offset of} ( type t )} \\
{\tt function type r = \ttstdkey{range type of} ( type t )} \\
{\tt function type r = \ttstdkey{offset type of} ( type t )}

\begin{center}
where {\tt t} is an enumeration type and $O$ is its offset type
\end{center}
\begin{indpar}
The enumeration offset, range type, or offset type of {\tt t} is returned.
\end{indpar}

\end{indpar}

Thus for a value {\tt v} of an enumeration type $E$,
\begin{center}
\tt underlying value of ( v ) \begin{tabular}[t]{@{}l@{}}
                              = range value of ( v ) \\
			      + enumeration offset of ( $E$ )
			      \end{tabular}
\end{center}

If the base type of an enumeration type is a builtin integer type,
the integer value corresponding to {\em first-enum} is {\em first-enum}
itself, and similarly for {\em last-enum}.  Thus the enumeration offset
is zero and we have the following example:
\begin{indpar}\begin{verbatim}
define type E as int32 with enum range [1 .. 20]
    // Now enumeration offset of (E) == 0
E C1 = next enum
    // Now underlying value of (C1) == 1
E C2 = next enum
    // Now underlying value of (C2) == 2
E C3 = previous enum
    // Now underlying value of (C3) == 20
E C4 = previous enum
    // Now underlying value of (C4) == 19
\end{verbatim}\end{indpar}

The enumeration offset of an {\em enum-type-name} is defined in general
as per the following cases:

\begin{indpar}
\begin{itemlist}
\item[\TT{define type} {\em qualifier-name}\STAR{} {\em enum-type-name}~~%
    \TT{as}~~{\em integer-type-expression} \ldots{}] ~\\
The enumeration offset of the {\em enum-type-name} equals \TT{0}.
\item[\TT{define type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em enum-type-name}~~\TT{as}~~%
              \TT{next}~~{\em enum-type-expression} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Has the effect of compiling the statements:
\begin{center}
\begin{tabular}{l}
{\em base-enum-type-name} {\tt ~V0~~=~~next enum} \\
{\em base-enum-type-name} {\tt ~V1~~=~~next enum} \\
{\em base-enum-type-name} {\tt ~V2~~=~~next enum} \\
\ldots\ldots\ldots \\
{\em base-enum-type-name} {\tt ~V$n$~~=~~next enum} \\
\end{tabular}
\end{center}
where $n$ = {\em last-enum} - {\em first-enum}, and then setting
\begin{center}
\TT{enumeration offset of (}{\em enum-type-name}\TT{)} = \\
{\tt ~~~~underlying value of (V0)~-~}{\em first-enum}
\end{center}
\item[\TT{define type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em enum-type-name}~~\TT{as}~~%
              \TT{previous}~~{\em enum-type-expression} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Has the effect of compiling the statements:
\begin{center}
\begin{tabular}{l}
{\em base-enum-type-name} {\tt ~V0~~=~~previous enum} \\
{\em base-enum-type-name} {\tt ~V1~~=~~previous enum} \\
{\em base-enum-type-name} {\tt ~V2~~=~~previous enum} \\
\ldots\ldots\ldots \\
{\em base-enum-type-name} {\tt ~V$n$~~=~~previous enum} \\
\end{tabular}
\end{center}
where $n$ = {\em last-enum} - {\em first-enum}, and then setting
\begin{center}
\TT{enumeration offset of (}{\em enum-type-name}\TT{)} = \\
{\tt ~~~~underlying value of (V0)~-~}{\em last-enum}
\end{center}
\end{itemlist}
\end{indpar}

The above is exemplified by:
\begin{indpar}\begin{verbatim}
define type E1 as int32 with enum range [1 .. 20]
    // Now enumeration offset of (E1) == 0
E1 C1 = previous enum
    // Now range value of (C1) == 20
    // Now underlying value of (C1) == 20
define type E2 as previous E1 with enum range [1 .. 10]
    // Now enumeration offset of (E2) == 9
E2 C2 = next enum 
    // Now range value of (C2) == 1,
    // Now underlying value of (C2) == 10
E2 C3 = previous enum 
    // Now range value of (C3) == 10,
    // Now underlying value of (C3) == 19
define type E3 as next E2 with enum range [1 .. 5]
    // Now enumeration offset of (E3) == 10
E3 C4 = next enum 
    // Now range value of (C4) == 1,
    // Now underlying value of (C4) = 11
\end{verbatim}\end{indpar}

The following builtin functions allow comparison and subtraction
of enumeration values:

\begin{indpar}

{\tt function bool r = $ma$\QMARK{} ( $E$ v1 ) "$cop$" ( $E$ v1 )}

\begin{center}
where $E$ is an enumeration type, \\
$ma$ is the {\em module-abbreviation} of $E$ if any, \\
and $cop$ is
\ttmkey{<}{of enum values}, \ttmkey{<=}{of enum values},
\ttmkey{==}{of enum values}, \ttmkey{!=}{of enum values},
\ttmkey{=>}{of enum values}, or \ttmkey{>}{of enum values}.
\end{center}
\begin{indpar}
Returns {\tt range value of (v1) "$cop$" range value of (v2)}.
\end{indpar}

{\tt function $R$ r =
    $ma$\QMARK{} ( $E$ v1 ) "\ttmkey{-}{of enum values}" ( $E$ v1 )}
\begin{center}
where $E$ is an enumeration type, \\
$ma$ is the {\em module-abbreviation} of $E$ if any, \\
and $R$ is $E$'s range type
\end{center}
\begin{indpar}
Returns {\tt range value of (v1) "-" range value of (v2)}.
\end{indpar}

\end{indpar}

Two enumeration values of different types
may be compared or subtracted if they can be implicitly
converted to a common enumeration or integer type.

The following are builtin enumeration types:
\begin{indpar} \tt
define types: \\
\TS~~~~\ttstdkey{type}~as unswrd with enum [0~..] \\
\TS~~~~\ttstdkey{qualifier}~as unswrd with enum [0~..] \\
define abbreviations: \\
\TS~~~~\ttkey{type} \ABV{} `std type' \\
\TS~~~~\ttkey{qualifier} \ABV{} `std qualifier' \\
\\[1ex]
type \ttstdkey{missing type}~= next enum // 0 \\
function std type r = \ttstdmkey{missing}{type}: \\
\TS~~~~r = std missing type
\\[1ex]
qualifier~\ttstdkey{missing qualifier}~= next enum // 0 \\
function std qualifier r = \ttstdmkey{missing}{qualifier}: \\
\TS~~~~r = std missing qualifier
\end{indpar}

Builtin types not mentioned above, such as `\TT{void}' and `\TT{int32}',
are given unspecified (i.e., implementation dependent)
`\TT{type}' enumeration values.
Similarly builtin qualifiers, e.g.~\TT{*READ*}, are given
unspecified `\TT{quali\-fier}' enumeration values.  
The `\TT{range value of}' function above
can be used to find the range value of an
enumeration constant, but unspecified builtin values may differ from
one compilation or program to the next.

Enumeration values are assigned within a compilation in
the order that {\em enum-assignments} are compiled.
Enumeration values are assigned during program initialization
according to the order
that code files containing the {\em enum-assignments} are initialized.
The program initialization
and compile values assigned by an {\em enum-assignment}
may differ.

However, within a code file, all assignments to an enumeration type
are done in the same order during program initialization as during compilation.
Thus values assigned within the same code file can be assumed to
have the same relative values at compile and run times.  Also,
compile and run values of a given enumeration type
can be assumed to be the same if \underline{all} values
of that enumeration type are assigned in the a single code file.

\subsection{Enumeration Set and List Types}
\label{ENUMERATION-SET-AND-LIST-TYPES}

For every enumeration type two additional types are created,
an enumeration set type and an enumeration list type.
An \key{enumeration set} is a set of enumeration values.
An \key{enumeration list} is a list of enumeration values.
These two new types do not have {\em type-names},
but they can be discovered by the following functions:

\begin{indpar}

{\tt function type r = \ttstdkey{set of} ( type E )} \\
{\tt function type r = \ttstdkey{list of} ( type E )}
\begin{indpar}
Returns the type whose values are sets or lists
of elements of type {\tt E}, where
{\tt E} must have an integer underlying type.
\end{indpar}

\end{indpar}

These types can be given type names by
{\em type-name-declarations} (\pagref{TYPE-NAME-DECLARATION}) of the form
\begin{indpar}
{\tt define type }{\em type-name}{\tt ~as type name of set of ( $E$ )} \\
{\tt define type }{\em type-name}{\tt ~as type name of list of ( $E$ )}
\end{indpar}
where $E$ is the element type.

Note that the element type of an enumeration set or list can be
a builtin integer type or a non-enumeration defined type
with a builtin integer underlying type.

The syntax
for enumeration set and list constants is:
\begin{indpar}
\emkey{enum-set-constant}\label{ENUM-SET-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{~\}} \\
    $|$ &\TT{\{} {\em enum-item}
                   \{ \TT{,} {\em enum-item} \}\STAR{} \TT{\}} \\
    \end{tabular} \\
\emkey{enum-list-constant}\label{ENUM-LIST-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{[~]} \\
    $|$ &\TT{[} {\em enum-item}
                   \{ \TT{,} {\em enum-item} \}\STAR{} \TT{]} \\
    \end{tabular} \\
\emkey{enum-item}
    ::= {\em enum-value} $|$ {\em enum-range} \\
\emkey{enum-range}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em enum-value}~~~\TT{..}~~~{\em enum-value} \\
    $|$ & {\em enum-value}~~~\TT{..} \\
    $|$ & \TT{..}~~~{\em enum-value} \\
    \end{tabular} \\
\emkey{enum-value} ::= {\em expression} evaluating at compile-time to
			an enumeration or integer value
\end{indpar}

If the {\em enum-values} in an {\em enum-set-constant} or
{\em enum-list-constant} have different
types, and these are defined types or enumeration types,
implied conversions from these to their base types
are inserted until all have the same defined type, enumeration type,
or builtin integer type,
which is called the
`\key{common element type}'\label{COMMON-ELEMENT-TYPE}
of the set or list.
This is the most specific type to which all the set
or list
elements can be converted by implied conversions
(see \pagref{MORE-SPECIFIC-RELATION}).
It is an error
if this cannot be done because some of the types have no implied
conversion to their base type defined for them.
The type of an enumeration set or list is the set or list type
defined for this common element type.

An {\em enum-range} designates the two values given and all
values in between.
After implied conversion, if the first {\em enum-value} in an {\em enum-range}
is greater than the second {\em enum-value} in the {\em enum-range},
the set is empty.  If the first or second {\em enum-value} of
an {\em enum-range} is omitted, it is taken to be the lower or upper
limit of the enumeration type of the non-omitted {\em enum-value}.

The order in which values are given in an {\em enum-set-constant}
does not matter.  Overlapping and adjoining ranges are implicitly
combined.\footnote{Internally an enumeration set may be stored as a
sorted list of integers with binary indicators specifying when all
the values between one integer and the next integer are to be included
in the set.}
Thus
\begin{indpar}\begin{verbatim}
define type X as uns8 with enum range [1 .. 20]
X X1 = next enum
X X2 = next enum
. . . . . . . . . .
X X20 = next enum

// Then:
//
//    { X1, X5, X2, X10 .. X16, X19 .. X20, X15 .. X18 }
// == { X1, X2, X5, X10 .. X20 }
\end{verbatim}\end{indpar}

The order in which values are given in an {\em enum-list-constant}
does matter, and ranges are not combined.  Thus in the above
example `{\tt [X1, X2] != [X2, X1]}' and `{\tt [X1, X1] != [X1]}'.

Enumeration set and list values are used in logical expressions that
condition function lookup.  For example,
\begin{indpar}\begin{verbatim}
T v = signed max (| type T |) ( T v1, T v2 )
      [| T is in { int8, int16, int32, int64, int128 } |]:
    . . . . . . . . . . .
\end{verbatim}\end{indpar}

defines a function that takes only signed integer type
arguments, and not unsigned integer type arguments.
The logical expression inside \TT{[|~|]} must be satisfied
for the function definition to match a function call, and
the type argument {\tt T}, which is implied and need not be
given in the function call, must be in the given set of
types, where types are values of the enumeration type `\TT{type}'
(see Section~\itemref{TYPE-VALUES}).

The information about enumeration set and list types can be determined
at compile-time by:

\begin{indpar}
{\tt function bool r = \TT{std} ( type T ) \TT{is enumeration set type}%
                                    \ttstdindex{is enumeration set type}}
\begin{indpar}
Returns \TT{true} if {\tt T} is an enumeration set type and \TT{false}
otherwise.
\end{indpar}

{\tt function bool r = \TT{std} ( type T ) \TT{is enumeration list type}%
                                    \ttstdindex{is enumeration list type}}
\begin{indpar}
Returns \TT{true} if {\tt T} is an enumeration list type and \TT{false}
otherwise.
\end{indpar}

{\tt function type r = \ttkey{element type of} ( type T )}
\begin{indpar}
Returns the element type of an enumeration set or list type {\tt T}.
\end{indpar}

\end{indpar}

The following are builtin enumeration set types:
\begin{indpar} \tt
define types: \\
\TS~~~~\ttstdkey{types} as set of type \\
\TS~~~~\ttstdkey{qualifiers} as set of qualifier \\
define abbreviations: \\
\TS~~~~\ttkey{types} \ABV{} `std types' \\
\TS~~~~\ttkey{qualifiers} \ABV{} `std qualifiers'
\end{indpar}

The following unchecked conversions between enumeration
set types and enumeration list types are builtin:
\begin{indpar}
{\tt function \TT{*UNCHECKED*} $T1$ r = $T1$ ( $T2$ v )}
\begin{center}
where $T1$ and $T2$ are either both enumeration set types or both
enumeration list types \\
and the element types of $T1$ and $T2$ have the same underlying type
\end{center}
\begin{indpar}
These conversions do nothing but change the type of the value.
\end{indpar}
\end{indpar}

Variables with compile-type enumeration set or list values can be defined.
If $S$ is an enumeration set type with element type $E$,
$L$ is an enumeration list type with element type $E$,
and $ma$ is the {\em module-abbreviation} of the original type name
of $E$ if any,
then the following functions are defined at compile-time
(but may not be defined at run-time):

\begin{indpar}
{\tt function $S$ r =
    $ma$\QMARK{} ($S$ v1) "\ttmkey{+}{enumeration set union}" ( $S$ v2 )}
\begin{indpar}
Returns the union of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $S$ r =
    $ma$\QMARK{} ($S$ v1) "\ttmkey{*}{enumeration set intersection}" ( $S$ v2 )}
\begin{indpar}
Returns the intersection of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $S$ r =
    $ma$\QMARK{} ($S$ v1) "\ttmkey{-}{enumeration set difference}" ( $S$ v2 )}
\begin{indpar}
Returns the set difference of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function bool r =
    $ma$\QMARK{} ($E$ e) \ttmkey{is in}{enumeration set} ($S$ s)}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the set {\tt s}, and
\TT{false} otherwise.
\end{indpar}

{\tt function $S$ r =
    $ma$\QMARK{} ($E$ e) "\ttmkey{+}{enumeration set union}" ($S$ s)}
\begin{indpar}
Returns union of \{{\tt e}\} and {\tt s}.
\end{indpar}

{\tt function $S$ r =
    $ma$\QMARK{} ($S$ s) "\ttmkey{+}{enumeration set union}" ($E$ e)}
\begin{indpar}
Returns union of \{{\tt e}\} and {\tt s}.
\end{indpar}

{\tt function $S$ r =
    $ma$\QMARK{} ($S$ s) "\ttmkey{-}{enumeration set union}" ($E$ e)}
\begin{indpar}
Returns the set difference of {\tt s} and \{{\tt e}\}.
\end{indpar}

{\tt function unswrd r = $ma$\QMARK{} \ttmkey{size of}{enumeration set} ($S$ s)}
\begin{indpar}
Returns the size of the set {\tt s} (number of elements in {\tt s}).
\end{indpar}

{\tt function $E$ r = $ma$\QMARK{} ($S$ s) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of enumeration set}
\begin{indpar}
Returns the {\tt i+1}'st element of {\tt s}, where the elements
of {\tt s} are taken in the order of their integer underlying values.
It is an error if {\tt i => size of (s)}.
\end{indpar}

{\tt function $S$ r = $S$ ($L$ ls)}
\begin{indpar}
Convert the enumeration list {\tt ls} to an enumeration set,
removing duplicate elements.
\end{indpar}

{\tt function $L$ r = $ma$\QMARK{} ($L$ ls1)
		    "\ttmkey{+}{enumeration list concatenation}" ($L$ ls2)}
\begin{indpar}
Returns the concatenation of {\tt ls1} and {\tt ls2}.
\end{indpar}

{\tt function $L$ r = $ma$\QMARK{} ($L$ ls)
                        "\ttmkey{-}{enumeration list difference}" ($S$ s)}
\begin{indpar}
Returns the list made by removing all elements from {\tt ls} that
are in {\tt s}.
\end{indpar}

{\tt function bool r = $ma$\QMARK{} ($E$ e)
                        \ttmkey{is in}{enumeration list} ($L$ ls)}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the list {\tt ls}, and
\TT{false} otherwise.
\end{indpar}

{\tt function $L$ r = $ma$\QMARK{} ($E$ e)
                        "\ttmkey{+}{enumeration list prepend}" ($L$ ls)}
\begin{indpar}
Returns the list made by prepending {\tt e} to {\tt ls}.
\end{indpar}

{\tt function $L$ r = $ma$\QMARK{} ($L$ ls)
                        "\ttmkey{+}{enumeration list append}" ($E$ e)}
\begin{indpar}
Returns the list made by appending {\tt e} to {\tt ls}.
\end{indpar}

{\tt function $L$ r = $ma$\QMARK{} ($L$ ls)
                        "\ttmkey{-}{enumeration list remove}" ($E$ e)}
\begin{indpar}
Returns the list made by removing the all occurrences of
{\tt e} in {\tt ls}.
\end{indpar}

{\tt function unswrd r =
    $ma$\QMARK{} \ttmkey{length of}{enumeration list} ($L$ ls)}
\begin{indpar}
Returns the length of the list {\tt ls} (number of elements in {\tt ls}).
\end{indpar}

{\tt function $E$ r = $ma$\QMARK{} ($L$ ls) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of enumeration list}
\begin{indpar}
Returns the {\tt i+1}'st list element of {\tt ls}.
It is an error if {\tt i => length of (ls)}.
\end{indpar}

{\tt function $L$ r = $L$ ($S$ s)}
\begin{indpar}
Convert the enumeration set {\tt s} to an enumeration list,
listing the elements of {\tt s} in order of their underlying values.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time enumeration
set and list variables.  If an implementation does
not implement run-time enumeration set and list variables,
enumeration set and list values computed at compile-time may
not be garbage collectible during the compilation.

\subsection{Type Values}
\label{TYPE-VALUES}

The type `\TT{type}' is a builtin enumeration type declared
by the builtin equivalent of:
\begin{indpar} \tt
define type \ttstdkey{type} as unswrd with enum [0~..] \\
define abbreviation \ttkey{type} \ABV{} `std type' \\
type \ttstdkey{missing type} = next enum // 0 \\
type \ttstdkey{type} = next enum // 1 \\
function std type r = std \ttmkey{missing}{type}: \\
\hspace*{3em}r = std missing type
\end{indpar}
Each type is associated with a unique enumeration value
of type `\TT{type}', and this value can be used at both
compile and run time to test whether two `\TT{type}'s are
equal.

New types are declared by statements of the form:
\begin{center}
\tt \ttkey{define type} {\em type-name} \ldots{}
\end{center}
The {\em type-name} of a type can be used (1) before a {\em variable-name}
in a declaration, (2) as the name of an enumeration value in an
expression, or (3) as the name of a function in a {\em function-call}.

In general, values of one type $T1$ may be \key{explicitly converted} to another
type $T2$ if and only if an inline function with prototype:
\begin{center} \tt
function \ldots~$T2$ r = $T2$ ( \ldots~$T1$ v )
\end{center}
is defined, where the `\ldots{}' denote arbitrary qualifiers.
This function is not builtin, except in the case where
$T2$ and $T1$ are both names for the same type (and possibly the
same name), and in this
case the function just copies the value without changing its
type.

Given assignment statements
\begin{center}
\begin{tabular}{l}
\tt $Tw$ w = \ldots \\
\tt $Tu$ u = w \\
\end{tabular}
\end{center}

the compiler will assign the value of {\tt w} to the variable {\tt v}
using `\key{direct assignment}'\label{DIRECT-ASSIGNMENT-TYPE} if possible, or
if not possible, will rewrite the second statement as
\begin{center}
\tt $Tu$ u = assign ( w )
\end{center}\label{EXPLICIT-ASSIGN}
in which case the assignment is said to be an
`\key{implied conversion}'\label{IMPLIED-CONVERSION}.  Direct assignment
can only be used if \skey{direct assignment rule}s are
satisfied, and one of these is
\begin{indpar}\begin{itemize}
\item[(DA1)]\label{DIRECT-ASSIGNMENT-TYPE-RULE}
In `{\tt u = w}' the types of {\tt u} and {\tt w}
must be identical, and if the assignment is \underline{not} a result
assignment (\pagref{RESULT-ASSIGNMENT}), this type must not have
\TT{void} as its underlying type.
\end{itemize}\end{indpar}
When direct assignment is used, the value of {\tt w} is copied
exactly to {\tt u} (or if there is no value because the common
type is derived from \TT{void}, nothing is done).
The other direct assignment rules involve qualifiers
(\pagref{DIRECT-ASSIGNMENT-QUALIFIER-RULES}).

The following is an example of an implied conversion {\tt assign}
function:

\begin{indpar}\begin{verbatim}
define type id as int32

// Allow id's to be implicitly converted to int32's:
//
function Qs int32 r = assign (| qualifiers Qs |) ( Qs id v ):
    *UNCHECKED* Qs r2 = int32 ( v )
    r = r2

// Example usage:
//
id file = ...
if file == 0:
    ...
\end{verbatim}\end{indpar}

Here {\tt Qs} is an implicit argument that copies the value qualifiers
(see \itemref{QUALIFIERS}) of the {\tt assign} prototype
result variable to the function
prototype result and prototype argument variables
(see \itemref{FUNCTION-PROTOTYPES-AND-CALLS}).
This code makes use of a builtin unchecked conversion from \TT{id} to \TT{int32}
that is created when by the {\tt define type} statement
(see \pagref{DEFINED-TYPE-UNCHECKED-CONVERSIONS}).

Implied {\tt assign}'s are not cascaded.  More specifically, in
\begin{center}
\tt $Tu$ u = assign ( w )
\end{center}
if {\tt assign} is explicitly written
and its result cannot be directly
assigned to {\tt u}, then an implied {\tt assign} would be added
making the statement
\begin{center}
\tt $Tu$ u = assign ( assign ( w ) )
\end{center}
But this is extra {\tt assign} is \underline{not} added
if the first {\tt assign} is implied.

Although the compiler cannot check this, it should be true
that if there are two different ways to implicitly convert from
one type to another, both ways should produce the same
result.  For example:
\begin{indpar}\begin{verbatim}
int16 v1 = ...
int32 v2 = v1
float64 v3 = v2
    // Implied conversions are v1 ---> v2 ---> v3.
float64 v4 = v1
    // Implied conversion is v1 ---> v4.

// v3 == v4 should be true.
\end{verbatim}\end{indpar}

There is a notion of one type being `\mkey{more specific}{type}' than
another type, and the relation of being more specific is required
to be a partial order compatible with implicit conversion.  Symbolically
we say that
\begin{center}
{\tt $T1~~\CNV~~T2$}
\end{center}%
\label{MORE-SPECIFIC-RELATION}
if $T1$ is more specific than $T2$, and that this is true if 
there exists some function with prototype of the form

\begin{center} \tt
function \begin{tabular}[t]{@{}l@{}}
	 \ldots{}~$T2$ r =
	 $ma$\QMARK{} \ttkey{assign}
	 ( \ldots{}~$T1$ v )
	 \end{tabular}
\end{center}
where \ldots{}~denotes possible qualifiers, and
the names {\tt r} and {\tt v} may be different
in the actual function prototype.
The notion of more specific
types is used by the
call-prototype matching rule
\ref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}
on page \pagref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}
to disambiguate function calls.

If for a set of types $\{T1,T2,\ldots\}$ there is a unique
type $T$ such that $T1\CNV T$, $T2\CNV T$, \ldots{}, then
$T$ is called the `\key{greatest lower bound}'\label{GREATEST-LOWER-BOUND}
of the set of types.

In general $T1~~\CNV~~T2$ implies that there is an implied conversion
of the above form from $T1$ to $T2$, but there are exceptions.
The builtin exceptions
are
\begin{center}
\begin{tabular}{lll}
\tt unswrd	& $\CNV$ & \tt intwrd \\
\tt intwrd	& $\CNV$ & \tt unsmax \\
\tt unsmax	& $\CNV$ & \tt intmax \\
\tt intmax	& $\CNV$ & \tt floatwrd \\
\end{tabular}
\end{center}
Note that this implies that
\begin{center}
\tt unswrd $\CNV$ intwrd $\CNV$ unsmax $\CNV$ intmax
           $\CNV$ floatwrd $\CNV$ floatmax
\end{center}
The only use of these exceptions is in
rule \ref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}
on page \pagref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}
by which the compiler favors function prototypes with
more specific argument types.

Functions can be overloaded based on the number and types
of their arguments, but also on the values of arguments that
are known at compile time.  For example, using this last,
many function declarations of the form
\begin{center}
\begin{tabular}{l}
{\tt function unsadr r = $ma$\QMARK{} size of ( type t == $T$ ):} \\
{\TS ~~~~r = $S$}
\end{tabular}
\end{center}
be coded, where $ma$ is the {\em module-abbreviation} of the
type name $T$, if any, and $S$ is the size in bytes of values of type $T$.
As a consequence `{\tt size of ($T$)}' can be used at compile
time to determine the size in bytes of values of an arbitrary type
$T$.

It is also possible to define a default function that is used when
function declarations with known prototypes are not applicable.
For example, the following declarations are builtin:
\begin{indpar}\begin{verbatim}
function bool r = std is uns ( type t == uns8 ):
    return true
function bool r = std is uns ( type t == uns16 ):
    return true
function bool r = std is uns ( type t == uns32 ):
    return true
function bool r = std is uns ( type t == uns64 ):
    return true
function bool r = std is uns ( type t == uns128 ):
    return true
function bool r = std is uns ( type t ):
    return false
\end{verbatim}\end{indpar}
where the last declaration is the default when none of the others
apply.  See
rule \ref{REQUIRED-ARGUMENTS-PREFERRED},
\pagref{REQUIRED-ARGUMENTS-PREFERRED}.
In this case we refer to the last declaration as the
`\key{default declaration}' and say that the default declaration
returns \TT{false}.

The following are defined automatically for a type $T$, where
$ma$ is the {\em module-abbreviation} of the module containing
the declaration of $T$, if $T$ has such a {\em module-abbreviation}.
Only some of these functions have a default declaration, but for
those that do, the default declaration is in the \TT{std} module.

\begin{indpar}
{\tt function bool r = \TT{std} ( type t == $T$ )
                                  \TT{is uns}\ttstdindex{is uns}} \\
{\tt function bool r = \TT{std} ( type t == $T$ )
                                  \TT{is int}\ttstdindex{is int}} \\
{\tt function bool r = \TT{std} ( type t == $T$ )
                                  \TT{is float}\ttstdindex{is float}} \\
{\tt function bool r = \TT{std} ( type t == $T$ )
                                  \TT{is numeric}\ttstdindex{is numeric}} \\
{\tt function bool r = \TT{std} ( type t == $T$ )
                                  \TT{is implemented numeric}%
				  \ttstdindex{is implemented numeric}}
\begin{indpar}
These functions test {\tt t} in the current scope to see if it is
an \TT{uns$x$} type, an \TT{int$x$} type, a \TT{float$x$} type,
any of these types, or any of these types for which arithmetic
and comparison operators are
`implemented' (see \pagref{IMPLEMENTED}).
The default declaration returns \TT{false}.
\end{indpar}
\end{indpar}

\begin{indpar}
{\tt function type r = $ma$\QMARK{} \ttkey{base type of} ( type t == $T$ )}
\begin{indpar}
Returns the base type of the type {\tt t}.  For defined and enumeration
types this is the associated base type from the defined type's
declaration.
The default declaration returns {\tt t} itself.
\end{indpar}

{\tt function type r = $ma$\QMARK{} \ttkey{underlying type of}
					( type t == $T$ )}
\begin{indpar}
If {\tt t} is a defined or enumeration type, returns
\begin{center}
{\tt underlying type of ( base type of ( t ) )}
\end{center}
The default declaration returns {\tt t} itself.
\end{indpar}

{\tt function unsadr r = $ma$\QMARK{} \ttkey{size of} ( type t == $T$ )}
\begin{indpar}
Returns the number of bytes in a value of type {\tt t}.
For defined and enumeration types it is the size of their underlying type
The size of \TT{void} is \TT{0}.
There is \underline{no} default declaration.
\end{indpar}

{\tt function unsadr r = $ma$\QMARK{} \ttkey{alignment of} ( type t == $T$ )}
\begin{indpar}
Returns the alignment of {\tt t}, a strictly positive integer.
The address of a value of type {\tt t} in RAM should
optimally be a multiple of the alignment.
The alignment of builtin types is their size.
For defined and enumeration types it is the alignment of their underlying type.
There is \underline{no} default declaration.
\end{indpar}

{\tt function bool r = $ma$\QMARK{} \ttkey{zero value OK for} ( type t == $T$ )}
\begin{indpar}
Returns \TT{true} if a memory location holding a value of type $T$ can be
initialized to all zero bits.  Returns \TT{false} otherwise.
Must return \TT{false} if the underlying type of $T$ is \TT{void}.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{min value}} \\
{\tt function $T$ r = $ma$\QMARK{} \ttkey{max value}}
\begin{indpar}
Returns the minimum or maximum value of a type $T$.
These are defined only for number types and enumeration types,
and for enumeration types the values returned are the limits of
the type's {\em enum-range}.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{min unassigned value}} \\
{\tt function $T$ r = $ma$\QMARK{} \ttkey{max unassigned value}}
\begin{indpar}
Returns the minimum or maximum values not yet assigned to an
enumeration type $T$ by an {\em enum-assignment}.  Values
assigned by unchecked conversions are not considered.  If
no values have been assigned, the enumeration value corresponding
to {\em first-enum} is returned by `\TT{min unassigned value}'
and the enumeration value corresponding
to {\em last-enum} is returned by `\TT{max unassigned value}'.

These are defined only for enumeration types,

These values may change when more code is compiled or initialized.
You may only assume that constants of type $T$ whose values have
already been compiled or initialized are within
ranges bounded by these values, i.e., in the ranges:
\begin{center}
{\tt [ min value, min unassigned value )} \\
{\tt ( max unassigned value, max value ]}
\end{center}
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{missing value}}
\begin{indpar}
Returns a suitable missing value for type $T$.
Defined to return the largest possible value for builtin unsigned
integer types, the smallest (most negative) possible value for
builtin signed integer types, and \TT{NaN} for builtin
floating point number types.
May be defined by user for defined types.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{default value}}%
    \label{DEFAULT-VALUE-OF-TYPE}
\begin{indpar}
Returns a suitable default value for type $T$.
Defined to return \TT{0} for builtin number types.
May be defined by user for defined types.  For use by allocators,
such as a function that allocates a vector whose
elements are of type $T$, and the function wishes to give the elements an
initial default value.
\end{indpar}

{\tt function *UNCHECKED* $Qs$ $T$ r = $ma$\QMARK{} \ttalkey{NO}{VALUE}}%
    \label{NO-VALUE}
\begin{indpar}
This is a special compile-time value that marks any variable
having it as not having a value that can be input to any builtin
operation that does not simply copy the value to another variable
(e.g., direct assignments, see \pagref{DIRECT-ASSIGNMENT-TYPE}).
It is implemented by simply not assigning any value to a variable
that the compiler knows has been assigned \TT{*NO* *VALUE*}, though
if the compiler cannot figure out if a value being copied is such
a value, the compiler will copy the value.

It is an error for an operation that does not simply copy the
value to another variable to attempt to process this value as input.
If the compiler can discover that this is being done it is a compile
error, but otherwise it is an undetected error, hence an unchecked
code error.

This function is builtin for \underline{all} types $T$ and sets of
value qualifiers $Qs$.
\end{indpar}

\end{indpar}

The following function differs from the above in that it
consults an internal compiler database and does not depend
on multiple function declarations with specified argument values:

\begin{indpar}

{\tt function bool r = std ( type T1 ) "\ttkey{>}" ( type T2 )}
\begin{indpar}
Returns \TT{true} if and only if {\tt T1$\CNV$T2}, that is, $T1$ is
more specific than $T2$ (see \pagref{MORE-SPECIFIC-RELATION}).
\end{indpar}

\end{indpar}

\subsection{The Character Type}
\label{THE-CHARACTER-TYPE}

A `\key{character}' is a 32-bit UNICODE character.  It is
defined as the derived type:
\begin{indpar} \tt
define type~\ttstdkey{character}~as uns32 \\
define abbreviation~\ttkey{character}~\ABV~`std character'
\end{indpar}

A character constant has the syntax:
\begin{indpar}
\emkey{character-constant}\label{CHARACTER-CONSTANT}
    :::= \TT{C"}{\em character-representative}\TT{"} \\
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}

This constant has type \TT{character} and value equal to the
single character represented.

The following functions are builtin:

\begin{indpar}

{\tt function character r = \ttstdkey{character} ( uns32 c )}
\begin{indpar}
Returns the character with UNICODE character code equal to {\tt c}.
No check is made that {\tt c} is a legal UNICODE character code
or is non-zero.
\end{indpar}

{\tt function uns32 r = \ttstdkey{code} ( character c )}
\begin{indpar}
Returns the UNICODE character code of the character {\tt c}.
\end{indpar}

function Qs~uns32 r =
		      \begin{tabular}[t]{@{}l@{}}
                      \ttmkey{assign}{of character} \\
                      \TS~~~~(| qualifiers Qs |) ( Qs~character c )
                      \end{tabular}
\begin{indpar}
Implied conversion (\pagref{IMPLIED-CONVERSION})
of character {\tt c} to its UNICODE character code.

Because of this implied conversion,
characters can be compared using \TT{<}, \TT{<=}, \TT{==},
\TT{!=}, \TT{=>}, or \TT{>}.
\end{indpar}

{\tt function character r = std \ttmkey{NUL}{character value}}
\begin{indpar}
Returns \TT{C"<0>"},
the character with UNICODE code \TT{0} that is conventionally
used to represent the missing \TT{character} value.
\end{indpar}

\end{indpar}

\subsection{The String Type}
\label{THE-STRING-TYPE}

A `\key{string}' is a vector of characters, that is,
of 32-bit UNICODE characters.
It is defined as a derived type:
\begin{indpar} \tt
define type \ttstdkey{string} as adr \\
define abbreviation \ttkey{string} \ABV{} `std string'
\end{indpar}

A {\em quoted-string} lexeme is a constant of \TT{string} type
whose characters are those represented by the lexeme with
the addition of a \TT{NUL} character (code \TT{0}) at the end:
\begin{indpar}
\emkey{string-constant}\label{STRING-CONSTANT}
    :::= \TT{"}{\em character-representative\STAR{}}\TT{"} \\
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}


Strings are read-only, and their characters cannot be changed.

String variables and values are implemented at compile-time.
The following are compile-time functions involving strings:

\begin{indpar}

{\tt function string r =
    std \ttmkey{string}{of character} ( character c )}
\begin{indpar}
Returns the string containing the single character {\tt c}.
\end{indpar}

{\tt function string r =
    std \ttmkey{string}{of integer} ( intmax i )}
\begin{indpar}
Returns the string that is the decimal integer representation of
the integer {\tt i}.  The value returned contains no high order
zeros or commas.  Non-negative values have no sign.
\end{indpar}

{\tt function string r =
    std ( string s1 ) "\ttmkey{+}{of strings}" ( string s2 )}
\begin{indpar}
Returns the concatenation of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function bool r =
    std ( string s1 ) "\ttmkey{<}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{<=}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{==}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{!=}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{=>}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{>}{of strings}" ( string s2 )}
\begin{indpar}
Returns whether {\tt s1} is less than, less than or equal to,
equal to, not equal to, greater than or equal to, or greater than
{\tt s2}.  Ordering of strings is lexical (note ordering of
characters is by character code).
\end{indpar}

{\tt function string r = std \ttmkey{null}{string value}}
\begin{indpar}
Returns a particular zero length \TT{string} that is conventionally
used to represent the missing \TT{string} value.
Although the string is of zero length, it does have one character:
the \TT{NUL} character at its end.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{string} ( string s )}
\begin{indpar}
Returns the length of {\tt s}, the number of characters in {\tt s}
\underline{not counting} the \TT{NUL} character at the end.
\end{indpar}

{\tt function character r = std ( string s ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st character of {\tt s}.

It is a programming error if {\tt i > length of ( s )}.

If {\tt i == length of ( s )}
the \TT{NUL} at the end of the string is returned.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time string
variables.  If an implementation does
not implement run-time string variables,
string values computed at compile-time may
not be garbage collectible during the compilation.

\subsection{The Name Type}
\label{THE-NAME-TYPE}

A `\key{name}' value is a vector of strings.  If the value is
a legal name as defined in Section~\itemref{NAMES}, the
strings are its {\em name-items} with a \TT{null} string appended.
Note that {\em natural-number} {\em name-items} are represented
by strings of digits and not by integers.

An element of a name value may be any string, so name values
may not be legal source code {\em names} as defined on \pagref{NAME}.
When a name value is used as a {\em name} in a compilation,
it is a compilation error if the value is not a source code {\em name}.

The \TT{name} type is is defined as a derived type:
\begin{indpar} \tt
define type \ttstdkey{name} as adr \\
define abbreviation \ttkey{name} \ABV{} `std name'
\end{indpar}

A sequence of {\em name-items} in \TT{`~'} quotes is a \TT{name}
constant whose strings are the {\em name-items}
with the \TT{null} string appended:
\begin{indpar}
\emkey{name-constant}\label{NAME-CONSTANT}
    ::= \TT{`}{\em name-item}\STAR{}\TT{'} \\
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

Name values are read-only, and their elements cannot be changed.

Name variables and values are implemented at compile-time.
The following are compile-time functions involving names:

\begin{indpar}

{\tt function name r = \ttmkey{name}{of string} ( string s )}
\begin{indpar}
Returns the name containing just {\tt s} as its only {\em name-item}.
A \TT{null} is appended to the end of the name.
No check is made that {\tt s} is a legal {\em name-item}.
\end{indpar}

{\tt function name r = ( name n1 ) "\ttmkey{+}{of names}" ( name n2 )}
\begin{indpar}
Returns the concatenation of {\tt n1} and {\tt n2}.
\end{indpar}

{\tt function bool r = ( name n1 ) "\ttmkey{<}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{<=}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{==}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{!=}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{=>}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{>}{of names}" ( name n2 )}
\begin{indpar}
Returns whether {\tt n1} is less than, less than or equal to,
equal to, not equal to, greater than or equal to, or greater than
{\tt n2}.  Ordering of names is lexical.
\end{indpar}

{\tt function name r = std \ttmkey{null}{name value}}
\begin{indpar}
Returns a particular zero length \TT{name} that is conventionally
used to represent the missing \TT{name} value.
Although the name is of zero length, it does have one string,
the \TT{null} string at its end.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{name} ( name n )}
\begin{indpar}
Returns the length of {\tt n}, the number of strings in {\tt n}
\underline{not counting} the \TT{null} string at the end.
\end{indpar}

{\tt function string r = std ( name n ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st string of {\tt n}.

It is a programming error if {\tt i > length of ( n )}.

If {\tt i == length of ( n )}
the \TT{null} at the end of the name is returned.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time name
variables.  If an implementation does
not implement run-time name variables,
name values computed at compile-time may
not be garbage collectible during the compilation.

\subsection{Name Sets and Lists}
\label{NAME-SETS-AND-LISTS}

A \key{name set} is a set of names.
A \key{name list} is a list of names.  The syntax
for name set and list constants is:
\begin{indpar}
\emkey{name-set-constant}\label{NAME-SET-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{~\}} \\
    $|$ &\TT{\{} {\em name-value}
                   \{ \TT{,} {\em name-value} \}\STAR{} \TT{\}} \\
    \end{tabular} \\
\emkey{name-list-constant}\label{NAME-LIST-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{[~]} \\
    $|$ &\TT{[} {\em name-value}
                   \{ \TT{,} {\em name-value} \}\STAR{} \TT{]} \\
    \end{tabular} \\
\emkey{name-value} ::= {\em compile-time-name-expression}
\end{indpar}

The order in which names are given in a {\em name-set-constant}
does not matter, and duplicate names in the set are eliminated.
Thus
\begin{center}
`{\tt \{`X1', `X2'\} == \{`X2', `X1'\}}'\\
and\\
`{\tt \{`X1', `X1'\} == \{`X1'\}}'.
\end{center}

The order in which values are given in an {\em name-list-constant}
does matter, and duplicates are not combined.
Thus
\begin{center}
`{\tt [`X1', `X2'] != [`X2', `X1']}'\\
and\\
`{\tt [`X1', `X1'] != [`X1']}'.
\end{center}

Name set and list values are used in code expansions.
For example,
\begin{indpar}\begin{verbatim}
include for n in [`x[1]', `x[2]', `x[3]' ]:
    int n = 0
\end{verbatim}\end{indpar}

Name sets and lists can be stored in variables of the builtin name set
or list types:
\begin{indpar} \tt
define types: \\
\TS~~~~\ttstdkey{name set} as adr \\
\TS~~~~\ttstdkey{name list} as adr \\
define abbreviations: \\
\TS~~~~\ttkey{name set} \ABV{} `std name set' \\
\TS~~~~\ttkey{name list} \ABV{} `std name list'
\end{indpar}

The following \TT{name set} functions are builtin:

\begin{indpar}
{\tt function name set r = std (name set s1)
                           "\ttmkey{+}{name set union}" ( name set s2 )}
\begin{indpar}
Returns the union of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function name set r = std ( name set s1 )
                           "\ttmkey{*}{name set intersection}" ( name set s2 )}
\begin{indpar}
Returns the intersection of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function name set r = std ( name set s1 )
                           "\ttmkey{-}{name set difference}" ( name set s2 )}
\begin{indpar}
Returns the set difference of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function bool r = std (name e) \ttmkey{is in}{name set} ( name set s )}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the set {\tt s}, and
\TT{false} otherwise.
\end{indpar}

{\tt function name set r = std (name n)
                           "\ttmkey{+}{name set union}" ( name set s )}
\begin{indpar}
Returns union of \{{\tt n}\} and {\tt s}.
\end{indpar}

{\tt function name set r = std ( name set s )
                           "\ttmkey{+}{name set union}" (name n)}
\begin{indpar}
Returns union of \{{\tt n}\} and {\tt s}.
\end{indpar}

{\tt function name set r = std ( name set s )
                           "\ttmkey{-}{name set difference}" (name n)}
\begin{indpar}
Returns the set difference of {\tt s} and \{{\tt n}\}.
\end{indpar}

{\tt function unswrd r = std \ttmkey{size of}{name set} ( name set s )}
\begin{indpar}
Returns the size of {\tt s}, the number of names in {\tt s}.
\end{indpar}

{\tt function name r = std ( name set s ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st name of {\tt s}, where names in {\tt s}
are taken in sorted order.

It is a programming error if {\tt i => size of ( s )}.
\end{indpar}

{\tt function name set r = \ttstdkey{name set} ( name list ls )}
\begin{indpar}
Converts {\tt ls} from a list to a set, removing duplicate elements.
\end{indpar}

\end{indpar}

The following \TT{name list} functions are builtin:

\begin{indpar}
{\tt function \begin{tabular}[t]{@{}l@{}}
              name list r = \\
	      std (name list ls1)
                        "\ttmkey{+}{name list concatenation}" (name list ls2)
	      \end{tabular}}
\begin{indpar}
Returns the concatenation of {\tt ls1} and {\tt ls2}.
\end{indpar}

{\tt function \begin{tabular}[t]{@{}l@{}}
              name list r = \\
	      std (name list ls)
                        "\ttmkey{-}{name list difference}" (name set s)
	      \end{tabular}}
\begin{indpar}
Returns the list made by removing all elements from {\tt ls} that
appear anywhere in {\tt s}.
\end{indpar}

{\tt function bool r = std (name n) \ttmkey{is in}{name list} (name list ls)}
\begin{indpar}
Returns \TT{true} if {\tt n} is an element of the list {\tt ls}, and
\TT{false} otherwise.
\end{indpar}

{\tt function name list r = std (name n)
                        "\ttmkey{+}{name list prepend}" (name list ls)}
\begin{indpar}
Returns the list made by prepending {\tt n} to {\tt ls}.
\end{indpar}

{\tt function name list r = std (name list ls)
                        "\ttmkey{+}{name list append}" (name n)}
\begin{indpar}
Returns the list made by appending {\tt n} to {\tt ls}.
\end{indpar}

{\tt function name list r = std (name list s)
                        "\ttmkey{-}{name list remove}" (name n)}
\begin{indpar}
Returns the list made by removing the all occurrences of
{\tt n} in {\tt ls}.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{name list} ( name list ls )}
\begin{indpar}
Returns the length of {\tt ls}, the number of names in {\tt ls}.
\end{indpar}

{\tt function name r = std ( name list ls ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st name of {\tt ls}.

It is a programming error if {\tt i => length of ( s )}.
\end{indpar}

{\tt function name list r = \ttstdkey{name list} ( name set s )}
\begin{indpar}
Converts {\tt s} from a set to a list, where elements of {\tt s}
are listed in sorted order in the result.
\end{indpar}

\end{indpar}

\subsection{Contexts}
\label{CONTEXTS}

Contexts (\pagref{CONTEXT}) exist at compile-time and can be
stored in compile-time variables.  A context value designates a point
in the program code, i.e., a `\key{code point}'.

The \TT{context} type is
defined by
\begin{indpar} \tt
define type \ttstdkey{context} as adr \\
define abbreviation \ttkey{context} \ABV{} `std context'
\end{indpar}

{\em Block-assignment-statements} (\itemref{BLOCK-ASSIGNMENT-STATEMENTS})
can specify a \TT{context} in which to compile the statements of
their block.

The following functions compute contexts:

\begin{indpar}

{\tt function context r = \ttstdkey{current context}}
\begin{indpar}
Returns the context in effect just before
the statement containing the {\tt current con\-text} {\em function-call}.
\end{indpar}

{\tt function context r = \ttstdkey{call context}}
\begin{indpar}
Returns the context in effect just before
the statement containing the {\em function-call} whose
inline function expansion contains
the statement containing the {\tt call con\-text} {\em function-call}.
\end{indpar}

{\tt function context r = \ttstdkey{declaration context}}
\begin{indpar}
Returns the context in effect just before
the statement containing the {\em function-declar\-a\-tion} of the
inline function whose {\em function-call} expansion contains
the statement containing the {\tt call context} {\em function-call}.
\end{indpar}

\end{indpar}

Context values are needed at run-time if the program contains
compile-and-run statements (\pagref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}).

In order for a context value to be available at run-time, it
must be returned by one of these functions or be the context of
a compile-and-run statement.
If a context value is stored in a variable by one of these functions,
then it need not be available at run time if it can be proved that the
variable value will not be available at run time.%
\footnote{With modern memories it may be reasonable
to make all contexts available at runtime by storing them
in a disk file mapped into memory and paged in only as needed.}

\section{Qualifiers}
\label{QUALIFIERS}

Variables may be qualified by \skey{qualifier}s, which precede the
type when a variable is declared.  There are six builtin qualifiers:
\TT{*READ*}, \TT{*WRITE*}, \TT{*STACK*}, \TT{*UNCHECKED*},
\TT{*READABLE*}, and \TT{*WRITABLE*}.
These have special effects or special usage
described in Section~\itemref{BUILTIN-QUALIFIERS}.
There is also a builtin method for defining trace qualifiers which
have special effects.
Other qualifiers that have no special effects
may be defined, and are typically used to add an
additional layer of type checking that is somewhat orthogonal to
types.

There are also three pseudo-qulifiers,
\TT{*DEFERRED*}, \TT{*OPTIONAL*}, and \TT{*UNUSED*},
which are syntactically like qualifiers but are not semantically
qualifiers.

Syntactically {\em qualifier-names} immediately precede the {\em type-names}
that are before {\em variable-names}.  A simple example is:
\begin{indpar}\begin{verbatim}
implied value qualifier fee
function fee int32 result = F ( int32 value ):
    // Declares function F that computes a result of
    // with qualifier fee.
    //
    ... [Function body omitted] ...
function int32 result = G ( fee int32 value ):
    // Declares function G that requires its argument to
    // have qualifier fee.
    //
    ... [Function body omitted] ...

// Example usage:
//
int32 x1 = ...
fee int32 x2 = F ( x1 )      // Legal; F produces result
                             // with qualifier fee.
int32 x3 = F ( x1 )          // Legal; F attaches implied
                             // qualifier fee automatically
                             // to x3.
int32 y1 = G ( x1 )          // Illegal; G requires argument
                             // to have qualifier fee.
int32 y2 = G ( x2 )          // Legal; x2 has qualifier fee.
int32 y3 = G ( x3 )          // Legal; x3 has qualifier fee.

\end{verbatim}\end{indpar}

Qualifiers may be declared by:
\begin{indpar}
\emkey{qualifier-declaration}\label{QUALIFIER-DECLARATION} \\
\hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define} {\em qualifier-attribute}\PLUS{} \ttkey{qualifier}
           {\em defined-qualifier-name} \\
    $|$ & {\em trace-qualifier-declaration}
    	  ~~~ [see \pagref{TRACE-QUALIFIERS}]
    \end{tabular} \\
\emkey{qualifier-attribute}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{value} \\
    $|$ & \ttkey{variable} \\
    $|$ & \ttkey{implied} \\
    $|$ & \ttkey{addable} \\
    $|$ & \ttkey{deletable} \\
    \end{tabular} \\
\emkey{defined-qualifier-name} ::= {\em qualifier-name} \\
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME}

where
\begin{enumerate}
\item
No {\em qualifier-name} may be a prefix of
any {\em type-name},
any {\em deferred-variable} (\pagref{DEFERRED-VARIABLE})
or any {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME}).
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.
\item
No qualifier name may begin with `\TT{next}'
or `\TT{previous}'.
\end{enumerate}
\end{indpar}

The builtin defined qualifiers are in effect declared by:
\begin{indpar}
{\tt define implied variable qualifier \ttstdakey{READ}} \\
{\tt define abbreviation \ttakey{READ} ---> `std *READ*'} \\
{\tt define implied variable qualifier \ttstdakey{WRITE}} \\
{\tt define abbreviation \ttakey{WRITE} ---> `std *WRITE*'} \\
{\tt define implied addable value qualifier \ttstdakey{STACK}} \\
{\tt define abbreviation \ttakey{STACK} ---> `std *STACK*'} \\
{\tt define variable qualifier \ttstdakey{UNCHECKED}} \\
{\tt define abbreviation \ttakey{UNCHECKED} ---> `std *UNCHECKED*'} \\
{\tt define implied deletable value qualifier \ttstdakey{READABLE}} \\
{\tt define abbreviation \ttakey{READABLE} ---> `std *READABLE*'} \\
{\tt define implied deletable value qualifier \ttstdakey{WRITABLE}} \\
{\tt define abbreviation \ttakey{WRITABLE} ---> `std *WRITABLE*'}
\end{indpar}

In addition there are several builtin `\skey{pseudo-qualifier}s'
that can only be used in function prototypes:
\begin{center}
\TT{*DEFERRED*} \\
\TT{*OPTIONAL*} \\
\TT{*UNUSED*} \\
\end{center}
These are qualifiers only syntactically, and have their own semantics
not related to that of other qualifiers.

Each qualifier is associated with a unique enumeration value,
and this value can be used at both
compile and run time to test whether two `\TT{qualifier}'s are
equal.
The type `\TT{qualifier}' is a builtin enumeration type declared
by:
\begin{indpar} \tt
define type \ttstdkey{qualifier} as unswrd with enum [0~..] \\
define abbreviation \ttkey{qualifier} \ABV{} `std qualifier' \\
qualifier \ttstdkey{missing qualifier} = next enum // 0 \\
function std qualifier r = std \ttmkey{missing}{qualifier}: \\
\hspace*{3em}r = std missing qualifier
\end{indpar}

The {\em qualifier-name} of a qualifier
can be used (1) before a {\em type-name}
in a declaration, or (2) as the name of an enumeration value in an
expression.

A `\key{variable qualifier}'\label{VARIABLE-QUALIFIER}
qualifies variables but not values.
If $Q$ is a variable qualifier attached to a variable {\tt v}, $Q$
does \underline{not} follow the value of {\tt v} when that value
is copied to another variable.

A `\key{value qualifier}'\label{VALUE-QUALIFIER}
qualifies values, although the qualifier
is attached to variables that hold these values.
If $Q$ is a value qualifier attached to a variable {\tt v}, $Q$
typically, but not necessarily,
follows the value of {\tt v} to another variable
when that value is copied to that other variable.

A qualifier must be a variable qualifier or a value qualifier,
but cannot be both.

A \underline{value} qualifier may be
\mkey{addable}{qualifier} or
\mkey{deletable}{qualifier}.  Any qualifier may be
\mkey{implied}{qualifier}.  These qualifier attributes control
direct assignments (\pagref{DIRECT-ASSIGNMENT-TYPE}) according to rules
we now describe.

Given variables {\tt u} and {\tt w}
the compiler will execute
\begin{center}
\tt \ldots~u = w
\end{center}
as a direct assignment (\pagref{DIRECT-ASSIGNMENT-TYPE}) if it can,
simply copying the value of {\tt w} to {\tt u}, or otherwise
the compiler will rewrite the statement as
\begin{center}
\tt \ldots~u = assign ( w )
\end{center}
and treat the assignment as a function call.  To qualify as a direct
assignment, the types of {\tt u} and {\tt w} must be identical and
not \TT{void},
and the assignment must obey some rules involving qualifiers.  These
qualifier rules differ for different kinds of assignments, so we
now introduce the different kinds of assignments.

To do this, we must look ahead at how
an inline function call is expanded (as per
\itemref{MATCHING-CALLS-TO-PROTOTYPES}).  Given the function
prototype
\begin{center}
\begin{tabular}{l}
\tt function $Qsr$ $Tr$ r = F ( $Qsv$ $Tv$ v ) \\
\end{tabular}
\end{center}
where $Qs\ldots$ are qualifiers and $T\ldots$ are types,
the code
\begin{center}
\begin{tabular}{l}
\tt $Qsw$ $Tw$ w = \ldots \\
\tt $Qsu$ $Tu$ u = F ( w ) \\
\end{tabular}
\end{center}
expands modulo variable renaming to the equivalent of
\begin{center}
\begin{tabular}{l}
\tt $Qsw$ $Tw$ w = \ldots \\
\tt $Qsv$ $Tv$ v = w \\

\tt $Qsr$ $Tr$ r =: \\
\tt ~~~~~ \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
\tt ~~~~~ r = \ldots \\
\tt ~~~~~ \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
\tt $Qsu$ $Tu$ u = r \\
\end{tabular}
\end{center}

In the above
\begin{indpar}
\begin{itemize}
\item {\tt \ldots{}~v = w}
	\begin{tabular}[t]{@{}l}
	is called an \key{argument assignment} \\
        ({\tt v} is a prototype argument variable)
	\end{tabular}
\item {\tt r = \ldots}
	\begin{tabular}[t]{@{}l}
	is called a \key{result deferred assignment} \\
	({\tt r} is not preceded by explicit qualifiers or type) \\
	({\tt r} is a prototype result variable that implicitly \\
	has the qualifiers and type given by
	call-prototype match) \\
        (see \pagref{DEFERRED-ASSIGNMENT} for other kinds of
	deferred assignments) \\
	\end{tabular}
\item {\tt \ldots{}~u = r}
	\begin{tabular}[t]{@{}l}
	is called a \key{result assignment}\label{RESULT-ASSIGNMENT} \\
	({\tt r} is a prototype result variable)
	\end{tabular}
\item any other
	\begin{tabular}[t]{@{}l}
	assignment {\tt \ldots~x = y} for variables {\tt x} and {\tt y} \\
	is called a \key{ordinary assignment}
	\end{tabular}
\end{itemize}
\end{indpar}

Rephrasing this, consider the assignment statement
\begin{center}
\begin{tabular}{l}
\tt \{ $Qsu$ $Tu$ \}\QMARK{} u = w \\
\end{tabular}
\end{center}

for variables {\tt w} and {\tt u}.
If {\tt u} is a prototype argument variable in a function call expansion,
the assignment is an argument assignment.
If {\tt w} is a function prototype result variable in a function call expansion,
the assignment a result assignment.
If there are no qualifiers $Qus$ and type $Tu$ explicitly given for {\tt u},
{\tt u} inherits qualifiers and type given previously, and the assignment
is a deferred assignment (\pagref{DEFERRED-ASSIGNMENT}).
Otherwise the assignment is an ordinary assignment.

As a subcase, a deferred assignment {\tt r = \ldots}~ is called
a \key{result deferred assignment} if {\tt r} is a prototype
result variable in a function call expansion.  In this case
the qualifiers of {\tt r} are determined by call-prototype matching, see
\itemref{MATCHING-CALLS-TO-PROTOTYPES}.

We distinguish these kinds of assignments because for
direct assignments:
(1) implied qualifiers of {\tt w} are implicitly
added to {\tt u} for result and ordinary assignments, but
not for deferred and argument assignments;
(2) {\tt u} may have explicit variable qualifiers only if either
{\tt u} or {\tt w} is a prototype result variable (i.e., result
assignments, and direct assignments to a result variable);
(3) result deferred assignments permit value qualifiers
to be added or deleted without restriction; and (4)
result direct assignments can in effect copy clusters
(see \pagref{RESULT-DIRECT-ASSIGNMENT}).

Formally, an
assignment {\tt \ldots{}~u = w} is a \key{direct assignment}
\label{DIRECT-ASSIGNMENT}
if and only if:
\begin{indpar}\begin{itemize}
\label{DIRECT-ASSIGNMENT-QUALIFIER-RULES}
\item[(DA1)]
The types of {\tt u} and {\tt w}
are identical, and if the assignment is \underline{not} a result
assignment, this type must not have
\TT{void} as its underlying type
(as per \pagref{DIRECT-ASSIGNMENT-TYPE-RULE}).
\item[(DA2)]
A \underline{value} qualifier of {\tt u}
is also a qualifier of {\tt w} unless
the qualifier is \mkey{addable}{qualifier} or the assignment
is an result deferred assignment.
\item[(DA3)]
A \underline{value} qualifier of {\tt w}
is also a qualifier of {\tt u} unless
the qualifier is \mkey{deletable}{qualifier}, or
the assignment is an result deferred assignment, or
the qualifier is \mkey{implied}{qualifier}
\underline{and} the assignment is a result assignment or
ordinary assignment.
In this last case,
the qualifier will be implicitly added to {\tt u} (and this
rule will thereby be satisfied).
\item[(DA4)]
If the assignment is an argument or ordinary assignment,
or if it is a deferred assignment and {\tt u} is \underline{not}
a prototype result variable,
{\tt u} does \underline{not} have any \underline{variable} qualifiers
(but {\tt w} may have \underline{variable} qualifiers).
\item[(DA5)]
If the assignment is a result assignment,
a \underline{variable} qualifier
of {\tt u} is also a qualifier of {\tt w}.
\item[(DA6)]
If the assignment is a result assignment,
a \underline{variable} qualifier
of {\tt w} is also a qualifier of {\tt u}.
However,
if the qualifier is \mkey{implied}{qualifier}
but not an explicit qualifier of {\tt u},
the qualifier will be implicitly added to {\tt u} (and this rule
will thereby be satisfied).
\item[NOTE]
In order to have a \underline{variable} qualifier, a variable {\tt u}
must be a result prototype variable in a deferred result assignment,
or must be assigned its value by a result assignment whose prototype
result variable {\tt w} has the qualifier.  In the latter case,
{\tt u} need not be given the qualifier explicitly if the qualifier
is implied.
\item[NOTE]
Result deferred assignments ignore qualifiers and are always direct
assignments when (DA1) is satisfied.  So as far as qualifiers are concerned,
result deferred assignments are effectly unchecked.
\item[NOTE]
If a result variable has \TT{void} as its underlying type, or if it
has either the \TT{*READ*} or \TT{*WRITE*} qualifiers
(\itemref{THE-READ-AND-WRITE-QUALIFIERS}), it is never
assigned a value by a deferred assignment, and is therefore free to have
any qualifiers.
\end{itemize}\end{indpar}

Generally a direct assignment `{\tt \ldots{}~u = w}' just copies the
value of {\tt w} to {\tt v}, but result direct assignments
are an exception%
\label{RESULT-DIRECT-ASSIGNMENT}.
A \key{result direct assignment} in effect makes {\tt u} an alternative name for
{\tt w}, and extends the scope of {\tt w} to include the scope of {\tt u}.
No values are copied, and the common type of {\tt u} and {\tt v} can have
\TT{void} as its underlying type.
In addition cluster members of {\tt w} (see \itemref{CLUSTERS})
become cluster members of {\tt u} (which does not happen for other
kinds of direct assignment).

Result deferred assignments that change qualifiers are allowed
to violate qualifier checking.  An example is:
\begin{indpar}\begin{verbatim}
// *UNCHECKED* function to remove *STACK* qualifier.
//
function *UNCHECKED* Qrs T r = remove *STACK*
        (| qualifiers Qvs, type T |) ( Qvs T v )
        [| qualifiers Qrs = Qvs - { *STACK* } |]:
    r = v
\end{verbatim}\end{indpar}

In this example, the {\tt *UNCHECKED*} qualifier could be
omitted, but then `{\tt remove *STACK*}' would violate
type checking without giving any indication that it did so.

Examples involving the \TT{*READ*} and \TT{*UNCHECKED*}
builtin variable qualifiers are:
\begin{indpar}\begin{verbatim}
// Function to read the int32 value at RAM address A.
// Not type safe as argument A not vetted.
//
function *READ* int32 r, adr r.adr = read ( adr A ):
    r.adr = A
*READ* int32 x = read (1000)
    // Creates variable adr x.adr = 1000.  *READ* is a
    // special variable qualifier: x is not given a value
    // by assignment, but automatically gets its value by
    // reading location x.adr.
int32 y = read(2000)
    // Ditto but *READ* qualifier is automatically added to
    // y.
int32 z = x
    // The *READ* variable qualifier on x is NOT propagated
    // to z.

*UNCHECKED* uns32 w = uns32 ( z )
    // *UNCHECKED* is a non-implied variable qualifier that
    // must be written into code.  It must be on the
    // result variable of an unchecked conversion from
    // int32 to uns32 that just changes the type of the
    // 32 bit value without changing the value.
uns32 v = w
    // The *UNCHECKED* variable qualifier on w is NOT
    // propagated to v.
\end{verbatim}\end{indpar}

A call to {\tt read} returns a cluster of
two variables, with only the root {\tt r} of the cluster being
specified explicitly by the call, and the child {\tt r.adr} being
created implicitly by the call: see \itemref{CLUSTERS}.
The \TT{*READ*} qualifier has the special property that a value of a \TT{*READ*}
variable {\tt r} is not given explicitly, but is read implicitly from
RAM memory using the address in {\tt r.adr}:
see \itemref{THE-READ-AND-WRITE-QUALIFIERS}.
As a variable qualifier, \TT{*READ*} can only be attached to
a variable by setting the variable to the result of a
function call.

Some examples involving the \TT{*STACK*} addable implied value
qualifier are:
\begin{indpar}\begin{verbatim}
// Assume:
//
//    function *UNCHECKED* *STACK* adr r = allocate to stack
//                                         ( unswrd size )
//        // Actual allocate to stack function returns more
//        // complex cluster.
//
*UNCHECKED* adr address of x =
               allocate to stack ( size of int32 )
    // address of x is automatically given the `*STACK*'
    // qualifier.

function *READ* int32 r, adr r.adr = read ( adr A ):
    r.adr = A
function *READ* int32 r, adr r.adr = read from stack 1
                                        ( *STACK* adr A ):
    *UNCHECKED* adr a = remove *STACK* ( A )
        // Uses `remove *STACK*' function defined above.
    r.adr = a
function *READ* int32 r, *STACK* adr r.adr =
        read from stack 2 ( *STACK* adr A ):
    r.adr = A

int32 x1 = read ( address of x )
    // Compiler error: `read' prototype argument does not
    // have non-deletable `*STACK*' qualifier that the call
    // argument has.
int32 x2 = read from stack 1 ( address of x )
int32 x3 = read from stack 2 ( address of x )
    // Both legal: `read from stack ...' prototype and call
    // arguments both have `*STACK*' qualifier.
    //
    // First call does NOT propagate *STACK* to x2.adr.
    // Second call propagates *STACK* to x3.adr.
\end{verbatim}\end{indpar}

The \TT{*STACK*} qualifier is special in that it is not allowed to qualify
values returned by an \underline{out-}\EOL \underline{of-}\EOL \underline{line}
function call.
This qualifier is then attached to addresses of data allocated
to the stack frame of the out-of-line function call,
because these addresses become invalid when the call returns.
There are other situations where
a \TT{*STACK*} value cannot qualify a variable value because the
lifetime of the variable is longer than the lifetime of the
stack frame in used when the variable is set:
see \itemref{THE-STACK-QUALIFIER} for details.

\section{Expressions}
\label{EXPRESSIONS}

Expressions compute values and appear inside statements where a value is needed.
For example, in a {\em simple-assignment-statement} of the form
\begin{indpar}
{\em qualifier-name}\STAR{} ~ {\em type-name} ~ {\em variable-name}
	~ {\tt =} ~ {\em expression}
\end{indpar}
the {\em expression} computes a value to store in the variable.

The parser and compiler convert {\em expressions} and into statements
that have no {\em expressions} except for {\em variable-names}
and {\em function-calls} in statements of the form
\begin{indpar}
\ldots{}~~ {\tt =} ~{\em constant} \\
\ldots{}~~ {\tt =} ~{\em variable-name} \\
\ldots{}~~ {\tt =} ~{\em function-call}
\end{indpar}
where \ldots{} is a list of result variables (which is optional
for {\em function-calls}).

The builtin operators that can appear in an expression in approximate
precedence order (lowest precedence topmost) are:

\begin{center}

\begin{tabular}{c}
\TT{if ~ else} \\
selection operators
\end{tabular}

\medskip

\begin{tabular}{c}
\TT{and ~ or} \\
\TT{not} \\
logical operators
\end{tabular}

\medskip

\begin{tabular}{c}
\TT{== ~ != ~ > ~ =>\footnotemark ~ < ~ <=} \\
comparison operators
\end{tabular}
\footnotetext{L-language uses \TT{=>} so {\tt x => y}
whereas the C language uses \TT{>=} so {\tt x >= y}.}

\medskip

\begin{tabular}[t]{c}
\TT{+ ~ -} \\
summation (binary) operators
\\[2ex]
\TT{* ~ / ~ div ~ mod ~ rem } \\
product operators
\\[2ex]
\TT{\textasciicircum} \\
exponent operator
\\[2ex]
\TT{+ ~ -} \\
sign (unary) operators
\end{tabular}
~~~~~
\begin{tabular}[t]{c}
\TT{\& ~ | ~ xor ~ <{}< ~ >{}>} \\
\TT{!} \\
bitwise operators
\end{tabular}

\end{center}

However precedence is only a rough guide to the syntax of L-Language
operators.

Two operators are said to be mixed in an expression if both are outside
parenthesized subexpressions of the expression.
The logical operators other than `\TT{not}' cannot be mixed with
each other, and similarly for the product operators and the
bitwise operators other than \TT{!} (bitwise complement).  Bitwise
operators cannot be mixed with summation, product, exponent, or sign operators.

\subsection{Variable Names}

A {\em variable-name} names a variable that is allocated to
the current function frame.
The syntax is:

\begin{indpar}
\emkey{variable-name}
	::= {\em variable-base-name} {\em member-selector}\STAR{} \\
\emkey{variable-base-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript } \\
\emkey{member-name}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark}
			    or {\em quoted-separator}
			\end{tabular} \\
\emkey{member-subscript}\label{MEMBER-SUBSCRIPT}
    ::= {\em enum-list-constant} \\
{\em enum-list-constant} ::= see \pagref{ENUM-LIST-CONSTANT} \\
{\em name} ::= see \pagref{NAME}
\end{indpar}

Variables with names containing {\em member-selectors} are
cluster members (\itemref{CLUSTERS}) and can only be allocated
to memory by {\em function-prototypes} and {\em generic-prototypes}.
All other variables can be allocated by {\em assignment-statements}
(\itemref{ASSIGNMENT-STATEMENTS}).

L-language has an extension,
the \ikey{\LSTAR-language}{L*-language}\label{LSTAR-LANGUAGE},
that allows variables with {\em member-selectors} to be allocated
by {\em assignment-statements}.  The \LSTAR-language is significantly
less type-safe than the L-language, but is needed by the compiler
as the output language for expanding inline function calls.

\subsection{Expression Syntax}
\label{EXPRESSION-SYNTAX}

Parsing converts expressions into function calls in two steps.
The first step identifies operators.  The second step inserts
implied parentheses, thus identifying function call argument lists.
At the end all the operators are quoted converting them into
function terms (i.e., names of functions).

Insertion of implied parentheses is driven by an operator
precedence table.  This in turn corresponds to operator
syntax equations, which in turn can be derived from parser
instructions.

\subsubsection{Operator Identification}
\label{OPERATOR-IDENTIFICATION}

The parser identifies operators by a left-to-right scan of
an expression, choosing the longest operator that matches the
beginning of the yet unscanned input at each stage, and skipping
the first lexeme of the yet unscanned input if no operator matches.
Then the parser parses expressions according to the syntax:

\begin{indpar}
\emkey{expression}\label{EXPRESSION} ::= \\
\hspace*{0.5in} {\em infix-operand}
	  \{ {\em infix-operator} {\em infix-operand} \}\STAR{}
\\[0.5ex]
\emkey{infix-operand} ::=
    {\em prefix-operator}\STAR{} {\em primary} {\em postfix-operator}\STAR{}
\\[0.5ex]
\emkey{primary}\label{PRIMARY}
    \begin{tabular}[t]{rl}
    ::= & {\em subexpression} \\
    $|$ & {\em argument-list}\STAR{}
	      \begin{tabular}[t]{l}
	      {\em primary-item}\PLUS{}\\
	      \{ {\em argument-list}\PLUS{}
		 {\em primary-item}\PLUS{} \}\STAR{} \\
	      {\em argument-list}\STAR{} \\
	      \end{tabular} \\
    $|$ & {\em argument-list} {\em argument-list}\PLUS{} \\
    $|$ & {\em bracketed-constant}
    \end{tabular}
\\[0.5ex]
\emkey{subexpression}
    \begin{tabular}[t]{rl}
    ::= & {\em module-abbreviation} ~ \TT{(} {\em expression} \TT{)} \\
    $|$ & \TT{(} {\em expression} \TT{)} \\
    \end{tabular}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
\emkey{primary-item}\label{PRIMARY-ITEM}
    ::= {\em word} $|$ {\em number} $|$ {\em quoted-string}
\\[0.5ex]
\emkey{argument-list}\label{ARGUMENT-LIST}
    \begin{tabular}[t]{rl}
    ::= & \TT{( )} \\
    $|$ & \TT{(} {\em expression} \{ \TT{,} {\em expression} \}\STAR{} \TT{)} \\
    $|$ & \TT{[ ]} \\
    $|$ & \TT{[} {\em expression} \{ \TT{,} {\em expression} \}\STAR{} \TT{]} \\
    $|$ & \TT{(| |)} \\
    $|$ & \TT{(|} {\em expression} \{ \TT{,} {\em expression} \}\STAR{}
          \TT{|)} \\
    \end{tabular}
\\[0.5ex]
\emkey{bracketed-constant}\label{BRACKETED-CONSTANT}
    \begin{tabular}[t]{rl}
    ::= & \TT{[ ]} \\
    $|$ & \TT{[} {\em range}
          \{ \TT{,} {\em range} \}\STAR{} \TT{]} \\
    $|$ & \TT{\{ \}} \\
    $|$ & \TT{\{} {\em range}
          \{ \TT{,} {\em range} \}\STAR{} \TT{\}} \\
    $|$ & \TT{`} {\em name-item}\STAR{} \TT{'}
    \end{tabular}
\\[0.5ex]
\emkey{range}\label{RANGE}
    \begin{tabular}[t]{rl}
    ::= & {\em expression} \\
    $|$ & {\em expression} \TT{..} {\em expression} \\
    $|$ & {\em expression} \TT{..} \\
    $|$ & \TT{..} {\em expression} \\
    \end{tabular}
\\[0.5ex]
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

Operators are classified as \key{infix}, \key{prefix}, or
\key{postfix}.  An operator can be more than one of these.
When a sequence of consecutive operators occurs, either
\begin{itemize}
\item[(1)] The sequence is before the first {\em primary}
in the expression and consists of just prefix operators.
\item[(2)] The sequence is between {\em primaries}
in the expression
and contains a single infix operator optionally
preceded by just postfix operators and optionally followed by
just prefix operators.
\item[(3)] The sequence is after the last {\em primary}
in the expression and consists of
just postfix operators.
\end{itemize}

Then
\begin{indpar}[0.5in]
\begin{itemize}
\item[(Rule A)] If operator fixity cannot be assigned so the (1-3)
above are true, the expression is illegal and a compile error.
\item[(Rule B)] If operator fixity can be assigned in \underline{more than one}
way so the (1-3) above are true, the expression is illegal and a compile error.
\end{itemize}
\end{indpar}

\newcommand{\IX}[1]{$_{\bullet}$\TT{#1}$_{\bullet}$}
\newcommand{\RX}[1]{\TT{#1}$_{\bullet}$}
\newcommand{\LX}[1]{$_{\bullet}$\TT{#1}}

The fixity of an operator is considered to be part of
the identification of the operator, so prefix \TT{+}
and infix \TT{+} are different operators.
We denote the fixity of \TT{$o$} as follows:
\begin{center}
\begin{tabular}{ll}
\LX{$o$} & postfix \TT{$o$} \\
\IX{$o$} & infix \TT{$o$} \\
\RX{$o$} & prefix \TT{$o$} \\
\end{tabular}
\end{center}

Then \IX{+} and \RX{+} are builtin operators, but \LX{+}
is not builtin (the user could define it).  Suppose the
user defined \LX{@} and \IX{@}.  Then we would have the
following examples:

\begin{center}
\begin{tabular}{lcll}
\tt x + + y	& parses as & \tt x \IX{+} \RX{+} y \\
\tt x @ @ y	& parses as & \tt x \LX{@} \IX{@} y \\
\tt x + y +	& cannot parse & & and violates Rule A \\
\tt @ x @ y	& cannot parse & & and violates Rule A \\
\tt x @ + y	& parses as & \tt x \IX{@} \RX{+} y \\
		& or        & \tt x \LX{@} \IX{+} y
			    & and violates Rule B \\
\end{tabular}
\end{center}

\subsubsection{The Builtin Operator Precedence Table}
\label{THE-BUILTIN-OPERATOR-PRECEDENCE-TABLE}

\begin{figure}[p]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|}
\hline
first & \multicolumn{11}{c|}{second operator} \\
\cline{2-12}
operator 	& \IX{if} & \IX{else} & \IX{and} & \IX{or} & \RX{not}
                & \IX{<}  & \IX{<=}   & \IX{==}  & \IX{!=} & \IX{=>} & \IX{>}
\\\hline
\TT{\{}		& >x & > & > & > & > & > & > & > & > & > & > \\
\hline
\IX{if}		& x & < & > & > & > & > & > & > & > & > & > \\
\IX{else}	& > & > & > & > & > & > & > & > & > & > & > \\
\hline
\IX{and}	& < & x< & < & x & > & > & > & > & > & > & > \\
\IX{or}		& < & x< & x & < & > & > & > & > & > & > & > \\
\RX{not}	& < & x< & < & < & > & > & > & > & > & > & > \\
\hline
\IX{<}		& < & x< & < & < & x & < & < & < & < & < & < \\
\IX{<=}		& < & x< & < & < & x & < & < & < & < & < & < \\
\IX{==}		& < & x< & < & < & x & < & < & < & < & < & < \\
\IX{!=}		& < & x< & < & < & x & < & < & < & < & < & < \\
\IX{=>}		& < & x< & < & < & x & < & < & < & < & < & < \\
\IX{>}		& < & x< & < & < & x & < & < & < & < & < & < \\
\hline
\IX{+}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{-}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\hline
\IX{*}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{/}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{div}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{mod}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{rem}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\hline
\IX{\textasciicircum}
		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\hline
\RX{+}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\RX{-}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\hline
\IX{\&}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{|}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{xor}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{<{}<}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\IX{>{}>}	& < & x< & x< & x< & x & < & < & < & < & < & < \\
\RX{!}		& < & x< & x< & x< & x & < & < & < & < & < & < \\
\hline
\RX{*}		& < & x< & < & < & x & < & < & < & < & < & < \\
\RX{-{}-}	& < & x< & < & < & x & < & < & < & < & < & < \\
\LX{++}		& < & x< & < & < & x & < & < & < & < & < & < \\
\hline

\end{tabular}
\end{center}
\caption{Builtin Operator Precedence Table: Part 1 of 3}
\label{BUILTIN-OPERATOR-PRECEDENCE-TABLE-1}
\end{figure}

\begin{figure}[p]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
\hline
first & \multicolumn{10}{c|}{second operator} \\
\hline
operator 	& \IX{+}  & \IX{-}    & \IX{*}   & \IX{/}
                & \IX{div} & \IX{mod} & \IX{rem} & \IX{\textasciicircum}
		& \RX{+} & \RX{-}
\\\hline
\TT{\{}		& > & > & > & > & > & > & > & > & > & > \\
\hline
\IX{if}		& >x & >x & >x & >x & >x & >x & >x & >x & >x & >x \\
\IX{else}	& > & > & > & > & > & > & > & > & > & > \\
\hline
\IX{and}	& >x & >x & >x & >x & >x & >x & >x & >x & >x & >x \\
\IX{or}		& >x & >x & >x & >x & >x & >x & >x & >x & >x & >x \\
\RX{not}	& >x & >x & >x & >x & >x & >x & >x & >x & >x & >x \\
\hline
\IX{<}		& > & > & > & > & > & > & > & > & > & > \\
\IX{<=}		& > & > & > & > & > & > & > & > & > & > \\
\IX{==}		& > & > & > & > & > & > & > & > & > & > \\
\IX{!=}		& > & > & > & > & > & > & > & > & > & > \\
\IX{=>}		& > & > & > & > & > & > & > & > & > & > \\
\IX{>}		& > & > & > & > & > & > & > & > & > & > \\
\hline
\IX{+}		& < & < & > & > & > & > & > & > & > & > \\
\IX{-}		& < & < & > & > & > & > & > & > & > & > \\
\hline
\IX{*}		& < & < & < & x & x & x & x & > & > & > \\
\IX{/}		& < & < & x & x & x & x & x & > & > & > \\
\IX{div}	& < & < & x & x & x & x & x & > & > & > \\
\IX{mod}	& < & < & x & x & x & x & x & > & > & > \\
\IX{rem}	& < & < & x & x & x & x & x & > & > & > \\
\hline
\IX{\textasciicircum}
		& < & < & < & < & < & < & < & x & > & > \\
\hline
\RX{+}		& < & < & < & < & < & < & < & < & > & > \\
\RX{-}		& < & < & < & < & < & < & < & < & > & > \\
\hline
\IX{\&}		& x & x & x & x & x & x & x & x & x & x \\
\IX{|}		& x & x & x & x & x & x & x & x & x & x \\
\IX{xor}	& x & x & x & x & x & x & x & x & x & x \\
\IX{<{}<}	& x & x & x & x & x & x & x & x & x & x \\
\IX{>{}>}	& x & x & x & x & x & x & x & x & x & x \\
\hline
\RX{!}		& x & x & x & x & x & x & x & x & x & x \\
\hline
\RX{*}		& < & < & < & < & < & < & < & < & x & x \\
\RX{-{}-}	& < & < & < & < & < & < & < & < & x & x \\
\LX{++}		& < & < & < & < & < & < & < & < & x & x \\
\hline

\end{tabular}
\end{center}
\caption{Builtin Operator Precedence Table: Part 2 of 3}
\label{BUILTIN-OPERATOR-PRECEDENCE-TABLE-2}
\end{figure}

\begin{figure}[p]
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
\hline
first & \multicolumn{10}{c|}{second operator} \\
\cline{2-11}
operator 	& \IX{\&} & \IX{|} & \IX{xor} & \IX{<{}<} & \IX{>{}>}
		& \RX{!} & \RX{*} & \RX{-{}-} & \LX{++} & \TT{\}}
\\\hline
\TT{\{}	& > & > & > & > & > & > & > & > & > & d \\
\hline
\IX{if}		& >x & >x & >x & >x & >x & >x & > & > & > & x< \\
\IX{else}	& > & > & > & > & > & > & > & > & > & < \\
\hline
\IX{and}	& >x & >x & >x & >x & >x & >x & > & > & > & < \\
\IX{or}		& >x & >x & >x & >x & >x & >x & > & > & > & < \\
\RX{not}	& >x & >x & >x & >x & >x & >x & > & > & > & < \\
\hline
\IX{<}		& > & > & > & > & > & > & > & > & > & < \\
\IX{<=}		& > & > & > & > & > & > & > & > & > & < \\
\IX{==}		& > & > & > & > & > & > & > & > & > & < \\
\IX{!=}		& > & > & > & > & > & > & > & > & > & < \\
\IX{=>}		& > & > & > & > & > & > & > & > & > & < \\
\IX{>}		& > & > & > & > & > & > & > & > & > & < \\
\hline
\IX{+}		& x & x & x & x & x & x & > & > & > & < \\
\IX{-}		& x & x & x & x & x & x & > & > & > & < \\
\hline
\IX{*}		& x & x & x & x & x & x & > & > & > & < \\
\IX{/}		& x & x & x & x & x & x & > & > & > & < \\
\IX{div}	& x & x & x & x & x & x & > & > & > & < \\
\IX{mod}	& x & x & x & x & x & x & > & > & > & < \\
\IX{rem}	& x & x & x & x & x & x & > & > & > & < \\
\hline
\IX{\textasciicircum}
		& x & x & x & x & x & x & > & > & > & < \\
\hline
\RX{+}		& x & x & x & x & x & x & > & > & > & < \\
\RX{-}		& x & x & x & x & x & x & > & > & > & < \\
\hline
\IX{\&}		& < & x & x & x & x & > & > & > & > & < \\
\IX{|}		& x & < & x & x & x & > & > & > & > & < \\
\IX{xor}	& x & x & < & x & x & > & > & > & > & < \\
\IX{<{}<}	& x & x & x & < & < & x & > & > & > & < \\
\IX{>{}>}	& x & x & x & < & < & x & > & > & > & < \\
\hline
\RX{!}	& < & < & < & < & < & > & > & > & > & < \\
\hline
\RX{*}		& < & < & < & < & < & x & > & > & > & < \\
\RX{-{}-}	& < & < & < & < & < & x & > & > & > & < \\
\LX{++}		& < & < & < & < & < & x & < & < & < & < \\
\hline

\end{tabular}
\end{center}
\caption{Builtin Operator Precedence Table: Part 3 of 3}
\label{BUILTIN-OPERATOR-PRECEDENCE-TABLE-3}
\end{figure}

After assigning fixity as in \itemref{OPERATOR-IDENTIFICATION},
    the parser inserts parentheses so that
	each prefix or postfix operator has a single {\em primary} operand
    and each infix operator has two {\em primary} operands.  This is
done using the \key{operator precedence table}.  The builtin part of
this table is given in Figures
\itemref{BUILTIN-OPERATOR-PRECEDENCE-TABLE-1},
\itemref{BUILTIN-OPERATOR-PRECEDENCE-TABLE-2}, and
\itemref{BUILTIN-OPERATOR-PRECEDENCE-TABLE-3}.

Given the operator precedence table, parentheses are inserted as
follows:

\begin{center}
\begin{tabular}{llcl}
if $op1$ x $op2$ & $op1$ {\em primary}\QMARK{} $op2$
		 & & is a compile error \\
if $op1$ < $op2$ & $op1$ {\em primary}\QMARK{} $op2$
		 & rewrites as
                 & $op1$ {\em primary}\QMARK{} \TT{)} $op2$ \\
if $op1$ x< $op2$ & $op1$ {\em primary}\QMARK{} $op2$
		  & rewrites as
                  & $op1$ {\em primary}\QMARK{} \TT{)$\!_x$} $op2$ \\
if $op1$ > $op2$ & $op1$ {\em primary}\QMARK{} $op2$
		 & rewrites as
                 & $op1$ \TT{(} {\em primary}\QMARK{} $op2$ \\
if $op1$ >x $op2$ & $op1$ {\em primary}\QMARK{} $op2$
		 & rewrites as
                 & $op1$ $_x\!$\TT{(} {\em primary}\QMARK{} $op2$ \\
if $op1$ d $op2$ & $op1$ {\em primary}\QMARK{} $op2$
                 & \multicolumn{2}{l}{is the final result of the parse} \\
\end{tabular}
\end{center}

In the operator precedence tables the symbol \TT{\{} is treated as an
operator that appears only at the very beginning of the expression
and the symbol \TT{\}} is treated as an operator that appears only at
the very end of the expression.  After applying these rules as much
as possible to an expression,
if the expression contains a sequence `\TT{)}$\!_x$ $op$' the operand
preceding $op$ is illegal for $op$ and is a compile error, or
if the expression contains a sequence `$op$ $_x\!$\TT{(}' the operand
following $op$ is illegal for $op$ and is a compile error.
It is possible for the parse result to be
`\TT{\{} $_x\!$\TT{(} {\em primary} \TT{)}$\!_x$ \TT{\}}' in which case
the parse is not a legal expression (this can happen if the {\em primary}
topmost operator is `\TT{if}').

As an example, given the expression
\begin{center}
\tt \TT{\{}  x \IX{+} \RX{+} y \IX{*} z \TT{\}}
\end{center}
we get
\begin{center}
\begin{tabular}{llcl}
    & & initially & \tt \TT{\{} x \IX{+} \RX{+} y \IX{*} z \TT{\}} \\
(1) &
\TT{\{} > \IX{+}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \RX{+} y \IX{*} z \TT{\}}\\
(2) &
\IX{+} > \RX{+}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \TT{(} \RX{+} y \IX{*} z \TT{\}} \\
(3) &
\RX{+} < \IX{*}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \TT{(} \RX{+} y \TT{)} \IX{*} z \TT{\}} \\
(4) &
\IX{+} > \IX{*}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \TT{(} \TT{(} \RX{+} y \TT{)} \IX{*} z
          \TT{\}} \\
(5) &
\IX{*} < \TT{\}}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \TT{(} \TT{(} \RX{+} y \TT{)} \IX{*} z
          \TT{)} \TT{\}} \\
(6) &
\IX{+} < \TT{\}}
    & so this rewrites as
    & \tt \TT{\{} \TT{(} x \IX{+} \TT{(} \TT{(} \RX{+} y \TT{)} \IX{*} z
          \TT{)} \TT{)} \TT{\}} \\
(7) &
\TT{\{} d \TT{\}}
    & \multicolumn{2}{l}{so this is the final result of the parse}
\end{tabular}
\end{center}

Notice that the step (4) above is possible because
{\tt \TT{(} \RX{+} y \TT{)}} became a {\em primary} after
the step (3),
step (6) is possible because
{\tt \TT{(} \TT{(} \RX{+} y \TT{)} \IX{*} z \TT{)} }
became a {\em primary} after step (5),
and step (7) is possible because
{ \tt \TT{(} x \IX{+} \TT{(} \TT{(} \RX{+} y \TT{)} \IX{*} z \TT{)} \TT{)} }
became a {\em primary} after step (6).
.

As another example, consider
\begin{center}
\tt \TT{\{} x \IX{if} \RX{+} y \IX{else} z \TT{\}}
\end{center}
we get
\begin{center}
\begin{tabular}{lcl}
    & initially
    & \tt \TT{\{} x \IX{if} \RX{+} y \IX{else} z \TT{\}} \\
\TT{\{} >x \IX{if}
    & so this rewrites as
    & \tt \TT{\{} $_x\!$\TT{(} x \IX{if} \RX{+} y \IX{else} z \TT{\}} \\
\IX{if} >x \RX{+}
   & so this rewrites as
   & \tt \TT{\{} $_x\!$\TT{(} x \IX{if} $_x\!$\TT{(} \RX{+} y \IX{else} z
         \TT{\}} \\
\RX{+} x< \IX{else}
   & so this rewires as
   & \tt \TT{\{} $_x\!$\TT{(} x \IX{if} $_x\!$\TT{(} \RX{+} y \TT{)}$\!_x$
         \IX{else} z \TT{\}} \\
\IX{if} < \IX{else}
   & so this rewires as
   & \tt \TT{\{} $_x\!$\TT{(} x \IX{if} $_x\!$\TT{(} \RX{+} y \TT{)}$\!_x$
         \TT{)} \IX{else} z \TT{\}} \\
\TT{\{} < \IX{else}
   & so this rewires as
   & \tt \TT{\{} \TT{(} $_x\!$\TT{(} x \IX{if} $_x\!$\TT{(} \RX{+} y \TT{)}$\!_x$
         \TT{)} \IX{else} z \TT{\}} \\
\IX{else} < \TT{\}}
   & so this rewires as
   & \tt \TT{\{} \TT{(} $_x\!$\TT{(} x \IX{if} $_x\!$\TT{(} \RX{+} y \TT{)}$\!_x$
         \TT{)} \IX{else} z \TT{)} \TT{\}} \\
\TT{\{} d \TT{\}}
    & \multicolumn{2}{l}{so this is the final result of the parse, with
                         an error signaled by \IX{if} $_x\!$\TT{(}}
\end{tabular}
\end{center}

Notice that in the sequence \TT{)}$\!_x$ \TT{)} \IX{else}
the $_x$ has been hidden from the \IX{else} by a \TT{)} without
the $_x$, so this part of the expression is legal.  Similarly
\TT{\{} \TT{(} $_x\!$\TT{(} is legal. The builtin
operator precedence table dictates that the left operand of an \IX{else}
must have \IX{if} or \IX{else} as its `\mkey{topmost}{operator}'
operator or be a {\em primary}
in the initial expression, and also dictates that \IX{if} cannot be the topmost
operator in the entire expression.  These rules are satisfied by the example.
The builtin operator precedence table also dictates that the
right operand of an \IX{if} must contain a logical or comparison
operator as its `topmost' operator or be a {\em primary}
in the initial expression.  This is \underline{not} satisfied by the
example because the right operand is {\tt (+ y)},
so the example is a compile error.

In order for this algorithm to work properly, the operator
precedence table is required to obey the following rules
concerning prefix and postfix operators:
\begin{center}
\begin{tabular}{cccl}
\IX{$op1$}~~<~~\RX{$op2$} & and & \IX{$op1$}~~x<~~\RX{$op2$} & are never true \\
\RX{$op1$}~~<~~\RX{$op2$} & and & \RX{$op1$}~~x<~~\RX{$op2$} & are never true \\
\LX{$op1$}~~>~~\IX{$op2$} & and & \LX{$op1$}~~>x~~\IX{$op2$} & are never true \\
\LX{$op1$}~~>~~\LX{$op2$} & and & \LX{$op1$}~~>x~~\LX{$op2$} & are never true \\
\end{tabular}
\end{center}


\subsubsection{Builtin Operator Syntax Equations}
\label{BUILTIN-OPERATOR-SYNTAX-EQUATIONS}

The builtin operator precedence table encodes the following syntax equations:

\begin{indpar}
\emkey{expression} ::= \\
    \begin{tabular}[t]{rl}
        & {\em else-expression} \\
    $|$ & {\em value-expression} \\
    $|$ & {\em primary} \\
    \end{tabular}
\\[0.5ex]
\emkey{value-expression} ::= \\
    \begin{tabular}[t]{rl}
        & {\em logical-expression} \\
    $|$ & {\em summation-expression} \\
    $|$ & {\em product-expression} \\
    $|$ & {\em exponent-expression} \\
    $|$ & {\em arithmetic-prefix-expression} \\
    $|$ & {\em arithmetic-postfix-expression} \\
    $|$ & {\em bitop-expression} \\
    $|$ & {\em shift-expression} \\
    $|$ & {\em bitop-prefix-expression} \\
    $|$ & {\em bitop-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{else-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em else-left-operand} \ttkey{else} {\em else-right-operand} \\
    ::= & {\em else-left-operand} \ttkey{else} {\em else-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{else-left-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em if-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{else-right-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em value-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{if-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em if-left-operand} \ttkey{if} {\em if-right-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{if-left-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em value-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{if-right-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em logical-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{logical-expression}\label{LOGICAL-EXPRESSION}
    \begin{tabular}[t]{rl}
    ::= & {\em logical-and-expression} \\
    $|$ & {\em logical-or-expression} \\
    $|$ & {\em not-expression} \\
    $|$ & {\em compare-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-and-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em logical-operand} \ttkey{and} {\em logical-operand} \\
    $|$ & {\em logical-and-expression} \ttkey{and} {\em logical-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-or-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em logical-operand} \ttkey{or} {\em logical-operand} \\
    $|$ & {\em logical-or-expression} \ttkey{or} {\em logical-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em not-expression} \\
    $|$ & {\em compare-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{not-expression}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{not} {\em not-operand} \\
    $|$ & \ttkey{not} {\em not-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{not-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em compare-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{compare-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em compare-operand} {\em compare-operator} {\em compare-operand} \\
    $|$ & {\em compare-expression} {\em compare-operator}
                                   {\em compare-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{compare-operator}::=
    \ttkey{==} $|$ \ttkey{!=} $|$ \ttkey{>} $|$
    \ttkey{=>} $|$ \ttkey{<} $|$ \ttkey{<=}
\\[0.5ex]
\emkey{compare-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em summation-expression} \\
    $|$ & {\em product-expression} \\
    $|$ & {\em exponent-expression} \\
    $|$ & {\em arithmetic-prefix-expression} \\
    $|$ & {\em arithmetic-postfix-expression} \\
    $|$ & {\em bitop-expression} \\
    $|$ & {\em shift-expression} \\
    $|$ & {\em bitop-prefix-expression} \\
    $|$ & {\em bitop-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{summation-expression} \\
    \hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & {\em summation-operand} {\em summation-operator}
                                  {\em summation-operand} \\
    $|$ & {\em summation-expression} {\em summation-operator}
                                     {\em summation-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{summation-operator}::= \ttkey{+} $|$ \ttkey{-}
\\[0.5ex]
\emkey{summation-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em product-expression} \\
    $|$ & {\em exponent-expression} \\
    $|$ & {\em arithmetic-prefix-expression} \\
    $|$ & {\em arithmetic-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{product-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em product-*-expression} \\
    $|$ & {\em product-operand} \ttkey{/} {\em product-operand} \\
    $|$ & {\em product-operand} \ttkey{mod} {\em product-operand} \\
    $|$ & {\em product-operand} \ttkey{rem} {\em product-operand} \\
    $|$ & {\em product-operand} \ttkey{div} {\em product-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{product-*-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em product-operand} \ttkey{*} {\em product-operand} \\
    $|$ & {\em product-*-expression} \ttkey{*} {\em product-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{product-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em exponent-expression} \\
    $|$ & {\em arithmetic-prefix-expression} \\
    $|$ & {\em arithmetic-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{exponent-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em exponent-operand} \ttkey{\textasciicircum}
                                  {\em exponent-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{exponent-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em arithmetic-prefix-expression} \\
    $|$ & {\em arithmetic-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{arithmetic-prefix-expression} \\
    \hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & {\em arithmetic-prefix-operator} {\em arithmetic-prefix-operand} \\
    $|$ & {\em arithmetic-prefix-operator} {\em arithmetic-prefix-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{arithmetic-prefix-operator}::= \ttkey{+} $|$ \ttkey{-}
\\[0.5ex]
\emkey{arithmetic-prefix-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em reference-prefix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{bitop-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-\&-expression} \\
    $|$ & {\em bitop-|-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{bitop-\&-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-operand} \ttkey{\&} {\em bitop-operand} \\
    $|$ & {\em bitop-\&-expression} \ttkey{\&} {\em bitop-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{bitop-|-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-operand} \ttkey{|} {\em bitop-operand} \\
    $|$ & {\em bitop-|-expression} \ttkey{|} {\em bitop-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{bitop-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-prefix-expression} \\
    $|$ & {\em bitop-postfix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{bitop-prefix-expression}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{!} {\em bitop-prefix-operand} \\
    $|$ & \ttkey{!} {\em bitop-prefix-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{bitop-prefix-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em reference-prefix-expression} \\
    ::= & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{shift-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em shift-left-operand} {\em shift-operator}
                                   {\em shift-right-operand} \\
    $|$ & {\em shift-expression} {\em shift-operator}
                                 {\em shift-right-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{shift-operator} ::= \TT{<{}<} $|$ \TT{>{}>}
\\[0.5ex]
\emkey{shift-left-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-prefix-expression} \\
    $|$ & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{shift-right-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em reference-prefix-expression} \\
    $|$ & {\em reference-postfix-expression} \\
    $|$ & {\em primary} \\
    \end{tabular}
\\[0.5ex]
\emkey{reference-prefix-expression} \\
    \hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & {\em reference-prefix-operator} {\em reference-prefix-operand} \\
    $|$ & {\em reference-prefix-operator} {\em reference-prefix-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{reference-prefix-operator}::= \ttkey{*} $|$ \ttkey{--}
\\[0.5ex]
\emkey{reference-prefix-operand}
    \begin{tabular}[t]{rl}
    ::= & {\em reference-postfix-expression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{reference-postfix-expression} \\
    \hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & {\em reference-postfix-operand} {\em reference-postfix-operator} \\
    $|$ & {\em reference-postfix-expression} {\em reference-postfix-operator} \\
    \end{tabular}
\\[0.5ex]
\emkey{reference-postfix-operator}::= \ttkey{++}
\\[0.5ex]
\emkey{reference-postfix-operand} ::= {\em primary}

\end{indpar}

\subsubsection{Builtin Parser Instructions}
\label{BUILTIN-PARSER-INSTRUCTIONS}

The builtin syntax equations above, and the builtin operator
precedence table, can be computed from the following builtin
`\skey{parser instruction}s':

\begin{indpar}\begin{verbatim}
define asymmetric right associative "else" operator "else"
include "else" expression in expression

define asymmetric binary "if" operator "if"
include "if" expression in "else" left operand

include "logical" expression in "if" right operand
include "value" expression in "else" right operand
include "value" expression in "if" left operand
include "value" expression in expression

define left associative "logical" operator "and"
define left associative "logical" operator "or"
include "logical" expression in "if" right operand
include "logical" expression in "value" expression

define prefix "not" operator "not"
include "not" expression in "logical" operand
include "not" expression in "logical" expression

define left associative "compare" operators
       "<", "<=", "==", "!=", "=>", ">"
include "compare" expression in "logical" operand
include "compare" expression in "not" operand
include "compare" expression in "logical" expression

define left associative "summation" operators "+", "-"
include "summation" expression in "compare" operand
include "summation" expression in "value" expression

define left associative "product" operator "*"
define binary "product" operator "/"
define binary "product" operator "mod"
define binary "product" operator "rem"
define binary "product" operator "div"
include "product" expression in "summation" operand
include "product" expression in "compare" operand
include "product" expression in "value" expression

define binary "exponent" operator "^"
include "exponent" expression in "product" operand
include "exponent" expression in "summation" operand
include "exponent" expression in "compare" operand
include "exponent" expression in "value" expression

define prefix "arithmetic-prefix" operators "+", "-"
include "arithmetic-prefix" expression in
        "exponent" operand
include "arithmetic-prefix" expression in
        "product" operand
include "arithmetic-prefix" expression in
        "summation" operand
include "arithmetic-prefix" expression in
        "compare" operand
include "arithmetic-prefix" expression in
        "value" expression

include "arithmetic-postfix" expression in
        "exponent" operand
include "arithmetic-postfix" expression in
        "product" operand
include "arithmetic-postfix" expression in
        "summation" operand
include "arithmetic-postfix" expression in
        "compare" operand
include "arithmetic-postfix" expression in
        "value" expression

define left associative "bitop" operator "&"
define left associative "bitop" operator "|"
include "bitop" expression in "compare" operand
include "bitop" expression in "value" expression

define asymmetric left associative
                       "shift" operators "<<", ">>"
include "shift" expression in "compare" operand
include "shift" expression in "value" expression

define prefix "bitop-prefix" operator "!"
include "bitop-prefix" expression in "shift" left operand
include "bitop-prefix" expression in "bitop" operand
include "bitop-prefix" expression in "compare" operand
include "bitop-prefix" expression in "value" expression

include "bitop-postfix" expression in "shift" left operand
include "bitop-postfix" expression in "bitop" operand
include "bitop-postfix" expression in "compare" operand
include "bitop-postfix" expression in "value" expression

define prefix "reference-prefix" operators "*", "--"
include "reference-prefix" expression in
        "exponent" operand
include "reference-prefix" expression in
        "product" operand
include "reference-prefix" expression in
        "summation" operand
include "reference-prefix" expression in
        "shift" left operand
include "reference-prefix" expression in
        "bitop" operand
include "reference-prefix" expression in
        "compare" operand
include "reference-prefix" expression in
        "value" expression

define postfix "reference-postfix" operator "++"
include "reference-postfix" expression in
        "exponent" operand
include "reference-postfix" expression in
        "product" operand
include "reference-postfix" expression in
        "summation" operand
include "reference-postfix" expression in
        "shift" left operand
include "reference-postfix" expression in
        "bitop" operand
include "reference-postfix" expression in
        "compare" operand
include "reference-postfix" expression in
        "value" expression

include "reference-postfix" expression in
        "reference-prefix" operand
\end{verbatim}\end{indpar}

Note that the {\tt "else"} operator is right associative and not
left associative.  However, because it defers evaluation of its
right operand, it evaluates its subexpressions in left to
right order.  See the example on \pagref{IF-ELSE-EXAMPLE}.

The user may add {\em parser-instructions} to those that
are builtin using {\em parser-blocks} (\itemref{PARSER-BLOCKS}).

There are several builtin expression types that have no builtin
operators, but are defined purely for the convenience of users
adding operators.  These are
\begin{center}
"arithmetic-postfix" expression \\
"bitop-postfix" expression
\end{center}

The builtin parser instructions respect the convention that
prefix and postfix operators should not be mixed with each other,
except that {\em reference-prefix} and {\em reference-postfix}
operators may be mixed, with the {\em reference-postfix} operators
being executed first.  For example,
`{\tt * x ++}' and parses as `{\tt * (x ++)}'.

\subsubsection{Parser Instruction Syntax}
\label{PARSER-INSTRUCTION-SYNTAX}

\ikey{Parser-instructions}{parser-instruction}\label{PARSER-INSTRUCTION}
have the syntax:

\begin{indpar}
\emkey{parser-instruction}
    \begin{tabular}[t]{rll}
    ::= & {\em parser-define-instruction} \\
    $|$ & {\em parser-include-instruction} \\
    $|$ & {\em parser-import-instruction}
        & [see \pagref{PARSER-IMPORT-INSTRUCTION}]\\
    $|$ & {\em parser-delete-instruction}
        & [see \pagref{PARSER-DELETE-INSTRUCTION}]\\
    $|$ & {\em parser-rewrite-rule}
        & [see \pagref{PARSER-REWRITE-RULES}]\\
    \end{tabular}
\\[0.5ex]
\emkey{parser-define-instruction} \\
\hspace*{0.3in}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{define} ~ {\em operator-type} ~ {\em expression-type}
    		   ~ \ttkey{operator} ~ {\em operator-name} \\
    $|$ & \ttkey{define} ~ {\em operator-type} ~ {\em expression-type}
    		   ~ \ttkey{operators} ~ {\em operator-name-list} \\
    \end{tabular}
\\[0.5ex]
\emkey{parser-include-instruction} \\
\hspace*{0.3in}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{include} ~ {\em expression-type}
    		   ~ \ttkey{expression in expression} \\
    $|$ & \ttkey{include} ~ {\em expression-type}
    		   ~ \begin{tabular}[t]{@{}l@{}}
		     \ttkey{expression in} \\
		     {\em expression-type} ~ {\em expression-kind}
		     \end{tabular}
    \end{tabular}
\\[0.5ex]
\emkey{operator-type}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{prefix} $|$ \ttkey{postfix} \\
    $|$ & \ttkey{asymmetric}\QMARK{} ~ \ttkey{binary} \\
    $|$ & \ttkey{asymmetric}\QMARK{} ~ \ttkey{left associative} \\
    $|$ & \ttkey{asymmetric}\QMARK{} ~ \ttkey{right associative} \\
    \end{tabular}
\\[0.5ex]
\emkey{expression-type} ::= {\em quoted-string}
\\[0.5ex]
\emkey{operator-name} ::= {\em quoted-string}
\\[0.5ex]
\emkey{operator-name-list} ::= {\em operator-name}
			   \{ \TT{,} {\em operator-name} \}\PLUS{}
\\[0.5ex]
\emkey{expression-kind}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{expression} \\
    $|$ & \ttkey{operand} \\
    $|$ & \ttkey{left operand} \\
    $|$ & \ttkey{right operand} \\
    \end{tabular}

\end{indpar}

The \skey{syntax unit}s defined by {\em parser-instructions}
have names of the forms:
\begin{center}
{\em expression-type}-expression \\
{\em expression-type}-operand \\
{\em expression-type}-left-operand \\
{\em expression-type}-right-operand \\
\end{center}
where the {\em expression-type} is unquoted.  In {\em parser-instructions}
{\em expression-types} are quoted because they are sometimes operators,
such as {\tt "and"}, but the syntax equations are not L-Language expressions.

The operators defined by parser instructions have one of three fixities:
\key{prefix}, or \key{postfix}, or \key{infix}.  The syntax of the
parser instruction specifies the operator fixity are follows:
\begin{center}
\begin{tabular}{ll}
\tt define prefix \ldots{} operator\ldots & specifies prefix operators \\
\tt define postfix \ldots{} operator\ldots & specifies postfix operators \\
\tt define \ldots{} binary \ldots{} operator\ldots
    & specifies infix operators \\
\tt define \ldots{} associative \ldots{} operator\ldots
    & specifies infix operators \\
\end{tabular}
\end{center}

Operators of different fixities are different operators from the point
of view of the operator precedence table:
see \itemref{THE-BUILTIN-OPERATOR-PRECEDENCE-TABLE}.  For example,
prefix {\tt +} and infix {\tt +} are distinct builtin operators from
this point of view.  The single operator lexeme sequence {\tt +} thus
has two fixities: prefix and infix.

A single operator lexeme sequence is \underline{not} permitted to have
all three fixities.

\subsubsection{Parser Instruction Semantics}
\label{PARSER-INSTRUCTION-SEMANTICS}

The {\em parser-define-instructions} act as follows:

\begin{indpar}

{\tt define \TT{prefix} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & $N$ {\em E-operand} \\
                            $|$ & $N$ {\em E-N-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{prefix} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-N1-operator} {\em E-operand} \\
                            $|$ & {\em E-N1-operator} {\em E-N1-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{postfix} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} $N$ \\
                            $|$ & {\em E-N-expression} $N$ \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{postfix} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} {\em E-N1-operator} \\
                            $|$ & {\em E-N1-expression} {\em E-N1-operator} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{binary} "$E$" operator "$N$"}
\begin{indpar}
creates: {\em E-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} $N$ {\em E-operand} \\
                            \end{tabular}
\end{indpar}

{\tt define \TT{binary} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} {\em E-operator}
			          {\em E-operand} \\
                            \end{tabular} \\
         {\em E-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{asymmetric binary} "$E$" operator "$N$"}
\begin{indpar}
creates: {\em E-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} $N$
			          {\em E-right-operand} \\
                            \end{tabular}
\end{indpar}

{\tt define \TT{asymmetric binary} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} {\em E-operator}
			          {\em E-right-operand} \\
                            \end{tabular} \\
         {\em E-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{left associative} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} $N$ {\em E-operand} \\
                            $|$ & {\em E-N-expression} $N$ {\em E-operand} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{left associative} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} {\em E-N1-operator}
			          {\em E-operand} \\
                            $|$ & {\em E-N1-expression} {\em E-N1-operator}
			          {\em E-operand} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{asymmetric left associative} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} $N$
			          {\em E-right-operand} \\
                            $|$ & {\em E-N-expression} $N$
			          {\em E-right-operand} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{asymmetric left associative} \begin{tabular}[t]{l}
                                             "$E$" operators \\
					     "$N1$"\TT{,} "$N2$" \ldots \\
					     \end{tabular}}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} {\em E-N1-operator}
			          {\em E-right-operand} \\
                            $|$ & {\em E-N1-expression} {\em E-N1-operator}
			          {\em E-right-operand} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{right associative} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} $N$ {\em E-operand} \\
                            $|$ & {\em E-operand} $N$ {\em E-N-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{right associative} "$E$" operators "$N1$"\TT{,} "$N2$" \ldots}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-operand} {\em E-N1-operator}
			          {\em E-operand} \\
                            $|$ & {\em E-operand} {\em E-N1-operator}
			          {\em E-N1-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{asymmetric right associative} "$E$" operator "$N$"}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} $N$
			          {\em E-right-operand} \\
                            $|$ & {\em E-left-operand} $N$
			          {\em E-N-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N-expression} \\
	 \end{tabular}
\end{indpar}

{\tt define \TT{asymmetric right associative} \begin{tabular}[t]{l}
                                             "$E$" operators \\
					     "$N1$"\TT{,} "$N2$" \ldots \\
					     \end{tabular}}
\begin{indpar}
creates: \begin{tabular}[t]{l}
         {\em E-N1-expression} \begin{tabular}[t]{rl}
                            ::= & {\em E-left-operand} {\em E-N1-operator}
			          {\em E-right-operand} \\
                            $|$ & {\em E-left-operand} {\em E-N1-operator}
			          {\em E-N1-expression} \\
                            \end{tabular} \\
         {\em E-expression} ::= {\em E-N1-expression} \\
         {\em E-N1-operator} ::= $N1$ $|$ $N2$ \ldots \\
	 \end{tabular}
\end{indpar}

\end{indpar}

The {\em parser-include-instructions} act as follows:

\begin{indpar}

{\tt include "$E$" expression in expression}
\begin{indpar}
creates: {\em expression} ::= {\em $E$-expression}
\end{indpar}

{\tt include "$E1$" expression in "$E2$" expression}
\begin{indpar}
creates: {\em $E2$-expression} ::= {\em $E1$-expression}
\end{indpar}

{\tt include "$E1$" expression in "$E2$" operand}
\begin{indpar}
creates: {\em $E2$-operand} ::= {\em $E1$-expression}
\end{indpar}

{\tt include "$E1$" expression in "$E2$" left operand}
\begin{indpar}
creates: {\em $E2$-left-operand} ::= {\em $E1$-expression}
\end{indpar}

{\tt include "$E1$" expression in "$E2$" right operand}
\begin{indpar}
creates: {\em $E2$-right-operand} ::= {\em $E1$-expression}
\end{indpar}

\end{indpar}

In general, creating the syntax equations
\begin{center}
$X$ ::= $Y$ \ldots \\
and \\
$X$ ::= $Z$ \ldots \\
\end{center}
is equivalent to creating
\begin{center}
$X$ \begin{tabular}[t]{rl}
    ::= & $Y$ \ldots \\
    $|$ & $Z$ \ldots \\
    \end{tabular}
\end{center}

In addition, whenever a syntax unit with a name of the
form {\em \ldots-operand} is created, the syntax equation
\begin{center}
{\em \ldots-operand} ::= {\em primary}
\end{center}
is created.  So a {\em primary} can be used as any operand.
The syntax equation
\begin{center}
{\em expression} ::= {\em primary}
\end{center}
is also created, so an {\em expression} can be a {\em primary} by itself.

\subsubsection{Computing Operator Precedence}
\label{COMPUTING-OPERATOR-PRECEDENCE}

The {\em parser-instructions} are used to compute the parser
syntax equations and from these the operator
precedence table.  The procedure is roughly as follows.

In general an infix operator $N$ ends up in a syntax equation equivalent to
\begin{center}
{\em $N$-expression} ::= {\em l-operand} $N$ {\em r-operand}
\end{center}
where just one of the following holds:
\begin{center}
{\em l-operand} ::= {\em $N$-operand} \\
{\em l-operand} ::= {\em $N$-left-operand} \\
{\em l-operand} ::= {\em $N$-operand} $|$ {\em $N$-expression } \\
{\em l-operand} ::= {\em $N$-left-operand} $|$ {\em $N$-expression }
\end{center}
and similarly for {\em r-operand}.
From the equations for the components of {\em l-operand} the following
are computed:
\begin{center}
\begin{tabular}{l}
$N_{top}$ = set of possible topmost operators in {\em l-operand} \\
$N_{all}$ = set of all possible operators outside parentheses
           in {\em l-operand}
\end{tabular}
\end{center}

Then for each $M\in{}N_{top}$ the operator precedence relation
`$M$~<~$N$' is generated, and for each $M\in(N_{all}-N_{top})$
the operator precedence relation
`$M$~x<~$N$' is generated.  A similar procedure involving {\em r-operand}
generates relations `$N$~>~$M$' and `$N$~>x~$M$'.

It is possible for this procedure to generate
both $M$~<~$N$ and $N$~<~$M$, or
both $N$~>~$M$ and $M$~>~$N$.
These are called `\skey{precedence loop}s' and are
compilation errors.  For example, the following
{\em parser-instructions} will trigger these errors:
\begin{indpar}\begin{verbatim}
define binary "N" operator "++"
define binary "M" operator "--"
include "N" expression in "M" operand
include "M" expression in "N" operand
\end{verbatim}\end{indpar}
These instructions generate the parser syntax equations:
\begin{center}
\begin{tabular}{l}
{\em N-expression} ::= {\em N-operand} ~ {\tt ++} ~ {\em N-operand} \\
{\em M-expression} ::= {\em M-operand} ~ {\tt -{}-} ~ {\em M-operand} \\
{\em M-operand} ::= {\em N-expression} \\
{\em N-operand} ::= {\em M-expression} \\
\end{tabular}
\end{center}
from which the following are derived:
\begin{center}
\begin{tabular}{l}
$N_{top}$ = \{ -{}- \} \\
$M_{top}$ = \{ +{}+ \} \\
{\tt -{}- < ++} ~~ and ~~ {\tt ++ > -{}-} \\
{\tt ++ < -{}-} ~~ and ~~ {\tt -{}- > ++} \\
\end{tabular}
\end{center}

According to the above rules, the {\em parser-instruction}:
\begin{center}
{\tt define prefix "not" operator "not"}
\end{center}
should produce the syntax equations:
\begin{center}
\begin{tabular}{l}
{\em not-not-expression} \begin{tabular}[t]{rl}
		     ::= & \TT{not} {\em not-operand} \\
		     $|$ & \TT{not} {\em not-not-expression} \\
		     \end{tabular} \\
{\em not-expression} ::= {\em not-not-expression} \\
\end{tabular}
\end{center}
However, because {\tt "not"} is the \underline{only} operator in
a {\em not-expression}, these equations can be simplified to
\begin{center}
\begin{tabular}{l}
{\em not-expression} \begin{tabular}[t]{rl}
		     ::= & \TT{not} {\em not-operand} \\
		     $|$ & \TT{not} {\em not-expression} \\
		     \end{tabular} \\
\end{tabular}
\end{center}
This simplification has been applied in section 
\itemref{BUILTIN-OPERATOR-SYNTAX-EQUATIONS} to simplify the following:
\begin{center}
{\em else-expression} \\
{\em not-expression} \\
{\em compare-expression} \\
{\em summation-expression} \\
{\em arithmetic-prefix-expression} \\
{\em shift-expression} \\
{\em bitop-prefix-expression}
\end{center}

Another implication of the above rules is what happens when
there are {\em parser-instructions} such as:
\begin{center}
\tt
\begin{tabular}{l}
define prefix "P" operators "+", "-"  \\
define prefix "P" operators "++", "-{}-"  \\
\end{tabular}
\end{center}
There produce the equations:
\begin{center}
\begin{tabular}{l}
{\em P-+-expression} \begin{tabular}[t]{rl}
		     ::= & {\em P-+-operator} {\em P-operand} \\
		     $|$ & {\em P-+-operator} {\em P-+-expression} \\
		     \end{tabular} \\
{\em P-expression} ::= {\em P-+-expression} \\
{\em P-+-operator} ::= \TT{+} $|$ \TT{-} \\
{\em P-++-expression} \begin{tabular}[t]{rl}
		     ::= & {\em P-++-operator} {\em P-operand} \\
		     $|$ & {\em P-++-operator} {\em P-++-expression} \\
		     \end{tabular} \\
{\em P-expression} ::= {\em P-++-expression} \\
{\em P-++-operator} ::= \TT{++} $|$ \TT{-{}-} \\
\end{tabular}
\end{center}
and the precedence table entries:
\begin{center}
\begin{tabular}{llll}
\RX{+} > \RX{+} & \RX{+} > \RX{-} & \RX{-} > \RX{+} & \RX{-} > \RX{-} \\
\RX{++} > \RX{++} & \RX{++} > \RX{-{}-} & \RX{-{}-} > \RX{++}
                                        & \RX{-{}-} > \RX{-{}-} \\
\RX{+} x \RX{++} & \RX{+} x \RX{-{}-} & \RX{-} x \RX{++} & \RX{-} x \RX{-{}-} \\
\RX{++} x \RX{+} & \RX{++} x \RX{-} & \RX{-{}-} x \RX{+} & \RX{-{}-} x \RX{-} \\
\end{tabular}
\end{center}
from which we derive that:
\begin{center}
\begin{tabular}{lll}
\tt + + x	& is legal & because \RX{+} > \RX{+} \\
\tt + - x	& is legal & because \RX{+} > \RX{-} \\
\tt ++ ++ x	& is legal & because \RX{++} > \RX{++} \\
\tt ++ -{}- x	& is legal & because \RX{++} > \RX{-{}-} \\
\tt + ++ x	& is \underline{not} legal & because \RX{+} x \RX{++} \\
\tt + -{}- x	& is \underline{not} legal & because \RX{+} x \RX{-{}-} \\
\tt ++ + x	& is \underline{not} legal & because \RX{++} x \RX{+} \\
\tt ++ - x	& is \underline{not} legal & because \RX{++} x \RX{-} \\
\end{tabular}
\end{center}

Contrast this with what happens with the {\em parser-instruction}:
\begin{center}
\tt
\begin{tabular}{l}
define prefix "P" operators "+", "-", "++", "-{}-"  \\
\end{tabular}
\end{center}
In this case `{\tt + ++ x}', etc. are legal.

The underlying idea is that operators of the same `precedence' can be
mixed only if they occur in the same {\em parser-instruction}.

\subsubsection{Parsing vs Type Checking}

The parser cannot identify as erroneous expressions such as
\begin{center}
\tt {\em if-expression} else ( {\em if-expression} )
\end{center}
in which the second `\TT{if}' is hidden inside parentheses.

In this case type checking will catch the error later in the
compilation, after parsing.

There are other possible cases where the parser cannot catch
errors that must be caught later by type checking.
For example, consider the {\tt "else"} operator
which is `{\tt asymmetric right associative}'.  This means
that in a sequence of operands and alternating {\tt "else"}
operators, the parser can make the rightmost operand different
from the other operands.  But because it is based on an
operator hierarchy table, the parser cannot
make the leftmost operand distinct from all the other operands.
It seems pure luck that the parser can do the right thing
for the {\tt "else"} operator, which is right associative only
because it defers the evaluation of its right operand.

\subsubsection{Parser Rewrite Rules}
\label{PARSER-REWRITE-RULES}

After parsing an expression, the parser applies rewrite rules
to the expression.  The builtin rules are:

\begin{indpar}\begin{verbatim}
rewrite "not" ( x "and" y ) ===>
        ( "not" ( x ) ) "or" ( "not" ( y ) )
rewrite "not" ( x "or" y ) ===>
        ( "not" ( x ) ) "and" ( "not" ( y ) )
rewrite "not" ( "not" x ) ===> x
rewrite "!" ( x "&" y ) ===>
        ( "!" ( x ) ) "|" ( "!" ( y ) )
rewrite "!" ( x "|" y ) ===>
        ( "!" ( x ) ) "&" ( "!" ( y ) )
rewrite "!" ( "!" x ) ===> x
\end{verbatim}\end{indpar}

These rules move {\tt "not"} inside {\tt "and"}
and {\tt "or"} and eliminate double negations,
and similarly move the bitwise complement operator {\tt "!"}
inside the bitwise operators {\tt "\&"} and {\tt "|"}
and eliminate double complements.

The general form of a parser rewrite rule is:
\begin{indpar}
\emkey{parser-rewrite-rule}
    ::= \ttkey{rewrite} ~ {\em expression-1}
    		   ~ \ttkey{===>} ~ {\em expression-2}
\end{indpar}
which says that any expression of the form {\em expression-1}
is to be rewritten as an expression of the form {\em expression-2}.
In these {\em expressions}, operators are quoted strings,
variables that take subexpressions as values are single words,
and parentheses are used to delimit subexpressions containing
operators.

A word naming a subexpression variable may appear at most once
in {\em expression-1}, but may appear any number of times, including
zero, in {\em expression-2}.

Explicit function names in an actual expression are not considered
to be operators for the purposes of rewriting.  Thus the code
line
\begin{center}
\tt bool x = "not" ( y and z )
\end{center}
will not be rewritten and after parsing will be
\begin{center}
\tt bool x = "not" ( y "and" z )
\end{center}
because "not" will not be treated as an operator,
whereas
\begin{center}
\tt bool x = not ( y and z )
\end{center}
will be rewritten and after parsing will be
\begin{center}
\tt bool x = ( "not" ( y ) ) "or" ( "not" ( z ) )
\end{center}

Rewrite rules can be applied to expressions in different
orders.  If the result does not depend upon the order of
rewrite rule application, the rules are said to be
\mkey{confluent}{rewrite rules}.  The builtin rules are confluent.
Its up to the programmer to make rules that are confluent, else
compilation will be non-deterministic.

\subsubsection{Parser Blocks}
\label{PARSER-BLOCKS}

{\em Parser-instructions} can only be included in {\em parser-blocks}
which themselves can only be included as {\em module-clauses} in
{\em module-declarations} (\pagref{MODULE-DECLARATION})
or {\em body-clauses} in {\em body-declarations} (\pagref{BODY-DECLARATION})
at the beginning of a file.

The {\em parser-instructions} at the beginning of a file are
added to the builtin {\em parser-instructions} to define the
operator precedence table used in the file.  The parsing
instructions in a module file also apply the files of bodies of that
module.

It is possible to export a block of {\em parser-instructions}.  This is
done by labeling a {\em parser-block} `\ttmkey{external}{parser-block}'
in a {\em module-declaration}.  The instructions in the external
{\em parser-blocks} of an exporting module can be imported by a
\begin{indpar}
\emkey{parser-import-instruction}\label{PARSER-IMPORT-INSTRUCTION} ::=
    \TT{import} ~ {\em module-name} ~ \TT{parsing}%
    \ttindex{import \ldots{} parsing}
\end{indpar}
in a {\em parser-block}.  This adds the {\em parser-instructions}
from the external {\em parser-block} of the named module to the
builtin {\em parser-instructions}.

The ordering of {\em parser-instructions} within a single {\em parser-block}
makes \underline{no} difference.  No two such instructions may define the same
operator with the same fixity.

The ordering of {\em parser-blocks} \underline{does} make a difference.
If {\em parser-block} X imports {\em parser-block} Y, or if X is in 
the body of a module and Y is the {\em parser-block} of the module, or if
Y is the block of builtin parser instructions, then
we say that Y is a parent of X.  The graph of parser blocks with the
parent relation must be acyclic.  The {\em parser-instructions} in the
ancestors of X in this graph are said to be \mkey{ancestor}{parser instruction}
{\em parser-instructions} of X.

Note that a module or body can contain at most one {\em parser-block}.
A module that contains nothing but a single exported {\em parser-block}
can be used to define {\em parser-instructions} that can be imported.

If a {\em parser-instruction} defines an operator with a given fixity,
then that operator is removed from all ancestor {\em parser-instructions}
in which it occurs with the same fixity.
For example, there are builtin {\em parser-instructions}
\begin{center}
\tt
\begin{tabular}{l}
define left associative "summation" operators "+", "-" \\
define prefix "arithmetic-prefix" operators "+", "-" \\
\end{tabular}
\end{center}
If a body {\em parser-block} contains the instruction
\begin{center}
define binary "foo" operator "+" \\
\end{center}
the first builtin instruction only will be modified to become
\begin{center}
\tt
\begin{tabular}{l}
define left associative "summation" operator "-" \\
\end{tabular}
\end{center}
If the body {\em parser-block} also contains the instruction
\begin{center}
define left associative "bar" operator "-" \\
\end{center}
that builtin instruction would be deleted entirely.  However the builtin
instruction
\begin{center}
\tt
\begin{tabular}{l}
define prefix "arithmetic-prefix" operators "+", "-" \\
\end{tabular}
\end{center}
would \underline{not} be modified by any of this.

The parser instruction 
\begin{indpar}
\emkey{parser-delete-instruction}\label{PARSER-DELETE-INSTRUCTION}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{delete}{operator} {\em operator-type}
          \TT{operator} {\em operator-name} \\
    $|$ & \ttmkey{delete}{operator} {\em operator-type}
          \TT{operators} {\em operator-name-list} \\
    $|$ & \ttmkey{delete}{rewrite rule} \TT{rewrite}
          {\em expression} \\
    \end{tabular}
\end{indpar}
may be used to delete operators or rewrite rules from ancestor
{\em parser-instructions}.

The first two forms delete operators.
An operator listed in one of these
{\em parser-delete-instructions} cannot be listed in
any other {\em parser-instruction} in the same {\em parser-block}.
The {\em operator-type} in a
{\em parser-delete-instruction} is only used to specify
the operator fixity, and need not otherwise match the {\em operator-type}
in the ancestor {\em parser-instruction} that is affected.
For example, {\tt binary} may be used in the {\em parser-delete-instruction}
where {\em associative} is used in the affected ancestor
{\em parser-instruction}.

The last form deletes rewrite rules whose first {\em expression}
matches the expression given in the {\em parser-delete-instruction}.
Here the operators and parentheses of the {\em expressions} must match
exactly, but words that name subexpression variables may differ.

\subsubsection{Primaries}
\label{PRIMARIES}



It is the compiler, and not the parser, that analyzes {\em primaries},
because knowledge of the {\em names} in scope is required.  To the
compiler, a {\em primary} has the following syntax:
\begin{indpar}
\emkey{primary}\label{COMPILER-PRIMARY}
    \begin{tabular}[t]{rl@{\hspace*{0.4in}}l}
    ::= & {\em constant} \\
    $|$ & {\em variable-name} 		& [see \pagref{VARIABLE-NAME}] \\
    $|$ & {\em variable-declaration} \\
    $|$ & {\em qualifier-conversion} \\
    $|$ & {\em type-conversion} \\
    $|$ & {\em function-call}		& [see \pagref{FUNCTION-CALL}] \\
    \end{tabular}
\\[0.5ex]
\emkey{constant}\label{CONSTANT}
    \begin{tabular}[t]{rl@{\hspace*{0.5in}}l}
    ::= & {\em number-constant} 	& [see \pagref{NUMBER-CONSTANT}] \\
    $|$ & {\em character-constant} 	& [see \pagref{CHARACTER-CONSTANT}]  \\
    $|$ & {\em string-constant} 	& [see \pagref{STRING-CONSTANT}]  \\
    $|$ & {\em name-constant} 		& [see \pagref{NAME-CONSTANT}]  \\
    $|$ & {\em enum-set-constant}	& [see \pagref{ENUM-SET-CONSTANT}]  \\
    $|$ & {\em enum-list-constant}	& [see \pagref{ENUM-LIST-CONSTANT}]  \\
    $|$ & {\em name-set-constant}	& [see \pagref{NAME-SET-CONSTANT}]  \\
    $|$ & {\em name-list-constant}	& [see \pagref{NAME-LIST-CONSTANT}]  \\
    \end{tabular}
\\[0.5ex]
\emkey{variable-declaration} ::= {\em qualifier-name}\STAR{}
                                 {\em type-name} {\em variable-name}
\\[0.5ex]
\emkey{qualifier-conversion}
    ::= {\em qualifier-name}\PLUS{} \TT{(} {\em expression} \TT{)}
\\[0.5ex]
\emkey{type-conversion}
    ::= {\em qualifier-name}\STAR{} {\em type-name}
        \TT{(} {\em expression} \TT{)}
\end{indpar}

If the {\em primary} is not a {\em constant}, the compiler
checks the scope to see if it is a {\em variable-declaration},
{\em variable-name}, {\em qualifier-conversion}, or
{\em type-conversion}.  If it is none of these, the
compiler applies the {\em function-call} matching rules of
\itemref{MATCHING-CALLS-TO-PROTOTYPES}
to match the {\em primary} to a {\em function-prototype}.

\subsection{Expression Semantics}

Expressions provide standard operators.  Expressions are compiled
into function calls, and builtin functions
implement logical and numeric operators.

\subsubsection{Expression Typing}
\label{EXPRESSION-TYPING}

L-Language uses a top-down method of assigning types to operator arguments.
Generally given the statement
\begin{center}
$T$ $v$ ~ \TT{=} ~ $e1$ ~ $op$ ~ $e2$
\end{center}
where $T$ is a type of a variable $v$,
$op$ is a builtin arithmetic operator,
and $e1$, $e2$ are subexpressions that are the operands of $op$, then
the subexpression values are implicitly converted to type $T$
before the operation is done.  Here $T$ is called the `\key{target type}'
of the expression `$e1$ $op$ $e2$', and for builtin arithmetic operators
usually becomes the target type of the operand subexpressions.

An example is:

\begin{indpar}\begin{verbatim}
float64 w = 1.5
int64 x = 9,568
uns64 y1 = 0xFF00
uns32 y2 = 0xFF00
int64 z1 = x + y1
    // Compile error:
    //     y1 is not implicitly convertible to int64
int64 z2 = x + y2
    // OK, y2 IS implicitly convertible to int64
int64 z3 = x + y2 * w
    // Compile error:
    //     Target type of x + ( y2 * w ) is int64, so
    //     target type of y2 * w is int64, target type
    //     of y2 is int64 which is OK, and target type
    //     of w is also int64, but w is not implicitly
    //     convertible to int64.
\end{verbatim}\end{indpar}

More explicitly, the mechanism by which this all works is as
follows.  Given the statement
\begin{center}
\tt $T$ $v$ = $e1$ $op1$ $e2$ $op2$ $e3$
\end{center}
where $T$ is a type of a variable $v$, $e1$, $e2$, $e3$ are
operand subexpressions, and $op1$, $op2$, \ldots{} are builtin arithmetic
operators with the
same precedence like \TT{+} and \TT{-}, then
after parsing and compilation the statement is translated to
\begin{center}
\begin{tabular}{l}
\tt $T1$ tmp1 = $e1$ \\
\tt $T2$ tmp2 = $e2$ \\
\tt $T3$ tmp3 = tmp1 "$op1$" tmp2 \\
\tt $T4$ tmp4 = $e3$ \\
\tt $T$ $v$ = tmp3 "$op2$" tmp4 \\
\end{tabular}
\end{center}
For builtin arithmetic operators like \TT{+} and \TT{-} the function
prototype is equivalent to
\begin{center}
\tt $T$ r = ( $T$ arg1 ) "$op$" ( $T$ arg2 )
\end{center}
in which the arguments are given the same type as the result,
so the target type of the function call becomes the target type
of each argument.  Therefore in the example $T3\equiv T$ and
$T4\equiv T$.  The function call for computing {\tt tmp3} is
similar and results in $T2\equiv T$, $T1\equiv T$.  Therefore
all operands are converted to the target type $T$ of the final
result variable $v$.

The target type of an expression is usually provided by the
type of the variable being set by an assignment statement, or in the
case of function arguments, by the argument type specified in the
function prototype.

The target type of a {\em logical-expression} or a {\em comparison-expression}
is \TT{bool}.

In some cases the target type is specified by special rules.  The
target type of {\em comparison-operands} is specified by special
rules given in \itemref{COMPARISON-EXPRESSIONS}.

Some special rules
make use of the `\key{natural type}'\label{NATURAL-TYPE}
that some subexpressions have.
The natural type of a variable is its type.
For an expression of the form `\TT{$Qs$ $T$ ( \ldots{} )}'
where $Qs$ is a list of qualifiers and $T$ is a type name, the
natural type is $T$.
The natural type of a {\em function-call} is the type found by matching
the call to {\em function-prototypes}
(\itemref{MATCHING-CALLS-TO-PROTOTYPES}), if an unambiguous
match can be found under the assumption that
the call has a result variable of unknown type.
No other expression has a natural type.

When an expression has a natural type, it also has natural qualifiers
that are found with the natural type.

If there is no target type because an expression is being used
as a {\em simple-assignment-statement} with no result variables, then
the expression must be a {\em function-call} and can only match
{\em function-prototypes} that have no result variables.

\subsubsection{Evaluation Order}
\label{EVALUATION-ORDER}

All builtin operators evaluate operands and operators from
left to right.  All that are associative are left associative,
except the `\TT{else}' operator, which evaluates from left
to right because it has a deferred second operand, even though
it is right associative.

For example, `{\tt x <{}< s1 >{}> s2}' is
equivalent to `{\tt (x <{}< s1) >{}> s2}'.

The `\TT{if} operator defers its first operand, while
the `\TT{else}', `\TT{and}' and `\TT{or} operators, and sometimes the
6 builtin comparison operators (\TT{<}, \TT{==}, etc.),
defer their second operand.  Usually operands are evaluated
before the operator executes, but a deferred operand is not
evaluated until inspection of other operand values determines
that the deferred operand value will be needed.  Furthermore,
if the other operand values are available at compile time,
and inspecting them at compile time determines that the deferred
operand value will not be needed, the deferred operand is not
even compiled.  Such an uncompiled deferred operand might have
compile errors were it compiled, but it will cause no compile
errors if it is not compiled.

For example, if in `\TT{$e1$~and~$e2$}' the subexpression $e1$
evaluates to \TT{false}, the subexpression $e2$ is never evaluated.
If $e1$ evaluates at compile-time to \TT{false},
$e2$ is not compiled, and any compile errors it contains
are not detected.  Similarly in `\TT{$e1$~if~$b$~else~$e2$}' if the
conditioning expression $b$ evaluates to \TT{true}, $e2$ is
never evaluated, and if $b$ evaluates to \TT{true} at compile
time, $e2$ is never compiled.  However all subexpressions are parsed and
parsing errors are always detected.

Deferred operands are just a particular case of deferred function arguments,
as operators are translated by the parser into function calls.
For example, the `\TT{and}' operator, which the parser translates
into the {\tt "and"} function, is implemented by the function
declaration:

\begin{indpar}\begin{verbatim}
function bool r =
        ( bool arg1 ) "and" ( *DEFERRED* bool arg2 ):
    if:
        arg1:
            r = do ( std call context ):
                r = arg2
        else:
            r = false
\end{verbatim}\end{indpar}

The assignment statement `{\tt bool v = $e1$ and $e1$}' is
translated by the parser into `{\tt bool v = $e1$ "and" $e2$}' which
given the above function declaration compiles to:\label{AND-EXAMPLE}
\begin{indpar}
\begin{tabular}{l}
\tt std context tmp0 = std current context \\
\tt // tmp0 is call(er) context \\
\tt // and-context is context of "and" function declaration \\
\tt // \\
\tt // Evaluate $e1$ - left operand of "and"\\
\tt bool tmp1 = $e1$ \\
\tt // \\
\tt // Evaluate ($e1$ "and" $e2$) \\
\tt bool v = do ( and-context ): \\
\tt ~~if: \\
\tt ~~~~tmp1: \\
\tt ~~~~~~do ( tmp0 ): \\
\tt ~~~~~~~~v = $e2$ \\
\tt ~~~~else: \\
\tt ~~~~~~v = false \\
\end{tabular}
\end{indpar}

There are context issues here.  For details on contexts,
see \itemref{SCOPE},
\itemref{CONTEXTS}, and the context option of the
{\em block-assignment-statement} in 
\itemref{BLOCK-ASSIGNMENT-STATEMENTS}).

\subsubsection{If/Else Expressions}
\label{IF/ELSE-EXPESSIONS}

The expression
\begin{center}
\tt $e1$ if $b1$ else $e2$ if $b2$ \ldots{} else $e$
\end{center}
is evaluated as follows.
$b1$ is evaluated first.  If it is \TT{true}, $e1$ is evaluated and its
value is returned.  If it is \TT{false}, $e1$ is \underline{not}
evaluated, and instead $b2$ is evaluated.  If that is \TT{true}
$e2$ is evaluated and its value is returned.  But if $b2$ is \TT{false}
evaluation of the expression continues.  If none of
the $bI$ evaluate to \TT{true}, $e$ is evaluated and returned as the result.

The target type of each $bI$ is \TT{bool} and the target type of each
$eI$ is the target type of the whole expression.
Only one of the $eI$ is evaluated.

If any $bI$ is a compile time
\TT{false} value, the associated $eI$ is not compiled or checked
for compile errors.
If any $bI$ is a compile time
\TT{true} value, the subsequent $bJ$'s and their associated $eJ$'s,
and also $e$,
are not compiled or checked
for compile errors.

In the rest of this section we consider the details of
how all the above happens.

A statement such as
\begin{center}
\tt $T$ $v$ = $e1$ if $b1$ else $e2$ if $b2$ else $e3$
\end{center}
is parsed to become
\begin{center}
\tt $T$ $v$ = ($e1$ "if" $b1$) "else" ( ($e2$ "if" $b2$) "else" $e3$ )
\end{center}

Here {\tt "else"} is parsed as a right associative operator,
but because it defers the evaluation of its right operand,
it evaluates its operands left to right.

The following are the builtin function definitions for
the {\tt "if"} and {\tt "else" } functions:

\begin{indpar}\label{IF-ELSE-IMPLEMENTATION}\begin{verbatim}
define type std *IF-VALUE* as void
    // The expression `e "if" b' has as its value an
    // *IF-VALUE* r that is a root of a cluster with members:
    //
    //    bool r.valid  Value of b.
    //    Qs T r.value  Value of e if r.valid true.
    //                  *UNCHECKED* ( *NO* *VALUE* )
    //                  if r.valid false.
    //
    // where T is the type of the e value and cannot itself
    // equal *IF-VALUE*, and Qs are the value qualifiers of
    // the e value, or is the empty set if r.valid is known
    // at compile time to be false.

function *IF-VALUE* r, T r.value, bool r.valid =
        (| type T |)
        ( *UNUSED* arg1 ) "if" ( bool arg2 == false )
        [| T != std *IF-VALUE* |]:
    if:
        r.value = *UNCHECKED* T ( *NO* *VALUE* )
        r.valid = false

function *IF-VALUE* r, Qs T r.value, bool r.valid =
        (| type T, qualifiers Qs |)
        ( *DEFERRED* Qs T arg1 ) "if" ( bool arg2 )
        [| T != std *IF-VALUE* |]:
    if:
        arg2:
                do ( std call context ):
                    r.value = arg1
                r.valid = true
        else:
            r.value = *UNCHECKED* Qs T ( *NO* *VALUE* )
            r.valid = false

function Qs T r =
        (| type T, qualifiers Qs |)
        ( *IF-VALUE* arg1, Qs T arg1.value,
                           bool arg1.valid == true )
        "else"
        ( *UNUSED* arg2 )
        [| T != std *IF-VALUE* |]
    if:
        r = arg1.value

function Q1s Q2s T r =
        (| type T, qualifiers Q1s, qualifiers Q2s |)
        ( *IF-VALUE* arg1, Q1s T arg1.value,
                           bool arg1.valid )
        "else"
        ( *DEFERRED* Q2s T arg2 )
        [| T != std *IF-VALUE* |]
    if:
        arg1.valid:
            r = arg1.value
        else:
            do ( std call context ):
                r = arg2
\end{verbatim}\end{indpar}

These functions use an {\tt *IF-VALUE*} cluster (see
\itemref{CLUSTERS} for details of clusters) to record
whether the {\em logical-expression} input to the {\tt "if"}
function was \TT{true} or \TT{false} and also record
the value of the other expression input to the {\tt "if"}
function when the {\em logical-expression} was \TT{true}.
These functions use the {\em if-assignment} statement
described in \itemref{CONDITIONAL-ASSIGNMENT-STATEMENTS}.

Given these definitions the compiler expands the example
\begin{center}\label{IF-ELSE-EXAMPLE}
\tt $T$ $v$ = ($e1$ "if" $b1$) "else" ( ($e2$ "if" $b2$) "else" $e3$ )
\end{center}

to the following \LSTAR-language (\pagref{LSTAR-LANGUAGE}) code:

\begin{indpar}
\begin{tabular}{l}
\tt std context tmp0 = std current context \\
\tt // tmp0 is call(er) context \\
\tt // if-context is context of "if" function declaration \\
\tt // else-context is context of "else" function declaration \\
\tt // \\
\tt // Evaluate $b1$ - right operand of first "if"\\
\tt bool tmp1 = $b1$ \\
\tt // \\
\tt // Evaluate ($e1$ "if" $b1$) - left operand of first "else" \\
\tt *IF-VALUE* tmp2, $T$ tmp2.value, bool tmp2.valid = \\
\tt ~~~~do ( if-context ): \\
\tt ~~if: \\
\tt ~~~~tmp1: \\
\tt ~~~~~~do ( tmp0 ): \\
\tt ~~~~~~~~tmp2.value = $e1$ \\
\tt ~~~~~~tmp2.valid = true \\
\tt ~~~~else: \\
\tt ~~~~~~tmp2.value = *UNCHECKED* ( *NO* *VALUE* ) \\
\tt ~~~~~~tmp2.valid = false \\
\end{tabular}

\begin{tabular}{l}
\tt // Evaluate first "else" \\
\tt $T$ $v$ = do ( else-context ): \\
\tt ~~if: \\
\tt ~~~~tmp2.valid: \\
\tt ~~~~~~$v$ = tmp2.value \\
\tt ~~~~else: \\
\tt ~~~~~~do ( tmp0 ): \\
\end{tabular}

\begin{tabular}{l}
\tt ~~~~~~~~// Evaluate (($e2$ "if" $b2$) "else" $e3$") \\
\tt ~~~~~~~~// - deferred right operand of first "else" \\
\tt ~~~~~~~~// Evaluate $b2$ \\
\tt ~~~~~~~~// - right operand of second "if" \\
\tt ~~~~~~~~bool tmp3 = $b2$ \\
\tt ~~~~~~~~// Evaluate ($e2$ "if" $b2$) \\
\tt ~~~~~~~~// - left operand of second "else" \\
\tt ~~~~~~~~*IF-VALUE* tmp4, $T$ tmp4.value, \\
\tt ~~~~~~~~~~~~~~~~~~~~~~~~~bool tmp4.valid = \\
\tt ~~~~~~~~~~do ( if-context ): \\
\tt ~~~~~~~~~~~~if: \\
\tt ~~~~~~~~~~~~~~tmp3: \\
\tt ~~~~~~~~~~~~~~~~do ( tmp0 ): \\
\tt ~~~~~~~~~~~~~~~~~~tmp4.value = $e2$ \\
\tt ~~~~~~~~~~~~~~~~tmp4.valid = true \\
\tt ~~~~~~~~~~~~~~else: \\
\tt ~~~~~~~~~~~~~~~~tmp4.value = *UNCHECKED* ( *NO* *VALUE* ) \\
\tt ~~~~~~~~~~~~~~~~tmp4.valid = false \\
\end{tabular}

\begin{tabular}{l}
\tt ~~~~~~~~// Evaluate second "else" \\
\tt ~~~~~~~~do ( else-context ): \\
\tt ~~~~~~~~~~if: \\
\tt ~~~~~~~~~~~~tmp4.valid: \\
\tt ~~~~~~~~~~~~~~v = tmp4.value \\
\tt ~~~~~~~~~~~~else: \\
\tt ~~~~~~~~~~~~~~do ( tmp0 ): \\
\tt ~~~~~~~~~~~~~~~~v = $e3$ \\
\end{tabular}

\end{indpar}

In this code the type $T$ of the result variable $v$ becomes
the type of the result of the first {\tt "else"} whose
first argument then assumes the types given in
\begin{center}
\tt *IF-VALUE* tmp2, $T$ tmp2.value, bool tmp2.valid
\end{center}
and whose second argument gets type $T$.  The second argument
is the second {\tt "else"} subexpression, and as it has
target type $T$, the arguments of the second {\tt "else"}
have the same types as the arguments of the first {\tt "else"}.

The first argument of {\tt "if"} and the second argument of {\tt "else"}
are {\tt *DEFERRED*}, which means that they are not computed before
the functions are called, but instead the expressions computing them
are inserted in the code expanded from the functions (which are
inline).  See the discussion at the end of the Evaluation Order section
\itemref{EVALUATION-ORDER}.

\subsubsection{Logical (And/Or/Not) Expressions}

In logical expressions the `\TT{not}' operator is moved inside
`\TT{and}' and `\TT{or}' operators before further evaluation.
Also double negations are deleted.

Thus the following example:
\begin{center}
\begin{tabular}{lcl}
	  &			& \tt not ( x and not y and z ) \\
parser:	  & $\Longrightarrow$ 	& \tt not ( ( x and ( not y ) ) and z ) \\
compiler: & $\Longrightarrow$ 	& \tt ( not ( x and ( not y ) ) ) or
                                                        ( not z ) \\
compiler: & $\Longrightarrow$ 	& \tt ( ( not x ) or (not ( not y ) ) ) or
                                                        ( not z ) \\
compiler: & $\Longrightarrow$ 	& \tt ( ( not x ) or y ) or ( not z ) \\
\end{tabular}
\end{center}

The target type for logical expressions and their operands
is always \TT{bool}.

The expression\\
\centerline{\tt $b1$ and $b2$ and $b3$ and \ldots{}}\\[1ex]
is evaluated from left to right and if any $bI$ evaluates to \TT{false},
evaluation of later $bI$ is skipped.
If any $bI$ is a
compile time \TT{false} value, the remaining $bI$ are not compiled
or checked for compile errors.

Similarly the expression\\
\centerline{\tt $b1$ or $b2$ or $b3$ or \ldots{}}\\[1ex]
is evaluated from left to right and if any $bI$ evaluates to \TT{true},
evaluation of later $bI$ is skipped.
If any $bI$ is a
compile time \TT{true} value, the remaining $bI$ are not compiled
or checked for compile errors.

This is implemented by defining
the {\tt "and"} and {\tt "or" } functions as follows:

\begin{indpar}\begin{verbatim}
function bool r =
        ( bool arg1 ) "and" ( *DEFERRED* bool arg2 ):
    if:
        arg1:
            do ( std call context ):
                r = arg2
        else:
            r = false

function bool r =
        ( bool arg1 ) "or" ( *DEFERRED* bool arg2 ):
    if:
        arg1:
            r = true
        else:
            do ( std call context ):
                r = arg2
\end{verbatim}\end{indpar}

Here the right operands are {\tt *DEFERRED*} and if needed are
evaluated in the context of the caller of the {\tt "and"} or
{\tt "or"} functions.
See the discussion at the end of the Evaluation Order section
\itemref{EVALUATION-ORDER}.


\subsubsection{Comparison (</<=/==/!=/=>/>) Expressions}
\label{COMPARISON-EXPRESSIONS}

The target type for comparison expressions is always \TT{bool}.

There is no given target type for operands of comparison operators.
So the target type of these must be specified by rules.

For numeric operands of comparison operators
the target type is the most specific type (\pagref{MORE-SPECIFIC-RELATION})
in the following set that is such that all operands
can be implicitly converted to that type:
\begin{center}
\TT{unswrd} ~ \TT{intwrd} ~ \TT{unsmax} ~ \TT{intmax}
           ~ \TT{floatwrd} ~ \TT{floatmax}
\end{center}

An example assuming:


\begin{indpar}\begin{verbatim}
unswrd      is 32 bits
intwrd      is 32 bits
unsmax      is 64 bits
intmax      is 64 bits
\end{verbatim}\end{indpar}

is:

\begin{indpar}\begin{verbatim}
int64 x = 9,568
uns64 y1 = 0xFF00
uns32 y2 = 0xFF00
bool z1 = x < y1
    // Compile error:
    //     x and y1 cannot be implicitly converted
    //     to the same target type
bool z1 = x < y2
    // OK, x and y2 are implicitly convertible to
    // intmax (int64)
\end{verbatim}\end{indpar}

Non-numeric comparison operators require that one or more of
the operands have a natural type (\pagref{NATURAL-TYPE}) that
cannot be converted to one of the numeric types listed above.
In this case the target type is
the greatest lower bound (\pagref{GREATEST-LOWER-BOUND})
of all these natural types.
It is a compile error if this greatest lower bound does
not exist, or if comparison operators are not defined for this
type.
For example, given the expression `{\tt v == missing}', where \TT{v}
is of `\TT{qualifier}' type, {\tt missing}, which has no natural type, will be
evaluated with `\TT{qualifier}' target type.

Note that a comparison operator may not have a negation that is
also simply a comparison operator, e.g., \TT{=>} may not be the
negation of \TT{<}.  For example, both return \TT{false} if an
operand is \TT{NaN}.  For this reason `{\tt x => y}' and
`{\tt not ( x < y )}' are semantically different expressions.

Comparison expressions are evaluated from left to right and are
true if and only if all the comparisons are true.  Middle
arguments are shared between two comparison operators, e.g.,
in `{\tt x < y < z}' the middle argument {\tt y} is evaluated
once and shared between `{\tt x < y}' and `{\tt y < z}'.
An example is:

\begin{indpar}\begin{verbatim}
// Assume intwrd is int64, unswrd is uns64.
//
int64 x = 9,568
uns16 y1 = 0xFF00
uns32 y2 = 0xFF01
bool z1 = x < y1 < y2
    // x, y1, y2 are all converted to intwrd (int64).
    // y2 is only converted if x < y1 is true.
bool z2 = x < y1 and y1 < y2
    // y1 is converted to intwrd to compare it with x
    // and then if x < y1 is true, y1 is separately
    // converted to unswrd (uns64) to compare it with y2.
\end{verbatim}\end{indpar}

If one comparison in a sequence of comparisons evaluates
to \TT{false}, operands following those of this comparison
are not evaluated.  If one comparison in a sequence of comparisons
evaluates to \TT{false} at compile time,
the operands following those of this comparison are not compiled.

This is implemented by the following builtin code:

\begin{indpar}\label{COMPARE-IMPLEMENTATION}\begin{verbatim}
define type std *COMPARE-VALUE* as void
    // The expression `e1 "cop" e2' where cop is a comparison
    // operator has as its value a *COMPARE-VALUE* r that is
    // a root of a cluster with members:
    //
    //    bool r.value  Result of comparison.
    //    T r.right op  Value of e2 (i.e., right operand) if
    //                  r.value is true.  *UNCHECKED* no
    //                  value if r.value is false.
    //
    // where T is the type of the operands and cannot itself
    // equal *COMPARE-VALUE*.
    //
    // *COMPARE-VALUE*s are implicitly convertible to bool's.

function Qs bool r = assign
                     (| qualifiers Qs |)
                     ( Qs *COMPARE-VALUE v, bool v.value ):
    r = v.value

// The following are defined separately for various types T
// and for comparison operators other than "<".
// 
function *COMPARE-VALUE* r, T r.right op, bool r.value =
        ( T arg1 ) "<" ( T arg2 ):
    r.right op = arg2
    r.value = arg1.right op "<" r.right op

function *COMPARE-VALUE* r, T r.right op, bool r.value =
        ( *COMPARE-VALUE* arg1, T arg1.right op,
                                bool arg1.value )
        "<" ( *DEFERRED* T arg2 ):
    if:
        arg1.value:
            do ( std call context ):
                r.right op = arg2
            r.value = arg1.right op "<" r.right op
        else:
            r.right op = *UNCHECKED* ( *NO* *VALUE* )
            r.value = false

function bool r = ( T arg1 ) "<" ( T arg2 ):
    r = [[[code to implement compare of arg1 and arg2]]]
\end{verbatim}\end{indpar}

Compare operations are left associative.

Given these definitions the parser expands the example
\begin{center}\label{COMPARE-EXAMPLE}
\tt bool $v$ = $e1 "<" $e2 "<" $e3$
\end{center}
to
\begin{center}
\tt bool $v$ = ( $e1 "<" $e2 ) "<" $e3$
\end{center}
and the compiler expands this to the following
\LSTAR-language (\pagref{LSTAR-LANGUAGE}) code:

\begin{indpar}
\begin{tabular}{l}
\tt std context tmp0 = std current context \\
\tt // tmp0 is call(er) context \\
\tt // lt-context is context of "<" function declaration \\
\tt // implied-conversion-context is context of the \\
\tt // ~~~~~~~~`assign' function declaration \\
\end{tabular}

\begin{tabular}{l}
\tt // Evaluate $e1$ and $e2$ - operands of first "<" \\
\tt T tmp1 = $e1$ \\
\tt T tmp2 = $e2$ \\
\end{tabular}

\begin{tabular}{l}
\tt // Evaluate `($e1$ "<" $e2$ )' \\
\tt // - right operand of second "<" \\
\tt *COMPARE-VALUE* tmp3, $T$ tmp3.right op, bool tmp3.value = \\
\tt ~~~~~~~~do ( lt-context ): \\
\tt ~~~~tmp3.right op = tmp2 \\
\tt ~~~~tmp3.value = tmp1 "<" tmp2 \\
\end{tabular}

\begin{tabular}{l}
\tt // Evaluate second "<" \\
\tt *COMPARE-VALUE* tmp4, $T$ tmp4.right op,\\
\tt ~~~~~~~~~~~~~~~~~~~~~~bool tmp4.value = \\
\tt ~~~~do ( lt-context ): \\
\tt ~~~~~~~~if: \\
\tt ~~~~~~~~~~~~tmp3.value: \\
\tt ~~~~~~~~~~~~~~~~do ( tmp0 ): \\
\tt ~~~~~~~~~~~~~~~~~~~tmp4.right op = $e3$ \\
\tt ~~~~~~~~~~~~~~~~tmp4.value = \\
\tt ~~~~~~~~~~~~~~~~~~~~tmp3.right op "<" tmp4.right op \\
\tt ~~~~~~~~~~~~else: \\
\tt ~~~~~~~~~~~~~~~~tmp4.right op = \\
\tt ~~~~~~~~~~~~~~~~~~~~*UNCHECKED* ( *NO* *VALUE* ) \\
\tt ~~~~~~~~~~~~~~~~tmp4.value = false \\
\end{tabular}

\begin{tabular}{l}
\tt // Evaluate bool $v$ = assign ( ... ) \\
\tt bool v = do ( implied-conversion-context ): \\
\tt ~~~~v = tmp4.value \\
\end{tabular}

\end{indpar}

Typing of comparison expressions, as described above, is a
consequence of the rules for matching function calls to
prototypes, and specifically of the rule that more restrictive
argument types are preferred to less restrictive ones
(rule \ref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED} on
\pagref{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}).
A function like {\tt "<"} is only defined for
some second operand types.  Given the type $T$ of the second operand
of the rightmost compare operator in a sequence of several compare operators,
the type of the first operand is a {\tt *COMPARE-VALUE*}
whose {\tt right op} member has type $T$.  Then the target types
of the remaining operands in the compare operator sequence are determined.
So if we have two candidates
for $T$, $T1$ and $T2$, we only need to choose the correct one.
By the rule cited, if $T1$ is implicitly convertible to $T2$, then
the types of both operands of the rightmost compare operator
in the $T1$ case will be
implicitly convertible to the types of the operands in the $T2$ case
and the rule will apply to reject $T2$.  Note that we do not need
an `{\tt assign}' function for {\tt *COMPARE-VALUE*}
values, as it suffices for the $T1$ `{\tt right op}' member to be
implicitly convertible to the $T2$ `{\tt right op}' member.

Importantly comparison operators, such as \TT{==}, are
\underline{not} defined for \TT{bool} operands.  Since many
types are implicitly convertible to \TT{bool}
(see \pagref{IMPLIED-BOOL-CONVERSION}), defining comparison
operators for \TT{bool} values would badly compromise compile time
detection of programming errors.\footnote{Another difficulty
with allowing comparison of \TT{bool} values is that in
`{\tt $e1$ < $e2$ < $e3$}' the first {\tt <} could evaluate
to a \TT{bool} and not a \TT{*COMPARE-VALUE*}.}

In order to implement a comparison operator $cop$ with optional
module abbreviation $ma$ for a new
type $T$, one defines a function with the prototype:
\begin{center}
\tt function bool r = $ma$\QMARK{} ( $T$ arg1 ) "$cop$" ( $T$ arg2 )
\end{center}
and then you add the line
\begin{center}
\tt define compare operator [$ma$]\QMARK{} ( $T$, "$cop$" )
\end{center}
This last line invokes the builtin generic:

\label{DEFINE-COMPARE-OPERATOR}%
\begin{indpar}\begin{verbatim}
generic std define compare operator ( type T, name OP )
            [| export if T exported |]:

    include ( T, OP ):

        function ..ma *COMPARE-VALUE* r, T r.right op,
                                       bool r.value =
                ( T arg1 ) OP ( T arg2 ):
            r.right op = arg2
            r.value = M ( arg1 op OP r.right op )

        function ..ma *COMPARE-VALUE* r, T r.right op,
                                       bool r.value =
                ( *COMPARE-VALUE* arg1, T arg1.right op,
                                        bool arg1.value )
                OP ( *DEFERRED* T arg2 ):
            if:
                arg1.value:
                    r.right op = do ( std call context ):
                        r.right op = arg2
                    r.value =
                        M ( arg1.right op OP r.right op )
                else:
                    r.right op = *UNCHECKED* ( *NO* *VALUE* )
                    r.value = false
\end{verbatim}\end{indpar}

\subsubsection{Integer Arithmetic Expressions}

If an integer arithmetic operator is being evaluated with
operand and target type \TT{uns$x$} or \TT{int$x$}, the
exact arithmetic result is computed and truncated to
$x$ bits, i.e., is taken modulo $2^x$ before being presented
as the result.

Some exceptions to this are made for integer division operations.
If the divisor is zero, the results are undefined.  If the
target type is \TT{int$x$}, the dividend is $-2^{x-1}$, and
the divisor is $-1$, the result is undefined.  In both these
cases the result may be a program terminating error.

Except for the right operands of
shift operators, the operand types of builtin
integer arithmetic operators are the target type of the result.

The arithmetic operators \TT{+}, \TT{-}, and \TT{*} are builtin.

The builtin bitwise operators are:
\begin{center}
\begin{tabular}{ll}
\TT{\&}		& bitwise AND \\
\TT{|}		& bitwise OR \\
\TT{xor}	& bitwise EXCLUSIVE OR \\
\TT{!}		& bitwise complement \\
\TT{<{}<}	& bitwise shift left \\
\TT{>{}>}	& bitwise shift right \\
\end{tabular}
\end{center}

In `{\tt v >{}> s}' and `{\tt v <{}< s}', {\tt v} is converted to the
target type which may be any integer type $T$, but {\tt s} is converted
to \TT{unswrd} and only its low order $x$ bits are used as the
shift amount, where $x$ is the size of $T$.
In other words, the shift amount is {\tt s mod 2$^x$}.

The builtin integer division operators are:
\begin{center}
\begin{tabular}{ll}
\TT{div}	& quotient rounded towards zero \\
\TT{mod}	& modulo; remainder when quotient is rounded
                  toward negative infinity \\
\TT{rem}	& remainder when quotient is rounded toward zero \\
\end{tabular}
\end{center}

The operator \TT{/} is strictly floating point.  The operator
\TT{\textasciicircum} is \underline{not} builtin and must be
defined by library code.

\subsubsection{Floating Point Arithmetic Expressions}
\label{FLOATING-POINT-ARITHMETIC-EXPRESSIONS}

There is a `\key{floating point error register}' that holds
floating point error flags that may be set by floating point
arithmetic and comparison operations.  These flags are `\key{sticky}', in that
arithmetic and comparison
operations may set them but may never clear them.  There are also
special builtin functions to manipulate these flags
(\itemref{FLOATING-POINT-ERROR-FLAG-FUNCTIONS}).

The flags and operation results when the flags are set are as follows:
\begin{indpar}
\mkey{Invalid Operand}{floating point error flag}
\begin{indpar}
Set upon one of the following:
\begin{center}
\begin{tabular}{l}
Compare operand is a \TT{NaN}. \\
Adding \TT{+Inf} and \TT{-Inf}. \\
Subtracting \TT{+Inf} from \TT{+Inf}. \\
Subtracting \TT{-Inf} from \TT{-Inf}. \\
Multiplying \TT{0} by \TT{+Inf} or \TT{-Inf}. \\
Dividing \TT{+Inf} or \TT{-Inf} by \TT{+Inf} or \TT{-Inf}. \\
Dividing \TT{0} by \TT{0}. \\
\end{tabular}
\end{center}

Except for compares, the result is \TT{NaN}.
For compares, the result is \TT{false}.
\end{indpar}

\mkey{Divide By Zero}{floating point error flag}
\begin{indpar}
Set by a floating point division with a \TT{+0} or
\TT{-0} divisor and a non-zero dividend.

The result is \TT{+Inf} if both operands have the
same sign and \TT{-Inf} if they have opposite signs.
\end{indpar}

\mkey{Result Overflow}{floating point error flag}
\begin{indpar}
Set if result has magnitude too large to store in a target type value.

If the result is positive, \TT{+Inf} is stored, and if negative,
\TT{-Inf} is stored.
\end{indpar}

\mkey{Result Underflow}{floating point error flag}
\begin{indpar}
Set if the result is too small to be stored, even as a denormalized
number, in a target type value.

The result is stored as \TT{+0} if it is positive and as
\TT{-0} if it is negative.
\end{indpar}

\mkey{Result Inexact}{floating point error flag}
\begin{indpar}
Set if result cannot be exactly stored in a target type value.
This happens frequently and is not normally considered a
real error.

The result is rounded to the nearest value, with ties to even.
\end{indpar}
\end{indpar}

Except for compares, \TT{NaN} operands cause \TT{NaN} results and
do \underline{not} set the invalid operand flag.

Results may be denormalized numbers.  Except for compares,
when an operand to an arithmetic operation is a denormalized
number, it is treated as a signed zero.

The builtin arithmetic floating point
operators are \TT{+}, \TT{-}, \TT{/}, and \TT{mod}.
The operand types of these operators are the target type of their result.
The operator
\TT{\textasciicircum} is \underline{not} builtin and must be
defined by library code.

\subsubsection{Qualifier/Type Subexpressions}
\label{QUALIFIER/TYPE-SUBEXPRESSIONS}

An expression of the form
\begin{center}
\tt $Q1s$ $T1$ ( $e$ )
\end{center}
where $Q1s$ are zero or more {\em qualifier-names}
and $T1$ is a {\em type-name},
when compiled in a statement of the form 
\begin{center}
\tt $Q2s$ $T2$ v = $Q1s$ $T1$ ( $e$ )
\end{center}
is compiled as
\begin{center}
\begin{tabular}{l}
\tt $Q1s$ $T1$ tmp = $e$ \\
\tt $Q2s$ $T2$ v = tmp
\end{tabular}
\end{center}
where {\tt tmp} is a temporary variable.

Similarly an expression of the form
\begin{center}
\tt $Q1s$ ( $e$ )
\end{center}
where $Q1s$ are one or more {\em qualifier-names},
when compiled in a statement of the form 
\begin{center}
\tt $Q2s$ $T2$ v = $Q1s$ ( $e$ )
\end{center}
is compiled as
\begin{center}
\begin{tabular}{l}
\tt $Q1s$ $T2$ tmp = $e$ \\
\tt $Q2s$ $T2$ v = tmp
\end{tabular}
\end{center}

\subsubsection{Module Abbreviation Subexpressions}
\label{MODULE-ABBREVIATION-SUBEXPRESSIONS}

An expression of the form
\begin{center}
\tt $ma$ ( $e$ )
\label{MODULE-ABBREVIATION-SEMANTICS}
\end{center}
where $ma$ is a {\em module-abbreviation} is modified
by the parser (not the compiler).  The parser prefixes
$ma$ to the unparenthesized operators in the the subexpression $e$.

For example,
\begin{center}
\begin{tabular}{c}
\tt $ma$ ( x + ( y1 + y2 ) + ( z1 * z2 ) ) \\
becomes \\
\tt $ma$ ( $ma$ x "+" ( y1 "+" y2 ) ) "+" ( z1 "*" z2 )
\end{tabular}
\end{center}
and
\begin{center}
\begin{tabular}{c}
\tt $ma$ ( x + ( y1 + y2 ) + z1 * z2 ) \\
becomes \\
\tt $ma$ ( $ma$ x "+" ( y1 "+" y2 ) ) "+" ( $ma$ z1 "*" z2 )
\end{tabular}
\end{center}

\subsubsection{User Defined Standard Operators}
\label{USER-DEFINED-STANDARD-OPERATORS}

The standard operators for comparison and arithmetic can be overloaded
for a non-builtin type $T$ with an optional module abbreviation
$ma$ by defining functions with the following prototypes:
\begin{indpar}
{\tt function bool r = $ma$\QMARK{} ( $T$ $v1$ ) "$op$" ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of \TT{<}, \TT{<=}, \TT{==}, \TT{!=}, \TT{=>}, or \TT{>}

In addition, to allow sequences of compare operators with operands
of type $T$, for each compare operator $op$ you must include the line
\begin{center}
\tt define compare operator ( $T$, "$op$" )
\end{center}
as described on \pagref{DEFINE-COMPARE-OPERATOR}.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} ( $T$ $v1$ ) "$op$" ( unswrd $v2$ )}
\begin{indpar}
where $op$ is one of \TT{<{}<} or \TT{>{}>}
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} "$op$" ( $T$ $v1$ )}
\begin{indpar}
where $op$ is one of \TT{-}, \TT{+}, or \TT{!}
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} ( $T$ $v1$ ) "$op$" ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of
    \TT{+}, \TT{-},
    \TT{*}, \TT{/}, \TT{div}, \TT{mod}, \TT{rem}, \TT{\textasciicircum},
    \TT{\&}, \TT{|}, \TT{xor}
\end{indpar}

\end{indpar}


The operators {\tt "if"}, {\tt "else"}, {\tt "and"},
{\tt "or"} and {\tt "not"} should not be overloaded.

\section{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

Variables are allocated to the current function frame
and are also given their values by assignment statements.
After the assignment statement allocating a variable,
the value of the variable cannot be changed.  However,
a new variable of the same name can be allocated via
the `\TT{next}' construction which we describe below.

Assignment statements have the syntax:
\begin{indpar}
\emkey{assignment-statement}
    ::= \{ {\em result-variable-list} \TT{=} \}\QMARK{}
    		{\em assignment-right-side}
\\[0.5ex]
\emkey{result-variable-list}\label{RESULT-VARIABLE-LIST}
    ::= {\em result-variable}
	  \{ \TT{,} {\em result-variable} \}\STAR{}
\\[0.5ex]
\emkey{result-variable}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em result-variable-declaration} \\
    $|$ & {\em next-variable-declaration} \\
    $|$ & {\em deferred-variable}
    		& [see \pagref{DEFERRED-VARIABLE}] \\
    $|$ & {\em iteration-result-variable}
    		& [see \pagref{ITERATION-RESULT-VARIABLE}] \\
    \end{tabular}
\\[0.5ex]
\emkey{result-variable-declaration}\label{RESULT-VARIABLE-DECLARATION}
    ::= {\em qualifier-name}\STAR{}~{\em type-name}~{\em result-variable-name}
\\[0.5ex]
\emkey{next-variable-declaration}\label{NEXT-VARIABLE-DECLARATION}
    ::= \ttkey{next}~{\em result-variable-name}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
\emkey{result-variable-name}\label{RESULT-VARIABLE-NAME}
    ::= \begin{tabular}[t]{l}
        {\em variable-name} without {\em member-selectors} \\
	(in the \LSTAR-Language (\pagref{LSTAR-LANGUAGE})
	 {\em member-selectors} are allowed)
	\end{tabular}
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{assignment-right-side}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em expression-list}
    		& [see \pagref{EXPRESSION-LIST}] \\
    $|$ & {\em function-call}
    		& [see \pagref{FUNCTION-CALL}] \\
    $|$ & {\em generic-call}
    		& [see \pagref{GENERIC-CALL}] \\
    $|$ & {\em block}
	        & [see kinds of assignment statement below] \\
    \end{tabular}
\end{indpar}

where the {\em assignment-right-side}
depends on the kind of assignment statement.
The kinds of assignment statements are:
\begin{indpar}
\emkey{assignment-statement}
    \begin{tabular}[t]{rll}
    ::= & {\em simple-assignment-statement}
	& \itemref{SIMPLE-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em block-assignment-statement}
	& \itemref{BLOCK-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em conditional-assignment-statement}
	& \itemref{CONDITIONAL-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em loop-assignment-statement}
	& \itemref{LOOP-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em call-assignment-statement}
	& \itemref{CALL-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em out-of-line-assignment-statement}
	& \itemref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em compile-and-run-assignment-statement}
	& \itemref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em compile-time-assignment-statement}
	& \itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em assembly-assignment-statement}
	& \itemref{ASSEMBLY-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em function-call}
	& \itemref{FUNCTION-PROTOTYPES-AND-CALLS} \\
    $|$ & {\em generic-call}
	& \itemref{GENERICS} \\
    \end{tabular}
\end{indpar}

If an {\em assignment-statement} has {\em result-variable-declarations}
that give {\em variable-names} with types and qualifiers,
these result variables are allocated to the current function frame, and
values produced by evaluating the {\em assign\-ment-right-side} are stored in
these variables.

The {\em assignment-right-side} may produce a list of values which can be
used to set multiple {\em result-variables}.  The {\em assignment-right-side}
is completely evaluated before any {\em result-variables} are set.

When a variable value is set, the value is implicitly first
computed in a register, then stored in the current function
frame, and for some time
afterwards the value is left in the register which becomes a cache
on the frame value.  This caching is hidden from the programmer.

If a variable value is copied from another variable, usually the
new variable simply becomes a compile-time alias for the old variable.
No executable copy code is created, no new register is allocated, and no new
value is pushed into the stack.

Similarly if a variable value can be easily computed from previous variable
values by in-line code, 
its value may not be stored into the function frame.  Instead its
value can be recovered at any time by repeating the computation
of the variable from the other values.

The value assigned to each result variable must be implicitly convertible to
the variable's type.  In some cases the type of a result variable is
the target type of an {\em expression} in a {\em assignment-right-side}
that is an {\em expression-list}
(\itemref{SIMPLE-ASSIGNMENT-STATEMENTS}).
In some cases the result variable type is matched to
the type of a {\em function-prototype} result variable
for a {\em function-call} that is the {\em assignment-right-side}
(\itemref{MATCHING-CALLS-TO-PROTOTYPES}).

A {\em result-variable-declaration} acts
as a declaration of its variable,
and the scope of the declarations includes any {\em subblock} that may
constitute the {\em assignment-right-side}.
Result variables are not allowed to hide (\pagref{HIDE})
other {\em name} declarations with exceptions listed on
\pagref{HIDING-EXCEPTIONS}.

A {\em next-variable-declaration} is similar to a
{\em result-variable-declaration}, but uses the word
`\ttkey{next}'\label{NEXT} in
place of the {\em qualifier-names} and {\em type-name}
of a result variable being assigned a value.  The named result variable must
have been previously assigned a value within the same smallest containing block.
A new variable with the same qualifiers, type, and name
as that previous variable is allocated,
and the new variable supersedes that previous variable
in subsequent code within the block.  Thus if {\tt v} is the name
of a variable declared in a block, then after `{\tt next v}' is
assigned, {\tt v} refers to the value assigned to `{\tt next v}'.

See the example in \itemref{SIMPLE-ASSIGNMENT-STATEMENTS}, and
the more detailed discussion in 
\itemref{BLOCK-ASSIGNMENT-STATEMENTS}.

Note that `\TT{next}' behaves differently when it used as part of
the name of
a {\em deferred-variable} (\pagref{DEFERRED-VARIABLE})
or an {\em iteration-result-variable} (\pagref{ITERATION-RESULT-VARIABLE}).

The {\em result-variables} may be completely omitted if the
{\em assignment-right-side} is a {\em subblock}, is a
{\em function-call} matching a {\em function-prototype} that has
no result variables (\itemref{MATCHING-CALLS-TO-PROTOTYPES}),
or is a {\em generic-call} (\itemref{GENERICS}).
Because such statements still have
the form and semantics of statements that could have result variables,
we call them `{\em assignment-statements}' even though they allocate
and assign no result variables.

Also there are statements with the form:
\begin{center}
{\em function-call} ~ \TT{=} ~ {\em expression-list}
\end{center}
which are syntactic sugar for a {\em function-call}
in which the {\em expression-list} has been made into a function argument
list and there are no result variables.
{\em Function-calls} \underline{cannot} be used as result variables.
See \itemref{MATCHING-CALLS-TO-PROTOTYPES}.

The \LSTAR-language (\pagref{LSTAR-LANGUAGE}) extends the L-Language
by allowing {\em result-variable-names} to contain {\em member-selectors}.

\subsection{Simple Assignment Statements}
\label{SIMPLE-ASSIGNMENT-STATEMENTS}

The simplest \skey{assignment statement}s have the syntax:

\begin{indpar}
\emkey{simple-assignment-statement}
    ::= {\em result-variable-list} \TT{=} {\em expression-list}
\\[0.5ex]
\emkey{expression-list}\label{EXPRESSION-LIST}
    ::= {\em expression} \{ \TT{,} {\em expression} \}\STAR{}
\end{indpar}

If there is more than one {\em expression} in the {\em expression-list},
or if there is a single {\em expression} that is \underline{not}
a {\em function-call},
then each {\em expression} produces a single value, and the list of these
values is the list of values assigned to the list of result variables.
The {\em expressions} are evaluated in left to
right order, and all the {\em expressions} are evaluated before any of
the result variables are given values.
In this case there must be the same number of {\em expressions}
in the {\em expression-list} as there are result variables.

If the {\em expression-list} is a single {\em expression} that
is a {\em function-call} which
returns a list of values, this list of values is used.
In this case the {\em function-call} may produce more values than
there are result variables, and the excess values are discarded,
as long as there is at least one result variable.
if there are no result variables, the
{\em function-call} must match a {\em function-prototype} that has
no result variables (\itemref{MATCHING-CALLS-TO-PROTOTYPES}).

If an {\em expression-list} contains more than one {\em expression},
and one of the {\em expressions} is a {\em function-call}, only the
first value returned by the function is used, and any other values
returned by the function are discarded.

An {\em expression} may only input values that are constants,
the values of variables in the same function execution
frame (including arguments passed to the function execution), 
or the values of global variables.  In particular,
no input can come \underline{directly}
from RAM memory outside the current function execution frame or
global memory,
but see \pagref{READ} and Section~\itemref{THE-READ-AND-WRITE-QUALIFIERS}
for ways to load RAM values into function frame variables.
See Section~\itemref{STACKS} for more information about
function frames.

The value assigned to each result variable must be implicitly convertible to
the variable's type.
In the case that an {\em expression} is producing
only a single value, the type of its associated result variable is the target
type of the {\em expression}.  If there is only one {\em expression}
and that is a {\em function-call}, the types the result variables
are matched to the types of the {\em function-prototype} result
variables (\itemref{MATCHING-CALLS-TO-PROTOTYPES}).

Some examples of {\em simple-assignment-statements} are:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = x + 1         // y == 2
next x = 10 * x         // Now x == 10
next y = x + y          // Now y == 12
int32 z = 256 + y       // z == 268
int8 u = z              // ILLEGAL!  Undefined implied
                        // conversion from int32 to int8.
int8 v = truncate ( z ) // Now v == 12
int8 w = v + 257        // ILLEGAL!  Constant out of range
                        // of target type int8.
float32 m = 1.7
int64 i = m             // ILLEGAL!  Undefined implied
                        // conversion from float32 to int64.
int32 j = nearest ( m ) // now j == 2 (round to nearest)
int32 y = x + y         // ILLEGAL! y hides y.
\end{verbatim}\end{indpar}

\subsection{Block Assignment Statements}
\label{BLOCK-ASSIGNMENT-STATEMENTS}

Another variant of the assignment statement is\index{block assignment}:

\begin{indpar}
\emkey{block-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \\
	\TT{~~~~}\{ \ttkey{do} {\em block-name}\QMARK{}
	              \{ \TT{(} {\em context-expression} \TT{)} \}\QMARK{}
	              \}\QMARK{} \TT{:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{}
	\end{tabular}
\\
\emkey{block-name} ::=
    \begin{tabular}[t]{l}
    {\em name} ~~~~~ [see \pagref{NAME}] \\
    \underline{not} containing
	`\TT{.}',~ {\em quoted-marks},~ or {\em quoted-separators} \\
    \end{tabular}
\end{indpar}

where `\TT{do} {\em block-name}\QMARK{}
	              \{ \TT{(} {\em context-expression} \TT{)} \}\QMARK{}'
may be omitted as long as \TT{=} is not omitted.

The {\em statements} within the {\em block-assignment-statement}
comprise a `\key{block}' of code.

Unless `\TT{(} {\em context-expression} \TT{)}' is given,
a {\em block-assignment-statement} is
compiled in the current context (\pagref{CONTEXT}),
and {\em names} declared within the block are \underline{not} permitted
to hide (\pagref{HIDE}) {\em names} declared before the block.
But if `\TT{(} {\em context-expression} \TT{)}' is given,
the {\em block-assignment-statement} is
compiled in the context given by {\em context-expression},
and names declared within the block
are permitted to hide names in the specified context.

Any result variables in a {\em block-assignment-statement}
are called `\skey{deferred variable}s' because they do not
immediately get a value.  They are assigned values by
{\em assignment-statements} within the block
whose {\em result-variable-lists}
include {\em deferred-variables}:
\begin{indpar}
\emkey{deferred-variable}\label{DEFERRED-VARIABLE}
    \begin{tabular}[t]{rl}
    ::= & {\em result-variable-name} \\
    $|$ & \TT{next} ~ {\em result-variable-name} \\
    $|$ & {\em prototype-result-variable-name} \\
    \end{tabular}
\\[1ex]
\emkey{prototype-result-variable-name} ::= {\em variable-name}
\end{indpar}
{\em Deferred-variables} of the first two forms are names of
{\em result-variables} of containing {\em assignment-blocks},
while {\em prototype-result-variable-names} are names of
result variables of the prototype of a containing
{\em function-declaration} or {\em generic-declaration}
(\pagref{FUNCTION-PROTOTYPE}).  These latter can contain
{\em member-selectors}.

{\em Assignment-statements} that set {\em deferred-variables}
are called `\skey{deferred assignment}s'.\label{DEFERRED-ASSIGNMENT}

No {\em qualifier-name} or {\em type-name} may be a prefix of
a {\em variable-name} used as a
{\em deferred-variable}.
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.

Variables declared in the block may not hide (\pagref{HIDE})
variables declared outside the block, including the result
variables of the block, with exceptions listed on
\pagref{HIDING-EXCEPTIONS}.

The code must be such that every deferred variable is given a value
by at most one deferred assignment, and if not a `\TT{next}' variable,
is given a value by a deferred assignment before the variable is read.
If a deferred variable is of the form `{\tt next v}', then {\tt v}
may be used in the block to refer to the variable value assigned
outside and before the {\em block-assignment-statement}, up to
the point where `{\tt next v}' is assigned a value in the block.
After that point {\tt v} refers to the value assigned to `{\tt next v}'.

An example of a {\em block-assignment-statement} is:
\begin{indpar}\begin{verbatim}
int32 x = 1
float64 y = 1.67
int64 z, uns8 w, next x =:

    z = 16,777,216   // Legal, z is deferred variable
    x = 265          // ILLEGAL, x is NOT deferred variable
    float64 y = 2.6  // ILLEGAL, y is visible outside block
    uns8 v = 55      // Legal, v is NOT visible outside block
    next x = 265 + x // Legal, next x is deferred variable,
                     //        now x == 266
    next y = 2.6     // ILLEGAL, y is visible outside block
                     //          and next y is not deferred
                     //          variable
    w = truncate ( x )  // Legal, w is deferred variable,
                     // sets w to 10 as x is now 266
\end{verbatim}\end{indpar}

An exit statement may be used to jump from within a block to
the end of the block:

\begin{indpar}
\emkey{exit-statement} ::=
        \ttkey{exit} ~ {\em block-name}\QMARK{} ~
	    \{ \TT{if} ~ {\em condition-expression} \}\QMARK{}
\end{indpar}

If the {\em block-name} is not given, the smallest block containing
the {\em exit-statement} is exited.

The block exit may be conditional.  The compiler checks that
if non-conditional exits are taken and conditional
exits are either taken or not, each one of the block's
deferred variables is given a value by a single deferred assignment statement.
However, if a {\em block-name} is given and the exit statement is in
a subblock of the named block,
the deferred variables of this subblock
need not be given values.

Examples of {\em exit-statements} are:

\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
bool v = do BLOCK1:
    // sets v = ( x <= 10 or y => 10 )
    //
    do BLOCK2:
        exit BLOCK2 if not x <= 10
        v = true
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3 if not y => 10
        v = true
        exit BLOCK1
    v = false

next v = do BLOCK1:
    // attempts to set next v = ( x <= 20 or y => 20 )
    next v = true
    exit BLOCK1 if x <= 20
    exit BLOCK1 if y => 20
    next v = false          // ILLEGAL: next v set twice
\end{verbatim}\end{indpar}

L-Language parses all code, but does not compile statements that
cannot be reached from the beginning of the current top level
statement (e.g., out-of-line function declaration).  Because
of unconditional \TT{exit} statements, or \TT{exit} statements
whose conditions evaluate to \TT{true} at compile time,
some statements will be unreachable and will not be compiled.
Unreachable statements are not checked for non-parsing compile
errors.

For example, the code
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
int32 z = do BLOCK1:
    do BLOCK2:
        exit BLOCK2 if not x <= 10
        z = 55
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3 if not y => 10
        z = "hot dog"    // Illegal conversion
        exit BLOCK1
    z = "cold dog"       // Illegal conversion
\end{verbatim}\end{indpar}

becomes after eliminating unreachable statements:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
int32 z = do BLOCK1:
    do BLOCK2:
        exit BLOCK2 if false
        z = 55
        exit BLOCK1
\end{verbatim}\end{indpar}

and therefore has no compiler errors.


\subsection{Conditional Assignment Statements}
\label{CONDITIONAL-ASSIGNMENT-STATEMENTS}

\ikey{Conditional assignment statements}{conditional assignment}
are syntactic sugar for block assignment statements
with exits (\pagref{BLOCK-ASSIGNMENT-STATEMENTS}).
Conditional assignment statements have the syntax:

\begin{indpar}
\emkey{conditional-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \ttkey{if}\TT{:} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	\TT{~~~~}\ttkey{else}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

In this case the {\em condition-expressions} are evaluated in order
until either one evaluates to true or the `\TT{else}' condition is
reached, and then the {\em statements} subject to the
first true condition (a.k.a the \key{subblock} of that condition)
are executed, or if no condition is true, the {\em statements}
of the `\TT{else}' subblock are executed.

Every variable in the {\em result-variable-list} \underline{must} be set by the
single subblock that executes, unless that subblock exits a block
that contains the {\em conditional-assignment-statement}.  A variable in the
{\em result-variable-list} cannot be read by a subblock {\em statement}
unless it is set by a previous {\em statement} in the
same subblock.

An example is:
\begin{indpar}\begin{verbatim}
function float64 result =
        max ( float64 x, float64 y, float64 z ):
    result = if:
        y <= x => z:
            result = x
        z <= y => x:
            result = y
        y <= z => x:
            result = z
        else:
            result = NaN
\end{verbatim}\end{indpar}

where \TT{NaN} means `\key{not-a-number}' and is the missing
value for \TT{float64} variables.  {\tt x~=>~y} is true if
and only if neither {\tt x} nor {\tt y} is a \TT{NaN} and
{\tt x} is equal to or greater than {\tt y}.  Thus if any of
{\tt x}, {\tt y}, or {\tt z} in the above conditional assignment
is a \TT{NaN}, none of the {\em conditional-expressions}
will be \TT{true}, and the \TT{else} subblock will be evaluated to set
the {\tt result} to a \TT{NaN}.

The following special rule applies to
{\em conditional-assignment-statements}:\label{CONDITIONAL-SPECIAL-RULE}

\begin{itemize}
\item
If some of the {\em conditional-expressions} can be computed at compile
time, subblocks that the compiler determines cannot execute are not
compiled or checked for compiler errors (but the subblocks are parsed
and checked for parsing errors).

Specifically, if a {\em conditional-expression} evaluates to \TT{true}
at compile time, subblocks beyond the subblock
of this {\em conditional-expression}
are not compiled.  And if a remaining {\em conditional-expression}
evaluates to \TT{false} at compile time, the subblock of this
{\em conditional-expression} is not compiled.
\end{itemize}

For example, if a {\em conditional-assignment-statement}
contained
\begin{indpar}\begin{verbatim}
    x => 1,000,000:
        result = NaN
\end{verbatim}\end{indpar}
where {\tt x} is a variable with value known at compile time
that is less than {\tt 1,000,000}, then
`{\tt result = NaN}' will not compile
and will not be checked for compile time errors.

The \TT{else} subblock cannot be omitted unless one of the
other subblocks has a conditional that evaluates to \TT{true}
at compile time.  For
example, the following has a compile time error unless
one of the conditionals evaluates to \TT{true} at compile time:
\begin{indpar}\begin{verbatim}
    result = if:
        x <= y:
            result = x
        y <= x:
            result = y
        // ILLEGAL because result is not set if there
        // is no else subblock.
\end{verbatim}\end{indpar}
Possible \TT{else} subblocks for this example are:
\begin{indpar}\begin{verbatim}
        else:
            result = default value
\end{verbatim}\end{indpar}
or
\begin{indpar}\begin{verbatim}
        else:
            result = *UNCHECKED* ( *NO* *VALUE* )
\end{verbatim}\end{indpar}
or
\begin{indpar}\begin{verbatim}
        else:
            program stop
\end{verbatim}\end{indpar}

\subsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

\ikey{Loop assignment statements}{loop assignment}
are similar to block assignment
and conditional assignment statements.  An example is:
\begin{indpar}\begin{verbatim}
// Calculate the sum of i for i == 1 to i == n.
//
int64 n = . . .
int64 sum = loop:
    initially:
        int64 i = 1
        int64 partial sum = 0
    while i <= n:
        next partial sum = partial sum + i
        next i = i + 1
    finally:
        sum = partial sum
\end{verbatim}\end{indpar}



The general syntax of loop assignment statements is:

\begin{indpar}
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	          \ttkey{loop:} \\
	\TT{~~~~}\ttkey{initially}\TT{:} \\
	\TT{~~~~~~~~~}{\em iteration-variable-assignment-statement}\STAR{} \\
	\TT{~~~~}\{ \ttkey{while} $|$ \ttkey{until} \}
	         {\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ttkey{finally}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{iteration-variable-assignment-statement} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    {\em assignment-statement} in which all {\em result-variables} \\
    are {\em result-variable-declarations}
    \end{tabular}
\end{indpar}

This is somewhat like the conditional assignment statement
except the `\TT{while}' or `\TT{until}'
subblock is iterated and there are iteration
variables defined by the `\TT{initially}' subblock.

The `\TT{initially}' subblock is call the `\key{initialization subblock}',
the `\TT{while/until}' subblock is call the `\key{iteration subblock}',
and the `\TT{finally}' subblock is call the `\key{finalization subblock}'.

The \skey{iteration variable}s are the
{\em result-variables} declared by the
{\em iteration-variable-assignment-statements} executed by the initialization subblock.
Each iteration of the loop gives these variables new values using
`{\tt next v}' to refer to the value of {\tt v} in the next iteration,
where {\tt v} is an iteration variable.  In the example `{\tt i}' and
`{\tt partial sum}' are iteration variables.

An iteration subblock qualified by `\ttkey{while}'
{\em condition-expression}' only executes if the
{\em condition-expression} evaluates to \TT{true},
whereas an iteration subblock qualified by `\ttkey{until}'
{\em condition-ex\-pres\-sion}' only executes if the
{\em condition-expression} evaluates to \TT{false}.

Lastly, when the {\em condition-expression} evaluates so the iteration
subblock is not executed, the finalization subblock
executes, and it must set all the variables in the
loop statement's {\em result-variable-list}.  At this point the loop stops
executing.

Loops are always in effect unraveled so multiple copies of
the iteration subblock exist at one time.

Within the initialization and iteration subblocks assignment
statements may set iteration variables in adjacent subblocks
using the following syntax for assignment statement result variables:
\begin{indpar}
\emkey{iteration-result-variable}\label{ITERATION-RESULT-VARIABLE}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{next}{iteration result variable} ~
                      {\em result-variable-name} \\
    $|$ & \ttmkey{next next}{iteration result variable}
                      {\em result-variable-name} \\
    \end{tabular}
\end{indpar}
{\em Assignment-statements} that set {\em iteration-result-variables}
are called `\skey{iteration assignment}s'.

Let {\tt v} be an iteration variable.  After it is set in the initialization
subblock, `{\tt v}' refers to the value of the variable in both
the initialization subblock and the first iteration.
`{\tt next v}' refers to the value of the variable in the second
iteration.  In order to prevent confusion, `{\tt v}' cannot
be used in the initialization subblock after `{\tt next v}' has
been assigned, `{\tt next v}' cannot be used in the subblock
except as a result variable when it is assigned, and
`{\tt next next v}' cannot be used in the initialization subblock.

Within the iteration
subblock, `{\tt v}' refers to the value of the variable in the
current iteration, `{\tt next v}' refers to the value of the variable
in the next iteration, and `{\tt next next v}' refers to the
value of the variable in the next iteration after the next iteration.
In order to prevent confusion, `{\tt v}' cannot
be used in the iteration subblock after `{\tt next v}' or
`{\tt next next v}' has been assigned,
and `{\tt next v}' and `{\tt next next v}'
cannot be used in the subblock
except as a result variables when they are assigned.

Within the finalization
subblock, `{\tt v}' refers to the value the variable would have
for an additional iteration if such an iteration existed.
Within the finalization subblock `{\tt next v}' and
`{\tt next next v}' cannot be used.

For a given iteration variable {\tt v},
either the initialization subblock sets {\tt v}
and the iteration subblock sets `{\tt next v}',
or the initialization subblock sets both {\tt v} and `{\tt next v}'
and the iteration subblock sets `{\tt next next v}'.

There are always at least 4 iterations of the loop with variables
simultaneously in the current function frame: the current iteration,
the previous iteration (if any), and the next two iterations.
When the third iteration of the loop starts, the first
iteration can be discarded, and so forth.

Code in an initialization or iteration subblock cannot set
deferred result variables outside the subblock (including loop block
result variables), or contain \TT{exit} statements that have
no block label (however such statements may be in subblocks 
of the initialization or iteration subblock).

\subsection{Call Assignment Statements}
\label{CALL-ASSIGNMENT-STATEMENTS}

Note that most functions are inline, and not out-of-line.
Inline functions are described later
in Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS}.

\ikey{Call assignment statements}{call assignment}
are used to call out-of-line functions:

\begin{indpar}
\emkey{call-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em call-assignment-option}\STAR
		~\ttkey{call}~ {\em function-expression} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{}
	\end{tabular}
\\[1ex]
\emkey{call-assignment-option}
	\begin{tabular}[t]{rl}
	::= & \ttakey{UNCHECKED} $|$ \ttakey{REVERSE}
	                          $|$ \ttakey{NO-RELOAD} \\
	$|$ & \ttakey{COMPILE-AND-RUN-TIME} $|$ \ttakey{COMPILE-TIME}
	\end{tabular}
\\[1ex]
\emkey{argument-assignment-statement} ::=
    \begin{tabular}[t]{l}
    {\em assignment-statement} in which all {\em result-variables} \\
    are {\em result-variable-declarations}
    \end{tabular}
\end{indpar}

The {\em function-expression} evaluates to a function to be called,
and must have a natural type (\pagref{NATURAL-TYPE})
$T$ that has \TT{adr} as its underlying type.

The values of the variables created by the {\em argument-assignment-statements}
are the arguments to the function.
The results of the function call are stored in the
{\em result-variable-list} variables.

A call assignment must have the \TT{*UNCHECKED*} option
unless $T$ is declared by an out-of-line
function type declaration described below.  If there is no
such declaration, the arguments are presented to the out-of-line
function in the order they are listed in the {\em call-assignment-statement},
unless the \TT{*REVERSE*} option is given, in which case this order
is reversed.

If there is an out-of-line function type declaration, arguments in the
call are matched by name to arguments in the type declaration,
and then ordered as per the type declaration.  In this case
the \TT{*REVERSE*} option is not permitted.

Normally a `\TT{reload *READ*, *READ* dependent}'
statement (see \itemref{THE-RELOAD-COMMAND})
is executed automatically
upon returning from the called function, but the
\ttakey{NO-RELOAD} option suppresses this.
If the \TT{*NO-RELOAD*} is given, the \TT{*UNCHECKED*} option must
also be given.

If the \TT{*COMPILE-AND-RUN-TIME*} option is given, the call
will be made at compile time only if the argument values are available
at compile time, and will otherwise be made at run time.  When the call
is made determines whether any result variable values are determined
at compile time.  If the \TT{*COMPILE-TIME*} option is given,
the call is made at compile time, and the argument values must be
available at compile time.

An out-of-line function type declaration has the form:

\begin{indpar}
\emkey{function-type-declaration}\label{FUNCTION-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function type}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{}
		    {\em defined-type-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{}
	\end{tabular}
\\[0.5ex]
\emkey{argument-variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{function-declaration-option}
	\begin{tabular}[t]{rl}
	::= & \ttakey{COMPILE-AND-RUN-TIME} \\
	$|$ & \ttakey{COMPILE-TIME}
	\end{tabular}
\end{indpar}

This makes \TT{adr} the base type of the new
defined type, and declares the prototype
for the out-of-line function.
Then a call assignment block is type-checked by matching
the variable names in the call assignment block
to those in the prototype.  Thus in this case the order of variables
in the call block does not matter as they will be matched by
variable name to the prototype and then their values will be
reordered according to the prototype.  Also, in this case
a call block argument
may be of different
type than corresponding prototype argument if there is an implied
conversion from the call block
argument type to the prototype argument type,
in which case the implied conversion will be invoked.
Similarly a prototype result variable may be converted to
a call block result variable by an implied conversion.

The result and argument variables in a 
{\em function-type-declaration} are permitted to hide (\pagref{HIDE})
names in the context of the declaration, but the {\em defined-type-name}
may not.

A function type may be declared multiple times.  All these declarations
must be identical except for ordering of options and qualifiers.

Out-of-line functions may be declared by
an assignment statement of the form:
\begin{indpar}
\emkey{out-of-line-function-deferred-assignment}%
\label{OUT-OF-LINE-FUNCTION-DEFERRED-ASSIGNMENT} ::= \\
\hspace*{0.5in}{\em function-type-name}~{\em function-name} \TT{=}
    \ttmkey{deferred}{function}
\end{indpar}

The {\em function-name} is referred to as a `\key{deferred function}'.
This specifies that the body of the out-of-line function
with the given {\em function-name} will be provided later
during program initialization.  It is an error to call an uninitialized
deferred function.

An out-of-line function may be declared by
an assignment statement of the form:
\begin{indpar}
\emkey{out-of-line-function-assignment}%
\label{OUT-OF-LINE-FUNCTION-ASSIGNMENT} ::= \\
\hspace*{0.5in}{\em function-type-name}~~{\em function-name} \TT{=:} \\
\hspace*{1.0in}{\em statement}\STAR{}
\end{indpar}

The argument and result variable names used by the {\em statements}
are those given in the {\em function-type} declaration.
These names
and names declared within the {\em statements} of the assignment,
are permitted to hide (\pagref{HIDE})
names in the context of the assignment, but the {\em function-name}
may not.  The {\em statements} of the assignment may reference
variables in the context of the assignment, which will have
the values they have been given when the assignment executes, except
for deferred variables (\pagref{DEFERRED-ASSIGNMENT-STATEMENTS}),
which must be given values before the function is called.


If the {\em function-name} is deferred, the {\em function-type}
name given in the {\em out-of-line-function-deferred-assignment}
and that given in the {\em out-of-line-function-assignment}
must be identical.  It is an error if the statement initializing
a deferred function is not in the same extended module as the function's
{\em out-of-line-deferred-assignment}.

Out-of-line functions may also be declared by:

\begin{indpar}
\emkey{out-of-line-function-declaration}%
\label{OUT-OF-LINE-FUNCTION-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{}
		             ~ {\em function-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
		\TT{~~~~do:} \\
		\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}\label{OUT-OF-LINE-FUNCTIONS}

This is equivalent to defining a function type with a hidden name
and then defining {\em function-name} to be a function of that type.
The result and argument variables in a
{\em out-of-line-function-declaration},
and names declared within the {\em statements} of the declaration,
are permitted to hide (\pagref{HIDE})
names in the context of the declaration, but the {\em function-name}
may not.

For the function to be callable at compile time, the
\TT{*COMPILE-AND-RUN-TIME*} or \TT{*COM\-PILE-\EOL TIME*} options must be given.
See Section~\itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS}.
A \TT{*COMPILE-\EOL TIME*} out-of-line function will also be callable at
run time, but a \TT{*COMPILE-\EOL TIME*}
out-of-line function will only be callable
at compile time.

Normally the standard call linkage for the computer environment of
the program is used.  Other implementation specific call options
may alter the call linkage used.

\subsection{Out-of-Line Assignment Statements}
\label{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}

An \key{out-of-line assignment statement} is like a combination of
a {\em call-assignment-statement} with
an {\em out-of-line-function-declaration} for a function
specific to the call:

\begin{indpar}
\emkey{out-of-line-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em function-declaration-option}\STAR
		~\ttkey{out-of-line} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

An {\em out-of-line-function-declaration} is constructed from this statement
by replacing the `\TT{out-\EOL of-\EOL line}' keyword by
an internally generated
{\em function-name}, and converting each {\em argument-assignment-statement}
to an {\em argument-variable-declaration}.

Then this statement is executed as a {\em call-assign\-ment-statement}
using the {\em function-name} and deleting the `\TT{do}' subblock.

{\em Out-of-line-assignment-statements} are generally included in
inline functions which preprocess arguments and may use various
{\em out-of-line-assignment-statements} to handle complex subcases.
When compiled multiple times in different contexts, the same
{\em out-of-line-assignment-statement} may be optimized in different
ways, and produce different out-of-line functions.  When it produces
the same out-of-line function more than once, this out-of-line function will
\underline{not} be duplicated.


\subsection{Compile-and-Run Assignment Statements}
\label{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}

A \key{compile-and-run assignment statement} computes a set of
variables that have values constant in a block, then compiles
the block using these constant values to optimize the compilation,
and lastly runs the block:

\begin{indpar}
\emkey{compile-and-run-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \\
	\TT{~~~~}\ttkey{compile-and-run}
		 \{ {(} {\em context-expression} \TT{)} \}\QMARK{}
		 \TT{:} \\
	\TT{~~~~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~~~~do} {\em block-name}\QMARK{} \TT{:} \\
	\TT{~~~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

The variable values are set by the {\em argument-assignment-statements}.
Then the `\TT{do}' subblock {\em statements} are compiled, using
the variable values to optimize the compilation.

Normally the
{\em compile-and-run-assignment-statement} is
compiled in its context (\pagref{CONTEXT}),
but if `\TT{(} {\em context-expression} \TT{)}'
is given, it is compiled in the context given by the
{\em context-expres\-sion}.
If the {\em context-expression}
specifies a context other than the context of the
{\em compile-and-run-assignment-statement}, the result variable names
and names declared within the block {\em statements}
are permitted to hide (\pagref{HIDE})
names in the specified context.

After it is compiled, the `\TT{do}' subblock is executed.
The variables in the {\em result-variable-list}
may be set by either {\em argument-assignment-statements} or
`\TT{do}' subblock {\em statements} as for
a block assignment statement (see \itemref{BLOCK-ASSIGNMENT-STATEMENTS}).
If a variable \TT{v} not in the {\em result-variable-list}
is set by an {\em argument-assignment-statement},
`\TT{next v}' can be set by a `\TT{do}' subblock {\em statement}, but
this will be a new variable whose value may not be available during
the compilation.

When the compile-and-run assignment statement is executed, the compiled
code will be saved in a table indexed by the values of the
variables set by the {\em argument-assignment-statements} and the context
used in compilation.  When the
compile-and-run assignment statement is re-executed, if these
variables have the same values they had during a previous execution,
and if the same context is being used,
the compilation will be bypassed and the previously compiled code used.
This optimization is required, but such previously compiled code
may be discarded if it has not been used in a long time.

The {\em statements} of the {\em compile-and-run-assignment-statement}
may reference to variables in the context of the assignment statement.
These variables act as arguments to the compiled code that may
vary from one execution to another, and are not used to optimize or
index the code.


\subsection{Compile-Time Assignment Statements}
\label{COMPILE-TIME-ASSIGNMENT-STATEMENTS}

\ikey{Compile-time assignment statements}{compile-time assignment statement}
run only once, when they are compiled, and produce variable values
at compile time:

\begin{indpar}
\emkey{compile-time-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~~~ \ttkey{compile-time:} \\
	\TT{~~~~}{\em statement}\STAR{}
	\end{tabular}
\end{indpar}

A compile-time block has its own stack, which is freed when the
block finishes executing.

Compile time blocks may only use compile time variables and values,
but may use visible inline functions, out-of-line functions
that have been declared to be compile-time, and global areas
that have been declared to be compile-time.

\subsection{Deferred Assignment Statements}
\label{DEFERRED-ASSIGNMENT-STATEMENTS}

\ikey{Deferred assignment statements}{deferred assignment statement}
specifies that assignment of its result variables is deferred until later:

\begin{indpar}
\emkey{deferred-assignment-statement} ::=  \\
\hspace*{0.5in}{\em result-variable-list} \TT{=} \ttkey{deferred}
\end{indpar}


The result variables of 
a {\em deferred-assignment-statement} are called `\mkey{deferred}{variable}'.

A {\em deferred-assignment-statement} must be top level.
The statement that assigns its values later must be an assignment
statement with identical {\em result-variable-list}
that is in the same extended module as the {\em deferred-assignment-statement}.
It is a detected program error to read a deferred variable before it has
been assigned a value (this error can only occur in the same extended
module as the {\em deferred-assignment-statement}).

\subsection{Assembly Assignment Statements}
\label{ASSEMBLY-ASSIGNMENT-STATEMENTS}

\ikey{Assembly assignment statements}{assembly assignment statement}
are used to embed assembler instructions in compiled code:

\begin{indpar}
\emkey{assembly-assignment-statement}\label{ASSEMBLY-ASSIGNMENT-STATEMENT}
    ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~\TT{*UNCHECKED*}~\ttakey{ASSEMBLY}\TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em assembler-instruction}\STAR{} \\
	\end{tabular}
\end{indpar}

The variables, those produced by the {\em argument-assignment-statements},
the {\em argument-variable-declarations},
and the result variables, are placed in machine registers
and their names become machine register names for the assembler instructions.
Assembler instructions are only permitted to reference these
machine registers, but load and store assembler instructions may be used.
The assembler instructions are written in the syntax of one of the
target machine assemblers.

The variables may have additional qualifiers which
are names of machine registers or groups of machine registers.  In this case
the variables will be allocated to the specified machine registers or
machine register groups.  Otherwise they will be allocated to target
machine specified register groups based on variable type.

The {\em argument-variable-declarations} list intermediate
variables.  Only the variables named in the {\em argument-assignment-statements}
are given initial values.  Unlike normal code, values of variables
of an {\em assembly-assignment-statement} can be overwritten by the
{\em assembler-instructions}, and there is no check to be sure that
result variables receive any value.

\section{Function Prototypes and Calls}
\label{FUNCTION-PROTOTYPES-AND-CALLS}

Inline functions are declared by {\em function-declarations}
that contain a {\em function-prototype} and the code body of the
function.  Note that inline functions can be called recursively,
but the recursion must be controlled by and terminated by compile-time
values.

The syntax is:

\begin{indpar}
\emkey{function-declaration}\label{FUNCTION-DECLARATION}
    ::= \begin{tabular}[t]{l}
        {\em function-prototype} \TT{:} \\
	\TT{~~~~~}{\em statement}\PLUS{}
	\end{tabular}
\\[2ex]
\emkey{function-prototype}\label{FUNCTION-PROTOTYPE}
    \begin{tabular}[t]{@{}rl}
    ::= & \ttkey{function} ~
          {\em prototype-result-variable-list} ~ \TT{=} \\
        & \TT{~~~~~}{\em module-abbreviation}\QMARK{}
	                ~ {\em prototype-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em prototype-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em prototype-pattern} ~ \TT{=} \\
        & \TT{~~~~~}{\em input-variable-list} \\
    $|$ & {\em function-prototype} \TT{[|} {\em conditioner} \TT{|]}
    \end{tabular}
\\[0.5ex]
\emkey{prototype-result-variable-list} ::= \\
\hspace*{0.5in}
    {\em prototype-result-variable-declaration}
    \{ \TT{,} {\em prototype-result-variable-declaration} \}\STAR{}
\\[0.5ex]
\emkey{prototype-result-variable-declaration} \\
\hspace*{1in}\begin{tabular}[t]{rl}
    ::= & {\em result-qualifier-name}\STAR{} ~
          {\em type-name} ~ {\em variable-name} \\
    $|$ & \ttmkey{next}{prototype result variable} ~
          {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{result-qualifier-name} ::= {\em qualifier-name} $|$ \ttakey{OPTIONAL}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
{\em type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
{\em variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{input-variable-list}
    ::= {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{}
\\[0.5ex]
\emkey{argument-declaration}\label{ARGUMENT-DECLARATION} \\
\hspace*{1in}\begin{tabular}[t]{@{}rl@{}}
    ::= & {\em argument-qualifier-name}\STAR{} {\em type-name}
          {\em variable-name} \\
    $|$ & {\em argument-qualifier-name}\STAR{} {\em type-name}
          {\em variable-name} \TT{?=} {\em default-value} \\
    $|$ & {\em argument-qualifier-name}\STAR{} {\em type-name}
          {\em variable-name} \TT{??} \\
    $|$ & {\em argument-qualifier-name}\STAR{} {\em type-name}
          {\em variable-name} \TT{==} {\em required-value} \\
    $|$ & \ttakey{UNUSED} {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{argument-qualifier-name} ::= {\em qualifier-name} $|$ \ttakey{DEFERRED}
\\[0.5ex]
\emkey{default-value} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[0.5ex]
\emkey{required-value} ::= {\em expression} with compile time value
\\[0.5ex]
\emkey{prototype-pattern}\label{FUNCTION-PATTERN}
    \begin{tabular}[t]{rl}
    ::= & {\em first-pattern-term} ~ {\em pattern-term}\STAR{} \\
    $|$ & {\em pattern-argument-list} {\em pattern-argument-list}\PLUS{}
    \end{tabular}
\\[0.5ex]
\emkey{first-pattern-term} ::= {\em pattern-argument-list}\STAR{} ~
				{\em pattern-term}
\\[0.5ex]
\emkey{pattern-term}
    ::= {\em term-name} ~ {\em pattern-argument-list}\STAR{}
\\[0.5ex]
\emkey{term-name} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\\[0.5ex]
\emkey{function-variable-name}\label{FUNCTION-VARIABLE-NAME} ::=
    \begin{tabular}[t]{@{}p{4in}@{}}
    {\em term-name} $N$ that appears in a {\em function-prototype}
    of the form `{\tt function $N$ = \ldots}'
    \end{tabular}
\\[0.5ex]
\emkey{pattern-argument-list} ::= {\em regular-argument-list}
                              $|$ {\em qualifiers-type-argument-list}
\\[0.5ex]
\emkey{regular-argument-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{qualifiers-type-argument-list} ::= \\
\hspace*{0.2in}\TT{(|} {\em qualifiers-type-argument-declaration}
	 \{ \TT{,} {\em qualifiers-type-argument-declaration} \}\STAR{} \TT{|)}
\\[0.5ex]
\emkey{qualifiers-type-argument-declaration} ::= \\
\hspace*{0.2in}{\em qualifiers-argument-declaration}
               $|$ {\em type-argument-declaration}
\\[0.5ex]
\emkey{qualifiers-argument-declaration} ::= \\
\hspace*{0.2in}\TT{qualifiers} {\em variable-name}
               \{ \TT{?=} {\em default-value} $|$
	          \TT{==} {\em required-value} \}\QMARK{}
\\[0.5ex]
\emkey{type-argument-declaration} ::= \\
\hspace*{0.2in}\TT{type} {\em variable-name}
               \{ \TT{?=} {\em default-value} $|$
	          \TT{==} {\em required-value} \}\QMARK{}
\\[0.5ex]
\emkey{conditioner}\label{CONDITIONER}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em logical-conditioner} \\
    $|$ & {\em qualifiers-conditioner} \\
    $|$ & {\em type-conditioner} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-conditioner}\label{LOGICAL-CONDITIONER}
    ::= {\em logical-expression} ~~~~~ [see \pagref{LOGICAL-EXPRESSION}]
\\[0.5ex]
\emkey{qualifiers-conditioner}\label{QUALIFIERS-CONDITIONER}
    ::= \TT{qualifiers} {\em variable-name} \TT{=} {\em expression}
\\[0.5ex]
\emkey{type-conditioner}\label{TYPE-CONDITIONER}
    ::= \TT{type} {\em variable-name} \TT{=} {\em expression}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[4ex]
\emkey{function-call}\label{FUNCTION-CALL}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em module-abbreviation}\QMARK{} ~ {\em first-call-term}
          ~ {\em call-term}\STAR{} \\
    $|$ & {\em module-abbreviation}\QMARK{}
          {\em call-argument-list} {\em call-argument-list}\PLUS{}
    \end{tabular}
\\[0.5ex]
\emkey{first-call-term} ::= {\em call-argument-list}\STAR{}
				{\em call-term}
\\[0.5ex]
\emkey{call-term}
    ::= {\em term-name} {\em call-argument-list}\STAR{}
\\[1ex]
\emkey{call-argument-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{]} \\
    $|$ & \TT{(|} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{|)} \\
    $|$ & \TT{()} $|$ \TT{[]} $|$ \TT{(|~|)} \\
    $|$ & {\em primary-argument}
    \end{tabular}
\\[0.5ex]
\emkey{actual-argument} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[0.5ex]
\emkey{primary-argument} ::= {\em primary-item}\PLUS{}
                         $|$ {\em bracketed-constant}
\\[0.5ex]
{\em primary-item} ::= {\em word} $|$ {\em number}
                   $|$ {\em quoted-string} ~~~~~ [see \pagref{PRIMARY-ITEM}]
\\[0.5ex]
{\em bracketed-constant} ::= see \pagref{BRACKETED-CONSTANT}

\begin{itemize}
\item
A {\em prototype-pattern} or {\em function-call}
must have either a {\em term-name}
or at least two {\em argu\-ment-lists}.
\item
A {\em prototype-pattern} {\em term-name} must not be
an initial segment of any other {\em term-name}
in the same {\em prototype-pattern}.
\item
A {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME})
should not have a {\em qualifier-name} or {\em type-name} as an initial segment.
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.
\item
A {\em prototype-result-variable-declaration} {\em variable-name}
can have {\em member-selectors},
unlike an {\em assignment-statement} {\em result-variable-name}
(\pagref{RESULT-VARIABLE-NAME}).  See Clusters \itemref{CLUSTERS}.
\item
For a {\em prototype-result-variable-declaration} of the form `\TT{next} $v$',
$v$ must be the {\em vari\-able-name} in an {\em argument-declaration}
of the form `{\em qualifier-name}\STAR{} {\em type-name} $v$', and
any actual argument associated to the {\em argument-declaration}
must be a {\em variable-name} $w$ for which `\TT{next} $w$' is a legal
{\em assignment-statement} {\em result-variable-declaration} in the
\LSTAR-language (i.e., with {\em member-selectors} allowed for $v$ and
$w$).  If $v$ or $w$ have {\em member-selectors}, these must be identical.
\item
\TT{"="} cannot be used as a {\em term-name}
in a {\em prototype-pattern}.
\item
The first {\em argument-declaration} in an {\em input-variable-list}
must not have a {\em default-value} or end in \TT{??}.
\item
All the result and argument {\em variable-names}
in a {\em function-prototype} must
be distinct.
\item
{\em Argument-declarations} appear inside `\TT{()}' or `\TT{[]}'
bracketed {\em argument-lists} and are \underline{not}
{\em qualifiers-type-argument-declarations} even if they have
the same form.  {\em Qualifiers-type-argument-declarations} appear
inside `\TT{(|\,|)}' bracketed {\em qualifiers-type-argument-lists}.
\item
The {\em variable-name} in a {\em qualifiers-argument-declaration}
or a {\em qualifiers-conditioner} is treated syntactically
as a {\em qualifier-name}
within the rest of the {\em function-prototype}.  The value assigned to the
{\em variable-name} must be computable at compile-time when the
function is called.
\item
The {\em variable-name} in a {\em type-argument-declaration}
or a {\em type-conditioner} is treated syntactically as a {\em type-name}
within the rest of the {\em function-prototype}.  The value assigned to the
{\em variable-name} must be computable at compile-time when the
function is called.
\item
In a {\em pattern-argument-list} or {\em input-variable-list}
an {\em argument-declaration} with no {\em de\-fault-value} cannot
follow an {\em argument-declaration} with a {\em default-value}.
An {\em argument-declaration} that ends with `\TT{??}' is considered
to have a \TT{bool} {\em default-value}: see \pagref{BOOL-DEFAULT}.
\item
Variable qualifiers (\pagref{VARIABLE-QUALIFIER}) can appear
in {\em prototype-result-variable-declarations}, but
cannot appear in {\em argument-declarations}.
\item
Note that prototype result variable names and argument variable names
may have {\em mem\-ber-selectors} in the L-language, unlike
variable names declared by {\em assignment-stat-ments}.  See
Clusters, \itemref{CLUSTERS}.



\end{itemize}
\end{indpar}

The result and argument variable names in a
{\em function-declaration},
and names declared within the {\em statements} of the declaration,
are permitted to hide (\pagref{HIDE})
names in the context of the {\em function-declara\-tion}.

A {\em function-call} with a {\em result-variable-list}
is replaced by an \LSTAR-language (\pagref{LSTAR-LANGUAGE})
{\em block-assignment-statement} (\itemref{BLOCK-ASSIGNMENT-STATEMENTS})
with an context option specifying the context of the
{\em function-declaration}.
Non-{\tt *DEFERRED*} actual arguments are assigned to temporary variables
before the function call {\em block-assignment-statement},
and the temporary variable values are assigned to prototype argument names
at the beginning of the {\em block-assignment-statement}.
Variables declared inside the
{\em block-assign\-ment-statement} are permitted to hide variables outside
the statement (\pagref{HIDE}).  The actual results of the
{\em block-assignment-statement} are temporary variables,
and the values of these are assigned
to the actual result variables after the {\em block-assignment-statement}.

The values of {\tt *DEFERRED*}
argument temporary variables are computed where they are used
inside the {\em block-assignment-statement},
but within their own subblock that has the
{\em function-call} context and not the {\em function-declaration}
context.
Default values for arguments are computed at the beginning
of the {\em block-assignment-statement}, which makes them similar to
non-{\tt *DEFERRED*} prototype argument except that they are computed
in the context of the {\em function-declaration} and not the context
of the {\em function-call}.

{\em Required-values} must be computable at compile time in the
context of the {\em function-declaration}, and have no effect unless
their associated argument is computable at compile time within the
context of the {\em function-call}.
In this case, if the compile time values are not equal, the
{\em function-declaration} does not match the {\em function-call}.
If a {\em function-declaration}
with a {\em required-value} does match the call,
some of the other arguments may be unused and never compiled,
and it may be desireable to permit these arguments to be uncompilable,
that is, to have compile errors if they were compiled.  These
arguments may be marked {\tt *UNUSED*} to suppress their compilation,
as long as such arguments are
not referenced in the function body.

There are examples on pages \pageref{AND-EXAMPLE}, \pageref{IF-ELSE-EXAMPLE},
and \pageref{COMPARE-EXAMPLE}.

If there is a {\em prototype-result-variable-declaration}
of the form `\TT{next} $v$' for some variable name $v$, there must
be a prototype
argument named $v$.
In this case any function call must have an actual argument $w$ that
is a {\em variable-name} for which `\TT{next} $w$' is legal
(in the \LSTAR-language) in the context
of the function call.  The value of the temporary result variable of the
{\em block-assignment-statement} corresponding to the `\TT{next} $v$'
prototype result will be assigned to the `\TT{next} $w$' actual result
after the {\em block-assignment-statement}.

In all cases the types and qualifiers of the actual and prototype
arguments must be such that the assignments mentioned above can
be compiled.  If this is not the case, the call-prototype match
fails and other prototypes will be tried.

An example using this is:
\begin{indpar}\begin{verbatim}
function int32 r, next v = post increment ( int32 v ):
    r = v
    next v = v + 1

int32 x = 1
int32 y = post increment ( x )     // y == 1
int32 z = x                        // z == 2
\end{verbatim}\end{indpar}

A {\em function-call} with an {\em input-variable-list} is just syntactic
sugar for a {\em function-call} with neither a {\em result-variable-list}
or {\em input-variable-list}.  Specifically
\begin{center}
{\tt F(a1,a2,...)~=~b1,b2,...} \\
is syntactic sugar for \\
{\tt F(a1,a2,...)~"="~(b1,b2,...)} \\
\end{center}

in which a term with \TT{"="} as its {\em term-name} is
placed at the end of the {\em function-call}.

{\em Call-terms} correspond to {\em pattern-terms}.  {\em Call-terms}
other than the first may be in a different order than their matching
{\em pattern-terms}.  {\em Call-terms} other than the first may be
omitted, and if omitted, will be inserted with empty {\em call-argument-lists}.
{\em Call-argument-lists} may be omitted, and if omitted, empty
lists will be inserted if this can be done unambiguously.
If a {\em pattern-argument-list} has \TT{()} brackets and a single
argument, and the corresponding {\em call-argument-list} has a single
{\em actual-argument} that
is a {\em primary-argument} ( sequence of {\em words}, {\em numbers},
and {\em quoted-strings}, or a {\em bracketed-constant}), then
the \TT{()} parentheses may be omitted in the {\em function-call}
if the {\em actual-argument} is bounded unambiguously by {\em call-terms}
and other argument lists without omitted parentheses.

Examples are:
\begin{indpar}\begin{verbatim}
function int32 r =
        fee ( int32 x ) fie ( int32 y ) foe ( int32 z ):
    ... function body omitted ...

int32 b 1 = ...
int32 c 2 = ...
int32 d 3 = ...
int32 f = fee ( b 1 ) foe ( c 2 ) fie ( d 3 )
    // Same as:
    //   int32 f = fee ( b 1 ) fie ( d 3 ) foe ( c 2 )
int32 g = fee ( b 1 ) foe ( c 2 )
    // Same as:
    //   int32 g = fee ( b 1 ) fie () foe ( c 2 )
    // Erroneous: actual argument missing
int32 h = fee b 1 foe c 2 fie d 3
    // Same as:
    //   int32 h = fee ( b 1 ) fie ( d 3 ) foe ( c 2 )
\end{verbatim}\end{indpar}

If an argument has a {\em required-value} in a {\em pattern-argument-list},
then there must be a corresponding {\em actual-argument} in the
{\em function-call} whose value is a compile-time value that equals the
{\em required-value}, which must also be a compile-time value.  An example is:
\begin{indpar}\begin{verbatim}
define types:
    my type as int32
    your type as uns32
function type r = companion type of ( type t == my type ):
    r = your type
function type r = companion type of ( type t == your type ):
    r = my type
\end{verbatim}\end{indpar}

{\em Actual-arguments} may be omitted at the end of a {\em call-argument-list}
if their corresponding
{\em argu\-ment-declaration} contains a {\em default-value}.
\label{DEFAULT-VALUE}
The \emkey{default-value} will be used as the actual argument
for such an omitted actual argument.

If the {\em argument-declaration} ends in `\TT{??}'\label{BOOL-DEFAULT}
with no explicit {\em default-value}, the
argument must have \TT{bool} type and the
{\em default-value} is taken to be \TT{true} if the
corresponding {\em call-term} was originally present, and \TT{false} if the
{\em call-term} was originally omitted and automatically inserted.

An example is:
\begin{indpar}\begin{verbatim}
int32 B = ...
int32 C = ...
context fooC = current context
function int32 r =
        foo ( int32 x ) bar ( int32 y ?= B + C, bool z ?? )
    ... function body omitted ...

int32 b 1 = ...
int32 f = foo ( b 1 )
    // Call has same effect as:
    //     int32 tmp y, bool tmp z = do ( fooC ):
    //         tmp y = B + C
    //         tmp z = false
    //     int32 f = foo ( b 1 ) bar ( tmp y, tmp z )
\end{verbatim}\end{indpar}

A {\em type-argument-declaration} inside `\TT{(|\,|)}' brackets or
a {\em type-conditioner} inside `\TT{[|\,|]}' brackets has the
form `{\tt type T \ldots}' for some {\em variable-name} {\tt T}.
This makes {\tt T} into a {\em type-name} within the {\em function-declaration}
containing the {\em type-argument-declaration}.
For a {\em type-argument-declaration}
in `\TT{(|\,|)}' brackets,
the actual value of {\tt T} can be implied by a {\em function-call}.
If an explicit or default value of {\tt T} is given by the call, that is used.
Otherwise if {\tt T} is the type of a prototype result variable, and there
is a corresponding {\em function-call} result variable with a known type,
the type of the \underline{leftmost} such {\em function-call} result variable
is assigned as the value of {\tt T}.  Otherwise
if {\tt T} is the type of a prototype argument variable, and
the {\em actual-argument} corresponding to the variable in the call has
a natural type (\pagref{NATURAL-TYPE}), {\tt T} is assigned the natural type
corresponding to the leftmost such variable in the prototype.


For example,
\begin{indpar}\begin{verbatim}
function T result = add (| type T |) ( T v1, T v2 ):
    result = v1 + v2

// Example usage
//
int32 x = ...
int32 y = ...
int32 z = add (| int32 |) ( x, y )
    // T is explicitly given.
next z = add ( x, y )
    // T = int32 is implied because that is the type of
    // `next z'.
\end{verbatim}\end{indpar}

A {\em qualifiers-argument-declaration}
\label{QUALIFIERS-ARGUMENT-DECLARATION-DISCUSSION}
inside `\TT{(|\,|)}' brackets or
a {\em qualifiers-conditioner} that is inside `\TT{[|\,|]}' brackets has the
form `{\tt qualifiers Qs \ldots}' for some {\em variable-name} {\tt Qs}.
This makes {\tt Qs} into a {\em qualifier-name}
within the {\em function-de\-clar\-a\-tion}
containing the {\em qualifiers-argument-de\-clar\-a\-tion}.  Note that {\tt Qs}
is used like a {\em qualifier-name}, but its value is a set of
zero or more qualifiers.

For a {\em qualifiers-argument-declaration}
within `\TT{(|\,|)}' brackets,
the actual value of {\tt Qs} may be implied by a {\em function-call}.
If an explicit or default value of {\tt Qs} is given by the call, that is used.
Otherwise if {\tt Qs} is given as a qualifier
of a prototype result or argument variable,
{\tt Qs} is assigned the \underline{value} qualifiers of the
corresponding actual variable that are not explicitly given the
prototype variable.  If {\tt Qs} is a qualifier of several prototype
argument variables, the \underline{leftmost} of these
is used, else if {\tt Qs} is a qualifier of several prototype result
variables, the \underline{leftmost} of these is used.
However any actual result variable used must have
a known type, and any actual argument variable used must have
a natural type (\pagref{NATURAL-TYPE}), else the call-prototype match
fails.

For example,
\begin{indpar}\begin{verbatim}
define implied deletable value qualifier in-range
define value qualifier ouch
function Qs in-range T r =
        check (| qualifiers Qs, type T |) ( Qs T v ):
        // Checks that v is in range and if so, copies
        // it to r and adds in-range qualifier.
    if:
        v < 0:
            error "argument < 0"
        v > 100:
            error "argument > 100"
        else:
            r = v

function ouch int32 F ( ... ):
    ... function body omitted ...
function G ( in-range ouch v ):
    ... function body omitted ...

// Example usage
//
ouch int32 x = F ( ... )
ouch int32 y1 = check ( x )
           // Legal: check prototype becomes:
           //   ouch in-range r = check ( ouch int32 v )
           // so result can have qualifier ouch.
           // Also y1 is given implied qualifier in-range.
int32 y2 = check ( x )
           // Illegal: y must have explicit qualifier ouch.
G ( x )    // Illegal, x does not have required in-range.
G ( y1 )   // Legal, y1 has required in-range and ouch.
\end{verbatim}\end{indpar}

{\em Conditioners} bracketed by `\TT{[|\,|]}'
can be written at the end of a {\em function-prototype},
as in:
\begin{indpar}\begin{verbatim}
types signed-integer-types =
    { int8, int16, int32, int64, int128 }

function T result = add (| type T |) ( T v1, T v2 )
    [| T is in signed-integer-types |]:
    result = v1 + v2
\end{verbatim}\end{indpar}

which would define `{\tt add}' only for signed integer types.
Here the conditioner is a {\em logical-ex\-pres\-sion} that must
be evaluatable whenever a call to the function is compiled.

Another example is:
\begin{indpar}\begin{verbatim}
function *UNCHECKED* Qsr T r = remove *STACK*
    (| qualifiers Qsv, type T |) ( Qsv T v )
    [| qualifiers Qsr = Qsv - { *STACK* } |]:
    r = v
\end{verbatim}\end{indpar}

which returns a value with the same value qualifiers as {\tt v}
except for the `{\tt *STACK*}' qualifier which is removed.
Here the rightside of the {\em qualifiers-conditioner}
must be evaluatable when a call to the function is compiled.

The body of an inline function is parsed, but it is not checked for
errors before the function is called.  When the function is called,
compile time values passed as arguments may cause parts of the body
to never be compiled or checked for compilation errors.  If a function
is never called, it may contain code that would have compilation errors
were the function called, such as calls to non-existent functions.

\subsection{Matching Calls to Prototypes}
\label{MATCHING-CALLS-TO-PROTOTYPES}

To compile a {\em function-call}
or {\em generic-call} it must be matched to a
single {\em function-prototype} or {\em generic-prototype}.
If the call matches more than one
prototype, the call is ambiguous and is a compilation error.

Calls that are {\em statements} by themselves, with no
result variables, are matched to both {\em function-prototypes}
with no result variables, and to
{\em generic-prototypes} (\pagref{GENERIC-PROTOTYPE}),
and no distinction is made during
matching between these two kinds of prototypes.

The matching algorithm, given a call and a
prototype, matches the call
to the {\em prototype-pattern} in the prototype,
and matches any call result variables to
the {\em prototype-result-variable-list}
of the prototype.  The call may have one or more result
variables of known types, or a single result variable of unknown
type, or no result variables (as in a call that is
a {\em statement} by itself).  The matching algorithm is as follows:

\begin{enumerate}

\item
If the call is in a statement of the form
\begin{center}
{\em function-call} ~ \TT{=} ~ {\em expression-list}
\end{center}
the prototype must be of the form
\begin{center}
{\tt function} ~ {\em prototype-pattern} ~ {\tt =} ~ {\em input-variable-list} \\
\end{center}
and the following will be done:
\begin{enumerate}
\item `\TT{=}' will be treated in the following as if it were the
{\em term-name} \TT{"="}.
\item{\em expression-list} is parenthesized.
\item {\em input-variable-list} is parenthesized.
\end{enumerate}

For example, the prototype
\begin{center}
\tt function F ( int64 i ) = int32 x, int32 y
\end{center}
behaves as if it were
\begin{center}
\tt function F ( int64 i ) "=" ( int32 x, int32 y )
\end{center}
and the assignment statement
\begin{center}
\tt F ( i ) = x, y
\end{center}
behaves as if it were the function call with no result variables
\begin{center}
\tt F ( i ) "=" ( x, y )
\end{center}

\item If the call begins with a {\em module-abbreviation}
(see \pagref{MODULE-ABBREVIATION}), the {\em prototype-pattern}
must begin with a {\em module-abbreviation}, and the two
{\em module-abbreviations} must reference the same {\em module-name}
(i.e., module file, see \itemref{MODULES}), else the
call-prototype match fails.

\item If the call does \underline{not} begin
with a {\em module-abbreviation}, but the {\em prototype-pattern}
does begin with a {\em module-abbreviation}, the match is marked
as `\key{module deficient}'\label{MODULE-DEFICIENT},
and will be disallowed later if there is
another match that is not module deficient.

\item
The {\em term-names} in the call are located by
matching segments of the call to
{\em term-names} in the {\em prototype-pattern}.
If a {\em term-name} matches more than one segment,
the call-prototype match fails.  If the first {\em term-name}
in the {\em prototype-pattern} does not match any segment,
or does not match the first matched segment, the call-prototype match fails.
(Note that {\em term-names} in the {\em prototype-pattern}
cannot be initial segments of each other, but unparenthesized
{\em variable-names} may appear in the call and be
mistaken for parts of {\em term-names}.)

\item The {\em call-terms} after the first in the call
are reordered so the {\em term-names} in the call,
taken in order, are a subsequence of the {\em term-names} in the
{\em prototype-pattern}.
If this cannot be done, the call-prototype match fails.
(Note that {\em call-terms} other than the first all begin with
a {\em term-name} and extend until the next {\em term-name}
or the end of the call.)

\item\label{ADD-TERMS}
If some of the {\em term-names} in the {\em prototype-pattern}
are missing from the call,
new {\em call-terms} without argument lists
are inserted in the call to match the missing
{\em pattern-terms}.  At this point there is a 1-1 ordered correspondence
between {\em call-terms} and {\em pattern-terms}.

\item
If some of the {\em pattern-terms} have argument lists that
have a single parenthesized argument, the parentheses may be omitted
in the call if the actual argument is a sequence of
{\em primary-items} or a {\em bracketed-constant}.
Also {\em argument-lists}
may be completely omitted in the call.  At this point
missing parentheses and missing {\em argument-lists} are added to
each {\em call-term} to make it match the corresponding
{\em pattern-term}.
The {\em argument-lists} added are empty and have the same type of
bracket, \TT{()}, \TT{[]}, or \TT{(|~|)}, as the {\em pattern-term}
{\em argument-lists} they match.

If this cannot be done \underline{uniquely}
so each {\em pattern-term} {\em argument-list}
is matched to a {\em call-term} {\em argument-list}
that has the same type of bracket, then the call-prototype match fails.

\item
\label{CLUSTER-MEMBER-ARGUMENTS}
If the prototype
has cluster member arguments,
these are implied in the call, and they are added to the call
at this point.  If this cannot be done because some of the required
cluster members do not exist in the context of the call, and if the
corresponding prototype arguments do not have default values,
the call-prototype match fails.  See \itemref{CLUSTERS} for details.

But if a required cluster member does not exist and the prototype
argument does have a default value, the default value becomes the
actual argument corresponding to the prototype argument.
In this case the prototype argument must be followed by \TT{?=},
and \underline{not} \TT{??}, in the prototype.

The modified call now matches
the {\em prototype-pattern} in {\em term-names},
location and number of {\em argument-lists}, and type of bracket (\TT{()},
\TT{[]}, or \TT{(|~|)}) for each {\em argument-list}.  Some
{\em call-argument-lists} may be shorter than the corresponding
{\em pattern-argument-lists}.

\item
If the prototype has cluster member results,
these will be created by the call, and if they already exist,
the call-prototype match fails.

\item\label{NEXT-CALL-PROTOTYPE-MATCHING}
If the prototype has a `\TT{next} $v$' result, then $v$ must be the
name of a prototype argument whose corresponding actual argument is
a variable name $w$ for which `\TT{next} $w$' is a permitted assignment
result in the \LSTAR-Language (\pagref{LSTAR-LANGUAGE}), else the
call-prototype match fails.  If `\TT{next} $w$' is permitted, it
becomes the actual result corresponding to the `\TT{next} $v$' prototype
result.

An exception to the last paragraph occurs when $w$ is the name of
a cluster member that does not exist, but $v$ has a default value.
In this case `\TT{next} $v$' is effectively replaced in the prototype
by $v$ with its type and qualifiers.

\item
If some of the {\em call-argument-lists} are now too long, the call-prototype
match fails.

\item
If some of the {\em call-argument-lists} are now too short, they are extended
by adding the {\em default-values} from
their matching {\em pattern-argument-lists}.
As a special case, if a prototype {\em arg\-u\-ment-de\-clar\-a\-tion} ends in
`\TT{??}' and has no {\em default-value}, then the actual
{\em default-value} used is \TT{true} if the {\em term-name}
appeared in the original function call and was not added in
Step~\ref{ADD-TERMS} above, or is \TT{false} if the {\em term-name}
did not appear in the original function call, but was added in
Step~\ref{ADD-TERMS}.

If any of the arguments that need to be inserted in a
{\em call-argument-list} matched to a {\em regular-argument-list}
(lists with \TT{()} or \TT{[]} brackets)
do not have {\em default-values}, the call-prototype match fails.

Now the modified call matches
the {\em prototype-pattern} in {\em term-names},
location and number of {\em argument-lists}, and type of bracket (\TT{()},
\TT{[]}, or \TT{(|~|)}) for each {\em argument-list}.  The number of
arguments also match for \TT{()} and \TT{[]} {\em argument-lists},
and number of actual arguments in each \TT{(|~|)} {\em call-argument-list}
is not greater than the number of arguments in the corresponding
{\em pattern-argument-list}.

\item
Any arguments marked \TT{*UNUSED*} are ignored during call-prototype
matching from this point on.  Such prototype arguments must not be referenced
in the body of a successfully matched {\em function-declaration},
but on the other hand, the corresponding actual arguments
need not be compilable, as they will not be compiled.

\item
If any {\em type-argument-declaration} in a {\em prototype-pattern}
{\em qualifiers-type-argument-list} has a corresponding
actual argument, the actual argument expression
is evaluated with the `\TT{type}' target type,
and must have a compile time value which is a type, else
the call-prototype match fails.  If the match does not fail,
the type value becomes the value of the {\em variable-name}
in the {\em type-argument-declaration} and
is substituted for the {\em variable-name} throughout the rest of the
prototype.

\item
\label{IMPLIED-TYPE-DETERMINATION-STEP}
If any {\em type-argument-declaration} in a {\em prototype-pattern}
{\em qualifiers-type-argument-list} does \underline{not} have
a corresponding actual or default argument, the value of the
{\em variable-name} in the {\em type-argument-declaration}
is implied.

If the {\em variable-name} in the {\em type-argument-declaration}
is used as the {\em type-name} of a prototype result or argument variable,
it is assigned the type of the corresponding actual variable.
If {\em variable-name} is the type of several prototype
variables, the leftmost result is used if it exists, and otherwise
the leftmost argument is used.
However the matching actual argument or result used must have
have known type if it is a result, or a
natural type (\pagref{NATURAL-TYPE}) if it is an argument,
else the call-prototype match fails.

If a matching actual argument is used, its type is determined by
compiling the actual argument with a single result variable of
unknown type.  If this compilation fails, the call-prototype match
fails, even if the argument is \TT{*DEFERRED*} and ends up not being
used in the call expansion\footnotemark.

\newcounter{DeferredFootnote}
\setcounter{DeferredFootnote}{\value{footnote}}
\footnotetext{This means that {\tt *DEFERRED*}
arguments should be in the call expansion unless other arguments to
the function have specific compile-time values that can be intercepted
by alternate prototypes: see the implementation of
\TT{if/else} on \pagref{IF-ELSE-IMPLEMENTATION} for an example.}

If no value can be assigned to the {\em variable-name} by these rules,
the call-prototype match fails.

If a value is assigned,
the type that is the assigned value is added as an actual argument
in the {\em call-argument-list} that corresponds
to the {\em type-argument-declaration}, and
is substituted for the {\em variable-name} throughout the rest of the
prototype.

\item
If any {\em qualifiers-argument-declaration} in a {\em prototype-pattern}
{\em qualifiers-type-argument-list} has a corresponding
actual argument, the actual argument expression
is evaluated with the `\TT{qualifiers}' target type,
and must have a compile time value which is a set of qualifiers, else
the call-prototype match fails.  If the match does not fail,
the set of qualifiers becomes the value of the {\em variable-name}
in the {\em qualifiers-argument-declaration} and
is substituted for the {\em variable-name} throughout the rest of the
prototype.

\item
If any {\em qualifiers-argument-declaration} in a {\em prototype-pattern}
{\em qualifiers-type-argument-list} does \underline{not} have
a corresponding actual or default argument, the value of the
{\em variable-name} in the {\em qual\-i\-fiers-argument-declaration}
is implied.

If the {\em variable-name} in the {\em qualifiers-argument-declaration}
is used as a {\em qualifier-name} of a prototype result or argument variable,
it is assigned the \underline{value} qualifiers of the
corresponding actual variable that are not explicitly given as qualifiers
of the prototype variable.  If {\em variable-name}
is a qualifier of several prototype
variables, the leftmost
argument is used if it exists, and otherwise
the leftmost result is used.
However the matching actual argument or result used must have
have known type if it is a result, or a
natural type (\pagref{NATURAL-TYPE}) if it is an argument,
else the call-prototype match fails.

If a matching actual argument is used, its qualifiers are determined by
compiling the actual argument with a single result variable of
type given by the prototype, unless the argument was compiled in
Step \ref{IMPLIED-TYPE-DETERMINATION-STEP}.
If this compilation fails, the call-prototype match
fails, even if the argument is \TT{*DEFERRED*} and ends up not being
used in the call expansion.\footnotemark[\value{DeferredFootnote}]
If instead the argument was compiled in
Step \ref{IMPLIED-TYPE-DETERMINATION-STEP}, then the result variable
qualifiers determined by that compilation are used.

If no value can be assigned to the {\em variable-name} by these rules,
the call-prototype match fails.

If a value is assigned,
the set of qualifiers that is the assigned value
is added as an actual argument
in the {\em call-argument-list} that corresponds
to the {\em qualifiers-argument-declaration}, and
is substituted for the {\em variable-name} throughout the rest of the
prototype.

\item
The modified call now matches the {\em prototype-pattern}
precisely in {\em term-names},
location and number of {\em argument-lists}, type of bracket, i.e. \TT{()},
\TT{[]}, or \TT{(|~|)} for each {\em argument-list}, and number of
arguments in each {\em argument-list}.
This modified function call is referred to as the
`\mkey{unfolded}{call}' call.

If any actual argument value needs to be a compile-time value in what
follows, the actual argument expression is compiled at this
time with its target type taken from the corresponding
{\em prototype-pattern} {\em argument-declaration}.
If the result is not a compile-time value, or an error occurs
while compiling the result, the call-prototype
match fails.

Note that any {\em default-values} inserted in the call
are evaluated in the context of the prototype, and not the
context of the call.

\item
If a pattern {\em argument-declaration} has a {\em required-value},
there must at this point be a matching call {\em actual-argument}
with a compile-time value equal to the {\em required-value},
else the call-prototype match fails.

\item
The {\em conditioners} in the prototype are evaluated
in order.  If any of the expressions in them do not have compile-time
values, the call-prototype match fails.
If any {\em logical-conditioner} evaluates
to \TT{false}, the call-prototype match fails.

If the value assigned to the {\em variable-name} of a
{\em type-conditioner} is not a type, the call-prototype match fails.
Otherwise this type value is substituted for the {\em variable-name}
throughout the prototype.

If the value assigned to the {\em variable-name} of a
{\em qualifiers-conditioner} is not a (possibly empty) set of
qualifiers, the call-prototype match fails.
Otherwise this qualifiers set value is substituted for the {\em variable-name}
throughout the prototype.

\item\label{ARGUMENT-CALL-PROTOTYPE-MATCHING}
If the {\em prototype-pattern} has
non-\TT{*DEFERRED*} {\em argument-declarations}
`$Qs1$ $T1$ $v1$', `$Qs2$ $T2$ $v2$', \ldots{} read from left to right,
and the unfolded call has {\em actual-argument}
expressions $e1$, $e2$, \ldots{} corresponding to $v1$, $v2$, \ldots{}
(including {\em default-values}),
then the statement containing the
revised call is replace by:
\begin{indpar}
{\tt $Qs1$ $T1$ $tmp1$ = $e1$} \\
{\tt $Qs2$ $T2$ $tmp2$ = $e2$} \\
\ldots\ldots\ldots\ldots \\
statement containing call
with each {\em actual-argument} $eI$ replaced by $tmpI$
\end{indpar}

Here the $Qs\ldots$ are possibly empty qualifier sets,
the $T\ldots$ are types, the $v\ldots$ are argument variable
names, and the $tmp\ldots$ are
\skey{temporary variable name}s (names of the form \TT{T\$}$n$
for a natural number $n$ manufactured by the compiler and
guaranteed to a unique among all {\em names}.)

If any $eI$ is a {\em default-value}, then in the above
\begin{indpar}
{\tt $QsI$ $TI$ $tmpI$ = $eI$}
\end{indpar}
is replaced by
\begin{indpar}
{\tt $QsI$ $TI$ $tmpI$ = do ( }{\em prototype-context}{\tt ~):} \\
\hspace*{0.5in}{\tt $tmpI$ = $eI$}
\end{indpar}

If any the statements `{\tt $QsI$ $TI$ $tmpI$ = \ldots}' cannot be compiled
for reasons other than an ambiguity error, the call-prototype match fails.

If any of the statements `{\tt $QsI$ $TI$ $tmpI$ = \ldots}' cannot be compiled
because of an ambiguity error, the call-prototype match
is `\key{ambiguity deficient}' (and will be
rejected later, possibly for another reason).

Note that for call-prototype matching purposes,
\ttamkey{DEFERRED}{call-prototype matching} prototype
arguments are ignored.  This is because they might never be compiled
(see the end of section \itemref{EVALUATION-ORDER}).

\item If the call has no result variables, either the
prototype must have no result variables,
or the first prototype result variable must have the
\ttakey{OPTIONAL} pseudo-qualifier,
else the call-prototype match fails.

\item If the call has one result variable of
unknown type, the prototype must have result variables
else the call-prototype match fails.
The type and qualifiers of the first
prototype result variable become the
type and qualifiers of the on call result variable, and also become the
natural
type and qualifiers (\pagref{NATURAL-TYPE})
of the call expression if
the match ultimately is accepted according to the rules below.

\item \label{FUNCTION-CALL-ASSIGNMENT-COMPILATION}
The prototype is now of the form
\begin{center}
{\tt function $QRs1$ $TR1$ $vr1$, $QRs2$ $TR2$ $vr2$,
     \ldots{}~=~}{\em prototype-pattern}
\end{center}
where $QRs1$, $TR1$, $QRS2$, $TR2$, \ldots{} are known.
The function call is now of the form
\begin{center}
{\tt $QCs1$ $TC1$ $vc1$, $QCs2$ $TC2$ $vc2$, \ldots{}~=~}{\em function-call}
\end{center}
where some of the $QCs.~TC.~v.$ may be replaced by `\TT{next} $w$' as per
(\ref{NEXT-CALL-PROTOTYPE-MATCHING}) above.

Then the function call is replaced by:
\begin{indpar}
{\tt $QRs1$ $TR1$ $tmp1$, $QRs2$ $TR2$ $tmp2$,
    \ldots{}~=~}{\em function-call} \\
{\tt $QCs1$ $TC1$ $vc1$ = $tmp1$} \\
{\tt $QCs2$ $TC2$ $vc2$ = $tmp2$} \\
\ldots\ldots\ldots\ldots
\end{indpar}
where $tmp1$, $tmp2$, \ldots{} are temporary variables.  There is
no statement `\ldots~$vc.$ = $tmp.$' if $vc.$ does not exist because
there are fewer actual result variables than there are prototype result
variables.

Here the assignments `\ldots~$vc.$ = $tmp.$' are treated as
result assignments, and not as ordinary assignments,
for the purposes of computing and checking qualifiers
(\pagref{DIRECT-ASSIGNMENT}).

If $QC.$ contains the \ttamkey{READ}{in call-prototype match}
or \ttamkey{WRITE}{in call-prototype match}
qualifier, the statement
`\ldots~$vc.$ = $tmp.$' must satisfy the rules of a direct
assignment (\pagref{DIRECT-ASSIGNMENT}), else the call-prototype
match fails.  In this case the assignment is treated as an
assignment for the purposes of implying qualifiers and determining
if it is a direct assignment, but is otherwise treated as if it did
not exist (no instructions are executed to copy a value).
See \itemref{THE-READ-AND-WRITE-QUALIFIERS}
for more on the \TT{*READ*} and \TT{*WRITE*} qualifiers.

If any of the `{\tt $QCsI$ $TCI$ $vc1$ = $tmpI$}' statements cannot be
compiled, the call-prototype match fails.

If the assignment `\ldots~$vc1$ = $tmp1$' exists and is not a direct
assignment (\pagref{DIRECT-ASSIGNMENT}), the match is marked
`\key{conversion deficient}'\label{CONVERSION-DEFICIENT},
and will be disallowed later
if there is another match that is not conversion deficient.
Note that only the first result variable is considered by this rule.

\end{enumerate}


The first step in compiling a call is to compute the
set of matches of that call.  Then the following is done in order:

\begin{enumerate}

\item If there is any match that is not conversion deficient, then
all conversion deficient matches are discarded.

\item\label{REQUIRED-ARGUMENTS-PREFERRED}
Let $e1$, $e2$, \ldots{}~be the argument expressions of
the not-unfolded original call, read from left to right.
If there are two matches $X$ and $Y$ such that
some of the $eI$ have
have {\em required-values} in $X$ but not in $Y$, and none of the $eI$
have {\em required-values} in $Y$ but not in $X$,
then the $Y$ match is discarded.

\item\label{MORE-SPECIFIC-ARGUMENT-TYPES-PREFERRED}
Let $e1$, $e2$, \ldots{}~be the argument expressions of
the not-unfolded original call, read from left to right.
If there are two matches $X$ and $Y$ such that
$TX1$, $TX2$, \ldots{}~are the types of the $X$ prototype argument
variables assigned to $e1$, $e2$, \ldots{}~in order, and
$TY1$, $TY2$, \ldots{}~are the types of the $Y$ argument
variables assigned to $e1$, $e2$, \ldots{}~in order,
and type $TXi$ is more specific (\pagref{MORE-SPECIFIC-RELATION})
than type $TYi$ for
every $i$, but not vice versa (which can only happen if
all the types are the same),
then the $Y$ match is discarded.

\item If there is any remaining match that is not module deficient, then
all module deficient matches are discarded.

\item If after discarding matches as above, there are no matches,
the call is `\key{unmatched}' and cannot be compiled.

\item If after discarding matches as above, there is more than one
match left,
the call is `\key{ambiguous}' and cannot be compiled.

\item If the remaining match has
an ambiguity deficiency,
the call is `\key{ambiguous}' and cannot be compiled.

\item Otherwise there is just one match left, and that
match has no ambiguity deficiency.  That match
is accepted and used to compile the call.

\end{enumerate}

\section{Generics}
\label{GENERICS}

A \key{generic} is an inline function that is completely
evaluated at compile time and that contains special
`\skey{include-statement}s' which generate code that replaces the generic call
in the program.  Within the included code compile time values are substituted
for `\skey{include-argument}s'.

An example is:
\begin{indpar}\begin{verbatim}
generic min-max ( name F, name C )
    include (F, C):
        function T result = F (| type T |) ( T x, T y ):
            result = if:
                (x) C (y):
                    result = x
                (y) C (x):
                    result = y
                T is float:
                    result = NaN
                else:
                    program stop

min-max functions ( `min', `"<="' )
int64 u = ...
int64 v = min ( u, -1,000,000 )
min-max functions ( `max', `"=>"' )
float64 w = ...
next w = max ( w, -1,000,000 )
\end{verbatim}\end{indpar}

Note that {\tt C} is a function call {\em term-name} and not
an operator.
Also if `{\tt T is float}' is \TT{false} the assignment of \TT{NaN}
to `{\tt result}' will not be compiled or checked for errors
(\pagref{CONDITIONAL-SPECIAL-RULE}), while if it is \TT{true}
the `\TT{else}' subblock will not be compiled.

The general syntax is:
\begin{indpar}
\emkey{generic-declaration}\label{GENERIC-DECLARATION}
    ::= \begin{tabular}[t]{l}
        {\em generic-prototype}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{generic-prototype}\label{GENERIC-PROTOTYPE}
    \begin{tabular}[t]{rl}
    ::= & \TT{generic} ~ {\em module-abbreviation}\QMARK{}
                       ~ {\em prototype-pattern} \\
    $|$ & {\em generic-prototype} \TT{[|} {\em generic-conditioner} \TT{|]}
    \end{tabular}
\\[0.5ex]
{\em prototype-pattern} ::= see \pagref{FUNCTION-PATTERN}
\\[0.5ex]
\emkey{generic-conditioner}\label{GENERIC-CONDITIONER}
    \begin{tabular}[t]{rl}
    ::= & {\em conditioner} ~~~~~ [see \pagref{CONDITIONER}] \\
    $|$ & {\em external-conditioner}
    \end{tabular}
\\[0.5ex]
\emkey{external-conditioner}\label{EXTERNAL-CONDITIONER}
    \begin{tabular}[t]{rl}
    ::= & \ttmkey{external}{conditioner} \\
    $|$ & \TT{external if} ~ {\em logical-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{generic-call}\label{GENERIC-CALL}
    ::= {\em function-call} ~~~~~ [see \pagref{FUNCTION-CALL}]
\\[0.5ex]
\emkey{include-statement}\label{INCLUDE-STATEMENT} ::=
    \begin{tabular}[t]{rl}
    ::= & {\em include-if-statement} \\
    $|$ & {\em include-for-statement} \\
    \end{tabular}
\\[0.5ex]
\emkey{include-if-statement}\label{INCLUDE-IF-STATEMENT} ::= \\
\hspace*{1in}
    \begin{tabular}[t]{l}
    \ttkey{include} ~ \begin{tabular}[t]{@{}l@{}}
                      {\em include-name}\QMARK{}
                          ~ {\em include-argument-list}\QMARK{} \\
		      \{ \TT{if} ~ {\em logical-expression}
		                 ~ \}\QMARK{} ~ \TT{:} \\
		      \end{tabular} \\
    \TT{~~}{\em statement}\STAR{}
    \end{tabular}
\\[0.5ex]
\emkey{include-for-statement}\label{INCLUDE-FOR-STATEMENT} ::= \\
\hspace*{1in}
    \begin{tabular}[t]{l}
    \TT{include}\ttindex{include for}
        ~ \begin{tabular}[t]{@{}l@{}}
	  {\em include-name}\QMARK{}
	      ~ {\em include-argument-list}\QMARK{} \\
	  \TT{for} ~ {\em include-argument-type}
	           ~ {\em include-argument-name} \\
	  \TT{in} ~ {\em list-expression} ~ \TT{:} \\
	  \end{tabular} \\
    \TT{~~}{\em statement}\STAR{}
    \end{tabular}
\\[0.5ex]
{\em logical-expression} ::= see \pagref{LOGICAL-EXPRESSION}
\\[0.5ex]
{\em list-expression} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[0.5ex]
\emkey{include-name} ::=
    \begin{tabular}[t]{l}
    {\em name} ~~~~~ [see \pagref{NAME}] \\
    \underline{not} containing
	`\TT{.}',~ {\em quoted-marks},~ {\em quoted-separators},`\TT{if}',
		or `\TT{for}'
    \end{tabular}
\\[0.5ex]
\emkey{include-argument-list} ::=
    \TT{(} {\em include-argument-name}
           \{ \TT{,} {\em include-argument-name} \}\STAR{}
    \TT{)}
\\[0.5ex]
\emkey{include-argument-name} ::= {\em word} not containing `\TT{.}'
\\[0.5ex]
\emkey{include-argument-type} ::= {\em type-name} referencing
	an include argument type
\\[0.5ex]
\ikey{Include Argument Type}{include argument type} - One of:
    \begin{tabular}[t]{l}
    \TT{name} ~~~ \TT{character} ~~~ \TT{string} \\
    \TT{uns$x$} ~~~ \TT{int$x$} ~~~ \TT{float$x$} \\
    \TT{type} ~~~ \TT{qualifier} ~~~ \TT{qualifiers}
    \end{tabular}
\end{indpar}

A {\em generic-prototype} is like a {\em function-prototype} without
result variables, and a {\em generic-call} is like a {\em function-call}
without result variables.  {\em Function-calls} without result variables
are matched to both {\em function-prototypes} without result variables
and to {\em generic-prototypes}, and those that end up matching just a
{\em generic-prototype} are {\em generic-calls}.

A {\em generic-call} is executed at compile-time and generates a list
of `\skey{included statement}s' that replace the {\em generic-call} in
the compilation.  The included statements are the {\em statements}
of the subblocks at the end of the {\em include-statements} executed
by the called generic function.  If several {\em include-statements}
are executed, the included statement lists they generate are concatenated
in execution order.

Within the included statements generated by an {\em include-statement}
the values of the {\em include-state\-ment}'s arguments
are substituted for the {\em include-argument-names} of these
arguments.  These values are the values of variables named by
the {\em include-argument-names} within the scope
of the {\em include-statement}, and these variables
must have {\em include-argument-types}.
The substitutions depend on the {\em include-argument-types}
of the variables as follows:
\begin{indpar}[0.5in]
\hspace*{-0.3in}\ttmkey{name}{include argument}
The include argument name is replace by the sequence of lexemes represented by
the \TT{name}.  A {\em name-item} that has the syntax of a {\em word}
or {\em number} lexeme is represented by that lexeme, and all other
{\em name-items} are represented by {\em quoted-strings}.

\hspace*{-0.3in}\ttmkey{character}{include argument}
The include argument name is replaced by the two lexeme
character constant representing the value. 

\hspace*{-0.3in}\ttmkey{string}{include argument}
The include argument name is replaced by a single quoted string lexeme
representing the value.

\hspace*{-0.3in}\ttmkey{uns$x$}{include argument}
The include argument name is replace by a single natural number lexeme.

\hspace*{-0.3in}\ttmkey{int$x$}{include argument}
The include argument name is replace by a single decimal integer lexeme.

\hspace*{-0.3in}\ttmkey{float$x$}{include argument}
The include argument name is replace by a single decimal floating point
number lexeme if the value can be represented exactly by that
lexeme.  Otherwise the include argument name is replaced by the two lexeme
hexadecimal number constant representing the value exactly. 

\hspace*{-0.3in}\ttmkey{type}{include argument}
The include argument name is replaced by a type name referencing the
value.  If no type name has been defined for the \TT{type} value, the
compiler generates a {\em type-name} that is unique among all names
within the current compilation (of a module or body)
and can be used within this compilation to refer to the type.

\hspace*{-0.3in}\ttmkey{qualifier}{include argument}
The include argument name is replaced by a qualifier name referencing the
value.  If no qualifier name has been defined for the \TT{qualifier} value, the
compiler generates a {\em qualifier-name} that is unique among all names
within the current compilation (of a module or body)
and can be used within this compilation to refer to the type.

\hspace*{-0.3in}\ttmkey{qualifiers}{include argument}
The include argument name is replaced by a list of qualifier names referencing
the qualifiers listed in the value, which must be a qualifier list or a
qualifier set.  If one of these qualifiers has no name, the
compiler generates a {\em qualifier-name} that is unique among all names
within the current compilation (of a module or body)
and can be used within this compilation to refer to the qualifier.

\hspace*{-0.3in}Also the name `\ttkey{..ma}' is treated by the parser
as a module abbreviation, and if it appears in the included code,
refers to either the current module or to no module (as for a non-external
name), as determined by {\em external-conditioners}
(\pagref{EXTERNAL-CONDITIONER-EXPLANATION}).
\end{indpar}

An example is:
\begin{indpar}\begin{verbatim}
module "my module" as mymod
generic goo ( name N, name OP,
              character C, string S,
              int32 X, float64 Y, float64 Z,
              type T )
        [| external if T is external |]
    include ( N, OP, C, S, X, Y, Z, T ):
        define abbreviation n ---> `N'
        int64 N = 0
        character c = C
        string ..ma s = S
        int32 x = X
        float64 y = Y
        float64 z = Z
        T v = x OP y
        T w = x * z OP y

goo ( `my variable', `"+"', C"<LF>", "Hi There",
      1,234, 1.5, 0.3, float64 )
    // Equivalent to:
    //    define abbreviation n ---> `my variable'
    //    int64 my variable = 0
    //    character c = C"<LF>"
    //    string mymod s = "Hi There"
    //    int32 x = 1,234
    //    float64 y = 1.5
    //    float64 z = X"0.4CCCCCCCCCCCCC"
    //    std float64 v = x "+" y
    //    std float64 w = x "*" ( z "+" y )
\end{verbatim}\end{indpar}

The {\em generic-declaration} is parsed when first encountered
by the compiler, but the included statements are not
compiled.
This means that operators in unparsed form cannot be substituted
in included statements.  So the computation of {\tt w} in the
example substitutes in the parsed expression `{\tt (x) "*" (z OP y)}'
where {\tt OP} has not been identified as an operator by the parser.

Also note that substitution inside name constant brackets such as
\TT{`'} is allowed.

The word `\key{..ma}' is treated as a module abbreviation by the
parser.\label{EXTERNAL-CONDITIONER-EXPLANATION}
If no `\ttkey{external}' {\em generic-conditioner} is present, or
if this is a compilation of a body file, `\TT{..ma}'
is deleted (replaced by an empty lexeme sequence).
If an `\TT{external}' {\em generic-conditioner} is present and a module
is being compiled, `\TT{..ma}'
is replaced by the abbreviation of the module.
If the {\em generic-conditioner} has the form `\TT{external if $e$}',
the expression $e$ is evaluated at the beginning of the evaluation of
the generic, and if \TT{true}, the effect is as if just `\TT{external}'
were the conditioner, but if \TT{false}, the effect is as if there
was no conditioner.

The `\TT{if }{\em logical-expression}' option
causes the {\em statements} to be included if and only if the
{\em logical-expression} evaluates to \TT{true}.  An example use is:
\begin{indpar}\begin{verbatim}
generic min-max ( type T, name F, name C )
    include ( T, F, C ):
        function T result = F ( T x, T y ):
            include if not T is float:
                result = if:
                    (x) C (y):
                        result = x
                    (y) C (x):
                        result = y
                    else:
                        program stop
            include if T is float:
                result = if:
                    (x) C (y):
                        result = x
                    (y) C (x):
                        result = y
                    else:
                        result = NaN
\end{verbatim}\end{indpar}

Only whole {\em statements} can be included, but {\em include-statements}
can be nested.  A nested {\em include-if-statement} does not have an
{\em include-argument-list} but instead inherits the {\em include-arguments}
of its containing {\em include-statement}.  The values of include arguments,
{\em logical-expressions}, and {\em list-expressions} in a set of
nested {\em include-statements} are computed at compile-time
just before the outermost of the {\em include-statements}.
No substitutions are made in {\em logical-expressions} or {\em list-expressions}
before they are evaluated.  Thus in the example, `{\tt not T is float}'
is evaluate as is, without any substitution for {\tt T},
just before `{\tt include ( T, F, C )}'.

The {\em include-for-statement} introduces a new {\em include-argument-name}
and assigns to it values from the list produced by a {\em list-expression}.
The {\em statements} in its subblock are included once for each value
from the list.  The {\em include-argument-name} introduced after the
`\TT{for}' is \underline{not} included in the {\em include-argument-list}
of the statement.  An example is:
\begin{indpar}\begin{verbatim}
generic min-max functions ( name F, name C ):
    include (F, C ) for T in [uns32, int32, uns64, int64]:
        min-max function ( T, F, C )
min-max function ( `max', `"=>"' )
    // Equivalent to:
    //
    // min-max function ( uns32, `max', `"=>"' )
    // min-max function ( int32, `max', `"=>"' )
    // min-max function ( uns64, `max', `"=>"' )
    // min-max function ( int64, `max', `"=>"' )
\end{verbatim}\end{indpar}

If an {\em include-statement} $S$ has an {\em include-name} $N$, then
{\em include-statements} nested inside $S$ that do \underline{not}
have the {\em include-name} $N$ are treated as ordinary statements
and not as nested {\em include-statements}.  An example is:
\begin{indpar}\begin{verbatim}
generic min-max functions ( type T ):
    include X ( T ):
        generic min-max function ( name F, name C ):
            include ( F, C ):
                function T r = F ( T x, T y ):
                    include X if T is float:
                        if:
                            x C y:
                                r = x
                            y C x:
                                r = y
                            else:
                                r = NaN
                    include X if not T is float:
                        if:
                            x C y:
                                r = x
                            y C x:
                                r = y
                            else:
                                program stop
        min-max function ( `min', `"<="' )
        min-max function ( `max', `"=>"' )
min-max functions ( uns32 )
    // Equivalent to:
    //
    // generic min-max function ( name F, name C )
    //     include ( F, C ):
    //         function std uns32 r =
    //                 F ( std uns32 x, std uns32 y ):
    //             if:
    //                 x C y:
    //                     r = x
    //                 y C x:
    //                     r = y
    //                 else:
    //                     program stop
    // min-max function ( `min', `"<="' )
    // min-max function ( `max', `"=>"' )
\end{verbatim}\end{indpar}

{\em Include-statements} without {\em include-names} are treated
as if they all had the same {\em include-name} that is different
from every other {\em include-name}.

The included statements that replace a generic call are compiled in the
current context, and \underline{not} the context of the
generic declaration.  The statements of the generic function
itself, and any default values in the generic prototype,
are compiled in the context of the generic declaration,
just as for an inline function.

If you want code compiled in another
context (\pagref{CONTEXT}), wrap that code in the body of an inline function
declared in that other context.  An example that implements a writable
parameter is:
\begin{indpar}\begin{verbatim}
module "my_module" as mymod
*UNCHECKED* adr p = allocate to static ( float64 ( 0 ) )
// Parameter is float64 stored at address p
// P is not visible in other modules.

// function to allow reading of parameter
// by other modules.  Usage is:
//
//    float64 v = mymod my parameter
//
function *READ* float64 r, adr r.adr = mymod my parameter:
    r.adr = p
\end{verbatim}\end{indpar}

As an additional feature of generics, whenever the word
`\TT{G\TMP*}' appears in the included code, it is replaced
by `\TT{G\TMP$n$}', where $n$ is a natural number unique
to the generic call within the compilation.  This allows
creation of names unique to the generic call.  Note that
`\TT{G\TMP*}' can be part of a name, and not the entire name,
so its replacement is not like the replacement of abbreviations.

The \TT{generate name} function (\pagref{GENERATE-NAME})
may be used to generate other names which can be substituted
for include arguments.

\section{Clusters}
\label{CLUSTERS}

A \key{cluster} is a group of related variables.  One variable of
the cluster is the \mkey{base variable}{of cluster} of the cluster, and the
other variables have names that are derived from the
name of the base variable by adding {\em member-selectors}
to the end of the base variable name.  See \pagref{NAMES}.

Thus a cluster
is like a C/C++ structure, but it is a set of variables and not a
block of RAM memory.

More specifically, the members of the cluster can be named by
adding either a member name beginning with a `\TT{.}' or a
`\TT{[]}' bracketed list of
integer indices to
either the base variable name of the cluster or to another member name
of the cluster.  Two variable names with different base variable names
belong to different clusters.  The indices must be compile time
constants when the member is allocated, but may be expression
run time values when the member is written or read.

Variables in clusters are thus organized into trees, with clusters
that have different bases being in disjoint trees.  Any variable in a cluster
can be considered
as the \mkey{root}{of subcluster} of a subtree of cluster members, and
the subtree is called a \key{subcluster}.

The main feature of clusters and subclusters
is that members are passed to or returned
from functions implicitly when their the root variable is named
explicitly.  Furthermore, non-root cluster members \underline{cannot}
be created except as implied results of function calls.

More specifically, non-root cluster members \underline{cannot}
be created or updated (via `\TT{next}')
by using them as result variable names in an
{\em assignment-statement}.  They can only be created or updated
when their root is given as an actual result or actual argument
to an inline function call, and the prototype of the function
specifies that the non-root cluster members should be implicitly created
or updated.

For example:
\begin{indpar}\begin{verbatim}
// The module has an exported parsing block containing:
//
//     define prefix "reference-prefix" operator "*"
//     define postfix "reference-postfix" operator "++"

define type pointer pair as void
    // if pp is a pointer pair then:
    //   unsadr pp.begin is the offset of the first element
    //   unsadr pp.end is the offset just AFTER the
    //                 last element
    //   *READ* adr pp.base is the base address that
    //                      is added to the offsets
    //   adr pp.base.adr is the address of pp.base
    //   type pp.type is type of elements pointed at

// Function to allocate a vector of n T's to the stack.
//
function *STACK* *WRITE* pointer pair pp,
         unsadr pp.begin,
         unsadr pp.end,
         *READ* adr pp.base,
         adr pp.base.adr,
         type pp.type =
      allocate to stack ( type T, uns32 n ):
    require ( zero value OK for T )
    require ( size of T mod alignment of T == 0 )
    pp.type = T
    unsadr size = size of ( T ) * n
    *UNCHECKED* void p = allocate to stack ( size )
        // p gets implied qualifiers *STACK* and *WRITE*
        // but these are is not implicitly propagated to pp.
        // The fact that p is *UNCHECKED* indicates that it
        // is the responsibility of the inline function
        // to attach *STACK* to pp.
    pp.base.adr = p.base.adr
    pp.begin = p.offset
    pp.end = pp.begin + size

// Assignment operator for pointer pairs.
//
function Qs pointer pair pp2,
         unsadr pp2.begin,
         unsadr pp2.end,
         *READ* adr pp2.base,
         adr pp2.base.adr,
         type pp2.type

       = assign (| qualifiers Qs |)
                (  Qs pointer pair pp,
                   type pp.type,
                   unsadr pp.begin,
                   unsadr pp.end,
                   adr pp.base.adr ):

    pp2.begin = pp.begin
    pp2.end = pp.end
    pp2.base.adr = pp.base.adr
    pp2.type = pp.type

// Operator to dereference a point returning the value
// pointed at.
//
function *READ* WQ pp.type out,
         unsadr out.offset,
         *READ* adr out.base,
         adr out.base.adr =

      "*" (| qualifiers Qs |)
          ( Qs pointer pair pp,
            type pp.type,
            unsadr pp.begin,
            unsadr pp.end,
            adr pp.base.adr )
      [| qualifiers WQ = Qs * { *WRITE* } |]
    if:
        pp.begin < pp.end:
            out.offset   = pp.begin
            out.base.adr = pp.base.adr
        else:
            fatal error
                ( "Dereferencing empty pointer pair." )

// Postfix operator to increment the begin pointer of a
// pointer pair while returning the original pointer
// pair.
//
function Qs pointer pair pp2,
         unsadr pp2.begin,
         unsadr pp2.end,
         *READ* adr pp2.base,
         adr pp2.base.adr,
         type pp2.type,
         next pp.begin

       = (| qualifiers Qs |)
         (  Qs pointer pair pp,
            type pp.type,
            unsadr pp.begin,
            unsadr pp.end,
            adr pp.base.adr )
         "++":

    pp2.begin = pp.begin
    pp2.end = pp.end
    pp2.base.adr = pp.base.adr
    pp2.type = pp.type

    unsadr r = pp.begin + size of ( pp.type )
    if:
        r < pp.begin:
            fatal error ( "Pointer pair adr overflow." )
            // adr address arithmetic overflow
        else:
            next pp.begin = r

// Example usage:
//
function ...:

    // Vector of 2 int32's is allocated and the elements
    // are set equal to 100 and 101.
    //
    pointer pair pp = allocate to stack ( int32, 2 )
    * pp ++ = 100
    * pp ++ = 101
    . . . .
    // Vector of 1000 float64's is summed.
    //
    pointer pair ppf = allocate to stack ( float64, 1000 )
    ... set 1000 elements ...
    float64 sum = loop:
        initially:
            float64 partial sum = 0
            pointer pair ppf2 = ppf
        while ppf2.begin < ppf2.end:
            next partial sum = partial sum + * ppf2 ++
        finally:
            sum = partial sum
\end{verbatim}\end{indpar}\label{NEXT-CLUSTER-BASE-EXAMPLE}

Note that although the functions defining operations on a pointer pairs
are a long winded, usage of pointer pairs is compact and easy.
This is a general characteristic of the L-Language, and derives
from the fact that the functions automatically manage the members
of a cluster.

In this example \TT{*READ*}\label{READ} is a special builtin variable qualifier.
Its special property is if a variable
{\tt v} of qualifier \TT{*READ*} is allocated,
and if a cluster members  {\tt v.base} of type \TT{adr}
and {\tt v.offset} of type \TT{unsadr}
are allocated and assigned values, then
the cluster root {\tt v} is automatically
assigned the value read from the RAM address {\tt v.base + v.offset}.
It is an error in this case to explicitly assign a value to {\tt v}.
This is how {\tt out} gets its value from
{\tt out.base}, and {\tt out.offset} in the {\tt "*"} prototype.

Similarly if {\tt v} and {\tt v.adr} are allocated, {\tt v} has qualifier
\TT{*READ*}, and {\tt v.adr} is assigned a value, then
the cluster root {\tt v} is automatically
assigned the value read from the RAM address {\tt v.adr}.
This is how {\tt out.base} gets its value from
{\tt out.base.adr} in the {\tt "*"} prototype, and
how {\tt pp.base} gets its value from
{\tt pp.base.adr} in the {\tt allocate to stack} prototype.

If a variable {\tt v} has both the \TT{*READ*} and \TT{*WRITE*}
qualifiers, you can assign a value to `\TT{next} {\tt v }' to write
the RAM location that {\tt v} caches.

For details on the \TT{*READ*} and \TT{*WRITE*} qualifiers
see \itemref{THE-READ-AND-WRITE-QUALIFIERS}.

The \TT{*STACK*} value qualifier in the example has the special property
that values with
this qualifier may not be passed out of a block with a free
stack.  This keeps stack addresses from escaping contexts in
which they are valid.  See Sections~\itemref{THE-STACK-QUALIFIER} and
\itemref{STACKS}.

Other examples of the use of clusters are the implementation of
\TT{if/else} expressions (\pagref{IF-ELSE-IMPLEMENTATION})
and \TT{</<=/==/!=/=>/>} expressions (\pagref{COMPARE-IMPLEMENTATION}).

The actual arguments and result variables of a function call are
matched to corresponding prototype arguments and result variables in
a function prototype, but when these are cluster members that are
not cluster roots, the matching process is modified.

When a cluster member name $v.m$ is used as prototype argument name,
the root $v$ of the member name must also be a prototype argument name.
An actual call argument $w$ must correspond to the prototype root $v$, but
\underline{no actual} argument may correspond to the prototype member $v.m$.
Instead, the cluster member $w.m$ of the actual root argument is implicitly
matched to the prototype member $v.m$.  If $w.m$ does not exist,
the call-prototype match fails unless the prototype $v.m$ has a
default value (see rule \ref{CLUSTER-MEMBER-ARGUMENTS},
\pagref{CLUSTER-MEMBER-ARGUMENTS} ).

Here $v$ denotes a variable name without any {\em member-selectors},
and $.m$ denotes any sequence of {\em member-selectors}, including possibly
{\em member-subscripts}.

When a cluster member name $v.m$ is used as prototype result name in
a {\em prototype-result-variable-declaration} that is \underline{not}
of the form `{\tt next $v.m$}',
the root $v$ of the member name must also be either a prototype result name
or a prototype argument name.
An actual call argument or result variable
$w$ must correspond to the prototype root $v$, but
\underline{no actual} result variable
may correspond to the prototype member $v.m$.
Instead, the cluster member $w.m$ of the actual root is implicitly
matched to the prototype member $v.m$.  This implies that $w.m$ is
created by the call and must
not pre-exist the call.  If it does pre-exist, the call-prototype match fails.

When a cluster member name $v.m$ is used as prototype result name in
a {\em prototype-result-variable-declaration} that \underline{is}
of the form `{\tt next $v.m$}', the cluster member name $v.m$ itself
must be a prototype argument name.  This implies that $v$ must also
be a prototype argument name with a matching actual argument $w$.
Either $w.m$ must pre-exist the call, or if $v.m$ has a default
value, then $w.m$ will be created with the default value before
the call is made.  The call will create a new variable of the
same name $w.m$ to supersede the pre-call $w.m$.
If $w.m$ does not pre-exist the call the $v.m$ has no default
value, the call-prototype match fails.

The following is an example:
\begin{indpar}\begin{verbatim}
function bool v.nonneg = test sign ( int32 v ):
    if:
        v => 0:
            v.nonneg = true
        else:
            v.nonneg = false

function test sign ( int32 v, bool v.nonneg ):
    // Do nothing

int32 x = 89
int32 y = -5
test sign ( x )    // Creates x.nonneg = true
test sign ( y )    // Creates y.nonneg = false
test sign ( x )    // Does nothing
\end{verbatim}\end{indpar}

A variable whose underlying type is \TT{void} has no actual value
and must not be assigned one.  Such variables are only useful
as cluster and subcluster roots.  The `\TT{allocate to stack}'
function requires that its result be a variable whose underlying
type is \TT{void} (see \pagref{ALLOCATE-TO-STACK}).

A cluster member may be used as an actual argument if
the corresponding prototype argument is
\underline{not} a cluster member.  A cluster member may \underline{not}
be used as an actual result.

Importantly, cluster members may only be created or updated
(via `\TT{next}')
as inline function call results.  Thus if
the inline functions are written correctly, the program will be type-safe.

Implementation of clusters depends upon special rules for 
result direct assignments.  See \pagref{RESULT-DIRECT-ASSIGNMENT}.

\section{Memory Organization}
\label{MEMORY-ORGANIZATION}

Memory is organized into two parts: \key{static} and \key{dynamic}.
Static memory variables are allocated at fixed addresses
that never change.  Dynamic memory contains blocks that
can be moved.  An implementation may choose not to implement dynamic
memory.

Static addresses consist of a single \TT{adr} value.

Dynamic blocks can be moved when they are expanded or when dynamic
memory needs to be reorganized because, for example, other dynamic
blocks are being are allocated or expanded.  As a consequence,
each dynamic block is associate with a pointer stored in static
memory that points at the beginning of the dynamic block.  This
pointer is called a \key{body pointer} and is located
in a static storage datum called a \key{stub}.
The dynamic block is called
a \key{body} of the stub.  A stub can have more than one body.

A pointer to a location in the body of a stub is called
a \key{dynamic pointer}\label{DYNAMIC-POINTER}.  A dynamic pointer
consists of an \TT{adr} value
pointing to the body pointer and an \TT{unsadr} or \TT{intadr}
value that is the offset of the location within the body.
Instead of an \TT{adr} value pointing at the body pointer, a pair consisting
of an \TT{adr} value pointing at the stub and an \TT{intadr} value
that is the offset of the body pointer in the stub may be used (the
offset may be negative).  However,
this offset is usually a constant, as is the stub address,
so adding the stub address and the
body pointer within stub offset together to get a single constant
address pointing directly at the body pointer is the norm.

Builtin function prototypes are defined to allocate static and dynamic memory
and deallocate dynamic memory.  These functions are actually provided
by the runtime system, and may be defined in different ways to support
different memory allocation/deallocation features.

This document assumes\label{DYNAMIC-STACKS-AND-GLOBAL-AREAS}
that stacks and global areas are allocated as dynamic blocks,
but an implementation
may choose to implement stacks and global areas in static memory and use
function prototypes different from those described in this document
for allocating memory to a stack or global area.

\subsection{Memory Regions}
\label{MEMORY-REGIONS}

Both static and dynamic data blocks are allocated to \skey{region}s.
This permits operations such as garbage collecting all blocks in a
region, compacting a dynamic region by moving blocks in it to eliminate
gaps between blocks, and requiring that a static region have limited size
so that data in it can be addressed using a limited size offset.

Regions are identified by \TT{memory region} values:
\begin{indpar}\tt
define type \ttstdkey{memory region}~as \ldots \\
define abbreviation \ttkey{memory region} \ABV{} `std memory region' \\
memory region \ttstdkey{default static region} = \ldots \\
memory region \ttstdkey{default dynamic region} = \ldots \\
memory region \ttstdkey{default stack region} = \ldots
\end{indpar}

Regions may be created by the run-time system using an interface that
is not specified by the L-Language.  However the run-time system must
provide the static and stack default memory regions defined above, and
also the dynamic default region if dynamic memory is implemented.
These default regions are used if no other regions are created.

\subsection{Static Memory}
\label{STATIC-MEMORY}

Static memory variables are allocated at fixed addresses
that never change.
Static addresses consist of a single \TT{adr} value.


The following function allocates static memory and computes static addresses.


\begin{indpar}

{\tt function adr r, unsadr s = \\
\hspace*{1in}\begin{tabular}[t]{@{}l@{}}
	     \ttstdkey{allocate to static} \\
	     ~~~~( unsadr size, \\
	     ~~~~~~unswrd alignment ?=~0, \\
	     ~~~~~~memory region r ?= \\
	     ~~~~~~~~~~std default static R ) \\
	     \end{tabular}}

\begin{indpar}
Allocate a {\tt size} byte block of static memory with the given
{\tt alignment} in bytes to static region {\tt R}.
Return
the address of this memory.  The address viewed as an
integer is an exact multiple of the {\tt alignment}.

If there is insufficient memory
in the region to allocate the desired memory,
this function returns \TT{ERROR(INSUFFICIENT MEMORY)} and sets
{\tt s} to the maximum {\tt size} argument value that
would have succeeded.  Otherwise {\tt s} is set to the value
of the {\tt size} argument.

If the {\tt alignment} is omitted or is given as \TT{0} it is taken
to be equal to \TT{size}.  The explicit or implied
alignment must be a power of two not greater than alignment of the
region (usually the page size for static regions).  If the {\tt alignment}
does not meet these criteria, \TT{ERROR(BAD ALIGNMENT)} is returned
and {\tt s} is set to the largest legal alignment for the region.

On success {\tt s} is set to the {\tt size} argument.

Any memory allocated is initialized to zero.
\end{indpar}

\end{indpar}

A vector whose elements are of some type $T$ can be allocated by
the pointer version of `\TT{allocate to static}': see
\pagref{POINTER-ALLOCATE-TO-STATIC}.  A vector containing a copy
of a compile-time \TT{string} value can be allocated by
`\TT{allocate UTF-8 to static}': see
\pagref{POINTER-ALLOCATE-UTF-8-TO-STATIC}.

The following functions can be used to embed static addresses or offsets
in static tables into
floating point NaNs or other numeric values.

\begin{indpar}

{\tt function adr r =} \\
{\TS~~~~~~~~~\ttstdkey{extract adr}\label{EXTRACT-ADR}} \\
{\TS~~~~~~~~~~~~~ ( uns64 v,} \\
{\TS~~~~~~~~~~~~~~~ unswrd L, unswrd S ?= 0 )}

\begin{indpar}
{\tt L} and {\tt S} must be compile time values.

Take the low order {\tt L} bits of {\tt v}, shift them left by {\tt S},
and return the result as a usable byte address.
If the target machine only uses the low order $k$ bits of a 64-bit
address, the high order $64-k$ bits of the result are set according
to the requirements of the target machine, or are undefined if there
are no such requirements.  If $k>${\tt L+S},
the {\tt L} bits are padded on the left with zero bits.

For example, for an INTEL 64 target machine $k=48$ and the high order
17 bits of the returned address must be equal (all 0's or all 1's).
If {\tt L = 40} and {\tt S = 4} then 64-40-4=20 zero bits of padding are
added on the left.  If {\tt L = 44} and {\tt S = 4}, the high order
bit of the low {\tt L} bits of {\tt v} is sign extended to become
the high order 17 bits of the returned address.
\end{indpar}

{\tt function *UNCHECKED* uns64 r =} \\
{\TS~~~~~~~~~\ttstdkey{embed adr}\label{EMBED-ADR}} \\
{\TS~~~~~~~~~~~~~ ( uns64 template, adr address,} \\
{\TS~~~~~~~~~~~~~~~ unswrd L, unswrd S ?= 0 )}

\begin{indpar}
{\tt L} and {\tt S} must be compile time values.

Make a 64-bit value containing the address in the low order
{\tt L} bits, such that if the low order {\tt S} bits of {\tt A}
are zero and either $k\leq${\tt L+S} or the high order $k-${\tt L+S} bits
of {\tt A} are zero, then
\begin{center}
\tt extract adr ( embed adr ( T, A, L, S ), L, S )
\end{center}
addresses the same location as {\tt A}.
The high order {\tt 64-L} bits of the value returned
by {\tt embed adr} are copied from the high order {\tt 64-L} bits
of the {\tt template}.
\end{indpar}

{\tt function unsadr r =} \\
{\TS~~~~~~~~~\ttstdkey{extract offset}\label{EXTRACT-OFFSET}} \\
{\TS~~~~~~~~~~~~~ ( uns64 v,} \\
{\TS~~~~~~~~~~~~~~~ unswrd L, unswrd S ?= 0 )}

\begin{indpar}
{\tt L} and {\tt S} must be compile time values.

Take the low order {\tt L} bits of {\tt v}, shift them left by {\tt S},
and return the result as an unsigned integer.  If \TT{unsadr} has
$k$ bits, the integer is truncated if $k<${\tt L+S} and padded on
the left with zero bits if $k>${\tt L+S}.

\end{indpar}

{\tt function uns64 r =} \\
{\TS~~~~~~~~~\ttstdkey{embed offset}\label{EMBED-OFFSET}} \\
{\TS~~~~~~~~~~~~~ ( uns64 template, unsadr offset,} \\
{\TS~~~~~~~~~~~~~~~ unswrd L, unswrd S ?= 0 )}

\begin{indpar}
{\tt L} and {\tt S} must be compile time values.

Make a 64-bit value containing {\tt offset} in the low order
{\tt L} bits, such that
\begin{center}
\tt extract offset ( embed offset ( T, O, L, S ), L, S ) == O
\end{center}
provided the low order {\tt S} bits of {\tt O} are zero and all of
the non-zero bits of {\tt O} are within the low order {\tt L+S} bits
of {\tt O}.  The high order {\tt 64-L} bits of the value returned
by {\tt embed offset} are copied from the high order {\tt 64-L} bits
of the {\tt template}.
\end{indpar}

\end{indpar}


\subsection{Dynamic Memory}
\label{DYNAMIC-MEMORY}

A \key{dynamic block} is a memory block that may be moved.  Each
dynamic block has an associated \key{body pointer} in static
memory that always points at the beginning of the dynamic block.
The block in turn points back at the
body pointer, so when the block is moved the body pointer can be
updated.  This back-pointer is provided by the run-time
system and is not visible to non-system code.

The addresses of body pointers (and not the body pointer themselves)
have the type:
\begin{indpar}\tt
define type \ttstdkey{body pointer address}~as adr \\
define abbreviation \ttkey{body pointer address} \ABV{} \\
\TS~~~~~~~~~~~~~~~~~~~~`std body pointer address'
\end{indpar}

Body pointers must be allocated to static memory, and are typically
elements in larger static memory data structures called \skey{stub}s.
Upon being so allocated, body pointers should be given the initial
value \TT{NULL}.  Body pointer addresses must be
created by unchecked code.

The following functions allocate and deallocate dynamic memory blocks.

\begin{indpar}

{\tt function adr r, unsadr s = \\
\hspace*{1in}\begin{tabular}[t]{@{}l@{}}
	     \ttstdlkey{allocate}{to dynamic} \\
	     ~~~~( body pointer address A, \\
	     ~~~~~~unsadr size, \\
	     ~~~~~~unswrd alignment ?=~0, \\
	     ~~~~~~memory region R ?= \\
	     ~~~~~~~~~~std default dynamic region ) \\
	     \end{tabular}}

\begin{indpar}
Allocate a {\tt size} byte block of dynamic memory with the given
{\tt alignment} in bytes.  Store the
the address of this memory in the body pointer that is in the static
memory location whose address is given by {\tt A}.
The address stored, when viewed as an
integer, is an exact multiple of the {\tt alignment}.

Before calling this function the body pointer at address {\tt A}
\underline{must} be set to {\tt NULL}.  If the function does not succeed,
an error value will be returned in {\tt r} and the body pointer will be
left unchanged.

On success the address stored in the body pointer is returned in {\tt r} and
the {\tt size} argument is returned in {\tt s }.

If there is insufficient memory in the region to allocated the desired block,
\TT{ERROR(\EOL INSUFFICIENT MEMORY)} is returned in {\tt r} and
the maximum size that could be successfully allocated is returned in {\tt s}.

If the {\tt alignment} is omitted or is given as \TT{0} it is taken
to be equal to \TT{size}.  The explicit or implied
alignment must be a power of two not greater than the alignment of the
region (by default the page size for dynamic regions).  If the {\tt alignment}
does not meet these criteria,
\TT{ERROR(BAD ALIGNMENT)} is returned in {\tt r}
and the largest legal alignment for the region is returned in {\tt s}.

Any memory allocated is initialized to zero.

The `\TT{allocate to dynamic}' inline function may move dynamic blocks
(even if it fails due to insufficient memory).
Therefore it ends by executing a
\begin{center}
{\tt reload *READ*, *READ* dependent}
\end{center}
statement.

\end{indpar}

{\tt function \TT{std *UNCHECKED* deallocate dynamic block}%
	      \index{deallocate@{\tt *UNCHECKED* deallocate}!%
	             dynamic block@{\tt dynamic block}} \\
\TS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~( body pointer address A )}

\begin{indpar}
Deallocate the dynamic block pointed at by the body pointer,
and set the body pointer to \TT{NULL}.  If
the body pointer is already \TT{NULL}, do nothing.
\end{indpar}

\end{indpar}

A vector whose elements are of some type $T$ can be allocated by
the pointer version of `\TT{allocate to dynamic}': see
\pagref{POINTER-ALLOCATE-TO-DYNAMIC}.

The following function allocates to the end of an \underline{existing}
dynamic block:

\begin{indpar}

{\tt function unsadr r, unsadr s = \\
\hspace*{1in}\begin{tabular}[t]{@{}l@{}}
	     \ttstdlkey{allocate}{to dynamic block}%
		 \label{ALLOCATE-TO-DYNAMIC-BLOCK} \\
	     ~~~~( body pointer address A, \\
	     ~~~~~~unsadr size, \\
	     ~~~~~~unswrd alignment ?=~0, \\
	     ~~~~~~memory region R ?= \\
	     ~~~~~~~~~~std default dynamic region ) \\
	     \end{tabular}}

\begin{indpar}
Add a {\tt size} byte block of to the end of the
dynamic block whose body pointer
is located at address {\tt A}.  The offset of the block is returned.
This offset is a multiple of the the given {\tt alignment} in bytes.
If necessary padding is added to the dynamic block before the
newly allocated memory to ensure the offset is a multiple of the
{\tt alignment}, and if necessary the dynamic block is moved so that
its body pointer is a multiple of the alignment.

If the dynamic block has not been allocated before this call
(i.e., its body pointer is \TT{NULL}),
it is allocated first.  Only in this case is the region argument {\tt R}
used.

On success the offset of the allocated memory in the dynamic block
is returned in {\tt r} and
the {\tt size} argument is returned in {\tt s }.

If there is insufficient memory,
\TT{ERROR(\EOL INSUFFICIENT MEMORY)} is returned in {\tt r} and
the maximum size that could be successfully allocated is returned in {\tt s}.

If the {\tt alignment} is omitted or is given as \TT{0} it is taken
to be equal to \TT{size}.  The explicit or implied
alignment must be a power of two not greater than the alignment of the
block being expanded (or if the block is being newly allocated, the
alignment of the region).  If the {\tt alignment}
does not meet these criteria,
\TT{ERROR(BAD ALIGNMENT)} is returned in {\tt r}
and the largest legal alignment is returned in {\tt s}.

Any memory allocated is initialized to zero.

The `\TT{allocate to dynamic block}' inline function may move dynamic blocks
(even if it fails due to insufficient memory).
Therefore it ends by executing a
\begin{center}
{\tt reload *READ*, *READ* dependent}
\end{center}
statement.

\end{indpar}

\end{indpar}

A vector whose elements are of some type $T$ can be allocated by
the pointer version of `\TT{allocate to dynamic block}': see
\pagref{POINTER-ALLOCATE-TO-DYNAMIC-BLOCK}.

The following function returns that static address of a body
pointer that points to all of static memory:

\begin{indpar}

{\tt function body pointer address r =
    \ttstdkey{STATIC BASE}}\label{STATIC BASE}\label{STATIC-BASE}

\begin{indpar}
Returns the address of a static memory location that contains an
\TT{adr} value equal to zero (note the value returned is not itself zero).
{\tt STATIC BASE} may be thought of as a body pointer to static memory,
treating static memory as if it were a dynamic block (that never moves).

This may be used to construct a dynamic pointer to a static
memory location.  The static address of the location becomes the
offset of the dynamic pointer.
\end{indpar}

\end{indpar}

\subsection{Stacks}
\label{STACKS}

Each execution thread has a stack that is not in any other
stack.  Each out-of-line function
execution is a block execution that has a stack which is
by default a substack of the thread in which the function
execution is running.  Each subblock in turn has a stack
which is by default a substack of the stack of its containing block.
And each global area has a stack that is not in any other stack.

Conceptually, the assignment statements in a block each allocate memory for
their result variables to the stack of their smallest containing
block, and copy values to these
variables.  As noted above (Section~\itemref{ASSIGNMENT-STATEMENTS}),
the memory and associated copies may be
optimized away in some cases.

Stacks are either free or bound.\label{FREE-STACK}
A bound stack is a substack that is
not deallocated from memory until its smallest containing free stack is
deallocated.  The main reason this is important is that stack addresses
(produced by the `\TT{allocate to stack}' function:
\pagref{ALLOCATE-TO-STACK})
can be passed out of a block with a bound stack to its containing block,
but cannot be passed out of a block with a free stack to its containing
or calling block.  This is implemented by giving certain
values containing stack addresses the \TT{*STACK*} qualifier: see
Section~\itemref{THE-STACK-QUALIFIER}.

Stacks of out-of-line function executions
(\pagref{OUT-OF-LINE-FUNCTIONS}),
out-of-line assignment statement blocks
(\pagref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}),
and
compile-time assignment statement blocks
(\pagref{COMPILE-TIME-ASSIGNMENT-STATEMENTS})
are free, and variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
may \underline{not} have the \TT{*STACK*} qualifier.

Global area stacks (see Section~\itemref{GLOBAL-AREAS}) are free,
but are never deallocated, so the
`\TT{allocate to global}' function makes no use of the \TT{*STACK*}
qualifier.

All other stacks are bound.  Memory allocated to them
by the `\TT{allocate to stack}' function (\pagref{ALLOCATE-TO-STACK})
is actually
allocated to their smallest containing free stack, and not deallocated
until that free stack is deallocated.

If you call `\TT{allocate to stack}' in loop iterations, the memory
allocated will not be freed until after the loop terminates, as the
iteration subblock stack is bound, as are the
`\TT{initially}' and `\TT{finally}' subblock stacks.

Thread stacks and global area stacks are dynamic blocks that can be moved
(\pagref{DYNAMIC-STACKS-AND-GLOBAL-AREAS}),
and all other stacks are allocated within these.  Thus all stacks are
within a dynamic block.  Stacks cannot move independently, but move
only when their dynamic block moves.  Stack addresses are dynamic
pointers (\pagref{DYNAMIC-POINTER})
containing an offset within the stack's dynamic block.

In a program being debugged, free stacks may be saved when they are
deallocated, in order to permit them to be analyzed
by a debugger if the program detects an error.

The following function is used to allocate memory to the
current stack:

\begin{indpar}

{\tt function \begin{tabular}[t]{@{}l@{}}
              *STACK* T r, \\
	      unsadr r.offset, \\
	      adr r.base.adr, \\
	      unsadr s = \\
	      \end{tabular} \\
\TS~~~~\begin{tabular}[t]{@{}l@{}}
       \ttstdkey{allocate to stack} \label{ALLOCATE-TO-STACK} \\
       ~~~~(| type T |) \\
       ~~~~( unsadr size, \\
       ~~~~~~unswrd alignment ?=~0 ) \\
\TS~~~~[|( underlying type of T ) == void |] \\
       \end{tabular}}

\begin{indpar}
Allocate a {\tt size} byte block to the current stack with the given
{\tt alignment} in bytes.

Return the offset of the block within the current stack's dynamic
block as {\tt r.offset},
and the address of the dynamic block's body pointer as {\tt r.base.adr}.

If there is not enough memory,
{\tt p.base.adr} is set to \TT{ERROR(\EOL IN\-SUF\-FI\-CIENT MEMORY)}
and {\tt p.base.begin} is set to the largest {\tt size}
that could be allocated.  Dynamic bodies may be moved if the function
call has this error.


If the {\tt alignment} is omitted or is given as \TT{0} it is taken
to be equal to \TT{size}.  The explicit or implied
alignment must be a power of two not greater than the alignment
of the dynamic block containing the stack (which is typically
\TT{64} or greater).  If the alignment does not met these criteria,
{\tt p.base.adr} is set to \TT{ERROR(BAD ALIGNMENT)}
and {\tt p.base\EOL .begin} is set to the largest alignment
that would be allowed.

Any allocated memory is initialized to zero.

The `\TT{allocate to stack}' inline function may move dynamic blocks.
Therefore it ends by executing a
\begin{center}
{\tt reload *READ*, *READ* dependent}
\end{center}
statement.

The returned cluster has
the \TT{*STACK*} qualifier (see \itemref{THE-STACK-QUALIFIER}),
so that {\tt r.offset} and {\tt r.base.adr} cannot be
stored by unchecked code in places whose lifetime exceeds that of the current
free stack.

The memory is freed when the free stack to which it is allocated
is freed (\itemref{STACKS}).

\end{indpar}

\end{indpar}

A vector whose elements are of some type $T$ can be allocated by
the pointer version of `\TT{allocate to stack}': see
\pagref{POINTER-ALLOCATE-TO-STACK}.


\subsection{Unwind Blocks}
\label{UNWIND-BLOCKS}

\ikey{Unwind blocks}{unwind block} are executed only when their
containing block terminates:

\begin{indpar}
\emkey{unwind-block}
    ::= \begin{tabular}[t]{l}
	\ttakey{UNWIND}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

Specifically, when an unwind block is encountered while
executing its containing block, the unwind block is marked
as enabled, but is skipped.  Then when the containing block
terminates, all its enabled unwind blocks are executed in
the reverse order of that in which they were enabled.

An unwind block can use result variables of its containing block
if and only if these are assigned values before the unwind block
is enabled.

Unwind blocks are used to close or deallocate things that were opened.
For example, right after a statement that opens a file there may be
an unwind block that closes the file.  This ensures that the file
will be closed even if the block that opened it terminates later
prematurely with an error, such as a memory fault.

\subsection{Throw and Catch}
\label{THROW-AND-CATCH}

\TT{*THROW*} and \TT{*CATCH*} statements are used to implement
exceptions, i.e., abnormal termination.

\begin{indpar}
\emkey{throw-statement} ::= \TT{*THROW*} \\[1ex]
\emkey{catch-statement} ::= \TT{*CATCH*}
\end{indpar}

The \TT{*THROW*} statement causes its containing block to
\ikey{terminate abnormally}{abnormal termination}.
When a block terminates abnormally, its containing
block is also terminated abnormally.

\ikey{Normal termination}{normal termination}
of a block occurs at the end of the block if
the block has not executed a \TT{*THROW*} or an abnormally
terminating subblock.

Any enabled unwind subblocks of an abnormally terminating
block are executed in reverse order, just as they would be if
the block were terminating normally.  No other part of the block
is executed.

If an unwind subblock executing in an abnormally terminating
containing block \TT{B}
executes a \TT{*CATCH*} statement, the termination of this
containing block \TT{B}
is changed from abnormal to normal.  This means
that \TT{B}'s containing block \TT{C} will resume when the now
normally terminating block \TT{B} finishes terminating.
However, \TT{B} will not execute anything but enabled unwind
subblocks, as it is still terminating.

Machine errors, i.e. memory faults, invoke callable functions
which can record error information and execute a \TT{*THROW*}.
Similarly detected programming or data errors can record
error information and execute a \TT{*THROW*}.  An unwind
block can look at recorded error information and decide whether
or not to execute a \TT{*CATCH*}.

If a block has result variables it must assign, then these need not be
assigned if the block terminates abnormally, as they will not
be visible to enabled unwind blocks in the block containing
the abnormally terminating block.  However, if a block \TT{B}
that is terminating abnormally executes a \TT{*CATCH*} statement in
one of its unwind subblocks,
all result variables that block \TT{B} must assign must be given values, even
though part of block \TT{B} may not have executed.  The compiler
will check this, and will only permit code that passes straight forward
compiler checks.

There are two ways to ensure correct code.  The first is to 
set all block result variables either in or before the
unwind block that contains the \TT{*CATCH*} statement.
The second is to use the special variable
\ttakey{LAST-ENABLED-UNWIND} inside the unwind block.
This variable is \TT{true} if and only if the unwind
block is the last unwind block enabled in its containing
block, and so if the variable is \TT{true}, any containing
block result variables set after the unwind block need to be
set.  The compiler will accept a statement of the form:
\begin{indpar}\begin{verbatim}
if:
    *LAST-ENABLED-UNWIND*:
        result-variable-1 = ...
        result-variable-2 = ...
	. . . . . . . . . . . .
\end{verbatim}\end{indpar}
where the result variables set are those set after the unwind
block, thus satisfying the requirement that all result variables be set.

[TBD: Maybe default clauses should exist for all block style
assignment statements and execute at the beginning, setting
values for result variables that will be available outside
the block if the block does not set any values itself.]



\subsection{Global Areas}
\label{GLOBAL-AREAS}

A global area is a dynamic block called the \key{global stack}
of the area.  Global variables are allocated to global stacks by
{\em global-area-blocks} in a manner similar to the way
ordinary variables are allocated to non-global stacks.
Specifically, the result variables of a statement in a {\em global-area-block}
are allocated to the area's global stack instead of being allocated
to the current (non-global) stack.

Global areas are defined by {\em global-area-blocks}:

The syntax is:
\begin{indpar}
\emkey{global-area-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	{\em global-area-option}\STAR{}
	\TT{global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular} \\
\emkey{global-area-option} ::= \ttakey{COMPILE-AND-RUN-TIME}
                           $|$ \ttakey{COMPILE-TIME} \\
\emkey{global-area-name} ::= {\em module-abbreviation}\QMARK{}
			     {\em block-name}
\end{indpar}

The result variables in a statement whose smallest containing block
is a {\em global-area-block} are allocated to the global stack of
the global area named by the {\em global-area-block}, instead of
being allocated to the current stack.  The `{\tt allocate to global}'
function (\pagref{ALLOCATE-TO-GLOBAL}) can also be used to allocate
data to the global stack.  All other result variables are allocated
as normal to the current stack (which is not a global stack).

{\em Global-area-names} may or may not start with {\em module-abbreviations}
and follow the same export/import rules
as non-global {\em variable-names}.  The names of variables in a global
area do not follow the export/import rules of non-global variables, but
are effectively exported if and only if their {\em global-area-name} is.

In order to access a global area it must be named in an
{\em extern-statement}:
\begin{indpar}
\emkey{extern-statement} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	\TT{extern} {\em global-area-abbreviation}
	            \TT{is global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em extern-variable-statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{extern-variable-statement} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name}
          {\em global-variable-name} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name}
          {\em extern-variable-name} \TT{is}
          {\em global-variable-name} \\
    \end{tabular}
\\[1ex]
\emkey{extern-variable-name} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
    ::= & {\em global-area-abbreviation}\TT{.}{\em global-variable-name} \\
    $|$ & {\em extern-variable-name} as defined in an
          {\em extern-variable-statement} \\
    \end{tabular}
\end{indpar}

A variable with {\em global-variable-name}
\TT{V} in a global area with {\em global-area-abbreviation}
\TT{A} is given the {\em extern-variable-name} \TT{A.V}
by the first form of the {\em extern-variable-statement}.
The second form of the {\em extern-variable-statement} gives
an explicit {\em extern-variable-name}.
The {\em global-area-abbreviation} and {\em extern-variable-names}
defined by an {\em extern-statement} are only visible within the
scope of the {\em extern-statement}.

An {\em extern-variable-name} actually names a new \key{external variable}
which has the qualifiers and type given in the {\em extern-variable-statement}
that defines the {\em extern-variable-name}.
Each of these new variables is assigned the value of its
associated global variable, using an ordinary assignment statement.
The qualifiers and type of the new variable do not have to exactly
match the qualifiers and type of its associated global variable as long
as this assignment can be compiled.

Note that both global variables and their associated external variables
are actually constant, and cannot be changed.  If $v$ is an external
variable, the construct `\TT{next} $v$' is \underline{not} permitted.

Also note that while a {\em global-variable-name} by itself cannot
generally be used, it can be used inside the {\em global-area-block}
that defines the global variable by code that is after that definition
in that block.

An {\em extern-statement} containing a {\em global-variable-name}
must be within the scope of the {\em global-area-block} that defines
the referenced global variable.

Memory within a global area can be allocated by the function:

\begin{indpar}

{\tt function *UNCHECKED* \begin{tabular}[t]{@{}l@{}}
                                  T r, \\
				  unsadr r.offset, \\
				  adr r.base.adr = \\
				  \end{tabular} \\
\TS~~~~\begin{tabular}[t]{@{}l@{}}
       \ttstdkey{allocate to global} \label{ALLOCATE-TO-GLOBAL} \\
       ~~~~(| type T |) \\
       ~~~~( unsadr size, \\
       ~~~~~~unswrd alignment ?=~0 ) \\
\TS~~~~[|( underlying type of T ) == void |] \\
       \end{tabular}}

\begin{indpar}
Just like `{\tt allocate to stack}' (\pagref{ALLOCATE-TO-STACK})
except that this function must be called by statements inside
a {\em global-area-block}, the memory will be allocated to the global stack
of the global area,
and there is \underline{no} \TT{*STACK*} qualifier on the result.


\end{indpar}

\end{indpar}

A vector whose elements are of some type $T$ can be allocated by
the pointer version of `\TT{allocate to global}': see
\pagref{POINTER-ALLOCATE-TO-GLOBAL}.

A {\em global-area-block} may continue a previous {\em global-area-block}
if it is within the scope of the previous block and has the
same {\em global-area-name} as the previous block.  In this case either
both blocks must be top level and in the same file,
or both must have the same smallest
containing subblock.  The second block is called the
\key{continuing global block} and the first block is called
the \key{continued global block}.

As far as allocating variables to the global stack is concerned,
the continuing {\em global-area-block}
resumes where the continued {\em global-area-block} left off.

A global area may exist at run time or at compile time or both.
For an area defined by a top level {\em global-area-block}, this is
dictated by the {\em global-area-options} on the
{\em global-area-block}.  No options indicates run-time only, the default.
The \TT{*COMPILE-AND-RUN-TIME*} option indicates both compile-time and run-time.
The \TT{*COMPILE-TIME*} option indicates compile-time only.
The {\em global-area-options} on a continuing {\em global-area-block}
must be identical (except for ordering) to those on the continued
{\em global-area-block}.

When a top level {\em global-area-block} is to be executed at compile time,
it is executed immediately after the entire block is compiled.
In this case it must not reference variables in its context that will
not be defined until run time.

When a top level {\em global-area-block} is to be executed at run-time,
it is executed when its containing file is initialized.

A non-top level {\em global-area-block}
is executed the \underline{first time}
its smallest containing subblock is executed, either at compile-time
or at run-time.  Non-top level
{\em global-area-blocks} must not have {\em global-area-options}.

The {\em global-area-name} of a global area is allocated as a
result variable of the first (non-continuing) {\em global-area-block}
defining the global area.  It is of type `\TT{global area}' and
can be used to find the dynamic block that is the area's global stack.
The relevant definitions are:
\begin{indpar}
{\tt
define type \ttstdkey{global area}~as \ldots \\
define abbreviation \ttkey{global area} \ABV{} `std global area'
\\[1ex]
function adr body pointer address = \ttstdkey{dynamic block of} \\
\TS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~( global area g )
}

\begin{indpar}
Return the address of the body pointer of the dynamic block that
is the global stack of the global area {\tt g}.
\end{indpar}
\end{indpar}

Global stacks may be moved during execution.  Given the address of
the body pointer of the global stack, the `{\tt *UNCHECKED* deallocate
dynamic block}' function can be used to deallocate the dynamic block and
reset the body pointer to {\tt NULL}, which will cause any future
reference to the global stack to suffer a memory fault.

\section{Builtin Qualifiers}
\label{BUILTIN-QUALIFIERS}

Builtin qualifiers with special properties implemented in the L-Language
are \TT{*READ*}, \TT{*WRITE*}, and \TT{*STACK*}.
Builtin qualifiers with no special properties but which are used
according to specific conventions are \TT{*UNCHECKED*}, \TT{*READABLE},
and \TT{*WRITABLE}.
There is also a special class of qualifiers called trace qualifiers.
Lastly \TT{*DEFERRED*}, \TT{*OPTIONAL*}, and \TT{*UNUSED*}
are pseudo-qualifiers that are
syntactically like qualifiers, but semantically are not qualifiers.

\subsection{The \TT{*READ*} and \TT{*WRITE*} Qualifiers}
\label{THE-READ-AND-WRITE-QUALIFIERS}

The \ttakey{READ} qualifier is a implied variable qualifier that behaves
in a special way when it is given to a variable {\tt v}.
In this situation {\tt v} is a copy of a RAM memory value and
must be in a cluster that
has either:
\begin{enumerate}
\item
A member {\tt v.adr} of type \TT{adr} 
that is the RAM address of {\tt v}.

\item
Members {\tt v.offset} of type \TT{intadr} or \TT{unsadr} and
{\tt w.base} of type \TT{adr}, where
{\tt w} is either {\tt v} or an ancestor
of {\tt v} in the cluster (if there are several such ancestors, the
closest to {\tt v} is selected).
In this case the RAM address of {\tt v} is {\tt v.offset+w.base}.

\item
It is possible for any of the cluster members mentioned above,
i.e., {\tt v.adr}, {\tt v.offset}, or {\tt w.base}, to have the
\TT{*READ*} qualifier, in which case they must obey these rules recursively.
E.g., if {\tt w.base} has the \TT{*READ*} qualifier there must be either
{\tt w.base.adr}, or there must be both
{\tt w.base\EOL .offset} and {\tt w.base.base} (in this case
{\tt w.base.base} must exist and {\tt w.base} cannot be used as its
own {\tt .base}).

\item
Member {\tt v.offset} of type \TT{intadr} or \TT{unsadr} with a
compile time value, but \underline{no} member {\tt v.base},
and instead for a cluster ancestor {\tt w} of {\tt v}
members as in any of these items, including this, that allow the RAM
address {\tt A} of {\tt w} to be computed.  The RAM address of {\tt v}
is then {\tt v.offset+A}.
\end{enumerate}

A variable {\tt v} with \TT{*READ*} qualifier
must \underline{not} be given a value by an
assignment statement, but will instead be loaded with a value
from its RAM address.  It is called a `\key{RAM cache variable}'.

The type of the variable {\tt v} must \underline{not} have \TT{void} as its
underlying type.

An example is:

\begin{indpar}\begin{verbatim}
// In C/C++:
//     struct foo_struct { int a, b, c }
//     typedef foo_struct * foo
//
// Here a cluster foo, foo.a, foo.b, foo.c
// where foo is an address.
//
define types:
    foo as void
    foo_ptr as adr
function foo x, adr x.base,
         *READ* *WRITE* int32 x.a, x.a.offset,
         *READ*         int32 x.b, x.b.offset,
         *READ* *WRITE* int32 x.c, x.c.offset
        = "*" ( foo_ptr y ):
    x.base = y
    x.a.offset = 0
    x.b.offset = 4
    x.c.offset = 8
function next x.a = update a
        ( foo x, *READ* *WRITE* int32 x.a, int32 v ):
    next x.a = v

// Usage:
//
foo_ptr zp = ...        // assign adr to zp
foo z = * zp            // Assign to z.base, z.a.offset, ...
... z.a ...             // Use z.a
update a ( z, ... )    // Write z.a

\end{verbatim}\end{indpar}

The \ttakey{WRITE} qualifier also identifies a variable as
being a cache of RAM.  However, the
variable is not given any initial value if it does not
also have the \TT{*READ*} qualifier.
If {\tt v} is a \ttakey{WRITE}
RAM cache variable, assigning a value to `{\tt next v}'
writes the value to RAM.  For example:

\begin{indpar}\begin{verbatim}
    function *WRITE* r, adr r.adr = foo ( ... ):
        . . . . . . . . . .
    int32 v = foo ( ... )
        // v does not have any value at this point, and
        // using the value of v will be a compiler error.
    next v = ...      
        // Writes value to v.adr and updates v
\end{verbatim}\end{indpar}

A RAM cache variable may have both the \TT{*READ*} and \TT{*WRITE*}
qualifiers.

If a RAM cache variable {\tt v}'s value is not used,
it will not actually be loaded from RAM, even if {\tt v} is written
by assigning a value to `{\tt next v}'.

Because \TT{*READ*} and \TT{*WRITE*} are implied qualifiers,
RAM cache variables can only be created as
results of inline function calls.
So only inline functions can effect a read or write
of arbitrary RAM contents.

There is a special unchecked function of zero arguments, \TT{NULL}, of result
type \TT{adr}, that
references a block of virtual memory that is
inaccessible and will cause a memory fault if referenced
(\pagref{NULL}).


\subsection{The \TT{*STACK*} Qualifier}
\label{THE-STACK-QUALIFIER}

The `\ttakey{STACK}' qualifier is an addable,
implied, value qualifier
attached to clusters containing offsets and addresses
returned by the builtin `\TT{allocate to stack}'
function (\pagref{ALLOCATE-TO-STACK}).
It is used to keep a stack address or offset from being stored in
non-stack memory and in stacks who lifetime exceeds that of the
memory the stack the address or offset points into.

The special property of the \TT{*STACK*} qualifier is that it cannot
be used to qualify variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement}.
This is so that stack addresses and offsets pointing into a free stack
cannot outlive the free stack.
See Section~\itemref{STACKS} for more information.

Also, as a prohibited qualifier, a \TT{*STACK*} value cannot be
passed as an argument to a function that does not expect a
\TT{*STACK*} value.  For example:
\begin{indpar}\begin{verbatim}
*STACK* adr sa = ...
adr ta = ...
function adr result = F ( adr arg ):
    . . . . . . . . . .
function adr result = G ( *STACK* adr arg ):
    . . . . . . . . . .
adr xa = F ( sa ) // Illegal; F's arg does not have
                  // *STACK* qualifier.
adr ya = G ( sa ) // Legal; G's arg has *STACK* qualifier.
adr za = G ( ta ) // Legal; G's arg's *STACK* qualifier has
                  // no effect (its not required).
\end{verbatim}\end{indpar}

\subsection{The \TT{*UNCHECKED*} Qualifier}
\label{THE-UNCHECKED-QUALIFIER}

The \ttakey{UNCHECKED} qualifier is a builtin
variable qualifier that is used by convention to mark the result variables
of function calls that violate normal type-checking.
See \itemref{UNCHECKED-NUMBER-CONVERSIONS}, Unchecked Number
Conversions, for examples of functions producing \TT{*UNCHECKED*}
results.

It is possible for two functions to have identical prototypes
except that one has the \TT{*UNCHECKED*} qualifier on its
result variable and the other does not.  The function selected by
call-prototype matching will depend upon whether the actual
result variable of the call has the \TT{*UNCHECKED*} qualifier,
because the qualifier is neither addable or deletable.
An example is given on page \pageref{NOT-UNCHECKED-CONVERSION-DEFINITION}.

The \TT{*UNCHECKED*} lexeme is also used as the initial part some
names. An example is the \TT{*UNCHECKED* *ASSEMBLY*} assignment statement
(\pagref{ASSEMBLY-ASSIGNMENT-STATEMENT}).

\subsection{The \TT{*READABLE*} and \TT{*WRITABLE*} Qualifiers}
\label{THE-READABLE-AND-WRITABLE-QUALIFIERS}

The \ttakey{READABLE} and \ttakey{WRITABLE} qualifiers are builtin
implied, deletable, value qualifiers that are used by convention
to mark pointers that can be safely used for, respectively,
reading or writing.

\subsection{Trace Qualifiers}
\label{TRACE-QUALIFIERS}

A \key{trace qualifier} permits values to be marked so that they
can be found (i.e., `traced') by garbage collectors
(and occasionally debuggers)
when they are stored in the
stack.  A trace qualifier may be declared by:

\begin{indpar}
\emkey{trace-qualifier-declaration}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{trace qualifier}
           {\em defined-qualifier-name} \\
        & ~~~~~ \TT{with base type}~~{\em type-name}
    \end{tabular}
\end{indpar}

The base type of a trace qualifier may be determined by the
function with the prototype:
\begin{center}
{\tt (type T) = \ttkey{base type of} ( qualifier Q )}
\end{center}
The value of any variable with the trace qualifier must be
\TT{*UNCHECKED*} convertible to a value of the base type.

It is common to add a trace qualifier to the statement that
defines a type you want to trace.  An example in which the
qualifier is \TT{Q} and the type is \TT{T} is:
\begin{indpar}\begin{verbatim}
trace qualifier Q with base type adr
define type Q T as adr
\end{verbatim}\end{indpar}
which causes all values of type \TT{T} in the stack to be
traced.

More specifically, when a value \TT{V} of a variable with the trace
qualifier \TT{Q} and base type \TT{B} is added to a stack,
\TT{V} converted to type \TT{B} is also
pushed into a (virtual or physical) \TT{Q}-stack of values of
type \TT{B}.
When the stack containing \TT{V} is freed, the corresponding
value in the \TT{Q}-stack is popped.  There is a \TT{Q}-stack
associated with every process and every global area.
Using functions in the
subroutine library (see TBD), these \TT{Q}-stacks can be read.

While a value may be pushed into a stack more than once,
a value will not be pushed if the compiler can prove it is already
in the stack.  Thus given the definitions above, in
\begin{indpar}\begin{verbatim}
T v = ...
T w = v
\end{verbatim}\end{indpar}
the first statement may push the value of \TT{v} to the \TT{Q} stack
but the second statement will not push the value of \TT{w} on
the grounds that it is already in the stack.

\subsection{The Reload Statement}
\label{THE-RELOAD-COMMAND}

The reload statement has the syntax:
\begin{indpar}
\emkey{reload-statement} ::=
    \ttkey{reload} {\em qualifiers} \{ \TT{,} {\em qualifiers} \}\STAR{} \\
\emkey{qualifiers} ::= {\em qualifier} $|$ {\em qualifier-set} \\
\emkey{qualifier} ::= {\em expression} evaluating to a qualifier \\
\emkey{qualifier-set} ::= {\em expression} evaluating to a qualifier set
\end{indpar}

This statement declares the values of all variables with the designated
qualifiers to be out-of-date and unusable.  If any of these variables
is used subsequently, statements to recompute the variable value
will be inserted automatically into the code at the point of the
\TT{reload} statement.  If this is not possible the compilation will
be in error.

As a special case, if a variable that is declared to be out-of-date,
\TT{v}, has the \TT{*READ*} qualifier, and is in
a cluster that causes \TT{v} to be loaded from memory
(as per Section~\itemref{THE-READ-AND-WRITE-QUALIFIERS}),
then if \TT{v} is declared
to be out-of-date, recomputing \TT{v} just means that \TT{v}
is reloaded from RAM.  The possibility that software cache
variables (with the \TT{*READ*} qualifier) will become out-of-date because
the RAM locations they cache have changed is the reason the \TT{reload}
statement exists.

The statement
\begin{center}
\TT{reload *READ*, *READ* dependent}
\end{center}
is commonly used to declare all
variables that act as software caches of memory, and all variables
that should be updated when the caches are updated, to be out-of-date.

Note that variables computed from out-of-date variables are \underline{not}
declared to be out-of-date.

If an out-of-date variable value is not used after the \TT{reload} statement,
it is not recomputed.

Variable values are recomputed in the same order as they were
originally computed.  How each variable is recomputed depends upon
how it was originally computed.

If a variable \TT{v} was originally computed by
a {\em simple-assignment-statement}
of the form `{\em type} \TT{v =} {\em expression}', then if
no input to {\em expression} has been recomputed, \TT{v} does not
need to be recomputed.  Otherwise \TT{v} is recomputed by re-executing
the assignment statement.

If a variable without a \TT{*READ*} qualifier needs to be
recomputed and was computed by other than
a {\em simple-assignment-statement}, it is a compile error if the
variable is marked out-of-date and later used.

The \TT{reload} statement behaves like an executable statement but
it has some unusual properties when it is executed inside a
nested subblock.  First, it declares out-of-date any variable with
the given qualifiers that is visible in its subblock \underline{and any
containing block}.
Second, it will recompute any out-of-date variable in its subblock
\underline{or any containing block} that may be used after the
\TT{reload} statement executes.
Third, when it recomputes variables, it overwrites
the place the variable is stored, rather than allocating a new
place as would a `\TT{next~}{\em variable-name}' expression.
These properties allow `\TT{reload Q}' to appear in an inline
or conditional subblock.

\section{Special Functions}
\label{SPECIAL-FUNCTIONS}

Note that in this section `\TT{std}' is used as the
{\em module-abbreviation} (\pagref{MODULE-ABBREVIATION})
of the \TT{"standard"} module.
This {\em module-abbreviation} is commonly omitted when
a function is called.


\subsection{Floating Pointer Error Flag Functions}
\label{FLOATING-POINT-ERROR-FLAG-FUNCTIONS}

The \skey{floating point error flag}s of
section~\itemref{FLOATING-POINT-ARITHMETIC-EXPRESSIONS}
are located in the `\key{floating point error register}' which
is a special register of \TT{unswrd} type.  The following
builtin functions test and manipulate this register.

\begin{indpar}
{\tt function unswrd r = \ttstdkey{fp error flags}} \\
{\tt function \ttstdkey{clear fp error flags}} \\
{\tt function \ttstdkey{clear fp error flags} ( unswrd mask ) } \\
{\tt function \ttstdkey{set fp error flags} ( unswrd mask ) }

\begin{indpar}
The first function
above reads the register, the second clears the floating point
error flags in the register, the third clears just the floating point
error flags selected by the bits of {\tt mask}, and the fourth sets just the
flags selected by the bits of {\tt mask}.  The value read from the register
may contain non-zero bits other than the floating point error flags.
\end{indpar}
\end{indpar}

The following functions with no arguments
return compile time constants that are
masks for the floating
point error flags in the floating point error
register.  Each mask has a single bit on.
\begin{center}
\begin{tabular}{ll}
{\tt function unswrd r = \ttstdkey{FP INVALID}}		& Invalid operand. \\
{\tt function unswrd r = \ttstdkey{FP DIVIDE BY ZERO}}	& Divide by zero. \\
{\tt function unswrd r = \ttstdkey{FP OVERFLOW}}	& Result overflow. \\
{\tt function unswrd r = \ttstdkey{FP UNDERFLOW}}	& Result underflow. \\
{\tt function unswrd r = \ttstdkey{FP INEXACT}}		& Result inexact. \\
\end{tabular}
\end{center}
The value of {\tt mask} above should be a bitwise OR's of these constants.

\subsection{Abbreviation Testing Functions}
\label{ABBREVIATION-TESTING-FUNCTIONS}

The following functions provide information
about regular abbreviations (\pagref{ABBREVIATION-DECLARATION}).

It is a compile error if any argument to these
functions is not a compile time value.  The results returned by these
functions are compile time values.

\begin{indpar}
{\tt function bool r = \TT{std} ( name N )
                       \TT{is abbreviation}\ttstdindex{is abbreviation}} \\
{\tt function name r = \ttstdkey{replacement of} ( name N )} \\
{\tt function name r = \ttstdkey{final replacement of} ( name N )}
\begin{indpar}
The first function returns \TT{true} if and only if {\tt N} names
an abbreviation (\pagref{ABBREVIATION-DECLARATION}).

The second function returns the replacement name from the
{\em abbreviation-declaration} of {\tt N}, or returns {\tt N} itself
if {\tt N} is not an abbreviation.  The replacement name may itself
be an abbreviation.

The third function applies the second function recursively until
the name returned is not an abbreviation.
\end{indpar}
\end{indpar}

\subsection{Compiler Functions}
\label{COMPILER-FUNCTIONS}

The following function can be used to produce compile-time
generated names like `\TT{T\TMP$n$}', which are most likely
to be useful in generics (\pagref{GENERICS}).

\begin{indpar}
{\tt function name r = \ttstdkey{generated name} ( character c )}%
\label{GENERATE-NAME}

\begin{indpar}
Returns the name `\TT{$c$\TMP$n$}' where $c$ is the value of the
argument and $n$ is a natural-number such that the returned name
is unique among all names generated during the compilation, either
by this function or by the compiler.  $c$ must be an ASCII
letter.
\end{indpar}
\end{indpar}

\subsection{Program Termination Functions}
\label{PROGRAM-TERMINATION-FUNCTIONS}

The following function is used to terminate program execution
when a programming error is discovered.

\begin{indpar}

{\tt function \ttstdkey{program stop}}
\begin{indpar}
This function terminates the program abnormally.  It has
the special property that deferred variables that normally
must be set in the block need not be set in an execution
path that includes a call to this function.
\end{indpar}

\end{indpar}


The following functions can be used before program termination
to diagnose the location of a programming error.  They reference
a table of call locations which is builtin.

\begin{indpar}

{\tt function string r = \ttstdkey{call location} ( unswrd i )}
\begin{indpar}
Returns the call location described by the {\tt i}'th entry in the
call locations table.  This call location is a string of the form:
\begin{center}
{\em file-name}\TT{:~line~}{\em line-number}
\end{center}
specifying the location in a source code file of the
first line of the statement
containing the function call described by the {\tt i}'th entry.
Here {\em file-name} is either
the {\em module-name} (\pagref{MODULES}) or {\em body-name}
(\pagref{BODIES}) of the file; that is, it is the name of
the file containing the statement
relative to one of several directories
specified separately to the compiler.
{\em Line-number} is the number (1, 2, 3, \ldots) of the
line in which the statement begins.
\end{indpar}

{\tt function unswrd r = \ttstdkey{call parent} ( unswrd i )}
\begin{indpar}
Returns the call parent $P$ of the {\tt i}'th entry in the
call locations table.
If $P$ is not 0, the {\tt i}'th entry is for a location
in an inline function call that was called from the location
described by the $P$'th entry of the call locations table.
If $P$ is 0, the call location described by  the {\tt i}'th entry
is not inside an inline function
call, but is inside an out-of-line function.
\end{indpar}

{\tt function unswrd r = \ttstdkey{call entry}}
\begin{indpar}
Returns the index in the call locations
table of the entry describing
the location of the statement containing the call
to this function.
\end{indpar}

{\tt function unswrd r = \ttstdkey{call entry} ( unswrd i )}
\begin{indpar}
Returns the index in the call locations
table of entry describing the location of the statement
containing the {\tt i+1}'st
active out-of-line call recorded in the program stack, counting
from the top of the stack (most recent entry).  For
{\tt i == 0} this is the out-of-line call that called the
out-of-line function which in turn called this builtin
{\tt call entry} function.  If \TT{0} is returned, {\tt i} equals
or exceeds the number of out-of-line calls in the stack.
\end{indpar}

\end{indpar}

\section{Pointers}
\label{POINTERS}

A \ttkey{pointer} points at a vector of RAM memory and
permits elements of the vector to be read or written.
Builtin functions are also available to copy one vector
to another, set all the elements of a vector to
a given value, and perform vector arithmetic operations.

\subsection{The Pointer Type}
\label{THE-POINTER-TYPE}

Pointers are a builtin cluster type defined by:

\begin{indpar} \tt
define type \ttstdkey{pointer}\label{POINTER} as void \\
define abbreviation \ttkey{pointer} \ABV{} `std pointer'
\end{indpar}

Its cluster members are:

\begin{indpar}[0.6in]
\hspace*{-0.3in}{\tt intadr \ttdmkey{begin}{of pointer}} \\
The offset of the first element relative to the pointer base address.
Note that the offset can be negative.

\hspace*{-0.3in}{\tt intadr \ttdmkey{end}{of pointer}} \\
The offset just after the last element relative to the pointer base address.
This may not be less than \TT{.begin}.

\hspace*{-0.3in}{\tt adr \ttdmkey{base.adr}{of pointer}} \\
The address from which the pointer base address is read.

\hspace*{-0.3in}{\tt type \ttdmkey{type}{of pointer}} \\
The type of the vector elements.

\hspace*{-0.3in}{\tt qualifiers \ttdmkey{qualifiers}{of pointer}} \\
The qualifiers of the vector elements.

\end{indpar}

The following qualifiers are recognized as having special meaning
when applied to pointers:

\begin{indpar}[0.6in]

\hspace*{-0.3in}\ttamkey{READABLE}{pointer} \\
Signifies that the pointer can be used to read vector elements.

\hspace*{-0.3in}\ttamkey{WRITABLE}{pointer} \\
Signifies that the pointer can be used to write vector elements.

\end{indpar}

The following functions can be used to copy pointers:

{\tt\begin{tabular}{@{}l}
function Qs pointer r, \\
~~~~~~~~~~~~intadr r.begin, \\
~~~~~~~~~~~~intadr r.end, \\
~~~~~~~~~~~~adr r.base.adr, \\
~~~~~~~~~~~~type r.type, \\
~~~~~~~~~~~~qualifiers r.qualifiers = \\
~~~~\ttstdkey{assign} \\
~~~~~~~~(| qualifiers Qs |) \\
~~~~~~~~( Qs pointer p, intadr p.begin, intadr p.end, \\
~~~~~~~~~~adr p.base.adr, type p.type, qualifiers p.qualifiers ) \\
\end{tabular}}\label{POINTER-ASSIGN}

\begin{indpar}
Copies a pointer as per an assignment statement.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function Qrs pointer r, \\
~~~~~~~~~~~~~intadr r.begin, \\
~~~~~~~~~~~~~intadr r.end, \\
~~~~~~~~~~~~~adr r.base.adr, \\
~~~~~~~~~~~~~type r.type, \\
~~~~~~~~~~~~~qualifiers r.qualifiers = \\
~~~~\ttstdkey{read only} \\
~~~~~~~~(| qualifiers Qps |) \\
~~~~~~~~( Qps pointer p, intadr p.begin, intadr p.end, \\
~~~~~~~~~~adr p.base.adr, type p.type, qualifiers p.qualifiers ) \\
~~~~~~~~[| Qrs = Qps - \{ *WRITABLE* \} |] \\
\end{tabular}}\label{POINTER-READ-ONLY}

\begin{indpar}
Copies a pointer as per an assignment statement while removing the
\TT{*WRITABLE*} qualifier from the pointer.
\end{indpar}

\subsection{Vector Allocators}
\label{VECTOR-ALLOCATORS}


The following functions allocate pointers to new vectors.
All these functions do nothing but the following on an error:
\begin{indpar}
{\bf Insufficient Memory}~~If there is not enough memory,
{\tt p.base.adr} is set to \TT{ERROR(\EOL IN\-SUF\-FI\-CIENT MEMORY)}
and {\tt p.base.begin} is set to the largest value of {\tt N}
that could be allocated.  Dynamic bodies may be moved if
a function call allocating a dynamic body or to the end of a dynamic
body has this error.

{\bf Bad Alignment}~~The elements of the vector could not be
aligned because {\tt alignment of ( $T$ )} is too large,
{\tt p.base.adr} is set to \TT{ERROR(BAD ALIGNMENT)}
and {\tt p.base\EOL .begin} is set to the largest alignment
that would be allowed.

\end{indpar}

\begin{indpar}


{\tt\begin{tabular}{@{}l}
function *STACK* *READABLE* *WRITABLE* pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdkey{allocate to stack} \\
~~~~~~~~(| type T ?= uns8, qualifiers Qs ?= \{\} |) \\
~~~~~~~~( unsadr N ?= 1 ) \\
~~~~~~~~[| zero value OK for T |] \\
~~~~~~~~[| Qs are all addable |] \\
\end{tabular}}\label{POINTER-ALLOCATE-TO-STACK}

\begin{indpar}
Allocates a vector of {\tt N} elements to the current free
stack (\pagref{FREE-STACK}).  The elements are set to zero.
The elements each have type {\tt T} and qualifiers {\tt Qs}.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function *READABLE* *WRITABLE* pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdkey{allocate to global} \\
~~~~~~~~(| type T ?= uns8, qualifiers Qs ?= \{\} |) \\
~~~~~~~~( unsadr N ?= 1 ) \\
~~~~~~~~[| zero value OK for T |] \\
~~~~~~~~[| Qs are all addable |] \\
\end{tabular}}\label{POINTER-ALLOCATE-TO-GLOBAL}

\begin{indpar}
Must be executed within a global area block (\itemref{GLOBAL-AREAS}).
Allocates a vector of {\tt N} elements to the global area.
The elements are set to zero.
The elements each have type {\tt T} and qualifiers {\tt Qs}.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function *READABLE* *WRITABLE* pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdkey{allocate to static} \\
~~~~~~~~(| type T ?= uns8, qualifiers Qs ?= \{\} |) \\
~~~~~~~~( unsadr N ?= 1, \\
~~~~~~~~~~memory region R ?= std default static region ) \\
~~~~~~~~[| zero value OK for T |] \\
~~~~~~~~[| Qs are all addable |] \\
\end{tabular}}\label{POINTER-ALLOCATE-TO-STATIC}

\begin{indpar}
Allocates a vector of {\tt N} elements to the static memory region R.
The elements are set to zero.
The elements each have type {\tt T} and qualifiers {\tt Qs}.
{\tt p.base.adr} is set equal to \TT{std STATIC BASE} (\pagref{STATIC-BASE}).
\end{indpar}

{\tt\begin{tabular}{@{}l}
function *READABLE* *WRITABLE* pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdkey{allocate to dynamic} \\
~~~~~~~~(| type T ?= uns8, qualifiers Qs ?= \{\} |) \\
~~~~~~~~( body pointer address A, unsadr N ?= 1, \\
~~~~~~~~~~memory region R ?= std default dynamic region ) \\
~~~~~~~~[| zero value OK for T |] \\
~~~~~~~~[| Qs are all addable |] \\
\end{tabular}}\label{POINTER-ALLOCATE-TO-DYNAMIC}

\begin{indpar}
Allocates a vector of {\tt N} elements as a new dynamic block in
the dynamic memory region R, and stores the address of the block
in the body pointer addressed by {\tt A}.  Before calling this
function the body pointer \underline{must} be set to \TT{NULL}.
The elements are set to zero.
The elements each have type {\tt T} and qualifiers {\tt Qs}.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function *READABLE* *WRITABLE* pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdlkey{allocate}{to dynamic block} \\
~~~~~~~~(| type T ?= uns8, qualifiers Qs ?= \{\} |) \\
~~~~~~~~( body pointer address A, unsadr N ?= 1, \\
~~~~~~~~~~memory region R ?= std default dynamic region ) \\
~~~~~~~~[| zero value OK for T |] \\
~~~~~~~~[| Qs are all addable |] \\
\end{tabular}}\label{POINTER-ALLOCATE-TO-DYNAMIC-BLOCK}

\begin{indpar}
If the dynamic block has not been allocated before this call
(i.e., its body pointer is \TT{NULL}),
it is allocated first.

Adds a vector of {\tt N} elements to the end of the dynamic block
whose body pointer is located at address {\tt A}.
If necessary padding is added before the vector and/or
the dynamic block is moved so that the vector has the alignment of
the type {\tt T}.

If the dynamic block has not been allocated before this call
(i.e., its body pointer is \TT{NULL}),
it is allocated first.

The elements are set to zero.
The elements each have type {\tt T} and qualifiers {\tt Qs}.
\end{indpar}

\end{indpar}

The following functions are \TT{*UNCHECKED*} versions of the
above, and do the same thing as the checked versions but
allow zero to be an illegal {\tt T} value and allow any qualifiers
in {\tt Qs}.  The vectors are initialized to zero.

\begin{indpar}

{\tt\begin{tabular}{@{}l}
function *UNCHECKED* *STACK* *READABLE* *WRITABLE* \\
~~~~~~~~~~~~~~~~~~~~~pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdkey{allocate to stack} \\
~~~~~~~~(| type T ?= uns8, qualifiers Qs ?= \{\} |) \\
~~~~~~~~( intadr N = 1 ) \\
\end{tabular}}

{\tt\begin{tabular}{@{}l}
function *UNCHECKED* *READABLE* *WRITABLE* pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdkey{allocate to global} \\
~~~~~~~~(| type T ?= uns8, qualifiers Qs ?= \{\} |) \\
~~~~~~~~( intadr N = 1 ) \\
\end{tabular}}

{\tt\begin{tabular}{@{}l}
function *UNCHECKED* *READABLE* *WRITABLE* pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdkey{allocate to static} \\
~~~~~~~~(| type T ?= uns8, qualifiers Qs ?= \{\} |) \\
~~~~~~~~( unsadr N ?= 1, \\
~~~~~~~~~~memory region R ?= std default static region ) \\
\end{tabular}}

{\tt\begin{tabular}{@{}l}
function *UNCHECKED* *READABLE* *WRITABLE* pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdkey{allocate to dynamic} \\
~~~~~~~~(| type T ?= uns8, qualifiers Qs ?= \{\} |) \\
~~~~~~~~( body pointer address A, unsadr N ?= 1, \\
~~~~~~~~~~memory region R ?= std default dynamic region ) \\
\end{tabular}}

{\tt\begin{tabular}{@{}l}
function *UNCHECKED* *READABLE* *WRITABLE* pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdlkey{allocate}{to dynamic block} \\
~~~~~~~~(| type T ?= uns8, qualifiers Qs ?= \{\} |) \\
~~~~~~~~( body pointer address A, unsadr N ?= 1, \\
~~~~~~~~~~memory region R ?= std default dynamic region ) \\
\end{tabular}}

\end{indpar}

The following function allocates a readonly UTF-8 character
string to static memory:

\begin{indpar}

{\tt\begin{tabular}{@{}l}
function *READABLE* pointer p, \\
~~~~~~~~~~~~~intadr p.begin, \\
~~~~~~~~~~~~~intadr p.end, \\
~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~type p.type, \\
~~~~~~~~~~~~~qualifiers p.qualifiers = \\
~~~~\ttstdkey{allocate UTF-8 to static} \\
~~~~~~~~( string S, \\
~~~~~~~~~~memory region R ?= std default static region ) \\
\end{tabular}}\label{POINTER-ALLOCATE-UTF-8-TO-STATIC}

\begin{indpar}
Allocate static memory and set it equal to the UTF-8 representation of the
value of {\tt S} with a \TT{NUL} appended.  The element type {\tt p.type}
is set to \TT{uns8}, and the element qualifiers {\tt p.qualifiers} is
set to the empty set.  The memory allocated may be
read-only, meaning that trying to write it with unchecked code
will cause a program memory fault error.
\end{indpar}

\end{indpar}

Like for most functions,
calls to the functions of this section execute at compile-time only if
they are included in a {\em compile-time-assign\-ment-\EOL statement}
(\itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS}).
Otherwise they execute at run time.

\subsection{Vector Access Operations}
\label{VECTOR-ACCESS-OPERATIONS}

The following builtin functions can be used to access vector elements:

\begin{indpar}

{\tt\begin{tabular}{@{}l}
function intadr r = \\
~~~~\ttstdmkey{size of}{pointer}
            ( pointer p, intadr p.begin, intadr p.end, \\
~~~~~~~~~~~~~~~~~~type p.type ) \\
\end{tabular}}

\begin{indpar}
Returns the number of elements
in the vector pointed at by {\tt p}.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function bool r = \\
~~~~\TT{std} ( pointer p, intadr p.begin, intadr p.end )
    \TT{is empty}\ttstdmindex{is empty}{pointer}
\end{tabular}}

\begin{indpar}
Equivalent to {\tt size of p == 0}.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function Qrs p.type r, \\
~~~~~~~~~~~~~intadr p.offset, \\
~~~~~~~~~~~~~*READ* adr p.base, \\
~~~~~~~~~~~~~adr p.base.adr = \\
~~~~(| qualifiers Qps |) \\
~~~~( Qps pointer p, intadr p.begin, intadr p.end, \\
~~~~~~adr p.base.adr, type p.type, qualifiers p.qualifiers ) \\
~~~~\TT{[} intadr i \TT{]}\ttmindex{[]}{of pointer} \\
~~~~(| qualifiers Qrs = \\
~~~~~~~~~p.qualifiers \\
~~~~~~~+ ( \{ *READ* \} if ( *READABLE* in Qps ) else \{\} ) \\
~~~~~~~+ ( \{ *WRITE* \} if ( *WRITABLE* in Qps ) else \{\} )  |] \\
\end{tabular}}

\begin{indpar}
If {\tt p} is a pointer and {\tt i} an unsigned integer,
{\tt p[i]} is the {\tt i}+1'st element of the vector pointed at
by {\tt p}.  It is a fatal error if {\tt i} is too large
(i.e., if {\tt i => size of p}).
\end{indpar}

{\tt\begin{tabular}{@{}l}
function Qrs p.type r, \\
~~~~~~~~~~~~~intadr p.offset, \\
~~~~~~~~~~~~~*READ* adr p.base, \\
~~~~~~~~~~~~~adr p.base.adr = \\
~~~~(| qualifiers Qps |) \\
~~~~"\ttmkey{*}{of pointer}"
        ( Qps pointer p, intadr p.begin, intadr p.end, \\
~~~~~~~~~~adr p.base.adr, type p.type, \\
~~~~~~~~~~qualifiers p.qualifiers ) \\
~~~~(| qualifiers Qrs = \\
~~~~~~~~~p.qualifiers \\
~~~~~~~+ ( \{ *READ* \} if ( *READABLE* in Qps ) else \{\} ) \\
~~~~~~~+ ( \{ *WRITE* \} if ( *WRITABLE* in Qps ) else \{\} )  |] \\
\end{tabular}}

\begin{indpar}
If {\tt p} is a pointer, {\tt *p} is equivalent to {\tt p[0]}.
Here {\tt *} is a prefix operator.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function Qps pointer r, \\
~~~~~~~~~~~~~intadr r.begin, \\
~~~~~~~~~~~~~intadr r.end, \\
~~~~~~~~~~~~~adr r.base.adr, \\
~~~~~~~~~~~~~type r.type, \\
~~~~~~~~~~~~~qualifiers r.qualifiers, \\
~~~~~~~~~~~~~next p.begin, \\
~~~~(| qualifiers Qps |) \\
~~~~( Qps pointer p, intadr p.begin, intadr p.end, \\
~~~~~~adr p.base.adr, type p.type, qualifiers p.qualifiers ) \\
~~~~"\ttmkey{++}{of pointer}" \\
\end{tabular}}

\begin{indpar}
If {\tt p} is a pointer, {\tt p++} adds {\tt size of T} to {\tt p.begin},
thus skipping over the first element of the vector pointed at by {\tt p},
and returns the initial value of {\tt p} before {\tt p.begin} was
altered.  The idiom {\tt *p++} returns the first element of the vector
pointed at by {\tt p} and also removes this element from the vector.

It is a fatal error if {\tt p} is empty when this function is
called.  Here {\tt ++} is a postfix operator.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function Qps pointer r, \\
~~~~~~~~~~~~~intadr r.begin, \\
~~~~~~~~~~~~~intadr r.end, \\
~~~~~~~~~~~~~adr r.base.adr, \\
~~~~~~~~~~~~~type r.type, \\
~~~~~~~~~~~~~qualifiers r.qualifiers, \\
~~~~~~~~~~~~~next p.end, \\
~~~~(| qualifiers Qps |) \\
~~~~"\ttmkey{-{}-}{of pointer}"
         ( Qps pointer p, intadr p.begin, intadr p.end, \\
~~~~~~~~~~~adr p.base.adr, type p.type, \\
~~~~~~~~~~~qualifiers p.qualifiers ) \\
\end{tabular}}

\begin{indpar}
If {\tt p} is a pointer, {\tt -{}-p} subtracts {\tt size of T} from {\tt p.end},
thus removing the last element of the vector pointed at by {\tt p},
and returns a pointer to a vector consisting of the single removed element.
The idiom {\tt *-{}-p} returns the last element of the vector
pointed at by {\tt p} and also removes this element from the vector.

It is a fatal error if {\tt p} is empty when this function is
called.  Here {\tt -{}-} is a prefix operator.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function Qps pointer r, \\
~~~~~~~~~~~~~intadr r.begin, \\
~~~~~~~~~~~~~intadr r.end, \\
~~~~~~~~~~~~~adr r.base.adr, \\
~~~~~~~~~~~~~type r.type, \\
~~~~~~~~~~~~~qualifiers r.qualifiers, \\
~~~~~~~~~~~~~next p.end, \\
~~~~(| qualifiers Qps |) \\
~~~~( Qps pointer p, intadr p.begin, intadr p.end, \\
~~~~~~adr p.base.adr, type p.type, qualifiers p.qualifiers ) \\
~~~~\TT{[} intadr i, intadr j \TT{]}\ttmindex{[]}{subvector} \\
\end{tabular}}

\begin{indpar}
If {\tt p} is a pointer, {\tt p[i,j]} is a pointer to elements
{\tt p[i]} through {\tt p[j]} of the vector pointed at by {\tt p}.
If {\tt i < 0} it is replaced by `{\tt size of p + i}', and similarly
for {\tt j}.
It is a fatal error if after these replacements {\tt i} and {\tt j}
are not both in the range {\tt [0, size of p - 1]}.
Otherwise if {\tt j < i} after these replacements,
the pointer returned is empty.
\end{indpar}


\end{indpar}

The following functions write the elements of a vector:

\begin{indpar}

{\tt\begin{tabular}{@{}l}
function \ttstdmkey{set}{vectors} \\
~~~~~~~~~~~~~( p.type v, \\
~~~~~~~~~~~~~~~*WRITABLE* pointer p, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p.begin, intadr p.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~adr p.base.adr, type p.type ) \\
\end{tabular}}

\begin{indpar}
Set each element of the vector pointed at by {\tt p} to the value {\tt v}.
Element qualifiers are ignored.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function \ttstdmkey{copy}{vectors} \\
~~~~~~~~~~~~~( *READABLE* pointer p1, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p1.begin, intadr p1.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~adr p1.base.adr, type p1.type ) \\
~~~~~~~~~~~~~~~*WRITABLE* pointer p2, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p2.begin, intadr p2.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~adr p2.base.adr, type p2.type ) \\
\end{tabular}}

\begin{indpar}
Copy the vector pointed at by {\tt p1} to the vector pointed at by
{\tt p2}.  Values of type {\tt p1.type} must be convertible to
values of type {\tt p2.type}.  If the two vectors overlap,
the types {\tt p1.type} and {\tt p2.type} must have the same
size (in which case if the {\tt p2} vector begins after
the beginning of the {\tt p1} vector, the copy will be from the ends of
the vectors to the beginnings of the vectors, while in all other
cases the copy will be from the beginnings to the ends).
The vectors must have the same number of elements.
\end{indpar}

\end{indpar}

\subsection{Vector Arithmetic Operations}
\label{VECTOR-ARITHMETIC-OPERATIONS}

The builtin functions of this section take pointer arguments that designate
input and output vectors and perform arithmetic operations on vector
elements.\footnote{These functions can be used to interface to
Intel SSE and AVX instructions.}

\begin{indpar}

{\tt\begin{tabular}{@{}l}
function T r = \ttstdmkey{sum}{of vector} (or \ttstdmkey{product}{of vector},
                                              \ttstdmkey{max}{of vector},
                                              \ttstdmkey{min}{of vector}) \\
~~~~(| type T |) \\
~~~~( *READABLE* pointer p, \\
~~~~~~~~~~~~~~~~~intadr p.begin, intadr p.end, \\
~~~~~~~~~~~~~~~~~adr p.base.adr, type p.type ) \\
~~~~[| T is in { float32, float64, float128 } |] \\
\end{tabular}}

\begin{indpar}
Return the sum, product, maximum, or minimum of all the elements of the vector
pointed at by {\tt p}.  Operations are done with target type {\tt T}.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function T r = \ttstdmkey{product}{of vectors} \\
~~~~(| type T |) \\
~~~~( *READABLE* pointer p1, \\
~~~~~~~~~~~~~~~~~intadr p1.begin, intadr p1.end, \\
~~~~~~~~~~~~~~~~~adr p1.base.adr, type p1.type ) \\
~~~~~~*READABLE* pointer p2, \\
~~~~~~~~~~~~~~~~~intadr p2.begin, intadr p2.end, \\
~~~~~~~~~~~~~~~~~adr p2.base.adr, type p2.type ) \\
~~~~[| T is in { float32, float64, float128 } |] \\
\end{tabular}}

\begin{indpar}
Return the scalar product of the vectors pointed at by {\tt p1} and
{\tt p2}.  Operations are done with target type {\tt T}.
\end{indpar}

\end{indpar}

Some of the remaining functions of this section obey the following:

\begin{indpar}
\key{The Vector Overlap Criteria}(\key{VOC}).
The input and output vectors of this function are such that if any
output vector overlaps an input vector, the two vectors are identical
in that they have the same element types and numbers of elements.
\end{indpar}

\begin{indpar}

{\tt\begin{tabular}{@{}l}
function \ttstdmkey{add}{vectors} {\rm (or \ttstdmkey{sub}{vectors},
					   \ttstdmkey{mul}{vectors},
					   \ttstdmkey{div}{vectors},
					   \ttstdmkey{max}{vectors},
					   \ttstdmkey{min}{vectors})} \\
~~~~~~~~~~~~~( *READABLE* pointer p1, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p1.begin, intadr p1.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~ adr p1.base.adr, type p1.type, \\
~~~~~~~~~~~~~~~*READABLE* pointer p2, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p2.begin, intadr p2.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~ adr p2.base.adr, type p2.type, \\
~~~~~~~~~~~~~~~*WRITABLE* pointer p3, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p3.begin, intadr p3.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~ adr p3.base.adr, type p3.type ) \\
~~~~~~~~~~~~~[| p1.type is numeric |] \\
~~~~~~~~~~~~~[| p2.type is numeric |] \\
~~~~~~~~~~~~~[| p3.type is float |] \\
\end{tabular}}

\begin{indpar}
Adds, subtracts, multiplies, divides, takes the maximum of, or
takes the minimum of corresponding elements of the vectors pointed
at by {\tt p1} and {\tt p2}
and stores the results in corresponding elements of
the vector pointed at by {\tt p3}.  Elements of {\tt p2} are subtracted
from elements of {\tt p1}, and elements of {\tt p1} are divided by
elements of {\tt p2}.  Element operations are
performed with target type {\tt p3.type}: note this must be floating
point.  All vectors must be of the same length.
Element qualifiers are ignored.
This function obeys VOC.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function \ttstdmkey{add}{scalar-vector}
    {\rm (or \begin{tabular}[t]{@{}l@{}}
             \ttstdmkey{sub}{scalar-vector},
             \ttstdmkey{revsub}{scalar-vector},
	     \ttstdmkey{mul}{scalar-vector}, \\
	     \ttstdmkey{div}{scalar-vector},
	     \ttstdmkey{revdiv}{scalar-vector}, \\
	     \ttstdmkey{max}{scalar-vector},
	     \ttstdmkey{min}{scalar-vector})
	     \end{tabular}} \\
~~~~~~~~~~~~~(| type T |) \\
~~~~~~~~~~~~~( T v, \\
~~~~~~~~~~~~~~~*READABLE* pointer p1, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p1.begin, intadr p1.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~ adr p1.base.adr, type p1.type, \\
~~~~~~~~~~~~~~~*WRITABLE* pointer p2, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p2.begin, intadr p2.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~ adr p2.base.adr, type p2.type ) \\
~~~~~~~~~~~~~[| T is numeric |] \\
~~~~~~~~~~~~~[| p1.type is numeric |] \\
~~~~~~~~~~~~~[| p2.type is float |] \\
\end{tabular}}

\begin{indpar}
Adds, subtracts, multiplies, divides, takes the maximum of, or
takes the minimum of {\tt v} and elements of the vector pointed
at by {\tt p1}
and stores the results in corresponding elements of
the vector pointed at by {\tt p2}.  Here \TT{sub} subtracts {\tt v}
from the vector elements, \TT{revsub} subtracts the vector elements
from {\tt v}, \TT{div} divides the vector elements by {\tt v},
and \TT{revdiv} divides {\tt v} by the vector elements.  Element operations are
performed with target type {\tt p2.type}: note this must be floating
point.  Both vectors must be of the same length.
Element qualifiers are ignored.
This function obeys VOC.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function \ttstdmkey{bitand}{vectors} {\rm (or \ttstdmkey{bitor}{vectors},
					   \ttstdmkey{bitnand}{vectors},
					   \ttstdmkey{bitor}{vectors})} \\
~~~~~~~~~~~~~( *READABLE* pointer p1, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p1.begin, intadr p1.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~ adr p1.base.adr, type p1.type, \\
~~~~~~~~~~~~~~~*READABLE* pointer p2, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p2.begin, intadr p2.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~ adr p2.base.adr, type p2.type, \\
~~~~~~~~~~~~~~~*WRITABLE* pointer p3, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p3.begin, intadr p3.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~ adr p3.base.adr, type p3.type ) \\
~~~~~~~~~~~~~[| p1.type is uns |] \\
~~~~~~~~~~~~~[| p2.type is uns |] \\
~~~~~~~~~~~~~[| p3.type is uns |] \\
\end{tabular}}

\begin{indpar}
Takes the bitwise and, or, nand, or xor
of corresponding elements of the vectors pointed
at by {\tt p1} and {\tt p2}
and stores the results in corresponding elements of
the vector pointed at by {\tt p3}.  The nand operation computes
the bitwise and of the {\tt p1} element and the complement of the
{\tt p2} element.
Element operations are
performed with target type {\tt p3.type}: note this must be an unsigned
integer type.  All vectors must be of the same length.
Element qualifiers are ignored.
This function obeys VOC.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function \ttstdmkey{add}{scalar-vector}
    {\rm (or \begin{tabular}[t]{@{}l@{}}
             \ttstdmkey{bitand}{scalar-vector},
             \ttstdmkey{bitor}{scalar-vector},
	     \ttstdmkey{bitnand}{scalar-vector}, \\
	     \ttstdmkey{bitxor}{scalar-vector})
	     \end{tabular}} \\
~~~~~~~~~~~~~(| type T |) \\
~~~~~~~~~~~~~( T v, \\
~~~~~~~~~~~~~~~*READABLE* pointer p1, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p1.begin, intadr p1.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~ adr p1.base.adr, type p1.type, \\
~~~~~~~~~~~~~~~*WRITABLE* pointer p2, \\
~~~~~~~~~~~~~~~~~~~~~~~~~~intadr p2.begin, intadr p2.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~ adr p2.base.adr, type p2.type ) \\
~~~~~~~~~~~~~[| T is uns |] \\
~~~~~~~~~~~~~[| p1.type is uns |] \\
~~~~~~~~~~~~~[| p2.type is uns |] \\
\end{tabular}}

\begin{indpar}
Takes the bitwise and, or, nand, or xor
of {\tt v} and elements of the vector pointed
at by {\tt p1}
and stores the results in corresponding elements of
the vector pointed at by {\tt p2}.  The nand operation computes
the bitwise AND of {\tt v} and the complement of the {\tt p1} element.
Element operations are
performed with target type {\tt p2.type}: note this must be an unsigned
integer type.  Both vectors must be of the same length.
Element qualifiers are ignored.
This function obeys VOC.
\end{indpar}

\end{indpar}

\section{Atomic Functions and Statements}
\label{ATOMIC-FUNCTIONS-AND-STATEMENTS}

In the following \key{system memory} refers to the computer large
RAM memory that is shared among the computer's processors.
There are many kinds of caches of this memory, and
when multiple processors are being used, it is sometimes important
to be sure that values read from memory are values store in
system memory at a particular time, and not values store in system
memory at some earlier time or values that will be stored at some
later time.

It is also sometimes important that a read or write operation to
system memory be executed completely without interruption by
other processors reading or writing the same locations.  Such
read and write operations are said to be \key{atomic}.

The following builtin \skey{atomic function}s
can be used to optimistically access a shared database stored
in system memory if there is only one process that writes the database:

\begin{indpar}

{\tt\begin{tabular}{@{}l}
function uns32 r = \ttstdkey{*ATOMIC* *PRE-READ*} \\
~~~~~~~~~~~~~~~~~~~~~~~( *READABLE* pointer p, \\
~~~~~~~~~~~~~~~~~~~~~~~~~intadr p.begin, intadr p.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~~~~~~~~~~~~~type p.type ) \\
~~~~~~~~~~~~~[| p.type == uns32 |] \\
\end{tabular}}

\begin{indpar}
Atomically read
from system memory and return the value of the vector's only element.
The vector length must be 1 (p.end must equal p.begin + size of uns32).
The type of this element must be \TT{uns32}, and the address of the element
must a multiple of the element size in bytes.

All reads executed by the current processor \underline{after}
a call to this builtin function will return data that either
existed in system memory at the time of the call, or was written
to system memory after the call.%
\footnote{On modern INTEL 64 processors
all aligned reads are atomic and {\tt *ATOMIC* *PRE-READ*} can be implemented
by a normal read \underline{followed} by a {\tt LFENCE} instruction.
In addition, optimized code must execute
{\tt *ATOMIC* *PRE-READ*} before executing following read statements. }

This builtin function executes
`{\tt reload *READ*, *READ* dependent}'.
\end{indpar}

{\tt\begin{tabular}{@{}l}
function uns32 r = \ttstdkey{*ATOMIC* *POST-READ*} \\
~~~~~~~~~~~~~~~~~~~~~~~( *READABLE* pointer p, \\
~~~~~~~~~~~~~~~~~~~~~~~~~intadr p.begin, intadr p.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~~~~~~~~~~~~~type p.type ) \\
~~~~~~~~~~~~~[| p.type == uns32 |] \\
\end{tabular}}

\begin{indpar}
Atomically read from system memory
and return the value of the vector's only element.
The vector length must be 1 (p.end must equal p.begin + size of uns32).
The type of this element must be \TT{uns32}, and the address of the element
must a multiple of the element size in bytes.

All reads executed by the current processor \underline{before}
a call to this builtin function will return data that was written
to system memory \underline{before} the call reads from system memory.%
\footnote{On modern INTEL 64 processors
all aligned reads are atomic and {\tt *ATOMIC* *POST-READ*} can be implemented
by a normal read \underline{preceded} by a {\tt LFENCE} instruction.  In
addition optimized code must not execute {\tt *ATOMIC* *POST-READ*}
before executing preceding read statements.}
\end{indpar}

{\tt\begin{tabular}{@{}l}
function \ttstdkey{*ATOMIC* *PRE-WRITE*} \\
~~~~~~~~~~~~~~~~~~~~~~~( uns32 value, \\
~~~~~~~~~~~~~~~~~~~~~~~~~*WRITABLE* pointer p, \\
~~~~~~~~~~~~~~~~~~~~~~~~~intadr p.begin, intadr p.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~~~~~~~~~~~~~type p.type ) \\
~~~~~~~~~~~~~[| p.type == uns32 |] \\
\end{tabular}}

\begin{indpar}
Atomically write {\tt value} to the vector's only element in system memory.
The vector length must be 1 (p.end must equal p.begin + size of uns32).
The type of this element must be \TT{uns32}, and the address of the element
must a multiple of the element size in bytes.

All writes by the current processor \underline{after} a call to
this builtin function will write
to system memory \underline{after} the call writes its {\tt value}
to system memory.%
\footnote{On modern INTEL 64 processors
all aligned writes are atomic and {\tt *ATOMIC* *PRE-WRITE*} can be implemented
by a normal write \underline{followed} by a {\tt SFENCE} instruction.
In addition, optimized code must execute
{\tt *ATOMIC* *PRE-WRITE*} before executing following write statements. }
\end{indpar}

{\tt\begin{tabular}{@{}l}
function \ttstdkey{*ATOMIC* *POST-WRITE*} \\
~~~~~~~~~~~~~~~~~~~~~~~( uns32 value, \\
~~~~~~~~~~~~~~~~~~~~~~~~~*WRITABLE* pointer p, \\
~~~~~~~~~~~~~~~~~~~~~~~~~intadr p.begin, intadr p.end, \\
~~~~~~~~~~~~~~~~~~~~~~~~~adr p.base.adr, \\
~~~~~~~~~~~~~~~~~~~~~~~~~type p.type ) \\
~~~~~~~~~~~~~[| p.type == uns32 |] \\
\end{tabular}}

\begin{indpar}
Atomically write {\tt value} to the vector's only element in system memory.
The vector length must be 1 (p.end must equal p.begin + size of uns32).
The type of this element must be \TT{uns32}, and the address of the element
must a multiple of the element size in bytes.

All writes by the current processor \underline{before} a call to
this builtin function will write
to system memory \underline{before} the call writes its {\tt value}
to system memory.%
\footnote{On modern INTEL 64 processors
all aligned write are atomic and {\tt *ATOMIC* *POST-WRITE*} can be implemented
by a normal write \underline{preceded} by a {\tt SFENCE} instruction.  In
addition optimized code must not execute {\tt *ATOMIC* *POST-WRITE*}
before executing preceding write statements.}
\end{indpar}

\end{indpar}

These atomic builtin functions can be used by themselves to
implement a shared complex database with a single writing process.
The database is protected by two \TT{uns32} aligned version numbers
called the pre-version and the post-version.  When no update operation
is in progress, these are equal.  The writer adds one to the pre-version
at the very beginning of the update, and adds one to the post-version
at the very end of the update.  A reader reads the post-version at
the very beginning of a read operation, and then at any point can
read the pre-version and check that it matches the post-version value
read to see if there has been any writing during the read operation.
Thus the read operation can check at any point
whether the values read so far are consistent.%
\footnote{This is an old method that appears, for example, in 
an article of Leslie Lamport, `Concurrent Reading and Writing',
Communications of the ACM, vol 20, no 11, pp 806--811, Nov 1977.
A variant uses a single version value incremented at both the
beginning and end of an update so this value is odd during the update
and even when no update is in progress.}

The code has the form:
\begin{indpar}\begin{verbatim}
*WRITABLE* pointer pre-version = ...
*READABLE* pointer post-version = ...
  // 2 pointers each with a single aligned uns32 element

. . . . . . . . . .

// Write operation
//
*ATOMIC* *PRE-WRITE* ( (* pre-version) + 1, pre-version )
. . . . perform update operation
*ATOMIC* *POST-WRITE* ( (* post-version) + 1, post-version )



// Read operation in a different process(or)
//
uns32 version = *ATOMIC* *PRE-READ* ( post-version )
. . . . perform read operation
if ( version != *ATOMIC* *POST-READ* ( pre-version ) )
    .... take action on read failure   ....
    .... (e.g., repeat read operation) ....
\end{verbatim}\end{indpar}

This code has two flaws:
\begin{itemize}
\item[(1)] If the reader and writer are in different
processes of the same processor, and the reader interrupts the writer
during an update, the read operation cannot succeed and will (typically)
spin forever.  His is known as \key{priority inversion} (writer must
have equal or higher priority than reader).  One simple fix is to lock
out interrupts during the entire write operation.

\item[(2)] If the reader and writer are on different processors, and
the write update takes a long time, the read operation cannot complete
during the write update, and will (typically) spin for the duration
of the update.  One simple fix is to minimize the duration of the
write operation.
\end{itemize}

These problems can be addressed by re-writing the write update
using an {\em atomic-block} as follows:
\begin{indpar}\begin{verbatim}
// Write operation, single process writer
//
uns32 next-version = (*ATOMIC* *PRE-READ* post-version) + 1
... compute values to be written ...
... and locations to write them to ...
... (but do NOT write any locations) ...
atomic code c, uns32 pass, uns32 index = *ATOMIC*:
    *ATOMIC* *PRE-WRITE* next-version, pre-version
    ... perform update operation writes (no reads) ...
    *ATOMIC* *POST-WRITE* next-version, post-version
\end{verbatim}\end{indpar}

Here all the write operations are collected together in the
the {\em atomic-block}, so from the point of view of readers,
the {\em atomic-block} is the update operation.  It is as short
as possible, as it only contains the writes.  In addition,
interrupts are disabled in an atomic block, so interrupts are
disabled during the update operation.

The atomic block actually executes in three passes.  Pass 1 `compiles'
the block code (the write instructions) and stores the result in
the operating system kernel.  This result is in two parts: code and
parameters.  Both are checked by the kernel at the end of pass 1.
If a particular {\em atomic-block} is executed many
times, the code is cached so it need be compiled and checked only once.

Pass 2 checks that the write instructions access writable memory pages,
but does no actual writes.

Pass 3 executes the write instructions in order.

Interrupts are disabled at the beginning of pass 2 and re-enabled when
the atomic block terminates (either on success or an operation failure
in pass 2).

The \TT{atomic code} returned by the {\em atomic-block} will indicate
whether the block succeeded or suffered an operation error.  There
are two kinds of operation error.  A pass 1 error is an unaligned
atomic write address (non-atomic writes need not be aligned).  A pass 2
error is an address that if used to write will cause a memory fault.
In each error case the pass number and the index of the instruction within
the {\em atomic-block} (\TT{1},\TT{2}, \ldots) is returned.

If there are now several processes that can write the database, the
write update operation code needs to be changed so something like:
\begin{indpar}\begin{verbatim}
// Write operation, multiple process writers
//
uns32 version = *ATOMIC* *READ* post-version
// Read phase of update: like a read operation
... read database to compute values to be written ...
... and locations to write them to ...
... (but do NOT write any locations) ...
...
atomic code c, uns32 pass, uns32 index = *ATOMIC*:
    *LOCK* ...
    *COMPARE* version pre-version
    *ATOMIC* *PRE-WRITE* version + 1, pre-version
    ... perform update operation writes (no reads) ...
    *ATOMIC* *POST-WRITE* version + 1, post-version
\end{verbatim}\end{indpar}

Here the {\tt *LOCK*} instruction sets a test-and-set lock bit that
locks out other writers.  Then the {\tt *COMPARE*} instruction
ensures that the {\tt pre-version} matches the {\tt post-version}
read when the update
started (if it does not, that would mean that some other writer updated the
database during the read phase of the update, and the update is
no longer valid).  Both these instructions are executed in pass 2.
Lastly the write instructions are executed as before, with the actual
writes being done in pass 3.

Now there are possible failures other than an operation error:
a lock may not be acquirable or a compare may fail.  If this happens
(in pass 2) a failure \TT{atomic code} is returned
(instead of an operation error code), along with the index of the
failing instruction (and no writes are executed).

Any locks acquired are released when the {\em atomic-block} terminates
(successfully or otherwise)
in the reverse order to that in which they were acquired and before
interrupts are re-enabled.

A transaction can also update several databases at once using a single
{\em atomic-block}.  Each database
may have its own pre- and post- version variables and its own lock,
in which case there will be one {\tt *LOCK*} and one {\tt *COMPARE*}
instruction in the {\em atomic-block} for each database.  Locks and
version variables may also be shared among databases.

Clearly {\em atomic-blocks} generalize
the classic compare-and-set instruction.
However, they are not meant for updates that have a large number of
writes, as these are best handled by using {\em atomic-blocks} to construct
queues of processes waiting to do updates or read the database.

The rest of this section describes the syntax and semantics
of general {\em atomic-blocks}.

The syntax is:

\begin{indpar}
\emkey{atomic-block} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        {\tt atomic code c, uns32 pass, uns32 index = \ttakey{ATOMIC}:} \\
	\TT{~~~~}{\em atomic-instruction}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{atomic-instruction}
    \begin{tabular}[t]{cl}
    ::= & {\em lock-instruction} \\
    $|$ & {\em compare-instruction} \\
    $|$ & {\em write-instruction} \\
    \end{tabular}
\\[0.5ex]
\emkey{lock-instruction} ::= \ttakey{LOCK} {\em lock-ID} \\
\emkey{compare-instruction} ::= \ttakey{COMPARE} {\em atomic-value}
						  {\em atomic-pointer} \\
\emkey{write-instruction} ::= {\em ordinary-write-instruction}
                          $|$ {\em atomic-write-instruction} \\
\emkey{ordinary-write-instruction} ::= 
        \ttakey{WRITE} {\em atomic-value} {\em atomic-pointer} \\
\emkey{atomic-write-instruction} ::= {\em atomic-pre-write-instruction}
                              $|$ {\em atomic-post-write-instruction} \\
\emkey{atomic-pre-write-instruction} ::= \\
\hspace*{0.5in}{\tt uns32 r =
    \ttalkey{ATOMIC}{PRE-WRITE}} {\em atomic-pointer} \\
\emkey{atomic-post-write-instruction} ::= \\
\hspace*{0.5in}{\tt uns32 r =
    \ttalkey{ATOMIC}{POST-WRITE}} {\em atomic-pointer}
\\[0.5ex]
\emkey{lock-ID} ::= {\em expression} evaluatable with target type \TT{uns32} \\
\emkey{atomic-value} ::= {\em expression} evaluatable to the \TT{.type}
			of the associated {\em atomic-pointer} \\
\emkey{atomic-pointer} ::= {\em expression} evaluatable with \TT{pointer} type

\begin{indpar}
Pointer {\tt .type}'s must have a numeric type as their underlying type
and pointers must point at vectors with a single element.
For {\em compare-instructions} and {\em atomic-write-instructions},
the {\tt .type} must be \TT{uns32}, and the
vector element address must be aligned on a {\tt size of uns32}
byte boundary.
\end{indpar}

\end{indpar}

The atomic codes are defined by:

\begin{indpar}

{\tt
define type \ttstdkey{atomic code} as uns32 with enum [0~..] \\
define \begin{tabular}[t]{@{}l@{}}
       abbreviation \\
       \ttkey{atomic code} \ABV{} `std atomic code' \\
       \end{tabular} \\
atomic code \ttstdkey{success atomic code } = next enum // 0 \\
function std atomic code r = std \ttmkey{success}{atomic code}: \\
\hspace*{3em}r = std success atomic code \\
atomic code \ttstdkey{fail atomic code } = next enum // 1 \\
function std atomic code r = std \ttmkey{fail}{atomic code}: \\
\hspace*{3em}r = std fail atomic code \\
atomic code \ttstdkey{op error atomic code } = next enum // 3 \\
function std atomic code r = std \ttmkey{op error}{atomic code}: \\
\hspace*{3em}r = std op error atomic code
}

\end{indpar}

{\em Atomic-blocks} are executed in three passes:

\begin{indpar}[0.6in]
\hspace*{-0.3in}{\bf Pass 1, Compilation Pass}:
This is executed as normal code, and in fact each {\em atomic-instruction}
translates into a call to a builtin unpublished function.  These functions
do some checking and compile the {\em atomic-instructions} into a block
of kernel code.

At the end of pass 1, this kernel code is loaded into the operating
system kernel and checked by the kernel.
If an {\em atomic-block}
is part of an out-of-line routine that is executed many times, compilation
of the kernel code, passing this code to the kernel, and checking the
code in the kernel, may only need to be done once.

Pass 1 also compiles a parameter block for the kernel code, and at the end
of pass 1, loads the parameter block into the kernel.  The kernel does
also checks the parameter block.  The parameter block, which encodes the
argument values of the {\em atomic-instructions}, must be compiled
individually for every
{\em atomic-block} execution.

\hspace*{-0.3in}{\bf Pass 2, Test Pass}: Asynchronous interrupts are
disabled at the beginning of pass 2, and are not re-enabled until
the {\em atomic-block} terminates.

Pass 2 executes all the {\em atomic-instructions} in order, except that
{\em write-instructions} are executed in \key{write-check} mode.
In this mode {\em write-instructions} check that the locations
they are to write are writable, but do not actually change these locations.

\hspace*{-0.3in}{\bf Pass 3, Write Pass}: 
{\em Write-instructions} are re-executed in order and each writes its
{\em atomic-value} into the locations designated by its
{\em atomic-pointer}.

If the {\em atomic-block} does not
terminate before executing pass 3, the block will succeed.
Failures and operation errors cannot be discovered during pass 3.

When the {\em atomic-block} terminates, either successfully or
on failure or operation error,
any locks acquired are released in the opposite order
to that in which they were acquired, and interrupts are then re-enabled.

Upon successful termination, the returned values are:
\begin{center}
{\tt atomic code = success},~~~~ {\tt pass = }undefined,~~~~
{\tt index = }undefined
\end{center}
\end{indpar}

The {\em atomic-instructions} are as follows:
\begin{indpar}[0.4in]
\hspace*{-0.2in}{\em \bf Lock-Instruction}\index{lock instruction}.
The {\em lock-ID} is of type \TT{uns32}
and identifies the lock.
The lock is a binary (1-bit equivalent) test-and-set lock provided by the
underlying runtime system.  Locks are allocated to groups of processes
that share memory, so that if any process in the group acquires
the lock, other processes in the group cannot.  Lock-IDs are allocated
by the runtime system using an interface that is not part of the L-Language.%
\footnote{On modern INTEL 64 processors one might use a bit test-and-set
instruction for a lock and allocate each lock its own cache line.}

In pass 1 a {\em lock-instruction} checks that the lock-ID is valid
for the current process.  It is an operation error if it is not.
The lock is \underline{not} set in pass 1.

In pass 2 a {\em lock-instruction} sets the lock and succeeds if the lock
was not already set, and otherwise fails.  If the instruction succeeds,
it will have set and thereby acquired the lock.

In pass 3 {\em lock-instructions} do nothing.

Locks are acquired in the order that their {\em lock-instructions} appear
within the {\em atomic-block}.
When the {\em atomic-block} terminates, either
successfully or when it fails or has an operation error,
all locks acquired are released in reverse order.

The implementation ensures values read and written by instructions
following a {\em lock-in\-struc\-tion} are read from system memory or
written to system memory \underline{after} the {\em lock-in\-struc\-tion}
has written its lock bit to system memory.%
\footnote{On some computers lock bit memory may not be main RAM memory,
and on these we extend the notion of `system memory' to include
non-RAM lock bit memories.}%
\footnote{On modern INTEL 64 processors this may be done by following
each sequence of lock instructions by a {\tt MFENCE} instruction.}

\hspace*{-0.2in}{\em \bf Compare-Instruction}\index{compare instruction}.
The {\em compare-instruction} reads the \TT{uns32}
value of the only element of the {\em atomic-pointer} designated
vector and compares it to the {\em atomic-value}.  The instruction
succeeds if the values are equal, and fails otherwise.

In pass 1 the vector pointed at by the {\em atomic-pointer} is checked
to ensure that it has
only one element and the address of that element is a multiple of
the size of an \TT{uns32} value.  It is an operation error if this
check fails.

In pass 2 the vector element value is read atomically from memory and
compared with the {\em atomic-value}.  If the values are equal, the
{\em compare-instruction} succeeds; otherwise it fails.  The instruction
may also have an operation error in pass 2 if it tries to read
inaccessible memory.

In pass 3 {\em compare-instructions} do nothing.


It is a compile error if the {\em atomic-pointer}
does not have the {\tt *READABLE*} qualifier or does not have
the \TT{uns32} {\tt .type}.


\hspace*{-0.2in}{\em \bf Write-Instructions}\index{write instruction}.
Write instructions write values into memory in pass 3.

In pass 1 the vector pointed at by the {\em atomic-pointer} is checked
to ensure that it has only one element, and for atomic write instructions,
the address of that element is additionally checked to ensure
that it is a multiple of
the size of an \TT{uns32} value.  It is an operation error if one or both
of these checks fails.

In pass 2 the vector element is in effect read and rewritten with its
current value: i.e., the value is not changed, but a check is made that
the value is writable into the element.\footnote{On modern INTEL 64
processors
this may be done by {\tt CHPXCHG} instructions with equal compare and write
values.}

In pass 3 the {\em atomic-value} is written to the vector element.
For atomic writes, the write to system memory is atomic.
The implementation ensures that all the {\em write-instructions}
following an {\tt *ATOMIC* *PRE-WRITE*} write to system memory
\underline{after} the value written by the
{\tt *ATOMIC* *PRE-WRITE*} has been written to system memory.
The implementation ensures that all the {\em write-instructions}
preceding an {\tt *ATOMIC* *POST-WRITE*} write to system memory
\underline{before} the value written by the
{\tt *ATOMIC* *POST-WRITE*} is been written to system memory.

It is a compile error if the {\em atomic-pointer}
does not have the {\tt *WRITABLE*} qualifier or does not have
the \TT{uns32} {\tt .type}.  The pointer need not have the
{\tt *READABLE*} qualifier, but the pages with the element must be readable
in order for the pointer to pass the check in pass 2.
\end{indpar}

The returned {\tt atomic code} indicates whether the {\em atomic-block}
succeeded, failed, or had an operation error.
If the block is terminated by an operation error
or instruction failure, the {\em pass} and {\tt index} values identify
the pass and instruction that had the error or failure.
{\tt Index} value \TT{1} corresponds to the first instruction in the block.

A system may put restrictions on the number of {\em atomic-instructions}
in an {\em atomic-block}.  Violation of these restrictions
is a pass 1 operation error that returns \TT{0} as the {\tt index}.
At least 32 {\em atomic-instructions} will be
allowed in all implementations.


\section{Memory Channels}
\label{MEMORY-CHANNELS}

OLD STUFF: REVISE.

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
structured set of elements each associated with a member of
some data set.  Each window element contains a
\key{block descriptor} that holds the address and length of the
memory block that contains the data associated with the element.
Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
The window has a \key{reference point}, and window elements are addressed
relative to this reference point.  There are shift operations that move
the reference point to a nearby window element.

Although we talk about blocks here, a block can be just a numeric array
element, and can be as small as a single bit.  Although we talk about
each element of a memory channel window having its own block descriptor,
an actual memory channel may use only block group descriptors, each of
which functions as a group of more than one individual element
block descriptor.

A memory channel is stored in a cluster.  As such it is mostly an
inline construction, though it can be passed to or returned from a
function, and the function can be all or partly out-of-line.

The most common type of memory channel has a window that appears to be
an array with \ttikey{.di\-men\-sions}{dimensions!of memory channel},
\ttdmkey{lower\_bound}{of memory channel}\TT{[}$i$\TT{]},
and \ttdmkey{upper\_bound}{of memory channel}\TT{[}$i$\TT{]}
being memory channel members.  Such are called
\key{array windows}.
If the memory channel cluster name is $M$, the window elements are
referred to by $M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]},
with $M$\TT{[0,0,}\ldots\TT{]} being the \key{reference point}.

The reference point can be shifted along any of the window's
dimensions by the command
\begin{center}
$M$\ttdkey{center}\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]}
\end{center}
This shifts
the window so that what was
$M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]} becomes
$M$\TT{[0,0,}\ldots\TT{]}.

Creating memory channels and completely resetting their reference points
are specific to the type of memory channel, and are not covered in
this section.

For most kinds of memory channels, block descriptors are computed
automatically when channel is created, when the window is
shifted, or when the data of
a neighboring window element is arrives from memory.
Immediately after a block descriptor is created, a read-ahead of
the block is initiated.  This read-ahead overlaps computation that
does not use the block contents.

If a memory channel accesses arrays stored in memory,
the channel block descriptors can be computed from the array coordinates
of the reference point.  Other memory channels use the contents
of a block to compute the block descriptors of neighboring blocks
in the window.

An example of the latter is a binary tree memory channel.
Let $M$ be such a channel, and let `\TT{.L}' denote the left
child of a binary tree element, `\TT{.R}' the right child, and
`\TT{.P}' the parent.  Then $M\!$\TT{.L.R} denotes the right
child of the left child of the reference point, $M\!$\TT{.P.L}
denotes the left child of the parent of the reference point,
and $M\!$\TT{.P.L.center} moves the reference point to this last element.
The window of such a memory channel might contain the depth 2
subtree of the reference point plus that closest 4 ancestors of the
reference point if these have been visited.  When the reference
point is moved, as soon as the reference point element has been
read from memory, the descriptors for its children are built and
the read of the children is initiated in parallel with other
computation.  When the children arrive from memory, the descriptors
of their children are built and reads of the data pointed at
are initiated.\footnote{All this can actually be done with modern
hardware: code is executed to read the reference point children and initiate the
reads of their children, and a modern processor will automatically
save the code that
executes when a read of a reference point child completes and execute
other code in parallel until the read does complete.}

Some standard memory channel types are built into the L-Language.
Others can be defined by users.

\section{To Do}

How can dynamically initialized locations be static.

Indirect address protocol.

Define `compile-time function' as a function that can only be
called at compile-time.

Add `\TT{no} {\em prototype-term}' as a way of saying
`{\em prototype-term} \TT{( false )}'.

If \TT{V} is the name of a repeatable variable (that may also
be omittable), then:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt unsadr V.\ttmkey{count}{of {\tt variable name}} } \\
Number of of times the variable name \TT{V} appears in the unfolded
pattern.  This is the number of times the {\em pattern-term} containing
the variable appears.  It is \TT{1} if the term is neither
replicated or omitted, and \TT{0} if it is omitted.

\hspace*{-0.3in}{\tt $T$ V\ttmkey{[$i$]}{of {\tt variable name}} } \\
The value of the $i$+1'st occurrence of \TT{V} in the unfolded pattern.
The index $i$ may be computed at run time, and has the range
\TT{0~..~V.count-1}.
$T$ is the type of the variable given in the {\em pattern-term}.
It is an error to use an index value that is out of range.


\end{indpar}

If \TT{V} is the name of a variable that may be omitted but not
repeated, then:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt bool V.\ttmkey{present}{of {\tt variable name}} } \\
True if the variable is present, and false if not.

\end{indpar}

In addition, if a variable can be omitted but not repeated, a default expression
must be given for the variable in a `\ttkey{defaults to}'
{\em conditioning-expression}.%
\label{DEFAULTS-TO}
If the variable \TT{V} is omitted, this
expression will be used at run time to compute the variable's value,
and `\TT{V.present}' will be set to `\TT{true}'.

\label{INDIRECT-ADDRESS-PROTOCOL}

Threads.
\label{THREADS}

\appendix

\section{Aliasing Hardware}
\label{ALIASING-HARDWARE}

The ultimate solution to the aliasing problem is new hardware.
At its simplest, registers, which currently hold a datum,
are replaced by triples of registers which hold a datum,
an address, and selection codes.  The register datum equals the value
of the memory location at the register address.  The selection
codes determine which part of this memory location is read or written
when the register is read or written.  If any memory location is
changed, the address of the location is checked against all the
register addresses, and if any match, the corresponding register
data are changed.

This is, however, not sufficient, because sometimes one register
address is a function of another register's datum.  For example,
consider the unchecked code:
\begin{indpar}[0.5em]\begin{verbatim}
struct S { ...; int32 m; ... }
S * * x
S * *& y = * x
int32 *& z = y->m
\end{verbatim}\end{indpar}
If we consider \TT{x}, \TT{y}, and \TT{z} to be registers,
the address of \TT{y} equals the value of \TT{x}, and the
address of \TT{z} equals the value of \TT{y} plus the offset of
\TT{m} in \TT{S}.

If the value of \TT{x} changes, this changes the address of \TT{y},
which may change the datum of \TT{y} and that may change the value
of \TT{y}.  If the value of \TT{y} changes, this changes the address
of \TT{z}, which may change the datum and value of \TT{z}.

The way we accommodate this is to use the selection codes of \TT{y}
to specify that the address of \TT{y} contains the value of \TT{x}
as an additive component, so
that if the value of \TT{x} is changed by adding $\Delta$\TT{x}
then the address of \TT{y} should be changed by adding $\Delta$\TT{x}.
And similarly the selection codes
of \TT{z} specify that the address of \TT{z}
contains the value of \TT{y} as an additive component.

So why should we bother with automatically updating
additive inclusions of one value in the
address of another value, and not bother with other expressions.
The reason is that expressions such as
`\TT{(*x)->m}' are likely to be reused frequently in code (actually,
in automatically generated code) and
therefore need to be cached, whereas an expressions of the form
`\TT{c*d}' will be reused comparatively rarely code
and therefore are not worth special hardware.


\bibliographystyle{plain}
\bibliography{layered-l-2012-language}

\printindex

\end{document}

