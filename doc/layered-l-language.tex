% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\TBDref}[1]{??}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

November 26, 2011
 
\end{center}

{\small \tableofcontents}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language.  See the Introduction to the Layered
Programming Languages for basic syntax and for an overview of the related
Middle Layer M-Language and Higher Layer H-Language.

Here we will give brief overviews of some of the principle issues
addressed by the L-Language.


\subsection{Code Targeting}

The L-Language is intended to be a target language for compilers of
higher level languages.  As such it is optimized first to be an easy to 
use and adequate target language, and second to be reasonably easy to
compile into efficient assembly language code.

The L-Language is similar to the C programming language
but has additional features intended to give
more control over compilation and more type safety in the use, but
not the declaration, of data.  The L-Language depends upon its powerful
macro facility to allow users to define type safe data declaration
macros.

\subsection{Code Computation}

The L-Language permits code to be computed by executing programs, and then
compiled and run.  The computed code can be an entire function, or can
be embedded within a function.

A main reason for this is to support scientific computing in which
code specific to a task must be computed and then optimized.

\subsection{Data Declaration}

The L-Language supports low level declaration of data and fairly high
level type safe optimized usage of declared data.  The L-Language also
supports macros written in the high level H-Language that extends the
L-Language, permitting very
capable macros to be written by users to give users high level
type-safe data declaration facilities tailored to specific kinds of data.

The thesis here is that a high level data declaration language that is
type safe and efficient for all kinds of data is not practical.
So instead tools are provided to create data declaration sublanguages that are
type safe and efficient for more limited kinds of data.

One way of explaining our approach is to say that we are taking the normal
division of programming into two layers, \key{system programming}
and \key{application programming}, and we are adding a third
layer in-between: \key{application system programming}.  This last
kind of programming uses basic and sometimes type unsafe tools to build
advanced and type safe tools for a particular application area, such
scientific programming, business accounting,
programming with particular data structures, and so forth.


\section{Memory}
\label{MEMORY}

We begin with an overview of L-Language memory, and then provide
details in the following subsections.

TBD

\subsection{Numbers}

\ikey{Numbers}{number} are a basic element of L-Language memory.
Numbers are sequences of bits, and each number is one of
four types, unsigned integer, signed integer, floating point number,
and address:

\begin{indpar}
\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\bf Name & \bf Kind & \bf Length \\[2ex]
\ttkey{uns8}		& unsigned integer & 8 bits \\
\ttkey{uns16}		& unsigned integer & 16 bits \\
\ttkey{uns32}		& unsigned integer & 32 bits \\
\ttkey{uns64}		& unsigned integer & 64 bits \\
\ttkey{uns128}		& unsigned integer & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{int8}		& signed integer & 8 bits \\
\ttkey{int16}		& signed integer & 16 bits \\
\ttkey{int32}		& signed integer & 32 bits \\
\ttkey{int64}		& signed integer & 64 bits \\
\ttkey{int128}		& signed integer & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{float16}		& IEEE floating point number & 16 bits \\
\ttkey{float32}		& IEEE floating point number & 32 bits \\
\ttkey{float64}		& IEEE floating point number & 64 bits \\
\ttkey{float128}	& IEEE floating point number & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{adr}		& address & 32 bits or 64 bits (see text) \\
\ttkey{unsadr}		& unsigned integer & size of address \\
\ttkey{intadr}		& signed integer & size of address \\
\end{tabular}
\end{indpar}

The \mkey{length}{of number}
of a number is the number of its bits.  Numbers can have
different lengths: for example, unsigned integers can have
lengths of 8, 16, 32, 64, or 128 bits.

Numbers are stored in random access memory (RAM).

An \key{unsigned integer} of length $L$ is a binary integer with
$L$ binary digits (\skey{bit}s).

A \key{signed integer} of length $L$ is a two's complement integer
of length $L$.  This represents an integer $I$
by the unsigned $L$-bit integer equal to $I~\mbox{modulo}~2^L$.

A \key{floating point number} of length $L$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes is as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l}
\bf Floating Point \\
\bf Number Size & \bf Exponent Size & \bf Mantissa Size \\[2ex]
16 bits & 5 bits & 10 bits \\
32 bits & 8 bits & 23 bits \\
64 bits & 11 bits & 52 bits \\
128 bits & 15 bits & 112 bits \\
\end{tabular}
\end{center}

An \key{address} (a.k.a. a `\key{pointer}') holds a RAM byte address.
A address is a 32-bit or 64-bit unsigned integer whose size
is determined by the target machine.  Some of high order bits may be
required to be all 0's or all 1's, depending upon
the target machine.  The \verb|unsadr| and \verb|intptr|
unsigned and signed integer types of the same size
as a address are provided for storing indices and offsets.

A reasonable assumption for 64-bit addresses is that only the low
order 48-bits of the address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing an address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The L-Language does
\underline{not} depend upon this assumption, but does provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$.  The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.

Variables can be declared to be of non-address numeric type
by declarations of the form
\begin{center}
{\em type-name} {\em variable-name} {\tt ;}
\end{center}
For example,
\begin{indpar}\begin{verbatim}
int32 i;
uns128 u;
float64 f;
\end{verbatim}\end{indpar}

Variables can be declared to be of address type by declarations of the form
\begin{center}
{\tt adr} {\em variable-name} {\tt ->} {\em variable-declaration} {\tt ;}
\end{center}
For example,
\begin{indpar}\begin{verbatim}
adr ip1 -> int32;
adr ip2 -> int32 i2;
adr ipp3 -> adr ip3 -> int32 i3;
\end{verbatim}\end{indpar}
declare variables {\tt ip1} and {\tt ip2} that store
the address of an {\tt int32} variable, and a variable
{\tt ipp3} that stores the address of a variable that stores
the address of an {\tt int32} variable.
The unary `{\tt *}' operator is used to reference the variable
pointed at by an address, so
here
`\verb|* ip1|',
`\verb|* ip2|',
`\verb|i2|',
`\verb|** ipp3|', `\verb|* ip3|',
and `\verb|i3|' reference
an {\tt int32} integer variable, while
`\verb|ip1|', `\verb|ip2|'
`\verb|* ipp3|', and `\verb|ip3|',
reference an {\tt adr} variable that stores the address of
an {\tt int32} variable.

Some of the names in address type variable declarations may be omitted,
as in
\begin{indpar}\begin{verbatim}
adr ip -> int32;
adr    -> int32 i;
\end{verbatim}\end{indpar}

In both these cases the value stored in the variable is the address
of a 32-bit integer.  However, {\tt ip} names the address and
{\tt i} names the integer.  The unary `{\tt \&}' operator is the inverse
of `{\tt *}', so `{\tt * ip}' can be used to name the
integer, and `{\tt \& i}' can be used to name the address.
Either of these names can be used to assign values, as in
\begin{indpar}\begin{verbatim}
* ip = 5;
& i = ip;
\end{verbatim}\end{indpar}

Variable declarations are actually short forms for the declaration
of constant addresses.  For example, the local variable declarations
\begin{indpar}\begin{verbatim}
int32 i;
stack adr ip -> int32;
\end{verbatim}\end{indpar}
are equivalent to
\begin{indpar}
{\tt constant stack adr =} {\em some-stack-address} {\tt -> int32 i;} \\
{\tt constant stack adr =} {\em some-stack-address}
                           {\tt -> stack adr ip -> int32;}
\end{indpar}

so that `{\tt ip = \& i}' is a legal assignment.  The compiler arranges
for appropriate stack addresses to be computed.  `{\tt \& i}' and
`{\tt \& ip}' are `{\tt constant}', and so cannot be changed, and also
`{\tt stack}', meaning that they have a lifetime only as long as the
current stack frame.

Note that if `{\tt stack adr ip}' were changed to
`{\tt adr ip}' the assignment `{\tt ip = \& i}' would no longer be
legal, because the lifetime of `{\tt \& i}' is shorter than the
indefinite lifetime promised by `{\tt adr ip}' unqualified by `{\tt stack}'.

\subsection{Subtypes}

A subtype of a parent type is a type whose values are formatted
and aligned in the same manner as values of the parent type and
which can be implicitly converted to or from the parent type by
unchecked code.  It is also possible to define checked conversion
functions.

One use of a subtype is to make a promise that a value
is in a given range.  The following is an example of a subtype
that has the range {\tt 0 .. max\_index-1}:

\begin{indpar}\begin{verbatim}
defsubtype indexint int;

extern int max_index;

inline indexint .conversion. ( int i ) unchecked:
    assert ( 0 <= i && i < max_index );
    return i;

inline int .conversion. ( indexint i ) unchecked:
    int j = i;
    fact ( 0 <= j && j < max_index );
    return j;

float64 x[max_index];
float64 getx ( indexint i ) = x[i];
\end{verbatim}\end{indpar}

Here `{\tt x[i]}' will expand to code containing an implicit
conversion of {\tt i} from {\tt indexint} to {\tt int}
and also a check that {\tt i} is in the proper range to be
in index of {\tt x}, so the code expansion will contain:
\begin{indpar}\begin{verbatim}
    fact ( 0 <= i && i < max_index );
    assert ( 0 <= i && i < max_index );
\end{verbatim}\end{indpar}
The `{\tt fact}' statement allows the `{\tt assert}' statement
to be optimized away.

A second use of a subtype is to reserve values of the parent type
for special meaning.  For example, an {\tt adr} address value
in the range from 0 through 4095 might be interpreted as an
integer and not
an address, under the assumption that low addresses are not
used by the memory system.  A example of subtypes implementing
this is:
\begin{indpar}\begin{verbatim}
defsubtype special unsadr;

inline special .conversion. ( unsadr x ) unchecked:
    assert ( x < 4096 );
    return x;

inline unsadr .conversion. ( special x ) unchecked:
    fact ( x < 4096 );
    return x;


defsubtype specialadr adr;

inline bool is_special ( specialadr a ) unchecked:
    unsadr x = a;
    return x < 4096;

inline adr .conversion. ( specialadr a ) unchecked:
    unsadr x = a;
    assert ( x >= 4096 );
    return a;

inline special .conversion. ( specialadr a ) unchecked:
    unsadr x = a;
    assert ( x < 4096 );
    return x;

inline specialadr .conversion. ( adr a ) unchecked:
    unsadr x = a;
    assert ( x >= 4096 );
    return a;

inline specialadr .conversion. ( special a ) unchecked:
    return a;

float64 x;
stack specialadr y = & x -> float64;
stack specialadr z = 23;
assert ( ! is_special ( y ) );
assert ( is_special ( z ) );
float64 x2 = * y;
float64 z2 = * z;  // Causes assert violation error!
\end{verbatim}\end{indpar}

\subsection{Random Access Memory (RAM) and Blocks}

\ikey{RAM}{Random Access Memory}\index{random access memory!RAM}
is a set of address/byte pairs.  Each 8-bit byte of RAM has an \key{address}
that is a unsigned integer.  It is possible for two addresses to refer to the
same byte, or for an address to refer to no byte.  An address that
refers to a byte is said to be \key{allocated}, and an address that refers
to no byte is said to be \key{deallocated}.  A byte that has two (or more)
distinct
addresses is said to be \key{shared}, and a byte with just one address is
\key{unshared}.

A \key{RAM block}\index{block!of RAM} is a sequence of RAM bytes with
consecutively increasing addresses.
The \mkey{origin}{of block} of the block is the first address,
and the \mkey{length}{of block} of the block is the number of bytes.

A RAM block is \mkey{allocated}{block}
if the addresses of all its bytes are allocated,
and is \mkey{deallocated}{block} if the addresses of all of its bytes
are deallocated.
A RAM block is \mkey{unshared}{block} if all its bytes are unshared.
A RAM block is \mkey{shared}{block} if
it is one of a set of several blocks (sequences of consecutive addresses)
such that the $n$'th byte of each block in the set is the same.
Note that a RAM block can be neither allocated or deallocated or
neither shared nor unshared; i.e., some of the block's bytes may be
allocated and some deallocated, or some may be shared and some unshared.

The address space is divided into \skey{page}s, which are RAM blocks that
have an implementation determined length that is a power of two,
e.g., 4096 byte pages, and an address that is an exact multiple of
this length.  There
are L-Language operations which call the operating system to
map an address page to physical memory, thus allocating a page
of RAM.  There are operations to deallocate a page, and to make
two pages be shared (map to the same bytes of RAM).

Pages are the units of allocation and sharing.  Each page of the
address space is either allocated or deallocated, and each page is
either shared or unshared.  The only way for an arbitrary RAM block to
have allocated bytes is to overlap an allocated page, and similarly
for deallocated bytes, shared bytes, and unshared bytes.

A \key{segment} is a contiguous sequence of pages all of which have
the same allocation and sharing status.

The builtin RAM blocks in L-Language are link blocks,
frame blocks (\pagref{CODE-AND-FRAME-BLOCKS}),
code blocks(\pagref{CODE-AND-FRAME-BLOCKS}), numbers, and segments.
All non-segment
blocks are contained within segments.  User defined (i.e., non-builtin)
blocks can be contained within segments.

User defined block data types may be declared by declarations of the form
\begin{center}
\ttkey{deftype} {\em type-name} {\tt (} {\em length}{\tt ,}
				        {\em alignment}{\tt ,}
				        {\em offset}
					{\tt )} {\tt ;}
\end{center}

The layout of a block of the defined type in memory is:

\begin{center}
\begin{picture}(4.0,1.6)
\put(2.0,1.5){\framebox(0.1,0.1){}}
\put(0.0,1.5){\makebox(1.5,0.1)[r]{origin}}
\put(1.6,1.55){\vector(1,0){0.3}}
\put(2.7,1.55){\vector(-1,0){0.5}}
\put(2.0,1.4){\framebox(0.1,0.1){}}
\put(2.0,1.13){\makebox(0.1,0.3){\vdots}}
\put(2.0,1.0){\framebox(0.1,0.1){}}
\put(2.0,0.9){\framebox(0.1,0.1){}}
\put(0.0,0.9){\makebox(1.5,0.1)[r]{address}}
\put(1.6,0.95){\vector(1,0){0.3}}
\put(2.5,0.95){\vector(-1,0){0.3}}
\put(2.4,1.25){\vector(0,1){0.3}}
\put(2.4,1.25){\vector(0,-1){0.3}}
\put(2.4,1.25){\line(1,0){0.6}}
\put(3.1,1.20){\makebox(0.5,0.1)[l]{\em offset}}
\put(2.0,0.8){\framebox(0.1,0.1){}}
\put(2.0,0.7){\framebox(0.1,0.1){}}

\put(2.0,0.43){\makebox(0.1,0.3){\vdots}}
\put(2.0,0.3){\framebox(0.1,0.1){}}
\put(2.0,0.2){\framebox(0.1,0.1){}}
\put(2.7,0.15){\vector(-1,0){0.5}}
\put(2.6,0.85){\vector(0,1){0.7}}
\put(2.6,0.85){\vector(0,-1){0.7}}
\put(2.6,0.85){\line(1,0){0.4}}
\put(3.1,0.80){\makebox(0.5,0.1)[l]{\em length}}
\end{picture}
\\[1ex]
address modulo {\em alignment} = 0
\end{center}

The \mkey{address}{of block} of the block is offset from the origin
of the block by the \mkey{offset}{of block} of block.  The address must be an
exact multiple of the \mkey{alignment}{of block} of the block.
The length of the block is an unsigned integer.  The alignment is an
unsigned integer equal to a power of two that defaults to {\tt 1}.
The offset is a signed integer that defaults to {\tt 0}.

A block can actually have bytes both before and after those described by
its type.  Thus the type specifies that every allocated block of the
type will contain allocated bytes at the addresses

\begin{center}
\begin{tabular}{l}
address - offset \\
address - offset + 1 \\
address - offset + 2 \\
\ldots\ldots\\
address - offset + length - 1
\end{tabular}
\end{center}

These are the \smkey{required byte}s{of a block} of the block.
In addition the block may contain \smkey{optional byte}s{of a block}
either before or after the required bytes.

Note that if the {\em offset} is negative, the block address does not
address a required byte, and may not address any block byte.  Similarly
if the {\em offset} is equal to or greater than the block {\em length}.


Blocks contain numbers (including direct addresses) and subblocks.
Access to these is provided by displacement values.  For example,
\begin{indpar}\begin{verbatim}
deftype type1 (48,8);
unchecked:
    disp member1 = 0 -> uns16 @ type1;
    disp member2 = 2 -> uns16 @ type1;
    disp member3 = 4 -> uns32 @ type1;
    disp member4 = 8 -> float32 @ type1;
    disp member5 = 12 -> adr @ type1 -> type1;
. . . . .
type1 x;
x.member1 = 9;
x.member2 = -19;
x.member3 = 190;
x.member4 = -0.01 * x.member3;
x.member5 = & x;
\end{verbatim}\end{indpar}

A type of the form
\begin{center}
{\em disp} {\tt ->} {\em type1} {\tt @} {\em type2}
\end{center}
denotes a displacement of a block of type {\em type1}
inside a block of type {\em type2}.  The displacement itself
is a signed integer with the same size and characteristics
as an {\tt intadr} signed integer.

A statement of the form
\begin{center}
{\em disp} {\em member-name} {\tt =} {\em value }
           {\tt ->} {\em type1} {\tt @} {\em type2}
\end{center}
assigns the {\em value} to the {\em member-name} variable
that has the above type.

Using {\tt =} to assign a signed integer to a displacement
variable is an unchecked operation that can be used only
in unchecked code, that is, in code
that permitted to avoid normal type checking
rules.

The type of the expression `{\tt x.member1}' is
\begin{center}
\tt constant stack adr -> uns16 V @ type1.member1
\end{center}
and \underline{not}
\begin{center}
\tt constant stack adr V -> uns16 @ type1.member1
\end{center}
The statement
\begin{center}
\tt x.member1 = 9;
\end{center}
therefore sets an {\tt uns16} integer variable, and
\underline{not} an {\tt adr} constant.  In these types
the {\em variable-name} {\tt V} is used to indicate which
value, the integer or the address, is the value of the expression.
This is the value that will be read if the expression appears to
the right of {\tt =} and written if the expression appears to the
left.  This value is also called the \key{value position} inside
the address type, and we say that {\tt V} specifies the value
position inside the address type.
Any other {\em variable-name} besides {\tt V} could be used
to specify the value position in an address type.

Notice that
the expression `{\tt x.member1}' has type
\begin{center}
\tt constant stack adr -> uns16 V @ type1.member1
\end{center}
and \underline{not}
\begin{center}
\tt constant stack adr -> uns16 V
\end{center}
The difference between the type `{\tt uns16 @ type1.member1}'
and the type `{\tt uns16}' is that the former specifies an
{\tt uns16} value that is inside a {\tt type1} value, and is
in fact at offset {\tt member1} inside that {\tt type1} value.
This extra information is only used by the compiler to determine
when variables can be aliased, so it is only used for optimization.
Nonetheless, if the information is incorrect,
optimization may not be done correctly, and the program may execute
erroneously (without detecting that it is doing so).


\subsection{Code and Frame Blocks}
\label{CODE-AND-FRAME-BLOCKS}

A \key{code block} is a sequence of executable program statements
and code subblocks.  Some code blocks are nested inside other
code blocks, and some are not.

A function is a code block whose execution is initiated by a
call statement.  The execution of the code block containing
the call statement is interrupted in order to execute the function
code block.  When the call returns, the interrupted execution
resumes.

Code block executions are grouped into threads.  At any time, only one code
block at a time may be executing statements within a given thread.

When a code block begins executing, a \key{frame}
is allocated to the \mkey{stack}{of thread} of the thread containing
the code block execution.  This frame is a RAM block that holds
data for the code block execution.  Thus there is a
1-1 correspondence between code block executions and frame blocks.
The frame block size can change during the code block execution.

A thread stack is a RAM block, and a frame is a
RAM subblock of the stack of
the thread that contains the code block execution associated with
the frame.  During the code block execution the end of this frame
is the end of the thread stack, and it is this end which can increase
or decrease thereby changing the size of both the stack and the frame.

Code blocks are sequences of lexemes, and are \underline{not} RAM blocks.
Associated with each code block is a \key{code RAM block} which is
the code block translated into machine code.  The code RAM block of
a code subblock need not be part of the code RAM block of the containing
code block, but must be associated with the latter.

\subsection{Block Types}
\label{BLOCK-TYPES}

There are three basic kinds of blocks: static blocks,
stack blocks, and heap blocks.

\ikey{Static blocks}{static block}
are never deallocated or relocated.  They can be \skey{link block}s that
are allocated when a program is loaded, or they can be
user allocated blocks that are never deallocated or relocated.

\ikey{Stack blocks}{stack block}
are allocated to thread stacks.  Frames
(\pagref{CODE-AND-FRAME-BLOCKS}) are stack blocks.
Stack blocks are allocated by a code block execution, and cannot
be deallocated until the code block execution terminates.
In some run-time systems frame blocks may be relocated.

\ikey{Heap blocks}{heap block}
are user allocated blocks that may be deallocated or relocated.
Usually they are garbage collectible.

All the heap blocks that are garbage collectible by the
same garbage collection algorithm are grouped together into
a `\key{heap}'.
For each heap there is a list of
static block locations that might hold pointers into
blocks in the heap.  And for each heap and each thread stack
there is a separate list of stack block locations
that might hold pointers into blocks in the heap.

Code RAM blocks may be static, stack, or heap blocks.

\subsection{Pointer Types}
\label{POINTER-TYPES}

The standard pointer type is {\tt adr}, which denotes an address.
But additional pointer types may be defined by
\begin{center}
\ttkey{defptr} {\em type-name} {\tt (} {\em length}{\tt ,}
				       {\em alignment}{\tt ,}
				       {\em offset}
				       {\tt )} {\tt ;}
\end{center}

This works just like {\tt deftype} but additionally declares
the defined type to be a pointer type.  As such it can be used
with that same syntax as `{\tt adr}' with the operators
`{\tt *}' and `{\tt \&}'.  An example is:

\begin{indpar}\begin{verbatim}
defptr ptr ( 64, 64, 0 );
void function1 ( ptr x -> int32, ptr -> mystruct y );
\end{verbatim}\end{indpar}

Here the first argument to {\tt function1},
{\tt x}, is a \verb|ptr| type pointer to an {\tt int32} value,
and the second argument is similarly a \verb|ptr| type pointer
to a {\tt mystruct} value designated by {\tt y}.

The operators `{\tt *}' and `{\tt \&}' are automatically
defined for pointer types and merely change these types by
moving the value position within the type.  Thus
\begin{center}
\begin{tabular}{lllll}
\tt *  & converts type & {\em pointer-type} {\tt V ->} {\em data-type}
       & to            & {\em pointer-type} {\tt ->} {\em data-type} {\tt V} \\
\tt \& & converts type & {\em pointer-type} {\tt ->} {\em data-type} {\tt V}
       & to            & {\em pointer-type} {\tt V ->} {\em data-type} \\

\end{tabular}
\end{center}

Conversion functions can be defined between pointer types.
Suppose `{\tt ptr}' is an indirect address, that is, the address of the
real adrress of the variable pointed at, and suppose the variable
is statically allocated.  This could be implemented
by the code:

TBD:

\begin{indpar}\begin{verbatim}
defsubtype ptr adr;

inline static adr .conversion. ( ptr p ) unchecked:
    adr p2 = p -> static adr; return * p2;
inline ptr .conversion. ( adr p -> static adr ) unchecked:
    return p;

static adr -> uns32 x allocate_uns32();
    // Declaration of function that returns a new statically
    // allocated variable.
static adr xp = & allocate_uns32() -> uns32;
    // xp has type stack adr -> static adr xp -> uns32.
ptr p = & xp -> uns32;
    // Implied conversion of stack adr V -> static adr -> uns32
    // to stack ptr p -> uns32.
uns32 y = * p;
    // Implied conversion of stack ptr p -> uns32 to
    // stack adr -> static adr -> uns32 and then dereference.
\end{verbatim}\end{indpar}

\subsection{Tuples}
\label{TUPLES}

A \key{tuple} is a sequence of zero or more values, where the values
need not all have the same type.  A tuple is \underline{not}
a first class datum; it cannot be stored in most kinds of memory.
Tuples are temporary data used to pass values to functions and
return values from functions.  A call to a function involves
at least two tuples, one holding the
\smkey{argument}s{of function} of the function
and another holding the \smkey{return value}s{of function} of the function.

It is also possible for one code block to transfer to another.
This is like a call in which the first code block execution
terminates just as the second code block execution begins.
A tuple can be transferred along with control.

Tuples may be \key{flattened}.  For example, 
`{\tt (1, 2, (3, 4), 5)}' is equivalent to
`{\tt (1, 2, 3, 4, 5)}'.  [TBD: more discussion, and special
treatment for cluster members.]

[TBD: what is the difference between input and output?]

\subsection{Clusters}
\label{CLUSTERS}

A \key{cluster} is a group of related variables.  One variable of
the cluster is the \mkey{base variable}{of cluster} of the cluster, and the
other variables have names that are derived from the
name of the base variable using the syntax:


\begin{indpar}
{\em variable-name} ::=
    {\em base-name} {\em member-selector}$^\star$ \\[1ex]
{\em member-selector} \begin{tabular}[t]{@{}rl}
    ::= & {\tt .}{\em member-name} \\
    $|$ & {\tt [}{\em member-index-list}{\tt ]}
    \end{tabular} \\[1ex]
{\em member-index-list} \begin{tabular}[t]{@{}rl}
    ::= & {\em member-index} \\
    $|$ & {\em member-index} {\tt ,} {\em member-index-list}
    \end{tabular} \\[1ex]
{\em member-index} ::= {\em integer-constant-expression}
\end{indpar}

Thus a cluster
is like a structure, but it is a set of variables and not a
piece of memory.

More specifically, the members of the cluster can be named by
adding either a member name preceded by `{\tt .}' or a
`{\tt []}' bracketed list of
integer constant subscripts to
either the base name of the cluster or to another member name
of the cluster.  Two variable names with different base names
belong to different clusters.  Two variable names allocated in
different scopes are in different clusters (a scope is a function,
a block within the function, the part of a package external to
functions, or a tuple).  Two variable
names with the same base name and scope are in the same cluster.

Clusters can be passed to functions and returned from functions.
For example:
\begin{indpar}\begin{verbatim}
// WARNING: This code is not completely type safe
//          because it does not use protection qualifiers.
//
// pp is a `pointer pair'
//   pp.begin points at the first element
//   pp.end points just AFTER the last element
//
// Function to allocate a vector of n int32's.
//
(void pp, int32 * pp.begin, int32 * pp.end )
    allocate ( uns32 n );
//
// Prefix operator to dereference a pointer pair.
//
int32 *& "*"
        ( void pp, int32 **& pp.begin, int32 **& pp.end )
    unchecked
{
    if ( pp.begin < pp.end ) return * pp.begin;
    else return * (int32 *) NULL;
}
//
// Prefix operator to increment the begin pointer of a pointer
// pair.
//
(void pp = pp ) "++" ( void pp, int32 **& pp.begin )
    unchecked
{
    ++ pp.begin;
}
//
// Example usage:
//
void my_function ( void )
{
    // Vector of 2 elements is allocated and the elements
    // are set equal to 100 and 101.
    //
    void pp = allocate ( 2 );
    * pp = 100;
    * ++ pp = 101;
    . . . .
}

\end{verbatim}\end{indpar}

This code is a bit extreme in that the base variable has type
{\tt void} indicating it has no actual value.  In this code
the {\tt allocate} function returns the cluster, and in the
example usage `{\tt void pp = allocate ( 2 );}' constructs
\underline{all} the members of the cluster returned by {\tt allocate}.
The member arguments to the prefix {\tt *} and {\tt ++} operators
are not given explicit values in calls to the operator functions,
but are implicitly defined from the first cluster base argument.
The argument list of a function is a tuple that is a scope so
clusters can be defined \underline{within} the argument list.
Similarly for the return value list.

The prefix {\tt ++} operator is unusual in that its declaration
indicates that it returns its first argument exactly, so that
the cluster base variable name is in effect returned.  This is
a stronger statement than just returning a {\tt *\&} value that
happens without the compiler's knowning it to be equal to the
{\tt *\&} value of the first argument.

\subsection{Arrays}
\label{ARRAYS}

Array variables can be declared by declarations of the form
\begin{center}
{\em type-name} {\tt *}$^\star$ {\tt \&}$^\star$ {\em variable-name}
	{\tt [} {\em dimension-spec}
	       \{ {\tt ,} {\em dimension-spec} \}$^\star$ {\tt ]}{\tt ;}
\end{center}
where
\begin{indpar}
{\em dimension-spec} ::= {\em bound-spec}~~{\em step-spec-option} \\[1ex]
{\em bound-spec} ::= {\em length}
    $|$ {\em lower-bound}~~{\tt ..}~~{\em upper-bound} \\[1ex]
{\em step-spec} ::= {\tt ++} {\em step}
\end{indpar}
For example,
\begin{indpar}\begin{verbatim}
int32 iarray[5];
int32 * piarray[1 .. 5];
int32 * & irarray[10,20];
int32 * & tirarray[10++1,20++10];
\end{verbatim}\end{indpar}

Here
\begin{itemize}
\item {\tt iarray[i]} is an {\tt int32} variable for {\tt i} =
{\tt 0}, {\tt 1}, {\tt 2}, {\tt 3}, and {\tt 4}.  The {\tt length}, which is
{\tt 5}, specifies the number of elements in the array's one dimension,
and array indexing begins at {\tt 0}.

\item {\tt piarray[i]} is a `direct address of {\tt int32}'
variable for {\tt i} =
{\tt 1}, {\tt 2}, {\tt 3}, {\tt 4}, and {\tt 5}.  The {\em lower-bound}
and {\em upper-bound} of the dimension index, {\tt 1} and {\tt 5} respectively,
are given.

\item {\tt \& irarray[i,j]}
is a `direct address of {\tt int32} variable', and
{\tt irarray[i,j]} is the {\tt int32} location so addressed,
for {\tt i} = {\tt 0}, {\tt 1}, \ldots, {\tt 9} and
for {\tt j} = {\tt 0}, {\tt 1}, \ldots, {\tt 19}, where the two
dimension {\em lengths} are given, respectively {\tt 10} and {\tt 20}.
The elements of the array are stored in {\tt 10*20} consecutive
memory locations that in memory order
have indices {\tt (0,0), (0,1), \ldots, (0,19),
(1,0), (1,1), \ldots, (9,19)}, with the last index {\tt j} varying
most rapidly.  This means that the implied step size of the first
dimension is {\tt 20} and of the second dimension is {\tt 1}.

\item {\tt tirarray[i,j]} is just like {\tt irarray[i,j]} but the
elements are stored in memory in transposed order:
{\tt (0,0), (1,0), \ldots, (9,0),
(0,1), (1,1), \ldots, (9,19)}, with the first index {\tt i} varying
most rapidly.  The step size of the first dimension is
given as {\tt 1} and of the second is given as {\tt 10}.

\end{itemize}

An array is a cluster such that

\begin{center}
\begin{tabular}[t]{lrl}
\multicolumn{3}{l}{
address of $array${\tt [}$i_0${\tt ,}$i_1${\tt ,}\ldots{\tt ,}$i_{n-1}${\tt ]}
= } \\\hspace*{2em}
&   & $array${\tt .base} \\
& + & $array${\tt .step[0]} * $i_0$ * {\em element-size}  \\
& + & $array${\tt .step[1]} * $i_1$ * {\em element-size}  \\
& + & \ldots\ldots \\
& + & $array${\tt .step[}$n-1${\tt ]} * $i_{n-1}$ * {\em element-size} \\
\end{tabular}

\end{center}

where

\begin{center}
\begin{tabular}{l}
$array${\tt .lower\_bound[0]} $\leq$ $i_0$ $\leq$ $array${\tt .upper\_bound[0]}
\\
$array${\tt .lower\_bound[1]} $\leq$ $i_1$ $\leq$ $array${\tt .upper\_bound[1]}
\\
\ldots\ldots
\\
$array${\tt .lower\_bound[}$n-1${\tt ]}
    $\leq$ $i_{n-1}$ $\leq$ $array${\tt .upper\_bound[}$n-1${\tt ]}
\end{tabular}

\end{center}

The members of an array cluster are called the
\smkey{parmeter}s{of array} of the array.
The parameters of an array $A$ whose element type is $T$ and whose
inheritable qualifiers are $Q$ are

\begin{indpar}

\begin{list}{}{}

\item[\ttdkey{first}] Type: `$Q$ $T$ {\tt *\&}'.
The first element of the array,
that is, the lowest addressed array element that can be accessed
using subscripts within the range indicated by the subscript bounds.
`\verb|& |$A$\verb|.first|' is {\tt NULL} if there are no
accessible elements (i.e., if some
upper bound is not at least as great as the corresponding lower bound).

\item[\ttdkey{length}] Type: `{\tt unsadr}'.
The total number of elements in the array.
The last used element of the array is
\begin{center}
{\tt (} $Q$ $T$ {\tt *\&)}
    $A${\tt .first @ (} $A${\tt .length - 1 ) * }{\em element-size}
\end{center}

This is an unchecked expression that could be written to access the
last array element.  The {\tt .length} is \verb|0| if there are no array
elements.

\item[\ttdkey{base}] Type:
`{\tt noaccess} $T$ {\tt * (unchecked || readonly) * \&}'.
The address of the {\tt [0,0,}\ldots{\tt ,0]}
element of the array.  This may not actually be inside the array,
as {\tt 0} subscripts may not be within bounds.

It is possible for unchecked code
to store into the {\tt .base} in order to relocate
the array.  When an array is passed to or returned from a function, it is
actually the {\tt .base} that is passed or returned.

\item[\ttdkey{dimensions}] Type: any unsigned integer type.
The number of dimensions (subscripts) of the array.

\item[\ttdkey{step}{$[i]$}]
Type: any integer type.
The multiplier
of the $i+1$'st subscript of the array for the purpose of determining
the address offset of the element in the array.
An integer (may be negative).
The unit of these multipliers is the size of the array element.

\item[\ttdkey{lower\_bound}{$[i]$}]
Type: any integer type.
The lower bound (smallest legal value)
of the $i+1$'st
subscript of the array.
An integer (may be negative).

\item[\ttdkey{upper\_bound}{$[i]$}]
Type: any integer type.
The upper bound (largest legal value)
of the $i+1$'st subscript of the array.
An integer (may be negative).

\end{list}

\end{indpar}

All the parameters except {\tt .first} and {\tt .length}
are given to describe an array.  The {\tt .first} and {\tt .length}
parameters are then computed from the other parameters.\footnote{
Note that these are functions and not C language members, and as
such only {\tt .first} returns an lvalue in the sense of the
C language.}

Given the example from above,
\begin{indpar}\begin{verbatim}
int32 iarray[5];
int32 * piarray[1 .. 5];
int32 * & irarray[10,20];
int32 * & tirarray[10++1,20++10];
\end{verbatim}\end{indpar}
we have
\begin{indpar}\begin{verbatim}
iarray.lower_bound[0] == 0
iarray.upper_bound[0] == 4
iarray.step[0] == 1
iarray.length == 5

piarray.lower_bound[0] == 1
piarray.upper_bound[0] == 5
piarray.step[0] == 1
piarray.length == 5

irarray.lower_bound[0] == 0
irarray.upper_bound[0] == 9
irarray.step[0] == 20
irarray.lower_bound[1] == 0
irarray.upper_bound[1] == 19
irarray.step[1] == 1
irarray.length == 200

tirarray.lower_bound[0] == 0
tirarray.upper_bound[0] == 9
tirarray.step[0] == 1
tirarray.lower_bound[1] == 0
tirarray.upper_bound[1] == 19
tirarray.step[1] == 10
tirarray.length == 200

\end{verbatim}\end{indpar}

When an array is allocated to the stack or to static memory,
the length of the array is just enough to include all the elements of the
array.  There can be unused elements.  Thus given
\begin{indpar}\begin{verbatim}
int32 x[1 .. 4 ++ 3];
\end{verbatim}\end{indpar}
then in memory the array {\tt x} is laid out as
\begin{center}
{\tt x[1]}, unused, unused,
{\tt x[2]}, unused, unused,
{\tt x[3]}, unused, unused,
{\tt x[4]}
\end{center}
and we have {\tt x.length == 10}, {\tt x.first == x[1]},
{\tt x.base == \&x[1] - 3}.

The parameters of an array can be any expression that evaluates
to an integer at the time the array is allocated.  For example,
\begin{indpar}\begin{verbatim}
uns32 constant number = ...
int64 constant first = ...
uns32 constant step = ...

int32 x[number];
int32 y[first .. first + number - 1 ++ step];
\end{verbatim}\end{indpar}

The variables used to determine the parameters
of an array must be `{\tt constant}' or
`{\tt readonly}' so that checked code cannot modify them.
More on this below.

\subsubsection{Array Function Parameters}
\label{ARRAY-FUNCTION-PARAMETERS}

An array can be passed to a function and returned as the value
of a function.  Some examples are:
\begin{indpar}\begin{verbatim}
void sort ( int64 vector[length], int32 length );
void transpose ( float64 array[lb .. ub ++ step1, lb .. ub ++ step2],
                 int64 lb, int64 ub, int64 step1, int64 step2 );
(float64 array[length,length]) unit ( uns32 length );
(string output[olength], uns32 olength) sort
        ( string input[ilength], uns32 ilength );
\end{verbatim}\end{indpar}

When an array is passed to a function, the parameters needed to
describe the array must be expressions computable from parameters
passed to the function.  When an array is returned by a function,
the parameters needed to describe the array must be expressions
computable from parameters either passed to or returned from the
function.  Note that integer function parameters are `{\tt constant}'
by default.

When a function that takes arrays as input parameters or computes
arrays as output results is called, the array parameters that are
function parameters or results may be implicitly specified.  Examples using
the function declarations above are:
\begin{indpar}\begin{verbatim}
int64 x[1 .. 100];
. . . compute x . . .
sort ( x[] );   // length implicitly passed.
float y[1 .. 5][1 .. 5];
. . . compute y . . .
transpose ( y[] );    // lb, ub, step1, step 2 implicitly passed.
float z[] = unit ( 10 );    // computes z and its parameters.
string s[10];
. . . compute s . . .
string t[] = sort ( s[] );    // ilength and olength implicitly passed.
                              // computes t and its parameters.
\end{verbatim}\end{indpar}

In order to indicate that implicit array parameter passing is
desired, the empty brackets `\ttkey{[]}' must be appended to the
array name.

Checked functions can only allocate arrays to static or stack
memory.  Unchecked functions can be written to allocate arrays
in a heap and return them.

The parameters of an array need not be constants: they can be
variables.  However, the variables must be qualified (see
\secref{QUALIFIERS}) in such a way that checked code cannot
modify them.  Unchecked functions may then be written to change the
array parameter variables and reconfigure the array: e.g., the
array may be expanded.  An example is:

\begin{indpar}\begin{verbatim}
// Implement myarray:

deftype myarray (32,8);
readonly unsadr *& .n ( myarray *& @ a ) unchecked = a@0;
readonly unsadr *& .max_n ( myarray *& @ a ) unchecked = a@8;
readonly unsadr *& .inc_max ( myarray *& @ a ) unchecked = a@16;
noaccess float64 (readonly *&b) [1 .. a.n] .void ( myarray *& @ a )
    unchecked = a@24;
(myarray *& @ a) .constructor.() unchecked
{
    a.n = 0;
    a.max_n = 0;
    a.inc_max = 30;
    a.void.base = NULL;
}
void push ( myarray *& a, float64 value ) unchecked
{
    if ( a.n >= a.max_n )
    {
        a.max_n += a.inc_max;
        float64 * ap =
            malloc ( sizeof ( float64 ) * ( a.max_n ) );
        if ( a.void != NULL )
            memcpy ( ap, a.void.base,
                     a.n * sizeof ( float64 ) );
        mfree ( a.void.base );
        a.void.base = ap;
    }
    ap[a.n] = value;
    ++ a.n;

}

// Use myarray:

myarray a;
push ( a, 1.0 );
push ( a, 2.0 );
a[1]; // Equals 1.0.
a[2]; // Equals 2.0.
a[0]; // Run time error.
a[3]; // Run time error.
\end{verbatim}\end{indpar}

There are a number of language features introduced in the above code.

First, {\tt a@24} is of type `{\tt void *\&}' which is
converted to type `{\tt float64 (*\&) [1 .. a.n]}' by the
`{\tt unchecked}' code of the {\tt .void} function.

Second, an array value is just its {\tt .base}, which is
just a pointer.  Viewed as the
element of an object, {\tt a.void} is just a {\tt .base} pointer,
and just enough
space to store this pointer must be allocated to it.  Here
we treat pointers as being 8 byte long values that are
aligned on 8 byte boundaries, but as 4 byte pointers will
fit into 8 bytes, the code will work even with 4 byte pointers.

Third, unchecked code can store a pointer of type `$T$ {\tt *}'
into $X${\tt .base}.  The line `{\tt a.void.base = ap;}' above
does just this.  Unchecked code can also read the base, as in
the line `{\tt memcpy ( ap, a.void.base, n );}', and implicitly
convert the base to a pointer to a `{\tt readwrite}' value.  Checked code
can also read the base, but the value returned will be given
the type `noaccess $T$ {\tt *}' since base pointers may not
point at real memory (e.g., given $X${\tt [1 ..~2]} then
$X${\tt .base} points to an unusable location just before
the first element).

Fourth, `{\tt unchecked}' code can use a pointer as if it were
a 1-dimensional array with step {\tt +1} and no bounds.  This is
done in the statement `{\tt ap[a.n] = value;}' above.

Fifth, `{\tt .base}' when applied to an array,
and `{\tt .void}' applied to any expression,
can always be omitted, as long as the
result can be disambiguated.  Thus in the above
`{\tt a.void.base}' could be replaced by either
`{\tt a.void}' or just `{\tt a}'.  In the code at the end
after the functions, `{\tt a.void[...]}' is replaced by `{\tt a[...]}'.

Sixth, `\verb|float64 (*&b) [1 .. a.n]|' differs from
`\verb|float64 *&b [1 .. a.n]|' which is equivalent to
`\verb|float64 *& (b [1 .. a.n])|'.  The first subexpression
means that the value returned is a pointer to the location holding
the base of an array whose elements are {\tt float64} values.
The second subexpression means that the value returned is the base
of an array whose elements are pointers to `{\tt float64}' values
(and {\tt b[i]} refers to the `{\tt float64}' value pointed at by the
array element indexed by {\tt i}).
In the expression `\verb|float64| \verb|(readonly *&b)| \verb|[1 .. a.n]|'
it is the array {\tt .base} that is read-only, not the array elements.

Seventh, the code above contains both an implementation of
{\tt myarray} and a use of {\tt myarray}.  We remind the reader that
the implementation is intended to be written by macros which are called
by the end user and which ensure that
the unchecked code generated is in fact type-safe, while the code that
uses {\tt myarray} is intended to be written by the end user and
should be type-safe in its own right.

\subsubsection{Copying Arrays}
\label{COPYING-ARRAYS}

If you want to copy entire arrays you have to apply the `{\tt *}'
operator to them.  Thus
\begin{indpar}\begin{verbatim}
declare alias qualifier same_data;
same_data int32 x[1 .. 10];
same_data int32 y[1 .. 10] = x;
// Now x and y are the same piece of memory.  This would not be
// legal without the alias qualifier (described later).
y[1] = ..., etc.
int32 z[1 .. 10];
* z = * y;
// Now the elements of x (and y) have been copied to
// the elements of z.
\end{verbatim}\end{indpar}

\subsubsection{Subarrays}
\label{SUBARRAYS}

Subarrays can be computed by expressions of the form
\begin{center}
{\em array-expression}
	{\tt [} {\em selector-spec}
	       \{ {\tt ,} {\em selector-spec} \}$^\star$ {\tt ]}{\tt ;}
\end{center}
where
\begin{indpar}
{\em selector-spec} ::=
    {\em lower-bound}~~{\tt ..}~~{\em upper-bound}~~{\em step-spec-option}
\end{indpar}

Here the bounds are valid subscripts for the given array, and the
steps are increments in these valid subscripts.

For example,
\begin{indpar}\begin{verbatim}
declare alias qualifier first_half, second_half;
first_half second_half int32 x[1 .. 10];
first_half int32 x1[1 .. 5] = x[1 .. 5];
second_half int32 x2[1 .. 5] = x[6 .. 10];

declare alias qualifier odd_half, even_half;
odd_half even_half int32 y[1 .. 10];
odd_half int32 y1[1 .. 5] = y[1 .. 9 ++ 2];
even_half int32 y2[1 .. 5] = x[2 .. 10 ++ 2];
\end{verbatim}\end{indpar}

Here {\tt x1} is the first half of {\tt x} and {\tt x2} is the second
half.  Similarly {\tt y1} is all the elements of {\tt y} with
odd subscripts, and {\tt y2} is all the elements with even
subscripts.

The `{\tt =}' operator used with arrays overlays and does not
copy.  It can only be used to initialize subarray names, and
only requires that the arrays involved have equal numbers of
subscripts in each dimension.

In somewhat more generality a subarray of an array may be
given a \key{linear view} defined by any linear map between
arbitrary subscripts and the subscripts of the array.  For
example:
\begin{indpar}\begin{verbatim}
declare alias same_data;
same_data int32 x[1 .. 70];
same_data int32 y[1 .. 10, 1 .. 7] = ([i,j] ===> x[(i-1)*7 + j]);
same_data int32 z[1 .. 7, 1 .. 10] = ([i,j] ===> y[j,i]);
same_data int32 w[1 .. 6] = ([i] ===> y[i,i+1]);
\end{verbatim}\end{indpar}

Here {\tt y} is a 2-dimensional array overlaid on the vector {\tt x},
{\tt z} is the transpose of {\tt y}, and {\tt w} is a subdiagonal of
{\tt y}.

\subsubsection{Array Maps}
\label{ARRAY-MAPS}

Special forms of array can be defined by adding parameters to the
array and defining special operators.  For example, a symmetric
array can be defined by:
\begin{indpar}\begin{verbatim}
int32 x[28];
uns32 x.size = 7;
int32 *& x[int32 i, int32 j]
{
    assert ( 0 <= i < size && 0 <= j < size );
    return x[i*(i+1)/2 + j];
}
\end{verbatim}\end{indpar}

Here `{\tt .size}' is an extra member of the cluster {\tt x}
and `{\tt x[ ]}' is just a function that surrounds it arguments
with `{\tt [ ]}' instead of `{\tt ( )}'.

\subsection{Qualifiers}
\label{QUALIFIERS}

The L-Language controls the way memory is accessed via \skey{qualifier}s.
A qualifier is either a qualifier name followed by optional
parameters in parentheses, or is a parentheses surrounded
qualifier expression.
Qualifier parameters may be expressions written
in a sublanguage special to the type of qualifier.

Qualifiers may be applied to values or to locations of memory.  Some
types of qualifiers apply to values and some to locations.
For example, `{\tt stack}' is a value qualifier that says that
a value is not valid after the currently executing function returns,
`{\tt constant}' is a location qualifier that says that the
location will never ever be written into,
and `{\tt readlonly}' is a location qualifier tat says that the
location cannot be written using the given address of the location.

For example, the
declarations
\begin{indpar}[0.5em]\begin{verbatim}
constant int32 x = 5;
stack adr yp = & x -> readonly int32 y;
\end{verbatim}\end{indpar}
promise that after initialization no one will ever
write into the location {\tt x} (which is {\tt constant}),
that {\tt yp} will be valid as long as the current function
execution exists (because it holds a {\tt stack} value), and that
{\tt yp} cannot be used to write to {\tt y} (which is {\tt readonly}).

A location qualifier is applied to the type of a value that is the
target of a pointer.  That is, they appear in types of the form
\begin{center}
{\em pointer-type} \verb|->| {\em location-qualifier} {\em value-type}
\end{center}

Values are a sequence of bytes, and locations are a set of bytes
in memory.  Note that unlike
the C programming language, L-Language does not specify arrays by
simply giving a single pointer; there is always a specification of
array extent (except for unchecked code).

Qualifiers may be given in type definitions, and apply to all
values and memory locations of the defined type.
For example, if {\tt Q} is a qualifier,
\begin{indpar}[0.5em]\begin{verbatim}
deftype Q type1 (48,8);
type1 x;
adr yp -> type1;
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}[0.5em]\begin{verbatim}
deftype type1 (48,8);
Q type1 x;
adr yp -> Q type1;
\end{verbatim}\end{indpar}

Qualifiers may also be applied to code blocks.  Such are called
`\skey{code block qualifier}s'.  A qualifier just before the
{\tt =} or \LEFTBRACKET{} that introduces the function body in a
function definition applies to the code in the
body.
For example, if {\tt Q} is a qualifier,
\begin{indpar}[0.5em]\begin{verbatim}
int32 function1 () Q = ... ;
int32 function2 () Q
{
   . . .
}
\end{verbatim}\end{indpar}
apply {\tt Q} to the body of the functions.

A qualifier just before the name of a function in a function definition
or declaration applies to calls to the function, and is said to be
a `\key{function access qualifier}'.  For example,
\begin{indpar}[0.5em]\begin{verbatim}
int32 Q function3 ();
adr -> int32 V Q function4 ();
\end{verbatim}\end{indpar}
Note that in this last case qualifiers appearing immediately
before function names
in function definitions and declarations are always assumed to apply
to the function and not the returned value.  Its possible to force
a qualifier to apply to returned values and not the function
by putting returned values in parentheses like an argument list,
but there is little reason to do this just for the sake of
a qualifier, since qualifiers are not last in value types.

Some qualifiers (e.g., see `{\tt pure}' below)
are both access and body qualifiers, and these
are put in the position of function access qualifier.

If in the above examples we assume that
{\tt Q} is a protection qualifier, then {\tt function3}
and {\tt function4} can only be called by functions whose bodies have
the {\tt Q} qualifier, and in particular these functions can be called
by {\tt function1} and {\tt function2}.

A qualifier immediately preceding a \verb|{ }| bracketed code block
inside a function applies to the code block.  For example,
\begin{indpar}[0.5em]\begin{verbatim}
int32 function3 ()
{
   . . .
   Q {
       . . . a code block . . .
   }
}
\end{verbatim}\end{indpar}
applies {\tt Q} to the code block.

There are several kinds of qualifiers.  We summarize these here, and
give details in following sections.

\ikey{Lifetime qualifiers}{lifetime qualifier}
specify the lifetime of a value.  This in turn controls where
the value may be stored, e.g., a value of limited lifetime may
not be stored in a location whose value is declared to be of
unlimited lifetime.

There are three builtin lifetime qualifiers.
The `{\tt static}' qualifier specifies that the value
has unlimited lifetime.
The `{\tt stack}' qualifier specifies that the value
has a lifetime that lasts at least until the
current function execution terminates.
The `{\tt caller}' qualifier
specifies that the value has a lifetime that begins before the
called function starts to execute and lasts until
sometime after that function returns.

In addition user define `calling lifetime qualifiers' {\tt Q} may be defined
that typically specify that lifetimes will continue until
an out-of-line function that does \underline{not} have access
qualifier {\tt Q} is called.
The `{\tt pure}' qualifier is often defined in this way.
Note that such a qualifier is simultaneously a lifetime qualifier,
a function access qualifier, and a code block qualifier.

\ikey{Traceable qualifiers}{traceable qualifier} may be declared that
indicate that either a location or the value stored in a location
must be known to garbage collectors or similar system maintenance
activities.  There are two builtin traceable qualifiers:
The `{\tt traceable location}' qualifier specifies that a location stored in
static memory or a thread stack must be findable by system maintenance
activities,
and the `{traceable value}' qualifier specifies that a location can only
hold values of which copies appear in static or thread stack locations
that are findable by system maintenance activities.

All locations with a particular traceable
qualifier may be found via builtin L-language primitives.
For example, if values of a particular type may hold pointers
to garbage collectible locations, making these values
traceable permits all such values allocated to the stack or static
memory to be located by the garbage collector.

\ikey{Caching qualifiers}{caching qualifier} specify when memory locations
may be changed, and thence when they may be cached in registers.  The
`{\tt constant}' qualifier specifies that a location will never be changed,
and may be cached indefinitely in registers.
The `{\tt unique}' qualifier specifies that a location has no overlaps
with other locations, and,
in particular, that a location passed from a caller to
a called function does not overlap with any other location so passed
or with any location accessible from other data.
\ikey{Parallel qualifiers}{parallel qualifier} may be declared to
identify memory locations whose register \underline{and hardware}
caches are to be flushed by explicit cache flushing statements in the
L-Language.
These are used for memory locations shared between different hardware
processing units (e.g., between a central processing unit and an
IO device, or between two different central processing units).

\ikey{Access qualifiers}{access qualifier} may be declared
to control which functions can access a memory location or call other
functions.  Access qualifiers may or may not be
\skey{protection qualifier}s.
The builtin non-protection access qualifiers are
`{\tt readwrite}', `{\tt readonly}', `{\tt writeonly}', and `{\tt noaccess}'.
The builtin protection qualifier is `{\tt unchecked}'.
Protection qualifiers may also be defined by the user.

A memory location with protection qualifier $X$ can only be
accessed by code blocks that have qualifier $X$, and
a function with an access protection
qualifier $X$ can only be called by functions
whose bodies have qualifier $X$.  The builtin protection
qualifier `{\tt unchecked}' permits access to various
builtin operations that explicitly or implicitly involve type
conversion.

Memory locations can be assigned qualifier expressions that are logical
combinations of qualifier names and the operators `\verb/|/' and
`\verb/&/'.  For example, a memory location may be assigned the expression
`\verb/(/$X$\verb/|constant)/' where $X$ is a protection qualifier.
A function body
with qualifier $X$ will be able to access such a memory location to both
read and write it, but a function body without qualifier $X$ will treat the
location as having the `\verb|constant|' qualifier, will not be able
to write the location, and will assume that the location will
not be written by others.  In order for this to work properly, the functions
with qualifier $X$ that are permitted to write the location must be called
first, before functions without qualifier $X$ are allowed to access the
location.  Alternatively, `{\tt constant}' can be replaced by `{\tt readonly}',
which forbids writing the location but does \underline{not} promise that
other code will not write the location.

\ikey{Inline qualifiers}{inline qualifier} specify that functions called
from a particular block of code are to be inlined, or that a particular
block of code is to be out-of-line even if code surrounding it is
being inlined.  Inlining is necessary to get full optimization.

Qualifiers may also be defined that represent
\ikey{groups}{group!of qualifiers} of
qualifiers.

Qualifiers may also be \ikey{inherited}{qualifiers}.  For example, if
{\tt G} is a group qualifier,
\begin{indpar}\begin{verbatim}
G? readonly unsadr .n ( adr -> myarray G? a ) unchecked = ...;
\end{verbatim}\end{indpar}
causes any qualifier in group {\tt G} that is present for the
argument `{\tt a}' to be applied to the function result.
See \secref{QUALIFIER-INHERITANCE}.

\subsubsection{Lifetime Qualifiers}
\label{LIFETIME-QUALIFIERS}

Lifetime qualifiers determine when value lifetimes expire.
For example, the lifetime of the address of a stack variable allocated
in a function frame expires when the function execution terminates.

The `{\tt static}' lifetime qualifier that indicates a value has
an unlimited lifetime is applied by default to numeric values.
But it is possible to apply other lifetime
qualifiers.  For example, if an {\tt int32} value is used
as an open file designator, it may be given a limited lifetime.

A lifetime qualifier {\tt Q1} is said to be `\key{convertible}'
to a lifetime qualifier {\tt Q2} if {\tt Q1} promises a lifetime
at least as long as {\tt Q2} promises.

If {\tt Q} is a lifetime qualifier in the type
\begin{center}
\tt adr xp -> Q mytype x
\end{center}
then {\tt Q} is said to be a qualifier of the location {\tt x},
all values written into that location must have lifetime qualifiers that
are convertable to {\tt Q},
and all values read from that location will have qualifier {\tt Q}.


Three lifetime qualifiers are builtin:  `{\tt static}', `{\tt stack}',
and `{\tt caller}'.
Checked code can only allocate to static memory
or to the stack memory of the currently executing function, and addresses
of variables allocated by checked code are given the `{\tt static}' or
`{\tt stack}' qualifier accordingly.
Addresses of variables that are part of a function argument or return value
are given the `{\tt caller}' lifetime qualifier by default.


\begin{indpar}

\hspace*{-1em}\ttkey{static}~~~~~Specifies
the value lives forever.  Automatically applied to the addresses of
locations allocated at load time, and may be applied to the
addresses of locations allocated at program initialization time
and never deallocated.

The `{\tt static}' lifetime qualifier is convertible to any other
lifetime qualifier.  It is also the default lifetime qualifier
for non-pointer values.

\hspace*{-1em}\ttkey{stack}~~~~~Specifies the value lives as least as
as long as the current function execution.  Equivalent to
{\tt stack(0)}: see the following.

`{\tt static}' values are convertable to `{\tt stack}' values.

\hspace*{-1em}\ttkey{stack(n)}~~~~~
Specifies the value lives at least as long as the execution of
the current code block of nested level
{\tt n} within the currently executing function.
Unnested code within the function is considered to be at nested level {\tt 0}.
{\tt stack(n)} is automatically applied
to the addresses of locations allocated to the
current function frame by code in a level {\tt n} block (such locations
are freed when the block of level {\tt n} terminates).

`{\tt stack(m)}' is convertable during the execution of
a block of level {\tt n}$>${\tt m} to `{\tt stack(n)}'.


A `{\tt stack(n)}' qualifier \underline{cannot}
be applied to function argument and return types.

\hspace*{-1em}\ttkey{caller}~~~~~Only
used in a function $F$'s argument or return value types to qualify a values
such as addresses passed to the function.
Specifies the value's lifetime begins sometime before a call to $F$
and continues until sometime after that call returns.

The `{\tt caller}' qualifier is like the {\tt stack} qualifier but
specifies that the value is valid at the moment the function begins
executing and at the moment the caller code returned to by
the function begins executing.

`{\tt static}', `{\tt stack(n)}', and {\tt caller} qualifiers
can be converted to the `{\tt caller}' qualifier when the latter is
part of the type of a value that is being passed as an argument or
a return value to a function being called by the code that does
the conversion.  However, 
`{\tt stack(n)}' and {\tt caller} qualifiers \underline{cannot}
be converted to the `{\tt caller}' qualifier when the latter is
part of the type of a value that is an argument or return
value of the currently executing function.  Note that in this
case a `{\tt caller}' qualifier cannot even be converted to
a `{\tt caller}' qualifier.


For example:
\begin{indpar}[0.5em]\begin{verbatim}
int32 function1 ( caller adr arg1 -> static adr -> int32 );
    // The argument is a pointer to a caller allocated location
    // holding a pointer to a statically allocated int32.
    // function1 can use `*arg1 = value' to return a static
    // adddress to an int32 value, and can also use
    // `**arg1 = value' to return an int32 value.
int32 function2 ( caller adr arg1 -> caller adr -> int32 );
    // The argument is a pointer to caller allocated location
    // holding a pointer to a caller allocated location holding
    // an int32.  function2 can use `**arg1 = value' to return
    // an int32 value, and can use `*arg1 = value' to return
    // a static address, but not a caller address.
int32 function3 ( static adr arg1 -> caller adr -> int32 );
    // Illegal; a static location cannot contain a value whose
    // lifetime may only last until some function returns.
\end{verbatim}\end{indpar}

The `{\tt caller}' lifetime qualifier is the default
lifetime qualifier for any function
argument or return value pointer value that has no
lifetime qualifier.  Thus in the above example the `{\tt caller}'
qualifiers could have been omitted.

The `{\tt caller}' lifetime qualifier may \underline{not} be used
except in function argument and return value declarations.

\end{indpar}

Users may define \skey{calling lifetime qualifier}s by using
a declaration of the form:
\begin{center}
{\tt declare} \begin{tabular}[t]{@{}l@{}}
              {\tt calling lifetime qualifier} {\em qualifier-name} \\
              {\tt with continuer} {\em qualifier-name} \\
	      {\tt with discontinuer} {\em qualifier-name} \\
	      {\tt with default} {\em qualifier-name}
              \end{tabular}
\end{center}
An example is:
\begin{center}
\begin{tabular}{l}
\tt declare calling lifetime qualifier relocatable \\
\tt ~~~~~~~~with continuer nonrelocating \\
\tt ~~~~~~~~with discontinuer relocating \\
\tt ~~~~~~~~with default relocating \\
\end{tabular}
\end{center}

If {\tt Q} is a calling lifetime qualifier, {\tt CQ} is its
continuer, and {\tt DQ} is its discontinuer,
then a value with qualifier {\tt Q} will have
a lifetime that is terminated by a call to an out-of-line function that has
the access qualifier {\tt DQ} or the execution of a code
block that has qualifier {\tt DQ}.

If an out-of-line function has the {\tt CQ} access qualifier,
the lifetime of a value with qualifier {\tt Q}
is not terminated by a call to the function.
Similarly if a code block has the {\tt CQ} qualifier,
the lifetime of the value is not terminated by the execution
of the code block.

The default qualifier is applied to out-of-line functions with no
explicit {\tt CQ} or {\tt DQ} access qualifier.
The {\tt CQ} qualifier is applied by default to both code blocks
and to inline functions with no explicit
{\tt CQ} or {\tt DQ} qualifier.

The {\tt DQ} and {\tt CQ} qualifiers are incompatible with each other.

The discontinuer lifetime qualifier {\tt DQ}
is also automatically declared to be
a protection qualifier(\pagref{PROTECTION-QUALIFIER}) so that
a block of code with continuer qualifier {\tt CQ} cannot call a function
or invoke a block of code with the discontinuer qualifier {\tt DQ}.

Thus in the example, a `{\tt relocatable}' value would have a lifetime until
an out-of-line function with no
`{\tt nonrelocating}' access qualifier is
called, or a code block with the `{\tt relocating}' qualifier is executed,
where this code block could be part of an inline function.

\subsubsection{Traceable Qualifiers}
\label{TRACEABLE-QUALIFIERS}

There are two builtin traceable qualifiers.  Both refer to
`{\tt static}' or `{\tt stack}' locations.  These are locations
whose pointer is an address of `{\tt adr}' type that has either
the `{\tt static}' or `{\tt stack}' qualifier, so the location
is either static or in a function frame.

\begin{indpar}

\hspace*{-1em}\ttkey{traceable location}~~~~~A location qualifier
that specifies that the
location can be found by the appropriate trace operations.
The location must be a `{\tt static}' or `{\tt stack}' location;
checked code cannot apply the qualifier to other locations.
The traceable location qualifier is used to find
data that must be read or modified in certain circumstances.

\hspace*{-1em}\ttkey{traceable value}~~~~~A value qualifier
that specifies that the
value can be found by the appropriate trace operations
\underline{if} it is stored in any `{\tt static}' or `{\tt stack}'
location.
In this case a traceable location is established implicitly that holds
the value.  As long as it is stored in a single traceable location,
copies of the a traceable value can exist in many other untraceable locations
in the stack or static memory.

Traceable value locations are used to store pointers to garbage collectible
data.  The `{\tt traceable value}' qualifier is usually attached to the
types of such data.  A pointer type (\pagref{POINTER-TYPES})
may be defined specifically so pointers of the given type
may be identified as traceable values by qualifying the type
with `{\tt traceable value}'.

The `{\tt traceable value}' qualifier has no affect on values that
are stored in non-stack, non-static locations.

\end{indpar}

\subsubsection{Caching Qualifiers}
\label{CACHING-QUALIFIERS}

When a memory location is moved into a register, the register becomes
a \key{software cache}\index{cache!software}
of the memory location.  Thus memory locations
are cached in registers under the control of software, and not hardware.
Unfortunately this makes things very difficult for the compiler
(the ultimate fix is a radical change in computer architecture;
see Appendix~\secref{ALIASING-HARDWARE}).

Memory locations may also be placed in hardware caches.  In a hardware
system with memory shared among multiple central processing units,
each central processing unit may have its own hardware cache that is
\underline{not} automatically synchronized with shared memory or
the caches of other central processing units.  Special instructions
are used to synchronize these hardware caches with shared memory.

Caching qualifiers determine when to invalidate and when to write
software and hardware caches.

Two caching qualifiers are builtin: `{\tt constant}' and `{\tt unique}'.
Two kinds are declarable: alias qualifiers and parallel qualifiers.

\begin{indpar}

\hspace*{-1em}\ttkey{constant}~~~~~The memory location is constant and will not
be modified at all.

The memory location can be cached in registers without
restriction.

Memory locations declared `{\tt constant}' must be written during their
initialization.  This is managed by not declaring a location to be
`{\tt constant}' when it is passed as a result value to the function
that initializes the location.

The following code has some examples:
\begin{indpar}[0.5em]\begin{verbatim}
int32 function1 ( stack adr -> constant int32 arg1 );
int32 function2 ( stack adr -> readonly int32 arg1 );
int32 function3 ( stack adr -> int32 arg1 );
. . . . . . . . . .
constant int32 value1 = 5;
   // Permitted:
   //   caller adr -> int32 .assign. ( 5 ) is called.
... my_function ( ... )
{
    value1 = 10; 
       // Erroneous:
       //   caller adr -> constant int32 .assign. ( 10 ) is called.
    function1 ( value1 );  // Permitted; arg1 constant.
    function2 ( value1 );  // Permitted; arg1 readonly.
    function3 ( value1 );  // Erroneous; arg1 NOT constant
                           // or readonly.
    int32 value2 = 15;
    function1 ( value2 );  // Erroneous.  Function1 might make
                           // a long term cache of value2 which
                           // might then be changed.
    function2 ( value2 );  // Permitted.  Function2 merely
                           // promises not to write value2.
    . . . . . . . . . .
\end{verbatim}\end{indpar}

Note that the `{\tt constant}' qualifier in an argument type is a promise
that \underline{no code} will \underline{ever} modify the location.  By contrast
a `{\tt readonly}' argument qualifier (like `{\tt const}' in C/C++)
is a promise only that the location will not be modified during
the course of the call.  The difference is that a called function
may construct a long-lived cache of a `{\tt constant}' location
but not of a `{\tt readonly}' location.

The `{\tt constant}' qualifier obeys the following special rules:
\begin{enumerate}
\item
`{\tt constant}' is removed from a location passed to a
function as the result location in the initializer statement
of the location.
\item
`{\tt constant}' is the default cache qualifier for locations of
function arguments that are passed by value and not by reference.
\end{enumerate}

The `{\tt constant}' qualifier is automatically applied to temporary
values.  Thus continuing the above example:
\begin{indpar}[0.5em]\begin{verbatim}
    function1 ( value1 + value2 );
        // Permitted; value1 + value2 is a `constant' int32
        // temporary value.
\end{verbatim}\end{indpar}


\hspace*{-1em}\ttkey{unique}~~~~~Function argument and return value
locations can be given the {\tt unique} qualifier if these locations
are being passed to the function from its caller.  These locations
cannot overlap any other location passed to the function or available
to the function via global data.  This means these locations must
either have been allocated by the caller, or passed as `{\tt unique}'
argument or return value locations to the caller from its caller.

A `{\tt unique}' memory location may be passed as an argument to
or return value of a function only if the function argument
or return value location is declared `{\tt unique}' within the
function declaration.  A stack memory location may be so passed
if no address that permits access to the location has been stored
anywhere except in the stack and the location is not passed as
more than one of the function argument or return value locations.

Addresses that permit a `{\tt unique}' memory location to be
accessed may only be stored in stack locations where they
can be tracked by the compiler.

A `{\tt unique}' memory location may be cached in a register.
This cache must be flushed when an out-of-line function is called
only if the address of the location is passed to the out-of-line
function as the address of a `{\tt unique}' function argument or
return value location.

\hspace*{-1em}\ikey{Alias Qualifiers}%
{alias qualifier}~~~~~Alias
qualifiers are declared by the programmer and are used to tag
memory locations that may be aliased with each other.

At compile time the L-Language converts location
addresses into a form that is the sum
of a \key{base address} and an integer \key{offset}.
In addition the location may have associated
alias qualifiers.  The L-Language assumes two locations do not overlap
unless they have a common alias qualifier, or unless the locations have
identical base addresses and their offsets indicate they overlap.

A base address is one of the following:

\begin{enumerate}
\item The address of a memory block allocated by the loader.
\item The address of a memory block allocated to the current function frame.
\item An address passed into the current function as the location
of an argument or return value.
\item An address returned from a function call or builtin operation,
      including addresses read from memory locations.
\end{enumerate}

For example:
\begin{indpar}[0.5em]\begin{verbatim}
void copy1 ( uns8 source[length],
             uns8 destination[length],
             uns32 length )
{
    uns32 i = 0;
    loop: {
        if ( i >= length ) break loop;
        destination[i] = source[i];
        ++ i;
    }
}
declare alias qualifier same_data;
void copy2 ( same_data uns8 source[length],
             same_data uns8 destination[length],
             uns32 length )
{
    uns32 i = 0;
    loop: {
        if ( i >= length ) break loop;
        destination[i] = source[i];
        ++ i;
    }
}
uns8 x[16];
x[0] = 0;
copy1 ( x[0 .. 14], x[1 .. 15], 15 );   // Erroneous.
copy2 ( x[0 .. 14], x[1 .. 15], 15 );   // Zeros x.
\end{verbatim}\end{indpar}

The call to {\tt copy1} is erroneous because
arguments that are not supposed to be aliased are in fact aliased.

Aliasing is checked as necessary by the compiler and at run time.
The run-time checks can be suppressed by compilation switches.

Simple alias qualifiers are just names.  Complex alias qualifiers
contain a \key{type overlap expression} as follows:

\begin{indpar}
{\em complex-alias-qualifier} ::=
    {\em alias-name} \verb|(| {\em type-overlap-expression} \verb|)| \\[1ex]
{\em type-overlap-expression} ::=
    {\em type-inclusion-sequence}
    \{ \verb/|/ {\em type-inclusion-sequence} \}$^\star$ \\[1ex]
{\em type-inclusion-sequence} ::=
    {\em type-factor}
    \{ \verb/>>/ {\em type-factor} \}$^\star$ \\[1ex]
{\em type-factor} ::= {\em type}
                  $|$ \verb|(| {\em type-overlap-expression} \verb|)|
\end{indpar}

A canonical {\em type-overlap-expression} is one with no parenthesized
{\em type-\EOL overlap-\EOL sub\-ex\-pres\-sions},
and any {\em type-\EOL overlap-\EOL expression} can be made
canonical by distributing \verb/|/ over \verb|>>| as in

\begin{indpar}
\ldots{} \verb|>>| \verb|(| $e_1$ \verb/|/ $e_2$ \verb/)/ \verb|>>| \ldots{}
~~$\Longrightarrow$~~
\ldots{} \verb|>>| $e_1$ \verb|>>| \ldots{} \verb/|/
\ldots{} \verb|>>| $e_2$ \verb|>>| \ldots{}
\end{indpar}

A {\em type-inclusion-sequence}
\begin{center}
$t_1$\verb|>>|$t_2$\verb|>>|$t_3$\verb|>>|\ldots\verb|>>|$t_n$
\end{center}
intuitively
describes a hierarchical data block structure: a date block $b_1$ of type
$t_1$ contains a subblock $b_2$ of type $t_2$ and this contains a
subblock $b_3$ of type $t_3$, etc., until we get to the smallest
data block $b_n$ of type $t_n$ which in turn contains the location
being qualified.  Furthermore, $b_1$ is allocated
to the stack memory, to static memory, or to a heap memory,
and is disjoint from every other data block so allocated
that has a type incompatible with $t_1$.
Similarly $b_2$ is a child of $b_1$ in the hierarchical
containment scheme, and is disjoint from every other child subblock
of $b_1$ that has a type incompatible with $t_2$.   Etc. through $b_n$
and $t_n$.

Formally two data types overlap if they are compatible, which means
that a location of one type may be viewed as having the other type.
Two {\em type-inclusion-sequences} overlap if one is an initial
segment of the other, where compatible types are viewed as being equal.
For example `\verb|mydata>>subdata1>>int|' and `\verb|mydata>>subdata1|'
overlap but `\verb|mydata>>subdata1>>int|' and `\verb|mydata>>subdata2>>int|'
do not, assuming that \verb|subdata1| and \verb|subdata2| are
incompatible types.

Note that `\verb|type1>>type2|' refers to a datum of \verb|type2| located
inside a datum of \verb|type1| \underline{without} any intervening
data; i.e., there is \underline{no} \verb|type12| such that
`{\tt type1\verb|>>|\EOL type12\verb|>>|\EOL type2}'
can also be used to describe the datum.

Intuitively a canonical {\em type-overlap-expression} $e_1$\verb/|/$e_2$
describes a data block that can be described by either of the
{\em type-inclusion-sequences} $e_1$ or $e_2$.  Formally,
two canonical {\em type-overlap-expressions} overlap if any
{\em type-including-sequence} from the first overlaps any
{\em type-including-sequence} from the second.

TBD: include fixed integer offsets as part of inclusion?

\hspace*{-1em}\ikey{Parallel Qualifiers}%
{parallel qualifier}~~~~~Parallel
qualifiers are declared by the programmer and are used to tag
memory locations that may be flushed from software and hardware
caches in order to permit separate central processing units
to communicate through shared memory.

There are three L-Language statements that flush caches.  Each gives
a list of parallel qualifiers that names all the locations accessible
at the point of the statement that are tagged with these qualifiers.  An
example is:
\begin{indpar}[0.5em]\begin{verbatim}
declare parallel qualifier pdata, pflag;
pdata float64 x[3];
pflag bool done_flag = false;
. . . . . . .
// Output data
x[0] = 35.87;
x[1] = -2.90;
parallel flush write pdata;
// Set done_flag indicating data has been output
done_flag = true;
parallel flush write pflag;
// Wait for data to be consumed
// Consumer clears done_flag after consuming data
loop: {
    spin ( 5000 ); // 5000 nanosecond spin
    parallel flush read pflag;
    if ( done_flag == false ) break loop;
}
// Data has been consumed
\end{verbatim}\end{indpar}

\end{indpar}

The `{\tt parallel flush}' command flushes \underline{both}
software and hardware caches.

\subsubsection{Access Qualifiers}
\label{ACCESS-QUALIFIERS}

Six access qualifiers are builtin:
`{\tt readwrite}', `{\tt readonly}', `{\tt writeonly}', `{\tt noaccess}',
`{\tt impure}', and `{\tt unchecked}'.
The last two are protection qualifiers;
additional protection qualifiers may be declared.
In addition the `{\tt pure}' builtin qualifier must be used to prevent the
`{\tt impure}' qualifier from being applied by default.

\begin{indpar}

\hspace*{-1em}\ttkey{readwrite}, \ttkey{readonly}, \ttkey{writeonly},
\ttkey{noaccess}~~~~~Specifies whether execution may read or write a location.

\hspace*{-1em}\ttkey{unchecked}~~~~~A builtin protection qualifier
that is required to access the builtin operators that
perform explicit or implicit
type conversions.

\hspace*{-1em}\ttkey{impure}~~~~~A builtin protection qualifier
that is required to access the builtin operators and that
may deallocate or reallocate memory locations.  Note that interrupts
may deallocate or reallocate memory locations, so functions that
are not `{\tt impure}' are not interruptable.

This qualifier is
transitive: if used as a function access qualifier, it is also
applied to the function body.  It is also a default function
access qualifier,
whose negation, the `\ttkey{pure}' qualifier, must be used as a
function access qualifier to
specify that a function does not have the `{\tt impure}' access qualifier.

\hspace*{-1em}\ikey{Protection Qualifiers}{protection qualifier}%
\label{PROTECTION-QUALIFIER}~~~~~Protection
qualifiers may be declared by the programmer.
Protection qualifiers may have names of the form
\begin{center}
{\em protection-qualifier-name} \verb|(| {\em type-expression} \verb|)|
\end{center}

A code block may call a function only if every protection qualifier
of the function is also protection qualifier of the code block, or
the special `{\tt unchecked}' qualifier is a qualifier of the code block.
Similarly a code block may access a memory location only if every
protection qualifier of the location is also a protection qualifier
of the code block, or
the special `{\tt unchecked}' qualifier is a qualifier of the code block.

\end{indpar}

Often qualifier expressions containing protection qualifiers are
used as function and memory location access qualifiers.  For this
reason, examples of access qualifiers are given in the next section.

\subsubsection{Qualifier Expressions}
\label{QUALIFIER-EXPRESSIONS}

A \key{qualifier expression} is an expression composed of qualifiers,
the operators `\ttmkey{\BAR}{in qualifier expression}'
and `\ttmkey{\&}{in qualifier expression}', and parentheses.
Qualifier expressions can be used as function access
qualifiers and memory location qualifiers.

In order for a function to be callable
or memory location to be accessible by a code block,
all of the function's access qualifier expressions
or the location's qualifier expressions must evaluate to true
according to the following rules.  First, each protection qualifier
is given the value true if it qualifies the code block and false otherwise.
Second, every non-protection qualifier is given the value true if and only if
doing so is necessary and sufficient to make all
the subexpressions containing the non-protection
qualifier true.  This last rule is applied from left to right.
Any non-protection qualifiers
given the value true for any qualifier expression
then qualify the function call or location when it is accessed by
the code block, while
non-protection qualifiers given the value false are ignored.

For example, given the code
\begin{indpar}[0.5em]\begin{verbatim}
deftype type1 (24,4);
declare protection qualifier constructor(type1);
(constructor(type1)|constant) type1 my_data;
void function1 ( type1 *& arg1 );
void function2 ( constant type1 *& arg1 );
void function3 ( type1 *& arg1 ) constructor(type1);
. . . . . . .
function1 ( my_data);   // Erroneous; my_data is constant for
                        // function1.
function2 ( my_data);   // Legal; my_data is constant for
                        // function2 and so is arg1.
function3 ( my_data);   // Legal; my_data is NOT constant for
                        // function3.
\end{verbatim}\end{indpar}

Note the left-to-right clause in the rule for evaluating non-protection
qualifiers.  For example, given the code:
\begin{indpar}[0.5em]\begin{verbatim}
deftype type1 (24,4);
declare protection qualifier A;
((A&readonly)|constant) type1 my_data1;
((A&readonly)|(A&readwrite)|constant) type1 my_data2;
\end{verbatim}\end{indpar}

then to a function with protection qualifier {\tt A}, {\tt my\_data1}
is {\tt readonly} and \underline{not}
{\tt constant}, whereas to all other functions, {\tt my\_data1}
is {\tt constant} and \underline{not} {\tt readonly}.  {\tt My\_data2}
behaves just like {\tt my\_data1}, as the subexpression `{\tt (A\&readwrite)}'
can never have any effect.

The precise specification for evaluating qualifier expressions
is as follows:

\begin{enumerate}
\item
A protection qualifier evaluates to true or false according to whether
the invoking code block has or does not have the qualifier.
\item
Any other qualifier evaluates to true when it is evaluated.
When this happens the qualifier is asserted for the function access
or location qualified by the qualifier expression.  Note that evaluation
may skip over subexpressions and thereby not evaluate qualifiers
therein.
\item
Evaluation of the subexpression $x$\verb/|/$y$ evaluates $x$ first.
If $x$ evaluates to true, the subexpression evaluates to true and
evaluation of $y$ is skipped.  If $x$ evaluates to false, $y$ is
evaluated and its value becomes the value of the subexpression.
Note that \verb/|/ is left associative:
$x$\verb/|/$y$\verb/|/$z$ $\equiv$
($x$\verb/|/$y$)\verb/|/$z$.
\item
Evaluation of the subexpression $x$\verb/&/$y$ evaluates $x$ first.
If $x$ evaluates to false, the subexpression evaluates to false and
evaluation of $y$ is skipped.  If $x$ evaluates to true, $y$ is
evaluated and its value becomes the value of the subexpression.
Note that \verb/&/ is left associative:
$x$\verb/&/$y$\verb/&/$z$ $\equiv$
($x$\verb/&/$y$)\verb/&/$z$.
\end{enumerate}

\subsubsection{Inline Qualifiers}
\label{INLINE-QUALIFIERS}

To `\key{inline}' a function is to replace the code calling the function
with the code of the function body.
For optimal performance functions should be inlined, so that
is the default.

Inlining is controlled by two builtin qualifiers: `\ttkey{inline}' and
`\ttkey{outline}'.  These are applied to function bodies and other
code blocks.  An `{\tt inline}' code block is inlined and an
`{\tt outline}' block not inlined.  An `{\tt outline}' block may
be nested inside an `{\tt inline}' block, but an `{\tt inline}'
block may \underline{not} be nested inside an `{\tt outline}' block.

An example is:
\begin{indpar}[0.5em]\begin{verbatim}
void function1 ( int32 x ) inline { ... }
void function2 ( int32 x ) outline { ... }
void function3 ( int32 x ) inline
{
    if ( x > 0 )
    {
        ... inlined code ...
    }
    else outline
    {
        ... outlined code ...
    }
}
\end{verbatim}\end{indpar}

Calls to {\tt function1} are inlined, those to
{\tt function2} are not, while those to {\tt function3}
are inlined except for the part executed when {\tt x<=0}
which is treated as an out-of-line function.

Recursive inlining is permitted provided it does not
lead to unbounded code.  For example:
\begin{indpar}[0.5em]\begin{verbatim}
int32 function1 ( int32 n ) inline { ... }
int32 recurse ( int32 n ) inline
{
    if ( n == 0 ) return 0;
    else return function1 ( n ) + recurse ( n - 1 );
}
int32 function2 ( void ) outline
{
    return recurse ( 5 );
        // Works, inlining recurse 6 times.
}
int32 function3 ( int32 n ) outline
{
    return recurse ( n );
        // Fails by producing an unbounded amount of code.
}
\end{verbatim}\end{indpar}

Inlining recursion works because while inlining code
the compiler computes compile time constant expressions
and uses the results to eliminate conditionalized code.

It is possible to control inlining to some degree
by associating compile time constant integers with
the `{\tt inline}' and `{\tt outline}' qualifiers.  If
a code block with qualifier `\verb|outline(|$m$\verb|)|'
calls a function whose code block has
qualifier `\verb|inline(|$n$\verb|)|', then the function
code block is inlined if and only if $m\geq n$.  Thus a
higher $m$ associated with and `{\tt output}' code block inlines more
code into the out-of-line block, and a higher $n$ associated
with an `{\tt inline}' code block makes it less likely the
code block will be inlined.

For example:
\begin{indpar}[0.5em]\begin{verbatim}
int32 function1 ( int32 n ) inline(1) { ... }
int32 function2 ( int32 n ) inline(2) { ... }
int32 function3 ( int32 n ) outline(1)
{
    function1(...); // Inlined.
    function2(...); // NOT inlined.
}
int32 function4 ( int32 n ) outline(2)
{
    function1(...); // Inlined.
    function2(...); // Inlined.
}
\end{verbatim}\end{indpar}

The numbers associated with the `{\tt inline}' and
`{\tt outline}' qualifiers are called
\key{optimization indices}.   Optimization indeces
default to the value {\tt 1}; e.g., `{\tt inline}'
is equivalent to `{\tt inline(1)}'.

\subsubsection{Qualifier Transitivity and Defaults}
\label{QUALIFIER-TRANSITIVITY-AND-DEFAULTS}

A qualifier may be declared to be \key{transitive qualifier},
meaning that if the qualifier is given as a function access
qualifier it will automatically be attached as a code block
qualifier of the function body.

A qualifier may be declared to be \ikey{default function access qualifier},
meaning that it is applied as a function access qualifier by
default to all functions that do not have a given
\key{counter qualifier}.  The counter qualifier merely specifies
that the default does not apply to a particular function.

The `{\tt impure}' qualifier is a builtin qualifier that is
transitive and default function access and has `{\tt pure}' as
its counter qualifier.  Were it not implicitly declared to have
these properties, it could be declared to have them by:
\begin{indpar}[0.5em]\begin{verbatim}
declare transitive qualifier impure;
declare default function access qualifier impure
        with counter qualifier pure;
\end{verbatim}\end{indpar}

Usually it is protection qualifiers that are declared to be transitive
or default function access qualifiers.

\subsubsection{Qualifier Inheritance}
\label{QUALIFIER-INHERITANCE}

\subsection{Memory Channels}
\label{MEMORY-CHANNELS}

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
structured set of elements each associated with a member of
some data set.  Each window element contains a
\key{block descriptor} that holds the address and length of the
memory block that contains the data associated with the element.
Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
The window has a \key{reference point}, and window elements are addressed
relative to this reference point.  There are shift operations that move
the reference point to a nearby window element.

Although we talk about blocks here, a block can be just a numeric array
element, and can be as small as a single bit.  Although we talk about
each element of a memory channel window having its own block descriptor,
an actual memory channel may use only block group descriptors, each of
which functions as a group of more than one individual element
block descriptor.

A memory channel is stored in a cluster.  As such it is mostly an
inline construction, though it can be passed to or returned from a
function, and the function can be all or partly out-of-line.

The most common type of memory channel has a window that appears to be
an array with \ttdmkey{dimensions}{of memory channel},
\ttdmkey{lower\_bound}{of memory channel}{\tt [}$i${\tt ]},
and \ttdmkey{upper\_bound}{of memory channel}{\tt [}$i${\tt ]}
being defined memory channel members.  Such are called
\key{array windows}.
If the memory channel cluster name is $M$, the window elements are
referred to by $M$\verb|[|$i_0$\verb|,|$i_1$\verb|,|\ldots\verb|]|,
with $M$\verb|[0,0,|\ldots\verb|]| being the \key{reference point}.

The reference point can be shifted along any of the window's
dimensions by the command
$M$\ttdkey{center}{\tt [}$i_0${\tt ,}$i_1${\tt ,}\ldots{\tt ]}, which shifts
the window so that what was
$M${\tt [}$i_0${\tt ,}$i_1${\tt ,}\ldots{\tt ]} becomes
$M${\tt [0,0,}\ldots{\tt ]}.

Creating memory channels and completely reseting their reference points
are specific to the type of memory channel, and are not covered in
this section.

For most kinds of memory channels, block descriptors are computed
automatically when channel is created, when the window is
shifted, or when the data of
a neighboring window element is arrives from memory.
Immediately after a block descriptor is created, a read-ahead of
the block is initiated.  This read-ahead overlaps computation that
does not use the block contents.

If a memory channel accesses arrays stored in memory,
the channel block descriptors can be computed from the array coordinates
of the reference point.  Other memory channels use the contents
of a block to compute the block descriptors of neighboring blocks
in the window.

An example of the latter is a binary tree memory channel.
Let $M$ be such a channel, and let `{\tt .L}' denote the left
child of a binary tree element, `{\tt .R}' the right child, and
`{\tt .P}' the parent.  Then $M\!$\verb|.L.R| denotes the right
child of the left child of the reference point, $M\!$\verb|.P.L|
denotes the left child of the parent of the reference point,
and $M\!$\verb|.P.L.center| moves the reference point to this last element.
The window of such a memory channel might contain the depth 2
subtree of the reference point plus that closest 4 ancestors of the
reference point if these have been visited.  When the reference
point is moved, as soon as the reference point element has been
read from memory, the descriptors for its children are built and
the read of the children is initiated in parallel with other
computation.  When the children arrive from memory, the descriptors
of their children are built and reads of the data pointed at
are initiated.\footnote{All this can actually be done with modern
hardware: code is executed to read the reference point children and initiate the
reads of their children, and a modern processor will automatically
save the code that
executes when a read of a reference point child completes and execute
other code in parallel until the read does complete.}

Some standard memory channel types are built into the L-Language.
Others can be defined by users.

\section{To Do}

How can dynamically initialized locations be static.

Indirect address protocol.
\label{INDIRECT-ADDRESS-PROTOCOL}

Functions.
\label{FUNCTIONS}

Threads.
\label{THREADS}

Function calls should be able to serve as lvalues so
\verb|x[i]=z| can update gc flags.

\appendix

\section{Aliasing Hardware}
\label{ALIASING-HARDWARE}

The ultimate solution to the aliasing problem is new hardware.
At its simplest, registers, which currently hold a datum,
are replaced by triples of registers which hold a datum,
an address, and selection codes.  The register datum equals the value
of the memory location at the register address.  The selection
codes determine which part of this memory location is read or written
when the register is read or written.  If any memory location is
changed, the address of the location is checked against all the
register addresses, and if any match, the corresponding register
data are changed.

This is, however, not sufficient, because sometimes one register
address is a function of another register's datum.  For example,
consider the unchecked code:
\begin{indpar}[0.5em]\begin{verbatim}
struct S { ...; int32 m; ... };
S * * x;
S * *& y = * x;
int32 *& z = y->m;
\end{verbatim}\end{indpar}
If we consider {\tt x}, {\tt y}, and {\tt z} to be registers,
the address of {\tt y} equals the value of {\tt x}, and the
address of {\tt z} equals the value of {\tt y} plus the offset of
{\tt m} in {\tt S}.

If the value of {\tt x} changes, this changes the address of {\tt y},
which may change the datum of {\tt y} and that may change the value
of {\tt y}.  If the value of {\tt y} changes, this changes the address
of {\tt z}, which may change the datum and value of {\tt z}.

The way we accommodate this is to use the selection codes of {\tt y}
to specify that the address of {\tt y} contains the value of {\tt x}
as an additive component, so
that if the value of {\tt x} is changed by adding $\Delta${\tt x}
then the address of {\tt y} should be changed by adding $\Delta${\tt x}.
And similarly the selection codes
of {\tt z} specify that the address of {\tt z}
contains the value of {\tt y} as an additive component.

So why should we bother with automatically updating
additive inclusions of one value in the
address of another value, and not bother with other expressions.
The reason is that expressions such as
`\verb|(*x)->m|' are likely to be reused frequently in code (actually,
in automatically generated code) and
therefore need to be cached, whereas an expressions of the form
`\verb|c*d|' will be reused comparatively rarely code
and therefore are not worth special hardware.


\bibliographystyle{plain}
\bibliography{layered-l-language}

\printindex

\end{document}
