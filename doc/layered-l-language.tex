% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

April 26, 2009
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language.  See the Introduction to the Layered
Programming Languages for basic syntax and for an overview of the related
Middle Layer M-Language and Higher Layer H-Language.

Here we will give brief overviews of some of the principle issues
addressed by the L-Language.


\subsection{Code Targetting}

The L-Language is intended to be a target language for compilers of
higher level languages.  As such it is optimized first to be an easy to 
use and adequate target language, and second to be reasonably easy to
compile into efficient assembly language code.

The L-Language is roughly like basic LISP with the type system and
syntax of C, and with additional features intended to give
more control over compilation and type safety.

\subsection{Code Computation}

The L-Language permits code to be computed by executing programs, and then
compiled and run.  The computed code can be an entire function, or can
be embedded within a function.

A main reason for this is to support scientific computing in which
code specific to a task must be computed and then optimized.

\subsection{Data Declaration}

The L-Language supports low level declaration of data and fairly high
level typesafe optimized usage of declared data.  The L-Language also
supports macros written in the L-Language itself, permitting very
capable macros to be written by users to give users high level data
declaration facilities taylored to specific kinds of data.

The thesis here is that a high level data declaration language that is
typesafe and efficient for all kinds of data is not practical.
So instead tools are provided to create data declaration sublanguages that are
typesafe and efficient for more limited kinds of data.


\section{Memory}
\label{MEMORY}

We begin with an overview of L-language memory, and then provide
details in the following subsections.

TBD

\subsection{Numbers}

\ikey{Numbers}{number} are a basic element of L-language memory.
Numbers are sequences of bits, and each number is one of
four types, unsigned integer, signed integer, floating point number,
and direct address:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l}
\bf Name & \bf Kind & \bf Length \\[2ex]
\ttkey{uns8}		& unsigned integer & 8 bits \\
\ttkey{uns16}		& unsigned integer & 16 bits \\
\ttkey{uns32}		& unsigned integer & 32 bits \\
\ttkey{uns64}		& unsigned integer & 64 bits \\
\ttkey{uns128}		& unsigned integer & 128 bits \\
\ttkey{int8}		& signed integer & 8 bits \\
\ttkey{int16}		& signed integer & 16 bits \\
\ttkey{int32}		& signed integer & 32 bits \\
\ttkey{int64}		& signed integer & 64 bits \\
\ttkey{int128}		& signed integer & 128 bits \\
\ttkey{float16}		& IEEE floating point number & 16 bits \\
\ttkey{float32}		& IEEE floating point number & 32 bits \\
\ttkey{float64}		& IEEE floating point number & 64 bits \\
\ttkey{float128}	& IEEE floating point number & 128 bits \\
(see text)		& direct address & 64 bits \\
\end{tabular}
\end{center}

The \mkey{length}{of number}
of a number is the number of its bits.  Numbers can have
different lengths: for example, unsigned integers can have
lengths of 8, 16, 32, 64, or 128 bits.

Numbers are stored in random access memory (RAM).

An \key{unsigned integer} of length $L$ is a binary integer with
$L$ binary digits (\skey{bit}s).

A \key{signed integer} of length $L$ is a two's complement integer
of length $L$.  This represents an integer $I$
by the unsigned $L$-bit integer equal to $I~\mbox{modulo}~2^L$.

A \key{floating point number} of length $L$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes is as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l}
\bf Floating Point \\
\bf Number Size & \bf Exponent Size & \bf Mantissa Size \\[2ex]
16 bits & 5 bits & 10 bits \\
32 bits & 8 bits & 23 bits \\
64 bits & 11 bits & 52 bits \\
128 bits & 15 bits & 112 bits \\
\end{tabular}
\end{center}

A \key{direct address} holds a RAM byte address.
A direct address is a 64-bit unsigned integer, but some
of high order bits are all 0's or all 1's, depending upon
the implementation.  A reasonable assumption is that only the low
order 48-bits of the direct address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing a direct address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The Layered Languages do
\underline{not} depend upon this assumption, but do provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit direct address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$.  The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.

Variables can be declared to be of non-address numeric type
by declarations of the form
\begin{center}
{\em type-name} {\em variable-name} {\tt ;}
\end{center}
For example,
\begin{indpar}\begin{verbatim}
int32 i;
uns128 u;
float64 f;
\end{verbatim}\end{indpar}

Variables can be declared to be of address type by declarations of the
form
\begin{center}
{\tt \&}$^\star$ {\em type-name} {\tt *}$^\star$ {\em variable-name} {\tt ;}
\end{center}
in which there is at least one {\tt \&} or {\tt *}.
For example,
\begin{indpar}\begin{verbatim}
int32 * ip;
& int32 i;
\end{verbatim}\end{indpar}
are both variables that reference a direct address of an {\tt int32} type
integer stored in memory.  However, `\verb|ip|' and `\verb|& i|' reference
the direct address variable, and `\verb|* ip|' and `\verb|i|' reference
the {\tt int32} integer.

In general if there are $N$ {\tt \&}'s and {\tt *}'s, the variable is
the direct address of the direct address of the \ldots{} of the direct address
of the non-address type, where there are $N$ direct addresses in all.
If there are no {\tt \&}'s, the variable name references the first of
these direct addresses, and the variable name with $M$ {\tt *}'s in
front of it references the $M+1$'st of the addresses, or the non-address
number of $M=N$.  If instead there are $M$ {\tt \&}'s in the declaration,
the variable name references the $M+1$'st direct address, or the non-address
number if $M=N$, and to get a previous direct address one must put a
{\tt \&} in front of the variable name, whereas to get a subsequent direct
address or the non-address number one puts a {\tt *} in front.

For example,
\begin{indpar}\begin{verbatim}
int32 *** ippp;
& int32 ** ipp;
&& int32 * ip;
&&& int32 i;
\end{verbatim}\end{indpar}
are all variables referencing a direct address of a direct address of a
direct address of an {\tt int32} number stored in memory.
The first of these direct addresses is accessed with
`\verb|ippp|', `\verb|& ipp|', `\verb|& & ip|', or `\verb|& & & i|'.
The second of these direct addresses is accessed with
`\verb|* ippp|', `\verb|ipp|', `\verb|& ip|', or `\verb|& & i|'.
The third of these direct addresses is accessed with
`\verb|* * ippp|', `\verb|* ipp|', `\verb|ip|', or `\verb|& i|'.
The {\tt int32} number is accessed with
`\verb|* * * ippp|', `\verb|* * ipp|', `\verb|* ip|', or `\verb|i|'.
Also note that in `\verb|* &|' the operators cancel each other out:
e.g., `\verb|* ip|', `\verb|* * & ip|', and `\verb|* * * & & ip|'
all reference the same thing.

\subsection{Random Access Memory (RAM) and Blocks}

\ikey{RAM}{Random Access Memory}\index{random access memory!RAM}
is a set of address/byte pairs.  Each 8-bit byte of RAM has an \key{address}
that is a unsigned integer.  It is possible for two addresses to refer to the
same byte, or for an address to refer to no byte.  An address that
refers to a byte is said to be \key{allocated}, and an address that refers
to no byte is said to be \key{deallocated}.  A byte that has two distinct
addresses is said to be \key{shared}, and a byte with just one address is
\key{unshared}.

A \mkey{block}{of RAM} of RAM is a sequence of consecutive increasing addresses.
The \mkey{origin}{of block} of the block is the address of its first byte,
and the \mkey{length}{of block} of the block is the number of bytes.

A block is \mkey{allocated}{block}
if the addresses of all its bytes are allocated,
and is \mkey{deallocated}{block} if the addresses of all of its bytes
are deallocated.
A block is \mkey{unshared}{block} if all its bytes are unshared.
A block is \mkey{shared}{block} if
it is one of a set of several blocks (sequences of consecutive addresses)
such that the $n$'th byte of each block in the set is the same.
Note that a block can be neither shared nor unshared.

The address space is divided into \skey{page}s, which are blocks that
have an implementation determined length
that is a power of two: e.g., 2048 byte = 16386 bit pages.  There
are L-Language operations which call the operating system to
map an address page to physical memory, thus allocating a page
of RAM.  There are operations to deallocate a page, and to make
two pages be shared (map to the same bytes of RAM).

The only way for two blocks to share a byte is for the blocks to
overlap shared pages.

The only blocks in L-language are frame blocks (\pagref{FRAMES}),
code blocks(\pagref{CODE-BLOCKS}), and pages.
Numbers are stored in these blocks.

Block data types are declared by declarations of the form
\begin{center}
\ttkey{deftype} {\em type-name} {\tt (} {\em length}{\tt ,}
				        {\em alignment}{\tt ,}
				        {\em offset}
					{\tt )} {\tt ;}
\end{center}

The layout of a block of the defined type in memory is:

\begin{center}
\begin{picture}(4.0,1.6)
\put(2.0,1.5){\framebox(0.1,0.1){}}
\put(0.0,1.5){\makebox(1.5,0.1)[r]{origin}}
\put(1.6,1.55){\vector(1,0){0.3}}
\put(2.7,1.55){\vector(-1,0){0.5}}
\put(2.0,1.4){\framebox(0.1,0.1){}}
\put(2.0,1.13){\makebox(0.1,0.3){\vdots}}
\put(2.0,1.0){\framebox(0.1,0.1){}}
\put(2.0,0.9){\framebox(0.1,0.1){}}
\put(0.0,0.9){\makebox(1.5,0.1)[r]{address}}
\put(1.6,0.95){\vector(1,0){0.3}}
\put(2.5,0.95){\vector(-1,0){0.3}}
\put(2.4,1.25){\vector(0,1){0.3}}
\put(2.4,1.25){\vector(0,-1){0.3}}
\put(2.4,1.25){\line(1,0){0.6}}
\put(3.1,1.20){\makebox(0.5,0.1)[l]{\em offset}}
\put(2.0,0.8){\framebox(0.1,0.1){}}
\put(2.0,0.7){\framebox(0.1,0.1){}}

\put(2.0,0.43){\makebox(0.1,0.3){\vdots}}
\put(2.0,0.3){\framebox(0.1,0.1){}}
\put(2.0,0.2){\framebox(0.1,0.1){}}
\put(2.7,0.15){\vector(-1,0){0.5}}
\put(2.6,0.85){\vector(0,1){0.7}}
\put(2.6,0.85){\vector(0,-1){0.7}}
\put(2.6,0.85){\line(1,0){0.4}}
\put(3.1,0.80){\makebox(0.5,0.1)[l]{\em length}}
\end{picture}
\\[1ex]
address modulo {\em alignment} = 0
\end{center}

The \mkey{address}{of block} of the block is offset from the origin
of the block by the \mkey{offset}{of block} of block.  This address must be an
exact multiple of the \mkey{alignment}{of block} of the block.
The length of the block is an unsigned integer.  The alignment is an
unsigned integer equal to a power of two that defaults to {\tt 1}.
The offset is a signed integer that defaults to {\tt 0}.

A block can actually have bytes both before and ofter those described by
its type.  Thus the type specifies that every allocated block of the
type will contain allocate bytes at the addresses

\begin{center}
\begin{tabular}{l}
address - offset \\
address - offset + 1 \\
address - offset + 2 \\
\ldots\ldots\\
address - offset + length - 1
\end{tabular}
\end{center}

These are the \smkey{required byte}s{of a block} of the block.
In addition the block may contain \smkey{optional byte}s{of a block}
either before or after the required bytes.

Note that if the {\em offset} is negative, the block address does not
address a required byte, and may not address any block byte.  Similarly
if the {\em offset} is greater than the required block {\em length}.


Blocks contain numbers and addresses.  Access to these is provided by
unchecked pointer computation functions.  For example
\begin{indpar}\begin{verbatim}
deftype type1 (24,4);
unchecked & uns16   .member1 ( & type1 m ) = m@0;
unchecked & int16   .member2 ( & type1 m ) = m@2;
unchecked & int32   .member3 ( & type1 m ) = m@4;
unchecked & float32 .member4 ( & type1 m ) = m@8;
unchecked & type1 * .member5 ( & type1 m ) = m@16;
. . . . .
type1 x;
x.member1 = 9;
x.member2 = -19;
x.member3 = 190;
x.member4 = -0.01 * x.member3;
x.member5 = & x;
\end{verbatim}\end{indpar}

Here $x${\tt @}$y$ is an operation that takes the byte address of
$x$ (i.e., `{\tt \&}$x$'), adds to it the integer $y$, and
stores it in a temporary variable of type `{\tt \& void}'.  In an
{\tt unchecked} function the {\tt void} type can be converted to
any other type.

\subsection{Qualifiers}
\label{QUALIFIERS}

The L-Language controls the way memory is accessed via \skey{qualifiers}s.
A qualifier has a name that is an identifier with optional type parameters,
just as a function has a name that is an identifier with optional
type parameters.

There are several types of qualifiers.

\ikey{Lifetime qualifiers}{lifetime qualifier}
specify the lifetime of a memory location.  The {\tt stack} qualifier
specifies that the location may only last as long as the caller of
a function, or that the location is allocated to the frame of the
function.  The {\tt unlimited} qualifier specifies that the location
has unlimited lifetime, though the location may be garbage collectable.
Additional \skey{collectable qualifier}s may be specified that
indicate that the location is garbage collectable and its address needs
to be protected against collection.

\ikey{Caching qualifiers}{caching qualifier} specify when memory locations
may be changed, and thence when they may be cached in registers.  The
`{\tt constant}' qualifier specifies that a location will not be changed,
and may be cached indefinitely in registers.
Additional \skey{alias qualifier}s may be declared to indicate when
memory locations may overlap.
Normally memory locations that are referenced differently are assumed by the
L-Language to be different memory locations that do not overlap.
To specify that two memory locations might overlap, they must
be given the same alias qualifier.
Additional \skey{parallel qualifier}s may be declared to
identify memory locations whose register \underline{and hardware}
caches are to be flushed by explicit cache flushing statements in the
L-Language.
These are used for memory locations shared between different hardware
processing units (e.g., between a central processing unit and an
IO device, or between two different central processing units).

\ikey{Protection qualifiers}{protection qualifier} control which
functions can access a memory location.
These qualifiers are declared in the program and not built into the
language.
A memory location with protection qualifier $X$ can only be
accessed by functions which have qualifier $X$.

Memory locations can be assigned qualifier expressions that are logical
combinations of qualifier names and the operators `\verb/|/' and
`\verb/&/'.  For example, a memory location may be assigned the expression
`$X$\verb/|constant/' where $X$ is a protection qualifier.  A function
with qualifier $X$ will be able to access such a memory location to both
read and write it, but a function without qualifier $X$ will treat the
function as having the `\verb|constant|' qualifier, will not be able
to write the location, and will be able to assume that the location will
not be written by others.  In order for this to work properly, the functions
with qualifier $X$ that are permitted to write the location must be called
first, before functions without qualifier $X$ are allowed to access the
location.


\subsubsection{Lifetime Qualifiers}
\label{LIFETIME-QUALIFIERS}

Two lifetime qualifiers are builtin:  `{\tt stack}', and `{\tt unlimited}'.
One kind of lifetime qualifier is declarable: collectable qualifiers.

\begin{indpar}

\hspace*{-1em}\ttkey{stack}~~When used in an argument or return type,
indicates that a memory location lifetime is at least as long as the
lifetime of the calling function execution's stack frame.  When used
for a memory location allocated by the current function execution,
indicates that the memory location lifetime is that of the current
function execution.

If the `{\tt stack}' qualifier is applied to the value returned by a
function call, the memory location is allocated by the caller and not
the called function.  There must be a `{\tt \&}' preceeding the
`{\tt stack}' qualifier in the return value type.  For example:
\begin{indpar}[0.5em]\begin{verbatim}
int function1 ( int arg1 );
    // Returns a int value in a register.
& global int function2 ( int arg1 );
    // Returns an address of int value in a register.
& stack int function3 ( int arg1 );
    // Returns an int value in a location whose address is passed
    // by the caller to the called function3.
\end{verbatim}\end{indpar}

A `{\tt stack}' memory location may be cached in a register,
but this cache must
be flushed when the address of the location is passed
to a called function.

The address of a `{\tt stack}' memory location may only be stored
by a function execution in its frame, or passed to called functions
whose argument or return value types indicate they accept `{\tt stack}'
locations.

\hspace*{-1em}\ttkey{unlimited}~~Unlimited memory locations can be
accessed by any function execution and their addresses may be stored
in any place.

\hspace*{-1em}\ikey{Collectable Qualifiers}%
{collectable qualifier}~~Collectable
qualifiers are declared by the programmer and are used to tag
memory locations can be garbage collected.  When the address of a garbage
collectable memory location is returned by a function, it is registered
with the garbage collector, so it will not be collected.  This is usually
done by placing a pointer to the location in a stack.  The stack is
popped when a function that may have pushed addresses into the stack
returns.

Like unlimited memory locations, collectable locations can be
accessed by any function execution and their addresses may be stored
in any place.



\end{indpar}

\subsubsection{Caching Qualifiers}
\label{Caching-QUALIFIERS}

One caching qualifier is builtin: `{\tt constant}'.

\begin{indpar}

\hspace*{-1em}\ttkey{constant}~~The memory location is constant and will not
be modified at all.

The memory location can be cached in registers without
restriction.

Memory locations declared `{\tt constant}' must be written during their
initialization.  This is managed by not declaring these locations to be
`{\tt constant}' when they are passed to constructors.

The following code has some examples:
\begin{indpar}[0.5em]\begin{verbatim}
int function1 ( & stack constant arg1 );
int function2 ( & stack arg1 );
int function3 ( void )
{
   constant int value1 = 5;
       // Permitted:
       //   & stack int .constructor. ( 5 ) is called.
   value1 = 10; 
       // Erroneous:
       //   & stack constant int .assign. ( 10 ) is called.
   function1 ( value1 );  // Permitted; arg1 constant.
   function2 ( value1 );  // Erroneous; arg1 NOT constant.
}
\end{verbatim}\end{indpar}


\end{indpar}

\subsection{Frames}
\label{FRAMES}

A \key{frame} is a set of non-overlapping
data blocks associated with a function
execution (see Functions, \pagref{FUNCTIONS}).  The blocks of a frame,
which are called \skey{frame block}s,
are allocated (come into existence) when the function execution begins,
and are deallocated (cease to exist) when the function execution ends.

There are three types of frame blocks:

\begin{indpar}

\hspace*{-1em}{\bf Local}.~~A \key{local frame block}
can only be accessed by the frame's function.
It cannot be accessed during calls made by this function,
or by functions running in parallel with this function.

\hspace*{-1em}{\bf Cache}.~~A \key{cache frame block}
can only be accessed by the frame's function or during calls
made by this function.  It cannot be accessed by functions running
in parallel with the frame's function.
Furthermore, if the block is modified during a call made by the
frame's function,
bits called `\skey{modification bit}s' are set in the block,
or in another cache block in the same frame.

\hspace*{-1em}{\bf Global}.~~A \key{global frame block}
can be accessed by the frame's function or during calls
made by this function.  It cannot be accessed by functions running
in parallel with the frame's function.

\end{indpar}

Note that parallel function calls cannot access blocks in a function's
frame.

\subsection{Heaps}
\label{HEAPS}

A \key{heap} is a set of non-overlapping data blocks \underline{not}
associated with any function execution.  The blocks of a heap,
which are called \skey{heap block}s.  Each heap is associated with
functions that allocate and deallocate blocks in the heap.

There are three types of heap blocks:

\begin{indpar}

\hspace*{-1em}{\bf Cache}.~~A \key{cache heap block}
is associated with a thread (see Threads, \pagref{THREADS}) and
can only be accessed by the function executions in that thread.
It cannot be accessed by function executions in other threads.
Furthermore, if the block is modified during a function execution,
bits called `\skey{modification bit}s' are set in the block,
or in another cache block associated with the same thread
in the same heap.

\hspace*{-1em}{\bf Global}.~~A \key{global heap block}
is associated with a thread and
can only be accessed by the function executions in that thread.
It cannot be accessed by function executions in other threads.

\hspace*{-1em}{\bf Parallel}.~~A \key{parallel heap block}
can only be accessed by function executions in any thread.

\end{indpar}

Note that parallel function calls cannot access blocks in a function's
frame.

\subsection{Registers}

A \key{register} is assigned a \mkey{type}{of register}
and some optional \mkey{type parameters}{of register}
and can hold any of the following:

\begin{center}
\begin{tabular}{l@{~~~~~~}l}
\bf Register Type & \bf Type Parameters \\[2ex]
unsigned integer & length \\
signed integer & length \\
floating point number & length \\
direct address \\
indirect address & level \\
linear channel & block-size window-size dimensions \\
chained channel & block-size window-size dimensions  \\
direct channel & block-size window-size dimensions \\
\end{tabular}
\end{center}

The type parameters are unsigned integers that
determine the sized of the register.

Registers with a number type can only hold numbers of the given register
type and register length.

An indirect address is consists of a direct address and a sequence of
zero or more offsets, each of which is a signed 64 bit integer.  The
number of offsets is the level of the indirect address.

A channel is a mechanism for caching a window of memory.  The window
consists of a linear array of blocks which are addressed by various
different means.  The block-size parameter specifies the maximum block
size, the window-size parameter the maximum size of any window dimension, 
and the dimensions parameter the maximum
number of dimensions in the window array.

Registers are virtual; some are implemented by hardware registers,
and some are implemented by a \key{frame}
which is an allocated block of RAM
associated with the currently executing code.

[TBD: Add register pointers and register sharing.]

\subsection{Indirect Addresses}

An \key{indirect address} consists of a direct address $A$
and $L$ offsets, $O_1$, $O_2$, \ldots, $O_L$, where $L\geq 0$ is the
\mkey{level}{of indirect address} of the indirect address.
The indirect address represents the \mkey{target address}{of indirect address}:

\begin{center}
\begin{tabular}{l@{~~~~~~}l}
\bf Level & \bf Target Address \\[2ex]
0 & $(*A)$ \\
1 & $((*A)+O_1)$ \\
2 & $(*((*A)+O_1)+O_2)$ \\
3 & $(*(*((*A)+O_1)+O_2)+O_3)$ \\
\ldots & \ldots
\end{tabular}
\end{center}

where $*$ is the \key{indirect addressing operation}
that takes the direct address $D$ of another direct address $F$ stored
in RAM, and returns $F$.  $F$, which is called the \key{forwarding address},
is both a direct address number and a block, and as a block
is required to have 64 bits as both its length and alignment.

The important thing about an indirect address is that the forwarding addresses
it accesses are permitted to change at most times, as long as they
are changed according to a protocol (\pagref{INDIRECT-ADDRESS-PROTOCOL}).
The forwarding addresses point at blocks that can be moved in memory at
any time the forwarding addresses are permited to change.  Moving blocks in
memory is part of memory compaction, which in turn is part of garbage
collection, so indirect addresses enable real-time garbage collection.

The offsets of an indirect address are 64-bit integers whose
units are bytes.  The $+$ operator in the target address computation
is treated as addition modulo $2^{64}$ of unsigned integers, so the offsets
can be either unsigned or signed.  Addition overflow is not possible.


\subsection{Memory Channels}
\label{MEMORY-CHANNELS}

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
multi-dimensional array of block descriptors.
A \key{block descriptor} contains the address and length of a block to be
accessed.  Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
There are shift operations on the window that move all its rows or columns
(or other dimension) over and fill in with empty block descriptors.

A memory channel is stored in a register, but the register may be shared.
The type and type parameters of the register determine the type of the
channel and determine how much actual memory is allocated to the register.

The window of a memory channel
is organized in the same way for all memory channels.
It consists of a rectangular array of block descriptors, with the number
of dimensions in the array being that given by the
`\mkey{dimensions}{of window}' register type parameter.  The size of
each dimension is determined when the memory channel is initialized at
run time, but must not be greater than the `\mkey{window-size}{of window}'
register type parameter.
Similarly the size of each block is determined when the block descriptor
is created, but must not be greater than the `\mkey{block-size}{of window}'
register type parameter.

For all types of memory channel the window appears to be a subarray of
a larger square array.  The window has a \mkey{reference point}{of window}
that can be shifted along any of its dimensions.  Or the reference point
can be completely reset.  For most kinds of memory channels, window
block descriptors are computed automatically from the block descriptor
and in some cases block contents of an adjacent window position.
In the typical case, once an initial reference point
block descriptor has been loaded into the memory channel, all other
block descriptors are computed automatically by this mechanism, and
typically the reference point is only moved by shifting it.

Memory channels differ in how block descriptors are computed.  A
linear memory channel assumes that blocks are addressed in memory according
to a linear scheme, and automatically fills in block descriptors when
the window is shifted.  A chained channel is similar except it assumes
each block points at its neighbors.  A direct channel requires programmed
instructions to load block descriptors.  In this last case, a block
descriptor may hold an instruction for computing it from the contents
of an adjacent block, so the instruction need not be delayed if the
adjacent block contents are not yet available.

When a window is shifted, block descriptors may be computed automatically
for new window elements, and the referenced blocks may be loaded into
a cache.  The part of the window for which blocks are loaded into the
cache in advance of any specific instruction referencing the blocks
is called the lookahead window, and is a subarray of the full window.


\subsubsection{Linear Memory Channels}

Linear memory channels access multi-dimensional arrays of blocks
whose addresses are computable from a linear equation of the form:

\begin{center}
$\mbox{\em address} = \mbox{\em base-address}
		    + \sum_{n=1}^N \mbox{\em offset}_n\cdot i_n$
\\[2ex]
where $0\leq i_n < \mbox{\em dimension-size}_n$ for $1\leq n \leq N$
\end{center}

\subsubsection{Chained Memory Channels}

For a chained memory channel there are a fixed set of instructions
that tell how to compute the address of a block from the contents
of adjacent blocks.


\section{Code Blocks}
\label{CODE-BLOCKS}

\section{To Do}

Indirect address protocol.
\label{INDIRECT-ADDRESS-PROTOCOL}

Functions.
\label{FUNCTIONS}

Threads.
\label{THREADS}

\bibliographystyle{plain}
\bibliography{layered-l-language}

\printindex

\end{document}
