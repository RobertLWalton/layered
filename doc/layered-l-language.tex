% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{\,\textsuperscript{p\pageref{#1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\TMP}{\$}			% Compiler Temporary
\newcommand{\ABV}{-{}-{}->}		% Abbreviates
\newcommand{\CNV}{\longrightarrow}	% Converts to
\newcommand{\TCNV}{\Longrightarrow}	% Transitive closure

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

March 31, 2018
 
\end{center}

{\small \tableofcontents}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language.  See the Introduction to the Layered
Programming Languages for basic syntax and for an overview of the related
Middle Layer M-Language and Higher Layer H-Language (these overviews
have not yet been written).

The L-Language is intended to be a target language for compilers of
higher level languages.  As such it is optimized first to be an easy to 
use as a target language, and second to be easy to
compile into reasonably efficient debuggable assembly language code.

The L-Language is similar to the C programming language
but differs in the following ways:

\begin{enumerate}

\item
L-Language facilitates isolating non-type-safe code into small inline functions.

\item
All L-Language data types are builtin number types or subtypes of
builtin number types.  All data managed directly by L-Language consists
of single numbers allocated to the stack.

\item
Memory references other than those to single stack allocated numbers
are handled by code
encapsulated in small inline functions written by the programmer.
These memory references
are treated in a manner reminiscent of input/output.
The bodies of these inline functions are not type-safe, but if
there are written correctly, usage of these functions is type-safe.

\item
There is no concept of a memory structure in the L-Language.  There
is a new concept, the `cluster', which is a collection of stack
variables that can be passed to inline functions
and returned from inline functions as a syntactic unit.

\item
The type `\TT{type}' is first class, is a subtype of integers, and
each `\TT{type}' value is assigned
a unique constant small integer value.  Constant
argument values, such as the value of a `\TT{type}' valued
argument, can be used to select overloaded functions.

\item
Most L-Language functions are inline.  Out-of-line functions can be
called using a block syntax that mirrors the overhead involved in
manipulating an argument stack in memory.

\item
L-Language uses a single-assignment style of program structure
to encourage
efficient code that leaves an audit trail for debugging in the stack.
Partial evaluation of expressions and inline code is supported without
compromising debuggability.

\item
L-Language allows code to be compiled at run-time just before
it is run, for extra efficiency.

\item
L-Language allows code to be compiled into the compiler, to support
language enhancements.

\item
L-Language uses the Layered Language Module Structure to manage
multi-file source code in a well-ordered and type-safe manner.


\end{enumerate}


\section{Lexemes}
\label{LEXEMES}

An L-Language source file is a sequence of bytes that is a UTF-8 encoding
of a sequence of UNICODE characters.  This is scanned into a sequence
of \skey{lexeme}s.

Unless otherwise specified, the term `\key{character}' in this
document means a 32-bit UNICODE character.

Lexemes are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes single space) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} :::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::=
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe}, \\
    and \TT{Pf}; includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{decimal-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em decimal-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment}\label{COMMENT} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

One kind of {\em horizontal-space} is given special distinction:
\begin{indpar}
\emkey{indent}\label{INDENT} ::=
	\begin{tabular}[t]{l}
        {\em horizontal-space} just before the first \\
	{\em graphic} character on a line
	\end{tabular}
\end{indpar}

The \skey{indent lexeme}s have no characters, but
do have an \mkey{indent}{of indent lexeme}, which is the indent of
the graphic character after the indent lexeme.
The \mkey{indent}{of character} of a character is the number
of columns that precede the character in the character's physical line.
Indent lexemes are used to form logical lines and blocks
(\itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break}\label{LINE-BREAK} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

A non-{\em indent}, non-{\em line-break} {\em white-space}, such as occurs
in the middle of text or code outside comments, is discarded and not treated
as a lexeme.  Such {\em white-space} may be used to separate lexemes.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::=
    \begin{tabular}[t]{l}
    {\em horizontal-space-character}, other than \\ single space
    \end{tabular}
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= {\em vertical-space-character}
	other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::=
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} \\
    or {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::=
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these strings generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

\begin{boxedfigure}[!p]
\begin{indpar}

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em word} $|$ {\em mark} $|$ {\em number} $|$
	      {\em separator} $|$ {\em quoted-string} $|$ {\em indent} \\
	$|$ & {\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}\label{CHARACTER-REPRESENTATIVE}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{number} \begin{tabular}[t]{rl}
    ::= & {\em middle-lexeme} with a {\em digit} before any {\em letter} \\
    $|$ & {\em middle-lexeme} with a {\em digit} immediately after
                               a `\TT{+}' or `\TT{-}' \\
	\end{tabular}
\\[0.5ex]
\emkey{natural-number}\label{NATURAL-NUMBER}
	:::= {\em decimal-digit}\PLUS{} not beginning with \TT{0} $|$ \TT{0}
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme} containing a {\em letter} that is not
                  a {\em number}
\\[0.5ex]
\emkey{mark} :::= {\em middle-lexeme} that is not a {\em word} or
		  {\em number}
\\[0.5ex]
{\em indent} ::= see \pagref{INDENT}
\\[0.5ex]
{\em line-break} ::= see \pagref{LINE-BREAK}
\\[0.5ex]
{\em comment} ::= see \pagref{COMMENT}
\\[0.5ex]
{\em end-of-file} ::= see \pagref{END-OF-FILE}

\end{indpar}
\caption{L-Langauge Program Lexemes}
\label{L-LANGUAGE-PROGRAM-LEXEMES}
\end{boxedfigure}

The lexemes in a L-Language program are specified in
Figure~\itemref{L-LANGUAGE-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see page \pageref{ILLEGAL-CHARACTERS}
above to account for such characters.

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file}\label{END-OF-FILE}
lexeme that occurs only at the end of a file.

Files are scanned into sequences of lexemes which are then divided
into logical lines as per \itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}.
After each logical line is formed,
{\em indent}, {\em comment},
{\em line-break}, and {\em end-of-file} lexemes are deleted
from the logical line.

\ikey{Quoted string lexemes}{quoted strings!concatenated}
separated by the `\TT{\#}' mark
are glued together if they are in the
same logical line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence" #
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

A \emkey{special-character-representative} can consist of
a UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.

A {\em special-character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.

\section{Logical Lines, Blocks, and Statements}
\label{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}

Each non-blank physical line begins with an {\em indent} lexeme
that is followed by a
lexeme that is not an {\em indent}, {\em line-break}, or
{\em end-of-file}.

Lexemes are organized into \skey{logical line}s.  A logical line
begins immediately after an {\em indent} lexeme, and the
\mkey{indent}{of logical line} of the logical line is the
indent of this {\em indent} lexeme (i.e., the indent of the
first graphic character of the logical line).

A logical line ends with the next {\em indent} lexeme whose indent
is not greater than the indent of the logical line, or with an
{\em end-of-file}.  Thus physical
lines with indent greater than that of the current logical line
are \skey{continuation line}s for that logical line.

A code file is a sequence of `\key{top level}' logical lines that
are required to have indent \TT{0}.

A logical line may end with a \key{block} that is itself a sequence of
logical lines that have indents greater than the indent of the
logical line containing the block.
The block is introduced by a `\TT{:}' at the end
of a physical line.  If the first {\em indent} lexeme after the
`\TT{:}' has an indent that is \underline{not} greater than the indent
of the logical line containing the `\TT{:}', the block is empty.
Otherwise the indent of this {\em indent} lexeme becomes the
\mkey{indent}{of block} of the block and the indent of all the
logical lines in the block.  The first logical line of the block
starts immediately after this {\em indent} lexeme.
The block ends just before the first
logical line with lesser indent than the block indent, or the end of file.
More specifically, the last logical line of the block ends with an
{\em indent} whose indent is less than the block indent, or with an
{\em end-of-file}.

Examples are:
\begin{indpar}\begin{verbatim}
this is a top level logical line ending with a block:
    this is the first line of the block
    this is the
         second line of the block
    this is the third line of the block:
        this is the first line of a subblock
        this is the second line
                of the subblock:
            this is the only line of a sub-subblock
        this is the third line of the subblock
    this is the fourth line
            of the block:
        this is the only line of the second subblock
    this is the fifth line of the block
         and it ends with an empty subblock:
this is the second top level
     logical line
\end{verbatim}\end{indpar}

A warning message is output if the indents of any two
consecutive logical lines differ by more than \TT{0} and
less than \TT{2} columns, in order to better detect
indentation mistakes.

{\em Line-break} lexemes are effectively ignored.  A sequence
of {\em line-break} lexemes is followed by an {\em indent}
or {\em end-of-file} which is not ignored.
Blank physical lines are represented by sequences of
more than one {\em line-break} lexeme, and are effectively
ignored.

A logical line that contains {\em comments}, but no
lexemes other than {\em comments}, {\em line-breaks}, {\em indents}
and a possible {\em end-of-file}, is
a `\key{comment line}', and is ignored.

It is an error to begin non-comment logical lines with
a {\em comment}.
{\em Comments} can be used freely in the middle of or at the
end of any logical line, or at the beginning of a comment line.

It is an error for the first logical line of a file
to have an indent that is greater than \TT{0}, the top level
indent.

It is an error for a block to be in the middle of a logical
line.  This means that the first {\em indent} following the
block must have an indent no greater than that of the logical
line containing the block.

Examples are:
\begin{indpar}\begin{verbatim}
// this is a logical line that is a single comment

// this is a logical line that has two
    // comments

this is a logical line // with a comment
     // and another comment
     with three comments // and a last comment

this is a logical line ending with a block:
     First line of the block
     Second line of the block
// Comment that ends block, but is in error because

    it begins a logical line that this continues

this is a logical line with a block:
     First line of the block
     Second line of the block
  but the block is in error because it is before
  this continuation of the logical line that contains
  the block

this is a logical line ending with a block:
        First line of the block
        Second line of the block
  // comments that end the block, but are in error,
  // because they continue the logical line
  // containing the block
\end{verbatim}\end{indpar}

After a logical line
has been formed, any {\em indent},
{\em comment}, {\em line-break}, and {\em end-of-file}
lexemes in the logical line
are removed from the logical line.  If the result is
empty, i.e., the logical line is a comment line, it is discarded.
Otherwise the
modified logical line becomes a L-Langauge `\emkey{statement}'.

Therefore a file is a sequence of top-level statements.

Since a logical line can end with a block that itself consists
of a sequence of logical lines, a statement can end with
a block that itself consists of a sequence of statements.


\section{Names}
\label{NAMES}

A \key{name} is a sequence of lexemes used to name things like
variables and functions.

\begin{indpar}
\emkey{name}\label{NAME} ::=
    {\em initial-name-item} {\em continuing-name-item}\STAR{} \\
\emkey{initial-name-item} ::= {\em name-item} other than {\em natural-number} \\
\emkey{continuing-name-item} ::= {\em name-item} not containing `\TT{.}' \\
\emkey{name-item}\label{NAME-ITEM}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} containing no `\TT{.}' following a character
                     that is not a `\TT{.}' \\
        & [see text about splitting words with embedded `\TT{.}'s] \\
    $|$ & {\em natural-number} \\
    $|$ & {\em quoted-mark} not containing `\TT{.}'s \\
    $|$ & {\em quoted-separator} not containing `\TT{.}'s \\
    \end{tabular} \\
\emkey{quoted-mark} :::= \TT{"} {\em mark} \TT{"} \\
\emkey{quoted-separator} :::= \TT{"} {\em separator} \TT{"}
\end{indpar}

{\em Words} containing embedded `\TT{.}'s are split into
{\em name-items} which can only contain `\TT{.}'s at their beginning.
Thus
\begin{center}
\TT{bills.wife.1.weight..size}
\end{center}
is split into
\begin{center}
\TT{bills~~~.wife~~~.1~~~.weight~~~~..size}
\end{center}
However, `\TT{.1}' is not a legal {\em name-item} and so cannot
be part of a legal {\em name}.

Name items beginning with more than one beginning `\TT{.}' are reserved
for use by systems and compilers (e.g., \TT{..size} in the example).

Words ending with `\TT{\TMP$n$}', where $n$ is a {\em natural-number}, are
reserved for use by the compiler and may not be used in names by the
L-Language user.  For example, names of the form \TT{T\TMP$n$} are used as
temporary variables introduced during compilation.

Names can be computed at compile time:
see~\itemref{THE-NAME-TYPE}.
One name can be used to abbreviate another:
see~\itemref{ABBREVIATIONS}.
A name may begin with a {\em word} that is a {\em module-abbreviation}
that designates a code module: see~\itemref{MODULES}.

A {\em name} may be an abbreviation for another name.  Such abbreviations
can be introduced by statements of the form
\begin{center}
{\em abbreviation-name} \TT{\ABV} \TT{`}{\em replacement-name}\TT{'}
\end{center}
See the section on abbreviations
(\itemref{ABBREVIATIONS})
for more details.

The builtin names in this document are implicitly in the
\TT{"standard"} module whose {\em module-abbreviation} is `\TT{std}'.
See the section on modules (\itemref{MODULES}) for details.
For example the name `\TT{bool}' of the boolean data type is actually a builtin
abbreviation defined by:
\begin{center}
\TT{bool {\ABV} `std bool'}
\end{center}
and the builtin type name proper is `\TT{std bool}' and not `\TT{bool}'.


Similarly the  builtin function such as \TT{round} as used in:
\begin{center} \tt
\begin{tabular}{l}
float$x$ v = \ldots{} \\
float$x$ r = round ( v ) \\
\end{tabular}
\end{center}
actually has the function prototype (\pagref{FUNCTION-PROTOTYPE}):
\begin{center}
{\tt function std float$x$ r = std round ( std float$x$ v )} \\
\end{center}
so its proper name is `\TT{std round}' and not `\TT{round}',
but in this case it is not necessary (or desirable) to make `\TT{round}'
an abbreviation because its module can be implied in a function call
(see `module deficient' on \pagref{MODULE-DEFICIENT}).

\subsection{Kinds of Names}
\label{KINDS-OF-NAMES}

The L-Language uses several kinds of names:

\begin{indpar}
\emkey{module-abbreviation}
	::= \TT{word} not containing any `\TT{.}'s \\
\emkey{type-name}\label{TYPE-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{qualifier-name}\label{QUALIFIER-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{variable-base-name}\label{VARIABLE-BASE-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{variable-name}\label{VARIABLE-NAME}
	::= {\em variable-base-name} {\em member-selector}\STAR{} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript } \\
\emkey{member-name}\label{MEMBER-NAME}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark}
			    or {\em quoted-separator}
			\end{tabular} \\
\emkey{member-subscript} ::= see \pagref{MEMBER-SUBSCRIPT} \\
\emkey{block-name}\label{BLOCK-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{function-term-name} ::= {\em name} \\
\emkey{function-variable-name} ::=
    \begin{tabular}[t]{@{}p{4in}@{}}
    {\em function-term-name} $N$ that appears in a {\em function-prototype}
    of the form `{\tt function $N$ = \ldots};
    see \pagref{FUNCTION-VARIABLE-NAME}
    \end{tabular}

where
\begin{enumerate}
\item
A {\em qualifier-name} or {\em type-name} must not be an initial segment
of a {\em name} $N$ that might begin a {\em statement} of
the form `{\tt $N$ = \ldots}'.  Examples of such names $N$
are {\em deferred-result-variables} (\pagref{DEFERRED-RESULT-VARIABLE})
and {\em function-variable-names} (\pagref{FUNCTION-VARIABLE-NAME}).
\label{TYPE-NAME-RULE}
\item
A {\em type-name}, {\em qualifier-name}, or {\em variable-base-name}
may not begin with the word `\TT{next}' or `\TT{previous}' or
contains the words `\TT{is}', `\TT{as}', `\TT{with}', or `\TT{without}.
\item
{\em Name-items} ending with `\TT{\TMP$n$}',
where $n$ is a {\em natural-number}, are
reserved for use by the compiler.
\item
{\em Name-items} beginning with `\TT{..}' (possibly followed by more
`\TT{.}'s) are reserved
for use by systems and compilers (e.g., `\TT{..size}').
\end{enumerate}
\end{indpar}

The first two rules are not enforced as such.  Instead the parser
parses statements into abstract syntax trees that contain
sequences of names, without separating the names in each sequence.
Then as a first step in compilation after parsing,
any name sequence that might be of the form
\begin{center}
{\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
\end{center}
is scanned left to right to first remove any {\em qualifier-names}
and then a {\em type-name}, leaving a non-empty {\em variable-name}.
At any point, if several suitable {\em names} match the
beginning of the remaining part of the name sequence, the longest
is choosen.  If this process succeeds without backup, the name
sequence is of the above form.  Otherwise it is not -- there is
no backup.  If the process does not suceed, in some
cases the name sequence may still be a single {\em variable-name}
by itself, and in other cases it might be a sequence of one or
more {\em function-term-names}.
Also the {\em qualifier-name} and {\em type-name}
candidates are those of the current scope (\pagref{SCOPE}).

Name sequences that might be of the above form can only occur at
the beginning of a statement or as a {\em result-variable-declaration}
or an {\em argument-declaration} in a {\em function-prototype}.

In addition, non-empty name sequences of the form
\begin{center}
{\em qualifier-name}\STAR{} {\em type-name}\QMARK{}
\end{center}
may appear in abstract tree subexpressions of the form
\begin{center}
{\em name-sequence} {\tt (~\ldots{}~)}
\end{center}
and are treated similarly.


\subsection{Abbreviations}
\label{ABBREVIATIONS}


An \key{abbreviation} is a {\em name} that is replaced
by another {\em name}.  There are separate abbreviations for
{\em qualifier-names}, {\em type-names}, {\em variable-base-names},
and {\em member-names}.

Abbreviations are declared by:
\begin{indpar}
\emkey{abbreviation-declaration}\label{ABBREVIATION-DECLARATION}
    ::= {\em abbreviation} ~ \ttkey{-{}-{}->} ~ {\em abbreviation-replacement}
\\[1ex]
\emkey{abbreviation} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\\[1ex]
\emkey{abbreviation-replacement} ::= \\
\hspace*{0.5in}
    {\em expression} that evaluates at compile time to a \TT{name};
    see \itemref{THE-NAME-TYPE}
\end{indpar}

The most common {\em abbreviation-replacement} is a {\em name-constant}:

\begin{indpar}
\emkey{name-constant}
    ::= \TT{`}{\em name-item}\STAR{}\TT{'} \\
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

The only {\em names}
that can be abbreviated are {\em qualifier-names},
{\em type-names}, {\em variable-base-names}, and
{\em member-names}.
{\em Module-abbreviations} and
{\em function-term-names} \underline{cannot} be abbreviated.

If the replacement name of an {\em abbreviation} is a {\em qualifier-name}
in the context of the {\em abbreviation-declaration},
the {\em abbreviation} becomes a {\em qualifier-name}, and
must have they syntax of a {\em qualifier-name}.
Similarly, if the replacement name of an {\em abbreviation} is a {\em type-name}
in the context of the {\em abbreviation-declaration},
the {\em abbreviation} becomes a {\em type-name}, and
must have they syntax of a {\em type-name}.
In other cases, the {\em abbreviation} must have the syntax of
a {\em variable-base-name} if its replacement does, and the syntax of
a {\em member-name} if its replacement does.

The rules in \itemref{KINDS-OF-NAMES}
apply to {\em abbreviations}.  In particular the rules regarding
{\em qualifier-names} and {\em type-names} apply to {\em abbreviations}
that are such.

Abbreviation replacement occurs after
{\em qualifier-names},
{\em type-names}, {\em variable-base-names}, and
{\em member-names} have been identified by the compiler.

Abbreviations are never external (\pagref{EXTERNAL}),%
\label{ABBREVIATIONS-ARE-NOT-EXTERNAL}
even if they begin with a {\em module-abbreviation}.
They do have scope (\pagref{SCOPE}) like other declarations, but their scope
never extends beyond the file in which they are declared.

Some examples are:
\begin{indpar}\begin{verbatim}
int32 ---> `std int32'
uns64 ---> `std uns64'
    // Builtin type abbreviations
*UNCHECKED*  ---> `std *UNCHECKED*'
    // Builtin qualifier abbreviation

*UNCHECKED* int32 x 1 = 99
    // Same as: std *UNCHECKED* std int32 x 1 = 99
.foo ---> `fee'
    // Illegal: `fee' does not begin with `.'.
"+" ---> `std int62'
    // Illegal: `"+"' is not allowed as a type name.

int64 unsigned ---> `uns64'
int64 unsigned z = 9 + 7
    // Legal, same as: std uns64 z = (9) "+" (7)
    // Matches function prototype:
    //   function std uns64 r =
    //       std (std uns64 v1) "+" (std uns64 v2)
    // unless another function with prototype:
    //   function std uns64 r =
    //       (std uns64 v1) "+" (std uns64 v2)
    // is defined.

x 1 ---> `x'
.foo ---> `.fee'
int64 y = x 1 .foo + 10
    // Same as: std int64 y = (x.fee) "+" (10)
\end{verbatim}\end{indpar}

Abbreviation is recursive: an {\em abbreviation-replacement} can
itself be an abbreviation.
Abbreviation loops are possible and result in compile errors when
the abbreviation is used.
For example:
\begin{indpar}\begin{verbatim}
    X ---> `Y'
    int64 X = 5       // Same as: std int64 Y = 5
    Y ---> `Z'
    int64 X = 5       // Same as: std int64 Z = 5
    Z ---> `X'
    int64 X = 5       // Compile error replacing X.
\end{verbatim}\end{indpar}


\section{Program Organization}
\label{PROGRAM-ORGANIZATION}

Code is organized into two kinds of files: \skey{module}s
and \ikey{bodies}{body}.
Each body is associated
with a particular module, the `\key{module of the body}',
and extends that module.  A module
may have zero or more bodies.
A module and all its bodies together form
an `\key{extended module}'.

Modules and bodies consist of a sequence
of \skey{declaration}s:
\begin{indpar}
\emkey{declaration}
    \begin{tabular}[t]{rll}
    ::= & {\em module-declaration}
        & [see \pagref{MODULE-DECLARATION}] \\
    $|$ & {\em body-declaration}
        & [see \pagref{BODY-DECLARATION}] \\
    $|$ & {\em defined-type-declaration}
        & [see \pagref{DEFINED-TYPE-DECLARATION}] \\
    $|$ & {\em enum-type-declaration}
        & [see \pagref{ENUM-TYPE-DECLARATION}] \\
    $|$ & {\em enum-set-type-declaration}
        & [see \pagref{ENUM-SET-TYPE-DECLARATION}] \\
    $|$ & {\em enum-list-type-declaration}
        & [see \pagref{ENUM-LIST-TYPE-DECLARATION}] \\
    $|$ & {\em qualifier-declaration }
        & [see \pagref{QUALIFIER-DECLARATION}] \\
    $|$ & {\em function-type-declaration }
        & [see \pagref{FUNCTION-TYPE-DECLARATION}] \\
    $|$ & {\em out-of-line-function-declaration }
        & [see \pagref{OUT-OF-LINE-FUNCTION-DECLARATION}] \\
    $|$ & {\em function-declaration }
        & [see \pagref{FUNCTION-DECLARATION}] \\
    $|$ & {\em abbreviation-declaration }
        & [see \pagref{ABBREVIATION-DECLARATION}] \\
    $|$ & {\em assignment-statement }
        & [see \pagref{ASSIGNMENT-STATEMENTS}] \\
    \end{tabular}
\end{indpar}

Declarations declare {\em names} and {\em function-prototypes}.
An {\em assignment-statement} is also a {\em declaration} of
its result {\em variable-names}.

{\em Names} shared between modules begin with {\em module-abbreviations}
that designate the module in which the name is declared.
Such names are called `\key{external}'.\label{EXTERNAL}
Similarly the pattern of a {\em function-prototype}
(\pagref{FUNCTION-PROTOTYPE})
may begin with the {\em module-abbreviation} of the module in
which the prototype is declared,
and such prototypes are `\key{external}'.

External names and prototypes can only be declared in modules, and
never in bodies.  External names and prototypes cannot be declared inside
statement blocks, but must be declared at `top level' outside
blocks.

As an exception, abbreviations are never external, even if
they begin with a {\em module-abbreviation}
(\pagref{ABBREVIATIONS-ARE-NOT-EXTERNAL}).

In inline function calls the
{\em module-abbreviation} may be omitted
if the {\em function-prototype} matching the call
can be unambiguously determined: see
`module deficient' on \pagref{MODULE-DEFICIENT}.
This may not be done
for names (e.g., external types, external variables).

An example is:
\begin{indpar}\begin{verbatim}
module "lib/math" as math

define type math complex as void
    // Given `math complex x', x[0] is the real part of a
    // complex number and x[1] is the imaginary part.

function math complex r, float64 r[0], float64 r[1] =
    math complex ( float64 real, float64 imaginary ):
    r[0] = real
    r[1] = imaginary

function math complex r, float64 r[0], float64 r[1] =
    math ( math complex a1, float64 a1[0], float64 a1[1] )
    "+"  ( math complex a2, float64 a2[0], float64 a2[1] ):
    r[0] = a1[0] + a2[0]
    r[1] = a1[1] + a2[1]

---------------------------------------------
module "my-module" as mine
    import "lib/math" as math

.............................
math complex x = math complex ( 1, 0 )
math complex y = complex ( 0, 1 )
    // The second `complex' in each line is a function name
    // so `math' may be omitted.  In this case the function
    // prototype that applies is selected by the y result
    // variable type.
math complex z1 = x + y
    // Parses to `math complex z1 = ( (x) "+" (y) )'.
    // Standard "+" does not apply because it does not match
    // result type.  `math' module abbreviator is implied so
    // that `math' module "+" applies.
math complex z2 = math ( x + y )
    // Parses to `math complex z2 = ( math (x) "+" (y) )'.
    // `math' module abbreviator for "+" is explicit and
    // NOT implied.
\end{verbatim}\end{indpar}

\subsection{Modules}
\label{MODULES}

A \key{module} is a file that begins with a {\em module-declaration}:

\begin{indpar}
\emkey{module-declaration}\label{MODULE-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= & {\em simple-module-declaration} \\
    $|$ & {\em simple-module-declaration}\TT{:} \\
	& \TT{~~~~}{\em import-clause}\STAR{} \\
    \end{tabular} \\
\emkey{simple-module-declaration} ::= \TT{module} {\em module-name}
        \TT{as} {\em module-abbreviation} \\
\emkey{module-name} ::= {\em quoted-string} \\
\emkey{module-abbreviation}\label{MODULE-ABBREVIATION}
	::= \TT{word} not containing any `\TT{.}'s \\
\emkey{import-clause}\label{IMPORT-CLAUSE} ::= \TT{import} {\em module-name}
        \TT{as} {\em module-abbreviation}

\begin{itemize}

\item
In a {\em module-declaration} all {\em module-abbreviations} must be
distinct, and all {\em module-names} must be distinct.
\end{itemize}
\end{indpar}

A {\em module-name} is a POSIX file name.
The {\em module-name} of a {\em module-declaration} must match the
name of the file containing the
{\em module-declaration}, relative to one of several directories
specified separately to the compiler.

The {\em module-abbreviation} associated with a {\em module-name}
may differ in different files.  Specifically, the {\em module-abbreviation}
for a module used in the module's own module file need not be the same
as the {\em module-abbreviations} used for the module in files
that import the module.

The conceptual directed graph whose nodes are modules and whose
arrows connect each module to the modules it or its bodies import is called
the `\key{module graph}'.\label{MODULE-GRAPH}
This graph \underline{must be acyclic}.

The module \TT{"standard"}\index{standard@\TT{"standard"}} with
module abbreviation \ttkey{std} is builtin and contains the builtin types and
functions.  The {\em import-clause}
\begin{center}
{\tt import }\TT{"standard"}\ttindex{standard@\TT{"standard"}}{\tt{}
    as \ttkey{std}}
\end{center}
is implied in every {\em module-declaration} and
{\em body-declaration} (see \itemref{BODIES}).

When a type is declared, functions with arguments or result
values of that type are automatically declared.  For example,
the declaration
\begin{center}
{\tt define type $T1$ as $T2$}
\end{center}
automatically declares
\begin{center}
\begin{tabular}{l}
{\tt function bool r = ( $T1$ x ) "==" ( $T1$ y ):} \\
{\tt ~~~~r = ( $T2$ ( x ) ) "==" ( $T2$  ( y ) )}
\end{tabular}
\end{center}

If the declared type begins with module abbreviation $ma$, the function
will also be given this module abbreviation.  Thus if $T1$ begins with
$ma$, the function will be
\begin{center}
\begin{tabular}{l}
{\tt function bool r = $ma$ ( $T1$ x ) "==" ( $T1$ y ):} \\
{\tt ~~~~r = ( $T2$ ( x ) ) "==" ( $T2$  ( y ) )}
\end{tabular}
\end{center}


\subsection{Scope}
\label{SCOPE}

A {\em declaration} has a \key{scope},
that is the set of statements in which any
names or function prototypes defined by the {\em declaration}
are recognized.  The scope of a {\em declaration}
begins just after the {\em declaration}
itself, and
lasts to the end of smallest block containing the {\em declaration},
or until the end of the file containing the {\em declaration} if
the {\em declaration} is not inside any block.
If the {\em declaration} is in a module, the scope of the
{\em declaration} is extended to include all the bodies of that
module.
If the {\em declaration} is external, the scope of the
{\em declaration} is extended to include all modules and
bodies that import the module containing the {\em declaration}.

The scope of a {\em name} or {\em function-prototype}
is the scope of the declaration that defines it.

In a {\em statement} that ends with a block
(e.g., see \pagref{BLOCK-ASSIGNMENT-STATEMENTS}),
any result {\em variable-names} or {\em block-names} declared by
the part of the statement before the statement ending block behave as if this
initial part of the statement were a separate declaration outside
and immediately preceeding
the statement ending block.

The \key{context}\label{CONTEXT} of a statement is the set of declarations
whose scope the statement is in.

When a function call to an inline function is compiled,
the context of the compilation is \underline{not} the current context but
rather the context of the inline function declaration.
Also the context in which any default expression provided by a declaration
is compiled is the \underline{not} the current context but
rather the context of that declaration.

However code included by a generic
(\itemref{GENERIC}) \underline{is} compiled in the current context.

If two different declarations of the same {\em name} have overlapping
scope, one of these scopes must include the other,
and the declaration with the smaller scope is said to 
`\mkey{hide}{declaration}'\label{HIDE} the other declaration.
Such hiding is a compiler error unless the smaller scope
is within one of the following kinds of statements, and
the larger scope includes the whole statement:
\begin{center}
\begin{tabular}{ll}
{\em function-type-declaration}
    & [see \pagref{FUNCTION-TYPE-DECLARATION}] \\
{\em out-of-line-function-assignment}
    & [see \pagref{OUT-OF-LINE-FUNCTION-ASSIGNMENT}] \\
{\em out-of-line-function-declaration}
    & [see \pagref{OUT-OF-LINE-FUNCTION-DECLARATION}] \\
{\em function-declaration}
    & [see \pagref{FUNCTION-DECLARATION}] \\
{\em block-assignment-statement} with context option
    & [see \pagref{BLOCK-ASSIGNMENT-STATEMENTS}] \\
{\em compile-and-run-assignment-statement} with context option
    & [see \pagref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}] \\
\end{tabular}\label{HIDING-EXCEPTIONS}
\end{center}

As an exception to the last rule, the declaration with the
smaller scope may be an assignment statement declaring
a variable name `\TT{next} {\tt v}' when the declaration
with the larger scope is an assignment statement
declaring `{\tt v}', and the two declarations have the
same smallest containing block.
Within the smaller scope `{\tt v}' refers to the
`\TT{next} {\tt v}' declaration: see \pagref{NEXT}.

By the last rule,
`\TT{next} {\tt v}' cannot be declared in a block $B$ if `{\tt v}' was
declared outside $B$ and $B$ is completely within
the scope of `{\tt v}', so the smallest containing block of
`{\tt v}' is not the same as the smallest containing block of
`\TT{next} {\tt v}'.

{\em Function-prototypes} cannot hide each other.  If the
current scope contains two declarations whose prototypes
both match a {\em function-call}, the call is ambiguous and
in error, even if the scope of one declaration is within
a subblock of the scope of the other.
As a consequence, it may be unwise to place function declarations
within inline functions or
assignment statements that have the context option.

A declaration not inside a block is said to be `\key{top level}'.

A top level declaration
may \underline{not} have `\TT{next} {\em variable-name}' as
a result variable.

A top level assignment statement in a module may not include references to
out-of-line functions or to inline functions that in turn include
references to out-of-line functions.  This implies that all code needed
to initialize a top level variable will be initialized before the
variable is initialized.

However a top level assignment statement may have a
\key{deferred value} (\pagref{DEFERRED-ASSIGNMENT-STATEMENTS}) indicating
that its result variable values will not be assigned until later.
The statement
assigning the values must be in the same extended module
as the deferred assignment statement, but may be in a body
of that module, and if it is in a body,
may use out-of-line functions.
It is a programming error to access
deferred result variable values before they are assigned.

A name or the pattern of a prototype
declared by a top level declaration in a module may begin with
the {\em module-abbreviation} of the module.  In this case the
name or prototype is `\key{external}', and its scope is extended
to include modules and bodies that import the declaring module.
All other names and prototypes declared in the module or
its bodies are `\key{internal}',
and these names and the patterns of these prototypes may not begin
with any {\em module-abbreviation}.

Any name or prototype declared to be external in an imported module is
said to be `\key{imported}'.  The name or prototype is said to be
`\key{exported}' by the module that contains its declaration,
and `\key{imported}' by modules and bodies that import that module.

Imported names can be used only if they begin
with the {\em module-abbreviation} that references the module in which
they are declared.  Imported prototypes may be used by calls beginning with
the {\em module-abbreviation} that references the module in which
they are declared, or if there is no ambiguity the {\em module-abbreviation}
may be omitted from the calls.

An example is:
\begin{indpar}\begin{verbatim}
module "my_own_module" as mom:
    // `import "standard" as std' is implied
    import "George's_own_module" as gom
    // gom contains:
    //    function int32 z = gom ( int32 x ) "+" ( int32 y )

int32 mom my external constant = ...
int32 my internal constant = ...

function int32 y = mom my external function ( int32 x ):
    ... function body omitted ...
function int32 y = my internal function ( int32 x ):
    ... function body omitted ...

function int32 z = my inline function ( int32 x, int32 y ):
    int32 z1 = gom ( x + y )
        // Uses gom's + operator.
        // Compiles as as `gom (x) "+" (y)'.
    int32 z2 = std ( x + y )
        // Uses builtin std's + operator.
        // Compiles as as `std (x) "+" (y)'.
    z  = z1 + z2 
        // Compiles as `z = ( (x) "+" (y) )'.
        // Compile error, ambiguous: both std + operator
        // and gom's + operator match the call to "+".
\end{verbatim}\end{indpar}\label{EXTERNAL-INTERNAL-EXAMPLE}

More specifically,
when a function declaration is used, the {\em module-abbreviation}
beginning the function call may be omitted if the function declaration is
the only function declaration within scope that matches the usage,
according to the module deficiency rules of
section~\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}.
Thus in the context of the above example the lines:
\begin{indpar}\begin{verbatim}
int32 y = mom my external function ( x )
int32 y = my external function ( x )
\end{verbatim}\end{indpar}
are equivalent if no imported module with abbreviation $ma$
contains the {\em function-prototype}:
\begin{center}
\tt function int32 r = $ma$ my external function ( int32 v )
\end{center}

\subsection{Bodies}
\label{BODIES}

A \key{body}
is a file that begins with an {\em body-declaration}:

\begin{indpar}
\emkey{body-declaration}\label{BODY-DECLARATION} ::=
    \begin{tabular}[t]{l}
    \TT{body }{\em body-name}\TT{ of }{\em module-name}\TT{:} \\
    \TT{~~~~}{\em import-clause}\STAR{} \\
    \TT{~~~~}{\em after-clause}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{body-name} ::= {\em quoted-string}
\\[0.5ex]
{\em import-clause} ::= see \pagref{IMPORT-CLAUSE}
\\[0.5ex]
{\em after-clause} ::= \TT{initialize after }{\em body-name}
\end{indpar}

A {\em body-name} is a POSIX file name.
The {\em body-name} of a {\em body-declaration} must match the
name of the file containing the
{\em body-declaration}, relative to one of several directories
specified separately to the compiler.

A \key{body} is an extension of the module named in the first
line of the {\em body-declaration}.  The body cannot itself
declare any external names.  It can provide
assignments for variables and out-of-line functions deferred in the
module it extends, and can call out-of-line functions in these
assignments.
It can also declare internal names and functions used only in the
body.

A body implicitly imports the module it extends.  Within the
body that module has the same {\em module-abbreviation} that it
had in the module's own file.  The other modules imported in the
module's own file are \underline{not} implicitly imported
to the body.  The body must import whatever other modules it uses
explicitly.

The {\em after-clauses} name other bodies that extend the same
module, and control initialization: see \itemref{PROGRAM-INITIALIZATION}.

\subsection{Program Initialization}
\label{PROGRAM-INITIALIZATION}

Modules must be initialized.  A module is initialized after every
module that it imports is initialized.  Otherwise the order of
initializing modules is indeterminate.  Because the module graph
(\pagref{MODULE-GRAPH}) is acyclic, it is always possible to
initialize imported modules before the importing module.

A module is initialized by executing top level assignment statements
in the module file, and then initializing
bodies that extend the module.  A body is initialized
by executing top level assignment statements in the body.
Top level statements in a file are executed in order.
Note that some of these assignment statements may not have
result variables.

A module is initialized before any bodies that extend it.
Unless specified by {\em after-clauses}, the order of initializing the
bodies that extend a module is indeterminate.
An `\TT{initialized after "$B1$"}' clause for module \TT{"$B2$"} causes
\TT{"$B2$"} to be initialized after \TT{"$B1$"}.

Each module has a `\key{body graph}'\label{BODY-GRAPH}
whose nodes are bodies that extend
the module and whose arrows connect each body to the bodies it
initializes after.  This graph must be acyclic.

{\em Deferred-assignment-statements} (\pagref{DEFERRED-ASSIGNMENT-STATEMENTS})
and {\em out-of-line-function-deferred-assignments}
(\pagref{OUT-OF-LINE-FUNCTION-DEFERRED-ASSIGNMENT}) must be executed
before statements initializing their variables or functions.

\subsection{Parsing}

The parser converts each statement to an abstract syntax tree,
using the language syntax equations and the {\em module-abbreviations}
and {\em parser-clauses}
of the current module's {\em module-declaration} or body's
{\em body-declaration}.  The abstract syntax
tree of a statement can be represented by inserting implied
parentheses into the statement.

For example, the statement
\begin{center}
\tt int64 x 1 = y 5 b + sin (w) * cos z
\end{center}
becomes the abstract syntax tree represented by
\begin{center}
\tt (int64 x 1) = ((y 5 b) "+" ((sin (w)) "*" (cos z)))
\end{center}
Note that the abstract tree representation is not legal
program code as it has parentheses around the result
variable declaration `{\tt int64 x 1}'.

Operators in the original statement are replaced by quoted
versions of the operators in the abstract
syntax tree, e.g., {\tt +} is replaced by {\tt "+"}, so that
the operators become {\em function-term-names}.

The parser does not process {\em result-variable-declarations} or
{\em argument-declarations}.  Thus
\begin{center}
\tt function int64 r = ( int64 a 1 ) "+" ( int64 a 2 )
\end{center}
becomes
\begin{center}
\tt function (int64 r) = (( int64 a 1 ) "+" ( int64 a 2 ))
\end{center}

Since the parser has only syntax information and {\em module-abbreviations}
available to
it, the parser does not know the {\em qualifier-names}
and {\em type-names} in a given scope, and in fact the parser
has no notion of scope.

The parser does know about {\em module-abbrevations} and
converts a statement of the form:
\begin{center}
{\em module-abbreviation} {\tt (~\ldots~)}
\end{center}
to
\begin{center}
{\tt (~}{\em module-abbreviation}{\tt ~\ldots~)}
\end{center}
after parsing `{\tt \ldots}'.  Thus if $ma$ is a {\em module-abbreviation},
\begin{center}
\tt int64 x 1 = $ma$ ( y 5 b + sin (w) * cos z )
\end{center}
becomes the abstract syntax tree represented by
\begin{center}
\tt (int64 x 1) = ($ma$ (y 5 b) "+" ((sin (w)) "*" (cos z)))
\end{center}

According to the syntax of expressions (\itemref{EXPRESSION-SYNTAX}),
the parser does not insert parentheses that make operators
left associative.  Thus
\begin{center}
\tt int64 w 1 = x 2 + y 3 + z 4 
\end{center}
becomes the abstract syntax tree represented by
\begin{center}
\tt (int64 w 1) = ((x 2) "+" (y 3) "+" (z 4))
\end{center}
and \underline{not}
\begin{center}
\tt (int64 w 1) = ( ( (x 2) "+" (y 3) ) "+" (z 4))
\end{center}
The compiler and not the parser handles binary operator associativity.


\section{Data Types}
\label{DATA-TYPES-TYPES}

The basic builtin types are the number types and the \TT{void} type.
All defined types are subtypes of these types.
One of the builtin defined subtypes is the `\TT{type}' type.

\subsection{Number Types}
\label{NUMBER-TYPES}

Numbers are sequences of bits, and each number is one of
four kinds, unsigned integer, signed integer, floating point number,
or address:

\begin{indpar}
\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\bf Name & \bf Kind & \bf Size \\[2ex]
\TT{std}~~~\ttkey{uns1}		& unsigned integer & 1 bits \\
\TT{std}~~~\ttkey{uns8}		& unsigned integer & 8 bits \\
\TT{std}~~~\ttkey{uns16}	& unsigned integer & 16 bits \\
\TT{std}~~~\ttkey{uns32}	& unsigned integer & 32 bits \\
\TT{std}~~~\ttkey{uns64}	& unsigned integer & 64 bits \\
\TT{std}~~~\ttkey{uns128}	& unsigned integer & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{int8}		& signed integer & 8 bits \\
\TT{std}~~~\ttkey{int16}	& signed integer & 16 bits \\
\TT{std}~~~\ttkey{int32}	& signed integer & 32 bits \\
\TT{std}~~~\ttkey{int64}	& signed integer & 64 bits \\
\TT{std}~~~\ttkey{int128}	& signed integer & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{float16}	& IEEE floating point number & 16 bits \\
\TT{std}~~~\ttkey{float32}	& IEEE floating point number & 32 bits \\
\TT{std}~~~\ttkey{float64}	& IEEE floating point number & 64 bits \\
\TT{std}~~~\ttkey{float128}	& IEEE floating point number & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unsadr}	& unsigned integer & size of address \\
\TT{std}~~~\ttkey{intadr}	& signed integer & size of address \\
\TT{std}~~~\ttkey{adr}		& signed or unsigned integer
                                & size of address \\
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unswrd}	& unsigned integer & size of integer register \\
\TT{std}~~~\ttkey{intwrd}	& signed integer & size of integer register \\
\TT{std}~~~\ttkey{floatwrd}	& floating point number
                                & size of floating point register
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unsmax}	& unsigned integer & max implemented size \\
\TT{std}~~~\ttkey{intmax}	& signed integer & max implemented size \\
\TT{std}~~~\ttkey{floatmax}	& floating point number & max implemented size
\end{tabular}

\end{indpar}

These are the \key{built in number types}.  The \TT{\ldots{}wrd} types
are the sizes that execute fastest, while the \TT{\ldots{}max} types
may be larger sizes for which all arithmetic and comparison
operations are \key{implemented}\label{IMPLEMENTED}.
Copying and conversion of values is always implemented for
\underline{all}
number types, regardless of implementation, except for implementations
that do not implement \underline{any} floating point types.

Here `\TT{std}' is the module abbreviation for the \TT{"standard"}
module to which builtin types and functions belong.  For convenience
the following abbreviations are builtin:
\begin{indpar}
\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{uns1} & {\tt `std~uns1'} \\
\ttkey{uns8} & {\tt `std~uns8'} \\
\ttkey{uns16} & {\tt `std~uns16'} \\
\ttkey{uns32} & {\tt `std~uns32'} \\
\ttkey{uns64} & {\tt `std~uns64'} \\
\ttkey{uns128} & {\tt `std~uns128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{int8} & {\tt `std~int8'} \\
\ttkey{int16} & {\tt `std~int16'} \\
\ttkey{int32} & {\tt `std~int32'} \\
\ttkey{int64} & {\tt `std~int64'} \\
\ttkey{int128} & {\tt `std~int128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{float16} & {\tt `std~float16'} \\
\ttkey{float32} & {\tt `std~float32'} \\
\ttkey{float64} & {\tt `std~float64'} \\
\ttkey{float128} & {\tt `std~float128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unsadr} & {\tt `std~unsadr'} \\
\ttkey{intadr} & {\tt `std~intadr'} \\
\ttkey{adr} & {\tt `std~adr'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unswrd} & {\tt `std~unswrd'} \\
\ttkey{intwrd} & {\tt `std~intwrd'} \\
\ttkey{floatwrd} & {\tt `std~floatwrd'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unsmax} & {\tt `std~unsmax'} \\
\ttkey{intmax} & {\tt `std~intmax'} \\
\ttkey{floatmax} & {\tt `std~floatmax'} \\
\end{tabular}
\end{indpar}

Here we use abbreviation statements of the form
\begin{center}
{\em abbreviation-name}~~\TT{\ABV}~~\TT{`}{\em replacement-name}\TT{'}
\end{center}
to specify that whenever the {\em abbreviation-name} occurs it is to be
replaced by the {\em replacement-name}.  See \itemref{ABBREVIATIONS} for
more abbreviation details. 

In this document we will use these abbreviations as the
`\skey{builtin number type}s':

\begin{indpar}
{\em builtin-number-type-name}\label{BUILTIN-NUMBER-TYPE-NAME}
    \begin{tabular}[t]{@{}cl}
    ::= & \TT{uns1} $|$ \TT{uns8} $|$ \TT{uns16} $|$ \TT{uns32} $|$ \TT{uns64}
                    $|$ \TT{uns128} \\
    $|$ & \TT{int8} $|$ \TT{int16} $|$ \TT{int32} $|$ \TT{int64}
                    $|$ \TT{int128} \\
    $|$ & \TT{float16} $|$ \TT{float32} $|$ \TT{float64} $|$ \TT{float128} \\
    $|$ & \TT{unsadr} $|$ \TT{intadr} $|$ \TT{adr} \\
    $|$ & \TT{unswrd} $|$ \TT{intwrd} $|$ \TT{floatwrd}  \\
    $|$ & \TT{unsmax} $|$ \TT{intmax} $|$ \TT{floatmax}  \\
    \end{tabular}
\end{indpar}

\subsubsection{Integer Number Types}

The \mkey{size}{of number}
of a number is the number of its bits.  Numbers can have
different sizes: for example, unsigned integers can have
sizes of 1, 8, 16, 32, 64, or 128 bits.

Numbers are stored in registers or in random access memory (RAM).

An \key{unsigned integer} of size $S$ is a binary integer with
$S$ binary digits (\skey{bit}s) and range from $0$ to $2^S-1$.

A \key{signed integer} of size $S$ is a two's complement integer
of size $S$ and range from $-2^{S-1}$ to $+2^{S-1}-1$.
This represents the integer $I$ in the given range
by the unsigned $S$-bit integer equal to $I~\mbox{modulo}~2^S$.

An \key{address} holds a RAM byte address.
An address is a 32-bit or 64-bit signed or unsigned integer whose size
and signage are determined by the target machine.
Some of high order bits may be
required to be all 0's or all 1's, depending upon
the target machine.  The \TT{unsadr} and \TT{intadr}
unsigned and signed integer types of the same size
as an address are provided for storing indices and offsets.

A reasonable assumption for 64-bit addresses is that only the low
order 48-bits of the address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing an address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The L-Language does
\underline{not} depend upon this assumption, but does provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$.  The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.\footnote{The I86 64-bit architecture
uses only the low order 48 bits of an address, but \underline{requires}
the high order 17 bits to all be the same, either all 1's or all 0's.
However, as it is unlikely that there will ever be an allocated memory region
that includes address 0 in its interior, it makes no significant difference
whether we consider addresses to be unsigned or signed.}

\subsubsection{Floating Point Number Types}

A \key{floating point number} of size $S$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes are as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}r@{~~~~~~}r}
                   &              &              &             & \bf Maximum \\
\bf Floating Point & \bf Exponent & \bf Mantissa & \bf Decimal & \bf Decimal\\
\bf Number Size    & \bf Size     & \bf Size     & \bf Digits  & \bf Exponent
\\[2ex]
16 bits & 5 bits & 10 bits & 3.31 & 4.51 \\
32 bits & 8 bits & 23 bits & 7.22 & 38.23 \\
64 bits & 11 bits & 52 bits & 15.95 & 307.95 \\
128 bits & 15 bits & 112 bits & 34.02 & 4931.77 \\
\end{tabular}
\end{center}

There are also three special floating point values:
\TT{+Inf} denoting positive infinity,
\TT{-Inf} denoting negative infinity,
and \TT{NaN} denoting `\key{not-a-number}' which is a value produced
when, for example, \TT{0} is divided by \TT{0}.
In this document \ttkey{NaN} denotes the particular non-signaling
not-a-number value
produced by arithmetic operations that cannot produce a number.
Floating point variables can store many other not-a-number values.

\subsubsection{Number Conversion Functions}

In the following we specify builtin conversion functions using
function prototypes of the form:
\begin{center}
\tt function $T1$ r = std $F$ ( $T2$ v )
\end{center}
This says that if you apply the function $F$ to the value \TT{v} which
is of type $T2$, the function will return a value \TT{r} of type $T1$.
See \itemref{FUNCTION-PROTOTYPES-AND-CALLS} for more function prototype details.

If a conversion from type $T2$ to type $T1$ may be implied, then
in code of the form
\begin{center} \tt
\begin{tabular}{l}
$T2$ v = \ldots \\
$T1$ r = v
\end{tabular}
\end{center}
the second statement will automatically invoke the implied conversion.

The following builtin conversion functions are defined:

\begin{indpar}
{\tt function uns$x$~~~r = std \ttkey{uns$x$}~~~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{int$x$}~~~( uns$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{int$x$}~~~( int$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( int$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( float$y$ v )}
\begin{center}
for any $x\geq y$ for which the types are builtin
\end{center}
\begin{indpar}
For these conversion functions, no information is lost from
the value when it is converted to the new type.  These conversions
can be \ikey{implied}{implied conversion}.
\end{indpar}

{\tt function uns$x$~~~r = std \ttkey{mod}~~~( uns$y$ v )} \\
{\tt function uns$x$~~~r = std \ttkey{mod}~~~( int$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{mod}~~~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{mod}~~~( int$y$ v )}
\ttindex{mod}
\begin{center}
for any $x$ and $y$ for which the types are builtin
\end{center}
\begin{indpar}
These functions return a value equal to the argument
modulo $2^x$.
\end{indpar}

{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( float$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( float$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( float$y$ v )}
\ttindex{nearest}
\begin{center}
for any $x$ and $y$ for which the types are builtin
\end{center}
\begin{indpar}
These functions round the argument to the nearest value (ties to even)
of the result type if the result must have less precision than the argument.
If the value overflows the result type, the result is \TT{+Inf} or \TT{+Inf}
for floating point results, and the largest or smallest possible result
value for integer results.
\end{indpar}

\end{indpar}

Note the difference between \TT{mod} and \TT{nearest} when applied to
integers outside the range of the target type:
\begin{center}
\begin{tabular}{l}
{\tt uns8 ( mod ( 257 ) ) == 1} \\
{\tt uns8 ( nearest ( 257 ) ) == 255} \\
\end{tabular}
\end{center}

Floating point numbers can be converted to integer valued floating point
numbers via:

\begin{indpar}
{\tt function float$x$~~~r = std \ttkey{round}~~~~~( float$x$ v )} \\
{\tt function float$x$~~~r = std \ttkey{ceiling}~~~( float$x$ v )} \\
{\tt function float$x$~~~r = std \ttkey{floor}~~~~~( float$x$ v )}

\begin{center}
for any $x$ for which the types are builtin
\end{center}
\begin{indpar}
These functions round to nearest (ties to even),
round up, and round down respectively.
\end{indpar}
\end{indpar}


\subsubsection{Unchecked Number Conversions}

The following \underline{unchecked} conversion functions are defined.
Note that here \TT{*UNCHECKED*} is a qualifier; see \itemref{QUALIFIERS}
for qualifier details.

\begin{indpar}
{\tt function \TT{*UNCHECKED*} uns$x$~~~r =~%
	\ttmkey{uns$x$}{conversion function}~~~( int$x$ v )} \\
{\tt function \TT{*UNCHECKED*} uns$x$~~~r =~%
	\ttmkey{uns$x$}{conversion function}~~~( float$x$ v )} \\
{\tt function \TT{*UNCHECKED*} int$x$~~~r =~%
	\ttmkey{int$x$}{conversion function}~~~( uns$x$ v )} \\
{\tt function \TT{*UNCHECKED*} int$x$~~~r =~%
	\ttmkey{int$x$}{conversion function}~~~( float$x$ v )} \\
{\tt function \TT{*UNCHECKED*} float$x$~r =~%
	\ttmkey{float$x$}{conversion function}~( uns$x$ v )} \\
{\tt function \TT{*UNCHECKED*} float$x$~r =~%
	\ttmkey{float$x$}{conversion function}~( int$x$ v )}

\begin{center}
for any $x$ for which the types are builtin
\end{center}
\begin{indpar}
These functions just return the $x$-bit value of \TT{v}
unchanged except for giving it a different type.
\end{indpar}
\end{indpar}

\subsubsection{Number Constants}
\label{NUMBER-CONSTANTS}

A \key{number-constant} is a {\em number} lexeme with specific syntax
that is used to denote a number.  The syntax is:

\begin{indpar}
\emkey{number-constant}\label{NUMBER-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em decimal-constant} \\
    $|$ & {\em binary-constant} \\
    $|$ & {\em hexadecimal-constant} \\
    $|$ & \TT{+Inf}\index{Inf@\TT{+Inf}}
          ~$|$~ \TT{-Inf}\index{Inf@\TT{-Inf}}
          ~$|$~ \ttkey{NaN}
    \end{tabular}
\\[0.5ex]
\emkey{sign} :::= \TT{+} $|$ \TT{-} \\
\emkey{exponent} :::=
	\{ \TT{e} $|$ \TT{E} \} {\em sign}\QMARK{} {\em dit}\PLUS{}
\\[0.5ex]
\emkey{decimal-constant} \begin{tabular}[t]{@{}rl@{}}
                         ::= & {\em decimal-lexeme} \\
			 $|$ & {\em decimal-constant-prefix} ~
			       {\em decimal-quoted-body} ~
			       {\em exponent}\QMARK{}
			 \end{tabular}
\\[0.5ex]
\emkey{decimal-lexeme} :::= {\em decimal-body-lexeme} ~ {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{decimal-body-lexeme} :::= {\em sign}\QMARK{} ~ {\em decimal-integer} ~
				 {\em decimal-fraction}\QMARK{}
\\[0.5ex]
\emkey{decimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{D}
\\[0.5ex]
\emkey{decimal-quoted-body} :::= \TT{"} {\em decimal-integer} ~
				 {\em decimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{decimal-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em dit}\PLUS{} \\
     $|$ & {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\PLUS{} \\
     $|$ & {\em dit} {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\PLUS{} \\
     $|$ & {\em dit} {\em dit} {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\PLUS{} \\
    \end{tabular} \\
\emkey{decimal-fraction} :::= \TT{.} {\em dit}\PLUS{} \\
\emkey{dit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
 \\[0.5ex]
\emkey{binary-constant} ::= {\em binary-constant-prefix} ~
                              {\em binary-quoted-body} ~
			      {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{binary-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{B}
\\[0.5ex]
\emkey{binary-quoted-body} :::= \TT{"} {\em binary-integer} ~
				{\em binary-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{binary-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em bit}\PLUS{} \\
     $|$ & {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\PLUS{} \\
     $|$ & {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\PLUS{} \\
     $|$ & {\em bit} {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\PLUS{} \\
     $|$ & {\em bit} {\em bit} {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\PLUS{} \\
    \end{tabular} \\
\emkey{binary-fraction} :::= \TT{.} {\em bit}\PLUS{} \\
\emkey{bit} :::= \TT{0} $|$ \TT{1}
 \\[0.5ex]
\emkey{hexadecimal-constant} ::= \\
\hspace*{0.5in}{\em hexadecimal-constant-prefix} ~
               {\em hexadecimal-quoted-body} ~
	       {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{hexadecimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{X}
\\[0.5ex]
\emkey{hexadecimal-quoted-body} :::= \TT{"} {\em hexadecimal-integer} ~
				     {\em hexadecimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{hexadecimal-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em hit}\PLUS{} \\
     $|$ & {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\PLUS{} \\
     $|$ & {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\PLUS{} \\
     $|$ & {\em hit} {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\PLUS{} \\
     $|$ & {\em hit} {\em hit} {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\PLUS{} \\
    \end{tabular} \\
\emkey{hexadecimal-fraction} :::= \TT{.} {\em hit}\PLUS{} \\
\emkey{hit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
	     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
	     $|$ \TT{a} $|$ \TT{b} $|$ \TT{c} $|$ \TT{d} $|$ \TT{e} $|$ \TT{f}
	     $|$ \TT{A} $|$ \TT{B} $|$ \TT{C} $|$ \TT{D} $|$ \TT{E} $|$ \TT{F}
\end{indpar}

The integer part of decimal constants may have commas
every 3 digits, and the integer part of binary and hexadecimal constants
may have commas every 4 digits.
If there is a decimal point, there must be at least one fraction digit.

\TT{NaN} denotes a canonical non-signaling NaN such
at that produced by hardware on the target machine.
\TT{+Inf} denotes positive infinity; \TT{-Inf} denotes negative infinity.

{\em Number-constants} have no type.  They can be converted to
values of number type as follows.

A {\em number-constant} can be implicitly converted to any number
type that can represent the number exactly.

A {\em number-constant} can be implicitly converted to any
floating point number type.  If it is too large, it is converted to
\TT{+Inf}, and if it is too small, it is converted to \TT{-Inf}.
If it cannot be represented exactly, it is rounded (ties to even).

A {\em number-constant} can be explicitly converted to any number
type by the \TT{mod} or \TT{nearest} functions.  It may be explicitly
converted by \TT{uns$x$}, \TT{int$x$}, or \TT{float$x$} functions only
if it may be implicitly converted to the desired type.

{\em Number-constants} are compile time values and can be combined by
the standard operators to produce compile time values
(see \itemref{COMPILE-TIME-EVALUATION}).

\subsection{The Void Type}
\label{THE-VOID-TYPE}

A \ttkey{void} type variable has no value.  No value can be
assigned to such a variable.  Nevertheless such variables have
uses, for example, as base variable in clusters (\pagref{CLUSTERS}).
When used as the base variable of a cluster, an assignment statement
may appear to be assigning a value to a \TT{void} variable, but
in fact it is assigning values to cluster members.

\subsection{Defined Types}
\label{DEFINED-TYPES}

A declaration statement of the following form defines a type by
specifying its {\em type-name}:
\begin{indpar}
\emkey{defined-type-declaration}\label{DEFINED-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
\TT{define type} {\em qualifier-name}\STAR{} {\em defined-type-name}
          \TT{as} {\em base-type-name} \\
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME} \\
\emkey{defined-type-name} ::= {\em type-name} \\
\emkey{base-type-name} ::= {\em type-name} \\
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\end{indpar}

Any {\em qualifiers} in the declaration are attached to every
variable or argument declared to have the defined type (see
section \itemref{QUALIFIERS} for more on {\em qualifiers}).

No {\em type-name} may be a prefix of
any {\em deferred-result-variable} (\pagref{DEFERRED-RESULT-VARIABLE})
or any {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME}).
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.

A value of a defined type may be converted to or from its base
type by the
\underline{unchecked}
builtin functions:
\begin{indpar}
{\tt function \TT{*UNCHECKED*} $B$ r = $B$ ( $D$ v )} \\
{\tt function \TT{*UNCHECKED*} $D$ r = $D$ ( $B$ v )}

where $B$ is the {\em base-type-name} used to define
the {\em defined-type-name} $D$

\begin{indpar}
These functions do not change the actual value, but merely its
compile-time type.  Using these unchecked conversions,
implied conversions in one direction only
may be defined as desired: see \itemref{IMPLIED-CONVERSION-FUNCTIONS}.
\end{indpar}
\end{indpar}\label{DEFINED-TYPE-UNCHECKED-CONVERSION}


\subsection{Enumeration Types}
\label{ENUMERATION-TYPES}

An \key{enumeration type} is a defined type whose values are
integers assigned to \skey{enumeration constant}s.
Each enumeration constant is assigned a value during compilation
that is an integer unique relative to all enumeration
constants of its enumeration type that are being compiled together.
Then during linking the enumeration constant is assigned a possibly
different value that is an integer unique relative to all enumeration
constants of its enumeration type that are being linked together.

A declaration statement of the following form defines an \key{enumeration type}
that has enumeration values:
\begin{indpar}
\emkey{enum-type-declaration}\label{ENUM-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
    \TT{define type} {\em qualifier-name}\STAR{}
    \begin{tabular}[t]{@{}l@{}}
    {\em enum-type-name} \TT{as}~~~{\em base-enum-type-name} \\
    \TT{with enum range}~~~{\em enum-range} \\
    \{ \TT{without implied conversion} \}\QMARK \\
    \end{tabular}
\\[0.5ex]
\emkey{base-enum-type-name}
    \begin{tabular}[t]{rl}
    ::= & {\em integer-type-name} \\
    $|$ & {\em enum-direction}\QMARK{}~~~{\em enum-type-name} \\
    \end{tabular} \\
\emkey{enum-direction} ::= \TT{next} $|$ \TT{previous} \\
\emkey{integer-type-name}
    ::= {\em builtin-number-type-name}%
            \,$^{\pagref{BUILTIN-NUMBER-TYPE-NAME}}$ naming an integer type \\
\emkey{enum-range}
    \begin{tabular}[t]{rl}
    ::= & \TT{[} {\em first-enum} \TT{..} {\em last-enum} \TT{]} \\
    $|$ & \TT{[} {\em first-enum} \TT{..} \TT{]} \\
    $|$ & \TT{[} \TT{..} {\em last-enum} \TT{]} \\
    \end{tabular} \\
\emkey{first-enum} ::= {\em compile-time-integer-expression} \\
\emkey{last-enum} ::= {\em compile-time-integer-expression}
\end{indpar}

Here {\em first-enum} and {\em last-enum} are compile time integer
values assigned to the newly defined enum type.
{\em First-enum} must be less than or equal to {\em last-enum}.
If {\em last-enum} is not given, it is assumed to be the maximum
value permitted by the base enumeration type that conforms to the
rules given below.
Similarly if {\em first-enum} is not given, it is assumed to be the minimum
value permitted by the base enumeration type.

Enumeration values can be assigned by declaration statements of the form
\begin{indpar}
\emkey{enum-assignment}
    \begin{tabular}[t]{rl}
    ::= & {\em enum-type-name} ~ {\em enum-constant-name}\TT{ is next enum} \\
    $|$ & {\em enum-type-name} ~ {\em enum-constant-name}\TT{ is previous enum}
    \end{tabular}
\\[0.5ex]
\emkey{enum-constant-name} ::= {\em variable-name}
\\[0.5ex]
{\em variable-name} ::= see \pagref{VARIABLE-NAME}
\end{indpar}

Within a compilation the compiler assigns the value {\em first-enum}
to the first constant named in a `\TT{next enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in increasing order.
It is an error if `\TT{next~enum}'
would return a value beyond the {\em last-enum} value in a range.

Similarly the compiler assigns the value {\em last-enum}
to the first constant named in a `\TT{previous enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in decreasing order.
It is an error if `\TT{previous~enum}'
would return a value below the {\em first-enum} value in a range.

It is also an error if for a given type the same value is returned
by some \TT{next~enum} and also by some \TT{previous~enum}.

An enumeration type is a defined type with integer base type and
extra apparatus provided by the range which provides a special
mechanism for assigning enumeration type values.
Given an enumeration type $E$ with its base type $B$
the following conversions are defined:
\begin{indpar}
{\tt function ~~~~~~~~~~~ $B$ r = $B$ ( $E$ v )} \\
{\tt function \TT{*UNCHECKED*} $B$ r = $B$ ( $E$ v )} \\
{\tt function \TT{*UNCHECKED*} $E$ r = $E$ ( $B$ v )}
\begin{indpar}
These conversions actually do nothing but change the type of the
value.  The first two have identical effect.  The first is an implied
conversion, and is only defined if the
`\TT{without implied conversion}' option is \underline{not} given in the
enumeration type definition.  The last two conversions are the
\TT{*UNCHECKED*} conversions defined for all enum types.
\end{indpar}
\end{indpar}

If the base type of an enumeration type is a builtin integer type,
the integer value corresponding to {\em first-enum} is {\em first-enum}
itself, and similarly for {\em last-enum}.  Thus the following
example:
\begin{indpar}\begin{verbatim}
define type E as int32 with enum range [1 .. 20]
E C1 = next enum
    // Now int32 (C1) == 1
E C2 = next enum
    // Now int32 (C2) == 2
E C3 = previous enum
    // Now int32 (C3) == 20
E C4 = previous enum
    // Now int32 (C4) == 19
\end{verbatim}\end{indpar}

The \key{underlying type}\label{UNDERLYING-TYPE}
of a type $T$ is $T$ itself if
$T$ is builtin, and is the underlying
type of the base type of $T$ if $T$ is a defined type or an
enumeration type.
Thus every enumeration type $E$ has an underlying integer
type $I$.  As long as the `\TT{without implied conversion}'
option is \underline{not} used, a value of an enumeration type
can always be implicitly converted to a value of its underlying
type.  Thus the following example:
\begin{indpar}\begin{verbatim}
define type D as int32
define type E as D with enum range [1 .. 20]
E C1 = next enum
    // Now int32 (C1) == 1
E C3 = previous enum
    // Now int32 (C3) == 20
\end{verbatim}\end{indpar}

If the base type of an enumeration type is another enumeration type,
the map from values of the first enumeration type to underlying
integer values consists of adding a constant, called the
`\key{enumeration offset}', and the
following are defined, where $I$ is the underlying
integer type of enumeration type $E$:

\begin{indpar}
{\tt function $I$ r = \ttkey{enumeration offset of}~( type E )}
\begin{indpar}
Returns the enumeration offset of \TT{E}.
\end{indpar}
{\tt function $I$ r = \ttkey{range value of}~( $E$ v )}
\begin{indpar}
Returns ~~ {\tt $I$~( v ) - enumeration offset of ( $E$ )}.
\end{indpar}

\end{indpar}

The enumeration offset of an {\em enum-type-name} is more specifically
defined for the following cases:

\begin{indpar}
\begin{itemlist}
\item[\TT{define type} {\em qualifier-name}\STAR{} {\em enum-type-name}~~%
    \TT{as}~~{\em builtin-integer-type-name} \ldots{}] ~\\
The enumeration offset of the {\em enum-type-name} equals \TT{0}.
\item[\TT{define type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em enum-type-name}~~\TT{as}~~%
              \TT{next}~~{\em base-enum-type-name} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Has the effect of compiling the statements:
\begin{center}
\begin{tabular}{l}
{\em base-enum-type-name} {\tt ~V0~~=~~next enum} \\
{\em base-enum-type-name} {\tt ~V1~~=~~next enum} \\
{\em base-enum-type-name} {\tt ~V2~~=~~next enum} \\
\ldots\ldots\ldots \\
{\em base-enum-type-name} {\tt ~V$n$~~=~~next enum} \\
\end{tabular}
\end{center}
where $n$ = {\em last-enum} - {\em first-enum}.
If $I$ is the underlying integer type of the {\em base-enum-type-name},
and thence also of {\em enum-type-name}, then
\begin{center}
\TT{enumeration offset of (}{\em enum-type-name}\TT{)} \\
{\tt =~$I$(V0)~-~}{\em first-enum}
\end{center}
Therefore if implied conversions are allowed, the first statement of the form
\begin{center}
{\em enum-type-name} \TT{~V~~=~~next enum} \\
\end{center}
compiled after the {\em enum-type-declaration} will make
{\tt $I$(V) == $I$(V0)}, and the first statement of the form
\begin{center}
{\em enum-type-name} \TT{~V~~=~~previous enum} \\
\end{center}
compiled after the {\em enum-type-declaration} will make
{\tt $I$(V) == $I$(V$n$)}.
\item[\TT{define type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em enum-type-name}~~\TT{as}~~%
              \TT{previous}~~{\em enum-type-name} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Ditto with every `\TT{next}' replaced everywhere by `\TT{previous}' and
\begin{center}
\TT{enumeration offset of (}{\em enum-type-name}\TT{)} \\
{\tt =~$I$(V0)~-~}{\em last-enum}
\end{center}
\end{itemlist}
\end{indpar}

The above is examplified by:
\begin{indpar}\begin{verbatim}
define type E1 as int32 with enum range [1 .. 20]
    // Now enumeration offset of (E1) == 0
E1 C1 = previous enum
    // Now range value of (C1) == 20 == int32(C1)
define type E2 as previous E1 with enum range [1 .. 10]
    // Now enumeration offset of (E2) == 9
E2 C2 = next enum 
    // Now range value of (C2) == 1,
    // Now range value of ( E1(C2) ) == 10 = int32(C2)
E2 C3 = previous enum 
    // Now range value of (C3) == 10,
    // Now range value of ( E1(C3) ) == 19 = int32(C3)
define type E3 as next E2 with enum range [1 .. 5]
    // Now enumeration offset of (E3) == 10
E3 C4 = next enum 
    // Now range value of (C4) == 1,
    // range value of ( E2(C4) ) == 2,
    // range value of ( E1(E2(C4)) ) = 11 = int32(C4)
\end{verbatim}\end{indpar}

If $E$ is an enumeration type with underlying
type $I$, the following comparison and subtraction
of values of type $E$ are defined as if implied conversion
of $E$ values to $I$ values were allowed (even if they
are not):

\begin{indpar}
{\tt function bool r = ( $E$ v1 ) "$cop$" ( $E$ v1 )}

where $cop$ is
\ttmkey{<}{of enum values}, \ttmkey{<=}{of enum values},
\ttmkey{==}{of enum values}, \ttmkey{!=}{of enum values},
\ttmkey{>=}{of enum values}, or \ttmkey{>}{of enum values}.
\begin{indpar}
Returns {\tt $I$(v1) "$cop$" $I$(v2)}.
\end{indpar}

{\tt function $I$ r = ( $E$ v1 ) "\ttmkey{-}{of enum values}" ( $E$ v1 )}
\begin{indpar}
Returns {\tt $I$(v1) "-" $I$(v2)}.
\end{indpar}
\end{indpar}

Two enumeration values of different types
may be compared or subtracted if they can be implicitly
converted to a common enumeration or integer type.

The following are builtin enumeration types:
\begin{indpar} \tt
define type~\ttkey{std type}~as unswrd with enum [0~..] \\
\ttkey{type} ---> `std type' \\
type~\ttkey{std missing type}~is next enum // 0 \\
function std type r = \ttmkey{std missing}{type}: \\
\hspace*{0in}~~~~r = std missing type
\\[1ex]
define type~\ttkey{std qualifier}~as unswrd with enum [0~..] \\
\ttkey{qualifier} ---> `std qualifier' \\
qualifier~\ttkey{std missing qualifier}~is next enum // 0 \\
function std qualifier r = \ttmkey{std missing}{qualifier}: \\
\hspace*{0in}~~~~r = std missing qualifier
\\[1ex]
define type~\ttkey{std bool}\begin{tabular}[t]{@{}l@{}}
                            ~as unswrd with enum [0~..~1] \\
                            ~without implied conversion \\
		            \end{tabular} \\
\ttkey{bool} ---> `std bool' \\
bool~\ttkey{std false}~is next enum // 0 \\
\ttkey{false} ---> `std false' \\
bool~\ttkey{std true}~~is next enum // 1 \\
\ttkey{true} ---> `std true'
\end{indpar}

Builtin types not mentioned above, such as `\TT{void}' and `\TT{int32}',
are given unspecified (i.e., implementation dependent)
`\TT{type}' enumeration values.
Similarly builtin qualifiers, such as `\TT{mem}', are given
unspecified `\TT{quali\-fier}' enumeration values.  Conversions and
`\TT{range value of}' functions above
can be used to find the integer values associated with any
enumeration constant, but unspecified builtin values may differ from
one compilation or linking to the next.

Enumeration values are assigned within a compilation in
the order that {\em enum-assignments} are compiled.
Enumeration values are assigned during linking according to the order
that modules containing the {\em enum-assignments} are linked.
The link and compile values assigned by an {\em enum-assignment}
may differ.

However, within a compilation module, all assignments to an enumeration type
are done in the same order during linking as during compilation.
Thus values assigned within the same module can be assumed to be
in the same order at compile and link times.  Also,
compile and link values of a given enumeration type
can be assumed to be the same if \underline{all} values
of that enumeration type are assigned in the a single compilation module.

\subsection{Enumeration Set and List Types}
\label{ENUMERATION-SET-AND-LIST-TYPES}

An \key{enumeration set} is a set of enumeration values.
An \key{enumeration list} is a list of enumeration values.  The syntax
for enumeration set and list constants is:
\begin{indpar}
\emkey{enum-set-constant}\label{ENUM-SET-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{~\}} \\
    $|$ &\TT{\{} {\em enum-item}
                   \{ \TT{,} {\em enum-item} \}\STAR{} \TT{\}} \\
    \end{tabular} \\
\emkey{enum-list-constant}\label{ENUM-LIST-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{[~]} \\
    $|$ &\TT{[} {\em enum-item}
                   \{ \TT{,} {\em enum-item} \}\STAR{} \TT{]} \\
    \end{tabular} \\
\emkey{enum-item}
    ::= {\em enum-value} $|$ {\em enum-range} \\
\emkey{enum-range}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em enum-value}~~~\TT{..}~~~{\em enum-value} \\
    $|$ & {\em enum-value}~~~\TT{..} \\
    $|$ & \TT{..}~~~{\em enum-value} \\
    \end{tabular} \\
\emkey{enum-value} ::= {\em compile-time-enum-expression}
\end{indpar}

If the {\em enum-values} in an {\em enum-set-constant} or
{\em enum-list-constant} have different
enumeration types, implied conversions from these to their base types
are inserted until all have the same defined enumeration type,
which is called the
`\key{common enumeration type}'\label{COMMON-ENUMERATION-TYPE}
of the set or list.
This is the most specific least general type to which all the set
or list
values can be converted (see \pagref{CONVERSION-RELATION}).
It is an error
if this cannot be done because some of the types have no implied
conversion defined for them, or if after implict conversion the
common type is not a defined enumeration type.
Note that the common type can be an integer type if all
{\em enum-values} are implicitly convertable to integer values.

An {\em enum-range} designates the two values given and all
values in between.
After implict conversion, the first {\em enum-value} in an {\em enum-range}
must \underline{not} be greater than the second {\em enum-value}
in the {\em enum-range}.  If the first or second {\em enum-value} of
an {\em enum-range} is omitted, it is taken to be the lower or upper
limit of the enumeration type of the non-omitted {\em enum-value}.

The order in which values are given in an {\em enum-set-constant}
does not matter.  Overlapping and adjoining ranges are implictly
combined.\footnote{Internally an enumeration set may be stored as a
sorted list of integers with binary indicators specifying when all
the values between one integer and the next integer are to be included
in the set.}
Thus
\begin{indpar}\begin{verbatim}
define type X as uns8 with enum range [1 .. 20]
X X1 is next enum
X X2 is next enum
. . . . . . . . . .
X X20 is next enum

// Then:
//
//    { X1, X5, X2, X10 .. X16, X19 .. X20, X15 .. X18 }
// == { X1, X2, X5, X10 .. X20 }
\end{verbatim}\end{indpar}

The order in which values are given in an {\em enum-list-constant}
does matter, and ranges are not combined.  Thus in the above
example `\TT{[X1 X2] != [X2 X1]}' and `\TT{[X1 X1] != [X1]}'.

Enumeration set and list values are used in logical expressions that
condition function lookup.  For example,
\begin{indpar}\begin{verbatim}
T v = signed max (| type T |) ( T v1, T v2 )
      [| T is in { int8, int16, int32, int64, int128 } |]:
    . . . . . . . . . . .
\end{verbatim}\end{indpar}

defines a function that takes only signed integer type
arguments, and not unsigned integer type arguments.
The logical expression inside \TT{[|~|]} must be satisfied
for the function definition to match a function call, and
the type argument \TT{T}, which is implied and need not be
given in the function call, must be in the give set of
types, where types are values of the enumeration type `\TT{type}'
(see Section~\itemref{TYPE-VALUES}).

At compile-time
enumeration sets and lists can be stored in variables of enumeration set
or list types, which can be declared by:
\begin{indpar}
\emkey{enum-set-type-declaration}\label{ENUM-SET-TYPE-DECLARATION} ::= \\
\hspace*{0.2in} \TT{define type}
		\begin{tabular}[t]{@{}l@{}}
                {\em qualifier-name}\STAR{} {\em enum-set-type-name} \\
		\TT{as set of } {\em element-enum-type-name}
		\end{tabular}
\\[0.5ex]
\emkey{enum-list-type-declaration}\label{ENUM-LIST-TYPE-DECLARATION} ::= \\
\hspace*{0.2in} \TT{define type}
		\begin{tabular}[t]{@{}l@{}}
                {\em qualifier-name}\STAR{} {\em enum-list-type-name} \\
		\TT{as list of } {\em element-enum-type-name}
		\end{tabular}
\end{indpar}

The information about enumeration set and list types can be determined
at compile-time by:

\begin{indpar}
{\tt function bool r = \ttkey{is enumeration set type} ( type T )}
\begin{indpar}
Returns \TT{true} if {\tt T} is an enumeration set type and \TT{false}
otherwise.
\end{indpar}

{\tt function bool r = \ttkey{is enumeration list type} ( type T )}
\begin{indpar}
Returns \TT{true} if {\tt T} is an enumeration list type and \TT{false}
otherwise.
\end{indpar}

{\tt function type r = \ttkey{element type of} ( type T )}
\begin{indpar}
Returns the element type of an enumeration set or list type {\tt T}.
For a set or list constant, this is the common enumeration type.
\end{indpar}

\end{indpar}

The following are builtin enumeration set types:
\begin{indpar} \tt
define type \ttkey{std types} as set of type \\
\ttkey{types} ---> `std types' \\
define type \ttkey{std qualifiers} as set of qualifier \\
\ttkey{qualifiers} ---> `std qualifiers'
\end{indpar}

An enumeration set or list constant is an enumeration set or list
whose element type 
is its common enumeration type, even if this enumeration set or list
type has not been
declared and is not builtin.

Given an enumeration set or list type $T1$ with base type $B1$ and
an enumeration set or list type $T2$ with base type $B2$, the following
conversions are defined:
\begin{indpar}
{\tt function ~~~~~~~~~~~ $T2$ r = ( $T1$ v )}
\begin{indpar}
    Defined as an implied conversion \underline{but only if}
    an implied conversion from $B1$ to $B2$ is defined
\end{indpar}
{\tt function \TT{*UNCHECKED*} $T2$ r = ( $T1$ v )}
\begin{indpar}
    Defined as an \TT{*UNCHECKED} explicit conversion \underline{but only if}
    an \TT{*UNCHECKED*} explicit conversion from $B1$ to $B2$ is defined
\end{indpar}
\end{indpar}
A set type can only be converted to a set type, and a list type can
only be converted to a list type.
These conversions actually do nothing but change the type of the
value.

If $S$ is an enumeration set type with element type $E$, the following
functions are defined at compile-time:

\begin{indpar}
{\tt function $S$ r =
    ($S$ v1) "\ttmkey{+}{enumeration set union}" ( $S$ v2 )}
\begin{indpar}
Returns the union of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $S$ r =
    ($S$ v1) "\ttmkey{*}{enumeration set intersection}" ( $S$ v2 )}
\begin{indpar}
Returns the intersection of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $S$ r =
    ($S$ v1) "\ttmkey{-}{enumeration set difference}" ( $S$ v2 )}
\begin{indpar}
Returns the set difference of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function bool r =
    ($E$ e) \ttmkey{is in}{enumeration set} ($S$ s)}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the set {\tt s}, and
\TT{false} otherwise.
\end{indpar}

{\tt function $S$ r =
    ($E$ e) "\ttmkey{+}{enumeration set union}" ($S$ s)}
\begin{indpar}
Returns union of \{{\tt e}\} and {\tt s}.
\end{indpar}

{\tt function $S$ r =
    ($S$ s) "\ttmkey{+}{enumeration set union}" ($E$ e)}
\begin{indpar}
Returns union of \{{\tt e}\} and {\tt s}.
\end{indpar}

{\tt function $S$ r =
    ($S$ s) "\ttmkey{-}{enumeration set union}" ($E$ e)}
\begin{indpar}
Returns the set difference of {\tt s} and \{{\tt e}\}.
\end{indpar}

\end{indpar}

If $L$ is an enumeration list type with element type $E$, the following
functions are defined at compile-time:

\begin{indpar}
{\tt function $L$ r = ($L$ v1)
		    "\ttmkey{+}{enumeration list concatenation}" ($L$ v2)}
\begin{indpar}
Returns the concatenation of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $L$ r = ($L$ v1)
                        "\ttmkey{-}{enumeration set difference}" ($L$ v2)}
\begin{indpar}
Returns the list made by removing all elements from {\tt v1} that
appear anywhere in {\tt v2}.
\end{indpar}

{\tt function bool r = ($E$ e)
                        \ttmkey{in}{enumeration list} ($L$ v)}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the list {\tt v}, and
\TT{false} otherwise.
\end{indpar}

{\tt function $L$ r = ($E$ e)
                        "\ttmkey{+}{enumeration list prepend}" ($L$ v)}
\begin{indpar}
Returns the list made by prepending {\tt e} to {\tt v}.
\end{indpar}

{\tt function $L$ r = ($L$ v)
                        "\ttmkey{+}{enumeration list append}" ($E$ e)}
\begin{indpar}
Returns the list made by appending {\tt e} to {\tt v}.
\end{indpar}

{\tt function $L$ r = ($L$ s)
                        "\ttmkey{-}{enumeration list remove}" ($E$ e)}
\begin{indpar}
Returns the list made by removing the all occurences of
{\tt e} in {\tt v}.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time enumeration
set and list variables.  If an implementation does
not implement run-time enumeration set and list variables,
enumeration set and list values computed at compile-time may
not be garbage collectable during the compilation.

\subsection{Type Values}
\label{TYPE-VALUES}

The type `\TT{type}' is a builtin enumeration type declared
by the builtin equivalent of:
\begin{indpar} \tt
define type \ttkey{std type} as unswrd with enum [0~..] \\
type \ttkey{std missing type} is next enum // 0 \\
type \ttkey{std type} is next enum // 1 \\
function std type r = std \ttmkey{missing}{type}: \\
\hspace*{3em}r = std missing type \\
\ttkey{type} \ABV{} `std type'
\end{indpar}
Each type is associated with a unique enumeration value
of type `\TT{type}', and this value can be used at both
compile and run time to test whether two `\TT{type}'s are
equal.

New types are declared by statements of the form:
\begin{center}
\tt define type {\em type-name} \ldots{}
\end{center}
The {\em type-name} of a type can be used (1) before a {\em variable-name}
in a declaration, (2) as the name of an enumeration value in an
expression, or (3) as the name of a function in a {\em function-call}.

Values of one type $T1$ can be converted implicitly to another
type $T2$ if and only if an inline function with prototype:
\begin{indpar} \tt
function rQs $T2$ r = (| qualifiers Qs |) ( Qs $T1$ v )
\end{indpar}
is defined.  In this case we say the $T1$ is \mkey{more specific}{types}
than $T2$, or $T2$ is \mkey{more general}{types} than $T1$, or
\begin{center}
{\tt $T1~~\CNV~~T2$}
\end{center}%
\label{CONVERSION-RELATION}

The transitive closure of the $\CNV$ relation between types is
required to be a partial order,
or equivalently, the directed graph whose nodes are types
which has an edge from $T1$ to
$T2$ if and only if \TT{$T1~\CNV~T2$} is required to be acyclic.
In addition, two different paths from one type to another are
required to produce the same result.  For example:
\begin{indpar}\begin{verbatim}
int16 v1 = ...
int32 v2 = v1
float64 v3 = v2
float64 v4 = v1
// Given the two implied conversion paths v1 ---> v2 ---> v3
// and v1 ---> v4, necessarily v3 == v4.
\end{verbatim}\end{indpar}

If for a set of types $\{T1,T2,\ldots\}$ there is a unique
type $T$ such that $T1\TCNV T$, $T2\TCNV T$, \ldots{}, where
$\TCNV$ is the transitive closure of $\CNV$, then
$T$ is called the `\key{least upper bound}'\label{LEAST-UPPER-BOUND}
of the set of types.

Functions can be overloaded based on the number and types
of their arguments and also on the values of arguments that
are known at compile time.  Thus different functions with
the common prototype
\begin{center}
{\tt function unsadr r = size of ( type T )}
\end{center}
may be defined for different values of {\tt T}.  

With this in mind, the following compile-time builtin functions may be
defined automatically:

\begin{indpar}
{\tt function bool r = std ( type T ) \ttkey{is uns}} \\
{\tt function bool r = std ( type T ) \ttkey{is int}} \\
{\tt function bool r = std ( type T ) \ttkey{is float}} \\
{\tt function bool r = std ( type T ) \ttkey{is numeric}} \\
{\tt function bool r = std ( type T ) \ttkey{is implemented numeric}} \\
\begin{indpar}
These functions test {\tt T} in the current scope to see if it is
an \TT{uns$x$} type, an \TT{int$x$} type, a \TT{float$x$} type,
any of these types, or any of these types for which arithmetic
and comparison operators are
`implemented' (see \pagref{IMPLEMENTED}).
\end{indpar}
\end{indpar}

\begin{indpar}
{\tt function type r = \ttkey{base type of} ( type T )}
\begin{indpar}
Returns the base type of the type {\tt T}.  For enumeration
types this is the associated base type from the defined type's
declaration.  For builtin types, it is
{\tt T} itself.
\end{indpar}

{\tt function type r = \ttkey{underlying type of} ( type T )}
\begin{indpar}
Returns {\tt T} if {\tt T} is a builtin type.
Otherwise if {\tt T} is a defined or enumeration type,
\begin{center}
\TT{underlying type of ( base type of ( T ) )}
\end{center}
is returned.  See \pagref{UNDERLYING-TYPE}.
\end{indpar}

{\tt function unsadr r = \ttkey{size of} ( type T )}
\begin{indpar}
Returns the number of bytes in a value of type {\tt T}.
For defined types it is the size of their underlying type
(the size of \TT{void} is \TT{0}).
\end{indpar}

{\tt function unsadr r = \ttkey{alignment of} ( type T )}
\begin{indpar}
Returns the alignment of {\tt T}, a strictly positive integer.
The address of a value of type {\tt T} in RAM should
optimally be a multiple of the alignment.
The alignment of builtin types is their size.
For defined types it is the alignment of their underlying type.
\end{indpar}

{\tt function T r = \ttkey{min value}} \\
{\tt function T r = \ttkey{max value}}
\begin{indpar}
Returns the minimum or maximum value of a type {\tt T}.
These are defined only for number types and enumeration types,
and for enumeration types the values returned are the limits of
the type's {\em enum-range}.
\end{indpar}

{\tt function T r = \ttkey{min unassigned value}} \\
{\tt function T r = \ttkey{max unassigned value}}
\begin{indpar}
Returns the minimum or maximum values not yet assigned to an
enumeration type {\tt T} by an {\em enum-assignment}.  Values
assigned by unchecked conversions are not considered.  If
no values have been assigned, the enumeration value corresponding
to {\em first-enum} is returned by `\TT{min unassigned value}'
and the enumeration value corresponding
to {\em last-enum} is returned by `\TT{max unassigned value}'.

These are defined only for enumeration types,

These values may change when more code is compiled or linked.
You may only assume that constants of type {\tt T} whose values have
already been compiled or linked are within
ranges bounded by these values, i.e., in the ranges:
\begin{center}
{\tt [ min value, min unassigned value )} \\
{\tt ( max unassigned value, max value ]}
\end{center}
\end{indpar}

{\tt function T r = \ttkey{missing value}}
\begin{indpar}
Returns a suitable missing value for type {\tt T}.
Defined to return the largest possible value for builtin unsigned
integer types, the smallest (most negative) possible value for
builtin signed integer types, and \TT{NaN} for builtin
floating point number types.
May be defined by user for defined types.
\end{indpar}

{\tt function T r = \ttkey{default value}}
\begin{indpar}
Returns a suitable default value for type {\tt T}.
Defined to return \TT{0} for builtin number types.
May be defined by user for defined types.  For use by allocators,
such as a user defined function that allocates a vector whose
elements are of type {\tt T}, and the function wishes to give the elements an
initial default value.
\end{indpar}

{\tt function bool r = ( type T1 ) "\ttkey{>}" ( type T2 )}
\begin{indpar}
Returns \TT{true} if and only if {\tt T1 > T2} in the sense that values
of type {\tt T1} can be implicitly converted to values of type {\tt T2}
(see \pagref{CONVERSION-RELATION}).
\end{indpar}

\end{indpar}

\subsection{The Character Type}
\label{THE-CHARACTER-TYPE}

A `\key{character}' is a 32-bit UNICODE character.  It is
defined as the derived type:
\begin{indpar} \tt
define type~\ttkey{std character}~as uns32 \\
\ttkey{character}~\ABV~`std character'
\end{indpar}

A character constant has the syntax:
\begin{indpar}
\emkey{character-constant}\label{CHARACTER-CONSTANT}
    :::= \TT{C"}{\em character-representative}\TT{"} \\
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}

This constant has type \TT{character} and value equal to the
single character represented.

The following functions are builtin:

\begin{indpar}

{\tt function character r = std \ttkey{character} ( uns32 c )}
\begin{indpar}
Returns the character with UNICODE character code equal to {\tt c}.
No check is made that {\tt c} is a legal UNICODE character code
or is non-zero.
\end{indpar}

{\tt function uns32 r = std \ttkey{code} ( character c )}
\begin{indpar}
Returns the UNICODE character code of the character {\tt c}.
\end{indpar}

{\tt function QS uns32 r = std ( qualifiers QS, QS \ttkey{character} c )}
\begin{indpar}
Implied conversion (\pagref{IMPLIED-CONVERSION-FUNCTIONS})
of character {\tt c} to its UNICODE character code.

Because of this implied conversion,
characters can be compared using \TT{<}, \TT{<=}, \TT{==},
\TT{!=}, \TT{>=}, or \TT{>}.
\end{indpar}

{\tt function character r = std \ttmkey{NUL}{character value}}
\begin{indpar}
Returns \TT{C"<0>"},
the character with UNICODE code \TT{0} that is conventionally
used to represent the missing \TT{character} value.
\end{indpar}

\end{indpar}

\subsection{The String Type}
\label{THE-STRING-TYPE}

A `\key{string}' is a vector of characters, that is,
of 32-bit UNICODE characters.
It is defined as a derived type:
\begin{indpar} \tt
define type \ttkey{std string} as adr \\
\ttkey{string} \ABV{} `std string'
\end{indpar}

A {\em quoted-string} lexeme is a constant of \TT{string} type
whose characters are those represented by the lexeme with
the addition of a \TT{NUL} character (code \TT{0}) at the end:
\begin{indpar}
\emkey{string-constant}\label{STRING-CONSTANT}
    :::= \TT{"}{\em character-representative}\TT{"} \\
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}


Strings are read-only, and their characters cannot be changed.

String variables and values are implemented at compile-time.
The following are compile-time functions involving strings:

\begin{indpar}

{\tt function string r =
    std \ttmkey{string}{of character} ( character c )}
\begin{indpar}
Returns the string containing the single character {\tt c}.
\end{indpar}

{\tt function string r =
    std \ttmkey{string}{of integer} ( int128 i )}
\begin{indpar}
Returns the string that is the decimal integer representation of
the integer {\tt i}.  The value returned contains no high order
zeros.  Non-negative values have no sign.
\end{indpar}

{\tt function string r =
    std ( string s1 ) "\ttmkey{+}{of strings}" ( string s2 )}
\begin{indpar}
Returns the concatenation of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function bool r =
    std ( string s1 ) "\ttmkey{==}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{!=}{of strings}" ( string s2 )}
\begin{indpar}
Returns whether {\tt s1} and {\tt s2} are equal or not.
\end{indpar}

{\tt function string r = std \ttmkey{null}{string value}}
\begin{indpar}
Returns a particular zero length \TT{string} that is conventionally
used to represent the missing \TT{string} value.
Although the string is of zero length, it does have one character:
the \TT{NUL} character at its end.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{string} ( string s )}
\begin{indpar}
Returns the length of {\tt s}, the number of characters in {\tt s}
\underline{not counting} the \TT{NUL} character at the end.
\end{indpar}

{\tt function character r = std ( string s ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st character of {\tt s}.

It is a programming error if {\tt i > length of ( s )}.

If {\tt i == length of ( s )}
the \TT{NUL} at the end of the string is returned.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time string
variables.  If an implementation does
not implement run-time string variables,
string values computed at compile-time may
not be garbage collectable during the compilation.

\subsection{The Name Type}
\label{THE-NAME-TYPE}

A `\key{name}' value is a vector of strings.  If the value is
a legal name as defined in Section~\itemref{NAMES}, the
strings are its {\em name-items} with a \TT{null} string appended.
Note that {\em natural-number} {\em name-items} are represented
by strings of digits and not by integers.

The \TT{name} type is is defined as a derived type:
\begin{indpar} \tt
define type \ttkey{std name} as adr \\
\ttkey{name} \ABV{} `std name'
\end{indpar}

A sequence of {\em name-items} in \TT{`~'} quotes is a \TT{name}
constant whose strings are the {\em name-items}
with the \TT{null} string appended:
\begin{indpar}
\emkey{name-constant}\label{NAME-CONSTANT}
    ::= \TT{`}{\em name-item}\STAR{}\TT{'} \\
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

Name values are read-only, and their elements cannot be changed.

Name variables and values are implemented at compile-time.
The following are compile-time functions involving names:

\begin{indpar}

{\tt function name r = \ttmkey{name}{of string} ( string s )}
\begin{indpar}
Returns the name containing just {\tt s} as its only {\em name-item}.
A \TT{null} is appended to the end of the name.
No check is made that {\tt s} is a legal {\em name-item}.
\end{indpar}

{\tt function name r = ( name n1 ) "\ttmkey{+}{of names}" ( name n2 )}
\begin{indpar}
Returns the concatenation of {\tt n1} and {\tt n2}.
\end{indpar}

{\tt function bool r = ( name n1 ) "\ttmkey{==}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{!=}{of names}" ( name n2 )}
\begin{indpar}
Returns whether {\tt n1} and {\tt n2} are equal or not.
\end{indpar}

{\tt function name r = std \ttmkey{null}{name value}}
\begin{indpar}
Returns a particular zero length \TT{name} that is conventionally
used to represent the missing \TT{name} value.
Although the name is of zero length, it does have one string,
the \TT{null} string at its end.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{name} ( name n )}
\begin{indpar}
Returns the length of {\tt n}, the number of strings in {\tt n}
\underline{not counting} the \TT{null} string at the end.
\end{indpar}

{\tt function string r = std ( name n ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st string of {\tt n}.

It is a programming error if {\tt i > length of ( n )}.

If {\tt i == length of ( n )}
the \TT{null} at the end of the name is returned.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time name
variables.  If an implementation does
not implement run-time name variables,
name values computed at compile-time may
not be garbage collectable during the compilation.

\subsection{Name Sets and Lists}
\label{NAME-SETS-AND-LISTS}

An \key{name set} is a set of names.
An \key{name list} is a list of names.  The syntax
for name set and list constants is:
\begin{indpar}
\emkey{name-set-constant}\label{NAME-SET-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{~\}} \\
    $|$ &\TT{\{} {\em name-value}
                   \{ \TT{,} {\em name-value} \}\STAR{} \TT{\}} \\
    \end{tabular} \\
\emkey{name-list-constant}\label{NAME-LIST-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{[~]} \\
    $|$ &\TT{[} {\em name-value}
                   \{ \TT{,} {\em name-value} \}\STAR{} \TT{]} \\
    \end{tabular} \\
\emkey{name-value} ::= {\em compile-time-name-expression}
\end{indpar}

The order in which names are given in a {\em name-set-constant}
does not matter, and duplicate names in the set are eliminated.
Thus
\begin{center}
`\TT{\{`X1' `X2'\} = \{`X2 `X1'\}}'\\
and\\
`\TT{\{`X1' `X1'\} = \{`X1'\}}'.
\end{center}

The order in which values are given in an {\em name-list-constant}
does matter, and duplicates are not combined.
Thus
\begin{center}
`\TT{[`X1' `X2'] != [`X2 `X1']}'\\
and\\
`\TT{[`X1' `X1'] != [`X1']}'.
\end{center}

Name set and list values are used in code expansions.
For example,
\begin{indpar}\begin{verbatim}
include for n in [`x[1]', `x[2]', `x[3]' ]:
    int n = 0
\end{verbatim}\end{indpar}

Name sets and lists can be stored in variables of the builtin name set
or list types:
\begin{indpar}
{\tt define type \ttkey{name set} as adr} \\
{\tt define type \ttkey{name list} as adr}
\end{indpar}

The following \TT{name set} functions are buitin:

\begin{indpar}
{\tt function name set r = (name set s1)
                        "\ttmkey{+}{name set union}" ( name set s2 )}
\begin{indpar}
Returns the union of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function name set r = ( name set s1 )
                        "\ttmkey{*}{name set intersection}" ( name set s2 )}
\begin{indpar}
Returns the intersection of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function name set r = ( name set s1 )
                        "\ttmkey{-}{name set difference}" ( name set s2 )}
\begin{indpar}
Returns the set difference of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function bool r = (name e) \ttmkey{in}{name set} ( name set s )}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the set {\tt s}, and
\TT{false} otherwise.
\end{indpar}

{\tt function name set r = (name n) "\ttmkey{+}{name set union}" ( name set s )}
\begin{indpar}
Returns union of \{{\tt n}\} and {\tt s}.
\end{indpar}

{\tt function name set r = ( name set s )
                        "\ttmkey{+}{name set union}" (name n)}
\begin{indpar}
Returns union of \{{\tt n}\} and {\tt s}.
\end{indpar}

{\tt function name set r = ( name set s )
                        "\ttmkey{-}{name set union}" (name n)}
\begin{indpar}
Returns the set difference of {\tt s} and \{{\tt n}\}.
\end{indpar}

\end{indpar}

The following \TT{name list} functions are buitin:

\begin{indpar}
{\tt function name list r = (name list ls1)
		    "\ttmkey{+}{name list concatenation}" (name list ls2)}
\begin{indpar}
Returns the concatenation of {\tt ls1} and {\tt ls2}.
\end{indpar}

{\tt function name list r = (name list ls1)
                        "\ttmkey{-}{name list difference}" (name list ls2)}
\begin{indpar}
Returns the list made by removing all elements from {\tt ls1} that
appear anywhere in {\tt ls2}.
\end{indpar}

{\tt function bool r = (name n) \ttmkey{in}{name list} (name list ls)}
\begin{indpar}
Returns \TT{true} if {\tt n} is an element of the list {\tt ls}, and
\TT{false} otherwise.
\end{indpar}

{\tt function name list r = (name n)
                        "\ttmkey{+}{name list prepend}" (name list ls)}
\begin{indpar}
Returns the list made by prepending {\tt n} to {\tt ls}.
\end{indpar}

{\tt function name list r = (name list ls)
                        "\ttmkey{+}{name list append}" (name n)}
\begin{indpar}
Returns the list made by appending {\tt n} to {\tt ls}.
\end{indpar}

{\tt function name list r = (name list s)
                        "\ttmkey{-}{name list remove}" (name n)}
\begin{indpar}
Returns the list made by removing the all occurences of
{\tt n} in {\tt ls}.
\end{indpar}

\end{indpar}

\subsection{Contexts}
\label{CONTEXTS}

TBD


\section{Qualifiers}
\label{QUALIFIERS}

Variables may be qualified by \skey{qualifier}s, which preceed the
type when a variable is declared.  There are four builtin qualifiers
described in Section~\itemref{BUILTIN-QUALIFIERS} that have special
effects: \TT{mem}, \TT{stack}, \TT{*UNCHECKED*}, and \TT{global}.
There is also a builtin method for defining trace qualifiers which
have special effects.
Other qualifiers that have no special effects
may be defined, and are typically used to add an
additional layer of type checking that is somewhat orthogonal to
types.

Syntactically {\em qualifier-names} immediately preceed the {\em type-names}
that are before {\em variable-names}.  Some introductory examples are:
\begin{indpar}\begin{verbatim}
required qualifier fee
prohibited qualifier fie
function int32 result = F ( fee int32 value ):
    // Declares function F that computes a result of type
    // int32 from a value of type int32 and qualifier fee.
    // Requires call argument to have qualifier fee, but
    // prohibits the argument from having qualifier fie.
    //
    ... [Function body omitted] ...

// Example usage:
//
int32 x1 = ...
fee int32 x2 = ...
fie int32 x3 = ...
int32 y1 = F ( x1 )          // Illegal; x1 does not have
                             // required fee.
int32 y2 = F ( x2 )          // Legal; x2 has required fee.
int32 y3 = F ( x3 )          // Illegal; x3 has prohibited
                             // fie.
fee int32 y4 = x1            // Illegal; x1 does not have
                             // required fee.
fee int32 y5 = x2            // Legal; x2 has required fee.
int32 y6 = x3                // Illegal; x3 has prohibited
                             // fie but y6 does not.
fie int32 y7 = x3            // Legal; x3 has prohibited
                             // fie but so does y7.

protected required qualifier foo
function fo int32 result = G ( int32 value ):
    // Declares function G that computes a result of type
    // int32 from a value of type int32.  Attaches fo, which
    // is protected, to the result.
    //
    ... [Function body omitted] ...

function int32 result = H ( fo int32 value ):
    ... [Function body omitted] ...

fee int32 z1 = G ( x1 )      // Legal; z1 also acquires fo.
fee int32 z2 = H ( z1 )      // Legal; z1 has implied
                             // qualifier fo.
fo  int32 z3 = F ( x1 )      // Illegal; fo is protected, and
                             // F does not have fo on its
                             // prototype result variable.
fo  int32 z4 = G ( x1 )      // Legal; G gives z4 the
                             // protected fo qualifier so its
                             // OK for z4 to have that
                             // qualifier explicitly.

fo  int32 z5 = x1            // Illegal, x1 does NOT have
                             // protected qualifier fo.
fo  int32 z6 = y7            // Legal, y7 has protected
                             // qualifier fo.
int32 z7 = y7                // Legal, y7 has protected
                             // qualifier fo, so z7
                             // acquires fo.
\end{verbatim}\end{indpar}

The qualifiers may be declared by:
\begin{indpar}
\emkey{qualifier-declaration}\label{QUALIFIER-DECLARATION} \\
\hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define} {\em qualifier-attribute}\PLUS{} \ttkey{qualifier}
           {\em defined-qualifier-name} \\
    $|$ & {\em trace-qualifier-declaration}
    	  ~~~ [see \pagref{TRACE-QUALIFIERS}]
    \end{tabular} \\
\emkey{qualifier-attribute}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{required} \\
    $|$ & \ttkey{prohibited} \\
    $|$ & \ttkey{protected} \\
    $|$ & \ttkey{inherited} \\
    \end{tabular} \\
\emkey{defined-qualifier-name} ::= {\em qualifier-name} \\
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME}

where
\begin{enumerate}
\item
No {\em qualifier-name} may be a prefix of
any {\em type-name},
any {\em deferred-result-variable} (\pagref{DEFERRED-RESULT-VARIABLE})
or any {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME}).
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.
\item
No qualifier name may begin with `\TT{next}'
or `\TT{previous}'.
\end{enumerate}
\end{indpar}

If a function prototype variable (argument or result) has
a \key{required qualifier}, any call variable matched to this
prototype variable must have the required qualifier.

If a function prototype variable (argument or result)
does \underline{not}
have a \key{prohibited qualifier}, any call variable matched to this
prototype variable must \underline{not} have the prohibited qualifier.

A qualifier \underline{must} be required or prohibited or both.
Given a function prototype variable with a qualifier that is
both required and prohibited,
a matching call variable must always have the qualifier,
and given a function prototype variable without such a qualifier,
a matching call variable must never have the qualifier.

If a function prototype result variable has a \key{protected
qualifier}, any call variable matched to this
prototype variable will be given the protected qualifier
(if it does not already have it).  Furthermore, no variable
may have a protected qualifier unless it is matched to
a function result variable with the qualifier.

In the above example, 
any call variable matched to the argument of {\tt F}
must have the `{\tt fie}' qualifier, which is required.
Any call variable matched to the argument of {\tt G}
must \underline{not} have the `{\tt fo}' qualifier, which is prohibited.
The `{\tt fo}' qualifier can only be placed on a variable that is
the result of a function like {\tt G} which attaches it to its result,
as `{\tt fo}' is protected.  `{\tt fee}' and `{\tt fie}' can be attached
to any variable, as they are \underline{not} protected.

Inherited qualifiers affect cluster variables and their behavior is
specified on page~\pageref{INHERITED-QUALIFIER}. 

The builtin qualifiers are in effect declared by:
\begin{indpar}
{\tt protected~qualifier~}\ttkey{mem} \\
{\tt prohibited~protected~inherited~qualifier~}\ttkey{stack} \\
{\tt required qualifier~}\ttkey{*UNCHECKED*} \\
{\tt protected~inherited~qualifier~}\ttkey{global}
\end{indpar}

The type `\TT{qualifier}' is a builtin enumeration type declared
by:
\begin{indpar} \tt
define type \ttkey{std qualifier} as unswrd with enum [0~..] \\
qualifier \ttkey{std missing qualifier} is next enum // 0 \\
function std qualifier r = std \ttmkey{missing}{qualifier}: \\
\hspace*{3em}r = std missing qualifier \\
\ttkey{qualifier} \ABV{} `std qualifier'
\end{indpar}
Each qualifier is associated with a unique enumeration value
of type `\TT{qualifier}', and this value can be used at both
compile and run time to test whether two `\TT{qualifier}'s are
equal.

The {\em qualifier-name} of a qualifier
can be used (1) before a {\em type-name}
in a declaration, (2) as the name of an enumeration value in an
expression, or (3) as the name of a function in a {\em function-call}.


\section{Conversions}
\label{CONVERSIONS}

Conversions of a value of one data type $T1$ to a value of another
data type $T2$ play a very important role in a typed language.
For example:
\begin{indpar}\begin{verbatim}
int64 x = y + 1,000 * z
    // Compiles to:
    //   int64 T$1 = y            // Conversion
    //   int64 T$2 = 1,000        // Conversion
    //   int64 T$3 = z            // Conversion
    //   int64 T$4 = T$2 "*" T$3  // Function call (of "*")
    //   int64 x = T$1 "+" T$4    // Function call (of "+")
\end{verbatim}\end{indpar}

Here the {\tt T\$\ldots} variables are temporary variables
introduced by the compiler, and {\tt int64} is the type
of these because being the type of {\tt x} it becomes the
`target type' of the expression and its subexpressions
(see \itemref{EXPRESSION-TYPING} for more on target types).

An \key{implied conversion} is a simple assignment statement whose
right side is a variable or a constant.

\subsection{Implied Conversion Functions}
\label{IMPLIED-CONVERSION-FUNCTIONS}

Implied conversions are defined by function prototypes of the form:
\begin{center} \tt
function \ldots{}~$T2$ r = ( \ldots{}~$T1$ v )
\end{center}
where `\ldots{}' denotes information about qualifiers.

An implied conversion function that copies qualifiers from the
argument has the form:
\begin{center} \tt
function rQs $T2$ r = (| qualifiers Qs |) ( Qs $T1$ v )
\end{center}

Here the {\tt Qs} argument may be implied as the list of
qualifiers of the actual argument.  {\tt rQs} is set equal to
{\tt Qs}, but only \underline{after} the value of {\tt Qs} has
been found by implication: see \itemref{FUNCTION-PROTOTYPES-AND-CALLS}
for more details.

Implied conversion functions are only called by implied conversions, that
is, by simple assignment statements whose right side is
a variable or constant.  The parentheses that would normally
surround the {\em function-call} argument may be omitted
in this case.

\subsection{The Conversion Graph}
\label{THE-CONVERSION-GRAPH}

An ordering is induced on types by implied conversions.  Let
$T1\CNV T2$ mean that there is an implied conversion from
values of type $T1$ to values of type $T2$.  Let $T1~\TCNV~T2$
be the transitive closure of $T1\CNV T2$, which means
that a value of type $T1$ may be converted to a value
of type $T2$ by applying zero or more implied conversions.
Then we \underline{require}
that $T1\TCNV T2$ be a partial order, which means that:
\begin{itemize}
\item $\TCNV$ is reflexive: $T1\TCNV T1$.
\item $\TCNV$ is transitive: $T1\TCNV T2$ and $T2\TCNV T3$
imply that $T1\TCNV T3$.
\item $\TCNV$ is anti-symmetric:
$T1\TCNV T2$ and $T2\TCNV T1$
imply that $T1 = T2$.
\end{itemize}

Importantly, the anti-symmetric rules \underline{requires} that
if values of type $T1$ can be implicitly converted to
values of a different type type $T2$, then values of type $T2$
\underline{cannot} be implicitly converted to values of type $T1$.

It is a compiler error for an implicit conversion function
prototype to cause $\TCNV$ to violate the anti-symmetric rule.

We define the \key{implied conversion graph} to be the directed
graph whose nodes are types and which has an arrow from $T1$ to
$T2$ if and only if $T1\CNV T2$.
Or equivalently, there is an implied conversion function defined
whose argument is of type $T1$ and whose result is of type $T2$.
Then $T1\TCNV T2$ if and only if there is a (possibly zero size)
path in this graph from $T1$ to $T2$.

It is a good idea if that all paths
from $T1$ to $T2$ give the same result, though we do not require
this.
This means, for example, that
if one can implicitly convert a $T1$ value directly to
either a $T2$ or $T3$ value, and one can implicitly convert
a $T2$ value to a $T3$ value, then converting a $T1$ value
to a $T2$ value and then converting that to a $T3$ value
must give the same resulting value as converting the $T1$ value
directly to a $T3$ value.

Various builtin implied conversions are described
in this document.

Note that $T1\CNV T2$ does \underline{not} imply that every
value of type $T1$ can be fully represented by a value of type
$T2$.  For example, an implied conversion $T1\CNV bool$
might be introduced to map all non-missing $T1$ values to \TT{true}
and any missing $T1$ value to \TT{false}.

\subsection{Qualifier Conversions}
\label{QUALIFIER-CONVERSIONS}

A simple assignment statement with variable or constant right
side that has the same type as the result variable on the left
side is a \key{qualifier conversion}.  These are builtin and
obey the following rules:

\begin{enumerate}
\item If there is a protected qualifier $Q$ on the right side, it
is automatically added to the left side.
\item If there is a required qualifier $Q$ on the left side, it
must also be on the right side.
\item If there is a prohibited qualifier $Q$ not on the left side, it
must also not be on the right side.
\end{enumerate}

Note that constants are considered to not have any qualifiers.
Also the case where the qualifiers and both side are the same,
as well as the types, is considered to be a `qualifier conversion'
even though nothing is actually converted.


\subsection{Explicit Conversions}
\label{EXPLICIT-CONVERSIONS}

In addition to implied conversions there are `\skey{explicit conversion}s'
defined by function prototypes of the form:
\begin{center} \tt
function \ldots{}~$T2$ r = $T2$ ( \ldots{}~$T1$ v )
\end{center}
where `\ldots{}' denotes information about qualifiers.
Here $T2$ is used as the name of a function that performs the
conversion.

A type $T2$ may be implicitly convertable to type $T1$ while
$T1$ is explicitly convertable to $T2$.

\section{Expressions}
\label{EXPRESSIONS}

Expressions compute values and appear inside statements where a value is needed.
For example, in a {\em simple-assignment-statement} of the form
\begin{indpar}
{\em qualifier-name}\STAR{} ~ {\em type-name} ~ {\em variable-name}
	~ {\tt =} ~ {\em expression}
\end{indpar}
the {\em expression} computes a value to store in the variable.

The parser parses {\em expressions} and converts code into statements
that have no {\em expressions} except for {\em variable-names}
and for {\em function-calls} in statements of the form
\begin{indpar}
\ldots{} ~ {\tt =} ~{\em function-call}
\end{indpar}
where \ldots{} is an optional list of result variables for the
{\em function-call}.

\subsection{Variable Names}

A {\em variable-name} names a variable that is allocated to
the current function frame by an {\em assignment-statement}.
The syntax is:

\begin{indpar}
\emkey{variable-name}
	::= {\em variable-base-name} {\em member-selector}\STAR{} \\
\emkey{variable-base-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript } \\
\emkey{member-name}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark}
			    or {\em quoted-separator}
			\end{tabular} \\
\emkey{member-subscript}\label{MEMBER-SUBSCRIPT}
    ::= {\em enum-list-constant} \\
{\em enum-list-constant} ::= see \pagref{ENUM-LIST-CONSTANT} \\
{\em name} ::= see \pagref{NAME}
\end{indpar}

Some examples that use {\em member-subscripts} are:\label{SLICE}
\begin{indpar}\begin{verbatim}
uns8 string[0 .. 5] = .....   // Allocate slice.
..... string[0] .....         // Read one variable of slice.
..... string[1 .. 5] .....    // Read subslice of slice.
..... string[0 .. 3] .....    // Read a different subslice.
\end{verbatim}\end{indpar}

One can also assemble slices into a larger slice.  For example:
\begin{indpar}\begin{verbatim}
float64 m[0 .. 1, 0 .. 1 ] = .....   // Allocate slice.
float64 m[2 .. 6, 0 .. 1 ] = .....   // Allocate slice.
float64 m[0 .. 6, 2 .. 4 ] = .....   // Allocate slice.
..... m[0 .. 6, 0 .. 4] .....        // Read assembled slice.
\end{verbatim}\end{indpar}

\subsection{Expression Syntax}
\label{EXPRESSION-SYNTAX}

The operators that can appear in an expression in approximate
precedence order (lowest precedence topmost) are:

\begin{center}

\begin{tabular}{c}
\TT{if ~ else} \\
selection operators
\end{tabular}

\medskip

\begin{tabular}{c}
\TT{and ~ or} \\
\TT{not} \\
logical operators
\end{tabular}

\medskip

\begin{tabular}{c}
\TT{== ~ != ~ > ~ >= ~ < ~ <=} \\
comparison operators
\end{tabular}

\medskip

\begin{tabular}[t]{c}
\TT{+ ~ -} \\
summation operators
\\[2ex]
\TT{* ~ / ~ div ~ mod ~ rem } \\
product operators
\\[2ex]
\TT{\textasciicircum} \\
exponent operator
\end{tabular}
~~~~~
\begin{tabular}[t]{c}
\TT{\& ~ | ~ xor ~ <{}< ~ >{}>} \\
\TT{!} \\
bitwise operators
\end{tabular}

\end{center}

\begin{indpar}

However precedence is only a rough guide to the syntax of L-Language
operators.  Also unary \TT{+} and \TT{-} operators have the
same precedence as the binary \TT{+} and\TT{-} operators.

Two operators are said to be mixed in an expression if neither is
inside a parenthesized subexpression that does not contain the other.
The logical operators other than `\TT{not}' cannot be mixed with
each other, and similarly for the product operators and the
bitwise operators other than \TT{!} (bitwise complement).  Bitwise
operators cannot be mixed with summation and product operators.

The precise syntax of expressions is:

\emkey{expression}\label{EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em selection-expression} \\
    $|$ & {\em logical-expression} \\
    $|$ & {\em comparison-expression} \\
    $|$ & {\em bitop-expression} \\
    $|$ & {\em summation-expression} \\
    $|$ & {\em product-expression} \\
    $|$ & {\em exponent-expression} \\
    $|$ & {\em mark-expression} \\
    $|$ & {\em subexpression} \\
    $|$ & {\em primary} \\
    \end{tabular}
\\[0.5ex]
\emkey{selection-expression}\label{SELECTION-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em selection-operand} \TT{if} {\em logical-expression} \TT{else} \\
	& ~~~~~ \{ {\em selection-operand} \TT{if} {\em logical-expression}
	           \TT{else} \}\STAR{} \\
	& ~~~~~ {\em selection-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{selection-operand}\label{SELECTION-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-expression} $|$ {\em summation-expression}
                                 $|$ {\em product-expression} \\
    $|$ & {\em exponent-expression} $|$ {\em mark-expression} \\
    $|$ & {\em subexpression} $|$ {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{logical-expression}\label{LOGICAL-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & \TT{not}\QMARK{} ~  {\em logical-operand} \\
    $|$ & \TT{not}\QMARK{} ~ {\em logical-operand}
         \{ \TT{and} ~ \TT{not}\QMARK{} ~ {\em logical-operand} \}\PLUS{} \\
    $|$ & \TT{not}\QMARK{} ~ {\em logical-operand}
         \{ \TT{or} ~ \TT{not}\QMARK{} ~ {\em logical-operand} \}\PLUS{} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-operand}\label{LOGICAL-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em comparison-expression} $|$ {\em subexpression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{comparison-expression}\label{COMPARISON-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em comparison-operand}
	  \{ {\em comparison-operator} ~ {\em comparison-operand} \}\PLUS{} \\
    \end{tabular}
\\[0.5ex]
\emkey{comparison-operator}\label{COMPARISON-OPERATOR} ::=
    \TT{==} $|$ \TT{!=} $|$ \TT{>} $|$ \TT{>=} $|$ \TT{<} $|$ \TT{<=}
\\[0.5ex]
\emkey{comparison-operand}\label{COMPARISON-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-expression} $|$ {\em summation-expression}
                                 $|$ {\em product-expression} \\
    $|$ & {\em exponent-expression} $|$ {\em mark-expression} \\
    $|$ & {\em subexpression} $|$ {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{bitop-expression}\label{BITOP-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & \TT{!} {\em bitop-operand} \\
    $|$ & \TT{!}\QMARK{} ~ {\em bitop-operand}
         \{ \TT{\&} ~ \TT{!}\QMARK{} ~ {\em bitop-operand} \}\PLUS{} \\
    $|$ & \TT{!}\QMARK{} ~ {\em bitop-operand}
         \{ \TT{|} ~ \TT{!}\QMARK{} ~ {\em bitop-operand} \}\PLUS{} \\
    $|$ & \TT{!}\QMARK{} ~ {\em bitop-operand}
         \{ \TT{xor}
	    ~ \TT{!}\QMARK{} ~ {\em bitop-operand} \}\PLUS{} \\
    $|$ & {\em bitop-operand}
         \{ {\em shift-operator} ~ {\em bitop-operand} \}\PLUS{} \\
    \end{tabular}
\\[0.5ex]
\emkey{shift-operator}\label{SHIFT-OPERATOR} ::= \TT{<{}<} $|$ \TT{>{}>}
\\[0.5ex]
\emkey{bitop-operand}\label{BITOP-OPERAND} ::=
    {\em mark-expression} $|$ {\em subexpression} $|$ {\em primary}
\\[0.5ex]
\emkey{summation-expression}\label{SUMMATION-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em sign}\QMARK{} ~  {\em summation-operand} ~
         \{ {\em sign} ~ {\em summation-operand} \}\PLUS{} \\
    $|$ & {\em sign} ~ {\em summation-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{sign}\label{SIGN} ::= \TT{+} $|$ \TT{-}
\\[0.5ex]
\emkey{summation-operand}\label{SUMMATION-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em product-expression} $|$ {\em exponent-expression}
                                   $|$ {\em mark-expression} \\
    $|$ & {\em subexpression} $|$ {\em primary} \\
    \end{tabular}
\\[0.5ex]
\emkey{product-expression}\label{PRODUCT-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em product-operand} ~ \{ \TT{*} ~ {\em product-operand} \}\PLUS{} \\
    $|$ & {\em product-operand} ~ \TT{/} ~ {\em product-operand} \\
    $|$ & {\em product-operand} ~ \TT{div} ~ {\em product-operand} \\
    $|$ & {\em product-operand} ~ \TT{mod} ~ {\em product-operand} \\
    $|$ & {\em product-operand} ~ \TT{rem} ~ {\em product-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{product-operand}\label{PRODUCT-OPERAND} ::=
    {\em exponent-expression} $|$ {\em mark-expression} $|$
    {\em subexpression} $|$ {\em primary}
\\[0.5ex]
\emkey{exponent-expression}\label{EXPONENT-EXPRESSION}
    ::= {\em exponent-operand} ~ \TT{\textasciicircum} ~ {\em exponent-operand}
\\[0.5ex]
\emkey{exponent-operand}\label{EXPONENT-OPERAND} ::=
    {\em mark-expression} $|$ {\em subexpression} $|$ {\em primary}
\\[0.5ex]
\emkey{mark-expression}\label{MARK-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & \{ {\em mark-operand} ~ {\em mark-operator} \}\PLUS{}
	  {\em mark-operand}\QMARK{} \\
    $|$ & \{ {\em mark-operator} ~ {\em mark-operand} \}\PLUS{}
	  {\em mark-operator}\QMARK{} \\
    \end{tabular}
\\[0.5ex]
\emkey{mark-operator}\label{MARK-OPERATOR} ::=
    {\em mark} that is not otherwise mentioned in these syntax equations
\\[0.5ex]
\emkey{mark-operand}\label{MARK-OPERAND} ::=
    {\em subexpression} $|$ {\em primary}
\\[0.5ex]
\emkey{subexpression}
    \begin{tabular}[t]{rl}
    ::= & {\em module-abbreviation} ~ \TT{(} {\em expression} \TT{)} \\
    $|$ & \TT{(} {\em expression} \TT{)} \\
    \end{tabular}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
\emkey{primary}\label{PRIMARY}
    \begin{tabular}[t]{rl}
    ::= & {\em argument-list}\STAR{}
	      \begin{tabular}[t]{l}
	      {\em primary-item}\PLUS{}\\
	      \{ {\em argument-list}\PLUS{}
		 {\em primary-item}\PLUS{} \}\STAR{} \\
	      {\em argument-list}\STAR{} \\
	      \end{tabular} \\
    $|$ & {\em argument-list} {\em argument-list}\PLUS{} \\
    $|$ & {\em bracketed-constant}
    \end{tabular}
\\[0.5ex]
\emkey{primary-item}\label{PRIMARY-ITEM}
    ::= {\em word} $|$ {\em number} $|$ {\em quoted-string}
\\[0.5ex]
\emkey{argument-list}\label{ARGUMENT-LIST}
    \begin{tabular}[t]{rl}
    ::= & \TT{( )} \\
    $|$ & \TT{(} {\em expression} \{ \TT{,} {\em expression} \}\STAR{} \TT{)} \\
    $|$ & \TT{[ ]} \\
    $|$ & \TT{[} {\em expression} \{ \TT{,} {\em expression} \}\STAR{} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{bracketed-constant}\label{BRACKETED-CONSTANT}
    \begin{tabular}[t]{rl}
    ::= & \TT{[ ]} \\
    $|$ & \TT{[} {\em range}
          \{ \TT{,} {\em range} \}\STAR{} \TT{]} \\
    $|$ & \TT{\{ \}} \\
    $|$ & \TT{\{} {\em range}
          \{ \TT{,} {\em range} \}\STAR{} \TT{\}} \\
    $|$ & \TT{`} {\em name-item}\STAR{} \TT{'}
    \end{tabular}
\\[0.5ex]
\emkey{range}\label{RANGE}
    \begin{tabular}[t]{rl}
    ::= & {\em expression} \\
    $|$ & {\em expression} \TT{..} {\em expression} \\
    $|$ & {\em expression} \TT{..} \\
    $|$ & \TT{..} {\em expression} \\
    \end{tabular}
\end{indpar}

Note that strictly binary operators such as \TT{mod} can also
be used as function names in {\em primaries}, as in
\begin{center}
{\tt uns8 x = mod ( 257 )}
\end{center}

It is the compiler, and not the parser, that analyzes {\em primaries},
because knowledge of the {\em names} in scope is required.  To the
compiler, a {\em primary} has the following syntax:
\begin{indpar}
\emkey{primary}\label{COMPILER-PRIMARY}
    \begin{tabular}[t]{rl@{\hspace*{0.4in}}l}
    ::= & {\em constant} \\
    $|$ & {\em variable-name} 		& [see \pagref{VARIABLE-NAME}] \\
    $|$ & {\em variable-declaration} \\
    $|$ & {\em qualifier-conversion} \\
    $|$ & {\em type-conversion} \\
    $|$ & {\em function-call}		& [see \pagref{FUNCTION-CALL}] \\
    \end{tabular}
\\[0.5ex]
\emkey{constant}\label{CONSTANT}
    \begin{tabular}[t]{rl@{\hspace*{0.5in}}l}
    ::= & {\em number-constant} 	& [see \pagref{NUMBER-CONSTANT}] \\
    $|$ & {\em character-constant} 	& [see \pagref{CHARACTER-CONSTANT}]  \\
    $|$ & {\em string-constant} 	& [see \pagref{STRING-CONSTANT}]  \\
    $|$ & {\em name-constant} 		& [see \pagref{NAME-CONSTANT}]  \\
    $|$ & {\em enum-set-constant}	& [see \pagref{ENUM-SET-CONSTANT}]  \\
    $|$ & {\em enum-list-constant}	& [see \pagref{ENUM-LIST-CONSTANT}]  \\
    $|$ & {\em name-set-constant}	& [see \pagref{NAME-SET-CONSTANT}]  \\
    $|$ & {\em name-list-constant}	& [see \pagref{NAME-LIST-CONSTANT}]  \\
    \end{tabular}
\\[0.5ex]
\emkey{variable-declaration} ::= {\em qualifier-name}\STAR{}
                                 {\em type-name} {\em variable-name}
\\[0.5ex]
\emkey{qualifier-conversion}
    ::= {\em qualifier-name}\PLUS{} \TT{(} {\em expression} \TT{)}
\\[0.5ex]
\emkey{type-conversion}
    ::= {\em qualifier-name}\STAR{} {\em type-name}
        \TT{(} {\em expression} \TT{)}
\end{indpar}

If the {\em primary} is not a {\em constant}, the compiler
checks the scope to see if it is a {\em variable-declaration},
{\em variable-name}, {\em qualifier-conversion}, or
{\em type-conversion}.  If it is none of these, the
compiler applies the {\em function-call} matching rules of
\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}
to match the {\em primary} to a {\em function-prototype}.

\subsection{Expression Semantics}

Expressions provide standard operators.  Expressions are compiled
into function calls, and builtin functions
implement logical and numeric operators.

\subsubsection{Expression Typing}
\label{EXPRESSION-TYPING}

L-Language uses a top-down method of assigning types to operator arguments.
Generally given the statement
\begin{center}
$T$ $v$ ~ \TT{=} ~ $e1$ ~ $op1$ ~ $e2$ ~ $op2$ ~ \ldots{}
\end{center}
where $T$ is a type of a variable $v$, where $e1$, $e2$, \ldots{} are
subexpressions, and where $op1$, $op2$, \ldots{} are operators with the
same precedence (e.g., all are either \TT{+} or \TT{-}), then
all the subexpression values are implicitly converted to type $T$
before the operations are done.  Here $T$ is called the `\key{target type}'
of the expressions $e1$, $e2$, \ldots{}.

An example is:

\begin{indpar}\begin{verbatim}
float64 w = 1.5
int64 x = 9,568
uns64 y1 = 0xFF00
uns32 y2 = 0xFF00
int64 z1 = x + y1
    // Compile error:
    //     y1 is not implicitly convertible to int64
int64 z2 = x + y2
    // OK, y2 IS implicitly convertible to int64
int64 z3 = x + y2 * w
    // Compile error:
    //     Target type of y2 * w is int64,
    //     hence target type of y2 is int64 with is OK,
    //     and target type of w is int64, but w is not
    //     implicitly convertiable to int64
\end{verbatim}\end{indpar}

The target type of an expression is usually provided by the
type of the variable being set by an assignment statement, or in the
case of function arguments, by the argument type specified in the
function prototype.

The target type of a {\em logical-expression} or a {\em comparison-expression}
is \TT{bool}.

In some cases the target type is specified by special rules.  The
target type of {\em comparison-operands} is specified by special
rules given in \itemref{COMPARISON-EXPRESSIONS}.

Some special rules
make use of the `\key{natural type}'\label{NATURAL-TYPE}
that some subexpressions have.
The natural type of a variable is its type.
The natural type of an expression of the
form `\TT{$Qs$ $T$ ( \ldots{} )}' where $Qs$ is a list of qualifiers
and $T$ is a type name is $T$.
The natural type of a {\em function-call} is the type found by matching
the call to {\em function-prototypes}
(\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}), if an unambiguous
match can be found under the assumption that
the call has a result variable of unknown type.
No other expression has a natural type.

When an expression has a natural type, it also has natural qualifiers
that are found with the natural type.

If there is no target type because an expression is being used
as a {\em simple-assignment-statement} with no result variables, then
the expression must be a {\em function-call} and can only match
{\em function-prototypes} that have no result variables.

\subsubsection{Evaluation Order}
\label{EVALUATION-ORDER}

Where binary operators of the same precedence appear outside
parentheses in an expression, they are evaluated left to right.
This is, they are left associative.  For example,
`{\tt x <{}< s1 >{}> s2}' is
equivalent to `{\tt (x <{}< s1) >{}> s2}'.

For logical operators such as `\TT{and}', `\TT{or}', and
`\TT{\ldots{}~if~\ldots{}~else~\ldots{}}' the value of the expression
may be determined before all the operands have been evaluated.
In this case the unnecessary operands are never evaluated.
For example, if in `\TT{$e1$~and~$e2$}' the subexpression $e1$
evaluates to \TT{false}, the subexpression $e2$ is never evaluated.
Furthermore, if $e1$ evaluates at compile-time to \TT{false},
$e2$ is not even compiled, and any compile errors it contains
are not detected.  Similarly if in `\TT{$e1$~if~$b$~else~$e2$}' the
conditioning expression $b$ evaluates to \TT{true}, $e2$ is
never evaluated, and if $b$ evaluates to \TT{true} at compile
time, $e2$ is never compiled.  However all subexpressions are parsed and
parsing errors are detected.

\subsubsection{Logical Expressions}

In logical expressions the `\TT{not}' operator is moved inside
`\TT{and}' and `\TT{or}' operators before further evaluation.
Also double negations are deleted.

The target type for logical expressions is always \TT{bool}.

Logical expressions are evaluated from left to right and
if the value of the entire expression is discovered before all
the subexpressions are evaluated, evaluation of later subexpressions is
skipped, as per \itemref{EVALUATION-ORDER}.

\subsubsection{Comparison Expressions}
\label{COMPARISON-EXPRESSIONS}

The target type for comparison expressions is always \TT{bool}.

There is no given target type for operands of comparison operators.
So the target type of these must be specified by rules.

For numeric operands of comparison operators
the target type is the first type
in the following sequence that is such that all operands
can be implicitly converted to that type:
\begin{center}
\TT{unswrd} ~ \TT{intwrd} ~ \TT{unsmax} ~ \TT{intmax}
           ~ \TT{floatwrd} ~ \TT{floatmax}
\end{center}

An example assuming:


\begin{indpar}\begin{verbatim}
unswrd ---> `uns32'
intwrd ---> `int32'
floatwrd ---> `float32'
unsmax ---> `uns64'
intmax ---> `int64'
floatmax ---> `float32'
\end{verbatim}\end{indpar}

is:

\begin{indpar}\begin{verbatim}
int64 x = 9,568
uns64 y1 = 0xFF00
uns32 y2 = 0xFF00
bool z1 = x < y1
    // Compile error:
    //     x and y1 cannot be implicitly converted
    //     to the same target type
bool z1 = x < y2
    // OK, x and y2 are implicitly convertible to
    // intmax (int64)
\end{verbatim}\end{indpar}

Non-numeric comparison operators require that one or more of
the operands have a natural type (\pagref{NATURAL-TYPE}),
and use as the target type
the least upper bound (\pagref{LEAST-UPPER-BOUND})
of all these natural types.
It is a compile error if this least upper bound does
not exist, or if it is \TT{bool} and no operand natural type was \TT{bool}.
For example, given the expression `{\tt v == missing}', where \TT{v}
is of `\TT{qualifier}' type, {\tt missing}, which has no natural type, will be
evaluated with `\TT{qualifier}' target type.

Comparison expressions are evaluated from left to right and are
true if and only if all the comparisons are true.  Middle
arguments are shared between two comparison operators.
An example is:

\begin{indpar}\begin{verbatim}
int64 x = 9,568
uns16 y1 = 0xFF00
uns32 y2 = 0xFF01
bool z1 = x < y1 < y2
    // x, y1, y2 are all converted to int64.
    // y2 is only converted if x < y1 is true.
bool z2 = x < y1 and y1 < y2
    // y1 is converted to int64 to compare it with x
    // and then if x < y1 is true, y1 is separately
    // converted to uns32 to compare it with y2.
\end{verbatim}\end{indpar}

As per \itemref{EVALUATION-ORDER}, if a comparison evaluates
to \TT{false}, operands following those of the comparison
are not evaluated.

Note that a comparison operator may not have a negation that is
also simply a comparison operator, e.g., \TT{>=} may not be the
negation of \TT{<}.  For example, both return \TT{false} if an
operand is \TT{NaN}.  For this reason `{\tt x >= y}' and
`{\tt not ( x < y )}' are treated as semantically different
expressions.

\subsubsection{Integer Arithmetic Expressions}

If an integer arithmetic operator is being evaluated with
operand and target type \TT{uns$x$} or \TT{int$x$}, the
exact arithmetic results is computed and truncated to
$x$ bits, i.e., is taken modulo $2^x$ before being presented
as the result.

An exception to this is made for integer division operations.
If the divisor is zero, the results are undefined.  If the
target type is \TT{int$x$}, the dividend is $-2^{x-1}$, and
the divisor is $-1$, the result is undefined.  In both these
cases the result may be a program terminating error.

The bitwise operators are:
\begin{center}
\begin{tabular}{ll}
\TT{\&}		& bitwise AND \\
\TT{|}		& bitwise OR \\
\TT{xor}	& bitwise EXCLUSIVE OR \\
\TT{!}		& bitwise complement \\
\TT{<{}<}	& bitwise shift left \\
\TT{>{}>}	& bitwise shift right \\
\end{tabular}
\end{center}

In `{\tt v >{}> s}' and `{\tt v <{}< s}', {\tt v} is converted to the
target type which may be any integer type $T$, but {\tt s} is converted
to \TT{unswrd} and only its low order $x$ bits are used as the
shift amount, where $x$ is the size of $T$.
In other words, the shift amount is {\tt s mod 2$^x$}.

The integer division operators are:
\begin{center}
\begin{tabular}{ll}
\TT{div}	& quotient rounded towards zero \\
\TT{mod}	& modulo; remainder when quotient is rounded
                  toward negative infinity \\
\TT{rem}	& remainder when quotient is rounded toward zero \\
\end{tabular}
\end{center}

The operator \TT{/} is strictly floating point.  The operator
\TT{\textasciicircum} is \underline{not} builtin and must be
defined by library code.

\subsubsection{Floating Point Arithmetic Expressions}
\label{FLOATING-POINT-ARITHMETIC-EXPRESSIONS}

There is a `\key{floating point error register}' that holds
floating point error flags that may be set by floating point
arithmetic and comparison operations.  These flags are `\key{sticky}', in that
arithmetic and comparison
operations may set them but may never clear them.  There are also
special builtin functions to manipulate these flags
(\itemref{FLOATING-POINT-ERROR-FLAG-FUNCTIONS}).

The flags with the operation results when the flags are set are:
\begin{indpar}
\mkey{Invalid Operand}{floating point error flag}
\begin{indpar}
Set upon one of the following:
\begin{center}
\begin{tabular}{l}
Compare operand is a \TT{NaN}. \\
Adding \TT{+Inf} and \TT{-Inf}. \\
Subtracting \TT{+Inf} from \TT{+Inf}. \\
Subtracting \TT{-Inf} from \TT{-Inf}. \\
Multiplying \TT{0} by \TT{+Inf} or \TT{-Inf}. \\
Dividing \TT{+Inf} or \TT{-Inf} by \TT{+Inf} or \TT{-Inf}. \\
Dividing \TT{0} by \TT{0}. \\
\end{tabular}
\end{center}

Except for compares, the result is \TT{NaN}.
For compares, the result is \TT{false}.
\end{indpar}

\mkey{Divide By Zero}{floating point error flag}
\begin{indpar}
Set by a floating point division with a \TT{+0} or
\TT{-0} divisor and a non-zero dividend.

The result is \TT{+Inf} if both operands have the
same sign and \TT{-Inf} if they have opposite signs.
\end{indpar}

\mkey{Result Overflow}{floating point error flag}
\begin{indpar}
Set if result has magnitude too large to store in a target type value.

If the result is positive, \TT{+Inf} is stored, and if negative,
\TT{-Inf} is stored.
\end{indpar}

\mkey{Result Underflow}{floating point error flag}
\begin{indpar}
Set if the result is too small to be stored, even as a denormalized
number, in a target type value.

The result is stored as \TT{+0} if it is positive and as
\TT{-0} if it is negative.
\end{indpar}

\mkey{Result Inexact}{floating point error flag}
\begin{indpar}
Set if result cannot be exactly stored in a target type value.
This happens frequently and is not normally considered a
real error.

The result is rounded to the nearest value, with ties to even.
\end{indpar}
\end{indpar}

Except for compares, \TT{NaN} operands cause \TT{NaN} results and
do \underline{not} set the invalid operand flag.

Results may be denormalized numbers.  Except for compares,
when an operand to an arithmetic operation is a denormalized
number, it is treated as a signed zero.

The operator
\TT{\textasciicircum} is \underline{not} builtin and must be
defined by library code.

\subsection{Operator Semantics}

The following evaluation rules are applied in the order given.

For example, `{\tt not ( x > y and z )}' is evaluated by applying
the rule that rewrites it to `{\tt not x > y or not z}' instead of
the rules that evaluated `{\tt x > y and z}' first and then complement
the result.

Parentheses are inserted by the parser to separate operators of
differing precedence before these rules are applied.

Comparison operators, and the
arithmetic operators, summation, product, and bitwise, 
may be overloaded by functions that apply them to non-numeric
types other than \TT{bool}.
If $T$ is such a type, these functions must have prototypes
of the forms
\begin{indpar}
{\tt function bool r = ( $T$ $v1$ ) "$op$" ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of \TT{<}, \TT{<=}, \TT{==}, \TT{!=}, \TT{>=}, or \TT{>}
\end{indpar}

{\tt function $T$ r = ( $T$ $v1$ ) "$op$" ( unswrd $v2$ )}
\begin{indpar}
where $op$ is one of \TT{<{}<} or \TT{>{}>}
\end{indpar}

{\tt function $T$ r = "$op$" ( $T$ $v1$ )}
\begin{indpar}
where $op$ is one of \TT{-} or \TT{!}
\end{indpar}

{\tt function $T$ r = ( $T$ $v1$ ) "$op$" ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of
    \TT{+}, \TT{-}, \TT{\&}, \TT{|}, \TT{xor},
    \TT{*}, \TT{/}, \TT{div}, \TT{mod}, \TT{rem}, \TT{\textasciicircum}
\end{indpar}
\end{indpar}


The selection operator (\TT{if/else}) and the logical
operators (\TT{not}, \TT{and}, \TT{or}) may \underline{not}
be overloaded.

\medskip

\TT{$e1$ if $b1$ else $e2$ if $b2$ \ldots{} else $e$}
\hfill [{\em selection-expression}]
\begin{indpar}
$b1$ is evaluated first.  If it is \TT{true}, $e1$ is evaluated and its
value is returned.  If it is \TT{false}, $e1$ is \underline{not}
evaluated, and instead $b2$ is evaluated.  If that is \TT{true}
$e2$ is evaluated and its value is returned.  But if $b2$ is \TT{false}
evaluation of the {\em selection-expression} continues.  If none of
the $bI$ evaluate to \TT{true}, $e$ is evaluated and returned as the result.

The target type of each $bI$ is \TT{bool} and the target type of each
$eI$ is the target type of the {\em selection-expression}.
Only one of the $eI$ is evaluated.

If any $bI$ is a compile time
\TT{false} value, the associated $eI$ is not compiled or checked
for compile errors.
If any $bI$ is a compile time
\TT{true} value, the subsequent $bJ$'s and their associated $eJ$'s
are not compiled or checked
for compile errors.
\end{indpar}

\TT{not ( $b1$ and $b2$ and \ldots{} )}
\hfill [{\em logical-expression}]
\begin{indpar}
The expression is replaced by
\TT{( ( not $b1$ ) or ( not $b2$ ) or \ldots{} )}.
\end{indpar}

\TT{not ( $b1$ or $b2$ or \ldots{} )}
\hfill [{\em logical-expression}]
\begin{indpar}
The expression is replaced by
\TT{( ( not $b1$ ) and ( not $b2$ ) and \ldots{} )}.
\end{indpar}

\TT{not ( not $b1$ )}
\hfill [{\em logical-expression}]
\begin{indpar}
The expression is replaced by $b1$.
\end{indpar}

\TT{$b1$ and $b2$ and \ldots{}}
\hfill [{\em logical-expression}]
\begin{indpar}
The $bI$ are evaluated left to right until one evaluates to
\TT{false} or none do.  If one evaluates to \TT{false},
\TT{false} is returned as the value of the {\em logical-expression}
and the remaining $bI$ are not evaluated.
Otherwise \TT{true} is returned.

The target type of all the $bI$ is \TT{bool}.  If any $bI$ is a
compile time \TT{false} value, the remaining $bI$ are not compiled
or checked for compile errors.
\end{indpar}

\TT{$b1$ or $b2$ or \ldots{}}
\hfill [{\em logical-expression}]
\begin{indpar}
The $bI$ are evaluated left to right until one evaluates to
\TT{true} or none do.  If one evaluates to \TT{true},
\TT{true} is returned as the value of the {\em logical-expression}
and the remaining $bI$ are not evaluated.
Otherwise \TT{false} is returned.

The target type of all the $bI$ is \TT{bool}.  If any $bI$ is a
compile time \TT{true} value, the remaining $bI$ are not compiled
or checked for compile errors.
\end{indpar}

\TT{not ( $e1$ $cop1$ $e2$ $cop2$ $e3$ \ldots{} )}
\hfill [{\em logical-expression}]
\begin{indpar}
where the $copI$ are comparison operators chosen from the list
\TT{==}, \TT{!=}, \TT{>}. \TT{>=}, \TT{<}, or \TT{<=}.

First $e1$ and $e2$ are evaluated.  Then the function
call `{\tt $e1$ "$cop1$" $e2$}'
is evaluated, and if it is \TT{false},
\TT{true} is returned as the value of the {\em logical-expression}.
Otherwise $e3$ and the function call `{\tt $e2$ "$cop2$" $e3$}'
are evaluated, and if the latter
evaluated to \TT{false},
\TT{true} is returned as the value of the {\em logical-expression}.
This continues until a comparison evaluates to \TT{false} or all
evaluate to \TT{true}.  In the latter case, \TT{false} is returned as
the value of the {\em logical-expression}.

No $eI$ is evaluated more than once, though the value of some $eI$
may be used more than once.

The target type $T$ of the expressions $eI$ is selected as
per \itemref{COMPARISON-EXPRESSIONS}.  The target type of the
function calls `{\tt $eI$ "$copI$" $e(I+1)$}' is \TT{bool}.
Builtin comparison operators are defined for all implemented
numeric types.

If $eI$, $e(I+1)$, and `{\tt $eI$ "$copI$" $e(I+1)$}' can be evaluated
at compile time and evaluate to \TT{false}, subsequent
$eJ$ are not compiled or checked for compile errors.
\end{indpar}

\TT{not $b$}
\hfill [{\em logical-expression}]
\begin{indpar}
$b$ is evaluated.  If it returns \TT{true}, \TT{false} is
returned as the value of the {\em logical-expression}.
Otherwise \TT{true} is returned.

The target type of the $b$ is \TT{bool}.
\end{indpar}

\TT{$e1$ $cop1$ $e2$ $cop2$ $e3$ \ldots{}}
\hfill [{\em comparison-expression}]
\begin{indpar}
where the $copI$ are comparison operators chosen from the list
\TT{==}, \TT{!=}, \TT{>}. \TT{>=}, \TT{<}, or \TT{<=}.

First $e1$ and $e2$ are evaluated.  Then the function call
`{\tt $e1$ "$cop1$" $e2$}'
is evaluated, and if it is \TT{false},
\TT{false} is returned as the value of the {\em comparison-expression}.
Otherwise $e3$ and the function call `{\tt $e2$ "$cop2$" $e3$}'
are evaluated, and if the latter
evaluated to \TT{false},
\TT{false} is returned as the value of the {\em comparison-expression}.
This continues until a comparison evaluates to \TT{false} or all
evaluate to \TT{true}.  In the latter case, \TT{true} is returned as
the value of the {\em comparison-expression}.

No $eI$ is evaluated more than once, though the value of some $eI$
may be used more than once.

The target type $T$ of the expressions $eI$ is selected as
per \itemref{COMPARISON-EXPRESSIONS}.  The target type of the
function calls `{\tt $eI$ "$copI$" $e(I+1)$}' is \TT{bool}.
Builtin comparison operators are defined for all implemented
numeric types.

If $eI$, $e(I+1)$, and `{\tt $eI$ "$copI$" $e(I+1)$}' can be evaluated
at compile time and evaluate to \TT{false}, subsequent
$eJ$ are not compiled or checked for compile errors.
\end{indpar}

\TT{! $e1$}
\hfill [{\em bitop-expression}] \\
\TT{$e1$ $bop$ $e2$ $bop$ $e3$ \ldots{}}
\hfill [{\em bitop-expression}]
\begin{indpar}
where the $bop$ is a bitop operator chosen from the list
\TT{\&}, \TT{|}, \TT{xor}

The $eI$ are evaluated left to right.
Each function call
`{\tt "!" $e1$}' or
`{\tt $eI$ "$bop$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators (other than \TT{!}) are
also evaluated left to right.

The target type $T$ of the $eI$ is the target type of the
{\em bitop-expression}.  Builtin bitop operators are defined
for all implemented integer numeric types.
\end{indpar}

\TT{$e1$ $shop1$ $e2$ $shop2$ $e3$ \ldots{}}
\hfill [{\em bitop-expression}]
\begin{indpar}
where the $shopI$ are bitop operators chosen from the list
\TT{<{}<}, \TT{>{}>}.

Each function call
`{\tt $eI$ "$shopI$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators are
also evaluated left to right.

The target type $T$ of $e1$ is the target type of the
{\em bitop-expression}.
The target type of $e2$, $e3$, \ldots{} is \TT{unswrd}.
Builtin bitop operators are defined
for all implemented integer numeric types $T$.
If $T$ is an integer type of size $x$,
the value of the shift for $shopI$
is $e(I+1)$ is taken modulo $2^x$.
\end{indpar}

\TT{$sop1$\QMARK{} $e1$ $sop2$ $e2$ $sop3$ $e3$ \ldots{}}
\hfill [{\em summation-expression}]
\begin{indpar}
where $sopI$ are summation operators chosen from the list
\TT{+} or \TT{-}.

The $eI$ are evaluated left to right.
Each function call
`{\tt "$sop1$" $e1$}' or
`{\tt $eI$ "$sop(I+1)$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators are
also evaluated left to right.

The target type of the $eI$ is the target type of the
{\em summation-expression}.
Builtin summation operators are defined
for all implemented numeric types $T$.
\end{indpar}

\TT{$e1$ * $e2$ * $e3$ \ldots{}}
\hfill [{\em product-expression}] \\
\TT{$e1$ $dop$ $e2$}
\hfill [{\em product-expression}]
\begin{indpar}
where the $dop$ is a divide operator chosen from the list
\TT{/}, \TT{div}, \TT{mod}, \TT{rem}.

The $eI$ are evaluated left to right.
Each function call
`{\tt "$eI$ "*" $e)I+1)$}' or
`{\tt $eI$ "$dop(I+1)$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators are
also evaluated left to right.

The target type $T$ of the $eI$ is the target type of the
{\em product-expression}.
Builtin \TT{"*"} and \TT{mod} operators are defined
for all implemented numeric types $T$.
Builtin \TT{div} and \TT{rem} operators are defined
for all implemented integer numeric types $T$ with size
at least 32 bits.
Builtin \TT{"/"} operators are defined
for all implemented floating point numeric types $T$.

\end{indpar}

\TT{$e1$ \textasciicircum{} $e2$}
\hfill [{\em exponential-expression}]
\begin{indpar}
The $eI$ are evaluated left to right.
The the function call
`{\tt $eI$ "\textasciicircum" $e(I+1)$}' is evaluated
as soon as its operands have
been evaluated.

The target type $T$ of the $eI$ is the target type of the
{\em exponential-expression}.  \underline{No} builtin
\TT{"\textasciicircum"} operators are defined.


\end{indpar}

\TT{$ma$ ( $e1$ $op1$ $e2$ $op2$ \ldots{} )}
\hfill [{\em subexpression}]
\label{MODULE-ABBREVIATION-SEMANTICS}
\begin{indpar}
where $ma$ is a {\em module-abbreviation}.

$ma$ is prefixed to the unparenthesized
operators whenever they are used according to the above
rules.  This is done by the parser, and not the compiler.

For example,
\begin{center}
\begin{tabular}{c}
{\tt $ma$ ( x + ( y1 + y2 ) + ( z1 * z2 ) )} \\
becomes \\
{\tt $ma$ x + ( y1 + y2 ) ) + ( z1 * z2 )}
\end{tabular}
\end{center}

Since the parser places parentheses implicitly, in `\TT{$ma$($e$)}'
only the lowest precedence operators in $e$ are affected.
Thus the pre-parser expression
\begin{center}
{\tt $ma$ ( x + ( y1 + y2 ) + z1 * z2 )} \\
\end{center}
is equivalent to the above example.

\end{indpar}

\TT{$Qs$ $T$ ( $e$ )}
\hfill [{\em subexpression}]
\begin{indpar}
where $Qs$ are zero or more {\em qualifier-names} and $T$ is a {\em type-name}.

If the {\em subexpression} can be compiled as a call to a
user defined function named $T$, it is evaluated as such with
target type `$Qs$ $T$'.

Otherwise $e$ is evaluated with target type `$Qs$ $T$'
and the result is implcitly
converted to the target type of the {\em subexpression}.
\end{indpar}

\section{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

Variables are allocated to the current function frame
and are also given their values by assignment statements.
After the assignment statement allocating a variable,
the value of the variable cannot be changed.  However,
a new variable of the same name can be allocated via
the `\TT{next}' construction which we describe below.

Assignment statements have the syntax:
\begin{indpar}
\emkey{assignment-statement}
    ::= \{ {\em result-variable-list} \TT{=} \}\QMARK{}
    		{\em assignment-right-side}
\\[0.5ex]
\emkey{result-variable-list}\label{RESULT-VARIABLE-LIST}
    ::= {\em result-variable}
	  \{ \TT{,} {\em result-variable} \}\STAR{}
\\[0.5ex]
\emkey{result-variable}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em result-variable-declaration} \\
    $|$ & {\em next-variable-declaration} \\
    $|$ & {\em deferred-result-variable}
    		& [see \pagref{DEFERRED-RESULT-VARIABLE}] \\
    $|$ & {\em iteration-result-variable}
    		& [see \pagref{ITERATION-RESULT-VARIABLE}] \\
    \end{tabular}
\\[0.5ex]
\emkey{result-variable-declaration}\label{RESULT-VARIABLE-DECLARATION}
    ::= {\em qualifier-name}\STAR{}~{\em type-name}~{\em variable-name}
\\[0.5ex]
\emkey{next-variable-declaration}
    ::= \ttkey{next}~{\em variable-name}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{assignment-right-side}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em expression-list}
    		& [see \pagref{EXPRESSION-LIST}] \\
    $|$ & {\em function-call}
    		& [see \pagref{FUNCTION-CALL}] \\
    $|$ & {\em block}
	        & [see kinds of assignment statement below] \\
    \end{tabular}
\end{indpar}

where the {\em assignment-right-side}
depends on the kind of assignment statement.
The kinds of assignment statements are:
\begin{indpar}
\emkey{assignment-statement}
    \begin{tabular}[t]{rll}
    ::= & {\em simple-assignment-statement}
	& \itemref{SIMPLE-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em block-assignment-statement}
	& \itemref{BLOCK-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em conditional-assignment-statement}
	& \itemref{CONDITIONAL-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em loop-assignment-statement}
	& \itemref{LOOP-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em call-assignment-statement}
	& \itemref{CALL-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em out-of-line-assignment-statement}
	& \itemref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em compile-and-run-assignment-statement}
	& \itemref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em compile-time-assignment-statement}
	& \itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em assembly-assignment-statement}
	& \itemref{ASSEMBLY-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em function-call}
	& \itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES} \\
    \end{tabular}
\end{indpar}

If an {\em assignment-statement} has {\em result-variable-declarations}
that give {\em variable-names} with types and qualifiers,
these result variables are allocated to the current function frame, and
values produced by evaluating the {\em assign\-ment-right-side} are stored in
these variables.
The {\em assignment-right-side} produces a list of values,
and this list must have
at least as many elements as there are result variables.
If the {\em assignment-right-side} is a list of {\em expressions},
and not a {\em subblock},
the result variables are assigned their values in parallel, after the
{\em assignment-right-side} has been completely evaluated.
If the {\em assignment-right-side} is a {\em function-call} that produces
too many values, the excess values are discarded.  Otherwise there must
be exactly as many values as there are result variables.

When a variable value is set, the value is implicitly first
computed in a register, then stored in the current function
frame, and for some time
afterwards the value is left in the register which becomes a cache
on the frame value.  This cacheing is hidden from the programmer.

If a variable value is copied from another variable, usually the
new variable simply becomes a compile-time alias for the old variable.
No executable copy code is created, no new register is allocated, and no new
value is pushed into the stack.

Similarly if a variable value can be easily computed from previous variable
values by in-line code, 
its value may not be stored into the function frame.  Instead its
value can be recovered at any time by repeating the computation
of the variable from the other values.

The value assigned to each result variable must be implicitly convertible to
the variable's type.  In some cases the type of a result variable is
the target type of an {\em expression} in a {\em assignment-right-side}
that is an {\em expression-list}
(\itemref{SIMPLE-ASSIGNMENT-STATEMENTS}).
In some cases the result variable type is matched to
the type of a {\em function-prototype} result variable
for a {\em function-call} that is the {\em assignment-right-side}
(\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}).

A list of {\em assignment-statement}
result variables acts as a declaration of these variables,
and the scope of this declaration includes any {\em subblock} that may
consitute the {\em assignment-right-side}.
Result variables are not allowed to hide (\pagref{HIDE})
other {\em name} declarations with exceptions listed on
\pagref{HIDING-EXCEPTIONS}.

However, if an assignment statement has a {\em next-variable-declaration}
that uses the word `\ttkey{next}'\label{NEXT} in
place of the {\em qualifier-names} and {\em type-name}
of a result variable being assigned a value, then the named variable must
have been previously assigned a value within the same smallest containing block,
a new variable with the same qualifiers, type, and name
as the previous variable is allocated,
and the new variable supersedes the previous variable
in subsequent code within the block.  Thus if {\tt v} is the name
of a variable declared in a block, then after `{\tt next v}' is
assigned, {\tt v} refers to the value assigned to `{\tt next v}'.

See the example in \itemref{SIMPLE-ASSIGNMENT-STATEMENTS}, and
the more detailed discussion in 
\itemref{BLOCK-ASSIGNMENT-STATEMENTS}.

Note that `\TT{next}' behaves differently when it used as part of
the name of
a {\em deferred-result-variable} (\pagref{DEFERRED-RESULT-VARIABLE})
or an {\em iteration-result-variable} (\pagref{ITERATION-RESULT-VARIABLE}).

The {\em result-variables} may be completely omitted if the
{\em assignment-right-side} is a {\em subblock} or is a
{\em function-call} matching a {\em function-prototype} that has
no result variables (\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}).
Because such statements still have
the form and semantics of statements that could have result variables,
we call them `{\em assignment-statements}' even though they allocate
and assign no result variables.

Also there are statements with the form:
\begin{center}
{\em function-call} ~ \TT{=} ~ {\em expression-list}
\end{center}
which are syntactic sugar for a {\em function-call}
in which the {\em expression-list} has been made into a function argument
list and there are no result variables.
{\em Function-calls} \underline{cannot} be used as result variables.
See \itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}.

\subsection{Simple Assignment Statements}
\label{SIMPLE-ASSIGNMENT-STATEMENTS}

The simplest \skey{assignment statement}s have the syntax:

\begin{indpar}
\emkey{simple-assignment-statement}
    ::= {\em result-variable-list} \TT{=} {\em expression-list}
\\[0.5ex]
\emkey{expression-list}\label{EXPRESSION-LIST}
    ::= {\em expression} \{ \TT{,} {\em expression} \}\STAR{}
\end{indpar}

If there is more than one {\em expression} in the {\em expression-list},
or if there is a single {\em expression} that is \underline{not}
a {\em function-call},
then each {\em expression} produces a single value, and the list of these
values is the list of values assigned to the list of result variables.
The {\em expressions} are evaluated in left to
right order, and all the {\em expressions} are evaluated before any of
the result variables are given values.
In this case there must be the same number of {\em expressions}
in the {\em expression-list} as their are result variables.

If the {\em expression-list} is a single {\em expression} that
is a {\em function-call} which
returns a list of values, this list of values is used.
In this case the {\em function-call} may produce more values than
there are result variables, and the excess values are discarded,
as long as there is at least one result variable.
if there are no result variables, the
{\em function-call} must match a {\em function-prototype} that has
no result variables (\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}).

An {\em expression} may only input values that are constants,
the values of variables in the same function execution
frame (including arguments passed to the function execution), 
or the values of global variables.  In particular,
no input can come \underline{directly}
from RAM memory outside the current function execution frame or
global memory,
but see \pagref{MEM} and Section~\itemref{THE-MEM-QUALIFIER}
for ways to load RAM values into function frame variables.
See Section~\itemref{STACK-MANAGEMENT} for more information about
function frames.

The value assigned to each result variable must be implicitly convertible to
the variable's type.
In the case that an {\em expression} is producing
only a single value, the type of its associated result variable is the target
type of the {\em expression}.  If there is only one {\em expression}
and that is a {\em function-call}, the types the result variables
are matched to the types of the {\em function-prototype} result
variables (\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}).

Some examples of {\em simple-assignment-statements} are:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = x + 1         // y == 2
next x = 10 * x         // Now x == 10
next y = x + y          // Now y == 12
int32 z = 256 + y       // z == 268
int8 u = z              // ILLEGAL!  Undefined implicit
                        // conversion from int32 to int8.
int8 v = mod ( z )      // Now v == 12
int8 w = v + 257        // ILLEGAL!  Constant out of range
                        // of target type int8.
float32 m = 1.7
int64 i = m             // ILLEGAL!  Undefined implicit
                        // conversion from float32 to int64.
int32 j = nearest ( m ) // now j == 2 (round to nearest)
int32 y = x + y         // ILLEGAL! y hides y.
\end{verbatim}\end{indpar}

\subsection{Block Assignment Statements}
\label{BLOCK-ASSIGNMENT-STATEMENTS}

Another variant of the assignment statement is\index{block assignment}:

\begin{indpar}
\emkey{block-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \\
	\TT{~~~~}\{ \ttkey{do} {\em block-name}\QMARK{}
	              \{ \TT{(} {\em context-expression} \TT{)} \}\QMARK{}
	              \}\QMARK{} \TT{:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{}
	\end{tabular}
\\
\emkey{block-name} ::=
    \begin{tabular}[t]{l}
    {\em name} ~~~~~ [see \pagref{NAME}] \\
    \underline{not} containing
	`\TT{.}',~ {\em quoted-marks},~ or {\em quoted-separators} \\
    \end{tabular}
\end{indpar}

where `\TT{do} {\em block-name}\QMARK{}
	              \{ \TT{(} {\em context-expression} \TT{)} \}\QMARK{}'
may be omitted as long as \TT{=} is not omitted.

The {\em statements} within the {\em block-assignment-statement}
comprise a `\key{block}' of code.

Unless `\TT{(} {\em context-expression} \TT{)}' is given,
a {\em block-assignment-statement} is
compiled in the current context (\pagref{CONTEXT}),
and {\em names} declared within the block are \underline{not} permitted
to hide (\pagref{HIDE}) {\em names} declared before the block.
But if `\TT{(} {\em context-expression} \TT{)}' is given,
the {\em block-assignment-statement} is
compiled in the context given by {\em context-expression},
and names declared within the block
are permitted to hide names in the specified context.

Any result variables in a {\em block-assignment-statement}
are called `\skey{deferred variable}s' because they do not
immediately get a value.  They are assigned values by
{\em assignment-statements} within the block
whose {\em result-variable-lists}
include {\em deferred-result-variables}:
\begin{indpar}
\emkey{deferred-result-variable}\label{DEFERRED-RESULT-VARIABLE} ::=
    {\em variable-name} $|$ \TT{next} ~ {\em variable-name}
\end{indpar}
{\em Assignment-statements} that set {\em deferred-result-variables}
are called `\skey{deferred assignment}s'.

No {\em qualifier-name} or {\em type-name} may be a prefix of
a {\em variable-name} used as a
{\em deferred-result-variable}.
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.

Variables declared in the block may not hide (\pagref{HIDE})
variables declared outside the block, including the result
variables of the block, with exceptions listed on
\pagref{HIDING-EXCEPTIONS}.

The code must be such that every deferred variable is given a value
by at most one deferred assignment, and if not a `\TT{next}' variable,
is given a value by a deferred assignment before the variable is read.
If a deferred variable is of the form `{\tt next v}', then {\tt v}
may be used in the block to refer to the variable value assigned
outside and before the {\em block-assignment-statement}, up to
the point where `{\tt next v}' is assigned a value in the block.
After that point {\tt v} refers to the value assigned to `{\tt next v}'.

An example of a {\em block-assignment-statement} is:
\begin{indpar}\begin{verbatim}
int32 x = 1
float64 y = 1.67
int64 z, uns8 w, next x =:

    z = 16,777,216   // Legal, z is result variable
    x = 265          // ILLEGAL, x is NOT result variable
    float64 y = 2.6  // ILLEGAL, y is visible outside block
    uns8 v = 55      // Legal, v is NOT visible outside block
    next x = 265 + x // Legal, next x is result variable,
                     //        now x == 266
    next y = 2.6     // ILLEGAL, y is visible outside block
                     //          and next y is not result
                     //          variable
    w = mod ( x )    // Legal, sets w to 10 as x is now 266
\end{verbatim}\end{indpar}

An exit statement may be used to jump from within a block to
the end of the block:

\begin{indpar}
\emkey{exit-statement} ::=
        \ttkey{exit} ~ {\em block-name}\QMARK{} ~
	    \{ \TT{if} ~ {\em condition-expression} \}\QMARK{}
\end{indpar}

If the {\em block-name} is not given, the smallest block containing
the {\em exit-statement} is exited.

The block exit may be conditional.  The compiler checks that
if non-conditional exits are taken and conditional
exits are either taken or not, each one of the block's
deferred variables is given a value by a single deferred assignment statement.
However, if a {\em block-name} is given and the exit statement is in
a subblock of the named block,
the deferred variables of this subblock
need not be given values.

Examples of {\em exit-statements} are:

\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
bool v = do BLOCK1:
    // sets v = ( x <= 10 or y >= 10 )
    //
    do BLOCK2:
        exit BLOCK2 if ( x > 10 )
        v = true
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3 if ( y < 10 )
        v = true
        exit BLOCK1
    v = false

next v = do BLOCK1:
    // attempts to set next v = ( x <= 20 or y >= 20 )
    next v = true
    exit BLOCK1 if x <= 20
    exit BLOCK1 if y >= 20
    next v = false          // ILLEGAL: next v set twice
\end{verbatim}\end{indpar}

L-Language parses all code, but does not compile statements that
cannot be reached from the beginning of the current top level
statement (e.g., out-of-line function declaration).  Because
of unconditional \TT{exit} statements, or \TT{exit} statements
whose conditions evaluate to \TT{true} at compile time,
some statements will be unreachable and will not be compiled.
Unreachable statements are not checked for non-parsing compile
errors.

For example, the code
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
int32 z = do BLOCK1:
    do BLOCK2:
        exit BLOCK2 if ( x > 10 )
        z = 55
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3 if ( y < 10 )
        z = "hot dog"    // Illegal conversion
        exit BLOCK1
    z = "cold dog"       // Illegal conversion
\end{verbatim}\end{indpar}

becomes after eliminating unreachable statements:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
int32 z = do BLOCK1:
    do BLOCK2:
        exit BLOCK2 if false
        z = 55
        exit BLOCK1
\end{verbatim}\end{indpar}

and therefore has no compiler errors.


\subsection{Conditional Assignment Statements}
\label{CONDITIONAL-ASSIGNMENT-STATEMENTS}

\ikey{Conditional assignment statements}{conditional assignment}
are syntactic sugar for block assignment statements
with exits (\pagref{BLOCK-ASSIGNMENT-STATEMENTS}).
Conditional assignment statements have the syntax:

\begin{indpar}
\emkey{conditional-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \ttkey{if}\TT{:} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	\TT{~~~~}\ttkey{else}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

In this case the {\em condition-expressions} are evaluated in order
until either one evaluates to true or the `\TT{else}' condition is
reached, and then the {\em statements} subject to the
first true condition (a.k.a the \key{subblock} of that condition)
are executed, or if no condition is true, the {\em statements}
of the `\TT{else}' subblock are executed.

Every variable in the {\em result-variable-list} \underline{must} be set by the
single subblock that executes, unless that subblock exits a block
that contains the {\em conditional-assignment-statement}.  A variable in the
{\em result-variable-list} cannot be read by a subblock {\em statement}
unless it is set by a previous {\em statement} in the
same subblock.

An example is:
\begin{indpar}\begin{verbatim}
function float64 result =
        max ( float64 x, float64 y, float64 z ):
    result = if:
        y <= x => z:
            result = x
        z <= y => x:
            result = y
        y <= z => x:
            result = z
        else:
            result = NaN
\end{verbatim}\end{indpar}

where \TT{NaN} means `\key{not-a-number}' and is the missing
value for \TT{float64} variables.  {\tt x~=>~y} is true if
and only if neither {\tt x} nor {\tt y} is a \TT{NaN} and
{\tt x} is equal to or greater than {\tt y}.  Thus if any of
{\tt x}, {\tt y}, or {\tt z} in the above conditional assignment
is a \TT{NaN}, none of the {\em conditional-expressions}
will be \TT{true}, and the \TT{else} subblock will be evaluated to set
the {\tt result} to a \TT{NaN}.

There are two special rules that apply to
{\em conditional-assignment-statements}:\label{CONDITIONAL-SPECIAL-RULES}

\begin{itemize}
\item
If some of the {\em conditional-expressions} can be computed at compile
time, subblocks that the compiler determines cannot execute are not
compiled or checked for compiler errors (but the subblocks are parsed
and checked for parsing errors).

Specifically, if a {\em conditional-expression} evaluates to \TT{true}
at compile time, subblocks beyond the subblock
of this {\em conditional-expression}
are not compiled.  And if a remaining {\em conditional-expression}
evaluates to \TT{false} at compile time, the subblock of this
{\em conditional-expression} is not compiled.
\end{itemize}

For example, if a {\em conditional-assignment-statement}
contained
\begin{indpar}\begin{verbatim}
    if x >= 1,000,000:
        result = NaN
\end{verbatim}\end{indpar}
where {\tt x} is a variable with value known at compile time
that is less than {\tt 1,000,000}, then
`{\tt result = NaN}' will not compile
and will not be checked for compile time errors.


A second special rule is:

\begin{itemize}
\item\label{MISSING-ELSE-RULE}
Missing `\TT{else}'s do not cause compile errors,
but will cause run time errors if needed at run time.
\end{itemize}

For example, the {\em conditional-assignment-statement}:
\begin{indpar}\begin{verbatim}
    result = if:
        x <= y:
            result = x
        y <= x:
            result = y
\end{verbatim}\end{indpar}
will suffer a run-time error if either {\tt x} or {\tt y} is
a floating point \TT{NaN} at run-time.

\subsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

\ikey{Loop assignment statements}{loop assignment}
are similar to block assignment
and conditional assignment statements.  An example is:
\begin{indpar}\begin{verbatim}
// Calculate the sum of i for i == 1 to i == n.
//
int64 n = . . .
int64 sum = loop:
    initially:
        int64 i = 1
        int64 partial sum = 0
    while i <= n:
        next partial sum = partial sum + i
        next i = i + 1
    finally:
        sum = partial sum
\end{verbatim}\end{indpar}



The general syntax of loop assignment statements is:

\begin{indpar}
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	          \ttkey{loop:} \\
	\TT{~~~~}\ttkey{initially}\TT{:} \\
	\TT{~~~~~~~~~}{\em assignment-statement}\STAR{} \\
	\TT{~~~~}\{ \ttkey{while} $|$ \ttkey{until} \}
	         {\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ttkey{finally}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

This is somewhat like the conditional assignment statement
except the `\TT{while}' or `\TT{until}'
subblock is iterated and there are iteration
variables defined by the `\TT{initially}' subblock.

The `\TT{initially}' subblock is call the `\key{initialization subblock}',
the `\TT{while/until}' subblock is call the `\key{iteration subblock}',
and the `\TT{finally}' subblock is call the `\key{finalization subblock}'.

The \skey{iteration variable}s are the
{\em result-variables} of the
{\em assignment-statements} executed by the initialization subblock.
Each iteration of the loop gives these variables new values using
`{\tt next v}' to refer to the value of {\tt v} in the next iteration,
where {\tt v} is an iteration variable.  In the example `{\tt i}' and
`{\tt partial sum}' are iteration variables.

An iteration subblock qualified by `\ttkey{while}'
{\em condition-expression}' only executes if the
{\em condition-expression} evaluates to \TT{true},
whereas an iteration subblock qualified by `\ttkey{until}'
{\em condition-ex\-pres\-sion}' only executes if the
{\em condition-expression} evaluates to \TT{false}.

Lastly, when the {\em condition-expression} evaluates so the iteration
subblock is not executed, the finalization subblock
executes, and it must set all the variables in the
loop statement's {\em result-variable-list}.  At this point the loop stops
executing.

Loops are always in effect unraveled so multiple copies of
the iteration subblock exist at one time.

Within the initialization and iteration subblocks assignment
statements may set iteration variables in adjacent subblocks
using the following syntax for assignment statement result variables:
\begin{indpar}
\emkey{iteration-result-variable}\label{ITERATION-RESULT-VARIABLE} ::=
    \ttmkey{next}{iteration result variable}~{\em variable-name}
     $|$ \ttmkey{next next}{iteration result variable}~{\em variable-name}
\end{indpar}
{\em Assignment-statements} that set {\em iteration-result-variables}
are called `\skey{iteration assignment}s'.

Let {\tt v} be an iteration variable.  After it is set in the initialization
subblock, `{\tt v}' refers to the value of the variable in both
the initialization subblock and the first iteration.
`{\tt next v}' refers to the value of the variable in the second
iteration.  In order to prevent confusion, `{\tt v}' cannot
be used in the initialization subblock after `{\tt next v}' has
been assigned, `{\tt next v}' cannot be used in the subblock
except as a result variable when it is assigned, and
`{\tt next next v}' cannot be used in the initialization subblock.

Within the iteration
subblock, `{\tt v}' refers to the value of the variable in the
current iteration, `{\tt next v}' refers to the value of the variable
in the next iteration, and `{\tt next next v}' refers to the
value of the variable in the next iteration after the next iteration.
In order to prevent confusion, `{\tt v}' cannot
be used in the iteration subblock after `{\tt next v}' or
`{\tt next next v}' has been assigned,
and `{\tt next v}' and `{\tt next next v}'
cannot be used in the subblock
except as a result variables when they are assigned.

Within the finalization
subblock, `{\tt v}' refers to the value the variable would have
for an additional iteration if such an iteration existed.
Within the finalization subblock `{\tt next v}' and
`{\tt next next v}' cannot be used.

For a given iteration variable {\tt v},
either the initialization subblock sets {\tt v}
and the iteration subblock sets `{\tt next v}',
or the initialization subblock sets both {\tt v} and `{\tt next v}'
and the iteration subblock sets `{\tt next next v}'.

There are always at least 4 iterations of the loop with variables
simultaneously in the current function frame: the current iteration,
the previous iteration (if any), and the next two iterations.
When the third iteration of the loop starts, the first
iteration can be discarded, and so forth.

Code in an initialization or iteration subblock cannot set
deferred result variables outside the subblock (including loop block
result variables), or contain \TT{exit} statements that have
no block label.

\subsection{Call Assignment Statements}
\label{CALL-ASSIGNMENT-STATEMENTS}

Note that most functions are inline, and not out-of-line.
Inline functions are described later
in Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS}.

\ikey{Call assignment statements}{call assignment}
are used to call out-of-line functions:

\begin{indpar}
\emkey{call-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em call-assignment-option}\STAR
		~\ttkey{call}~ {\em function-expression} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{}
	\end{tabular}
\\[1ex]
\emkey{call-assignment-option}
	\begin{tabular}[t]{rl}
	::= & \ttkey{*UNCHECKED*} $|$ \ttkey{*REVERSE*}
	                          $|$ \ttkey{*NO-RELOAD*} \\
	$|$ & \ttkey{*COMPILE-TIME*} $|$ \ttkey{*COMPILE-TIME-ONLY*}
	\end{tabular}
\\[1ex]
\emkey{argument-assignment-statement} ::=
    \begin{tabular}[t]{l}
    {\em assignment-statement} in which all {\em result-variables} \\
    are {\em result-variable-declarations}
    \end{tabular}
\end{indpar}

The {\em function-expression} evaluates to a function to be called,
and must have a natural type (\pagref{NATURAL-TYPE})
$T$ that has \TT{adr} as its underlying type.

The values of the variables created by the {\em argument-assignment-statements}
are the arguments to the function.
The results of the function call are stored in the
{\em result-variable-list} variables.

A call assignment must have the \TT{*UNCHECKED*} option
unless $T$ is declared by an out-of-line
function type declaration described below.  If there is no
such declaration, the arguments are presented to the out-of-line
function in the order they are listed in the {\em call-assigment-statement},
unless the \TT{*REVERSE*} option is given, in which case this order
is reversed.

If there is an out-of-line function type declaration, arguments in the
call are matched by name to arguments in the type declaration,
and then ordered as per the type declaration.  In this case
the \TT{*REVERSE*} option is not permitted.

Normally a `\TT{reload mem, mem dependent}'
statement (see \itemref{THE-RELOAD-COMMAND})
is executed automatically
upon returning from the called function, but the
\ttkey{*NO-RELOAD*} option suppresses this.
If the \TT{*NO-RELOAD*} is given, the \TT{*UNCHECKED*} option must
also be given.

If the \TT{*COMPILE-TIME*} option is given, the call
will be made at compile time only if the argument values are available
at compile time, and will otherwise be made at run time.  When the call
is made determines whether any result variable values are determined
at compile time.  If the \TT{*COMPILE-TIME-ONLY*} option is given,
the call is made at compile time, and the argument values must be
available at compile time.

An out-of-line function type declaration has the form:

\begin{indpar}
\emkey{function-type-declaration}\label{FUNCTION-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function type}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{}
		    {\em defined-type-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{}
	\end{tabular}
\\[0.5ex]
\emkey{argument-variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{function-declaration-option}
	\begin{tabular}[t]{rl}
	::= & \ttkey{*COMPILE-TIME*} \\
	$|$ & \ttkey{*COMPILE-TIME-ONLY*}
	\end{tabular}
\end{indpar}

This makes \TT{adr} the base type of the new
defined type, and declares the prototype
for the out-of-line function.
Then a call assignment block is type-checked by matching
the variable names in the call assignment block
to those in the prototype.  Thus in this case the order of variables
in the call block does not matter as they will be matched by
variable name to the prototpye and then their values will be
reordered according to the prototype.  Also, in this case
a call block argument
may be of different
type than corresponding prototype argument if there is an implied
conversion from the call block
argument type to the prototype argument type,
in which case the implied conversion will be invoked.
Similarly a prototype result variable may be converted to
a call block result variable by an implied conversion.

The result and argument variables in a 
{\em function-type-declaration} are permitted to hide (\pagref{HIDE})
names in the context of the declaration, but the {\em defined-type-name}
may not.

A function type may be declared multiple times.  All these declarations
must be identical except for ordering of options and qualifiers.

Out-of-line functions may be declared by
an assignment statement of the form:
\begin{indpar}
\emkey{out-of-line-function-deferred-assignment}%
\label{OUT-OF-LINE-FUNCTION-DEFERRED-ASSIGNMENT} ::= \\
\hspace*{0.5in}{\em function-type-name}~{\em function-name} \TT{=}
    \ttmkey{deferred}{function}
\end{indpar}

The {\em function-name} is referred to as a `\key{deferred function}'.
This specifies that the body of the out-of-line function
with the given {\em function-name} will be provided later
during program initialization.  It is an error to call an uninitialized
deferred function.

An out-of-line function may be declared by
an assignment statement of the form:
\begin{indpar}
\emkey{out-of-line-function-assignment}%
\label{OUT-OF-LINE-FUNCTION-ASSIGNMENT} ::= \\
\hspace*{0.5in}{\em function-type}~~{\em function-name} \TT{=:} \\
\hspace*{1.0in}{\em statement}\STAR{}
\end{indpar}

The argument and result variable names used by the {\em statements}
are those given in the {\em function-type} declaration.
Thes names
and names declared within the {\em statements} of the assignment,
are permitted to hide (\pagref{HIDE})
names in the context of the assignment, but the {\em function-name}
may not.

If the {\em function-name} is deferred, the {\em function-type}
name given in the {\em out-of-line-function-deferred-assignment}
and that given in the {\em out-of-line-function-assignment}
must be identical.  It is an error if the statement initializing
a deferred function is not in the same extended module as the function's
{\em out-of-line-deferred-assignment}.

Out-of-line functions may also be declared by:

\begin{indpar}
\emkey{out-of-line-function-declaration}%
\label{OUT-OF-LINE-FUNCTION-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{}
		             ~ {\em function-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
		\TT{~~~~do:} \\
		\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}\label{OUT-OF-LINE-FUNCTIONS}

This is equivalent to defining a function type with a hidden name
and then defining {\em function-name} to be a function of that type.
The result and argument variables in a
{\em out-of-line-function-declaration},
and names declared within the {\em statements} of the declaration,
are permitted to hide (\pagref{HIDE})
names in the context of the declaration, but the {\em function-name}
may not.

For the function to be callable at compile time, the
\TT{*COMPILE-TIME*} or \TT{*COMPILE-\EOL TIME-\EOL ONLY*} options must be given.
See Section~\itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS}.
A \TT{*COMPILE-\EOL TIME*} out-of-line function will also be callable at
run time, but a \TT{*COMPILE-\EOL TIME-\EOL ONLY*}
out-of-line function will only be callable
at compile time.

Normally the standard call linkage for the computer environment of
the program is used.  Other implementation specific call options
may alter the call linkage used.

\subsection{Out-of-Line Assignment Statements}
\label{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}

An \key{out-of-line assignment statement} is like a combination of
a {\em call-assignment-statement} with
an {\em out-of-line-function-declaration} for a function
specific to the call:

\begin{indpar}
\emkey{out-of-line-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em function-declaration-option}\STAR
		~\ttkey{out-of-line} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

An {\em out-of-line-function-declaration} is constructed from this statement
by replacing the `\TT{out-\EOL of-\EOL line}' keyword by
an internally generated
{\em function-name}, and converting each {\em argument-assignment-statement}
to an {\em argument-variable-declaration}.

Then this statement is executed as a {\em call-assign\-ment-statement}
using the {\em function-name} and deleting the `\TT{do}' subblock.

{\em Out-of-line-assignment-statements} are generally included in
inline functions which preprocess arguments and may use various
{\em out-of-line-assignment-statements} to handle complex subcases.
When compiled multiple times in different contexts, the same
{\em out-of-line-assignment-statement} may be optimized in different
ways, and produce different out-of-line functions.  When it produces
the same out-of-line function more than once, this out-of-line function will
\underline{not} be duplicated.


\subsection{Compile-and-Run Assignment Statements}
\label{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}

A \key{compile-and-run assignment statement} computes a set of
variables that have values constant in a block, then compiles
the block using these constant values to optimize the compilation,
and lastly runs the block:

\begin{indpar}
\emkey{compile-and-run-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \\
	\TT{~~~~}\ttkey{compile-and-run}
		 \{ {(} {\em context-expression} \TT{)} \}\QMARK{}
		 \TT{:} \\
	\TT{~~~~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~~~~do} {\em block-name}\QMARK{} \TT{:} \\
	\TT{~~~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

The variable values are set by the {\em argument-assignment-statements}.
Then the `\TT{do}' subblock {\em statements} are compiled, using
the variable values to optimize the compilation.

Normally the
{\em compile-and-run-assignment-statement} is
compiled in its context (\pagref{CONTEXT}),
but if `\TT{(} {\em context-expression} \TT{)}'
is given, it is compiled in the context given by the
{\em context-expres\-sion}.
If the {\em context-expression}
specifies a context other than the context of the
{\em compile-and-run-assignment-statement}, the result variable names
and names declared within the block {\em statements}
are permitted to hide (\pagref{HIDE})
names in the specified context.

Then the
compiled code is executed.  The variables in the {\em result-variable-list}
may be set by either {\em argument-assignment-statements} or
`\TT{do}' subblock {\em statements} as for
a block assignment statement (see \itemref{BLOCK-ASSIGNMENT-STATEMENTS}).
If a variable \TT{v} not in the {\em result-variable-list}
is set by an {\em argument-assignment-statement},
`\TT{next v}' can be set by a `\TT{do}' subblock {\em statement}, but
this will be a new variable whose value may not be available during
the compilation.

When the compile-and-run assignment statement is executed, the compiled
code will be saved in a table indexed by the values of the
variables set by the {\em argument-assignment-statements} and the context
used in compilation.  When the
compile-and-run assignment statement is re-executed, if these
variables have the same values they had during a previous execution,
and if the same context is being used,
the compilation will be bypassed and the previously compiled code used.
This optimization is required, but such previously compiled code
may be discarded if it has not been used in a long time.


\subsection{Compile-Time Assignment Statements}
\label{COMPILE-TIME-ASSIGNMENT-STATEMENTS}

\ikey{Compile-time assignment statements}{compile-time assignment statement}
run only once, when they are compiled, and produce variable values
at compile time:

\begin{indpar}
\emkey{compile-time-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~~~ \ttkey{compile-time:} \\
	\TT{~~~~}{\em statement}\STAR{}
	\end{tabular}
\end{indpar}

A compile-time block has its own stack, which is freed when the
block finishes executing.

Compile time blocks may only use compile time variables and values,
but may use visible inline functions, out-of-line functions
that have been declared to be compile-time, and global areas
that have been declared to be compile-time.

\subsection{Deferred Assignment Statements}
\label{DEFERRED-ASSIGNMENT-STATEMENTS}

\ikey{Deferred assignment statements}{deferred assignment statement}
specifies that assigment of its result variables is deferred until later:

\begin{indpar}
\emkey{deferred-assignment-statement} ::=  \\
\hspace*{0.5in}{\em result-variable-list} \TT{=} \ttkey{deferred}
\end{indpar}


The result variables of 
a {\em deferred-assignment-statement} are called `mkey{deferred}{variable}'.

A {\em deferred-assignment-statement} must be top level.
The statement that assigns its values later must be an assignment
statement with identical {\em result-variable-list}
that is in the same extended module as the {\em deferred-assignment-statement}.
It is a program error to read a deferred variable before it has
been assigned a value.

\subsection{Assembly Assignment Statements}
\label{ASSEMBLY-ASSIGNMENT-STATEMENTS}

\ikey{Assembly assignment statements}{assembly assignment statement}
are used to embed assembler instructions in compiled code:

\begin{indpar}
\emkey{assembly-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~\TT{*UNCHECKED*}~\ttkey{*ASSEMBLY*:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em assembler-instruction}\STAR{} \\
	\end{tabular}
\end{indpar}

The variables, those produced by the {\em argument-assignment-statements},
the {\em argument-variable-declarations},
and the result variables, are placed in machine registers
and their names become machine register names for the assembler instructions.
Assembler instructions are only permitted to reference these
machine registers, but load and store assembler instructions may be used.
The assembler instructions are written in the syntax of one of the
target machine assemblers.

The variables may have additional qualifiers which
are names of machine registers or groups of machine registers.  In this case
the variables will be allocated to the specified machine registers or
machine register groups.  Otherwise they will be allocated to target
machine specified register groups based on variable type.

The {\em argument-variable-declarations} list intermediate
variables.  Only the variables named in the {\em argument-assignment-statements}
are given initial values.  Unlike normal code, values of variables
of an {\em assembly-assignment-statement} can be overwritten by the
{\em assembler-instructions}, and there is no check to be sure that
result variables receive any value.

\section{Function Prototypes and Calls}
\label{FUNCTION-PROTOTYPES-AND-CALLS}

Inline functions are declared by {\em function-declarations}
that contain a {\em function-prototype} and the code body of the
function.  Note that inline functions cannot be called recursively.

The syntax is:

\begin{indpar}
\emkey{function-declaration}\label{FUNCTION-DECLARATION}
    ::= \begin{tabular}[t]{l}
        {\em function-prototype} \TT{:} \\
	\TT{~~~~~}{\em statement}\PLUS{}
	\end{tabular}
\\[2ex]
\emkey{function-prototype}\label{FUNCTION-PROTOTYPE}
    \begin{tabular}[t]{@{}rl}
    ::= & \ttkey{function} ~
          {\em prototype-result-variable-list} ~ \TT{=} \\
        & \TT{~~~~~}{\em module-abbreviation}\QMARK{}
	                ~ {\em function-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em function-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em function-pattern} ~ \TT{=} \\
        & \TT{~~~~~}{\em input-variable-list} \\
    $|$ & {\em function-prototype} \TT{[|} {\em conditioner} \TT{|]}
    \end{tabular}
\\[0.5ex]
\emkey{prototype-result-variable-list} ::= \\
\hspace*{0.5in}
    {\em result-variable-declaration}
    \{ \TT{,} {\em result-variable-declaration} \}\STAR{}
\\[0.5ex]
{\em result-variable-declaration} ::= see \pagref{RESULT-VARIABLE-DECLARATION}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
\emkey{input-variable-list}
    ::= {\em first-input-argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{}
\\[0.5ex]
\emkey{first-input-argument-declaration} ::= {\em argument-declaration}
	without a {\em default-value}
\\[0.5ex]
\emkey{argument-declaration}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
          \TT{?} {\em default-value}\QMARK{} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
          \TT{==} {\em required-value} \\
    \end{tabular}
\\[0.5ex]
\emkey{default-value} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[0.5ex]
\emkey{required-value} ::= {\em expression} with compile time value
\\[0.5ex]
\emkey{function-pattern}\label{FUNCTION-PATTERN}
    \begin{tabular}[t]{rl}
    ::= & {\em first-pattern-term} ~ {\em pattern-term}\STAR{} \\
    $|$ & {\em pattern-argument-list}\PLUS{}
    \end{tabular}
\\[0.5ex]
\emkey{first-pattern-term} ::= {\em pattern-argument-list}\STAR{} ~
				{\em pattern-term}
\\[0.5ex]
\emkey{pattern-term}
    ::= {\em function-term-name} ~ {\em pattern-argument-list}\STAR{}
\\[0.5ex]
\emkey{function-term-name} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\\[0.5ex]
\emkey{function-variable-name}\label{FUNCTION-VARIABLE-NAME} ::=
    \begin{tabular}[t]{@{}p{4in}@{}}
    {\em function-term-name} $N$ that appears in a {\em function-prototype}
    of the form `{\tt function $N$ = \ldots}
    \end{tabular}
\\[0.5ex]
\emkey{pattern-argument-list} ::= {\em regular-argument-list}
                              $|$ {\em qualifiers-type-argument-list}
\\[0.5ex]
\emkey{regular-argument-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{qualifiers-type-argument-list} ::= \\
\hspace*{0.2in}\TT{(|} {\em qualifiers-type-argument-declaration}
	 \{ \TT{,} {\em qualifiers-type-argument-declaration} \}\STAR{} \TT{|)}
\\[0.5ex]
\emkey{qualifiers-type-argument-declaration} ::= \\
\hspace*{0.2in}{\em qualifiers-argument-declaration}
               $|$ {\em type-argument-declaration}
\\[0.5ex]
\emkey{qualifiers-argument-declaration} ::= \\
\hspace*{0.2in}\TT{qualifiers} {\em variable-name}
               \{ \TT{?} {\em default-value} \}\QMARK{}
\\[0.5ex]
\emkey{type-argument-declaration} ::= \\
\hspace*{0.2in}\TT{type} {\em variable-name}
               \{ \TT{?} {\em default-value} \}\QMARK{}
\\[0.5ex]
\emkey{conditioner}\label{CONDITIONER}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em logical-conditioner} \\
    $|$ & {\em qualifiers-conditioner} \\
    $|$ & {\em type-conditioner} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-conditioner}\label{LOGICAL-CONDITIONER}
    ::= {\em logical-expression} ~~~~~ [see \pagref{LOGICAL-EXPRESSION}]
\\[0.5ex]
\emkey{qualifiers-conditioner}\label{QUALIFIERS-CONDITIONER}
    ::= \TT{qualifiers} {\em variable-name} \TT{=} {\em expression}
\\[0.5ex]
\emkey{type-conditioner}\label{TYPE-CONDITIONER}
    ::= \TT{type} {\em variable-name} \TT{=} {\em expression}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[4ex]
\emkey{function-call}\label{FUNCTION-CALL}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em module-abbreviation}\QMARK{} ~ {\em first-call-term}
          ~ {\em call-term}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{first-call-term} ::= {\em call-argument-list}\STAR{}
				{\em call-term}
\\[0.5ex]
\emkey{call-term}
    ::= {\em function-term-name} {\em call-argument-list}\STAR{}
\\[1ex]
\emkey{call-argument-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{]} \\
    $|$ & \TT{(|} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{|)} \\
    $|$ & \TT{()} $|$ \TT{[]} $|$ \TT{(|~|)} \\
    $|$ & {\em primary-argument}
    \end{tabular}
\\[0.5ex]
\emkey{actual-argument} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[0.5ex]
\emkey{primary-argument} ::= {\em primary-item}\PLUS{}
                         $|$ {\em bracketed-constant}
\\[0.5ex]
{\em primary-item} ::= {\em word} $|$ {\em number}
                   $|$ {\em quoted-string} ~~~~~ [see \pagref{PRIMARY-ITEM}]
\\[0.5ex]
{\em bracketed-constant} ::= see \pagref{BRACKETED-CONSTANT}

\begin{itemize}
\item
A {\em function-pattern} must have either a {\em function-term-name}
or at least two {\em pattern-argu\-ment-lists} that have either `\TT{()}'
or `\TT{[]}' brackets, unless it
has the special form required of an implied conversion
(\pagref{IMPLIED-CONVERSION-FUNCTIONS}).
\item
A {\em function-prototype} {\em function-term-name} must not be
an initial segment of any other {\em function-term-name}
in the same {\em function-prototype}.
\item
An {\em function-variable-name}
should not have a {\em qualifier-name} or {\em type-name} as an initial segment.
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.
\item
\TT{"="} cannot be used as a {\em function-term-name}
in a {\em function-pattern}.
\item
All the result and argument {\em variable-names}
in a {\em function-prototype} must
be distinct.
\item
The {\em variable-name} in a {\em qualifiers-argument-declaration}
or a {\em qualifiers-conditioner} is treated as a {\em qualifier-name}
within the rest of the {\em function-prototype}.  The value of the
{\em variable-name} must be computable at compile-time when the
function is called.  A {\em qualifiers-argument-declaration}
can be inside `\TT{()}' or `\TT{[]}' bracketed {\em argument-lists},
as well as `\TT{(|~|)}' bracketed {\em argument-lists}.
\item
The {\em variable-name} in a {\em type-argument-declaration}
or a {\em type-conditioner} is treated as a {\em type-name}
within the rest of the {\em function-prototype}.  The value of the
{\em variable-name} must be computable at compile-time when the
function is called.  A {\em type-argument-declaration}
can be inside `\TT{()}' or `\TT{[]}' bracketed {\em argument-lists},
as well as `\TT{(|~|)}' bracketed {\em argument-lists}.
\item
In a {\em pattern-argument-list} or {\em input-variable-list}
an {\em argument-declaration} with no {\em de\-fault-value} cannot
follow an {\em argument-declaration} with a {\em default-value}.
An {\em argument-declaration} that ends with `\TT{?}' is considered
to have a \TT{bool} {\em default-value}: see \pagref{BOOL-DEFAULT}.


\end{itemize}
\end{indpar}

The result and argument variables in a
{\em function-declaration},
and names declared within the {\em statements} of the declaration,
are permitted to hide (\pagref{HIDE})
names in the context of the declaration.

A {\em function-call} with a {\em result-variable-list}
is replaced by a {\em block-assignment-statement}
with an context option specifying the context of the
{\em function-declaration}
(\itemref{BLOCK-ASSIGNMENT-STATEMENTS}).
The result and argument variables in the {\em function-declaration}
are effectively replaced by compiler generated temporary variable names to
avoid conflicts, and variables declared inside the replacing
{\em block-assignment-statement} are permitted to hide variables outside
the statement (\pagref{HIDE}).  The values of the argument temporary
variables are computed before the block and the values of the result
temporary variables are assigned to the {\em function-call} result
variables after the block.\footnote{This can be implemented by using
two nested blocks instead of one block without actually replacing
variable names in the {\em function-declaration} by temporary variable
names.}

A {\em function-call} without any {\em result-variable-list}
is just like a {\em function-call} with an empty
{\em result-variable-list}.

A {\em function-call} with an {\em input-variable-list} is just syntactic
sugar for a {\em function-call} with neither a {\em result-variable-list}
or {\em input-variable-list}.  Specifically
\begin{center}
{\tt F(a1,a2,...)~=~b1,b2,...} \\
is syntactic sugar for \\
{\tt F(a1,a2,...)~"="~(b1,b2,...)} \\
\end{center}

in which a term with \TT{"="} as its {\em function-term-name} is
placed at the end of the {\em function-call}.

{\em Call-terms} correspond to {\em pattern-terms}.  {\em Call-terms}
other than the first may be in a different order than their matching
{\em pattern-terms}.  {\em Call-terms} other than the first may be
omitted, and if omitted, will be inserted with empty {\em call-argument-lists}.
{\em Call-argument-lists} may be omitted, and if omitted, empty
lists will be inserted if this can be done unambiguously.
If a {\em pattern-argument-list} has \TT{()} brackets and a single
argument, and the corresponding {\em call-argument-list} has a single
{\em actual-argument} that is just a {\em name} or {\em constant},
the \TT{()} parentheses may be omitted in the {\em function-call}
if there is no ambiguity involving {\em function-term-names}.

Examples are:
\begin{indpar}\begin{verbatim}
function int32 r =
        fee ( int32 x ) fie ( int32 y ) foe ( int32 z ):
    ... function body omitted ...

int32 b 1 = ...
int32 c 2 = ...
int32 d 3 = ...
int32 f = fee ( b 1 ) foe ( c 2 ) fie ( d 3 )
    // Same as:
    //   int32 f = fee ( b 1 ) fie ( d 3 ) foe ( c 2 )
int32 g = fee ( b 1 ) foe ( c 2 )
    // Same as:
    //   int32 g = fee ( b 1 ) fie () foe ( c 2 )
    // Erroneous: actual argument missing
int32 h = fee b 1 foe c 2 fie d 3
    // Same as:
    //   int32 h = fee ( b 1 ) fie ( d 3 ) foe ( c 2 )
\end{verbatim}\end{indpar}

If an argument has a {\em required-value} in a {\em pattern-argument-list},
then there must be a corresponding {\em actual-argument} in the
{\em function-call} whose value is a compile-time value that equals the
{\em required-value}, which must also be a compile-time value.  An example is:
\begin{indpar}\begin{verbatim}
define type my type as int32
define type your type as uns32
function type r = companion type of ( type t == my type ):
    r = your type
function type r = companion type of ( type t == your type ):
    r = my type
\end{verbatim}\end{indpar}

{\em Actual-arguments} may be omitted at the end of a {\em call-argument-list}
if their corresponding
{\em argu\-ment-declaration} contains a {\em default-value}.
The {\em default-value} will be used as the actual argument
for such an omitted actual argument.

If the {\em argument-declaration} ends in `\TT{?}'\label{BOOL-DEFAULT}
with no explicit {\em default-value}, the
argument must have \TT{bool} type and the
{\em default-value} is taken to be \TT{true} if the
corresponding {\em call-term} was originally present, and \TT{false} if the
{\em call-term} was originally omitted and automatically inserted.

An example is:
\begin{indpar}\begin{verbatim}
int32 B = ...
int32 C = ...
context fooC = current context
function int32 r =
        foo ( int32 x ) bar ( int32 y ? B + C, bool z ? )
    ... function body omitted ...

int32 b 1 = ...
int32 f = foo ( b 1 )
    // Call has same effect as:
    //     int32 tmp y, bool tmp z = do ( fooC ):
    //         tmp y = B + C
    //         tmp z = false
    //     int32 f = foo ( b 1 ) bar ( tmp y, tmp z )
\end{verbatim}\end{indpar}

An {\em argument-declaration} can be a {\em type-argument-declaration}
which has the form `{\tt type T}' for some {\em variable-name} {\tt T}.
This makes {\tt T} into a {\em type-name} within the {\em function-declaration}
containing the {\em type-argument-declaration}.
If the {\em type-argument-declaration} is
in an argument list with `\TT{(|~|)}' brackets,
the actual value of {\tt T} can be implied by a {\em function-call}.
If an explicit or default value of {\tt T} is given by the call, that is used.
Otherwise if {\tt T} is the type of a prototype result variable, and there
is a corresponding {\em function-call} result variable with a known type,
the type of the leftmost such result variable
is assigned as the value of {\tt T}.  Otherwise
if {\tt T} is the type of a prototype argument variable, and
the {\em actual-argument} corresponding to the variable in the call has
a natural type (\pagref{NATURAL-TYPE}), {\tt T} is assigned the natural type
corresponding to the leftmost such variable in the prototype.


For example,
\begin{indpar}\begin{verbatim}
function T result = add (| type T |) ( T v1, T v2 ):
    result = v1 + v2

// Example usage
//
int32 x = ...
int32 y = ...
int32 z = add (| int32 |) ( x, y )
    // T is explicitly given.
next z = add ( x, y )
    // T = int32 is implied because that is the type of
    // `next z'.
\end{verbatim}\end{indpar}

An {\em argument-declaration} can be a {\em qualifiers-argument-declaration}
which for some {\em variable-name} {\tt Qs}
has the form `{\tt qualifiers Qs}'.
This makes {\tt Qs} into a {\em qualifier-name}
within the {\em function-de\-clar\-a\-tion}
containing the {\em type-argument-declaration}.  Note that {\tt Qs}
is used like a {\em qualifier-name}, but its value is a set of
zero or more qualifiers.

If the {\em qalifiers-argument-declaraion} is
in an argument list with `\TT{(|~|)}' brackets,
the actual value of {\tt Qs} may be implied by a {\em function-call}.
If an explicit or default value of {\tt Qs} is given by the call, that is used.
Otherwise if {\tt Qs} is the given as the \underline{only} qualifier
of a prototype result variable, and there is a corresponding {\em function-call}
result variable with known type,
the qualifiers of the leftmost such call result variable are
assigned as the value of {\tt Qs}.  Otherwise
if {\tt Qs} is given as the \underline{only} qualifier
of a prototype argument variable,
and the {\em actual-argument} corresponding to the
variable has a natural type (\pagref{NATURAL-TYPE}),
{\tt Qs} is assigned the qualifiers of the natural type corresponding
to the leftmost such variable in the prototype.

For example,
\begin{indpar}\begin{verbatim}
define protected required qualifier in-range
define required prohibited qualifier ouch
function Qs in-range T r =
        check (| qualifiers Qs, type T |) ( Qs T v ):
    if:
        v < 0:
            error "argument < 0"
        v > 100:
            error "argument > 100"
        else:
            result = v

function F ( in-range v ):
    ... function body omitted ...

// Example usage
//
ouch int32 x = ...
ouch int32 y1 = check ( x )
           // Legal: check prototype becomes:
           //   ouch in-range r = check ( ouch int32 v )
           // so argument can have qualifier ouch,
           // and y1 must have qualifier ouch.
           // Also y1 is given protected qualifier
           // `in-range'.
int32 y2 = check ( x )
           // Illegal, result `ouch in-range r' cannot
           // be converted to y2 which has no `ouch'
           // qualifer.
F ( x )    // Illegal, x does not have required in-range
F ( y1 )   // Legal, y1 has required in-range
\end{verbatim}\end{indpar}

{\em Conditioners} bracketed by `\TT{[|~|]}'
can be written at the end of a {\em function-prototype},
as in:
\begin{indpar}\begin{verbatim}
types signed-integer-types =
    { int8, int16, int32, int64, int128 }

function T result = add (| type T |) ( T v1, T v2 )
    [| T is in signed-integer-types |]:
    result = v1 + v2
\end{verbatim}\end{indpar}

which would define `\TT{add}' only for signed integer types.
Here the conditioner is a {\em logical-ex\-pres\-sion} that must
be evaluatable whenever a call to the function is compiled.

Another example is:
\begin{indpar}\begin{verbatim}
function Qs2 T r = inc (| qualifiers Qs1, type T |)
                       ( Qs1 T v )
    [| qualifiers Qs2 = Qs1 - { stack } |]:
    return v + 1
\end{verbatim}\end{indpar}

which returns {\tt v+1} with the same qualifiers as {\tt v}
except for the `{\tt stack}' qualifier which is removed.
Here the rightside of the {\em qualifiers-conditioner}
must be evaluatable when a call to the function is compiled.

The body of an inline function is parsed, but it is not checked for
errors before the function is called.  When the function is called,
compile time values passed as arguments may cause parts of the body
to never be compiled or checked for compilation errors.  If a function
is never called, it may contain code that would have compilation errors
were the function called, such as calls to non-existent functions.

\subsection{Matching Function Calls to Prototypes}
\label{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}

To compile a {\em function-call} it must be matched to a
single {\em function-prototype}.  If it matches more than one
{\em function-prototype}, the call is ambiguous and is a compilation error

The matching algorithm, given a {\em function-call} and a
{\em function-prototype}, matches the {\em function-call}
to the {\em function-pattern} in the {\em function-prototype},
and matches any call result variables to
the {\em prototype-result-variable-list}
of the {\em function-prototype}.  The call may have one or more result
variables of known types, or a single result variable of unknown
type, or no result variables (as in a {\em function-call} that is
a {\em statement} by itself).  The algorithm is as follows:

\begin{enumerate}

\item
If the {\em function-call} is in a statement of the form
\begin{center}
{\em function-call} ~ \TT{=} ~ {\em expression-list}
\end{center}
the {\em function-prototype} must be of the form
\begin{center}
{\tt function} ~ {\em function-pattern} ~ {\tt =} ~ {\em input-variable-list} \\
\end{center}
and the following will be done:
\begin{enumerate}
\item `\TT{=}' will be treated in the following as if it were the
{\em function-term-name} \TT{"="}.
\item{\em expression-list} is parenthesized.
\item {\em input-variable-list} is parenthesized.
\end{enumerate}

For example, the prototype
\begin{center}
\tt function F ( int64 i ) = int32 x, int32 y
\end{center}
behaves as if it were
\begin{center}
\tt function F ( int64 i ) "=" ( int32 x, int32 y )
\end{center}
and the assignment statement
\begin{center}
\tt F ( i ) = x, y
\end{center}
behaves as if it were the function call with no result variables
\begin{center}
\tt F ( i ) "=" ( x, y )
\end{center}

\item If the {\em function-call} begins with a {\em module-abbreviation}
(see \pagref{MODULE-ABBREVIATION}), the {\em function-pattern}
must begin with a {\em module-abbreviation}, and the two
{\em module-abbreviations} must reference the same {\em module-name}
(i.e., module file, see \itemref{MODULES}), else the
call-prototype match fails.

\item If the {\em function-call} does \underline{not} begin
with a {\em module-abbreviation}, but the {\em function-pattern}
does begin with a {\em module-abbreviation}, the match is marked
as `\key{module deficient}'\label{MODULE-DEFICIENT},
and will be disallowed later if there is
another match that is not module deficient.

\item
The {\em function-term-names} in the {\em function-call} are located by
matching segments of the {\em func\-tion-call} to
{\em function-term-names} in the {\em function-pattern}.
If a {\em function-term-name} matches more than one segment,
the call-prototype match fails.  If the first {\em function-term-name}
in the {\em function-pattern} does not match any segment,
or does not match the first matched segment, the call-prototype match fails.
(Note that {\em function-term-names} in the {\em function-pattern}
cannot be initial segments of each other, but unparenthesized
{\em variable-names} may appear in the {\em function-call} and be
mistaken for parts of {\em function-term-names}.)

\item The {\em call-terms} after the first in the {\em function-call}
are reordered so the {\em function-term-names} in the {\em function-call},
taken in order, are a subsequence of the {\em function-term-names} in the
{\em function-pattern}.
If this cannot be done, the call-prototype match fails.
(Note that {\em call-terms} other than the first all begin with
a {\em function-term-name} and extend until the next {\em function-term-name}
or the end of the {\em function-call}.)

\item\label{ADD-TERMS}
If some of the {\em function-term-names} in the {\em function-pattern}
are missing from the call,
new {\em call-terms} without argument lists
are inserted in the call to match the missing
{\em pattern-terms}.  At this point there is a 1-1 ordered correspondence
between {\em call-terms} and {\em pattern-terms}.

\item
If some of the {\em pattern-terms} have argument lists that
have a single parenthesized argument, the parentheses may be omitted
in the {\em function-call} if the actual argument is a sequence of
{\em primary-items} or a {\em bracketed-constant}.
Also {\em argument-lists}
may be completely omitted in the {\em function-call}.  At this point
missing parentheses and missing {\em argument-lists} are added to
each {\em call-term} to make it match the corresponding
{\em pattern-term}.
The {\em argument-lists} added are empty and have the same type of
bracket, \TT{()}, \TT{[]}, or \TT{(|~|)}, as the {\em pattern-term}
{\em argument-lists} they match.

If this cannot be done \underline{uniquely}
so each {\em pattern-term} {\em argument-list}
is matched to a {\em call-term} {\em argument-list}
that has the same type of bracket, then the call-prototype match fails.

\item
If the {\em function-prototype}
has cluster member arguments or result variables,
these must be implied, and they are added to the {\em function-call}
at this point.  See \itemref{CLUSTERS} for details.

\item
Now the modified {\em function-call} matches
the {\em function-pattern} in {\em function-term-names},
location and number of {\em argument-lists}, and type of bracket (\TT{()},
\TT{[]}, or \TT{(|~|)}) for each {\em argument-list}.  Some
{\em call-argument-lists} may be shorter than the corresponding
{\em pattern-argument-lists}.

If a pattern {\em argument-declaration} has a {\em required-value},
there must at this point be a matching {\em function-call} {\em actual-argument}
with a compile-time value equal to the {\em required-value},
else the call-prototype match fails.

\item
If some of the {\em call-argument-lists} are now too short, they are extended
by adding the {\em default-values} from
their matching {\em pattern-argument-lists}.
As a special case, if a prototype {\em arg\-u\-ment-de\-clar\-a\-tion} ends in
`\TT{?}' but has no {\em default-value}, then the actual
{\em default-value} used is \TT{true} if the {\em function-term-name}
appeared in the original function call and was not added in
Step~\ref{ADD-TERMS} above, or is \TT{false} if the {\em function-term-name}
did not appear in the original function call, but was added in
Step~\ref{ADD-TERMS}.

If any of the arguments that need to be inserted in a
{\em call-argument-list} matched to a {\em regular-argument-list}
do not have {\em default-values}, the call-prototype match fails.

Now the modified {\em function-call} matches
the {\em function-pattern} in {\em function-term-names},
location and number of {\em argument-lists}, and type of bracket (\TT{()},
\TT{[]}, or \TT{(|~|)}) for each {\em argument-list}.  The number of
arguments also match for \TT{()} and \TT{[]} {\em argument-lists},
and number of actual arguments in each \TT{(|~|)} {\em call-argument-list}
is not greater than the number of arguments in the corresponding
{\em pattern-argument-list}.

Note that any {\em default-values} inserted in the {\em function-call}
are evaluated in the context of the {\em function-prototype}.  For
matching purposes, this is relevant only if the {\em default-values}
are {\em expressions} with compile-time values, and such
{\em default-values} can be replaced by constants when the
{\em function-prototype} is first compiled.

\item
If any {\em qualifiers-argument-declaration} in a {\em function-pattern}
{\em qualifiers-type-argument-list} has a corresponding
actual argument, the actual argument expression
is evaluated with the `\TT{qualifiers}' target type,
and must have a compile time value which is a set of qualifiers, else
the call-prototype match fails.  If the match does not fail,
the set of qualifiers becomes the value of the {\em variable-name}
in the {\em qualifiers-argument-declaration} and
is substituted for the {\em variable-name} throughout the rest of the
{\em function-prototype}.

\item
If any {\em type-argument-declaration} in a {\em function-pattern}
{\em qualifiers-type-argument-list} has a corresponding
actual argument, the actual argument expression
is evaluated with the `\TT{type}' target type,
and must have a compile time value which is a type, else
the call-prototype match fails.  If the match does not fail,
the type value becomes the value of the {\em variable-name}
in the {\em type-argument-declaration} and
is substituted for the {\em variable-name} throughout the rest of the
{\em function-prototype}.

\item
If any {\em qualifiers-argument-declaration} in a {\em function-pattern}
{\em qualifiers-type-argument-list} does \underline{not} have
a corresponding actual argument, the value of the
{\em variable-name} in the {\em qual\-i\-fiers-argument-declaration}
is implied.

If the {\em variable-name} in the {\em qualifiers-argument-declaration}
is used as the \underline{sole} {\em qualifier-name}
of prototype result variables
with a matching actual results with known type and qualifiers,
the qualifiers of the leftmost such actual result is assigned as the
value of the {\em variable-name}.

Otherwise if the {\em variable-name}
is used as the \underline{sole} {\em qualifier-name}
of several arguments whose matching
actual arguments have natural types, the qualifiers of the leftmost
of these arguments is assigned as the
value of the {\em variable-name}.

If no value can be assigned to the {\em variable-name} by these rules,
the call-prototype match fails.

If a value is assigned,
the set of qualifiers that is the assigned value
is added as an actual argument
in the {\em call-argument-list} that corresponds
to the {\em qualifiers-argument-declaration}, and
is substituted for the {\em variable-name} throughout the rest of the
{\em function-prototype}.

\item
If any {\em type-argument-declaration} in a {\em function-pattern}
{\em qualifiers-type-argument-list} does \underline{not} have
a corresponding actual argument, the value of the
{\em variable-name} in the {\em type-argument-declaration}
is implied.

If the {\em variable-name} in the {\em type-argument-declaration}
is used as the {\em type-name} of prototype result variables
with a matching actual results with known type,
the type of the leftmost such actual result is assigned as the
value of the {\em variable-name}.

Otherwise if the {\em variable-name}
is used the {\em type-name} of several arguments whose matching
actual arguments have natural types, the type of the leftmost
of these arguments is assigned as the
value of the {\em variable-name}.

If no value can be assigned to the {\em variable-name} by these rules,
the call-prototype match fails.

If a value is assigned,
the type that is the assigned value is added as an actual argument
in the {\em call-argument-list} that corresponds
to the {\em type-argument-declaration}, and
is substituted for the {\em variable-name} throughout the rest of the
{\em function-prototype}.

\item
The modified {\em function-call} now matches the {\em function-pattern}
precisely in {\em function-term-names},
location and number of {\em argument-lists}, type of bracket, i.e. \TT{()},
\TT{[]}, or \TT{(|~|)} for each {\em argument-list}, and number of
arguments in each {\em argument-list}.
This modified function call is referred to as the
`\mkey{unfolded}{function call}' {\em function-call}.

If any actual argument value needs to be a compile-time value in what
follows, the actual argument expression is compiled at this
time with its target type taken from the corresponding
{\em function-pattern} {\em argument-declaration}.
If the result is not a compile-time value, the call-prototype
match fails.

\item
The {\em conditioners} in the {\em function-prototype} are evaluated
in order.  If any of the expressions in them do not have compile-time
values, the call-prototype match fails.
If any {\em logical-conditioner} evaluates
to \TT{false}, the call-prototype match fails.

If the value assigned to the {\em variable-name} of a
{\em type-conditioner} is not a type, the call-prototype match fails.
Otherwise this type value is substituted for the {\em variable-name}
throughout the {\em function-prototype}.

If the value assigned to the {\em variable-name} of a
{\em qualifiers-conditioner} is not a (possibly empty) set of
qualifiers, the call-prototype match fails.
Otherwise this qualifiers set value is substituted for the {\em variable-name}
throughout the {\em function-prototype}.

\item If the unfolded {\em function-call} has {\em actual-argument}
expressions $e1$, $e2$, \ldots{} read from left to right
(including {\em default-values}),
and the {\em function-pattern} has
{\em argument-declarations} `$Qs1$ $T1$ $v1$', `$Qs2$ $T2$ $v2$', \ldots{}
read from left to right,
then the statement containing the
revised {\em function-call} is replace by:
\begin{indpar}
{\tt $Qs1$ $T1$ $tmp1$ = $e1$} \\
{\tt $Qs2$ $T2$ $tmp2$ = $e2$} \\
\ldots\ldots\ldots\ldots \\
statement containing {\em function-call}
with each {\em actual-argument} $eI$ replaced by $tmpI$
\end{indpar}

Here the $Qs\ldots$ are possibly empty qualifier sets,
the $T\ldots$ are types, the $v\ldots$ are argument variable
names, and the $tmp\ldots$ are
\skey{temporary variable name}s (names of the form \TT{T\$}$n$
for a natural number $n$ manufactured by the compiler and
guaranteed to a unique among all {\em names}.)

If any $eI$ is a {\em default-value}, then in the above
\begin{indpar}
{\tt $QsI$ $TI$ $tmpI$ = $eI$}
\end{indpar}
is replaced by
\begin{indpar}
{\tt $QsI$ $TI$ $tmpI$ = do ( }{\em prototype-context}{\tt ~):} \\
\hspace*{0.5in}{\tt $tmpI$ = $eI$}
\end{indpar}

If any the statements `{\tt $QsI$ $TI$ $tmpI$ = \ldots}' cannot be compiled
for reasons other than an ambiguity error, the call-prototype match fails.

If any of the statements `{\tt $QsI$ $TI$ $tmpI$ = \ldots}' cannot be compiled
because of an ambiguity error, the call-prototype match
is `\key{ambiguity deficient}' (and will be
rejected later, possibly for another reason).

\item If the {\em function-call} has no result variables, the
{\em function-prototype} must have no result variables,
else the call-prototype match fails.

\item If the {\em function-call} has one result variable of
unknown type, the {\em function-prototype} must have result variables
else the call-prototype match fails.
The type and qualifiers of the first
{\em function-prototype} result variable become the natural
type and qualifiers (\pagref{NATURAL-TYPE})
of the {\em function-call} expression if
the match ultimately is accepted according to the rules below.

\item \label{FUNCTION-CALL-ASSIGNMENT-COMPILATION}
If the {\em function-call} has result variables of known type
as in a statement of the form
\begin{center}
{\tt $QCs1$ $TC1$ $vc1$, $QCs2$ $TC2$ $vc2$, \ldots{}~=~}{\em function-call}
\end{center}
with at least one result variable of known type,
the {\em function-prototype} must be of the form
\begin{center}
{\tt function $QRs1$ $TR1$ $vr1$, $QRs2$ $TR2$ $vr2$,
     \ldots{}~=~}{\em function-pattern}
\end{center}
with at least as many result variables in the prototype as in
the {\em function-call} statement.  The statement is then
replaced by:
\begin{indpar}
{\tt $QRs1$ $TR1$ $tmp1$, $QRs2$ $TR2$ $tmp2$,
    \ldots{}~=~}{\em function-call} \\
{\tt $QCs1$ $TC1$ $vc1$ = $tmp1$} \\
{\tt $QCs2$ $TC2$ $vc2$ = $tmp2$} \\
\ldots\ldots\ldots\ldots
\end{indpar}
If any of the `{\tt $QCsI$ $TCI$ $vc1$ = $tmpI$}' statements cannot be
compiled because $QRsI$ $TRI$ is not implicitly convertible
to $QCsI$ $TCI$, the call-prototype match fails.
Note that extra prototype result variables
are never used and are ultimately ignored.

If $QRs1$ $TR1$ and $QCs1$ $TC1$ are not equal
(but $QRs1$ $TR1$ values are implicitly
convertible to $QCs1$ $TC1$ values), the match is marked
`\key{conversion deficient}'\label{CONVERSION-DEFICIENT},
and will be disallowed later
if there is another match that is not conversion deficient.
Note that only the first result variable is considered by this rule.

\end{enumerate}


The first step in compiling a {\em function-call} is to compute the
set of matches of that call.  Then the following is done in order:

\begin{enumerate}

\item If there is any match that is not conversion deficient, then
all conversion deficient matches are discarded.

\item If there is any remaining match that is not module deficient, then
all module deficient matches are discarded.

\item Let $e1$, $e2$, \ldots{}~be the argument expressions of
the not-unfolded original {\em function-call}, read from left to right.
If there are two matches $X$ and $Y$ such that
some of the $eI$ have
have {\em required-values} in $X$ but not in $Y$, and none of the $eI$
have {\em required-values} in $Y$ but not in $X$,
then the $Y$ match is discarded.

\item Let $e1$, $e2$, \ldots{}~be the argument expressions of
the not-unfolded original {\em function-call}, read from left to right.
If there are two matches $X$ and $Y$ such that
$TX1$, $TX2$, \ldots{}~are the types of the $X$ prototype argument
variables assigned to $e1$, $e2$, \ldots{}~in order, and
$TY1$, $TY2$, \ldots{}~are the types of the $Y$ argument
variables assigned to $e1$, $e2$, \ldots{}~in order,
and values of type
$TXi$ are implicitly convertible to values of type $TYi$ for
every $i$,
then the $Y$ match is discarded.

\item If after discarding matches as above, there are no matches,
the {\em function-call} is `\key{unmatched}' and cannot be compiled.

\item If after discarding matches as above, there is more than one
match left,
the {\em function-call} is `\key{ambiguous}' and cannot be compiled.

\item If the remaining match has
an ambiguity deficiency,
the {\em function-call} is `\key{ambiguous}' and cannot be compiled.

\item Otherwise there is just one match left, and that
match has no ambiguity deficiency.  That match
is accepted and used to compile the {\em function-call}.

\end{enumerate}

\section{Special Functions}
\label{SPECIAL-FUNCTIONS}

Note that in this section `\TT{std}' is used as the
{\em module-abbreviation} (\pagref{MODULE-ABBREVIATION})
of the \TT{"standard"} module.
This {\em module-abbreviation} is commonly omitted when
a function is called.

\subsection{Floating Pointer Error Flag Functions}
\label{FLOATING-POINT-ERROR-FLAG-FUNCTIONS}

The \skey{floating point error flag}s of
section~\itemref{FLOATING-POINT-ARITHMETIC-EXPRESSIONS}
are located in the `\key{floating point error register}' which
is a special register of \TT{unswrd} type.  The following
builtin functions test and manipulate this register.

\begin{indpar}
{\tt function unswrd r = std \ttkey{fp error flags}} \\
{\tt function std \ttkey{clear fp error flags}} \\
{\tt function std \ttkey{clear fp error flags} ( unswrd mask ) } \\
{\tt function std \ttkey{set fp error flags} ( unswrd mask ) }

\begin{indpar}
The first function
above reads the register, the second clears the floating point
error flags in the register, the third clears just the floating point
error flags selected by the bits of \TT{mask}, and the fourth sets just the
flags selected by the bits of \TT{mask}.  The value read from the register
may contain non-zero bits other than the floating point error flags.
\end{indpar}
\end{indpar}

The following functions with no arguments
return compile time constants that are
masks for the floating
point error flags in the floating point error
register.  Each mask has a single bit on.
\begin{center}
\begin{tabular}{ll}
{\tt function unswrd r = std \ttkey{FP INVALID}}	& Invalid operand. \\
{\tt function unswrd r = std \ttkey{FP DIVIDE BY ZERO}}	& Divide by zero. \\
{\tt function unswrd r = std \ttkey{FP OVERFLOW}}	& Result overflow. \\
{\tt function unswrd r = std \ttkey{FP UNDERFLOW}}	& Result underflow. \\
{\tt function unswrd r = std \ttkey{FP INEXACT}}	& Result inexact. \\
\end{tabular}
\end{center}
The value of \TT{mask} above should be a bitwise OR's of these constants.

\subsection{Abbreviation Testing Functions}
\label{ABBREVIATION-TESTING-FUNCTIONS}

The following functions provide information
about regular abbreviations (\pagref{ABBREVIATION-DECLARATION}).

It is a compile error if any argument to these
functions is not a compile time value.  The results returned by these
functions are compile time values.

\begin{indpar}
{\tt function bool r = std ( name N ) \ttkey{is abbreviation}} \\
{\tt function name r = std \ttkey{replacement of} ( name N )} \\
{\tt function name r = std \ttkey{final replacement of} ( name N )}
\begin{indpar}
The first function returns \TT{true} if and only if {\tt N} names
an abbreviation (\pagref{ABBREVIATION-DECLARATION}).

The second function returns the replacement name from the
{\em abbreviation-declaration} of {\tt N}, or returns {\tt N} itself
if {\tt N} is not an abbreviation.  The replacement name may itself
be an abbreviation.

The third function applies the second function recursively until
the name returned is not an abbreviation.
\end{indpar}
\end{indpar}

\subsection{Compiler Functions}
\label{COMPILER-FUNCTIONS}

The following function can be used to produce compile-time
generated names like `\TT{T\TMP$n$}', which are most likely
to be useful in generics (\pagref{GENERICS}).

\begin{indpar}
{\tt function name r = std \ttkey{generated name} ( character c )}%
\label{GENERATE-NAME}

\begin{indpar}
Returns the name `\TT{$c$\TMP$n$}' where $c$ is the value of the
argument and $n$ is a natural-number such that the returned name
is unique among all names generated during the compilation, either
by this function or by the compiler.  $c$ must be an ASCII
letter.
\end{indpar}
\end{indpar}

\subsection{Program Termination Functions}
\label{PROGRAM-TERMINATION-FUNCTIONS}

The following functions are used to terminate program execution
when a programming error is discovered.

\begin{indpar}

{\tt function string r = std \ttkey{call location}}
\begin{indpar}
This function returns a string of the form:
\begin{center}
{\em file-name}\TT{:~line~}{\em line-number}
\end{center}
describing the location of the {\em function-call}
that invoked an inline function containing the call to
`{\tt call location}'.  Here {\em file-name} is either
the {\em module-name} (\pagref{MODULES}) or {\em body-name}
(\pagref{BODIES}) of the file; that is, it is the name of
the file containing the {\em function-call}
relative to one of several directories
specified separately to the compiler.
{\em Line-number} is the number (1, 2, 3, \ldots) of the
line in which the statement containing the {\em function-call}
begins.

This function allows an inline function to be written that
outputs a message containing the location of the call to the
inline function.
\end{indpar}

{\tt function std \ttkey{program stop}}
\begin{indpar}
This function terminates the program abnormally.  It has
the special property that deferred variables that normally
must be set in the block need not be set in an execution
path that includes a call to this function.
\end{indpar}

\end{indpar}


\section{Generics}
\label{GENERICS}

A \key{generic} is an inline function that is completely
evaluated at compile time and that contains special
`\skey{include-statement}s' which generate code that replaces the generic call
in the program.  Within the included code compile time values are substituted
for `\skey{include-argument}s'.

An example is:
\begin{indpar}\begin{verbatim}
generic min-max ( name F, name C )
    include (F, C):
        function T result = F (| type T |) ( T x, T y ):
            result = if:
                (x) C (y):
                    result = x
                (y) C (x):
                    result = y
                T is float:
                    result = NaN

min-max functions ( `min', `"<="' )
int64 u = ...
int64 v = min ( u, -1,000,000 )
min-max functions ( `max', `">="' )
float64 w = ...
next w = max ( w, -1,000,000 )
\end{verbatim}\end{indpar}

Note that {\tt C} is a function call {\em function-term-name} and not
an operator.
Also if {\tt T is float} is \TT{false} the last condition statement
clause is not compiled or checked for errors
(\pagref{MISSING-ELSE-RULE}).

The general syntax is:
\begin{indpar}
\emkey{generic-declaration}\label{GENERIC-DECLARATION}
    ::= \begin{tabular}[t]{l}
        {\em generic-prototype}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{generic-prototype}\label{GENERIC-PROTOTYPE}
    ::= \TT{generic} ~ {\em module-abbreviation}\QMARK{}
                     ~ {\em function-pattern}
\\[0.5ex]
{\em function-pattern} ::= see \pagref{FUNCTION-PATTERN}
\\[0.5ex]
\emkey{generic-call} ::= {\em function-call} ~~~~~ [see \pagref{FUNCTION-CALL}]
\\[0.5ex]
\emkey{include-statement} ::=
    \begin{tabular}[t]{l}
    \ttkey{include} ~ \begin{tabular}[t]{@{}l@{}}
                      {\em include-name}\QMARK{}
                          ~ {\em include-argument-list}\QMARK{} \\
		      \{ \TT{if} ~ {\em compile-time-expression}
		                 ~ \}\QMARK{} ~ \TT{:} \\
		      \end{tabular} \\
    \TT{~~}{\em statement}\STAR{}
    \end{tabular}
\\[0.5ex]
\emkey{include-name} ::=
    \begin{tabular}[t]{l}
    {\em name} ~~~~~ [see \pagref{NAME}] \\
    \underline{not} containing
	`\TT{.}',~ {\em quoted-marks},~ {\em quoted-separators}, or `\TT{if}'
    \end{tabular}
\\[0.5ex]
\emkey{include-argument-list} ::=
    \TT{(} {\em include-argument} \{ \TT{,} {\em include-argument} \}\STAR{}
    \TT{)}
\\[0.5ex]
\emkey{include-argument} ::= {\em word} not containing `\TT{.}'
\end{indpar}

A {\em generic-prototype} is a {\em function-prototype} and a
{\em generic-call} is a {\em function-call}.  {\em Function-calls}
are matched to all {\em function-prototypes}, including
{\em generic-prototypes}, and those that end up matching just a
{\em generic-prototype} are {\em generic-calls}.

A {\em generic-call} is executed at compile-time and generates a list
of `\skey{included statement}s' that replace the {\em generic-call} in
the compilation.  The included statements are the {\em statements}
of the subblocks at the end of the {\em include-statements} executed
by the called generic function.  If several {\em include-statements}
are executed, the included statement lists they generate are concatenated
in execution order.

Within the included statements generated by an {\em include-statement}
the values of the {\em include-state\-ment}'s
{\em include-arguments} are substituted for the names of these
arguments.  These values must be known at compile-time within the scope
of the {\em include-statement}.  The substitutions depend on the
type of the argument variables as follows:
\begin{indpar}[0.5in]
\hspace*{-0.3in}\ttmkey{name}{include argument}
The argument name is replace by the sequence of lexemes represented by
the \TT{name}.  A {\em name-item} that has the syntax of a {\em word}
or {\em number} lexeme is represented by that lexeme, and all other
{\em name-items} are represented by {\em quoted-strings}.

\hspace*{-0.3in}\ttmkey{uns$x$}{include argument}
The argument name is replace by a single natural number lexeme.

\hspace*{-0.3in}\ttmkey{int$x$}{include argument}
The argument name is replace by a single decimal integer lexeme.

\hspace*{-0.3in}\ttmkey{float$x$}{include argument}
The argument name is replace by a single decimal floating point
number lexeme if the value can be represented exactly by that
lexeme.  Otherwise the argument name is replaced by the two lexeme
hexadecimal number constant representing the value exactly. 

\hspace*{-0.3in}\ttmkey{character}{include argument}
The argument name is replaced by the two lexeme
character constant representing the value. 

\hspace*{-0.3in}\ttmkey{string}{include argument}
The argument name is replaced by a single quoted string lexeme
representing the value.
\end{indpar}

An example is:
\begin{indpar}\begin{verbatim}
generic goo ( name N, name OP,
              character C, string S,
              int32 X, float64 Y, float64 Z )
    include ( N, OP, C, S, X, Y, Z ):
        n --> `N'
        int64 n = 0
        character c = C
        string s = S
        int32 x = X
        float64 y = Y
        float64 z = Z
        float64 v = x OP y
        float64 w = x * z OP y

goo ( `my variable', `"+"', C"<LF>", "Hi There",
      1,234, 1.5, 0.3 )
    // Equivalent to:
    //    n --> `my variable'
    //    int64 my variable = 0
    //    character c = C"<LF>"
    //    string s = "Hi There"
    //    int32 x = 1,234
    //    float64 y = 1.5
    //    float64 z = X"0.4CCCCCCCCCCCCC"
    //    float64 v = x "+" y
    //    float64 w = x "*" ( z "+" y )
\end{verbatim}\end{indpar}

The {\em generic-declaration} is parsed when first encountered
by the compiler, but the included statments are not
compiled.
This means that operators in unparsed form cannot be substituted
in included statements.  So the computation of {\tt w} in the
example substitutes in the parsed expression `{\tt (x) "*" (z OP y)}'
where {\tt OP} has not been identified as an operator by the parser.

Also note that substitution inside name constant brackets such as
\TT{`'} is allowed.

The `\TT{if }{\em compile-time-expression}' option
causes the {\em statements} to be included if and only if the
{\em compile-time-expression} evaluates to \TT{true}.  An example use is:
\begin{indpar}\begin{verbatim}
generic min-max ( name F, name C )
    include ( F, C ):
        function T result = F (| type T |) ( T x, T y ):
            include if not T is float:
                result = if:
                    (x) C (y):
                        result = x
                    (y) C (x):
                        result = y
            include if T is float:
                result = if:
                    (x) C (y):
                        result = x
                    (y) C (x):
                        result = y
                    else:
                        result = NaN
\end{verbatim}\end{indpar}

Only whole {\em statements} can be included, but {\em include-statements}
can be nested.  A nested {\em include-statement} does not have an
{\em include-argument-list} but instead inherits the {\em include-arguments}
of its containing {\em include-statement}.

If an {\em include-statement} $S$ has an {\em include-name} $N$, then
{\em include-statements} nested inside $S$ that do \underline{not}
have the {\em include-name} $N$ are treated as ordinary statements
and not as nested {\em include-statements}.  An example is:
\begin{indpar}\begin{verbatim}
generic compare function prototypes ( type T ):
    include X ( T ):
        generic compare function prototype ( name C )
            include ( C ):
                function bool r = ( T x ) C ( T y )
        compare function prototype ( "<" )
        compare function prototype ( "<=" )
        compare function prototype ( "==" )
        compare function prototype ( "!=" )
        compare function prototype ( ">=" )
        compare function prototype ( ">" )
\end{verbatim}\end{indpar}

The included statements that replace a generic call are compiled in the
current context, and \underline{not} the context of the
generic declaration.  The statements of the generic function
itself, and any default values in the generic prototype,
are compiled in the context of the generic declaration,
just as for an inline function.

If you want code compiled in another
context (\pagref{CONTEXT}), wrap that code in the body of an inline function
declared in that other context.  An example that implements a writable
parameter is:
\begin{indpar}\begin{verbatim}
module "my_module" as mymod
    define type P as read-write pointer to vector of float64
    P p = new
    // Parameter is stored in p.all
    // P and p are not visible in other modules.

    // function to allow reading of parameter
    // by other modules.
    //
    function float64 r = mymod my parameter:
        return p.all
\end{verbatim}\end{indpar}

As an additional feature of generics, whenever the word
`\TT{G\TMP*}' appears in the included code, it is replaced
by `\TT{G\TMP$n$}', where $n$ is a natural number unique
to the generic call within the compilation.  This allows
creation of names unique to the generic call.  Note that
`\TT{G\TMP*}' can be part of a name, and not the entire name,
so its replacement is not like the replacement of abbreviations.

The \TT{generate name} function (\pagref{GENERATE-NAME})
may be used to generate other names which can be substituted
for {\em include-arguments}.

\section{Clusters}
\label{CLUSTERS}

A \key{cluster} is a group of related variables.  One variable of
the cluster is the \mkey{base variable}{of cluster} of the cluster, and the
other variables have names that are derived from the
name of the base variable by adding {\em member-selectors}
to the end of the base variable name.  See \pagref{NAMES}.

Thus a cluster
is like a C/C++ structure, but it is a set of variables and not a
piece of memory.

More specifically, the members of the cluster can be named by
adding either a member name beginning with a `\TT{.}' or a
`\TT{[]}' bracketed list of
integer indices to
either the base variable name of the cluster or to another member name
of the cluster.  Two variable names with different base variable names
belong to different clusters.  The indices must be compile time
constants when the member is allocated and written, but may be run time
variables when the member is read.

Variables in clusters are thus organized into trees, with clusters
that have different bases being in disjoint trees.  Any variable in a cluster
can be considered
as the \mkey{root}{of subcluster} of a subtree of cluster members, and
the subtree is called a \key{subcluster}.

The main feature of clusters and subclusters
is that members are passed to or returned
from functions implicitly when their the root variable is named
explicitly.  Furthermore, non-root cluster members \underline{cannot}
be created except as results of function calls.

For example:
\begin{indpar}\begin{verbatim}
define type pointer pair as void
    // if pp is a pointer pair then:
    //   unsadr pp.begin is the offset of the first element
    //   unsadr pp.end is the offset just AFTER the
    //                 last element
    //   mem adr pp.base is the base address that
    //                   is added to the offsets
    //   *UNCHECKED* adr pp.base.adr is the address of
    //                                  pp.base
    //   type pp.type is type of elements pointed at

// Function to allocate a vector of n T's to the stack.
//
function ( stack pointer pair pp,
           unsadr pp.begin,
           unsadr pp.end,
           mem adr pp.base,
           *UNCHECKED* adr pp.base.adr,
           type pp.type ) =
        allocate to stack ( type T, uns32 n ):
    require ( zero value OK ( T ) )
    pp.type = T
    unsadr size = size of ( T ) * n
    pp = allocate to stack ( size )
        // This sets pp.offset, pp.base and
        // pp.base.adr.
    pp.begin = pp.offset
    pp.end = pp.begin + size
        // pp.offset is not returned to caller


// Prefix operator to dereference a pointer pair to read
// memory.
//
function ( mem pp.type out,
           *UNCHECKED* unsadr out.offset,
           mem adr out.base,
           *UNCHECKED* adr out.base.adr ) =
        "*" ( stack pointer pair pp,
              type pp.type,
              unsadr pp.begin,
              unsadr pp.end,
              *UNCHECKED* adr pp.base ):
    if:
        pp.begin < pp.end:
            out.offset   = pp.begin
            out.base.adr = pp.base.adr
        else:
            fatal error
                ( "Deferencing empty pointer pair." )

// Prefix operator to increment the begin pointer of a
// pointer pair.
//
function ( next pp.begin )
        "++" ( stack pointer pair pp,
               unsadr pp.begin )
      next pp.begin = pp.begin + size of ( pp.type )

// Assignment operator for pointer pairs.
//
function ( Q pointer pair pp2,
           unsadr pp2.begin,
           unsadr pp2.end,
           mem adr pp2.base,
           *UNCHECKED* adr pp2.base.adr,
           type pp2.type )
        = ( qualifiers Q,
            Q pointer pair pp,
            type pp.type,
            unsadr pp.begin,
            unsadr pp.end,
            *UNCHECKED* adr pp.base.adr ):
      pp2.begin = pp.begin
      pp2.end = pp.end
      pp2.base.adr = pp.base.adr
      pp2.type = pp.type

// Example usage:
//
function ...

    // Vector of 2 int32's is allocated and the elements
    // are set equal to 100 and 101.
    //
    pointer pair pp = allocate to stack ( int32, 2 )
    next ( * pp ) = 100
    ++ pp
    next ( * pp ) = 101
    . . . .
    // Vector of 1000 float64's is summed.
    //
    pointer pair ppf = allocate to stack ( float64, 1000 )
    ... set 1000 elements ...
    float64 sum = loop:
        initially:
            float64 partial sum = 0
            pointer pair ppf2 = ppf
        while ppf2.begin < ppf2.end:
            next partial sum = partial sum + * ppf2
            ++ ppf2
        finally:
            sum = partial sum
\end{verbatim}\end{indpar}\label{NEXT-CLUSTER-BASE-EXAMPLE}

Note that although the functions defining operations on a pointer pairs
are a long winded, usage of pointer pairs is compact and easy.
This is a general characteristic of the L-Language, and derives
from the fact that the functions automatically manage the members
of a cluster.

Cluster member names may be used as prototype parameter
names, with the root of these names also being a prototype
parameter.  This specifies that the parameters are related
by being in the same cluster.  The arguments with member names
\underline{must} not be given explicit values by function calls,
they must be omitted in the call itself, as they will be given
the values taken from members of the root value given in the call.
If the cluster members named as arguments
in the function prototype do not have corresponding members of the
root value given in the call,
the function prototype does not match the call unless the prototype
member has a default (see \pagref{DEFAULTS-TO} ).

When this is done for prototype results, the cluster root must similarly
be a either a result or argument, and the designated
members of the cluster are created and set from the results.
Again the cluster members \underline{must} be omitted in calls,
but will be automatically created.
Note that when this is done any qualifiers on the omitted cluster
members will be set by the prototypes.

If all result variables are cluster members, then calls
using the prototypes will have no explicit result variables,
but will create new members of existing clusters.  For example:
\begin{indpar}\begin{verbatim}
function ( bool v.nonneg ) = test sign ( int32 v ):
    if:
        v >= 0:
            v.nonneg = true
        else:
            v.nonneg = false

int32 x = 89
int32 y = -5
test sign ( x )
test sign ( y )
// Now x.nonneg exits and is true
// and y.nonneg exits and is false.
\end{verbatim}\end{indpar}

A variable whose underlying type is \TT{void} has no actual value
and must not be assigned one.  Such variables are only useful
as cluster and subcluster roots.  The `\TT{allocate to stack}'
function requires that its result be a variable whose underlying
type is \TT{void} (see \pagref{ALLOCATE-TO-STACK}).

Cluster roots and members may be implied next variable
(see \pagref{IMPLIED-NEXT-VARIABLES}).  Some members of a cluster
may be next variables while other members of the same cluster are
not.  The variables of a cluster are independent of each other
in this respect.

Cluster members may only be created as function call results.
A {\em result-declaration} of the form `\TT{next} {\em v}' where
{\em v} denotes a cluster member or root can only be used in
a function result prototype: 
see \pagref{IMPLIED-NEXT-VARIABLES}.

A cluster member may be explicitly passed as a result variable
or argument if it is the root of a subcluster that is being
created or used.  The matching prototype variable must
be a cluster root, and \underline{not} a cluster member,
within the prototype.  If the cluster member being passed is a
result variable, its matching prototype variable declaration must have the
underlying type \TT{void} or be a `\TT{next ...}' result.

The `\TT{qualifiers Q}' argument to the assignment operation
is assigned by implication to qualifiers of the `\TT{pointer pair}'
argument, and these qualifiers are added to the result.

In the above example `\TT{mem}' is a special builtin qualifier
which can be applied to variables.
See \itemref{BUILTIN-QUALIFIERS}.

The `\TT{mem}' qualifier\label{MEM}
has the special property that given a variable
\TT{v} of qualifier \TT{mem}, then if \TT{v} is allocated,
and \TT{v.base} of type \TT{adr} and qualifier \TT{*UNCHECKED*}
is allocated and assigned a value
and \TT{v.offset} of type \TT{unsadr} and qualifier \TT{*UNCHECKED*}
is allocated and assigned a value, then
the root \TT{v} is automatically
assigned the value located at the RAM address \TT{v.base + v.offset}.
It is an error in this case to explicitly assign a value to \TT{v}.
This is how \TT{out} gets its value from
\TT{out.base}, and \TT{out.offset}.

Similarly if \TT{v.adr} is allocated an assigned a value, then
the root \TT{v} is automatically
assigned the value located at the RAM address \TT{v.adr}.
This is how \TT{out.base} and \TT{pp.base} get their values from
\TT{out.base.adr} and \TT{pp.base.adr} respectively.

For details on the `\TT{mem}' qualifier see \itemref{THE-MEM-QUALIFIER}.

The `\TT{stack}' qualifier has the property that values with
this qualifier may not be passed out of a block with a free
stack.  This keeps stack addresses from escaping contexts in
which they are valid.  See Sections~\itemref{THE-STACK-QUALIFIER} and
\itemref{STACK-MANAGEMENT}.

A qualifier may be \ikey{inherited}{qualifier}\label{INHERITED-QUALIFIER}.
If an inherited qualifier
is applied to the root variable of a cluster
or subcluster, this inherited qualifier is automatically applied to all
the member variables in the cluster or subcluster.  This is not done
for non-inherited qualifiers.

The `\TT{stack}' qualifier is inherited.

Another example of a cluster with implied next variables is:
\begin{indpar}\begin{verbatim}
define type sequence as void
    // if seq is a sequence,
    // seq.count is the number of its elements
    // seq.type is the type of the elements
    // seq[0 .. seq.count - 1] are the elements

// Function to rotate the sequence right 1 position.
//
next seq.count, next seq[0 .. seq.count - 1]
    = right rotate ( sequence seq, unsadr seq.count,
                     type seq.type,
                     seq.type seq[0 .. seq.count - 1]:
    next seq[1 .. seq.count - 1] = seq[0 .. seq.count - 2]
    next seq[0] = seq[seq.count - 1]

// Example usage
//
    sequence s = ...
    rotate ( s )
\end{verbatim}\end{indpar}
Here the \TT{seq.count} and \TT{seq.type} arguments
specify types and member indices
of results and of arguments later in the argument list.  A call's actual
\TT{seq.count} and \TT{seq.type} arguments must be compile time values
in order to be so used.

A last example of the use of clusters is the implementation of
comparison operators so that
\begin{center}
\TT{(x~<~y)~<~z}
\end{center}
is the same as
\begin{center}
\TT{(x~<~y) AND (y~<~z)}
\end{center}
where \TT{y}, if it is an expression,
is not evaluated twice:\label{COMPARISON-RESULTS}
\begin{indpar}\begin{verbatim}
define type comparison result as void
    // if cr is a comparison result then:
    //   bool cr.value is the result of the comparison
    //   type cr.type is the type of the values compared
    //   cr.type last is the last value compared

// Comparison result of x < y where x and y are type T.
//
function comparison result cr, bool cr.value,
         type cr.type, T cr.last =
        (| type T |) ( T first ) "<" ( T last ):
    cr.type = T
    cr.last = last
    cr.value = first less than last

// Comparison result of x < y where x is a comparison result.
//
function comparison result cr, bool cr.value, type cr.type,
         T cr.last =
         ( comparison result cf, bool cf.value, type cf.type,
           cf.type cf.last ) "<" ( cf.type last ):
    cr.type = cf.type
    cr.last = last
    cr.value = cf.last less than last

// Implied conversion of comparison result to bool.
//
function Qs bool result =
    (| qualifiers Qs |) ( QS comparison result cr,
    bool cr.value, type cr.type, cr.type cr.last ):
    result = cr.value
\end{verbatim}\end{indpar}

Cluster variables can be grouped into `\skey{slice}s', see
\pagref{SLICE}.  A slice can be allocated and passed
as an argument as if it were a single variable.  When cluster
variables or slices containing {\em member-indexes} are allocated,
the {\em member-indexes} must be defined at compile time.
When these variables or slices are read, the
{\em member-indexes} can be run time.

\section{Builtin Qualifiers}
\label{BUILTIN-QUALIFIERS}

The builtin qualifiers are \TT{mem}, \TT{stack}, \TT{*UNCHECKED*},
and \TT{global}.
There is also a special class of qualifiers called trace qualifiers.

\subsection{The Memory Qualifier}
\label{THE-MEM-QUALIFIER}

The \ttkey{mem} qualifier is a protected qualifier that behaves
in a special way when it is given to a variable \TT{v}.
In this situation \TT{v} is a copy of a RAM memory value and
must be in a cluster that
has either:
\begin{enumerate}
\item
A variable \TT{v.adr} of type \TT{adr} with either of the qualifiers
\TT{mem} or \TT{*UNCHECKED*} that is the RAM address of \TT{v}.

\item
A variable \TT{v.offset} of type \TT{intadr} or \TT{unsadr} and
qualifier \TT{*UNCHECKED*}, and
a variable \TT{w.base} of type \TT{adr} and qualifier \TT{mem}
or \TT{*UNCHECKED*} where \TT{w} is either \TT{v} or an ancestor
of \TT{v} in the cluster (if there are several such ancestors, the
closest to \TT{v} is selected).
In this case the RAM address of \TT{v} is \TT{v.offset+w.base}.
If \TT{w.base} has qualifier \TT{mem} it must recursively obey these
rules (so there must be either a \TT{w.base.adr} variable
or \TT{w.base.offset} and \TT{u.base} variables where \TT{u}
is either \TT{w.base} or an ancestor of \TT{w.base} in the cluster, etc.).
\end{enumerate}
The the
variable \TT{v} must \underline{not} be given a value by an
assignment statement, but will instead be loaded with a value
from its RAM address.  It is called a `\key{RAM cache variable}'.

An example is:

\begin{indpar}\begin{verbatim}
// In C/C++:
//     struct foo_struct { int a, b, c }
//     typedef foo_struct * foo
//
// Here a cluster foo, foo.a, foo.b, foo.c
// where foo is an address.
//
define type foo as void
define type foo_ptr as adr
function foo x, *UNCHECKED* adr x.base,
         mem int32 x.a, *UNCHECKED* x.a.offset,
         mem int32 x.b, *UNCHECKED* x.b.offset,
         mem int32 x.c, *UNCHECKED* x.c.offset
        = "*" ( foo_ptr x ):
    x.base = x
    x.a.offset = 0
    x.b.offset = 4
    x.c.offset = 8

// Usage:
//
foo_ptr zp = ... // assign adr to zp
foo z = * zp     // Assign to z.base, z.a.offset, ...
... z.a ...      // Use z.a
next z.a = ...   // Write z.a

\end{verbatim}\end{indpar}

If a RAM cache variable is not used, it will not actually be loaded
from RAM.  If two RAM cache variables are explicitely given the
same address, the two variables will be treated as the same variable
(i.e., a variable with two names).  For example:

\begin{indpar}\begin{verbatim}
    mem int32 w
    adr w.adr = ...
    mem int32 v
    adr v.adr = w.adr
        // v and w are two names for the same variable.
\end{verbatim}\end{indpar}

If \TT{v} is a RAM cache variable, assigning a value to `\TT{next v}'
writes the value to RAM.  For example:

\begin{indpar}\begin{verbatim}
    mem int32 v
    adr v.adr = ...
    next v = ...       // Writes value to v.adr
\end{verbatim}\end{indpar}

If the original value of \TT{v} was never used, it will not be
read from RAM even \TT{v} is written in this way.

Because \TT{mem} is a protected qualifier, \TT{v} and the required
members of the cluster of which \TT{v} is a root
must be created as matches to result variables of a function.
So only functions can effect a load of RAM contents to a variable.

There is a special function of zero arguments, \TT{NULL}, of result
type \TT{adr}, that
references a block of 4,096 bytes of virtual memory that is
inaccessible and will cause a segmentation fault if referenced.


\subsection{The Stack Qualifier}
\label{THE-STACK-QUALIFIER}

The `\ttkey{stack}' qualifier is an inherited, prohibited,
protected qualifier
attached to offsets and addresses
returned by the builtin `\TT{allocate to stack}'
function (\pagref{ALLOCATE-TO-STACK}).
It is used to keep these from being stored in
non-stack memory and in stacks who lifetime exceeds that of the
memory the stack address points at.

The special property of the `\TT{stack}' qualifier is that it cannot
be used to qualify variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
or iteration variables in a {\em loop-assignment-statement}.
This is so that stack addresses pointing into a free stack
cannot outlive the free stack.
See Section~\itemref{STACK-MANAGEMENT} for more information.

Also, as a prohibited qualifier, a \TT{stack} value cannot be
passed as an argument to a function that does not expect a
\TT{stack} value.  For example:
\begin{indpar}\begin{verbatim}
stack adr sa = ...
adr ta = ...
function adr result = F ( adr arg ):
    . . . . . . . . . .
function adr result = G ( stack adr arg ):
    . . . . . . . . . .
adr xa = F ( sa ) // Illegal; F's arg does not have
                  // stack qualifier.
adr ya = G ( sa ) // Legal; G's arg has stack qualifier.
adr za = G ( ta ) // Legal; G's arg's stack qualifier has
                  // no effect (its not required).
\end{verbatim}\end{indpar}

\subsection{The \TT{*UNCHECKED*} Qualifier}
\label{THE-UNCHECKED-QUALIFIER}

The \TT{*UNCHECKED*} qualifier is a
required qualifier that must qualify the \TT{v.adr} or
\TT{v.offset} variables
associated with a variable \TT{v} that has the \TT{mem} qualifier.
See Section~\itemref{THE-MEM-QUALIFIER}.

The \TT{*UNCHECKED*} qualifier is also required for the result variable
of an unchecked conversion.  When used for a result variable of an
assignment, the value assigned need only be convertable to the type
of the variable by an unchecked conversion, instead of by a checked
conversion.

The \TT{*UNCHECKED*} lexeme is also used as the initial part some
names. An example is the \TT{*UNCHECKED* *ASSEMBLY*} assignment statement.

\subsection{Trace Qualifiers}
\label{TRACE-QUALIFIERS}

A \key{trace qualifier} permits values to be marked so that they
can be found (i.e., `traced') by garbage collectors
(and occassionally debuggers)
when they are stored in the
stack.  A trace qualifier may be declared by:

\begin{indpar}
\emkey{trace-qualifier-declaration}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{trace qualifier}
           {\em defined-qualifier-name} \\
        & ~~~~~ \TT{with base type}~~{\em type-name}
    \end{tabular}
\end{indpar}

The base type of a trace qualifier may be determined by the
function with the prototype:
\begin{center}
{\tt (type T) = \ttkey{base type of} ( qualifier Q )}
\end{center}
The value of any variable with the trace qualifier must be
\TT{*UNCHECKED*} convertable to a value of the base type.

It is common to add a trace qualifier to the statement that
defines a type you want to trace.  An example in which the
qualifier is \TT{Q} and the type is \TT{T} is:
\begin{indpar}\begin{verbatim}
trace qualifier Q with base type adr
define type Q T as adr
\end{verbatim}\end{indpar}
which causes all values of type \TT{T} in the stack to be
traced.

More specifically, when a value \TT{V} of a variable with the trace
qualifier \TT{Q} and base type \TT{B} is added to a stack,
\TT{V} converted to type \TT{B} is also
pushed into a (virtual or physical) \TT{Q}-stack of values of
type \TT{B}.
When the stack containing \TT{V} is freed, the corresponding
value in the \TT{Q}-stack is popped.  There is a \TT{Q}-stack
associated with every process and every global area.
Using functions in the
subroutine library (see TBD), these \TT{Q}-stacks can be read.

While a value may be pushed into a stack more than once,
a value will not be pushed if the compiler can prove it is already
in the stack.  Thus given the definitions above, in
\begin{indpar}\begin{verbatim}
T v = ...
T w = v
\end{verbatim}\end{indpar}
the first statement may push the value of \TT{v} to the \TT{Q} stack
but the second statement will not push the value of \TT{w} on
the grounds that it is already in the stack.

\subsection{The Reload Statement}
\label{THE-RELOAD-COMMAND}

The reload statement has the syntax:
\begin{indpar}
\emkey{reload-statement} ::=
    \ttkey{reload} {\em qualifiers} \{ \TT{,} {\em qualifiers} \}\STAR{} \\
\emkey{qualifiers} ::= {\em qualifier} $|$ {\em qualifier-set} \\
\emkey{qualifier} ::= {\em expression} evaluating to a qualifier \\
\emkey{qualifier-set} ::= {\em expression} evaluating to a qualifier set
\end{indpar}

This statement declares the values of all variables with the designated
qualifiers to be out-of-date and unusable.  If any of these variables
is used subsequently, statements to recompute the variable value
will be inserted automatically into the code at the point of the
\TT{reload} statement.  If this is not possible the compilation will
be in error.

As a special case, if a variable that is declared to be out-of-date,
\TT{v}, has the `\TT{mem}' qualifier, and is in
a cluster that causes \TT{v} to be loaded from memory
(as per Section~\itemref{THE-MEM-QUALIFIER}), then if \TT{v} is declared
to be out-of-date, recomputing \TT{v} just means that \TT{v}
is reloaded from RAM.  The possibility that software cache
variables (with the \TT{mem} qualifier) will become out-of-date because
the RAM locations they cache have changed is the reason the \TT{reload}
statement exists.

The statement
\begin{center}
\TT{reload mem, mem dependent}
\end{center}
is commonly used to declare all
variables that act as software caches of memory, and all variables
that should be updated when the caches are updated, to be out-of-date.

Note that variables computed from out-of-date variables are \underline{not}
declared to be out-of-date.

If an out-of-date variable value is not used after the \TT{reload} statement,
it is not recomputed.

Variable values are recomputed in the same order as they were
originally computed.  How each variable is recomputed depends upon
how it was originally computed.

If a variable \TT{v} was originally computed by
a {\em simple-assignment-statement}
of the form `{\em type} \TT{v =} {\em expression}', then if
no input to {\em expression} has been recomputed, \TT{v} does not
need to be recomputed.  Otherwise \TT{v} is recomputed by re-executing
the assignment statement.

If a variable without a \TT{mem} qualifier needs to be
recomputed and was computed by other than
a {\em simple-assigment-statement}, it is a compile error if the
variable is marked out-of-date and later used.

The \TT{reload} statement behaves like an executable statement but
it has some unusual properties when it is executed inside a
nested subblock.  First, it declares out-of-date any variable with
the given qualifiers that is visible in its subblock \underline{and any
containing block}.
Second, it will recompute any out-of-date variable in its subblock
\underline{or any containing block} that may be used after the
\TT{reload} statement executes.
Third, when it recomputes variables, it overwrites
the place the variable is stored, rather than allocating a new
place as would a `\TT{next~}{\em variable-name}' expression.
These properties allow `\TT{reload Q}' to appear in an inline
or conditional subblock.

\section{Memory Write Statements}
\label{MEMORY-WRITE-STATEMENTS}

Statements that write memory make use of cluster structures
similar to those used with
\TT{mem} qualifier variables:
see Section~\itemref{THE-MEM-QUALIFIER}.

Specifically, memory needs to be addressed.  This is done by either
of the following methods of specifying a RAM address:
\begin{enumerate}
\item
An `\key{address variable} \TT{va}
of type \TT{adr} with either of the qualifiers
\TT{mem} or \TT{*UNCHECKED*} that contains the RAM address.
If \TT{va} has qualifier \TT{mem} it must obey
the rules of Section~\itemref{THE-MEM-QUALIFIER}.


\item
An `\key{address variable}' \TT{vo} of type \TT{intadr} or \TT{unsadr} and
qualifier \TT{*UNCHECKED*} in a cluster, and
a variable \TT{vb.base} of type \TT{adr} and qualifier \TT{mem}
or \TT{*UNCHECKED*} where \TT{vb} is either \TT{vo} or an ancestor
of \TT{vo} in its cluster.
In this case the RAM address is \TT{vo+vb.base}.
If \TT{vo.base} has qualifier \TT{mem} it must recursively obey
the rules of Section~\itemref{THE-MEM-QUALIFIER}.

\end{enumerate}

An address variable may be the member \TT{v.adr} or \TT{v.offset}
of a cluster with RAM cache variable \TT{v}.  In this case the
address variable is said to be the `\mkey{address}{of RAM cache variable}'
of the RAM cache variable \TT{v}.

\subsection{Single Value Write Statements}
\label{SINGLE-VALUE-WRITE-STATEMENTS}

The form of a single valued write statement is:

\begin{indpar}
\emkey{single-value-write-statement} ::=
    \TT{*WRITE*} {\em value-variable} {\em address-variable}
\end{indpar}

The value in the {\em value-variable} is written to the RAM address
in the {\em address-variable}.  If the {\em address-variable} is the
address of a RAM cache variable \TT{v}, the write statement does
\underline{not} update \TT{v} or create `\TT{next v}'.

\subsection{Memory Copy Statements}
\label{MEMORY-COPY-STATEMENTS}

The form of a memory copy statement is:

\begin{indpar}
\emkey{memory-copy-statement} ::=
    \TT{*COPY*} {\em source-variable} {\em destination-variable}
    		{\em length-variable}
\end{indpar}
Bytes are copied from the RAM address in the {\em source-variable}
to the RAM address in the {\em destin\-ation-\EOL variable}.
The number of bytes copied is in the {\em length-variable},
which must be of the \TT{unsadr} type.

If the source address is greater than the destination address,
the bytes are copied in ascending address order.  If the
source address is less than the destination address,
bytes are copied in descending address order.  If the two
addresses are equal, bytes may or may not be copied.  The effect of
all this is to copy regions of memory correctly even if they
overlap.


\subsection{Memory Set Statements}
\label{MEMORY-SET-STATEMENTS}

The form of a memory set statement is:

\begin{indpar}
\emkey{memory-set-statement} ::=
    \TT{*SET*} {\em value-variable} {\em address-variable}
    		{\em length-variable}
\end{indpar}
The `set length' is stored in the {\em length-variable} which must
be of \TT{unsadr} type.  As long as the set length is not zero,
this statement performs a \TT{*WRITE*} operation on its
first two arguments, and then increments the address by
the length of the type of the value, and decrements the set length
by one.

\subsection{Atomic Memory Statements}
\label{ATOMIC-MEMORY-STATEMENTS}

An \key{atomic-memory-statement} is a generalization of
the classic compare-and-set instruction.  It is a block assignment
statement that executes a sequence of specialized instructions:

\begin{indpar}
\emkey{atomic-memory-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \TT{( uns32 count, adr bad address ) = }\ttkey{*ATOMIC*} \TT{:} \\
	\TT{~~~~}{\em lock-instruction}\STAR{} \\
	\TT{~~~~}{\em compare-instruction}\STAR{} \\
	\TT{~~~~}{\em write-instruction}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{lock-instruction} ::= \ttkey{*LOCK*} {\em lock-variable} \\
\emkey{compare-instruction} ::= \ttkey{*COMPARE*} {\em compare-variable}
						  {\em address-variable} \\
\emkey{write-instruction} ::= \\
\hspace*{0.2in}\begin{tabular}[t]{rl}
        & \TT{*WRITE*} {\em value-variable} {\em address-variable} \\
    $|$ & \TT{*COPY*} {\em source-variable} {\em destination-variable}
    		      {\em length-variable} \\
    $|$ & \TT{*SET*} {\em value-variable} {\em address-variable}
    		     {\em length-variable} \\
    \end{tabular}
\end{indpar}

The special instructions,
which make use of clusters (Section~\itemref{CLUSTERS}),
and are as follows:
\begin{indpar}[0.4in]
\hspace*{-0.2in}{\em \bf Lock-Instruction}.
The {\em lock-variable} is of type \TT{uns32}
and identifies the lock.
The lock is a binary test-and-set lock provided by the
underlying system.  Locks are allocated to sets of processes
that share memory, so that if any process in the set gets
the lock, other processes in the set cannot.

The lock instruction sets the lock and succeeds if the lock
was not already set, and otherwise just fails.

When the {\em atomic-assignment-statement} terminates, either
successfully or when it fails, all locks gotten are released in
reverse order.

\hspace*{-0.2in}{\em \bf Compare-Instruction}.
The compare
instruction reads the value at the {\em address-variable} designated
address and compares
it to the value of the {\em compare-variable}.  The instruction
succeeds if the values are equal, and fails otherwise.

The {\em compare-variable} may be a RAM cache variable whose
address is the {\em address-variable}.  The RAM cache variable
is not changed even if the value read does not match its value.

\hspace*{-0.2in}{\em \bf Write-Instructions}.
These do what they normally do, except they are all dry-run 
before any actually execute.  During the dry-run one of these
instruction fails if any memory reference it makes would fail
were the instruction actually executed.  In particular, if any
piece of memory is paged out or not in RAM, the dry-run fails.
\end{indpar}

The `\TT{count}' value returned by the {\em atomic-memory-statement}
equals \TT{0} if the statement succeeds, or is the number of the
first failed instruction in the statement block if the statement
fails (the first instruction is number \TT{1}).
The `\TT{bad address}' value is \TT{0} unless the block
fails because of a memory fault, in which case the `\TT{bad address}'
value is set to the faulting address.  One usually deals with a faulting
address by reading it with a normal instruction if it is a read fault,
or writing it with a normal instruction that does not change its
value if it is a write fault (this may require a compare and set
assembly instruction),
and then retrying the \TT{*ATOMIC*} block.

Interrupts of all kinds are disabled during the execution of an
{\em atomic-memory-statement} so the statement will execute as
fast as the underlying hardware will allow.  However, this means
that memory paging is disabled, so instructions will fail if
they page fault.  This is the reason for the dry-run of the
{\em write-instructions}, to be sure they will not fail
when they actually write data.

A system may put restrictions on the size of the value in
a {\em length-variable}, and on the number of instructions
in an \TT{*ATOMIC*} block, in order to ensure that interrupts
are not disabled for very long.  Violation of these restrictions
causes a \TT{*ATOMIC*} block instruction fault that is distinct
from \TT{*ATOMIC*} block failures described above (such violations
are not recoverable).

\section{Stack Management}
\label{STACK-MANAGEMENT}

Each execution thread has a stack that is not in any other
stack.  Each out-of-line function
execution is a block execution that has a stack which is
by default a substack of the thread in which the function
execution is running.  Each subblock in turn has a stack
which is by default a substack of the stack of its containing block.
And each global area has a stack that is not in any other stack.

Conceptually, the assignment statements in a block each allocate memory for
their variable to the current block stack and copy values to these
variables.  As noted above (Section~\itemref{ASSIGNMENT-STATEMENTS}),
the memory and associated copies may be
optimized away in some cases.

Stacks are either free or bound.\label{FREE-STACK}
A bound stack is a substack that is
not deallocated from memory until its smallest containing free stack is
deallocated.  The main reason this is important is that stack addresses
can be passed out of a block with a bound stack to its containing block,
but cannot be passed out of a block with a free stack to its containing
or calling block.  This is implemented by giving certain
variables the `\TT{stack}' qualifier: see
Section~\itemref{THE-STACK-QUALIFIER}.

Stacks of out-of-line function executions
(\pagref{OUT-OF-LINE-FUNCTIONS}),
out-of-line assignment statement blocks
(\pagref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}),
and
compile-time assignment statement blocks
(\pagref{COMPILE-TIME-ASSIGNMENT-STATEMENTS})
are free, and variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
may \underline{not} have the `\TT{stack}' qualifier.

Stacks of loop iteration subblocks are free, and
variables in the {\em result-variable-list}
and iteration variables
of a {\em loop-assignment-statement} may not have the `\TT{stack}'
qualifier.  However, stacks of loop `\TT{initially}' and `\TT{finally}'
subblocks are not free.

Global area stacks (see Section~\itemref{GLOBAL-AREAS}) are free,
but are never deallocated and make no use of the `\TT{stack}'
qualifier.

All other stacks are bound.  Memory allocated to them
by the `\TT{allocate to stack}' function (\pagref{ALLOCATE-TO-STACK})
is actually
allocated to their smallest containing free stack, and not deallocated
until that free stack is deallocated.

Free stacks are relocatable and can be moved.
Substacks cannot move independently,
but move whenever their smallest containing free stack moves.
Any stack address is relative to its containing free stack,
which is the current free stack at the time executable code uses
the stack address.  To accommodate this builtin memory read-write
functions will not only accept an \TT{adr} value as a RAM address,
but also accept a RAM address consisting of an \TT{unsadr}
offset within the stack and a stack base address that is itself
stored in RAM.  See Sections~\itemref{THE-MEM-QUALIFIER}
and \itemref{STACK-MEMORY-ALLOCATION}
for details.

There are a couple of situations in which free stacks move.

Memory of runtime determined size can be allocated to the end of
a stack by the `\TT{allocate to stack}' and `\TT{allocate to global}'
functions described below, and such may
require that the smallest containing free stack
be moved to a memory region where there is more free memory available.

In a program being debugged, free stacks may be saved after they are no
longer needed by the program, in order to permit them to be analyzed
by a debbugger if the program detects an error.  In this situation
free stacks are allocated to a very big circular buffer, and overwritten
after they are no longer needed by the program.  It may happen that
a free stack whose block is still running is in the way of allocating
a new stack to the circular buffer, in which case the still running
block's free stack may be moved.

Lastly, global area stacks (\pagref{GLOBAL-AREAS})
may be deallocated when programs that
can reference them are still running, or may not yet be allocated
when these programs run.  Deallocated global area stacks are treated as if
they were allocated to inaccessible memory, so deallocating these stacks
is like moving them to inaccessible memory, and referencing
them when they are deallocated gives a memory fault.


\subsection{Unwind Blocks}
\label{UNWIND-BLOCKS}

\ikey{Unwind blocks}{unwind block} are executed only when their
containing block terminates:

\begin{indpar}
\emkey{unwind-block}
    ::= \begin{tabular}[t]{l}
	\ttkey{*UNWIND*}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

Specifically, when an unwind block is encountered while
executing its containing block, the unwind block is marked
as enabled, but is skipped.  Then when the containing block
terminates, all its enabled unwind blocks are executed in
the reverse order of that in which they were enabled.

Unwind blocks are used to close or deallocate things that were opened.
For example, right after a statement that opens a file there may be
an unwind block that closes the file.  This ensures that the file
will be closed even if the block that opened it terminates later
prematurely with an error, such as a memory fault.

\subsection{Throw and Catch}
\label{THROW-AND-CATCH}

\TT{*THROW*} and \TT{*CATCH*} statements are used to implement
exceptions, i.e., abnormal termination.

\begin{indpar}
\emkey{throw-statement} ::= \TT{*THROW*} \\[1ex]
\emkey{catch-statement} ::= \TT{*CATCH*}
\end{indpar}

The \TT{*THROW*} statement causes its containing block to
\ikey{terminate abnormally}{abnormal termination}.
When a block terminates abnormally, its containing
block is also terminated abnormally.

\ikey{Normal termination}{normal termination}
of a block occurs at the end of the block if
the block has not executed a \TT{*THROW*} or an abnormally
terminating subblock.

Any enabled \TT{*UNWIND*} subblocks of an abnormally terminating
block are executed in reverse order, just as they would be if
the block were terminating normally.  No other part of the block
is executed.

If an \TT{*UNWIND*} subblock executing in an abnormally terminating
containing block \TT{B}
executes a \TT{*CATCH*} statement, the termination of this
containing block \TT{B}
is changed from abnormal to normal.  This means
that \TT{B}'s containing block \TT{C} will resume when the now
normally terminating block \TT{B} finishes terminating.
However, \TT{B} will not execute anything but enabled \TT{*UNWIND*}
subblocks, as it is still terminating.

Machine errors, i.e. memory segment faults, invoke callable functions
which can record error information and execute a \TT{*THROW*}.
Similarly detected programming or data errors can record
error information and execute a \TT{*THROW*}.  An \TT{*UNWIND*}
block can look at recorded error information and decide whether
or not to execute a \TT{*CATCH*}.

If a block has result variables it must assign, then these need not be
assigned if the block terminates abnormally, as they will not
be visible to enabled \TT{*UNWIND*} blocks.  However, if a block \TT{B}
that is terminating abnormally executes a \TT{*CATCH*} statement in
one of its \TT{*UNWIND*} subblocks,
all result variables that block \TT{B} must assign must be given values, even
though part of block \TT{B} may not have executed.  The compiler
will check this, and will only permit code that passes straight forward
compiler checks.

There are two ways to ensure correct code.  The first is to 
set all block result variables either in or before the
\TT{*UNWIND*} block that contains the \TT{*CATCH*} statement.
The second is to use the special variable
\ttkey{*LAST-ENABLED-UNWIND*} inside the \TT{*UNWIND*} block.
This variable is \TT{true} if and only if the \TT{*UNWIND*}
block is the last \TT{*UNWIND*} block enabled in its containing
block, and so if the variable is \TT{true}, any containing
block result variables set after the \TT{*UNWIND*} block need to be
set.  The compiler will accept a statement of the form:
\begin{indpar}\begin{verbatim}
if:
    *LAST-ENABLED-UNWIND*:
        result-variable-1 = ...
        result-variable-2 = ...
	. . . . . . . . . . . .
\end{verbatim}\end{indpar}
where the result variables set are those set after the \TT{*UNWIND*}
block, thus satisying the requirement that all result variables be set.

[TBD: Maybe default clauses should exist for all block style
assignment statements and execute at the beginning, setting
values for result variables that will be available outside
the block if the block does not set any values itself.]

\subsection{Stack Memory Allocation}
\label{STACK-MEMORY-ALLOCATION}

The `\ttkey{allocate to stack}' function allocates \TT{N} bytes of
memory to the current free stack and returns its offset within
the stack and the address of the stack base address:

\begin{indpar}\tt\begin{tabular}{l}
function T result, \\
~~~~~~~~~stack *UNCHECKED* unsadr result.offset, \\
~~~~~~~~~stack mem adr result.base, \\
~~~~~~~~~*UNCHECKED* adr result.base.adr = \\
~~~~\ttkey{allocate to stack} ( type T, unsadr N ) \\
~~~~~~~~[| underlying type of T == void |]
\end{tabular}\end{indpar}\label{ALLOCATE-TO-STACK}

Here `\TT{result.offset}' is the offset of the \TT{N} bytes within the
stack, `\TT{result.base}' is the base address of the stack, and
stack, `\TT{result.base.adr}' is the address of where this
base address is stored in RAM.  The first and last of these
are fixed but `\TT{result.base}' may change when the stack is
moved.

The returned values use
the `\TT{stack}' qualifier (see \itemref{THE-STACK-QUALIFIER})
and `\TT{*UNCHECKED*}' qualifier (see \itemref{THE-UNCHECKED-QUALIFIER}).

The memory is freed when the free stack to which it is allocated
is freed (\itemref{STACK-MANAGEMENT}).
The memory containing the \TT{base} value may also be
freed at this time.  The inherited `\TT{stack}' qualifier is used to
ensure that addresses of these values cannot survive the free stack:
see \itemref{THE-STACK-QUALIFIER}.

The memory allocated is always aligned on an \TT{8} byte boundary.

If you want a different alignment you can use:

\begin{indpar}\tt\begin{tabular}{l}
function T result, \\
~~~~~~~~~stack *UNCHECKED* unsadr result.offset, \\
~~~~~~~~~stack mem adr result.base, \\
~~~~~~~~~*UNCHECKED* adr result.base.adr = \\
~~~~\ttkey{allocate to stack} \\
~~~~~~~~~~~~( type T, unsadr N, unsadr O, unsadr A ) \\
~~~~~~~~[| underlying type of T == void |]
\end{tabular}\end{indpar}

where \TT{A} must be a power of \TT{2} not greater than \TT{64}.
This will align the \TT{O+1}'st
byte of the allocated memory block
at an address which is a multiple of \TT{A}\,.
Free stacks are always allocated on a \TT{64} byte boundary.

The `\TT{allocate to stack}' inline functions may move stackes and
therefore executes a `\TT{reload mem, mem dependent}' statement.


\subsection{Global Areas}
\label{GLOBAL-AREAS}

A global area is like the stack frame of a function that has no
arguments or return value, except that after this function executes,
the global area remains allocated and its variables can be referenced
by other code.  The syntax is:
\begin{indpar}
\emkey{global-area-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	{\em global-area-option}\STAR{}
	\TT{global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular} \\
\emkey{global-area-option} ::= \ttkey{*COMPILE-TIME*}
                           $|$ \ttkey{*COMPILE-TIME-ONLY*}
\end{indpar}

Several such blocks may have the same {\em global-area-name},
as long as no {\em variable-name} appears in more than one of these blocks.

In order to be accessed a global area must be named in an `\TT{extern}'
statement:
\begin{indpar}
\emkey{extern-global-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	\TT{extern} {\em global-area-abbreviation}
	            \TT{is global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em extern-variable-statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{extern-variable-statement} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & {\em variable-abbreviation} \TT{is}
          {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\end{indpar}

A variable with {\em variable-name}
\TT{V} in a global area with {\em global-area-abbreviation}
\TT{A} may be named as \TT{A.V}, or if the variable has its own
{\em variable-abbreviation} \TT{VA},
this by itself (and \underline{not} \TT{A.VA})
may be used to name the variable.  An abbreviation is only effective
withing the scope of the `\TT{extern}' statement that defines it.

A variable in an
{\em extern-variable-statement} must match its corresponding
{\em global-area-block} variable with respect to type and qualifiers
in the same manner as a function prototype argument variable
matches a function call variable.

The {\em global-area-block} containing \TT{A.V} need not be compiled
or linked before the {\em extern-global-block} referencing
\TT{A.V} is compiled or linked.  This means a runtime reference
can be made to \TT{A.V} when it does not exist.  Such a reference
will incure a runtime error, typically a segmentation fault.

Memory within a global area can be allocated by:

\begin{indpar}\tt\begin{tabular}{l}
( T result, \\
~~global *UNCHECKED* unsadr result.offset, \\
~~mem adr result.offset.base, \\
~~global *UNCHECKED* adr result.offset.base.adr  ) = \\
~~~~\ttkey{allocate to global} ( type T, unsadr N ) \\
~~~~~~~~[| underlying type of T == void |]
\\[1ex]
( T result, \\
~~global *UNCHECKED* unsadr result.offset, \\
~~mem adr result.offset.base, \\
~~global *UNCHECKED* adr result.offset.base.adr  ) = \\
~~~~\ttkey{allocate to global} \\
~~~~~~~~~~~~( type T, unsadr N, unsadr O, unsadr A ) \\
~~~~~~~~[| underlying type of T == void |]
\end{tabular}\end{indpar}\label{ALLOCATE-TO-GLOBAL}

Here \TT{A} must a power of \TT{2} not greater than \TT{64}.
Global areas are allocated on a \TT{64} byte boundary and
may be moved during execution.

Global area variables \underline{cannot} be written to, but memory allocated
by `\TT{allocate to global}' can be.

The `\TT{allocate to global}' function plays the same role for
global areas as the `\TT{allocate to stack}' function does for
stacks, accept that the address gets the \TT{global} qualifier
instead of the \TT{stack} qualifier.  The \TT{global} qualifier
is a protected, inherited qualifier
with \underline{none} of the special `\TT{stack}'
qualifier properties, and normally has no effect on code.

The `\TT{allocate to global}' inline functions may move
global areas and threfore executes a
\begin{center}
\TT{reload mem, mem dependent}
\end{center}
statement.

Global areas are run time by default.
The code of a run time
global area block is executed when the file containing it is
loaded, and the stack of the area is allocated and defined when
the global area block is executed.
Global areas may be deallocated or moved during execution.
References to a global area
that is not yet allocated or that has been deallocated cause runtime
errors (typically segmentation faults).

Global areas may also be made compile time, or both compile and run time,
by use of the \TT{*COM\-PILE-\EOL TIME-\EOL ONLY*} or \TT{*COMPILE-\EOL TIME*}
{\em global-\EOL area-\EOL options} above.  For a compile time
global area, global area blocks are executed in the compiler immediately
after the block compiles, and the global area stack exists in the compiler.
If the global area is also run time, its
block code will be re-executed in the run time environment when the
file containing it is linked, and might produce different stack contents
for the area than the compile time version of the area.

\section{Memory Channels}
\label{MEMORY-CHANNELS}

OLD STUFF: REVISE.

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
structured set of elements each associated with a member of
some data set.  Each window element contains a
\key{block descriptor} that holds the address and length of the
memory block that contains the data associated with the element.
Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
The window has a \key{reference point}, and window elements are addressed
relative to this reference point.  There are shift operations that move
the reference point to a nearby window element.

Although we talk about blocks here, a block can be just a numeric array
element, and can be as small as a single bit.  Although we talk about
each element of a memory channel window having its own block descriptor,
an actual memory channel may use only block group descriptors, each of
which functions as a group of more than one individual element
block descriptor.

A memory channel is stored in a cluster.  As such it is mostly an
inline construction, though it can be passed to or returned from a
function, and the function can be all or partly out-of-line.

The most common type of memory channel has a window that appears to be
an array with \ttikey{.di\-men\-sions}{dimensions!of memory channel},
\ttdmkey{lower\_bound}{of memory channel}\TT{[}$i$\TT{]},
and \ttdmkey{upper\_bound}{of memory channel}\TT{[}$i$\TT{]}
being memory channel members.  Such are called
\key{array windows}.
If the memory channel cluster name is $M$, the window elements are
referred to by $M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]},
with $M$\TT{[0,0,}\ldots\TT{]} being the \key{reference point}.

The reference point can be shifted along any of the window's
dimensions by the command
\begin{center}
$M$\ttdkey{center}\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]}
\end{center}
This shifts
the window so that what was
$M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]} becomes
$M$\TT{[0,0,}\ldots\TT{]}.

Creating memory channels and completely reseting their reference points
are specific to the type of memory channel, and are not covered in
this section.

For most kinds of memory channels, block descriptors are computed
automatically when channel is created, when the window is
shifted, or when the data of
a neighboring window element is arrives from memory.
Immediately after a block descriptor is created, a read-ahead of
the block is initiated.  This read-ahead overlaps computation that
does not use the block contents.

If a memory channel accesses arrays stored in memory,
the channel block descriptors can be computed from the array coordinates
of the reference point.  Other memory channels use the contents
of a block to compute the block descriptors of neighboring blocks
in the window.

An example of the latter is a binary tree memory channel.
Let $M$ be such a channel, and let `\TT{.L}' denote the left
child of a binary tree element, `\TT{.R}' the right child, and
`\TT{.P}' the parent.  Then $M\!$\TT{.L.R} denotes the right
child of the left child of the reference point, $M\!$\TT{.P.L}
denotes the left child of the parent of the reference point,
and $M\!$\TT{.P.L.center} moves the reference point to this last element.
The window of such a memory channel might contain the depth 2
subtree of the reference point plus that closest 4 ancestors of the
reference point if these have been visited.  When the reference
point is moved, as soon as the reference point element has been
read from memory, the descriptors for its children are built and
the read of the children is initiated in parallel with other
computation.  When the children arrive from memory, the descriptors
of their children are built and reads of the data pointed at
are initiated.\footnote{All this can actually be done with modern
hardware: code is executed to read the reference point children and initiate the
reads of their children, and a modern processor will automatically
save the code that
executes when a read of a reference point child completes and execute
other code in parallel until the read does complete.}

Some standard memory channel types are built into the L-Language.
Others can be defined by users.

\section{To Do}

How can dynamically initialized locations be static.

Indirect address protocol.

Define `compile-time function' as a function that can only be
called at compile-time.

Add `\TT{no} {\em function-term}' as a way of saying
`{\em function-term} \TT{( false )}'.

If \TT{V} is the name of a repeatable variable (that may also
be omittable), then:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt unsadr V.\ttmkey{count}{of {\tt variable name}} } \\
Number of of times the variable name \TT{V} appears in the unfolded
pattern.  This is the number of times the {\em pattern-term} containing
the variable appears.  It is \TT{1} if the term is neither
replicated or omitted, and \TT{0} if it is omitted.

\hspace*{-0.3in}{\tt $T$ V\ttmkey{[$i$]}{of {\tt variable name}} } \\
The value of the $i$+1'st occurance of \TT{V} in the unfolded pattern.
The index $i$ may be computed at run time, and has the range
\TT{0~..~V.count-1}.
$T$ is the type of the variable given in the {\em pattern-term}.
It is an error to use an index value that is out of range.


\end{indpar}

If \TT{V} is the name of a variable that may be omitted but not
repeated, then:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt bool V.\ttmkey{present}{of {\tt variable name}} } \\
True if the variable is present, and false if not.

\end{indpar}

In addition, if a variable can be omitted but not repeated, a default expression
must be given for the variable in a `\ttkey{defaults to}'
{\em conditioning-expression}.%
\label{DEFAULTS-TO}
If the variable \TT{V} is omitted, this
expression will be used at run time to compute the variable's value,
and `\TT{V.present}' will be set to `\TT{true}'.

\label{INDIRECT-ADDRESS-PROTOCOL}

Threads.
\label{THREADS}

\appendix

\section{Aliasing Hardware}
\label{ALIASING-HARDWARE}

The ultimate solution to the aliasing problem is new hardware.
At its simplest, registers, which currently hold a datum,
are replaced by triples of registers which hold a datum,
an address, and selection codes.  The register datum equals the value
of the memory location at the register address.  The selection
codes determine which part of this memory location is read or written
when the register is read or written.  If any memory location is
changed, the address of the location is checked against all the
register addresses, and if any match, the corresponding register
data are changed.

This is, however, not sufficient, because sometimes one register
address is a function of another register's datum.  For example,
consider the unchecked code:
\begin{indpar}[0.5em]\begin{verbatim}
struct S { ...; int32 m; ... }
S * * x
S * *& y = * x
int32 *& z = y->m
\end{verbatim}\end{indpar}
If we consider \TT{x}, \TT{y}, and \TT{z} to be registers,
the address of \TT{y} equals the value of \TT{x}, and the
address of \TT{z} equals the value of \TT{y} plus the offset of
\TT{m} in \TT{S}.

If the value of \TT{x} changes, this changes the address of \TT{y},
which may change the datum of \TT{y} and that may change the value
of \TT{y}.  If the value of \TT{y} changes, this changes the address
of \TT{z}, which may change the datum and value of \TT{z}.

The way we accommodate this is to use the selection codes of \TT{y}
to specify that the address of \TT{y} contains the value of \TT{x}
as an additive component, so
that if the value of \TT{x} is changed by adding $\Delta$\TT{x}
then the address of \TT{y} should be changed by adding $\Delta$\TT{x}.
And similarly the selection codes
of \TT{z} specify that the address of \TT{z}
contains the value of \TT{y} as an additive component.

So why should we bother with automatically updating
additive inclusions of one value in the
address of another value, and not bother with other expressions.
The reason is that expressions such as
`\TT{(*x)->m}' are likely to be reused frequently in code (actually,
in automatically generated code) and
therefore need to be cached, whereas an expressions of the form
`\TT{c*d}' will be reused comparatively rarely code
and therefore are not worth special hardware.


\bibliographystyle{plain}
\bibliography{layered-l-2012-language}

\printindex

\end{document}

