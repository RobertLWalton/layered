% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{\,\textsuperscript{p\pageref{#1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}


\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

August 23, 2016
 
\end{center}

{\small \tableofcontents}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language.  See the Introduction to the Layered
Programming Languages for basic syntax and for an overview of the related
Middle Layer M-Language and Higher Layer H-Language (these overviews
have not yet been written).

The L-Language is intended to be a target language for compilers of
higher level languages.  As such it is optimized first to be an easy to 
use as a target language, and second to be easy to
compile into reasonably efficient debuggable assembly language code.

The L-Language is similar to the C programming language
differs in the following ways:

\begin{enumerate}

\item
L-Language facilitates isolating non-type-safe code into small inline functions.

\item
All L-Language data types are builtin number types or subtypes of
builtin number types.  All data managed directly by L-Language consists
of single numbers allocated to the stack.

Other memory is handled by code
encapsulated in small non-type-safe inline functions by the programmer.
Memory references other than those to single stack allocated numbers
are treated in a manner reminiscent of input/output.

\item
The type `\TT{type}' is first class, is a subtype of integers, and
is assigned a unique constant small integer value for each type.  Constant
argument values, such as the value of a `\TT{type}' valued
argument, can be used to select overloaded functions.

\item
Most L-Language functions are inline.  Out-of-line functions can be
called using a block syntax that mirrors the overhead involved in
manipulating an argument stack in memory.

\item
L-Language uses a single-assignment style of program structure
to encourage
efficient code that leaves an audit trail for debugging in the stack.
Partial evaluation of expressions and inline code is supported without
compromising debuggability.

\item
L-Language allows code to be compiled at run-time just before
it is run, for extra efficiency.

\item
L-Language allows code to be compiled into the compiler, to support
language enhancements.

\item
L-Language uses the Layered Language Module Structure to manage
multi-file source code in a well-ordered and type-safe manner.


\end{enumerate}


\section{Types}
\label{TYPES}

The basic builtin types are the number types and the \TT{void} type.
All defined types are subtypes of these types.
One of the builtin defined subtypes is the `\TT{type}' type.

\subsection{Number Types}
\label{NUMBER-TYPES}

Numbers are sequences of bits, and each number is one of
four kinds, unsigned integer, signed integer, floating point number,
or address:

\begin{indpar}
\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\bf Name & \bf Kind & \bf Length \\[2ex]
\ttkey{uns8}		& unsigned integer & 8 bits \\
\ttkey{uns16}		& unsigned integer & 16 bits \\
\ttkey{uns32}		& unsigned integer & 32 bits \\
\ttkey{uns64}		& unsigned integer & 64 bits \\
\ttkey{uns128}		& unsigned integer & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{int8}		& signed integer & 8 bits \\
\ttkey{int16}		& signed integer & 16 bits \\
\ttkey{int32}		& signed integer & 32 bits \\
\ttkey{int64}		& signed integer & 64 bits \\
\ttkey{int128}		& signed integer & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{float16}		& IEEE floating point number & 16 bits \\
\ttkey{float32}		& IEEE floating point number & 32 bits \\
\ttkey{float64}		& IEEE floating point number & 64 bits \\
\ttkey{float128}	& IEEE floating point number & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{unsadr}		& unsigned integer & size of address \\
\ttkey{intadr}		& signed integer & size of address \\
\ttkey{adr}		& signed or unsigned integer & size of address \\
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{unswrd}		& unsigned integer & size of machine word \\
\ttkey{intwrd}		& signed integer & size of machine word \\
\end{tabular}
\end{indpar}

These are the \key{built in number types}:
\begin{indpar}
{\em builtin-number-type-name}\label{BUILTIN-NUMBER-TYPE-NAME}
    \begin{tabular}[t]{@{}cl}
    ::= & \TT{uns8} $|$ \TT{uns16} $|$ \TT{uns32} $|$ \TT{uns64}
                    $|$ \TT{uns128} \\
    $|$ & \TT{int8} $|$ \TT{int16} $|$ \TT{int32} $|$ \TT{int64}
                    $|$ \TT{int128} \\
    $|$ & \TT{float16} $|$ \TT{float32} $|$ \TT{float64} $|$ \TT{float128} \\
    $|$ & \TT{unsadr} $|$ \TT{intadr} $|$ \TT{adr}
                      $|$ \TT{unswrd} $|$ \TT{intwrd} \\
    \end{tabular}
\end{indpar}

The \mkey{length}{of number}
of a number is the number of its bits.  Numbers can have
different lengths: for example, unsigned integers can have
lengths of 8, 16, 32, 64, or 128 bits.

Numbers are stored in registers or in random access memory (RAM).

An \key{unsigned integer} of length $L$ is a binary integer with
$L$ binary digits (\skey{bit}s) and range from $0$ to $2^L-1$.

A \key{signed integer} of length $L$ is a two's complement integer
of length $L$ and range from $-2^{L-1}$ to $+2^{L-1}-1$.
This represents the integer $I$ in the given range
by the unsigned $L$-bit integer equal to $I~\mbox{modulo}~2^L$.

A \key{floating point number} of length $L$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes are as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}r@{~~~~~~}r}
                   &              &              &             & \bf Maximum \\
\bf Floating Point & \bf Exponent & \bf Mantissa & \bf Decimal & \bf Decimal\\
\bf Number Size    & \bf Size     & \bf Size     & \bf Digits  & \bf Exponent
\\[2ex]
16 bits & 5 bits & 10 bits & 3.31 & 4.51 \\
32 bits & 8 bits & 23 bits & 7.22 & 38.23 \\
64 bits & 11 bits & 52 bits & 15.95 & 307.95 \\
128 bits & 15 bits & 112 bits & 34.02 & 4931.77 \\
\end{tabular}
\end{center}

An \key{address} holds a RAM byte address.
An address is a 32-bit or 64-bit signed or unsigned integer whose size
and signage are determined by the target machine.
Some of high order bits may be
required to be all 0's or all 1's, depending upon
the target machine.  The \TT{unsadr} and \TT{intadr}
unsigned and signed integer types of the same size
as an address are provided for storing indices and offsets.

A reasonable assumption for 64-bit addresses is that only the low
order 48-bits of the address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing an address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The L-Language does
\underline{not} depend upon this assumption, but does provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$.  The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.\footnote{The I86 64-bit architecture
uses only the low order 48 bits of an address, but \underline{requires}
the high order 17 bits to all be the same, either all 1's or all 0's.
However, as it is unlikely that there will ever be an allocated memory region
that includes address 0 in its interior, it makes no significant difference
whether we consider addresses to be unsigned or signed.}

The following \underline{implicit} conversion operators are defined:
\begin{center}

\begin{tabular}{r@{~}l}
\TT{uns}$x$ & \TT{(} \TT{uns}$y${\em -value} \TT{)} \\
\TT{int}$x$ & \TT{(} \TT{uns}$y${\em -value} \TT{)} \\
\TT{float}$x$ & \TT{(} \TT{uns}$y${\em -value} \TT{)} \\
\TT{int}$x$ & \TT{(} \TT{int}$y${\em -value} \TT{)} \\
\TT{float}$x$ & \TT{(} \TT{int}$y${\em -value} \TT{)} \\
\TT{float}$x$ & \TT{(} \TT{float}$y${\em -value} \TT{)} \\
\end{tabular}

where $x>y$

\end{center}

For all these implicit conversions no information is lost from
the value when it is converted to the new type.

The following \underline{unchecked}
conversion operator is defined provided $t2$ is known at compile time:
\begin{center}

\TT{*UNCHECKED*~}$t2$~~\TT{(} ~~ $t1${\em -value} ~~\TT{)}%
\label{<<**}

for any two builtin number types $t1$ and $t2$.

\end{center}

\TT{*UNCHECKED*} conversions sometimes use rounding and exception flags.  The
L-Language assumes the hardware is set to `\key{round to nearest}'
and all exceptions are masked.%
\footnote{`round to nearest' not only affects
only rounding, but also affects the results of converting values
too large to fit in a target; `round to nearest' produces \TT{+Inf}
or \TT{-Inf} whereas other rounding modes sometimes produce minimum or
maximum numeric values.}  If there are two equally near values, the one with
the zero low order bit is chosen.
\TT{+Inf}, \TT{-Inf}, and \TT{NaN}
are considered to be numbers representable in floating point formats.
All kinds of \TT{NaN} are considered to be identical.


The \TT{*UNCHECKED*} conversion operator is defined as follows:%
\begin{itemize}
\item The implicit conversion `$t2$ \TT{(} $t1${\em -value} \TT{)}'
if that is defined.
\item $t2$ is a floating point type,
and the $t1$-value is a number within the range of values representable
by a $t2$ value.
The result is the $t1$-value rounded to the nearest $t2$-value.
\item $t2$ is a floating point type,
and the $t1$-value is a number outside the range of values representable
by a $t2$ value.
The result is plus infinity, \TT{+Inf}, or minus infinity, \TT{-Inf},
according to the sign of the $t1$-value.
\item $t2$ is a floating point type,
and the $t1$-value is a floating point \TT{NaN}.
The result is a floating point \TT{NaN}, but precisely which \TT{NaN}
is undefined.
\item $t2$ and $t1$ are integer types and the $t1$-value is too large
to be represented as a $t2$ value.
The result is the $t2$ value that
equals modulo $2^n$ the $t1$-value, where $n$ is the
number of bits in a $t2$ value.
\item $t2$ is an integer type and $t1$ is a floating point type, and
the $t1$-value rounded to the nearest integer
can be represented as a $t2$ value,
the result is this rounded $t1$-value.
\item $t2$ is an integer type and $t1$ is a floating point type,
the $t1$-value cannot be represented as a $t2$ value because its
absolute value is too large, or because it is not a number but is
\TT{+Inf}, \TT{-Inf}, or a \TT{NaN}.  The result is undefined, but
the floating point \key{invalid operation} flag is set.%
\footnote{In this situation,
Intel hardware sets the invalid operation flag and
\underline{not} the numeric overflow flag.}
\end{itemize}

Numeric constants are treated as if they had their own type,
\key{numeric-constant}.\footnote{Otherwise we would have problems
representing \TT{256}.  If we used \TT{uns16} we could not implicitly
convert to \TT{int16}, and if we used \TT{int16} we could not implicitly
convert to \TT{uns16}.}  The values \TT{+Inf}, \TT{-Inf}, and \TT{NaN}
are considered to be numeric constants.
The implicit conversion:
\begin{center}
$t2$ \TT{(} {\em numeric-constant} \TT{)}
\end{center}
is defined when $t2$ is known at compile time and either:
\begin{itemize}
\item No information about the size, sign, and
precision of the number is lost by representing the number
as a $t2$ type value.  This will always be true if $t2$ is
floating point and the numeric constant is \TT{+Inf}, \TT{-Inf},
or \TT{NaN}.
\item $t2$ is a floating point type,
and the {\em numeric-constant} is a number (i.e., not
\TT{+Inf}, \TT{-Inf}, or \TT{NaN})
within the range of values representable
by a $t2$ value.  The result is the {\em numeric-constant} rounded to
the nearest representable $t2$ value.
\end{itemize}

The \underline{unchecked} conversion:
\begin{center}
\TT{*UNCHECKED*} $t2$ \TT{(} {\em numeric-constant} \TT{)}
\end{center}
is defined if $t2$ is known at compile time
and one of the following cases applies:
\begin{itemize}
\item The implicit conversion `$t2$ \TT{(} {\em numeric-constant} \TT{)}'
if that is defined.
\item $t2$ is a floating point type,
and the {\em numeric-constant} is a number
outside the range of values representable
by a $t2$ value.
The result is plus infinity, \TT{+Inf}, or minus infinity, \TT{-Inf},
according to the sign of the {\em numeric-constant}.
\item $t2$ is an integer type, the {\em numeric-constant}
has a fractional part, and
the {\em numeric-constant} rounded toward the nearest integer
can be represented as a $t2$ value,
the result is this rounded {\em numeric-constant}.
\item $t2$ is an integer type
and the {\em numeric-constant} is an integer
outside the range of values representable
by a $t2$ value.
The result is the $t2$ value that
equals modulo $2^n$ the {\em numeric-constant}, where $n$ is the
number of bits in a $t2$ value.
\item $t2$ is an integer type,
and the {\em numeric-constant} is floating point and
outside the range of values representable
by a $t2$ value.
A compile error is signalled.
\end{itemize}

\subsection{The Void Type}
\label{THE-VOID-TYPE}

A \ttkey{void} type variable has no value.  No value can be
assigned to such a variable.  Nevertheless such variables have
uses, for example, as base variable in clusters (\pagref{CLUSTERS}).
When used as the base variable of a cluster, an assignment statement
may appear to be assigning a value to a \TT{void} variable, but
in fact it is assigning values to cluster members.

\subsection{Defined Types}
\label{DEFINED-TYPES}

A declaration statement of the following form defines a type:
\begin{center}
\TT{type} {\em qualifier-name}\STAR{} {\em defined-type-name}
          \TT{is} {\em base-type-name}
\end{center}
Any {\em qualifiers} in the declaration are attached to every
variable or argument declared to have the defined type (see
section \itemref{QUALIFIERS} for more on this).

A value of a defined type may be converted to or from its base
type by the
\underline{unchecked}
operations:
\begin{center}
\begin{tabular}{r@{~}l}
\TT{*UNCHECKED*} {\em base-type-name}
	& \TT{(} {\em defined-type-value} \TT{)}\\
\TT{*UNCHECKED*} {\em defined-type-name}
	& \TT{(} {\em base-type-value} \TT{)}\\
\end{tabular}\label{DEFINED-TYPE-UNCHECKED-CONVERSION}
\end{center}
These operators do not change the actual value, but merely its
compile-time type.  Implied conversions in one direction only
may be defined as desired.


\subsection{Enumeration Values}
\label{Enumeration-VALUES}

An \key{enumeration type} is a defined type whose values are
integers assigned to \skey{enumeration constant}s.
Each enumeration constant is assigned a value during compilation
that is an integer unique relative to all enumeration
constants of its enumeration type that are being compiled together.
Then during linking the enumeration constant is assigned a possibly
different value that is an integer unique relative to all enumeration
constants of its enumeration type that are being linked together.

A declaration statement of the following form defines an \key{enumeration type}
that has enumeration values:
\begin{center}
\TT{type} {\em qualifier-name}\STAR{} {\em defined-enum-type-name}
    \begin{tabular}[t]{l}
    \TT{is}~~~{\em base-enum-type-name} \\
    \TT{with enum range}~~~{\em enum-range} \\
    \{ \TT{without implicit conversion} \}\QMARK \\
    \end{tabular}
\end{center}
where
\begin{center}
\begin{tabular}{rrl}
\emkey{base-enum-type-name}
    & ::= & {\em integer-base-type-name} \\
    & $|$ & {\em enum-direction}\QMARK{}~~~{\em defined-enum-type-name} \\
\emkey{enum-direction}
    & ::= & \TT{next} $|$ \TT{previous} \\
\emkey{integer-base-type-name}
    & ::= & {\em builtin-number-type-name}%
            \,$^{\pagref{BUILTIN-NUMBER-TYPE-NAME}}$ naming an integer type \\
    & $|$ & {\em defined-type-name} with integer underlying type
            (see \pagref{UNDERLYING-TYPE}) \\
\emkey{enum-range}
    & ::= & \TT{[} {\em first-enum} \TT{..} {\em last-enum} \TT{]} \\
    & $|$ & \TT{[} {\em first-enum} \TT{..} \TT{]} \\
    & $|$ & \TT{[} \TT{..} {\em last-enum} \TT{]} \\
\emkey{first-enum}
    & ::= & {\em compile-time-integer-expression} \\
\emkey{last-enum}
    & ::= & {\em compile-time-integer-expression} \\
\end{tabular}
\end{center}

Here {\em first-enum} and {\em last-enum} are compile time integer
values assigned to the newly defined enum type.
{\em First-enum} must be less than or equal to {\em last-enum}.
If {\em last-enum} is not given, it is assumed to be the maximum
value permitted by the base enumeration type that conforms to the
rules given below.
Similarly if {\em first-enum} is not given, it is assumed to be the minimum
value permitted by the base enumeration type.

Enumeration values can be assigned by declaration statements of the form
\begin{indpar}
\emkey{enum-assignment}
    ::= {\em enum-type-name} {\em constant-name} \TT{is} \TT{next enum} \\
\emkey{enum-assignment}
    ::= {\em enum-type-name} {\em constant-name} \TT{is} \TT{previous enum}
\end{indpar}

Within a compilation the compiler assigns the value {\em first-enum}
to the first constant named in a `\TT{next enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in increasing order.
It is an error if `\TT{next~enum}'
would return a value beyond the {\em last-enum} value in a range.

Similarly the compiler assigns the value {\em last-enum}
to the first constant named in a `\TT{previous enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in decreasing order.
It is an error if `\TT{previous~enum}'
would return a value below the {\em first-enum} value in a range.

It is also an error if for a given type the same value is returned
by some \TT{next~enum} and also by some \TT{previous~enum}.

An enumeration type is a defined type with integer base type and
extra apparatus provided by the range which provides a special
mechanism for assigning enumeration type values.
Given an enumeration type \TT{E} with its base type \TT{B}
the following conversions are defined:
\begin{center}
\begin{tabular}{rl}
{\TT B} & \TT{(} {\em \TT{E}-value} \TT{)} \\
\TT{*UNCHECKED*} \TT{B}
	& \TT{(} {\em \TT{E}-value} \TT{)} \\
\TT{*UNCHECKED*} \TT{E}
	& \TT{(} {\em \TT{B}-value} \TT{)} \\
\end{tabular}
\end{center}
These conversions actually do nothing but change the type of the
value.  The first two have identical effect.  The first is an implicit
conversion, and is only defined if the
`\TT{without implicit conversion}' option is \underline{not} given in the
enumeration type definition.  The last two conversions are the
\TT{*UNCHECKED*} conversions defined for all defined types
(see \pagref{DEFINED-TYPE-UNCHECKED-CONVERSION}).

If the base type of an enumeration type is a builtin integer type,
the integer value corresponding to {\em first-enum} is {\em first-enum}
itself, and similarly for {\em last-enum}.  Thus the following
example:
\begin{indpar}\begin{verbatim}
type E is int32 with enum range [1 .. 20]
E C1 = next enum
    // Now int32 (C1) == 1
E C2 = next enum
    // Now int32 (C2) == 2
E C3 = previous enum
    // Now int32 (C3) == 20
E C4 = previous enum
    // Now int32 (C4) == 19
\end{verbatim}\end{indpar}

The \key{underlying type}\label{UNDERLYING-TYPE}
of a type \TT{T} is \TT{T} itself if
\TT{T} is builtin, and is the underlying
type of the base type of \TT{T} if \TT{T} is a defined type.
Thus every enumeration type \TT{E} has an underlying integer
type \TT{I}.  As long as the `\TT{without implicit conversion}'
option is \underline{not} used, a value of an enumeration type
can always be implicitly converted to a value of its underlying
type.  Thus the following example:
\begin{indpar}\begin{verbatim}
type D is int32
type E is D with enum range [1 .. 20]
E C1 = next enum
    // Now int32 (C1) == 1
E C3 = previous enum
    // Now int32 (C3) == 20
\end{verbatim}\end{indpar}

If the base type of an enumeration type is another enumeration type,
the map from values of the first enumeration type to underlying
integer values consists of adding a constant, called the
`\key{enumeration offset}', which is determined as follows:

\begin{indpar}
\begin{itemlist}
\item[\TT{type} {\em qualifier-name}\STAR{} {\em defined-enum-type-name}~~%
    \TT{is}~~{\em builtin-integer-type-name} \ldots{}] ~\\
The enumeration offset of the defined enumeration type equals 0.
\item[\TT{type} {\em qualifier-name}\STAR{} {\em defined-enum-type-name}~~%
    \TT{is}~~{\em non-builtin-integer-type-name} \ldots{}] ~\\
The enumeration offset of the defined enumeration type equals
the enumeration offset of its base type.
\item[\TT{type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em defined-enum-type-name}~~\TT{is}~~%
              \TT{next}~~{\em base-defined-enum-type-name} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Has the effect of compiling the statements:
\begin{center}
\begin{tabular}{l}
{\em base-defined-enum-type-name} \TT{V0~~=~~next enum} \\
{\em base-defined-enum-type-name} \TT{V1~~=~~next enum} \\
{\em base-defined-enum-type-name} \TT{V2~~=~~next enum} \\
\ldots\ldots\ldots \\
{\em base-defined-enum-type-name} \TT{V$n$~~=~~next enum} \\
\end{tabular}
\end{center}
where $n$ = {\em last-enum} - {\em first-enum}, and assigning
the enumeration offset of the defined enumeration type so that if
\begin{center}
{\em defined-enum-type-name} \TT{V~~=~~next enum} \\
\end{center}
were the first statement compiled later that assigns a
{\em defined-enum-type-name} enumeration value,
and \TT{I} is the underlying builtin integer type of both enum
types, then \TT{I(V) = I(V0)}.  Here \TT{V} stands for a manufactured
word lexeme prefix that makes the names \TT{V\ldots}
distinct from any other lexemes in the program.
\item[\TT{type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em defined-enum-type-name}~~\TT{is}~~%
              \TT{previous}~~{\em defined-enum-type-name} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Ditto with every `\TT{next}' replaced everywhere by `\TT{previous}'.
\end{itemlist}
\end{indpar}

The following are also defined:

\begin{indpar}[0.5in]
\hspace*{-0.3in}\TT{(I} i-value\TT{)~~=~~}\ttkey{range value of}
			\TT{( E} e-value \TT{)} \\
Returns:~~\TT{I( e-value )}~\TT{-}~the enumeration offset of \TT{E}.
\\[1ex]
\hspace*{-0.3in}\TT{(I} i-value\TT{)~~=~~}\ttkey{enumeration offset of}
			\TT{( type E )} \\
Returns the enumeration offset of \TT{E}.
\end{indpar}

The above is examplified by:
\begin{indpar}\begin{verbatim}
type E1 is int32 with enum range [1 .. 20]
    // Now enumeration offset of (E1) == 0
E1 C1 = previous enum
    // Now range value of (C1) == 20 == int32(C1)
type E2 is previous E1 with enum range [1 .. 10]
    // Now enumeration offset of (E2) == 9
E2 C2 = next enum 
    // Now range value of (C2) == 1,
    // Now range value of ( E1(C2) ) == 10 = int32(C2)
E2 C3 = previous enum 
    // Now range value of (C3) == 10,
    // Now range value of ( E1(C3) ) == 19 = int32(C3)
type E3 is next E2 with enum range [1 .. 5]
    // Now enumeration offset of (E3) == 10
E3 C4 = next enum 
    // Now range value of (C4) == 1,
    // range value of ( E2(C4) ) == 2,
    // range value of ( E1(E2(C4)) ) = 11 = int32(C4)
\end{verbatim}\end{indpar}

Note that as long as implicit conversions from enumeration
types to their base types are defined (i.e., as long as
`\TT{without implicit conversion}' is not used), enumeration
type values can be compared.
The comparison will convert the values to integers of their
underlying type and compare the resulting integers.
Such comparisons may not be meaningful.

The following are builtin enumeration types:
\begin{indpar}
\TT{type~type~is unswrd with enum [0~..]} \\
\TT{type~missing~is next enum // 0} \\
\TT{type~type~is next enum // 1}
\\[1ex]
\TT{type~qualifier~is unswrd with enum [0~..]} \\
\TT{qualifier~missing~is next enum // 0}
\\[1ex]
\TT{type~}\ttkey{bool}\TT{~is unswrd with enum [0~..~1]} \\
\TT{bool}~\ttkey{false}\TT{~is next enum // 0} \\
\TT{bool}~\ttkey{true}\TT{~~is next enum // 1}
\end{indpar}

Builtin types not mentioned above, such as `\TT{void}' and `\TT{int32}',
are given unspecified `\TT{type}' enumeration values.
Similarly builtin qualifiers, such as `\TT{mem}', are given
unspecified `\TT{quali\-fier}' enumeration values.  Conversions and
`\TT{range value of}' functions above
can be used to find the integer values associated with any
enumeration constant, but unspecified builtin values may differ from
one compilation or linking to the next.

Enumeration values are assigned within a compilation module in
the order that {\em enum-assignments} are compiled.
When the module is linked, enumeration values are assigned
in the same manner and order, but the values themselves may
differ because the assignments of an enumeration type made
before the module is processed may differ between when the
module is compiled and when it is linked.

However, within a compilation module, all assignments to an enumeration type
are done in the same order during linking as during compilation.
Thus values assigned within the same module can be assumed to be
in the same order at compile and link times.  Also,
compile and link values of a given enumeration type
can be assumed to be the same if \underline{all} values
of that enumeration type are assigned in the a single compilation module.

\subsection{Enumeration Sets}
\label{Enumeration-Sets}

An enumeration set is a set of enumeration values.  The syntax
for enumeration set constants is:
\begin{indpar}
\emkey{enum-set-constant}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{\{~\}\}} \\
    $|$ &\TT{\{\{} {\em enum-set-item}
                   \{ \TT{,} {\em enum-set-item} \}\STAR{} \TT{\}\}} \\
    \end{tabular} \\
\emkey{enum-set-item}
    ::= {\em enum-value} $|$ {\em enum-range} \\
\emkey{enum-range}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em enum-value}~~~\TT{..}~~~{\em enum-value} \\
    $|$ & {\em enum-value}~~~\TT{..} \\
    $|$ & \TT{..}~~~{\em enum-value} \\
    \end{tabular} \\
\emkey{enum-value} ::= {\em compile-time-enum-expression}
\end{indpar}

If the {\em enum-values} in an {\em enum-set-constant} have different
enumeration types, implicit conversions from these to their base types
are inserted until all have the same defined enumeration type,
which is called the
`\key{common enumeration type}'\label{COMMON-ENUMERATION-TYPE}
of the set.
This is the most specific least general type to which all the set
values can be converted (see \pagref{CONVERSION-RELATION}).
It is an error
if this cannot be done because some of the types have no implicit
conversion defined for them, or if after implict conversion the
common type is not a defined enumeration type.
Importantly, note that the common type cannot be a builtin integer
type.

An {\em enum-range} designates the two values given and all
values in between.
After implict conversion, the first {\em enum-value} in an {\em enum-range}
must \underline{not} be greater than the second {\em enum-value}
in the {\em enum-range}.  If the first or second {\em enum-value} of
an {\em enum-range} is omitted, it is taken to be the lower or upper
limit of the enumeration type of the non-omitted {\em enum-value}.

The order in which values are given in an {\em enum-set-constant}
does not matter.  Overlapping and adjoining ranges are implictly
combined.\footnote{Internally an enumeration set may be stored as a
sorted list of integers with binary indicators specifying when all
the values between one integer and the next integer are to be included
in the set.}
Thus
\begin{indpar}\begin{verbatim}
type X is uns8 with enum range [1 .. 20]
X X1 is next enum
X X2 is next enum
. . . . . . . . . .
X X20 is next enum

// Then:
//
//    {{ X1, X5, X2, X10 .. X16, X19 .. X20, X15 .. X18 }}
// == {{ X1, X2, X5, X10 .. X20 }}
\end{verbatim}\end{indpar}

Enumeration set values are used in logical expressions that
condition function lookup.  For example,
\begin{indpar}\begin{verbatim}
T v = signed max ( type T, T v1, T v2 )
      [[ T is in {{ int8, int16, int32, int64, int128 }} ]]:
    . . . . . . . . . . .
\end{verbatim}\end{indpar}

defines a function that takes only signed integer type
arguments, and not unsigned integer type arguments.
The logical expression inside \TT{[[~]]} must be satisfied
for the function definition to match a function call, and
the type argument \TT{T}, which is implicit and need not be
given in the function call, must be in the give set of
types, where types are values of the enumeration type `\TT{type}'
(see Section~\itemref{TYPE-VALUES}).

Enumeration sets can be stored in variables of enumeration set
types, which can be declared by:
\begin{center}
\TT{type} {\em qualifier-name}\STAR{} {\em defined-enum-set-type-name}
    \TT{is set of } {\em base-enum-type-name} \\
\end{center}

The information about enumeration set types can be determined by:

\begin{indpar}
\hspace*{-0.3in}{\tt bool = \ttkey{is enumeration set type}
			( type T )} \\
Returns \TT{true} if \TT{T} is an enumeration set type and \TT{false}
otherwise.

\hspace*{-0.3in}{\tt (type B) = \ttkey{base type of}
			( type T )} \\
Returns the base type \TT{B} of an enumeration set type \TT{T}.
\end{indpar}

The following are builtin enumeration set types:
\begin{indpar}
\TT{type~}\ttkey{types}\TT{~is set of type} \\
\TT{type~}\ttkey{qualifiers}\TT{~is set of qualifier}
\end{indpar}

An enumeration set constant is an enumeration set whose base type 
is its common enumeration type, even if this enumeration set type has not been
declared and is not builtin.

The following operations on enumeration sets are builtin:

\begin{indpar}
\hspace*{-0.3in}{\tt (S union) = (type S, S op1)
                        "\ttmkey{+}{enumeration set union}" ( S op2 )} \\
\hspace*{0.3in}{\tt [[ is enumeration set type ( S ) ]]} \\
\hspace*{-0.3in}{\tt (S union) = (S op1)
                        "\ttmkey{+}{enumeration set union}"
			( type S, S op2 )} \\
\hspace*{0.3in}{\tt [[ is enumeration set type ( S ) ]]} \\
Returns the union of \TT{op1} and \TT{op2}.

\hspace*{-0.3in}{\tt (S intersection) = (type S, S op1)
                        "\ttmkey{*}{enumeration set intersection}" ( S op2 )} \\
\hspace*{0.3in}{\tt [[ is enumeration set type ( S ) ]]} \\
\hspace*{-0.3in}{\tt (S intersection) = (S op1)
                        "\ttmkey{*}{enumeration set intersection}"
			( type S, S op2 )} \\
\hspace*{0.3in}{\tt [[ is enumeration set type ( S ) ]]} \\
Returns the intersection of \TT{op1} and \TT{op2}.

\hspace*{-0.3in}{\tt (S difference) = (type S, S op1)
                        "\ttmkey{+}{enumeration set difference}" ( S op2 )} \\
\hspace*{0.3in}{\tt [[ is enumeration set type ( S ) ]]} \\
Returns the set difference of \TT{op1} and \TT{op2}.

\hspace*{-0.3in}{\tt bool = (E e)
                        \ttmkey{in}{enumeration set} ( type S, S s )} \\
\hspace*{0.3in}{\tt [[ is enumeration set type ( S ) ]]} \\
\hspace*{0.3in}{\tt [[ E = base type of ( S ) ]]} \\
Returns \TT{true} if \TT{e} is an element of the set \TT{s}, and
\TT{false} otherwise.

\hspace*{-0.3in}{\tt (S union) = (E e)
                        "\ttmkey{+}{enumeration set union}" ( type S, S s )} \\
\hspace*{0.3in}{\tt [[ is enumeration set type ( S ) ]]} \\
\hspace*{0.3in}{\tt [[ E = base type of ( S ) ]]} \\
Returns union of \{\TT{e}\} and \TT{s}.

\hspace*{-0.3in}{\tt (S union) = (type S, S s)
                        "\ttmkey{+}{enumeration set union}" ( E e )} \\
\hspace*{0.3in}{\tt [[ is enumeration set type ( S ) ]]} \\
\hspace*{0.3in}{\tt [[ E = base type of ( S ) ]]} \\
Returns union of \{\TT{e}\} and \TT{s}.

\hspace*{-0.3in}{\tt (S difference) = (type S, S s)
                        "\ttmkey{-}{enumeration set union}" ( E e )} \\
\hspace*{0.3in}{\tt [[ is enumeration set type ( S ) ]]} \\
\hspace*{0.3in}{\tt [[ E = base type of ( S ) ]]} \\
Returns the set difference of \TT{s} and \{\TT{e}\}.

\end{indpar}

\subsection{Type Values}
\label{TYPE-VALUES}

The type `\TT{type}' is a builtin enumeration type declared
by the builtin equivalent of:
\begin{indpar}
\TT{type~}\ttkey{type}\TT{~is unswrd with enum [0~..]} \\
\TT{type}~\ttkey{missing}\TT{~is next enum // 0} \\
\TT{type}~\ttkey{type}\TT{~is next enum // 1}
\end{indpar}
Each type is associated with a unique enumeration value
of type `\TT{type}', and this value can be used at both
compile and run time to test whether two `\TT{type}'s are
equal.

Values of one type \TT{T1} can be converted implicitly to another
type \TT{T2} if and only if an inline function with prototype:
\begin{center}
\TT{Q T2} {\em result-variable}%
    ~~\TT{=}~~\TT{( qualifiers Q, Q T1} {\em source-variable} \TT{)}
\end{center}
is defined.  In this case we say the \TT{T1} is \mkey{more specific}{types}
than \TT{T2}, or \TT{T2} is \mkey{more general}{types} than \TT{T1}, or
\begin{center}
\TT{T1~~-{}-{}->~~T2}
\end{center}%
\label{CONVERSION-RELATION}

The transitive closure of the \TT{-{}-{}->} relation between types is
required to be a partial order,
or equivalently, the directed graph with an edge from \TT{T1} to
\TT{T2} iff \TT{T1~-{}-{}->~T2} is required to be acyclic.
In addition, two different paths from one type to another are
required to produce the same result.  For example:
\begin{indpar}\begin{verbatim}
int16 v1 = ...
int32 v2 = v1
float64 v3 = v2
float64 v4 = v1
// Given the two implicit conversion paths v1 ---> v2 ---> v3
// and v1 ---> v4, necessarily v3 == v4.
\end{verbatim}\end{indpar}

Functions can be overloaded based on the number and types
of their arguments and also on the values of arguments that
are known at compile time.  Thus different functions with
the common prototype
\begin{center}
\TT{(unsadr length) = size of ( type T )}
\end{center}
may be defined for different values of \TT{T}.  
This is done automatically for the following functions:

\begin{indpar}[0.5in]
\hspace*{-0.3in}{\tt (type B) = \ttkey{base type of}
			( type T )} \\
Returns the base type \TT{B} of the type \TT{T}.  For defined
types this is the associated base type from the defined type's
declaration.  For builtin types, it is
\TT{T} itself.

\hspace*{-0.3in}{\tt (type U) = \ttkey{underlying type of}
			( type T )}
Returns \TT{T} if \TT{T} is a builtin type.
Otherwise if \TT{T} is a defined type,
\begin{center}
\TT{underlying type of ( base type of ( T ) )}
\end{center}
is returned.  See \pagref{UNDERLYING-TYPE}.

\hspace*{-0.3in}{\tt (unsadr size) = \ttkey{size of}
			( type T )} \\
Returns \TT{size}, the number of bytes in a value of type \TT{T}.
For defined types it is the size of their underlying type
(the size of \TT{void} is \TT{0}).

\hspace*{-0.3in}{\tt (unsadr alignment) = \ttkey{alignment of}
			( type T )} \\
Returns \TT{alignment}, a strictly positive integer.
The address of a value of type \TT{T} in RAM should
optimally be a multiple of the \TT{alignment}.
The alignment of builtin types is their size.
For defined types it is the alignment of their underlying type.

\hspace*{-0.3in}{\tt (T value) = \ttkey{min of}
			( type T )} \\
\hspace*{-0.3in}{\tt (T value) = \ttkey{max of}
			( type T )} \\
Returns the minimum or maximum value of a type \TT{T}.
These are defined only for number types and enumeration types,
and for enumeration types the values returned are the limits of
the type's {\em enum-range}.

\hspace*{-0.3in}{\tt (T value) = \ttkey{min unassigned of}
			( type T )} \\
\hspace*{-0.3in}{\tt (T value) = \ttkey{max unassigned of}
			( type T )} \\
Returns the minimum or maximum values not yet assigned to an
enumeration type \TT{T} by an {\em enum-assignment}.  Values
assigned by unchecked conversions are not considered.  If
no values have been assigned, the enumeration value corresponding
to {\em first-enum} is returned by `\TT{min unassigned of}'
and the enumeration value corresponding
to {\em last-enum} is returned by `\TT{max unassigned of}'.
It is a compile time error if \TT{T} is not an enumeration type.

These values may change when more code is compiled or linked.
You may only assume that constants of type \TT{T} whose values have
already been compiled or linked are within
ranges bounded by these values, i.e., in the ranges:
\begin{center}
\TT{[ min of (T), min unassigned of (T) )} \\
\TT{( max unassigned of (T), max of (T) ]} \\
\end{center}

\hspace*{-0.3in}{\tt (T value) = \ttkey{default value of}
			( type T )} \\
Returns a suitable default value for type \TT{T}.
Defined to return \TT{0} for builtin number types.
Must be defined by user for defined types.  For use by allocators,
such as a user defined function that allocates a vector whose
elements are of type \TT{T}, and the function wishes to give the elements an
initial default value.

\hspace*{-0.3in}{\tt (bool value) = ( type T1 ) \ttkey{>} ( type T2 )} \\
Returns \TT{true} if and only if \TT{T1 > T2} in the sense that values
of type \TT{T1} can be implicitly converted to values of type \TT{T2}
(see \pagref{CONVERSION-RELATION}).
\end{indpar}

For all these functions it is a compile time error if their arguments
do not have a compile time value.

\section{Qualifiers}
\label{QUALIFIERS}

Variables may be qualified by \skey{qualifier}s, which preceed the
type when a variable is declared.  There are four builtin qualifiers
described in Section~\itemref{BUILTIN-QUALIFIERS} that have special
effects: \TT{mem}, \TT{stack}, \TT{*UNCHECKED*}, and \TT{global}.
There is also a builtin method for defining trace qualifiers which
have special effects.
Other qualifiers that have no special effects
may be defined, and are typically used to add an
additional layer of type checking that is somewhat orthogonal to
types.

Syntactically {\em qualifier-names} immediately preceed the {\em type-names}
that are before {\em variable-names}.  Some introductory examples are:
\begin{indpar}\begin{verbatim}
qualifier fee
required qualifier fie
function fee int32 result = F ( fee fie int32 value ):
    // Declares function F that computes a result of type
    // int32 from a value of type int32 and qualifier fie.
    // Requires call argument to have qualifier fie, but
    // not fee.
    //
    ... [Function body omitted] ...

// Example usage:
//
fie int32 x1 = ...
fee int32 x2 = ...
int32 y1 = F ( x1 )          // Legal; x1 has required fie.
int32 y2 = F ( x2 )          // Illegal; x2 does not have
                             // required fie.
protected prohibited qualifier fo
function fo int32 result = G ( int32 value ):
    // Declares function G that computes a result of type
    // int32 from a value of type int32 that does NOT have
    // qualifier fo, which is prohibited.  Attaches fo, which
    // is also protected, to the result.
    //
    ... [Function body omitted] ...

fee int32 y3 = G ( x1 )      // Legal; y3 also acquires fo.
fee int32 y4 = G ( y3 )      // Illegal; y3 has implied
                             // qualifier fo.
fo  int32 y5 = 9             // Illegal; fo is protected.
fo  int32 y6 = y3            // Legal; y3 has implied fo.
\end{verbatim}\end{indpar}

The qualifiers may be declared by:
\begin{indpar}
\emkey{qualifier-declaration}
    \begin{tabular}[t]{rl}
    ::= & {\em qualifier-attribute}\STAR{} \ttkey{qualifier}
           {\em defined-qualifier-name} \\
    $|$ & {\em trace-qualifier-declaration}
    	  ~~~ [see \pagref{TRACE-QUALIFIERS}]
    \end{tabular} \\
\emkey{qualifier-attribute}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{required} \\
    $|$ & \ttkey{prohibited} \\
    $|$ & \ttkey{protected} \\
    $|$ & \ttkey{inherited} \\
    \end{tabular}
\end{indpar}

If a function prototype variable (argument or result) has
a \key{required qualifier}, any call variable matched to this
prototype variable must have the required qualifier.

If a function prototype variable (argument or result)
does \underline{not}
have a \key{prohibited qualifier}, any call variable matched to this
prototype variable must \underline{not} have the prohibited qualifier.

A qualifier \underline{can} be both required and prohibited.
Given a function prototype variable with such a qualifier,
a matching call variable must always have the qualifier,
and given a function prototype variable without such a qualifier,
a matching call variable must never have the qualifier.

If a function prototype result variable has a \key{protected
qualifier}, any call variable matched to this
prototype variable will be given the protected qualifier
(if it does not already have it).  Furthermore, no variable
may have the protected qualifier unless it is matched to
a function result variable with the qualifier.

In the above example, 
any call variable matched to the argument of \TT{F}
must have the `\TT{fie}' qualifier, which is required.
Any call variable matched to the argument of \TT{G}
must \underline{not} have the `\TT{fo}' qualifier, which is prohibited.
The `\TT{fo}' qualifier can only be placed on a variable that is
the result of a function like \TT{G} which attaches it to its result,
as `\TT{fo}' is protected.  `\TT{fee}' and `\TT{fie}' can be attached
to any variable, as they are \underline{not} protected.

Inherited qualifiers affect cluster variables and their behavior is
specified on page~\pageref{INHERITED-QUALIFIER}. 

The builtin qualifiers are in effect declared by:
\begin{indpar}
\TT{protected~qualifier~}\ttkey{mem} \\
\TT{prohibited~protected~inherited~qualifier~}\ttkey{stack} \\
\TT{required qualifier~}\ttkey{*UNCHECKED*} \\
\TT{protected~inherited~qualifier~}\ttkey{global}
\end{indpar}

The type `\ttkey{qualifier}' is a builtin enumeration type implicitly
declared after the manner of
\begin{indpar}
\TT{type~}\ttkey{qualifier}\TT{~is unswrd with enum [0~..]} \\
\TT{qualifier}~\ttkey{missing}\TT{~is next enum // 0}
\end{indpar}
Each qualifier is associated with a unique enumeration value
of type `\TT{qualifier}', and this value can be used at both
compile and run time to test whether two `\TT{qualifier}'s are
equal.

\section{Names and Abbreviations}
\label{NAMES-AND-ABBREVIATIONS}

A \key{name} is a sequence of lexemes used to name things like
variables and functions.

\begin{indpar}\label{NAMES}
\emkey{name} ::= {\em name-component} {\em member-selector}\STAR{} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript} \\
\emkey{member-name} := {\em name-component} beginning with `\TT{.}' \\
\emkey{name-component} ::=
    {\em name-item} {\em continuing-name-item}\STAR{} \\
\emkey{continuing-name-item} := {\em name-item} not containing `\TT{.}' \\
\emkey{name-item} \begin{tabular}[t]{@{}rl}
    ::= & {\em word} with no embedded or ending `\TT{.}'s \\
        & [see text about splitting words with embedded `\TT{.}'s] \\
    $|$ & {\em quoted-mark} with no embedded or ending `\TT{.}'s \\
    $|$ & {\em quoted-separator} not containing `\TT{.}'s \\
    \end{tabular} \\
\emkey{quoted-mark} :::= \TT{"} {\em mark} \TT{"} \\
\emkey{quoted-separator} :::= \TT{"} {\em separator} \TT{"} \\
\emkey{member-subscript} ::= \TT{[}{\em member-index-list}\TT{]} \\
\emkey{member-index-list} \begin{tabular}[t]{@{}rl}
    ::= & {\em member-index} \\
    $|$ & {\em member-index} \TT{,} {\em member-index-list}
    \end{tabular} \\
\emkey{member-index} ::= {\em compile-time-integer-expression}
\end{indpar}

[We have not yet defined lexemes.  Roughly, separators are single
characters such as `\TT{(}' `\TT{)}' and `\TT{,}', marks are lexemes
that are not separators and do not contain letters or digits or `\TT{\#}',
words are lexemes that contain a letter before any digit, and
numerics are lexemes that contain either a digit before any letter
or contain `\TT{\#}'.]

{\em Words} containing embedded `\TT{.}'s are split into
{\em name-items} which can only contain `\TT{.}'s at their beginning.
Thus
\begin{center}
\TT{bills.wife.1.weight}
\end{center}
is split into
\begin{center}
\TT{bills~~~.wife~~~.1~~~.weight}
\end{center}
However, `\TT{.1}' is not a legal {\em name-item} and so cannot
be part of a {\em name}.

A variable of type \ttkey{name} can store a {\em name}.
Constants of type `\TT{name}' are made by \TT{`~'} quoting a {\em name}.
Two \TT{name} values can be
concatenated by the \TT{+} operator if the second begins with
a {\em member-selector}.  An
example is:
\begin{indpar}\begin{verbatim}
name n1 = `jill'
name n2 = `.daughter[3]'
name n = n1 + n2  // n now = `jill .daughter[3]'
                  // or equivalently `jill.daughter[3]'
\end{verbatim}\end{indpar}

{\em Variable-names}, {\em type-names}, {\em qualifier-names},
{\em function-names}, etc.~are {\em names}.

An `\ttkey{abbreviation}' is name that is replaced in code by its value.
More specifically,
\begin{indpar}
\TT{type~}\ttkey{abbreviation}\TT{~is name}
\end{indpar}
is builtin, and given
\begin{center}
\TT{abbreviation V = `N'}
\end{center}
for any variable \TT{V} and name \TT{N}, any occurrance of
the name \TT{V} as an \underline{initial} subname of
a name in code within the scope of \TT{V} is replace by \TT{N} during
compilation.  Here a `\key{subname}' is a sequence of {\em name-components}
and {\em member-subscripts} within a name (i.e., a subname cannot
contain a \underline{partial} {\em name-component}),
and an `\key{initial subname}' is a subname that begins at the beginning
of the name that contains it.
If there is more than one replaceable initial subname
in a name, the longest is replaced.  After replacement, the complete name is
reinspected for possible additional abbreviations: that is, abbreviation
replacement in names is recursive.  However, abbreviation replacement
is done after other parsing; abbreviations may replace operators, but
only after the operators have been used to insert implied parentheses.

For example:
\begin{indpar}[0.1in]\begin{verbatim}
name ni = `i'
abbreviation nj = `j'
abbreviation nnj = `nj'
int32 nj = 5       // Legal: nj => j; same as j = 5
int32 i = 6        // Legal: has no abbreviation
int32 ni = 6       // Illegal variable overlay;
                   //     ni => i; same as i = 6
next nj = 6        // Legal variable overlay:
                   //     nj => j; same as next j = 6
int32 r = nnj      // Legal: nnj => nj => j; same as r = j 
abbreviation "+.+" = `+'
int32 i = ( 4 ) +.+ ( 5 )
    // Legal; ( 4 ) "+" ( 5 ) which is what 4 + 5 becomes
    // after parsing.  However, 4 +.+ 5 will be illegal as
    // the parser will not treat +.+ as an operator, will
    // not insert implied parentheses, and therefore post-
    // parsing will not recognize +.+ as a name.
\end{verbatim}\end{indpar}

If an abbreviation is referenced in code being compiled, the value
of the abbreviation variable must be available to the compilation.
This does \underline{not} mean the value of every abbreviation
variable must be compile-time, as such a variable may be computed
at run-time and then used in a `\TT{compile-and-run}' assignment
statement: see Section~\itemref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}.

\section{Conversions}
\label{CONVERSIONS}

Conversions of a value of one data type \TT{T-src} to a value of another
data type \TT{T-des} play a very important role in a typed language.

\subsection{Implied Conversions}
\label{IMPLIED-CONVERSIONS}

Particularly important are \skey{implied conversion}s.  If an inline function
exists with prototype:
\begin{center}
\TT{QS T-des} {\em result-variable}%
    ~~\TT{=}~~\TT{( qualifiers QS, QS T-src} {\em source-variable} \TT{)}
\end{center}
then this function defines an implied conversion from values of
type \TT{T-src} to values of type \TT{T-des}.

An ordering is induced on types by implicit conversions.  Let
\TT{T1}$\succ$\TT{T2} mean that there is an implicit conversion from
values of type \TT{T1} to values of type \TT{T2}.  Let \TT{T1~-{}-{}->~T2}
be the transitive closure of \TT{T1}$\succ$\TT{T2}, which means
that a value of type \TT{T1} may be converted to a value
of type \TT{T2} by applying zero or more implicit conversions.
Then we \underline{require}
that \TT{T1~-{}-{}->~T2} be a partial order, which means that:
\begin{itemize}
\item \TT{-{}-{}->} is reflexive: \TT{T1~-{}-{}->~T1}.
\item \TT{-{}-{}->} is transitive: \TT{T1~-{}-{}->~T2} and \TT{T2~-{}-{}->~T3}
imply that \TT{T1~-{}-{}->~T3}.
\item \TT{-{}-{}->} is anti-symmetric:
\TT{T1~-{}-{}->~T2} and \TT{T2~-{}-{}->~T1}
imply that \TT{T1~==~T2}.
\end{itemize}

Importantly, we \underline{require} that
if values of type \TT{T1} can be implicitly converted to
values of a different type type \TT{T2}, then values of type \TT{T2}
\underline{cannot} be implicitly converted to values of type \TT{T1}.

We define the \key{implicit conversion graph} to be the directed
graph whose nodes are types and which has an arrow from \TT{T1} to
\TT{T2} if and only if there is an inline function defined with
prototype:
\begin{center}
\TT{QS T-des} {\em result-variable}%
    ~~\TT{=}~~\TT{( qualifiers QS, QS T-src} {\em source-variable} \TT{)}
\end{center}
Or equivalently, there is an implicit conversion function defined
whose argument is of type \TT{T1} and whose result is of type \TT{T2}.
Then \TT{T1~-{}-{}->~T2} if and only if there is a (possibly zero length)
path in this graph from \TT{T1} to \TT{T2}.

In addition we \underline{require} that all paths
from \TT{T1} to \TT{T2} give the same result.
So, for example, if one can implicitly convert a \TT{T1} value directly to
either a \TT{T2} or \TT{T3} value, and one can implicitly convert
a \TT{T2} value to a \TT{T3} value, then converting a \TT{T1} value
to a \TT{T2} value and then converting that to a \TT{T3} value
must give the same resulting value as converting the \TT{T1} value
directly to a \TT{T3} value.

User defined implicit conversions are assumed to obey these rules.

Various builtin implied conversions are described
in this document.

\subsection{Directed Conversions}
\label{DIRECTED-CONVERSIONS}

In addition to applied conversions, \skey{directed conversion}s may
be defined by inline functions with the prototypes that constrain
the qualifiers involved.  An example is
\begin{center}
\TT{QS-des T-des} {\em result-variable}%
    ~~\TT{=}~~\TT{( QS-src T-src} {\em source-variable} \TT{)}
\end{center}
where \TT{QS-src} and \TT{QS-des} are explicit lists of qualifiers.
Another example is
\begin{center}
\begin{tabular}{l}
\TT{QS *UNCHECKED* T-des} {\em result-variable} ~~\TT{=} \\
~~~~~~~~~~~~~~~\TT{( qualifiers QS, QS T-src} {\em source-variable} \TT{)} \\
\end{tabular}
\end{center}
which defines an \TT{*UNCHECKED*} conversion.

Various builtin \TT{*UNCHECKED*} conversions are described
in this document.

\subsection{Conversion Assignments}
\label{CONVERSION-ASSIGNMENTS}

Assignment of the value of one variable \TT{v-src} to another
variable \TT{v-des} is a \emkey{conversion-assignment-statement} if
the types or qualifiers of \TT{v-des} and \TT{v-src} differ:
\begin{center}
\begin{tabular}{l}
\TT{QS-src T-src v-src = ...} \\
\TT{QS-des T-des v-des = v-src} \\
\end{tabular}
\end{center}

where \TT{QS-}$xxx$ are the qualifiers of \TT{v-}$xxx$ and
\TT{T-}$xxx$ is the type of \TT{v-}$xxx$.  Such statements are
executed according to the following rules:

\begin{enumerate}
\item If there is a protected qualifier \TT{Q} in \TT{QS-src}, it
is automatically added to \TT{QS-des}.
\item If there is a required qualifier \TT{Q} in \TT{QS-des}, it
must also be in \TT{QS-src}.
\item If there is a prohibited qualifier \TT{Q} not in \TT{QS-des}, it
must also not be in \TT{QS-src}.
\item If \TT{T-src} and \TT{T-des} are not the same
and \TT{T-src~-{}-{}->T-des},
meaning that an implicit conversions are defined that convert values
of type \TT{T-src} to values of type \TT{T-des}, these conversions are
applied to \TT{v-src} to produce the value of \TT{v-des}.
The conversions are invoked with \TT{QS == QS-src}.
\item
\label{DIRECT-CONVERSION-ASSIGMENTS}
If \TT{T-src} and \TT{T-des} are not the same and \TT{T-src~-{}-{}->T-des}
\underline{is false}, but a directed conversion exists from
\TT{QS-src T-src} to \TT{QS-des T-des}, that conversion is applied
if only one such conversion is applicable.
\end{enumerate}


\subsection{Temporary Variables}
\label{TEMPORARY-VARIABLES}

Consider the code:

\begin{center}
\begin{tabular}{l}
\TT{prototype QS-F-result T-F-result F-result =} \\
\TT{~~~~~~~~~~F ( QS-F-argument T-F-argument F-argument)} \\
\TT{prototype QS-G-result T-G-result G-result =} \\
\TT{~~~~~~~~~~G ( QS-G-argument T-G-argument G-argument)} \\
\TT{QS-src T-src v-src = ...} \\
\TT{QS-des T-des v-des = F ( G ( v-src ) )} \\
\end{tabular}
\end{center}

This is compiled by introducing temporary variables \TT{tmp-}$xxx$:

\begin{center}
\begin{tabular}{l}
\TT{QS-src T-src v-src = ...} \\
\TT{QS-G-argument T-G-argument tmp-G-argument = v-src} \\
\TT{QS-G-result T-G-result tmp-G-result = G ( tmp-G-argument )} \\
\TT{QS-F-argument T-F-argument tmp-F-argument = tmp-G-result} \\
\TT{QS-F-result T-F-result tmp-F-result = F ( tmp-F-argument )} \\
\TT{QS-des T-des v-des = tmp-F-result} \\
\end{tabular}
\end{center}

There are two special rules applied to this situation.

The first is:
\begin{indpar}
\ikey{No Direct Conversions.}{no direct conversions} Direct
conversions from one temporary variable to another are not
allowed.  Only implicit conversions are allowed.
\end{indpar}
Thus in the assignment conversions between two temporary
variables that are introduced by compilation,
Rule~\ref{DIRECT-CONVERSION-ASSIGMENTS}
of Section~\itemref{CONVERSION-ASSIGNMENTS} is \underline{not}
applicable.  Examples involving the No Direct Conversions Rule
are given in the Directing Conversions Section~\itemref{DIRECTING-CONVERSIONS}.

The second special rule applies if the functions, \TT{F} and \TT{G}
in the above code, have more than one definition, and therefore more
than one prototype.
This is the Conversion Disambiguation Rule described in
Section~\itemref{CONVERSION-DISAMBIGUATION}.

\subsection{Directing Conversions}
\label{DIRECTING-CONVERSIONS}

A \key{directing conversion} is an expression of the form:
\begin{center}
{\em qualifier}\STAR{} {\em type}\QMARK{} \TT{(} {\em subexpression} \TT{)}
\end{center}

in which at least one {\em qualifier} or the {\em type} is present.
The result of the directing expression is the value of the
temporary variable \TT{tmp} in:
\begin{center}
{\em qualifier}\STAR{} {\em type} \TT{tmp =} {\em subexpression}
~~~ [direct conversion allowed]
\end{center}
where if {\em type} was not given in the directing expression,
the type of the {\em subexpression} is used.  In this assignment,
direct conversions \underline{are allowed}; that is, the
No Direct Conversions rule does \underline{not} apply.

As an example, consider the code:
\begin{indpar}\begin{verbatim}
// Prototypes of builtin "+" operator:
function int64 result = ( int64 argument 1 )
                     "+" ( int64 argument 2)
function float64 result = ( float64 argument 1 )
                       "+" ( float64 argument 2)
int64 x = ...
int64 y = ...
*UNCHECKED* float64 s = x + y
float64 t = *UNCHECKED* float64 ( x )
          + *UNCHECKED* float64 ( y )
\end{verbatim}\end{indpar}

Here there are two definitions of \TT{"+"}, one for \TT{int64}
values and one for \TT{float64} values.
\TT{s} is computed by adding \TT{x} and \TT{y} as \TT{int64}
values, which has the disadvantage that if the result overflows,
it will be truncated to 64 bits.  \TT{t} on the other hand is
computed by first converting \TT{x} and \TT{y} to \TT{float64}
values and then adding, so overflows will not exist.  The last
statement of the above code is equivalent to:
\begin{indpar}\begin{verbatim}
*UNCHECKED* float64 tmp x = x  // Direct conversion allowed.
*UNCHECKED* float64 tmp y = y  // Direct conversion allowed.
float64 t = tmp x + tmp y
\end{verbatim}\end{indpar}


\subsection{Conversion Disambiguation}
\label{CONVERSION-DISAMBIGUATION}

Consider the code:
\begin{indpar}\begin{verbatim}
// Prototypes of builtin "+" operator:
function int32 result = ( int32 argument 1 )
                     "+" ( int32 argument 2)
function float64 result = ( float64 argument 1 )
                       "+" ( float64 argument 2)
int32 x = ...
int32 y = ...
float64 s = x + y
\end{verbatim}\end{indpar}

Here \TT{s} is computed by
\begin{indpar}\begin{verbatim}
int32 tmp x = x
int32 tmp y = y
int32 tmp s = tmp x + tmp y
float64 s = tmp s
\end{verbatim}\end{indpar}
using an implicit conversion of the result of \TT{"+"}.
But why not compute it by
\begin{indpar}\begin{verbatim}
float64 tmp x = x
float64 tmp y = y
float64 tmp s = tmp x + tmp y
float64 s = tmp s
\end{verbatim}\end{indpar}
using implicit conversions of the arguments of \TT{"+"}?

The answer is the
\begin{indpar}
\ikey{Conversion Disambiguation.}{conversion disambiguation}%
\index{disambiguation!conversion} Roughly, delaying conversions is
preferred.  For a precise specification of this rule, see text.
\end{indpar}

In general, the first compilation step after parsing a statement
is to match its subexpressions to function prototypes and introduce
temporary variables as per Section~\itemref{TEMPORARY-VARIABLES}.
There may be many ways to match subexpressions to function prototypes,
but usually these all introduce the same temporary variables.
So in the above example, the code becomes
\begin{indpar}\begin{verbatim}
T tmp x = x
T tmp y = y
T tmp s = tmp x + tmp y
float64 s = tmp s
\end{verbatim}\end{indpar}
where \TT{T} is either \TT{int32} or \TT{float64}.  It is possible
that different subexpression/prototype matches introduce different
sets of temporary variables, but such cases are anomalies caused by
poor name choices, and are treated as compilation errors.

In this case we prefer \TT{T == ins32} because \TT{ins32 -{}-{}-> float64},
as per the implicit conversion ordering of types introduced in
Section~\itemref{IMPLIED-CONVERSIONS}.

In general, we have a set of temporary variables \TT{tmp$_i$}
and for each matching $j$ an assigment of types
\TT{tmp$_i$~$\mapsto$~T$_{j,i}$}.  We say that a matching $j$ is
\mkey{more specific}{type matching}
than a matching $k$ if and only if \TT{T$_{j,i}$~-{}-{}->~T$_{k,i}$}
for every $i$.  A matching is \mkey{most specific}{type matching} if it is
more specific than every other matching.  If there is a most
specific matching, it is chosen; otherwise the statement is
ambiguous and its compilation is in error.

As a last example, consider
\begin{indpar}\begin{verbatim}
int32 x = ...
int32 y = ...
float64 s = float64 ( x ) + y
\end{verbatim}\end{indpar}
which because of the directed conversion compiles as
\begin{indpar}\begin{verbatim}
float64 direct tmp x = x
float64 s = direct tmp x + y
\end{verbatim}\end{indpar}
and then the last statement has only one matching
\begin{indpar}\begin{verbatim}
float64 tmp x = direct tmp x    // Only implict conversions
                                // allowed.
float64 tmp y = y               // Ditto.
float64 tmp s = tmp x + tmp y   // Only float64 "+" matches.
float64 s = tmp s
\end{verbatim}\end{indpar}

Note the effect of the most specific rule on expressions such as
`\TT{(x~==~y)~==~z}' where \TT{x}, \TT{y}, and \TT{z} are of type
\TT{bool} and \TT{==} produces `comparison results' as
on page \pageref{COMPARISON-RESULTS}.  The most specific rule
prevents the comparison result produced by `\TT{(x~==~y)}'
from being implicitly converted to a \TT{bool}.

[Though it is untraditional, it might be worth considering
using the `least specific' matching instead of the `most specific'.
But this would cause problems for `comparison results'.]

\section{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

Code is executed in blocks, which are described in more detail
below, and block executions have stacks that contain \underline{all}
their variables.
These variables are allocated and their values are computed by
assignment statements:

\begin{indpar}
\emkey{simple-assignment-statement}
    ::= \{ {\em result-variable-list} \TT{=} \}\QMARK{}
        {\em expression}
\\[0.5ex]
\emkey{result-variable-list}\label{RESULT-VARIABLE-LIST}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em result-variable-declaration} \\
    $|$ & \TT{(~}{\em result-variable-declaration} \\
        & ~~~~~~~~~~
	  \{ \TT{,} {\em result-variable-declaration} \}\STAR{} \TT{)} \\
    \end{tabular}
\\[0.5ex]
\emkey{result-variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & \ttkey{next} {\em variable-name}
    \end{tabular}
\end{indpar}

An assignment statement
allocates new variables with the given {\em variable-names}, types,
and qualifiers
to the stack and stores values from the {\em expression} in the variables
({\em qualifiers} are described in section \itemref{QUALIFIERS}).
The {\em expression} produces a list of values, and this list must have
at least as many elements as there are variables.  Each variable is
assigned its value in order.  If the {\em expression} produces
too many values, the excess values at the end of the value list will be
discarded.

The value assigned to each variable
must be implicitly convertable to the variable's type, unless
the variable has the \TT{*UNCHECKED*} qualifier, in which case
the value must be convertable by unchecked conversion to the
variable's type.

The {\em expression} may only input values that are constants or are
the values of other variables in the same function execution
stack (including
arguments passed to the function execution).  In particular,
no input can come \underline{directly}
from RAM memory outside the function execution stack
(but see \pagref{MEM} and Section~\itemref{THE-MEM-QUALIFIER}
for ways to load RAM values into stack variables).
See Section~\itemref{STACK-MANAGEMENT} for more information about stacks.

Implicitly when a variable value is set this way, the value is first
computed in a register, then stored in the stack, and for some time
afterwards the value is left in the register which becomes a cache
on the stack value.  This cacheing is hidden from the programmer.

If a variable value is copied from another variable, usually the
new variable simply becomes a compile-time alias for the old variable.
No executable copy code is created, no new register is allocated, and no new
value is pushed into the stack.

Similarly if a variable value can be computed from previous variable
values by in-line code, 
its value may not be pushed into the stack.  Instead its
value can be recovered at any time by repeating the computation
of the variable from the other values.

Two variables in the same block of code may not have the same
name.  Thus variables are only assigned values once.

However, if an assignment statement uses the word `\TT{next}' in
place of the {\em qualifiers} and {\em type-name}
of a variable being assigned a value, then the named variable must
have been previously assigned a value within the same block,
and a new variable with the same
name, type, and qualifiers as the previous variable is allocated,
and the new variable supercedes the previous variable in subsequent code within
the block.

Note that `\TT{next}' behaves differently for loop interation
variables (see below) than it does for other variables.

All assignment statements have a special case where there are
no variables being assigned, the {\em variables-list} is omitted,
and the \TT{=} is also omitted.  In this case the
{\em simple-assignment-statement} reduces to just an {\em expression}
that executes for side effects (such as
input/output or non-stack memory modification).

Some examples of {\em simple-assignment-statements} are:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = x + 1
next x = 10 * x         // Now x == 10
next y = x + 1          // Now y == 11
int32 z = 257
*UNCHECKED* int8 u = z  // *UNCHECKED* conversion used:
                        // Now u == 1
float64 m = 1.7
int32 i = m             // Illegal: undefined implicit
                        // conversion
*UNCHECKED* int32 j = m // *UNCHECKED* conversion used:
                        // now j == 2 (round to nearest)
\end{verbatim}\end{indpar}

\subsection{Block Assignment Statements}
\label{BlOCK-ASSIGNMENT-STATEMENTS}

Another variant of the assignment statement is\index{block assignment}:

\begin{indpar}
\emkey{block-assignment-statement}
    ::= \begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	\ttkey{do}\QMARK{} \TT{:} \\
	\TT{~~~~}{\em statement}\STAR{}
	\end{tabular}
\end{indpar}

where `\TT{do}' may be omitted as long as \TT{=} is not omitted.

The {\em statements} in the block can include
{\em assignment-statements} in which {\em variable-declarations}
are replaced by simple {\em variable-names}
if these variables have the same name as a variable
in the {\em block-assignment-statement's} {\em result-variable-list}.
These {\em statements} assign values to the variables
in the {\em block-assignment-statement's} {\em result-variable-list}.
Furthermore, every variable in the
{\em block-assignment-statement's} {\em result-variable-list}
\underline{must} be assigned a value
by exactly one of the {\em statements} in the block.
Also the value of one of these variables cannot
be input to any of the {\em statements} in the block until the
variable has been assigned a value by a previous one of these
{\em statements}.

Variables allocated in the block are not visible outside the
block.  They may \underline{not} have the same name as a variable
\TT{v} visible outside the block,  and they may \underline{not}
have the name `\TT{next v}' where  \TT{v} is a block result
variable or is otherwise visible outside the block.

An example of a {\em block-assignment-statement} is:
\begin{indpar}\begin{verbatim}
int32 x = 1
float64 y = 1.67
int64 z, *UNCHECKED* uns8 w, next x =:

    z = 16,777,216   // Legal, z is result variable
    x = 265          // Illegal, x is NOT result variable
    float64 y = 2.6  // Illegal, y is visible outside block
    uns8 v = 55      // Legal, v is NOT visible outside block
    next x = 266     // Legal, next x is result variable,
                     //        now x == 266
    next y = 2.6     // Illegal, y is visible outside block
                     //          and next y is not result
                     //          variable
    w = x            // Legal, sets w to 10 as x is now 266
                     //        and w is *UNCHECKED*
\end{verbatim}\end{indpar}

\subsection{Conditional Assignment Statements}
\label{CONDITIONAL-ASSIGNMENT-STATEMENTS}

\ikey{Conditional assignment statements}{conditional assignment}
are similar to block assignment statements:

\begin{indpar}
\emkey{conditional-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \ttkey{if}\TT{:} \\
	\TT{~~~~}\ttkey{default}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\TT{default:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	\TT{~~~~}\ttkey{else}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

In this case the {\em condition-expressions} are evaluated in order
until either one evaluates to true or the `\TT{else}' condition is
reached, and then the {\em statements} subject to the
first true condition (a.k.a the \key{subblock} of that condition)
are executed, or if no condition is true, the {\em statements}
of the `\TT{else}' subblock are executed.  Each separate subblock of
{\em statements} must set \underline{every} variable
in the {\em condition-assignment-statement's} {\em result-variable-list} exactly
once, with exceptions for defaults described next.

A {\em conditional-assignment-statement} with a
{\em result-variable-list} may have
`\ttkey{default}\TT{:}' subblocks.  Each assigns one or more
variables in the {\em result-variable-list}.  After any non-default subblocks
that are going to execute have executed, if there are any unset
variables in the {\em result-variable-list},
enabled default subblocks are executed
in order.  A default subblock is enabled if and
only if \underline{all} of the
{\em result-variable-list} variables set by the default subblock have
\underline{not} been set yet.

No two default subblocks may set the same {\em result-variable-list}
variable.  This rule is purely to prevent overly clever code that
uses the execution of earlier default blocks to disable the
execution of later default blocks.

Every variable in the {\em result-variable-list} \underline{must} be set by some
single subblock that executes.  A variable in the
{\em result-variable-list} cannot be read by a subblock {\em statement}
unless it is set by a previous {\em statement} in the
same subblock.

An example is:
\begin{indpar}\begin{verbatim}
function float64 result =
        max ( float64 x, float64 y, float64 z ):
    result = if:
        default:
            result = NaN
        x => y and x => z:
            result = x
        y => z && y => x:
            result = y
        z => y && z => x:
            result = z
\end{verbatim}\end{indpar}

where \TT{NaN} means `\key{not-a-number}' and is the missing
value for \TT{float64} variables.  \TT{x~=>~y} is true if
and only if neither \TT{x} nor \TT{y} is a \TT{NaN} and
\TT{x} is equal to or greater than \TT{y}.  Thus if any of
\TT{x}, \TT{y}, or \TT{z} in the above conditional assignment
is a \TT{NaN}, none of the non-\TT{default} {\em conditional-expressions}
will be true, and the \TT{default} will be evaluated to set
the \TT{result} to a \TT{NaN}.

There are a couple of special rules applying to conditionals:%
\label{CONDITIONAL-SPECIAL-RULES}

\begin{indpar}
A subblock not compiled because the compiler can determine its
condition will never be true is not checked for compile errors.
\end{indpar}

For example, if a {\em conditional-assigment-statement}
contained
\begin{indpar}\begin{verbatim}
    if T is in floating-types:
        result = NaN
\end{verbatim}\end{indpar}
where \TT{T} is a type known at compile time,
then if \TT{T} is not a floating
point number type, `\TT{result = NaN}' will not compile
and will not be checked for compile time errors.


A second special rule is:

\begin{indpar}
Missing `\TT{else}'s do not cause compile errors, though they
may cause warnings if the compiler cannot prove they will never
be needed.  They will cause run time errors if needed at run time.
\end{indpar}

For example, the {\em conditional-assignment-statement}:
\begin{indpar}\begin{verbatim}
    result =:
        if:
            x <= y:
                result = x
            y <= x:
                result = y
            T is in floating-types:
                result = NaN
\end{verbatim}\end{indpar}
where \TT{T} is the type of \TT{x} and \TT{y} will work as
follows.  If \TT{T} is not a floating point type, then a
warning message will be issued and an implicit `\TT{else}'
clause that is a fatal error at run time will be compiled, unless the
compiler can prove that an `\TT{else}' is not needed because
for values of type \TT{T} it is
true that either `\TT{x~<=~y}' or `\TT{y~<=~x}' (which
the compiler will be able to do for integer types).  If
\TT{T} is a floating point type, the compiler will be able
to prove that an `\TT{else}' is not needed, as the last condition
is always true.


\subsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

\ikey{Loop assignment statements}{loop assignment}
are similar to block assignment
and conditional assignment statements.  An example is:
\begin{indpar}\begin{verbatim}
// Calculate the sum of i for i == 1 to i == n.
//
int64 n = . . .
int64 sum = loop:
    initially:
        int64 i = 1
        int64 partial sum = 0
    while i <= n:
        next partial sum = partial sum + i
        next i = i + 1
    finally:
        sum = partial sum
\end{verbatim}\end{indpar}



The general syntax of loop assignment statements is:

\begin{indpar}
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	          \ttkey{loop:} \\
	\TT{~~~~}\ttkey{initially}\TT{:} \\
	\TT{~~~~~~~~~}{\em assignment-statement}\STAR{} \\
	\TT{~~~~}\ttkey{while} {\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ttkey{finally}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

This is somewhat like the conditional assignment statement
except the `\TT{while}' subblock is iterated and there are iteration
variables defined by the `\TT{initially}' subblock.

The \skey{iteration variable}s are the
{\em result-variables} of the
{\em assignment-statements} executed by the `\ttkey{initially}' subblock.
Each iteration of the loop gives these variables new values using
`\TT{next v}' to refer to the next value of \TT{v}, where \TT{v}
is an iteration variable.  In the example `\TT{i}' and
`\TT{partial sum}' are iteration variables.

The iteration subblock is qualified by `\ttkey{while}'
{\em condition-expression}' and only executes if the
{\em condition-expression} evaluates to true.  Then
for every iteration variable \TT{v}
it must set the variable `\TT{next v}' or `\TT{next next v}',
as indicated below.

Lastly, when
the {\em condition-expression} evaluates to false, the
subblock qualified by `\ttkey{finally}'
executes, and it must set all the variables in the
loop statement's {\em result-variable-list}.  At this point the loop stops
executing.

Loops are always in effect unravelled so multiple copies of
the `\TT{while}' subblock exist at one time.
`\TT{next v}' refers to \TT{v} in the
next iteration of the loop, which exists simultaneously with
the current iteration.  `\TT{next next v}' refers to \TT{v}
in the next iteration to the next iteration of the loop, which
also exists simultaneously with the current iteration.

For a given iteration variable \TT{v},
either the `\TT{initially}' subblock sets \TT{v}
and the `\TT{while}' subblock sets `\TT{next v}',
or the `\TT{initially}' subblock sets both \TT{v} and `\TT{next v}'
and the `\TT{while}' subblock sets `\TT{next next v}'.
Values of `\TT{next v}' and `\TT{next next v}' may be stored in
the stack memory of an iteration that will never be executed.

The \TT{finally} subblock executes at the end using the iteration
variable values that would be used for an additional iteration,
were such an iteration to exist.

There are always at least 4 iterations of the loop with variables
simultaneously in the current execution frame stack: the current iteration,
the previous iteration (if any), and the next two iterations.
When the third iteration of the loop starts, the first
iteration can be discarded, and so forth.

The stack (\itemref{STACK-MANAGEMENT})
of a loop iteration may be deallocated after the
iteration finishes executing.
However, deallocation of some of these stacks may be deferred by
an implementation, which may allow debuggers to look at them
in some circumstances.

Any iteration variable \TT{v} \underline{cannot} be referenced
within either the `\TT{initially}' or `\TT{while}' blocks
after `\TT{next v}' has been assigned in the block.
However `\TT{next v}' can be referenced.

Similarly `\TT{next v}' cannot be referenced
after `\TT{next next v}' has been assigned in the block.
However `\TT{next next v}' can be referenced.

These rules exist to reduce confusion with the non-iteration
case where the forbidden references have a very different meaning.%
\footnote{Perhaps we should use `\TT{new v}' for non-iteration
variables, forbid `\TT{new v}' for iteration variables, and
allow unrestricted access to \TT{v} and `\TT{next v}' after the
latter is assigned.}


\subsection{Call Assignment Statements}
\label{CALL-ASSIGNMENT-STATEMENTS}

Note that functions are most commonly inline, and not out-of-line.
Inline functions are described later in Section~\itemref{INLINE-FUNCTIONS}.

\ikey{Call assignment statements}{call assignment}
are used to call out-of-line functions:

\begin{indpar}
\emkey{call-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em call-assignment-option}\STAR
		~\ttkey{call}~ {\em function-expression} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{}
	\end{tabular}
\\[1ex]
\emkey{call-assignment-option}
	\begin{tabular}[t]{rl}
	::= & \ttkey{*UNCHECKED*} $|$ \ttkey{*REVERSE*}
	                          $|$ \ttkey{*NO-RELOAD*} \\
	$|$ & \ttkey{*COMPILE-TIME*} $|$ \ttkey{*COMPILE-TIME-ONLY*}
	\end{tabular}
\\[1ex]
\emkey{argument-assignment-statement} ::=
    \begin{tabular}[t]{l}
    {\em assignment-statement} in which \\
    `\TT{next} {\em variable-name}' \\
    is not a result variable
    \end{tabular}
\end{indpar}

The {\em function-expression} evaluates to a function to be called,
and its type \TT{T} must have the \TT{adr} type as its underlying type.
The values of the variables created by the {\em argument-assignment-statements}
are the arguments to the function.
The results of the function call are stored in the
{\em result-variable-list} variables.

A call assignment must have the \TT{*UNCHECKED*} option
unless \TT{T} is declared by an out-of-line
function type declaration described below.  If there is no
such declaration, the arguments are presented to the out-of-line
function in the order they are listed in the {\em call-assigment-statement},
unless the \TT{*REVERSE*} option is given, in which case this order
is reversed.

If there is an out-of-line function type declaration, arguments in the
call are matched by name to arguments in the type declaration,
and then ordered as per the type declaration.  In this case
the \TT{*UNCHECKED*} and \TT{*REVERSE*} options are ignored and have no effect.

Normally a `\TT{reload mem}' statement (see \itemref{THE-RELOAD-COMMAND})
is executed automatically
upon returning from the called function, but the
\ttkey{*NO-RELOAD*} option suppresses this.

If the \TT{*COMPILE-TIME*} option is given, the call
will be made at compile time only if the argument values are available
at compile time, and will otherwise be made at run time.  When the call
is made determines whether any result variable values are determined
at compile time.  If the \TT{*COMPILE-TIME-ONLY*} option is given,
the call is made at compile time, and the argument values must be
available at compile time.

An out-of-line function type declaration has the form:

\begin{indpar}
\emkey{function-type-declaration} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function type}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{}
		    {\em defined-type-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{}
	\end{tabular}
\\[0.5ex]
\emkey{argument-variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{function-declaration-option}
	\begin{tabular}[t]{rl}
	::= & \ttkey{*NO-RELOAD*} \\
	$|$ & \ttkey{*COMPILE-TIME*} \\
	$|$ & \ttkey{*COMPILE-TIME-ONLY*}
	\end{tabular}
\end{indpar}

This makes \TT{adr} the base type of the new
defined type, and declares the prototype
for the function.
Then a call assignment block is type-checked by matching
the variable names in the call assignment block
to those in the prototype.  Thus in this case the order of variables
in the call block does not matter as they will be matched by
variable name to the prototpye and then their values will be
reordered according to the prototype.  Also, in this case
a call block argument
may be of different
type than corresponding prototype argument if there is an implied
conversion from the call block
argument type to the prototype argument type,
in which case the implied conversion will be invoked.
Note that the conversion \underline{must be implied}, and not
\TT{*UNCHECKED*}, even if the prototype argument has the
\TT{*UNCHECKED*} qualifier.

Out-of-line functions are defined by declarations of the form:

\begin{indpar}
\emkey{out-of-line-function-declaration} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{} \\
		\TT{~~~~~~~~}{\em function-type-name} ~~
		             {\em function-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
		\TT{~~~~do:} \\
		\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}\label{OUT-OF-LINE-FUNCTIONS}

This defines {\em function-name} to be both a compile-time and run-time
constant (with different values at compile and run time) of type
{\em function-type-name} and also declares {\em function-type-name}
after the manner of a {\em function-type-declaration}.  When the function
is called, the {\em statements} of its `\TT{do}' subblock execute to produce the
result variable values from the argument variable values.

For the function to be callable at compile time, the
\TT{*COMPILE-TIME*} or \TT{*COMPILE-\EOL TIME-\EOL ONLY*} options must be given.
Then the function may not reference Global Areas that are
do not have the same options (see Section~\itemref{GLOBAL-AREAS}).
See Section~\itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS}.
A \TT{*COMPILE-\EOL TIME*} out-of-line function will also be callable at
run time, but a \TT{*COMPILE-\EOL TIME-\EOL ONLY*}
out-of-line function will only be callable
at compile time.

A function type may be declared multiple times.  All these declarations
must be identical except for ordering of options and qualifiers.

Normally the standard call linkage for the computer environment of
the program is used.  Other implementation specific call options
may alter the call linkage used.

\subsection{Out-of-Line Assignment Statements}
\label{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}

An \key{out-of-line assignment statement} is like a combination of
a {\em call-assignment-statement} with
an {\em out-of-line-function-declaration}:

\begin{indpar}
\emkey{out-of-line-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em function-declaration-option}\STAR
		~\ttkey{out-of-line} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

An {\em out-of-line-function-declaration} is constructed from this statement
by replacing the `\TT{out-\EOL of-\EOL line}' keyword by
an internally generated {\em function-type-name}
and {\em function-name}, and converting each {\em argument-assignment-statement}
to an {\em argument-variable-declaration}.

Then this statement is executed as a {\em call-assign\-ment-statement}
using the {\em function-name} and deleting the `\TT{do}' subblock.

{\em Out-of-line-assignment-statements} are generally included in
inline functions which preprocess arguments and may use various
{\em out-of-line-assignment-statements} to handle complex subcases.
When compiled multiple times in different contexts, the same
{\em out-of-line-assignment-statement} may be optimized in different
ways, and produce different out-of-line functions.  When it produces
the same out-of-line function more than once, this out-of-line function will
\underline{not} be duplicated.


\subsection{Compile-and-Run Assignment Statements}
\label{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}

A \key{compile-and-run assignment statement} computes a set of
variables that have values constant in a block, then compiles
the block using these constant values to optimize the compilation,
and lastly runs the block:

\begin{indpar}
\emkey{compile-and-run-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
		~\ttkey{compile-and-run} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

The variable values are set by the {\em argument-assignment-statements}.
Then the `\TT{do}' subblock {\em statements} are compiled, using
the variable values to optimize the compilation.  Then the
compiled code is executed.  The variables in the {\em result-variable-list}
may be set by either {\em argument-assignment-statements} or
`\TT{do}' subblock {\em statements} as for
a block assignment statement (see \itemref{BlOCK-ASSIGNMENT-STATEMENTS}).
If a variable \TT{v} not in the {\em result-variable-list}
is set by an {\em argument-assignment-statement},
`\TT{next v}' can be set by a `\TT{do}' subblock {\em statement}, but
this will be a new variable whose value may not be available during
the compilation.

When the compile-and-run assignment statement is executed, the compiled
code will be saved in a table indexed by the values of the
variables set by the {\em argument-assignment-statements}.  When the
compile-and-run assignment statement is re-executed, if these
variables have the same value they had during a previous execution,
the compilation will be bypassed and the previously compiled code used.
This optimization is required, but such previously compiled code
may be discarded if it has not been used in a long time.


\subsection{Assembly Assignment Statements}
\label{ASSEMBLY-ASSIGNMENT-STATEMENTS}

\ikey{Assembly assignment statements}{assembly assignment statement}
are used to embed assembler instructions in compiled code:

\begin{indpar}
\emkey{assembly-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~\TT{*UNCHECKED*}~\ttkey{*ASSEMBLY*:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em assembler-instruction}\STAR{} \\
	\end{tabular}
\end{indpar}

The variables, those produced by the {\em argument-assignment-statements},
the {\em argument-variable-declarations},
and the result variables, are placed in machine registers
and their names become machine register names for the assembler instructions.
Assembler instructions are only permitted to reference these
machine registers, but load and store assembler instructions may be used.
The assembler instructions are written in the syntax of one of the
target machine assemblers.

The variables may have additional qualifiers which
are names of machine registers or groups of machine registers.  In this case
the variables will be allocated to the specified machine registers or
machine register groups.  Otherwise they will be allocated to target
machine specified register groups based on variable type.

The {\em argument-variable-declarations} list intermediate
variables.  Only the variables named in the {\em argument-assignment-statements}
are given initial values.  Unlike normal code, values of variables
of an {\em assembly-assignment-statement} can be overwritten by the
{\em assembler-instructions}, and there is no check to be sure that
result variables receive any value.

\subsection{Compile-Time Assignment Statements}
\label{COMPILE-TIME-ASSIGNMENT-STATEMENTS}

\ikey{Compile-time assignment statements}{compile-time assignment statement}
run only once, when they are compiled, and produce variable values
at compile time:

\begin{indpar}
\emkey{compile-time-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~~~ \ttkey{compile-time:} \\
	\TT{~~~~}{\em statement}\STAR{}
	\end{tabular}
\end{indpar}

A compile-time block has its own stack, which is freed when the
block finishes executing.

Compile time blocks may only use compile time variables and values,
but may use visible inline functions, out-of-line functions
that have been declared to be compile-time, and global areas
that have been declared to be compile-time.

\section{Scopes}
\label{SCOPES}

A \key{declaration} is a statement the defines a name which
can be referenced in code.  Assignment statements also
introduce the names of their result variables, and serve
as declarations of these result variables.

Declarations are statements in blocks.  A declaration has
a \key{scope}, that is the set of statements in which any
name defined by the declaration is recognized.  The scope
of a declaration begins just after the declaration itself, and
lasts to the end of smallest block containing the declaration.
The scope of a name is the scope of the declaration that defines
it.

Two different declarations of the same name may \underline{not}
have overlapping scope, except when the second declaration is
for `\TT{next} {\em variable-name}' and both declarations are
in the same smallest containing block.

The scope of a name consists of statements and subblocks.
By the last rule, a name may not be
redeclared in a subblock that is in the name's scope.
So `\TT{next v}' cannot be declared in a subblock that is inside the scope
of `\TT{v}'.

\section{Inline Functions}
\label{INLINE-FUNCTIONS}

Most functions are inline.  An inline function can call an out-of-line
function by using
a call assignment statement (\itemref{CALL-ASSIGNMENT-STATEMENTS})
or the out-of-line assignment statement
(\itemref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}).

Inline function declarations have the form:

\begin{indpar}
\emkey{function-declaration}
    ::= \begin{tabular}[t]{l}
        \ttkey{function} {\em function-prototype}\TT{:} \\
	~~~~ {\em statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{function-prototype}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em result-variable-list} \TT{=} {\em function-name}
	    {\em argument-variable-list}\QMARK{} \\
    $|$ & {\em function-name} {\em argument-variable-list}\QMARK{} \\
    $|$ & {\em function-name} {\em argument-variable-list}\QMARK{}
            \TT{=} {\em input-variable-list} \\
    $|$ & {\em function-prototype}
          \TT{[[} {\em qualifying-expression} \TT{]]} \\
    $|$ & {\em other} as per Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS} \\
    \end{tabular}
\\[1ex]
\emkey{qualifying-expression}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em call-compile-time-logical-expression} \\
    $|$ & {\em abbreviation-name} \TT{is} {\em call-compile-time-expression} \\
    $|$ & {\em other} as per Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS} \\
    \end{tabular}
\\[1ex]
\emkey{result-variable-list} ::= see \pagref{RESULT-VARIABLE-LIST} \\
\\[1ex]
\emkey{argument-variable-list}\label{ARGUMENT-VARIABLE-LIST}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(~}{\em argument-variable-declaration} \\
        & ~~~~~~~~~~
	  \{ \TT{,} {\em argument-variable-declaration} \}\STAR{} \TT{)} \\
    \end{tabular}
\\[0.5ex]
\emkey{argument-variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\end{indpar}

A function call with a {\em result-variable-list}
is in effect replaced by a {\em block-assignment-statement}
(Section~\itemref{BlOCK-ASSIGNMENT-STATEMENTS})
with the {\em function-declaration's} {\em result-variable-list} becoming the 
{\em result-variable-list} of the {\em block-assignment-statement} and the
{\em function-declaration's} subblock {\em statements} becoming the 
{\em block-\EOL assign\-ment-\EOL state\-ment's} subblock {\em statements}.
Actual argument values from the function call are assigned to variables in
the definition {\em argument-variable-list}.  The values produced in
the {\em result-variable-list's} variables become the values of the
function call when it is used as part of an {\em expression}.

When this is done, the names declared by {\em statements} in the
function block are in effect changed so they will not conflict
with names the call is within scope of.  Also, names not declared
in the function block but used in the block are resolved
in the context of the function block declaration itself,
and not in the context of a call to the function.\footnote{
Because L-Language is a single assignment language, all such
names are the names of constants.}

A function call without any {\em result-variable-list}
is just like a function call with an empty
{\em result-variable-list}.

A function call with an {\em input-variable-list} is just syntactic
sugar for a function call with neither a {\em result-variable-list}
or {\em input-variable-list}.  Specifically
\begin{center}
\TT{F(a1,a2,...)~=~(b1,b2,...)} \\
is syntactic sugar for \\
\TT{F(a1,a2,...)(b1,b2,...)} \\
\end{center}

where use is made of the fact that a function can have multiple
argument lists (Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS}).

An argument or return variable can have the `\TT{type}' type.
If an argument variable has type `\TT{type}', its value can be used as the
type of other argument variables that are
after it in the {\em argument-variable-list},
or of any result variable.  For example:

\begin{indpar}\begin{verbatim}
function ( T result ) = add ( type T, T v1, T v2 ):
    result = v1 + v2

// Example usage
//
int32 x = ...
int32 y = ...
int32 z = add ( int32, x, y )
\end{verbatim}\end{indpar}

A type argument can be implied if it is the type of another argument
after it in the argument list, or the type of a result.  For example:

\begin{indpar}\begin{verbatim}
int32 z = add ( x, y )
\end{verbatim}\end{indpar}

Conditions can be written at the end of a {\em function-prototype},
as in:
\begin{indpar}\begin{verbatim}
types signed-integer-types =
    {{ int8, int16, int32, int64, int128 }}

function ( T result ) = add ( type T, T v1, T v2 )
    [[ T is in signed-integer-types ]]:
    result = v1 + v2
\end{verbatim}\end{indpar}

which would define `\TT{add}' only for signed integer types.
The conditions must be evaluatable whenever a call to the
function is compiled.

If an argument variable has type `\TT{qualifiers}',
its value is a set of qualifiers,
it can be used to denote the qualifiers of any variable
after it in the {\em argument-variable-list}, and it can be
used to compute qualifiers of either argument or result variables.
For example:
\begin{indpar}\begin{verbatim}
function ( Qr pointer result ) =
    increment ( qualfiers Qs, Qs pointer value )
    [[ Qr is Qs & {{ stack }} ]]:
    . . . . . . . . . .
\end{verbatim}\end{indpar}

Here \TT{Qs} denotes the qualifiers of the `\TT{value}' argument
and \TT{Qr} is just an abbreviation of the more complex
qualifiers-valued expression defined by `\TT{[[ Qr is~}\ldots\TT{]]}'.

Arguments of type `\TT{qualifiers}' may be implied if they
denote the qualifiers of a given argument appearing later in the
argument list.  So in the above,
the \TT{Q} argument may be implied.

If `\TT{type}' or `\TT{qualifiers}' arguments can be implied
but are given explicitly instead, their values must be available
at compile time.

Since they are inline, functions can use abbreviation arguments as function
names.  An example is:
\begin{indpar}\begin{verbatim}
function ( T r1, T r2 ) =
        sort2 ( type T, T x, T y, abbreviation less-than ):
    if:
        less-than ( x, y ):
            r1 = x; r2 = y
        else
            r1 = y; r2 = x

// Function that is like < except it makes a NaN less than
// a non-NaN ( < is false if either argument is NaN ).
//
function bool r = less-than-float64 ( float64 x, float64 y ):
    r = if:
        is-NaN ( x ): r = true
        x < y:        r = true
        else:         r = false

float64 b1 = 5.37857
float64 b2 = 5.37289
( float64 c1, float64 c2 ) =
    sort2 ( b1, b2, `less-than-float64' )
\end{verbatim}\end{indpar}

However, as names in a function block are resolved in the context
of the function block declaration, and not in the context of a
call, the following fails:
\begin{indpar}\begin{verbatim}
function ( T r1, T r2 ) = sort2 ( type T, T x, T y ):
    if:
        less-than ( x, y ):
            r1 = x; r2 = y
        else
            r1 = y; r2 = x

// Function that is like < except it makes a NaN less than
// a non-NaN ( < is false if either argument is NaN ).
//
function bool r = less-than-float64 ( float64 x, float64 y ):
    r = if:
        is-NaN ( x ): r = true
        x < y:        r = true
        else:         r = false

float64 b1 = 5.37857
float64 b2 = 5.37289
( float64 c1, float64 c2 ) = sort2 ( b1, b2  )
    // Illegal because `less-than' in function block is
    // not defined when function block was declared.
\end{verbatim}\end{indpar}

More complex {\em function-prototypes} can be written:
see Function Prototypes and Calls, \itemref{FUNCTION-PROTOTYPES-AND-CALLS}.
In particular, implied conversions have the prototype:
\begin{center}
\TT{Q T2} {\em result-variable}%
    ~~\TT{=}~~\TT{( qualifiers Q, Q T1} {\em source-variable} \TT{)}
\end{center}
for particular types \TT{T1} and \TT{T2}, and binary operators have prototypes
like
\begin{center}
\TT{T1} {\em result-variable}%
    ~~\TT{=}~~\TT{( T2} {\em argument-variable-1} \TT{)}
    ~~\TT{"}{\em operator}\TT{"}~~\TT{( T2} {\em argument-variable-2} \TT{)}
\end{center}
for a particular types \TT{T1} and \TT{T2}
and binary operator \TT{"}{\em operator}\TT{"}.


\section{Generics}
\label{GENERICS}

A \key{generic} is like an inline function except that:
\begin{enumerate}
\item All the arguments in a generic call must have compile-time values.
\item The generic call has no result variables.
\item The code in the generic block runs at compile-time and
      assigns its variables compile-time values.
\item There is an extra `\TT{include}' block consisting of
      statements that replace the generic call
      in the code that contains the call.  These included statements may
      contain the names of call arguments and computed block variables,
      including abbreviations, and these are replaced
      in the included statements by their values.
\end{enumerate}

Generic declarations have the form:

\begin{indpar}
\emkey{generic-declaration}
    ::= \begin{tabular}[t]{l}
        {\em generic-prototype}\TT{:} \\
	\TT{~~~~}{\em assignment-statement}\STAR{} \\
	\TT{~~~~include:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{generic-prototype}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{generic} {\em generic-name}
	    {\em argument-variable-list}\QMARK{} \\
    $|$ & {\em other} as per Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS} \\
    $|$ & {\em generic-prototype}
          \TT{[[} {\em qualifying-expression} \TT{]]} \\
    \end{tabular}
\\[1ex]
{\em qualifying-expression} ::= see \pagref{QUALIFYING-EXPRESSION}
\end{indpar}

An example is:
\begin{indpar}\begin{verbatim}
generic min-max functions ( type T )
    include:
        function T result = min ( T x, T y ):
            result = if:
                x <= y:
                    result = x
                y <= x:
                    result = y
                T is in floating-types:
                    result = NaN
        function T result = max ( T x, T y ):
            result = - min ( -x, -y )

min-max functions ( int64 )
int64 u = ...
int64 v = min ( u, -1,000,000 )
int64 w = max ( u, 1,000,000 )
\end{verbatim}\end{indpar}

The special conditional assignment statement
rules described on page \pageref{CONDITIONAL-SPECIAL-RULES}
are applied here to enable \TT{T} to be any integer or
floating point number type.

\section{Clusters}
\label{CLUSTERS}

A \key{cluster} is a group of related variables.  One variable of
the cluster is the \mkey{base variable}{of cluster} of the cluster, and the
other variables have names that are derived from the
name of the base variable by adding {\em member-selectors}
to the end of the base variable name.  See \pagref{NAMES}.

Thus a cluster
is like a C/C++ structure, but it is a set of variables and not a
piece of memory.

More specifically, the members of the cluster can be named by
adding either a member name beginning with a `\TT{.}' or a
`\TT{[]}' bracketed list of
integer constant subscripts to
either the base variable name of the cluster or to another member name
of the cluster.  Two variable names with different base variable names
belong to different clusters.

Variables in clusters are thus organized into trees, with clusters
that have different bases being in disjoint trees.  Any variable in a cluster
can be considered
as the \mkey{root}{of subcluster} of a subtree of cluster members, and
the subtree is called a \key{subcluster}.

The main feature of clusters and subclusters
is that members are passed to or returned
from functions implicitly when their the root variable is named
explicitly.  Furthermore, cluster members \underline{cannot}
be passed explicitly, and cannot be created except as results
of function calls.

For example:
\begin{indpar}\begin{verbatim}
type pointer pair is void
    // if pp is a pointer pair then:
    //   unsadr pp.begin is the offset of the first element
    //   unsadr pp.end is the offset just AFTER the
    //                 last element
    //   mem adr pp.begin.base is the base address that
    //                         is added to the offsets
    //   *UNCHECKED* adr pp.begin.base.adr is the address of
    //                                     pp.begin.base
    //   type pp.type is type of elements pointed at

// Function to allocate a vector of n T's to the stack.
//
function ( stack pointer pair pp,
           unsadr pp.begin,
           unsadr pp.end,
           mem adr pp.begin.base,
           *UNCHECKED* adr pp.begin.base.adr,
           type pp.type ) =
        allocate to stack ( type T, uns32 n ):
    require ( zero value OK ( T ) )
    pp.type = T
    unsadr length = size of ( T ) * n
    pp.begin = allocate to stack ( length )
        // This also sets pp.begin.base and
        // pp.begin.base.adr.
    pp.end = pp.begin + length


// Prefix operator to dereference a pointer pair to read
// memory.
//
function ( mem pp.type out,
           *UNCHECKED* adr out.adr ) =
        "*" ( stack pointer pair pp,
              type pp.type,
              unsadr pp.begin,
              unsadr pp.end,
              *UNCHECKED* adr pp.begin.base ):
    if:
        pp.begin < pp.end:
            out.adr = pp.begin + pp.begin.base
        else:
            fatal error
                ( "Deferencing empty pointer pair." )

// Prefix operator to dereference a pointer pair to
// write memory.
//
function "*" ( stack pointer pair pp,
               type pp.type,
               unsadr pp.begin,
               unsadr pp.end,
               adr pp.begin.base )
             ( pp.type in ):
    if:
        pp.begin < pp.end:
            adr destination = pp.begin + pp.begin.base
            *WRITE* in destination
        else:
            fatal error
                ( "Deferencing empty pointer pair." )

// Prefix operator to increment the begin pointer of a
// pointer pair.  Note the result is a NEW pointer pair.
//
function ( stack pointer pair pp2,
           unsadr pp2.begin,
           unsadr pp2.end,
           mem adr pp2.base,
           *UNCHECKED* adr pp2.base.adr,
           type pp2.type ) =
        "++" ( stack pointer pair pp,
               type pp.type,
               unsadr pp.begin,
               unsadr pp.end,
               *UNCHECKED* adr pp.base.adr ):
      pp2.begin = pp.begin + size of ( pp.type )
      pp2.end = pp.end
      pp2.base.adr = pp.base.adr
      pp2.type = pp.type

// Assignment operator for pointer pairs.
//
function ( stack pointer pair pp2,
           unsadr pp2.begin,
           unsadr pp2.end,
           mem adr pp2.base,
           *UNCHECKED* adr pp2.base.adr,
           type pp2.type )
        = ( stack pointer pair pp,
            type pp.type,
            unsadr pp.begin,
            unsadr pp.end,
            adr pp.base.adr ):
      pp2.begin = pp.begin
      pp2.end = pp.end
      pp2.base.adr = pp.base.adr
      pp2.type = pp.type

// Example usage:
//
function ...

    // Vector of 2 int32's is allocated and the elements
    // are set equal to 100 and 101.
    //
    pointer pair pp = allocate to stack ( int32, 2 )
    * pp = 100
    next pp = ++ pp
    * pp = 101
    . . . .
    // Vector of 1000 float64's is summed.
    //
    pointer pair ppf = allocate to stack ( float64, 1000 )
    ... set 1000 elements ...
    float64 sum = loop:
        initially:
            float64 partial sum = 0
            pointer pair ppf2 = ppf
        while ppf2.begin < ppf2.end:
            next partial sum = partial sum + * ppf2
            next ppf2 = ++ ppf2
        finally:
            sum = partial sum
\end{verbatim}\end{indpar}

Note that although the functions defining operations on a pointer pairs
are a long winded, usage of pointer pairs is compact and easy.
This is a general characteristic of the L-Language, and derives
from the fact that the functions automatically manage the members
of a cluster.

Cluster member names may be used as prototype parameter
names, with the root of these names also being a prototype
parameter.  This specifies that the parameters are related
by being in the same cluster.

When this is done for prototype arguments, the cluster root must
also be an argument, and the cluster member values
will be derived from the root, and \underline{must}
be omitted in calls.  If the cluster members named as arguments
in the function prototype do not exist,
the function prototype does not match the call.

When this is done for prototype results, the cluster root must similarly
be a either a result or argument, and the designated
members of the cluster are created and set from the results.
Again the cluster members \underline{must} be omitted in calls,
but will be automatically created.
Note that when this is done any qualifiers on the omitted cluster
members will be set by the prototypes.

Also, if all result variables are cluster members, then calls
using the prototypes will have no explicit result variables,
but will create new members of existing clusters.  For example:
\begin{indpar}\begin{verbatim}
function ( bool v.nonneg ) = test sign ( int32 v ):
    if:
        v >= 0:
            v.nonneg = true
        else:
            v.nonneg = false

int32 x = 89
int32 y = -5
test sign ( x )
test sign ( y )
// Now x.nonneg exits and is true
// and y.nonneg exits and is false.
\end{verbatim}\end{indpar}

Cluster members may only be created as function call results.

A cluster member may be explicitly passed as a result variable
or argument if it is the root of a subcluster that is being
created or used.  The matching prototype variable must
be a cluster root, and \underline{not} a cluster member,
within the prototype.

A variable of \TT{void} type has no actual value
and must not be assigned one.  Such variables are only useful
as cluster and subcluster roots.

In the above example `\TT{mem}' and `\TT{stack} are special builtin qualifiers
which can be applied to variables.
See \itemref{BUILTIN-QUALIFIERS}.

The `\TT{mem}' qualifier\label{MEM}
has the special property that given a variable
\TT{v} of qualifier \TT{mem}, then if \TT{v} is allocated,
and \TT{v.adr} of type \TT{adr} and qualifier \TT{*UNCHECKED*}
is allocated and
assigned a value, the root \TT{v} will also be automatically
assigned as its value the value read from RAM address \TT{v.adr}.
It is an error in this case to explicitly assign a value to \TT{v}.
This is how \TT{out} gets its value from
\TT{out.adr}, and how \TT{pp.begin.base} gets its value from
\TT{pp.begin.base.adr}.

For details on the `\TT{mem}' qualifier see \itemref{THE-MEM-QUALIFIER}.

The `\TT{stack}' qualifier has the property that values with
this qualifier may not be passed out of a block with a free
stack.  This keeps stack addresses from escaping contexts in
which they are valid.  See Sections~\itemref{THE-STACK-QUALIFIER} and
\itemref{STACK-MANAGEMENT}.

A qualifier may be \ikey{inherited}{qualifier}\label{INHERITED-QUALIFIER}.
If an inherited qualifier
is applied to the root variable of a cluster
or subcluster, this inherited qualifier is automatically applied to all
the member variables in the cluster or subcluster.  This is not done
for non-inherited qualifiers.

The `\TT{stack}' qualifier is inherited.

A last example of the use of clusters is the implementation of
comparison operators so that
\begin{center}
\TT{(x~<~y)~<~z}
\end{center}
is the same as
\begin{center}
\TT{(x~<~y) AND (y~<~z)}
\end{center}
where \TT{y}, if it is an expression,
is not evaluated twice:\label{COMPARISON-RESULTS}
\begin{indpar}\begin{verbatim}
type comparison result is void
    // if cr is a comparison result then:
    //   bool cr.value is the result of the comparison
    //   type cr.type is the type of the values compared
    //   cr.type last is the last value compared

// Comparison result of x < y where x and y are type T.
//
function ( comparison result cr, bool cr.value,
           type cr.type, T cr.last ) =
        ( type T, T first ) "<" ( T last ):
    cr.type = T
    cr.last = last
    cr.value = first less than last

// Comparison result of x < y where x is a comparison result.
//
function ( comparison result cr, bool cr.value, type cr.type,
           T cr.last ) =
         ( comparison result cf, bool cf.value, type cf.type,
           cf.type cf.last ) "<" ( cf.type last ):
    cr.type = cf.type
    cr.last = last
    cr.value = cf.last less than last

// Implicit conversion of comparison result to bool.
//
function ( Qs bool result ) =
    ( qualifiers Qs, QS comparison result cr,
      bool cr.value, type cr.type, cr.type cr.last ):
    result = cr.value
\end{verbatim}\end{indpar}

\section{Builtin Qualifiers}
\label{BUILTIN-QUALIFIERS}

The builtin qualifiers are \TT{mem}, \TT{stack}, \TT{*UNCHECKED*},
and \TT{global}.
There is also a special class of qualifiers called trace qualifiers.

\subsection{The Memory Qualifier}
\label{THE-MEM-QUALIFIER}

The \ttkey{mem} qualifier is a protected qualifier that behaves
in a special way when it is given to a variable \TT{v}.
In this situation \TT{v} is a copy of a RAM memory value and
must be the root of a subcluster that
has either:
\begin{enumerate}
\item
A variable \TT{v.adr} of type \TT{adr} with either of the qualifiers
\TT{mem} or \TT{*UNCHECKED*} that is the RAM address of \TT{v}.

\item
A variable \TT{v.offset} of type \TT{intadr} or \TT{unsadr} and
qualifier \TT{*UNCHECKED*}, and
a variable \TT{v.offset.base} of type \TT{adr} and qualifier \TT{mem}
or \TT{*UNCHECKED*}.
In this case the RAM address of \TT{v} is \TT{v.offset+v.offset.base}.
If \TT{v.offset.base} has qualifier \TT{mem} it must recursively be
the root of a subcluster obeying
these rules (so there must be either a \TT{v.offset.base.adr} variable
or \TT{v.offset.base.offset} and \TT{v.offset.base\EOL .offset.base}
variables, etc.).
\end{enumerate}
The the
variable \TT{v} must \underline{not} be given a value by an
assignment statement, but will instead be loaded with a value
from its RAM address.  It is called a `\key{RAM cache variable}'.

However, if the value of the RAM address is available in another
variable, \TT{v} will be loaded from the other variable.
For example:
\begin{indpar}\begin{verbatim}
    mem int32 w
    adr w.adr = ...
    mem int32 v
    adr v.adr = w.adr	// v = w will be implicitly executed
\end{verbatim}\end{indpar}

Because \TT{mem} is a protected qualifier, \TT{v} and the required
members of the cluster of which \TT{v} is a root
must be created as matches to result variables of a function.
So only functions can effect a load of RAM contents to a variable.


\subsection{The Stack Qualifier}
\label{THE-STACK-QUALIFIER}

The `\ttkey{stack}' qualifier is an inherited, prohibited,
protected qualifier
attached to offsets and addresses
returned by the builtin `\TT{allocate to stack}'
function (\pagref{ALLOCATE-TO-STACK}).
It is used to keep these from being stored in
non-stack memory and in stacks who lifetime exceeds that of the
memory the stack address points at.

The special property of the `\TT{stack}' qualifier is that it cannot
be used to qualify variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
or iteration variables in a {\em loop-assignment-statement}.
This is so that stack addresses pointing into a free stack
cannot outlive the free stack.
See Section~\itemref{STACK-MANAGEMENT} for more information.

Also, as a prohibited qualifier, a \TT{stack} value cannot be
passed as an argument to a function that does not expect a
\TT{stack} value.  For example:
\begin{indpar}\begin{verbatim}
stack adr sa = ...
adr ta = ...
function adr result = F ( adr arg ):
    . . . . . . . . . .
function adr result = G ( stack adr arg ):
    . . . . . . . . . .
adr xa = F ( sa ) // Illegal; F's arg does not have
                  // stack qualifier.
adr ya = G ( sa ) // Legal; G's arg has stack qualifier.
adr za = G ( ta ) // Legal; G's arg's stack qualifier has
                  // no effect (its not required).
\end{verbatim}\end{indpar}

\subsection{The \TT{*UNCHECKED*} Qualifier}
\label{THE-UNCHECKED-QUALIFIER}

The \TT{*UNCHECKED*} qualifier is a
required qualifier that must qualify the \TT{v.adr} or
\TT{v.offset} variables
associated with a variable \TT{v} that has the \TT{mem} qualifier.
See Section~\itemref{THE-MEM-QUALIFIER}.

The \TT{*UNCHECKED*} qualifier is also required for the result variable
of an unchecked conversion.  When used for a result variable of an
assignment, the value assigned need only be convertable to the type
of the variable by an unchecked conversion, instead of by a checked
conversion.

The \TT{*UNCHECKED*} lexeme is also used as the initial part some
names. An example is the \TT{*UNCHECKED* *ASSEMBLY*} assignment statement.

\subsection{Trace Qualifiers}
\label{TRACE-QUALIFIERS}

A \key{trace qualifier} permits values to be marked so that they
can be found (i.e., `traced') by garbage collectors
(and occassionally debuggers)
when they are stored in the
stack.  A trace qualifier may be declared by:

\begin{indpar}
\emkey{trace-qualifier-declaration}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{trace qualifier}
           {\em defined-qualifier-name} \\
        & ~~~~~ \TT{with base type}~~{\em type-name}
    \end{tabular}
\end{indpar}

The base type of a trace qualifier may be determined by the
function with the prototype:
\begin{center}
{\tt (type T) = \ttkey{base type of} ( qualifier Q )}
\end{center}
The value of any variable with the trace qualifier must be
\TT{*UNCHECKED*} convertable to a value of the base type.

It is common to add a trace qualifier to the statement that
defines a type you want to trace.  An example in which the
qualifier is \TT{Q} and the type is \TT{T} is:
\begin{indpar}\begin{verbatim}
trace qualifier Q with base type adr
type Q T is adr
\end{verbatim}\end{indpar}
which causes all values of type \TT{T} in the stack to be
traced.

More specifically, when a value \TT{V} of a variable with the trace
qualifier \TT{Q} and base type \TT{B} is added to a stack,
\TT{V} converted to type \TT{B} is also
pushed into a (virtual or physical) \TT{Q}-stack of values of
type \TT{B}.
When the stack containing \TT{V} is freed, the corresponding
value in the \TT{Q}-stack is popped.  There is a \TT{Q}-stack
associated with every process and every global area.
Using functions in the
subroutine library (see TBD), these \TT{Q}-stacks can be read.

While a value may be pushed into a stack more than once,
a value will not be pushed if the compiler can prove it is already
in the stack.  Thus given the definitions above, in
\begin{indpar}\begin{verbatim}
T v = ...
T w = v
\end{verbatim}\end{indpar}
the first statement may push the value of \TT{v} to the \TT{Q} stack
but the second statement will not push the value of \TT{w} on
the grounds that it is already in the stack.

\subsection{The Reload Statement}
\label{THE-RELOAD-COMMAND}

The reload statement has the syntax:
\begin{center}
\ttkey{reload} {\em qualifier-name} \{ \TT{,} {\em qualifier-name} \}\STAR{}
\end{center}

This statement declares the values of all variables with the designated
qualifiers to be out-of-date and unusable.  If any of these variables
is used subsequently, statements to recompute the variable value
may be inserted automatically into the code at the point of the
\TT{reload} statement.

As a special case, if a variable that is declared to be out-of-date,
\TT{v}, has the `\TT{mem}' qualifier, and is the base of
a cluster that causes \TT{v} to be loaded from memory
(as per Section~\itemref{THE-MEM-QUALIFIER}), then if \TT{v} is declared
to be out-of-date, recomputing \TT{v} means that the necessary members
of the cluster headed by \TT{v} must first be recomputed, and then \TT{v}
must be reloaded from RAM.  The possibility that software cache
variables (with the \TT{mem} qualifier) will become out-of-date because
the RAM locations they cache have changed is the reason the `\TT{reload}'
statement exists.

The statement `\TT{reload mem}' can be used to declare all
variables that act as software caches of memory to be out-of-date.
Or a qualifier \TT{Q} can be attached to some \TT{mem} variables
and `\TT{reload Q}' can be used to declare just these to be out-of-date.

Note that variables computed from out-of-date variables are \underline{not}
declared to be out-of-date.

Variable values are recomputed in the same order as they were
originally computed.  How each variable is recomputed depends upon
how it was originally computed.

If a variable \TT{v} was originally computed by
an {\em assignment-statement}
of the form `{\em type} \TT{v =} {\em expression}', then if
no input to {\em expression} is out-of-date, \TT{v} is not out-of-date.
Otherwise if all the inputs that are out-of-date can be recomputed,
\TT{v} is recomputed.  However, \TT{v} is not recomputed if this
recompuation requires evaluation of loops or out-of-line calls or
writes to RAM;
but it will be recomputed if evaluation can be done with a conditional
statement subblock that does not involve loops or out-of-line calls or
writes to RAM,
even if other subblocks of the conditional statement do involve such.

If an out-of-date variable value is not used after the \TT{reload} statement,
it is not recomputed.

The `\TT{reload Q}' statement behaves like an executable statement but
it has some unusual properties when it is executed inside a heavily
nested subblock.  First, it declares out-of-date any variable with
qualifier \TT{Q} that is visible in its subblock \underline{and any
containing block}.
Second, it will recompute any variable in its subblock
\underline{or any containing block} that may be used after the
`\TT{reload Q}' statement executes.
Third, when it recomputes variables, it overwrites
the place the variable is stored, rather than allocating a new
place as would a `\TT{next~}{\em variable-name}' expression.
These properties allow `\TT{reload Q}' to appear in an inline
or conditional subblock.

\section{Memory Write Statements}
\label{MEMORY-WRITE-STATEMENTS}

Statements that write memory make use of cluster structures
similar to those used with
\TT{mem} qualifier variables:
see Section~\itemref{THE-MEM-QUALIFIER}.

Specifically, memory needs to be addressed.  This is done by either
of the following methods of specifying a RAM address:
\begin{enumerate}
\item
An `\key{address variable} \TT{va}
of type \TT{adr} with either of the qualifiers
\TT{mem} or \TT{*UNCHECKED*} that contains the RAM address.
If \TT{va} has qualifier \TT{mem} it must recursively be
the root of a subcluster obeying
the rules of Section~\itemref{THE-MEM-QUALIFIER},
so there must be either a \TT{va.adr} variable
or \TT{va.offset} and \TT{va.offset\EOL .base}
variables, etc.


\item
An `\key{address variable}' \TT{vo} of type \TT{intadr} or \TT{unsadr} and
qualifier \TT{*UNCHECKED*}, and
a variable \TT{vo.base} of type \TT{adr} and qualifier \TT{mem}
or \TT{*UNCHECKED*}.
In this case the RAM address is \TT{vo+vo.base}.
If \TT{vo.base} has qualifier \TT{mem} it must recursively be
the root of a subcluster obeying
the rules of Section~\itemref{THE-MEM-QUALIFIER},
so there must be either a \TT{vo.base.adr} variable
or \TT{vo.base.offset} and \TT{vo.base.offset\EOL .base}
variables, etc.

\end{enumerate}

\subsection{Single Value Write Statements}
\label{SINGLE-VALUE-WRITE-STATEMENTS}

The form of a single valued write statement is:

\begin{indpar}
\emkey{single-value-write-statement} ::=
    \TT{*WRITE*} {\em value-variable} {\em address-variable}
\end{indpar}

The value in the {\em value-variable} is written to the RAM address
in the {\em address-variable}.

\subsection{Memory Copy Statements}
\label{MEMORY-COPY-STATEMENTS}

The form of a memory copy statement is:

\begin{indpar}
\emkey{memory-copy-statement} ::=
    \TT{*COPY*} {\em source-variable} {\em destination-variable}
    		{\em length-variable}
\end{indpar}
Bytes are copied from the RAM address in the {\em source-variable}
to the RAM address in the {\em destin\-ation-\EOL variable}.
The number of bytes copied is in the {\em length-variable},
which must be of the \TT{unsadr} type.

If the source address is greater than the destination address,
the bytes are copied in ascending address order.  If the
source address is less than the destination address,
bytes are copied in descending address order.  If the two
addresses are equal, bytes may or may not be copied.  The effect of
all this is to copy regions of memory correctly even if they
overlap.


\subsection{Memory Set Statements}
\label{MEMORY-SET-STATEMENTS}

The form of a memory set statement is:

\begin{indpar}
\emkey{memory-set-statement} ::=
    \TT{*SET*} {\em value-variable} {\em address-variable}
    		{\em length-variable}
\end{indpar}
The `set length' is stored in the {\em length-variable} which must
be of \TT{unsadr} type.  As long as the set length is not zero,
this statement performs a \TT{*WRITE*} operation on its
first two arguments, and then increments the address by
the length of the type of the value, and decrements the set length
by one.

\subsection{Atomic Memory Statements}
\label{ATOMIC-MEMORY-STATEMENTS}

An \key{atomic-memory-statement} is a generalization of
the classic compare-and-set instruction.  It is a block assignment
statement that executes a sequence of specialized instructions:

\begin{indpar}
\emkey{atomic-memory-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \TT{( uns32 count, adr bad address ) = }\ttkey{*ATOMIC*} \TT{:} \\
	\TT{~~~~}{\em lock-instruction}\STAR{} \\
	\TT{~~~~}{\em compare-instruction}\STAR{} \\
	\TT{~~~~}{\em write-instruction}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{lock-instruction} ::= \ttkey{*LOCK*} {\em lock-variable} \\
\emkey{compare-instruction} ::= \ttkey{*COMPARE*} {\em compare-variable}
						  {\em address-variable} \\
\emkey{write-instruction} ::= \\
\hspace*{0.2in}\begin{tabular}[t]{rl}
        & \TT{*WRITE*} {\em value-variable} {\em address-variable} \\
    $|$ & \TT{*COPY*} {\em source-variable} {\em destination-variable}
    		      {\em length-variable} \\
    $|$ & \TT{*SET*} {\em value-variable} {\em address-variable}
    		     {\em length-variable} \\
    \end{tabular}
\end{indpar}

The special instructions,
which make use of clusters (Section~\itemref{CLUSTERS}),
and are as follows:
\begin{indpar}[0.4in]
\hspace*{-0.2in}{\em \bf Lock-Instruction}.
The {\em lock-variable} is of type \TT{uns32}
and identifies the lock.
The lock is a binary test-and-set lock provided by the
underlying system.  Locks are allocated to sets of processes
that share memory, so that if any process in the set gets
the lock, other processes in the set cannot.

The lock instruction sets the lock and succeeds if the lock
was not already set, and otherwise just fails.

When the {\em atomic-assignment-statement} terminates, either
successfully or when it fails, all locks gotten are released in
reverse order.

\hspace*{-0.2in}{\em \bf Compare-Instruction}.
The {\em compare-variable} is a RAM cache variable (which need
not have the \TT{mem} qualifier).  The compare
instruction reads the value at the {\em address-variable} designated
address and compares
it to the value of the {\em compare-variable}.  The instruction
succeeds if the values are equal, and fails otherwise.


\hspace*{-0.2in}{\em \bf Write-Instructions}.
These do what they normally do, except they are all dry-run 
before any actually execute.  During the dry-run one of these
instruction fails if any memory reference it makes would fail
were the instruction actually executed.  In particular, if any
piece of memory is paged out or not in RAM, the dry-run fails.
\end{indpar}

The `\TT{count}' value returned by the {\em atomic-memory-statement}
equals \TT{0} if the statement succeeds, or is the number of the
first failed instruction in the statement block if the statement
fails (the first instruction is number \TT{1}).
The `\TT{bad address}' value is \TT{0} unless the block
fails because of a memory fault, in which case the `\TT{bad address}'
value is set to the faulting address.  One usually deals with a faulting
address by reading it with a normal instruction if it is a read fault,
or writing it with a normal instruction that does not change its
value if it is a write fault (this may require a compare and set
assembly instruction),
and then retrying the \TT{*ATOMIC*} block.

Interrupts of all kinds are disabled during the execution of an
{\em atomic-memory-statement} so the statement will execute as
fast as the underlying hardware will allow.  However, this means
that memory paging is disabled, so instructions will fail if
they page fault.  This is the reason for the dry-run of the
{\em write-instructions}, to be sure they will not fail
when they actually write data.

A system may put restrictions of the size of the value in
a {\em length-variable}, and on the number of instructions
in an \TT{*ATOMIC*} block, in order to ensure that interrupts
are not disabled for very long.  Violation of these restrictions
causes a \TT{*ATOMIC*} block instruction fault that is distinct
from \TT{*ATOMIC*} block failures described above (such violations
are not recoverable).

\section{Stack Management}
\label{STACK-MANAGEMENT}

Each execution thread has a stack that is not in any other
stack.  Each out-of-line function
execution is a block execution that has a stack which is
by default a substack of the thread in which the function
execution is running.  Each subblock in turn has a stack
which is by default a substack of the stack of its containing block.
And each global area has a stack that is not in any other stack.

Conceptually, the assignment statements in a block each allocate memory for
their variable to the current block stack and copy values to these
variables.  As noted above (Section~\itemref{ASSIGNMENT-STATEMENTS}),
the memory and associated copies may be
optimized away in some cases.

Stacks are either free or bound.\label{FREE-STACK}
A bound stack is a substack that is
not deallocated from memory until its smallest containing free stack is
deallocated.  The main reason this is important is that stack addresses
can be passed out of a block with a bound stack to its containing block,
but cannot be passed out of a block with a free stack to its containing
or calling block.  This is implemented by giving certain
variables the `\TT{stack}' qualifier: see
Section~\itemref{THE-STACK-QUALIFIER}.

Stacks of out-of-line function executions
(\pagref{OUT-OF-LINE-FUNCTIONS}),
out-of-line assignment statement blocks
(\pagref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}),
and
compile-time assignment statement blocks
(\pagref{COMPILE-TIME-ASSIGNMENT-STATEMENTS})
are free, and variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
may \underline{not} have the `\TT{stack}' qualifier.

Stacks of loop iteration subblocks are free, and
variables in the {\em result-variable-list}
and iteration variables
of a {\em loop-assignment-statement} may not have the `\TT{stack}'
qualifier.  However, stacks of loop `\TT{initially}' and `\TT{finally}'
subblocks are not free.

Global area stacks (see Section~\itemref{GLOBAL-AREAS}) are free,
but are never deallocated and make no use of the `\TT{stack}'
qualifier.

All other stacks are bound.  Memory allocated to them
by the `\TT{allocate to stack}' function (\pagref{ALLOCATE-TO-STACK})
is actually
allocated to their smallest containing free stack, and not deallocated
until that free stack is deallocated.

Free stacks are relocatable and can be moved.
Substacks cannot move independently,
but move whenever their smallest containing free stack moves.
Any stack address is relative to its containing free stack,
which is the current free stack at the time executable code uses
the stack address.  To accommodate this builtin memory read-write
functions will not only accept an \TT{adr} value as a RAM address,
but also accept a RAM address consisting of an \TT{unsadr}
offset within the stack and a stack base address that is itself
stored in RAM.  See Sections~\itemref{THE-MEM-QUALIFIER}
and \itemref{MEMORY-WRITE-STATEMENTS}
for details.

There are a couple of situations in which free stacks move.

Memory of runtime determined size can be allocated to the end of
a stack by the `\TT{allocate to stack}' and `\TT{allocate to global}'
functions described below, and such may
require that the smallest containing free stack
be moved to a memory region where there is more free memory available.

In a program being debugged, free stacks may be saved after they are no
longer needed by the program, in order to permit them to be analyzed
by a debbugger if the program detects an error.  In this situation
free stacks are allocated to a very big circular buffer, and overwritten
after they are no longer needed by the program.  It may happen that
a free stack whose block is still running is in the way of allocating
a new stack to the circular buffer, in which case the still running
block's free stack may be moved.

Lastly, global area stacks (\pagref{GLOBAL-AREAS})
may be deallocated when programs that
can reference them are still running, or may not yet be allocated
when these programs run.  Deallocated global area stacks are treated as if
they were allocated to inaccessible memory, so deallocating these stacks
is like moving them to inaccessible memory, and referencing
them when they are deallocated gives a memory fault.


\subsection{Unwind Blocks}
\label{UNWIND-BLOCKS}

\ikey{Unwind blocks}{unwind block} are executed only when their
containing block terminates:

\begin{indpar}
\emkey{unwind-block}
    ::= \begin{tabular}[t]{l}
	\ttkey{*UNWIND*}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

Specifically, when an unwind block is encountered while
executing its containing block, the unwind block is marked
as enabled, but is skipped.  Then when the containing block
terminates, all its enabled unwind blocks are executed in
the reverse order of that in which they were enabled.

Unwind blocks are used to close or deallocate things that were opened.
For example, right after a statement that opens a file there may be
an unwind block that closes the file.  This ensures that the file
will be closed even if the block that opened it terminates later
prematurely with an error, such as a memory fault.

\subsection{Throw and Catch}
\label{THROW-AND-CATCH}

\TT{*THROW*} and \TT{*CATCH*} statements are used to implement
exceptions, i.e., abnormal termination.

\begin{indpar}
\emkey{throw-statement} ::= \TT{*THROW*} \\[1ex]
\emkey{catch-statement} ::= \TT{*CATCH*}
\end{indpar}

The \TT{*THROW*} statement causes its containing block to
\ikey{terminate abnormally}{abnormal termination}.
When a block terminates abnormally, its containing
block is also terminated abnormally.

\ikey{Normal termination}{normal termination}
of a block occurs at the end of the block if
the block has not executed a \TT{*THROW*} or an abnormally
terminating subblock.

Any enabled \TT{*UNWIND*} subblocks of an abnormally terminating
block are executed in reverse order, just as they would be if
the block were terminating normally.  No other part of the block
is executed.

If an \TT{*UNWIND*} subblock executing in an abnormally terminating
containing block \TT{B}
executes a \TT{*CATCH*} statement, the termination of this
containing block \TT{B}
is changed from abnormal to normal.  This means
that \TT{B}'s containing block \TT{C} will resume when the now
normally terminating block \TT{B} finishes terminating.
However, \TT{B} will not execute anything but enabled \TT{*UNWIND*}
subblocks, as it is still terminating.

Machine errors, i.e. memory segment faults, invoke callable functions
which can record error information and execute a \TT{*THROW*}.
Similarly detected programming or data errors can record
error information and execute a \TT{*THROW*}.  An \TT{*UNWIND*}
block can look at recorded error information and decide whether
or not to execute a \TT{*CATCH*}.

If a block has result variables it must assign, then these need not be
assigned if the block terminates abnormally, as they will not
be visible to enabled \TT{*UNWIND*} blocks.  However, if a block \TT{B}
that is terminating abnormally executes a \TT{*CATCH*} statement in
one of its \TT{*UNWIND*} subblocks,
all result variables that block \TT{B} must assign must be given values, even
though part of block \TT{B} may not have executed.  The compiler
will check this, and will only permit code that passes straight forward
compiler checks.

There are two ways to ensure correct code.  The first is to 
set all block result variables either in or before the
\TT{*UNWIND*} block that contains the \TT{*CATCH*} statement.
The second is to use the special variable
\ttkey{*LAST-ENABLED-UNWIND*} inside the \TT{*UNWIND*} block.
This variable is \TT{true} if and only if the \TT{*UNWIND*}
block is the last \TT{*UNWIND*} block enabled in its containing
block, and so if the variable is \TT{true}, any containing
block result variables set after the \TT{*UNWIND*} block need to be
set.  The compiler will accept a statement of the form:
\begin{indpar}\begin{verbatim}
if:
    *LAST-ENABLED-UNWIND*:
        result-variable-1 = ...
        result-variable-2 = ...
	. . . . . . . . . . . .
\end{verbatim}\end{indpar}
where the result variables set are those set after the \TT{*UNWIND*}
block, thus satisying the requirement that all result variables be set.


\subsection{Stack Memory Allocation}
\label{STACK-MEMORY-ALLOCATION}

The `\ttkey{allocate to stack}' function allocates \TT{N} bytes of
memory to the current free stack and returns its offset within
the stack and the address of the stack base address:

\begin{indpar}\tt\begin{tabular}{l}
( stack unsadr offset, \\
~~mem adr offset.base, \\
~~*UNCHECKED* adr offset.base.adr  ) = \\
~~~~\ttkey{allocate to stack} ( unsadr N ) \\
\end{tabular}\end{indpar}\label{ALLOCATE-TO-STACK}

Here `\TT{offset}' is the offset of the \TT{N} bytes within the
stack, `\TT{offset.base}' is the base address of the stack, and
stack, `\TT{offset.base.adr}' is the address of where this
base address is stored in RAM.  The first and last of these
are fixed but `\TT{offset.base}' may change when the stack is
moved.

The returned values are a cluster: see Section~\itemref{CLUSTERS}.
Also used are the `\TT{stack}' qualifier (see \itemref{THE-STACK-QUALIFIER})
and `\TT{*UNCHECKED*}' qualifier (see \itemref{THE-UNCHECKED-QUALIFIER}).

The memory is freed when the free stack to which it is allocated
is freed.  The memory containing the \TT{offset.base} value is
also freed at this time.  The inherited `\TT{stack}' qualifier is used to
ensure that addresses of these values cannot survive the free stack:
see \itemref{THE-STACK-QUALIFIER}.

The memory allocated is always alligned on an \TT{8} byte boundary.

If you want a different alignment you can use:

\begin{indpar}\tt\begin{tabular}{l}
( stack unsadr offset, \\
~~mem adr offset.base, \\
~~*UNCHECKED* adr offset.base.adr  ) = \\
~~~~\ttkey{allocate to stack} ( unsadr N, unsadr O, unsadr A ) \\
\end{tabular}\end{indpar}

where \TT{A} must be a power of \TT{2} not greater than \TT{64}.
This will align the \TT{O+1}'st
byte of the allocated memory block
at an address which is a multiple of \TT{A}\,.
Free stacks are always allocated on a \TT{64} byte boundary.

The `\TT{allocate to stack}' inline functions execute a
`\TT{reload mem}' statement.


\subsection{Global Areas}
\label{GLOBAL-AREAS}

A global area is like the stack frame of a function that has no
arguments or return value, except that after this function executes,
the global area remains allocated and its variables can be referenced
by other code.  The syntax is:
\begin{indpar}
\emkey{global-area-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	{\em global-area-option}\STAR{}
	\TT{global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular} \\
\emkey{global-area-option} ::= \ttkey{*COMPILE-TIME*}
                           $|$ \ttkey{*COMPILE-TIME-ONLY*}
\end{indpar}

Several such blocks may have the same {\em global-area-name},
as long as no {\em variable-name} appears in more than one of these blocks.

In order to be accessed a global area must be named in an `\TT{extern}'
statement:
\begin{indpar}
\emkey{extern-global-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	\TT{extern} {\em global-area-abbreviation}
	            \TT{is global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em extern-variable-statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{extern-variable-statement} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & {\em variable-abbreviation} \TT{is}
          {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\end{indpar}

A variable with {\em variable-name}
\TT{V} in a global area with {\em global-area-abbreviation}
\TT{A} may be named as \TT{A.V}, or if the variable has its own
{\em variable-abbreviation} \TT{VA},
this by itself (and \underline{not} \TT{A.VA})
may be used to name the variable.  An abbreviation is only effective
withing the scope of the `\TT{extern}' statement that defines it.

A variable in an
{\em extern-variable-statement} must match its corresponding
{\em global-area-block} variable with respect to type and qualifiers
in the same manner as a function prototype argument variable
matches a function call variable.

If \TT{A.V} is not defined, it is not a compile or link time error
(though there may be warning messages if requested), but accessing
\TT{A.V} will cause a runtime error (typically a segmentation fault).

Memory within a global area can be allocated by:

\begin{indpar}\tt\begin{tabular}{l}
( global unsadr offset, \\
~~mem adr offset.base, \\
~~*UNCHECKED* adr offset.base.adr  ) = \\
~~~~\ttkey{allocate to global} ( unsadr N ) \\[1ex]
( global unsadr offset, \\
~~mem adr offset.base, \\
~~*UNCHECKED* adr offset.base.adr  ) = \\
~~~~\ttkey{allocate to global} ( unsadr N, unsadr O, unsadr A ) \\
\end{tabular}\end{indpar}\label{ALLOCATE-TO-GLOBAL}

Here \TT{A} must a power of \TT{2} not greater than \TT{64}.
Global areas are allocated on a \TT{64} byte boundary and
may be moved during execution.

The `\TT{allocate to global}' function plays the same role for
global areas as the `\TT{allocate to stack}' function does for
stacks, accept that the address gets the \TT{global} qualifier
instead of the \TT{stack} qualifier.  The \TT{global} qualifier
is a protected, inherited qualifier
with \underline{none} of the special `\TT{stack}'
qualifier properties, and normally has no effect on code.

The `\TT{allocate to global}' inline functions execute a
`\TT{reload mem}' statement.

Global areas are run time by default.
The code of a run time
global area block is executed when the file containing it is
loaded, and the stack of the area is allocated and defined when
the global area block is executed.
Global areas may be deallocated or moved during execution.
References to a global area
that is not yet allocated or that has been deallocated cause runtime
errors (typically segmentation faults).

Global areas may also be made compile time, or both compile and run time,
by use of the \TT{*COM\-PILE-\EOL TIME-\EOL ONLY*} or \TT{*COMPILE-\EOL TIME*}
{\em global-\EOL area-\EOL options} above.  For a compile time
global area, global area blocks are executed in the compiler immediately
after the block compiles, and the global area stack exists in the compiler.
If the global area is also run time, its
block code will be re-executed in the run time enviroment when the
file containing it is linked, and might produce a different stack contents
for the area than the compile time version of the area.

\section{Function Prototypes and Calls}
\label{FUNCTION-PROTOTYPES-AND-CALLS}

In this section we elaborate on the {\em function-prototypes} that were
introduced in Section~\itemref{INLINE-FUNCTIONS}.   Here we replace
\begin{center}
{\em function-name} {\em argument-variable-list}\QMARK{}
\end{center}
by `{\em function-pattern}'.  We also add to the set of possible
{\em qualifying-expressions}.

The extended syntax is:

\begin{indpar}
\emkey{function-declaration}
    ::= \begin{tabular}[t]{l}
        \ttkey{function} {\em function-prototype}\TT{:} \\
	~~~~ {\em statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{function-prototype}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em result-variable-list} \TT{=} {\em function-pattern} \\
    $|$ & {\em function-pattern} \\
    $|$ & {\em function-pattern} \TT{=} {\em input-variable-list} \\
    $|$ & {\em function-prototype}
          \TT{[[} {\em qualifying-expression} \TT{]]} \\
    \end{tabular}
\\[1ex]
\emkey{result-variable-list} ::= see \pagref{RESULT-VARIABLE-LIST}
\\[1ex]
\emkey{function-pattern}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em function-term}
          \{ \TT{\textasciitilde} {\em function-term} \}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{function-term}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em pattern-name} \\
        & ~~ \{ {\em argument-variable-list}\PLUS{}
	        {\em pattern-name} \}\STAR{}  \\
        & ~~ {\em argument-variable-list}\STAR{}
	     {\em function-term-modifier}\QMARK{} \\
    $|$ & \{ {\em argument-variable-list}\PLUS{}
	     {\em pattern-name} \}\STAR{}  \\
        & ~~ {\em argument-variable-list}\PLUS{}
	     {\em function-term-modifier}\QMARK{} \\
    $|$ & \{ {\em argument-variable-list}\PLUS{}
	     {\em pattern-name} \}\PLUS{}  \\
        & ~~ {\em function-term-modifier}\QMARK{} \\
    \end{tabular}
\\[0.5ex]
\emkey{function-term-modifier} ::= \TT{?} $|$ \TT{...} $|$ \TT{...~?}
\\[0.5ex]
\emkey{pattern-name} ::= {\em name} see \pagref{NAMES}
\\[1ex]
\emkey{argument-variable-list}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em opening-argument-bracket}~~~%
          {\em argument-variable-declaration} \\
	& \{ {\em argument-separator}~~~%
	     {\em argument-variable-declaration} \}\STAR{} \\
	& \{ {\em argument-separator}
	     \TT{...} \}\QMARK{} \\
	& {\em closing-argument-bracket} \\
	& [{\em argument-brackets} must match] \\
    $|$ & {\em opening-argument-bracket}~~~\TT{...}\QMARK{}~~~%
	  {\em closing-argument-bracket} \\
	& [{\em argument-brackets} must match] \\
    \end{tabular}
\\[0.5ex]
\emkey{argument-variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{opening-argument-bracket} ::= \TT{(} $|$ \TT{[} $|$ \TT{\{}
\\[0.5ex]
\emkey{closing-argument-bracket} ::= \TT{)} $|$ \TT{]} $|$ \TT{\}}
\\[1ex]
\emkey{qualifying-expression}\label{QUALIFYING-EXPRESSION}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em call-compile-time-logical-expression} \\
    $|$ & {\em abbreviation-name} \TT{is} {\em call-compile-time-expression} \\
    $|$ & {\em pattern-name} \TT{is} \\
        & ~~~~~~~~
          {\em alternative-name} \{ \TT{|} {\em alternative-name} \}\PLUS{}
    \end{tabular}
\end{indpar}

Matching a function call to a {\em function-pattern} begins as follows.
The {\em function-pattern} is changed to by omitting some
{\em function-terms}, replicating others, and reordering the resulting
list of {\em function-terms}.
However, the first {\em function-term}
in the {\em function-pattern} is never deleted or moved in the ordering.

Any {\em pattern-name} that has
{\em alternative-names} specified by a {\em qualifying-expression}
are replaced by one of its {\em alternative-names}.
If any {\em function-term} has the form
\begin{center}
{\em pattern-name} \TT{( bool } {\em variable-name} \TT{) ?}
\end{center}
the term may be replaced by either
`{\em pattern-name}' or `\TT{no} {\em pattern-name}', in which
cases the variable will be assigned the values \TT{true} or \TT{false}
respectively.

Then the `\TT{\textasciitilde}'s and {\em function-term-modifiers} are deleted.
The result is called the `\key{unfolded}' pattern.

At this point the function call and the unfolded pattern must match,
in that
{\em pattern-names} must match exactly, any `\TT{no}' introduced
in the unfolded pattern must match exactly,
and
{\em opening/\EOL closing-argument-brackets} must match exactly,
while the remaining parts of {\em argu\-ment-variable-lists}
must match as described below.

To make the unfolded pattern unique,
no two {\em pattern-names} in a {\em function-pattern} may be the same,
and no two {\em opening-argument-brackets} that \underline{begin}
some {\em function-term} may be the same.

The {\em function-term-modifiers} determine whether a {\em function-term}
may be replicated or deleted.  If \TT{?} is in the modifier, the term
may be deleted.  If \TT{...} is in the modifier, the term may be replicated.
The first {\em function-term} may \underline{not} have a modifier containing
\TT{?}.

Within the body of a function, the {\em pattern-names} become
distinct constants of type `\ttkey{pattern name}'.  These are used in
the following builtin functions:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt (unsadr size) = \ttmkey{count}{of {\tt pattern name}}
			( pattern name N )} \\
Number of repetitions of the {\em function-term} that begins with the
pattern name in the unfolded pattern.  The pattern name may be
\TT{"("}, \TT{"["}, or \TT{"\{"} if the {\em function-term} begins
with an {\em argument-variable-list} that begins with the corresponding
{\em opening-argument-bracket}.  \TT{0} if the {\em function-term}
was deleted.

TBD Variable argument list.

TBD Implied arguments.

TBD Conversion functions.

TBD Operator syntax.

\end{indpar}

\section{Memory Channels}
\label{MEMORY-CHANNELS}

OLD STUFF: REVISE.

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
structured set of elements each associated with a member of
some data set.  Each window element contains a
\key{block descriptor} that holds the address and length of the
memory block that contains the data associated with the element.
Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
The window has a \key{reference point}, and window elements are addressed
relative to this reference point.  There are shift operations that move
the reference point to a nearby window element.

Although we talk about blocks here, a block can be just a numeric array
element, and can be as small as a single bit.  Although we talk about
each element of a memory channel window having its own block descriptor,
an actual memory channel may use only block group descriptors, each of
which functions as a group of more than one individual element
block descriptor.

A memory channel is stored in a cluster.  As such it is mostly an
inline construction, though it can be passed to or returned from a
function, and the function can be all or partly out-of-line.

The most common type of memory channel has a window that appears to be
an array with \ttikey{.di\-men\-sions}{dimensions!of memory channel},
\ttdmkey{lower\_bound}{of memory channel}\TT{[}$i$\TT{]},
and \ttdmkey{upper\_bound}{of memory channel}\TT{[}$i$\TT{]}
being memory channel members.  Such are called
\key{array windows}.
If the memory channel cluster name is $M$, the window elements are
referred to by $M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]},
with $M$\TT{[0,0,}\ldots\TT{]} being the \key{reference point}.

The reference point can be shifted along any of the window's
dimensions by the command
\begin{center}
$M$\ttdkey{center}\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]}
\end{center}
This shifts
the window so that what was
$M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]} becomes
$M$\TT{[0,0,}\ldots\TT{]}.

Creating memory channels and completely reseting their reference points
are specific to the type of memory channel, and are not covered in
this section.

For most kinds of memory channels, block descriptors are computed
automatically when channel is created, when the window is
shifted, or when the data of
a neighboring window element is arrives from memory.
Immediately after a block descriptor is created, a read-ahead of
the block is initiated.  This read-ahead overlaps computation that
does not use the block contents.

If a memory channel accesses arrays stored in memory,
the channel block descriptors can be computed from the array coordinates
of the reference point.  Other memory channels use the contents
of a block to compute the block descriptors of neighboring blocks
in the window.

An example of the latter is a binary tree memory channel.
Let $M$ be such a channel, and let `\TT{.L}' denote the left
child of a binary tree element, `\TT{.R}' the right child, and
`\TT{.P}' the parent.  Then $M\!$\TT{.L.R} denotes the right
child of the left child of the reference point, $M\!$\TT{.P.L}
denotes the left child of the parent of the reference point,
and $M\!$\TT{.P.L.center} moves the reference point to this last element.
The window of such a memory channel might contain the depth 2
subtree of the reference point plus that closest 4 ancestors of the
reference point if these have been visited.  When the reference
point is moved, as soon as the reference point element has been
read from memory, the descriptors for its children are built and
the read of the children is initiated in parallel with other
computation.  When the children arrive from memory, the descriptors
of their children are built and reads of the data pointed at
are initiated.\footnote{All this can actually be done with modern
hardware: code is executed to read the reference point children and initiate the
reads of their children, and a modern processor will automatically
save the code that
executes when a read of a reference point child completes and execute
other code in parallel until the read does complete.}

Some standard memory channel types are built into the L-Language.
Others can be defined by users.

\section{To Do}

How can dynamically initialized locations be static.

Indirect address protocol.
\label{INDIRECT-ADDRESS-PROTOCOL}

Threads.
\label{THREADS}

\appendix

\section{Aliasing Hardware}
\label{ALIASING-HARDWARE}

The ultimate solution to the aliasing problem is new hardware.
At its simplest, registers, which currently hold a datum,
are replaced by triples of registers which hold a datum,
an address, and selection codes.  The register datum equals the value
of the memory location at the register address.  The selection
codes determine which part of this memory location is read or written
when the register is read or written.  If any memory location is
changed, the address of the location is checked against all the
register addresses, and if any match, the corresponding register
data are changed.

This is, however, not sufficient, because sometimes one register
address is a function of another register's datum.  For example,
consider the unchecked code:
\begin{indpar}[0.5em]\begin{verbatim}
struct S { ...; int32 m; ... }
S * * x
S * *& y = * x
int32 *& z = y->m
\end{verbatim}\end{indpar}
If we consider \TT{x}, \TT{y}, and \TT{z} to be registers,
the address of \TT{y} equals the value of \TT{x}, and the
address of \TT{z} equals the value of \TT{y} plus the offset of
\TT{m} in \TT{S}.

If the value of \TT{x} changes, this changes the address of \TT{y},
which may change the datum of \TT{y} and that may change the value
of \TT{y}.  If the value of \TT{y} changes, this changes the address
of \TT{z}, which may change the datum and value of \TT{z}.

The way we accommodate this is to use the selection codes of \TT{y}
to specify that the address of \TT{y} contains the value of \TT{x}
as an additive component, so
that if the value of \TT{x} is changed by adding $\Delta$\TT{x}
then the address of \TT{y} should be changed by adding $\Delta$\TT{x}.
And similarly the selection codes
of \TT{z} specify that the address of \TT{z}
contains the value of \TT{y} as an additive component.

So why should we bother with automatically updating
additive inclusions of one value in the
address of another value, and not bother with other expressions.
The reason is that expressions such as
`\TT{(*x)->m}' are likely to be reused frequently in code (actually,
in automatically generated code) and
therefore need to be cached, whereas an expressions of the form
`\TT{c*d}' will be reused comparatively rarely code
and therefore are not worth special hardware.


\bibliographystyle{plain}
\bibliography{layered-l-2012-language}

\printindex

\end{document}

