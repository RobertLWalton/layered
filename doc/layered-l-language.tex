% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{\,\textsuperscript{p\pageref{#1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\TMP}{\$}			% Compiler Temporary
\newcommand{\ABV}{-{}-{}->}		% Abbreviates
\newcommand{\CNV}{\longrightarrow}	% Converts to
\newcommand{\TCNV}{\Longrightarrow}	% Transitive closure

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

April 23, 2018
 
\end{center}

{\small \tableofcontents}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language, which is similar to the C programming language
but differs in the following ways:

\begin{enumerate}

\item
L-Language facilitates isolating non-type-safe code into small inline functions.

\item
All L-Language data types are builtin number types or subtypes of
builtin number types.  All data managed directly by L-Language consists
of single numbers allocated to the stack.

\item
Memory references other than those to single stack allocated numbers
are handled by code
encapsulated in small inline functions written by the programmer.
These memory references
are treated in a manner reminiscent of input/output.
The bodies of these inline functions are not type-safe, but if
there are written correctly, usage of these functions is type-safe.

\item
There is no concept of a memory structure in the L-Language.  There
is a new concept, the `cluster', which is a collection of stack
variables that can be passed to inline functions
and returned from inline functions as a syntactic unit.

\item
The type `\TT{type}' is first class, is a subtype of integers, and
each `\TT{type}' value is assigned
a unique constant small integer value.  Constant
argument values, such as the value of a `\TT{type}' valued
argument, can be used to select overloaded functions.

\item
Most L-Language functions are inline.  Out-of-line functions can be
called using a block syntax that mirrors the overhead involved in
manipulating an argument stack in memory.

\item
L-Language uses a single-assignment style of program structure
to encourage
efficient code that leaves an audit trail for debugging in the stack.
Partial evaluation of expressions and inline code is supported without
compromising debuggability.

\item
L-Language allows code to be compiled at run-time just before
it is run, for extra efficiency.

\item
L-Language allows code to be compiled into the compiler, to support
language enhancements.

\item
L-Language has module structure to manage
multi-file source code in a well-ordered and type-safe manner.


\end{enumerate}


\section{Lexemes}
\label{LEXEMES}

An L-Language source file is a sequence of bytes that is a UTF-8 encoding
of a sequence of UNICODE characters.  This is scanned into a sequence
of \skey{lexeme}s.

Unless otherwise specified, the term `\key{character}' in this
document means a 32-bit UNICODE character.

Lexemes are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes ASCII single space) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} :::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::=
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe}, \\
    and \TT{Pf}; includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{decimal-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em decimal-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment}\label{COMMENT} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

The following is a special virtual lexeme:
\begin{indpar}
\emkey{indent}\label{INDENT} ::=
        virtual lexeme inserted just before the first
	{\em graphic} character on a line
\end{indpar}

\ikey{Indent lexemes}{indent lexeme} have no characters, but
do have an \mkey{indent}{of indent lexeme}, which is the indent of
the graphic character after the indent lexeme.
The \mkey{indent}{of character} of a character is the number
of columns that precede the character in the character's physical line.
Indent lexemes are used to form logical lines and blocks
(\itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break}\label{LINE-BREAK} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

A non-{\em indent}, non-{\em line-break} {\em white-space}, such as occurs
in the middle of text or code outside comments, is discarded and not treated
as a lexeme.  Such {\em white-space} may be used to separate lexemes.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::=
    \begin{tabular}[t]{l}
    {\em horizontal-space-character}, other than \\
    ASCII single space
    \end{tabular}
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= {\em vertical-space-character}
	other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::=
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} \\
    or {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::=
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these sequences generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

\begin{boxedfigure}[!p]
\begin{indpar}

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em word} $|$ {\em mark} $|$ {\em number} $|$
	      {\em separator} $|$ {\em quoted-string} $|$ {\em indent} \\
	$|$ & {\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}\label{CHARACTER-REPRESENTATIVE}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em ASCII-single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{number} \begin{tabular}[t]{rl}
    ::= & {\em middle-lexeme} with a {\em digit} before any {\em letter} \\
    $|$ & {\em middle-lexeme} with a {\em digit} immediately after
                               a `\TT{+}' or `\TT{-}' \\
	\end{tabular}
\\[0.5ex]
\emkey{natural-number}\label{NATURAL-NUMBER}
	:::= {\em decimal-digit}\PLUS{} not beginning with \TT{0} $|$ \TT{0}
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme} containing a {\em letter} that is not
                  a {\em number}
\\[0.5ex]
\emkey{mark} :::= {\em middle-lexeme} that is not a {\em word} or
		  {\em number}
\\[0.5ex]
{\em indent} ::= see \pagref{INDENT}
\\[0.5ex]
{\em line-break} ::= see \pagref{LINE-BREAK}
\\[0.5ex]
{\em comment} ::= see \pagref{COMMENT}
\\[0.5ex]
{\em end-of-file} ::= see \pagref{END-OF-FILE}

\end{indpar}
\caption{L-Language Program Lexemes}
\label{L-LANGUAGE-PROGRAM-LEXEMES}
\end{boxedfigure}

The lexemes in a L-Language program are specified in
Figure~\itemref{L-LANGUAGE-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see page \pageref{ILLEGAL-CHARACTERS}
above to account for such characters.

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file}\label{END-OF-FILE}
lexeme that occurs only at the end of a file.

Files are scanned into sequences of lexemes which are then divided
into logical lines as per \itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}.
After each logical line is formed,
{\em indent}, {\em comment},
{\em line-break}, and {\em end-of-file} lexemes are deleted
from the logical line.

\ikey{Quoted string lexemes}{quoted strings!concatenated}
separated by the `\TT{\#}' mark
are glued together if they are in the
same logical line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence" #
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

A \emkey{special-character-representative} can consist of
a UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.

A {\em special-character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.

\section{Logical Lines, Blocks, and Statements}
\label{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}

Each non-blank physical line begins with an {\em indent} lexeme
that is followed by a
lexeme that is not an {\em indent}, {\em line-break}, or
{\em end-of-file}.

Lexemes are organized into \skey{logical line}s.  A logical line
begins immediately after an {\em indent} lexeme, and the
\mkey{indent}{of logical line} of the logical line is the
indent of this {\em indent} lexeme (i.e., the indent of the
first graphic character of the logical line).

A logical line ends with the next {\em indent} lexeme whose indent
is not greater than the indent of the logical line, or with an
{\em end-of-file}.  Thus physical
lines with indent greater than that of the current logical line
are \skey{continuation line}s for that logical line.

A code file is a sequence of `\key{top level}' logical lines that
are required to have indent \TT{0}.

A logical line may end with a \key{block} that is itself a sequence of
logical lines that have indents greater than the indent of the
logical line containing the block.
The block is introduced by a `\TT{:}' at the end
of a physical line.  If the first {\em indent} lexeme after the
`\TT{:}' has an indent that is \underline{not} greater than the indent
of the logical line containing the `\TT{:}', the block is empty.
Otherwise the indent of this {\em indent} lexeme becomes the
\mkey{indent}{of block} of the block and the indent of all the
logical lines in the block.  The first logical line of the block
starts immediately after this {\em indent} lexeme.
The block ends just before the first
logical line with lesser indent than the block indent, or the end of file.
More specifically, the last logical line of the block ends with an
{\em indent} whose indent is less than the block indent, or with an
{\em end-of-file}.

Examples are:
\begin{indpar}\begin{verbatim}
this is a top level logical line ending with a block:
    this is the first line of the block
    this is the
         second line of the block
    this is the third line of the block:
        this is the first line of a subblock
        this is the second line
                of the subblock:
            this is the only line of a sub-subblock
        this is the third line of the subblock
    this is the fourth line
            of the block:
        this is the only line of the second subblock
    this is the fifth line of the block
         and it ends with an empty subblock:
this is the second top level
     logical line
\end{verbatim}\end{indpar}

A warning message is output if two indents that are being compared
differ by more than \TT{0} and
less than \TT{2} columns, in order to better detect
indentation mistakes.

{\em Line-break} lexemes are effectively ignored.  A sequence
of {\em line-break} lexemes is followed by an {\em indent}
or {\em end-of-file} which is not ignored.
Blank physical lines are represented by sequences of
more than one {\em line-break} lexeme, and are effectively
ignored.

A logical line that contains {\em comments}, but no
lexemes other than {\em comments}, {\em line-breaks}, {\em indents}
and a possible {\em end-of-file}, is
a `\key{comment line}', and is ignored.

It is an error to begin non-comment logical lines with
a {\em comment}.
{\em Comments} can be used freely in the middle of or at the
end of any logical line, or at the beginning of a comment line.

It is an error for the first logical line of a file
to have an indent that is greater than \TT{0}, the top level
indent.

It is an error for a block to be in the middle of a logical
line.  This means that the first {\em indent} following the
block must have an indent no greater than that of the logical
line containing the block.

Examples are:
\begin{indpar}\begin{verbatim}
// this is a logical line that is a single comment

// this is a logical line that has two
    // comments

this is a logical line // with a comment
     // and another comment
     with three comments // and a last comment

this is a logical line ending with a block:
     First line of the block
     Second line of the block
// Comment that ends block
// Comment that is in error because
    it begins a logical line that this continues

this is a logical line with a block:
     First line of the block
     Second line of the block
  but the block is in error because it is before
  this continuation of the logical line that contains
  the block

this is a logical line ending with a block:
        First line of the block
        Second line of the block
  // comments that end the block, but are in error,
  // because they continue the logical line
  // containing the block
\end{verbatim}\end{indpar}

After a logical line
has been formed, any {\em indent},
{\em comment}, {\em line-break}, and {\em end-of-file}
lexemes in the logical line
are removed from the logical line.  If the result is
empty, i.e., the logical line is a comment line, it is discarded.
Otherwise the
modified logical line becomes a L-Language `\emkey{statement}'.

Therefore a file is a sequence of top-level statements.

Since a logical line can end with a block that itself consists
of a sequence of logical lines, a statement can end with
a block that itself consists of a sequence of statements.


\section{Names}
\label{NAMES}

A \key{name} is a sequence of lexemes used to name things like
variables and functions.

\begin{indpar}
\emkey{name}\label{NAME} ::=
    {\em initial-name-item} {\em continuing-name-item}\STAR{} \\
\emkey{initial-name-item} ::= {\em name-item} other than {\em natural-number} \\
\emkey{continuing-name-item} ::= {\em name-item} not containing `\TT{.}' \\
\emkey{name-item}\label{NAME-ITEM}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} containing no `\TT{.}' following a character
                     that is not a `\TT{.}' \\
        & [see text about splitting words with embedded `\TT{.}'s] \\
    $|$ & {\em natural-number} \\
    $|$ & {\em quoted-mark} not containing `\TT{.}'s \\
    $|$ & {\em quoted-separator} not containing `\TT{.}'s \\
    \end{tabular} \\
\emkey{quoted-mark} :::= \TT{"} {\em mark} \TT{"} \\
\emkey{quoted-separator} :::= \TT{"} {\em separator} \TT{"}
\end{indpar}

{\em Words} containing embedded `\TT{.}'s are split into
{\em name-items} which can only contain `\TT{.}'s at their beginning.
Thus
\begin{center}
\TT{bills.wife.1.weight..size}
\end{center}
is split into
\begin{center}
\TT{bills~~~.wife~~~.1~~~.weight~~~~..size}
\end{center}
However, `\TT{.1}' is not a legal {\em name-item} and so cannot
be part of a legal {\em name}.

Name items beginning with more than one `\TT{.}' are reserved
for use by systems and compilers (e.g., \TT{..size} in the example).

Words ending with `\TT{\TMP$n$}', where $n$ is a {\em natural-number}, are
reserved for use by the compiler and may not be used in names by the
L-Language user.  For example, names of the form \TT{T\TMP$n$} are used as
temporary variables introduced during compilation.

Names can be computed at compile time:
see~\itemref{THE-NAME-TYPE}.
One name can be used to abbreviate another:
see~\itemref{ABBREVIATIONS}.
A name may begin with a {\em word} that is a {\em module-abbreviation}
that designates a code module: see~\itemref{MODULES}.

A {\em name} may be an abbreviation for another name.  Such abbreviations
can be introduced by statements of the form
\begin{center}
{\em abbreviation-name} \TT{\ABV} \TT{`}{\em replacement-name}\TT{'}
\end{center}
See the section on abbreviations
(\itemref{ABBREVIATIONS})
for more details.

The builtin names in this document are implicitly in the
\TT{"standard"} module whose {\em module-abbreviation} is `\TT{std}'.
See the section on modules (\itemref{MODULES}) for details.
For example the name `\TT{bool}' of the boolean data type is actually a builtin
abbreviation defined by:
\begin{center}
\TT{bool {\ABV} `std bool'}
\end{center}
and the builtin type name proper is `\TT{std bool}' and not `\TT{bool}'.


Similarly the  builtin function such as \TT{round} as used in:
\begin{center} \tt
\begin{tabular}{l}
float$x$ v = \ldots{} \\
float$x$ r = round ( v ) \\
\end{tabular}
\end{center}
actually has the function prototype (\pagref{FUNCTION-PROTOTYPE}):
\begin{center}
{\tt function std float$x$ r = std round ( std float$x$ v )} \\
\end{center}
so its proper name is `\TT{std round}' and not `\TT{round}',
but in this case it is not necessary (or desirable) to make `\TT{round}'
an abbreviation because its module can be implied in a function call
(see `module deficient' on \pagref{MODULE-DEFICIENT}).

\subsection{Kinds of Names}
\label{KINDS-OF-NAMES}

The L-Language uses several kinds of names:

\begin{indpar}
\emkey{module-abbreviation}
	::= \TT{word} not containing any `\TT{.}'s \\
\emkey{type-name}\label{TYPE-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{qualifier-name}\label{QUALIFIER-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{variable-base-name}\label{VARIABLE-BASE-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{variable-name}\label{VARIABLE-NAME}
	::= {\em variable-base-name} {\em member-selector}\STAR{} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript } \\
\emkey{member-name}\label{MEMBER-NAME}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark}
			    or {\em quoted-separator}
			\end{tabular} \\
\emkey{member-subscript} ::= see \pagref{MEMBER-SUBSCRIPT} \\
\emkey{block-name}\label{BLOCK-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{function-term-name} ::= {\em name} \\
\emkey{function-variable-name} ::=
    \begin{tabular}[t]{@{}p{4in}@{}}
    {\em function-term-name} $N$ that appears in a {\em function-prototype}
    of the form `{\tt function $N$ = \ldots};
    see \pagref{FUNCTION-VARIABLE-NAME}
    \end{tabular} \\
\emkey{block-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{include-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator}

where
\begin{enumerate}
\item
A {\em qualifier-name} must not be an initial segment
of a {\em type-name}.
\item
A {\em qualifier-name} or {\em type-name} must not be an initial segment
of a {\em name} $N$ that might begin a {\em statement} of
the form `{\tt $N$ = \ldots}'.  Examples of such names $N$
are {\em deferred-variables} (\pagref{DEFERRED-VARIABLE})
and {\em function-variable-names} (\pagref{FUNCTION-VARIABLE-NAME}).
\label{TYPE-NAME-RULE}
\item
A {\em type-name}, {\em qualifier-name}, {\em variable-base-name},
{\em block-name}, or {\em include-name}
may not begin with the word `\TT{next}' or `\TT{previous}' or
contain the words `\TT{is}', `\TT{as}', `\TT{with}', `\TT{without},
or `\TT{if}'.
\item
{\em Name-items} ending with `\TT{\TMP$n$}',
where $n$ is a {\em natural-number}, are
reserved for use by the compiler.
\item
{\em Name-items} beginning with `\TT{..}' (possibly followed by more
`\TT{.}'s) are reserved
for use by systems and compilers (e.g., `\TT{..size}').
\end{enumerate}
\end{indpar}

The first two rules are not enforced as such.  Instead the parser
parses statements into abstract syntax trees that contain
sequences of names, without separating the names in each sequence.
Then as a first step in compilation after parsing,
any name sequence that might be of the form
\begin{center}
{\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
\end{center}
is scanned left to right to first remove any {\em qualifier-names}
and then a {\em type-name}, leaving a non-empty {\em variable-name}.
At any point, if several suitable {\em qualifier-names} or
{\em type-names} match the
beginning of the remaining part of the name sequence, the longest
is chosen.  If this process succeeds without backup, the name
sequence is of the above form.  Otherwise it is not -- there is
no backup.  If the process does not succeed, in some
cases the name sequence may still be a single {\em variable-name}
by itself, and in other cases it might be a sequence of one or
more {\em function-term-names}.
Also the {\em qualifier-name} and {\em type-name}
candidates are those of the current scope (\pagref{SCOPE}).

Name sequences that might be of the above form can only occur at
the beginning of a statement or as a {\em result-variable-declaration}
or an {\em argument-declaration} in a {\em function-prototype}.

In addition, non-empty name sequences
may appear in abstract tree subexpressions of the form
\begin{center}
{\em qualifier-name}\STAR{} {\em type-name}\QMARK{} {\tt (~\ldots{}~)}
\end{center}
and are treated similarly.


\subsection{Abbreviations}
\label{ABBREVIATIONS}


An \key{abbreviation} is a {\em name} that is replaced
by another {\em name}.  There are separate abbreviations for
{\em qualifier-names}, {\em type-names}, {\em variable-base-names},
and {\em member-names}.

Abbreviations are declared by:
\begin{indpar}
\emkey{abbreviation-declaration}\label{ABBREVIATION-DECLARATION}
    ::= {\em abbreviation} ~ \ttkey{-{}-{}->} ~ {\em abbreviation-replacement}
\\[1ex]
\emkey{abbreviation} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\\[1ex]
\emkey{abbreviation-replacement} ::= \\
\hspace*{0.5in}
    {\em expression} that evaluates at compile time to a \TT{name};
    see \itemref{THE-NAME-TYPE}
\end{indpar}

The most common {\em abbreviation-replacement} is a {\em name-constant}:

\begin{indpar}
\emkey{name-constant}
    ::= \TT{`}{\em name-item}\STAR{}\TT{'} \\
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

The only {\em names}
that can be abbreviated are {\em qualifier-names},
{\em type-names}, {\em variable-base-names}, and
{\em member-names}.

If the replacement name of an {\em abbreviation} is a {\em qualifier-name}
in the context of the {\em abbreviation-declaration},
the {\em abbreviation} becomes a {\em qualifier-name}, and
must have they syntax of a {\em qualifier-name}.
Similarly, if the replacement name of an {\em abbreviation} is a {\em type-name}
in the context of the {\em abbreviation-declaration},
the {\em abbreviation} becomes a {\em type-name}, and
must have they syntax of a {\em type-name}.
In other cases, the {\em abbreviation} must have the syntax of
a {\em variable-base-name} if its replacement does, and the syntax of
a {\em member-name} if its replacement does.

The rules in \itemref{KINDS-OF-NAMES}
apply to {\em abbreviations}.  For example, the rule regarding
{\em type-names} applies to {\em abbreviations}
of {\em type-names}.

Abbreviation replacement occurs after
{\em qualifier-names},
{\em type-names}, {\em variable-base-names}, and
{\em member-names} have been identified by the compiler.

Abbreviations are internal and never external (\pagref{EXTERNAL}),%
\label{ABBREVIATIONS-ARE-INTERNAL}
even if they begin with a {\em module-abbreviation}.
They do have scope (\pagref{SCOPE}) like other declarations, but their scope
is limited to the extended module (\pagref{EXTENDED-MODULE}) in
which they are declared.

Some examples are:
\begin{indpar}\begin{verbatim}
int32 ---> `std int32'
uns64 ---> `std uns64'
    // Builtin type abbreviations
*UNCHECKED*  ---> `std *UNCHECKED*'
    // Builtin qualifier abbreviation

*UNCHECKED* int32 x 1 = 99
    // Same as: std *UNCHECKED* std int32 x 1 = 99
.foo ---> `fee'
    // Illegal: `fee' does not begin with `.'.
"+" ---> `std int62'
    // Illegal: `"+"' is not allowed as a type name.

int64 unsigned ---> `uns64'
int64 unsigned z = 9 + 7
    // Legal, same as: std uns64 z = (9) "+" (7)
    // Matches function prototype:
    //   function std uns64 r =
    //       std (std uns64 v1) "+" (std uns64 v2)
    // unless another function with prototype:
    //   function std uns64 r =
    //       (std uns64 v1) "+" (std uns64 v2)
    // is defined.

x 1 ---> `x'
.foo ---> `.fee'
int64 y = x 1 .foo + 10
    // Same as: std int64 y = (x.fee) "+" (10)
\end{verbatim}\end{indpar}

Abbreviation is recursive: an {\em abbreviation-replacement} can
itself be an abbreviation.
Abbreviation loops are possible and result in compile errors when
the abbreviation is used.
For example:
\begin{indpar}\begin{verbatim}
    X ---> `Y'
    int64 X = 5       // Same as: std int64 Y = 5
    Y ---> `Z'
    int64 X = 5       // Same as: std int64 Z = 5
    Z ---> `X'
    int64 X = 5       // Compile error replacing X.
\end{verbatim}\end{indpar}


\section{Program Organization}
\label{PROGRAM-ORGANIZATION}

Code is organized into two kinds of files: \skey{module}s
and \ikey{bodies}{body}.
Each body is associated
with a particular module, the `\key{module of the body}',
and extends that module.  A module
may have zero or more bodies.
A module and all its bodies together form
an `\key{extended module}'\label{EXTENDED-MODULE}.

Modules and bodies consist of a sequence
of \skey{declaration}s:
\begin{indpar}
\emkey{declaration}
    \begin{tabular}[t]{rll}
    ::= & {\em module-declaration}
        & [see \pagref{MODULE-DECLARATION}] \\
    $|$ & {\em body-declaration}
        & [see \pagref{BODY-DECLARATION}] \\
    $|$ & {\em defined-type-declaration}
        & [see \pagref{DEFINED-TYPE-DECLARATION}] \\
    $|$ & {\em type-name-declaration}
        & [see \pagref{TYPE-NAME-DECLARATION}] \\
    $|$ & {\em enum-type-declaration}
        & [see \pagref{ENUM-TYPE-DECLARATION}] \\
    $|$ & {\em qualifier-declaration }
        & [see \pagref{QUALIFIER-DECLARATION}] \\
    $|$ & {\em function-type-declaration }
        & [see \pagref{FUNCTION-TYPE-DECLARATION}] \\
    $|$ & {\em out-of-line-function-declaration }
        & [see \pagref{OUT-OF-LINE-FUNCTION-DECLARATION}] \\
    $|$ & {\em function-declaration }
        & [see \pagref{FUNCTION-DECLARATION}] \\
    $|$ & {\em generic-declaration }
        & [see \pagref{GENERIC-DECLARATION}] \\
    $|$ & {\em abbreviation-declaration }
        & [see \pagref{ABBREVIATION-DECLARATION}] \\
    $|$ & {\em assignment-statement }
        & [see \pagref{ASSIGNMENT-STATEMENTS}] \\
    \end{tabular}
\end{indpar}

Declarations declare {\em names}, {\em function-prototypes},
and {\em generic-prototypes}.
An {\em assignment-state\-ment} is also a {\em declaration} of
its result {\em variable-names}.

{\em Names} shared between modules begin with {\em module-abbreviations}
that designate the module in which the name is declared.
Such names are called `\key{external}'.\label{EXTERNAL}
Similarly the pattern of a {\em function-prototype}
(\pagref{FUNCTION-PROTOTYPE})
or {\em generic-prototype}
(\pagref{GENERIC-PROTOTYPE})
may begin with the {\em module-abbreviation} of the module in
which the prototype is declared,
and such prototypes are `\key{external}'.

External names and prototypes can only be declared in modules, and
never in bodies.  External names and prototypes cannot be declared inside
statement blocks, but must be declared at `top level' outside
blocks.

As an exception, abbreviations are internal, and never external, even if
they begin with a {\em module-abbreviation}
(\pagref{ABBREVIATIONS-ARE-INTERNAL}).

In {\em function-calls} and {\em generic-calls} the
{\em module-abbreviation} may be omitted
if the {\em function-proto\-type} or {\em generic-prototype} matching the call
can be unambiguously determined: see
`module deficient' on \pagref{MODULE-DEFICIENT}.
This may \underline{not} be done
for names (e.g., external types, external variables).

An example is:
\begin{indpar}\begin{verbatim}
module "lib/math" as math

define type math complex as void
    // Given `math complex x', x[0] is the real part of a
    // complex number and x[1] is the imaginary part.

function math complex r, float64 r[0], float64 r[1] =
    math complex ( float64 real, float64 imaginary ):
    r[0] = real
    r[1] = imaginary

function math complex r, float64 r[0], float64 r[1] =
    math ( math complex a1, float64 a1[0], float64 a1[1] )
    "+"  ( math complex a2, float64 a2[0], float64 a2[1] ):
    r[0] = a1[0] + a2[0]
    r[1] = a1[1] + a2[1]

---------------------------------------------
module "my-module" as mine
    import "lib/math" as math

.............................
math complex x = math complex ( 1, 0 )
math complex y = complex ( 0, 1 )
    // The second `complex' in each line is a function name
    // so `math' may be omitted.  In this case the function
    // prototype that applies is selected by the y result
    // variable type.
math complex z1 = x + y
    // Parses to `math complex z1 = ( (x) "+" (y) )'.
    // Standard "+" does not apply because it does not match
    // result type.  `math' module abbreviation is implied so
    // that `math' module "+" applies.
math complex z2 = math ( x + y )
    // Parses to `math complex z2 = ( math (x) "+" (y) )'.
    // `math' module abbreviation for "+" is explicit and
    // NOT implied.
\end{verbatim}\end{indpar}

\subsection{Modules}
\label{MODULES}

A \key{module} is a file that begins with a {\em module-declaration}:

\begin{indpar}
\emkey{module-declaration}\label{MODULE-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= & {\em simple-module-declaration} \\
    $|$ & {\em simple-module-declaration}\TT{:} \\
	& \TT{~~~~}{\em import-clause}\STAR{} \\
    \end{tabular} \\
\emkey{simple-module-declaration} ::= \TT{module} {\em module-name}
        \TT{as} {\em module-abbreviation} \\
\emkey{module-name} ::= {\em quoted-string} \\
\emkey{module-abbreviation}\label{MODULE-ABBREVIATION}
	::= \TT{word} not containing any `\TT{.}'s \\
\emkey{import-clause}\label{IMPORT-CLAUSE} ::= \TT{import} {\em module-name}
        \TT{as} {\em module-abbreviation}

\begin{itemize}

\item
In a {\em module-declaration} all {\em module-abbreviations} must be
distinct, and all {\em module-names} must be distinct.
\end{itemize}
\end{indpar}

A {\em module-name} is a POSIX file name.
The {\em module-name} of a {\em module-declaration} must match the
name of the file containing the
{\em module-declaration}, relative to one of several directories
specified separately to the compiler.

The {\em module-abbreviation} associated with a {\em module-name}
may differ in different files.  Specifically, the {\em module-abbreviation}
for a module used in the module's own module file need not be the same
as the {\em module-abbreviations} used for the module in files
that import the module.

The conceptual directed graph whose nodes are modules and whose
arrows connect each module to the modules it or its bodies import is called
the `\key{module graph}'.\label{MODULE-GRAPH}
This graph \underline{must be acyclic}.

The module \TT{"standard"}\index{standard@\TT{"standard"}} with
module abbreviation \ttkey{std} is builtin and contains the builtin types and
functions.  The {\em import-clause}
\begin{center}
{\tt import }\TT{"standard"}\ttindex{standard@\TT{"standard"}}{\tt{}
    as \ttkey{std}}
\end{center}
is implied in every {\em module-declaration} and
{\em body-declaration} (see \itemref{BODIES}).

When a type is declared, functions with arguments or result
values of that type are automatically declared.  For example,
the declaration
\begin{center}
{\tt define type $T1$ as $T2$}
\end{center}
automatically declares
\begin{center}
\begin{tabular}{l}
{\tt function bool r = ( $T1$ x ) "==" ( $T1$ y ):} \\
{\tt ~~~~r = ( $T2$ ( x ) ) "==" ( $T2$  ( y ) )}
\end{tabular}
\end{center}

If the declared type begins with module abbreviation $ma$, the function
will also be given this module abbreviation.  Thus if $T1$ begins with
$ma$, the function will be
\begin{center}
\begin{tabular}{l}
{\tt function bool r = $ma$ ( $T1$ x ) "==" ( $T1$ y ):} \\
{\tt ~~~~r = ( $T2$ ( x ) ) "==" ( $T2$  ( y ) )}
\end{tabular}
\end{center}


\subsection{Scope}
\label{SCOPE}

A {\em declaration} has a \key{scope},
that is the set of statements in which any
names or prototypes defined by the {\em declaration}
are recognized.  The scope of a {\em declaration}
begins just after the {\em declaration}
itself, and
lasts to the end of smallest block containing the {\em declaration},
or until the end of the file containing the {\em declaration} if
the {\em declaration} is not inside any block.
If the {\em declaration} is in a module, the scope of the
{\em declaration} is extended to include all the bodies of that
module.
If the {\em declaration} is external, the scope of the
{\em declaration} is extended to include all modules and
bodies that import the module containing the {\em declaration}.

The scope of a {\em name}, {\em function-prototype}, or
{\em generic-prototype}
is the scope of the declaration that defines it.

The scope of a {\em block-name} is the block it names
(see \itemref{BLOCK-ASSIGNMENT-STATEMENTS}).

The \key{context}\label{CONTEXT} of a statement is the set of declarations
whose scope the statement is in.

When a {\em function-call} to an inline function
or a {\em generic-call} to a generic is compiled,
the context of the compilation is \underline{not} the current context but
rather the context of the inline function or generic
declaration.
Also the context in which any {\em default-value} expression
provided by a declaration
is compiled is the \underline{not} the current context but
rather the context of that declaration.

Code included by a generic
(\itemref{GENERICS}), however, \underline{is} compiled in the current context.

If two different declarations of the same {\em name} have overlapping
scope, one of these scopes must include the other,
and the declaration with the smaller scope is said to 
`\mkey{hide}{declaration}'\label{HIDE} the other declaration.
Such hiding is a compiler error unless the smaller scope
is within one of the following kinds of statements, and
the larger scope includes the whole statement:
\begin{center}
\begin{tabular}{ll}
{\em function-type-declaration}
    & [see \pagref{FUNCTION-TYPE-DECLARATION}] \\
{\em out-of-line-function-assignment}
    & [see \pagref{OUT-OF-LINE-FUNCTION-ASSIGNMENT}] \\
{\em out-of-line-function-declaration}
    & [see \pagref{OUT-OF-LINE-FUNCTION-DECLARATION}] \\
{\em function-declaration}
    & [see \pagref{FUNCTION-DECLARATION}] \\
{\em generic-declaration}
    & [see \pagref{GENERIC-DECLARATION}] \\
{\em block-assignment-statement} with context option
    & [see \pagref{BLOCK-ASSIGNMENT-STATEMENTS}] \\
{\em compile-and-run-assignment-statement} with context option
    & [see \pagref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}] \\
\end{tabular}\label{HIDING-EXCEPTIONS}
\end{center}

As an exception to the last rule, the declaration with the
smaller scope may be an assignment statement declaring
a variable name `\TT{next} {\tt v}' when the declaration
with the larger scope is an assignment statement
declaring `{\tt v}', and the two declarations have the
same smallest containing block.
Within the smaller scope `{\tt v}' refers to the
`\TT{next} {\tt v}' declaration: see \pagref{NEXT}.

By the last rule,
`\TT{next} {\tt v}' cannot be declared in a block $B$ if `{\tt v}' was
declared outside $B$ and $B$ is completely within
the scope of `{\tt v}', so the smallest containing block of
`{\tt v}' is not the same as the smallest containing block of
`\TT{next} {\tt v}'.

Prototypes cannot hide each other.  If the
current scope contains two declarations whose prototypes
both match a {\em function-call} or {\em generic-call},
the call is ambiguous and
in error, even if the scope of one declaration is within
a subblock of the scope of the other.
As a consequence, it may be unwise to place {\em function-declarations}
or {\em generic-declarations}
within assignment statements that have the context option.

A call that is a statement by itself
is matched against both {\em generic-prototypes}
and {\em function-proto\-types}, and will be ambiguous if it matches
one of each kind.

A declaration not inside a block is said to be `\key{top level}'.

A top level declaration
may \underline{not} have `\TT{next} {\em variable-name}' as
a result variable.

A top level assignment statement in a module may not include references to
out-of-line functions or to inline functions that in turn include
references to out-of-line functions.  This implies that all code needed
to initialize a top level variable will be initialized before the
variable is initialized.

However a top level assignment statement may have a
\key{deferred value} (\pagref{DEFERRED-ASSIGNMENT-STATEMENTS}) indicating
that its result variable values will not be assigned until later.
The statement
assigning the values must be in the same extended module
as the deferred assignment statement, but may be in a body
of that module, and if it is in a body,
may use out-of-line functions.
It is a programming error to access
deferred result variable values before they are assigned.

A name or prototype pattern
declared by a top level declaration in a module may begin with
the {\em module-abbreviation} of the module.  In this case the
name or prototype is `\key{external}',
unless it is an abbreviation.
The scope of external names and prototypes is extended
to include modules and bodies that import the declaring module.
All other names and prototypes declared in the module or
its bodies are `\key{internal}',
and these names and prototype patterns may not begin
with any {\em module-abbreviation}.

{\em Abbreviations} are always internal (\pagref{ABBREVIATIONS-ARE-INTERNAL}),
even when they begin with a {\em module-abbreviation}.

Any name or prototype declared to be external in an imported module is
said to be `\key{imported}'.  The name or prototype is said to be
`\key{exported}' by the module that contains its declaration,
and `\key{imported}' by modules and bodies that import that module.

Imported names can be used only if they begin
with the {\em module-abbreviation} that references the module in which
they are declared.  Imported prototypes may be used by calls beginning with
the {\em module-abbreviation} that references the module in which
they are declared, or if there is no ambiguity the {\em module-abbreviation}
may be omitted from the calls.

An example is:
\begin{indpar}\begin{verbatim}
module "my_own_module" as mom:
    // `import "standard" as std' is implied
    import "George's_own_module" as gom
    // gom contains:
    //    function int32 z = gom ( int32 x ) "+" ( int32 y )

int32 mom my external constant = ...
int32 my internal constant = ...

function int32 y = mom my external function ( int32 x ):
    ... function body omitted ...
function int32 y = my internal function ( int32 x ):
    ... function body omitted ...

function int32 z = my inline function ( int32 x, int32 y ):
    int32 z1 = gom ( x + y )
        // Uses gom's + operator.
        // Compiles as as `gom (x) "+" (y)'.
    int32 z2 = std ( x + y )
        // Uses builtin std's + operator.
        // Compiles as as `std (x) "+" (y)'.
    z  = z1 + z2 
        // Compiles as `z = ( (x) "+" (y) )'.
        // Compile error, ambiguous: both std + operator
        // and gom's + operator match the call to "+".
\end{verbatim}\end{indpar}\label{EXTERNAL-INTERNAL-EXAMPLE}

More specifically,
when a function declaration is used, the {\em module-abbreviation}
beginning the function call may be omitted if the function declaration is
the only function declaration within scope that matches the usage,
according to the module deficiency rules of
section~\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}.
Thus in the context of the above example the lines:
\begin{indpar}\begin{verbatim}
int32 y = mom my external function ( x )
int32 y = my external function ( x )
\end{verbatim}\end{indpar}
are equivalent if no imported module with abbreviation $ma$
contains the {\em function-prototype}:
\begin{center}
\tt function int32 r = $ma$ my external function ( int32 v )
\end{center}

\subsection{Bodies}
\label{BODIES}

A \key{body}
is a file that begins with an {\em body-declaration}:

\begin{indpar}
\emkey{body-declaration}\label{BODY-DECLARATION} ::=
    \begin{tabular}[t]{l}
    \TT{body }{\em body-name}\TT{ of }{\em module-name}\TT{:} \\
    \TT{~~~~}{\em import-clause}\STAR{} \\
    \TT{~~~~}{\em after-clause}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{body-name} ::= {\em quoted-string}
\\[0.5ex]
{\em import-clause} ::= see \pagref{IMPORT-CLAUSE}
\\[0.5ex]
{\em after-clause} ::= \TT{initialize after }{\em body-name}
\end{indpar}

A {\em body-name} is a POSIX file name.
The {\em body-name} of a {\em body-declaration} must match the
name of the file containing the
{\em body-declaration}, relative to one of several directories
specified separately to the compiler.

A \key{body} is an extension of the module named in the first
line of the {\em body-declaration}.  The body cannot itself
declare any external names.  It can provide
assignments for variables and out-of-line functions deferred in the
module it extends, and can call out-of-line functions in these
assignments.
It can also declare internal names and functions used only in the
body.

A body implicitly imports the module it extends.  Within the
body that module has the same {\em module-abbreviation} that it
had in the module's own file.  The other modules imported in the
module's own file are \underline{not} implicitly imported
to the body.  The body must import whatever other modules it uses
explicitly.

The {\em after-clauses} name other bodies that extend the same
module, and control initialization: see \itemref{PROGRAM-INITIALIZATION}.

\subsection{Program Initialization}
\label{PROGRAM-INITIALIZATION}

Modules must be initialized.  A module is initialized after every
module that it imports is initialized.  Otherwise the order of
initializing modules is indeterminate.  Because the module graph
(\pagref{MODULE-GRAPH}) is acyclic, it is always possible to
initialize imported modules before the importing module.

A module is initialized by executing top level assignment statements
in the module file, and then initializing
bodies that extend the module.  A body is initialized
by executing top level assignment statements in the body.
Top level statements in a file are executed in order.
Note that some of these assignment statements may not have
result variables.

A module is initialized before any bodies that extend it.
Unless specified by {\em after-clauses}, the order of initializing the
bodies that extend a module is indeterminate.
An `\TT{initialized after "$B1$"}' clause for module \TT{"$B2$"} causes
\TT{"$B2$"} to be initialized after \TT{"$B1$"}.

Each module has a `\key{body graph}'\label{BODY-GRAPH}
whose nodes are bodies that extend
the module and whose arrows connect each body to the bodies it
initializes after.  This graph must be acyclic.

{\em Deferred-assignment-statements} (\pagref{DEFERRED-ASSIGNMENT-STATEMENTS})
and {\em out-of-line-function-deferred-assignments}
(\pagref{OUT-OF-LINE-FUNCTION-DEFERRED-ASSIGNMENT}) must be executed
before statements initializing their deferred variables or deferred functions.
Statements initializing deferred variables and functions must be executed
during initialization of the extended module containing the
deferred variables and functions, and
before the deferred variable values or deferred functions are used.

\subsection{Parsing}

The parser converts each statement to an abstract syntax tree,
using the language syntax equations and the {\em module-abbreviations}
and {\em parser-clauses}
of the current module's {\em module-declaration} or body's
{\em body-declaration}.  The abstract syntax
tree of a statement can be represented by inserting implied
parentheses into the statement and quoting operators.

For example, the statement
\begin{center}
\tt int64 x 1 = y 5 b + sin (w) * cos z
\end{center}
becomes the abstract syntax tree represented by
\begin{center}
\tt (int64 x 1) = ((y 5 b) "+" ((sin (w)) "*" (cos z)))
\end{center}
Note that the abstract tree representation is not legal
program code as it has parentheses around the result
variable declaration `{\tt int64 x 1}'.

Operators in the original statement are replaced by quoted
versions of the operators in the abstract
syntax tree, e.g., {\tt +} is replaced by {\tt "+"}, so that
the operators become {\em function-term-names}.

The parser does not process {\em result-variable-declarations} or
{\em argument-declarations}.  Thus
\begin{center}
\tt function int64 r = ( int64 a 1 ) "+" ( int64 a 2 )
\end{center}
becomes
\begin{center}
\tt function (int64 r) = (( int64 a 1 ) "+" ( int64 a 2 ))
\end{center}

Since the parser has only syntax information and {\em module-abbreviations}
available to
it, the parser does not know the {\em qualifier-names}
and {\em type-names} in a given scope, and in fact the parser
has no notion of scope.

The parser does know about {\em module-abbreviations} and
converts a statement of the form:
\begin{center}
{\em module-abbreviation} {\tt (~\ldots~)}
\end{center}
to
\begin{center}
{\tt (~}{\em module-abbreviation}{\tt ~\ldots~)}
\end{center}
after parsing `{\tt \ldots}'.  Thus if $ma$ is a {\em module-abbreviation},
\begin{center}
\tt int64 x 1 = $ma$ ( y 5 b + sin (w) * cos z )
\end{center}
becomes the abstract syntax tree represented by
\begin{center}
\tt (int64 x 1) = ($ma$ (y 5 b) "+" ((sin (w)) "*" (cos z)))
\end{center}

According to the syntax of expressions (\itemref{EXPRESSION-SYNTAX}),
the parser does not insert parentheses that make operators
left associative.  Thus
\begin{center}
\tt int64 w 1 = x 2 + y 3 + z 4 
\end{center}
becomes the abstract syntax tree represented by
\begin{center}
\tt (int64 w 1) = ((x 2) "+" (y 3) "+" (z 4))
\end{center}
and \underline{not}
\begin{center}
\tt (int64 w 1) = ( ( (x 2) "+" (y 3) ) "+" (z 4))
\end{center}
The compiler and not the parser handles binary operator associativity.


\section{Data Types}
\label{DATA-TYPES-TYPES}

The basic builtin types are the number types and the \TT{void} type.
All defined types are subtypes of these types.
One of the builtin defined subtypes is the `\TT{type}' type.

\subsection{Number Types}
\label{NUMBER-TYPES}

Numbers are sequences of bits, and each number is one of
four kinds, unsigned integer, signed integer, floating point number,
or address:

\begin{indpar}
\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\bf Name & \bf Kind & \bf Size \\[2ex]
\TT{std}~~~\ttkey{uns8}		& unsigned integer & 8 bits \\
\TT{std}~~~\ttkey{uns16}	& unsigned integer & 16 bits \\
\TT{std}~~~\ttkey{uns32}	& unsigned integer & 32 bits \\
\TT{std}~~~\ttkey{uns64}	& unsigned integer & 64 bits \\
\TT{std}~~~\ttkey{uns128}	& unsigned integer & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{int8}		& signed integer & 8 bits \\
\TT{std}~~~\ttkey{int16}	& signed integer & 16 bits \\
\TT{std}~~~\ttkey{int32}	& signed integer & 32 bits \\
\TT{std}~~~\ttkey{int64}	& signed integer & 64 bits \\
\TT{std}~~~\ttkey{int128}	& signed integer & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{float16}	& IEEE floating point number & 16 bits \\
\TT{std}~~~\ttkey{float32}	& IEEE floating point number & 32 bits \\
\TT{std}~~~\ttkey{float64}	& IEEE floating point number & 64 bits \\
\TT{std}~~~\ttkey{float128}	& IEEE floating point number & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unsadr}	& unsigned integer & size of address \\
\TT{std}~~~\ttkey{intadr}	& signed integer & size of address \\
\TT{std}~~~\ttkey{adr}		& address
                                & size of address \\
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unswrd}	& unsigned integer & size of integer register \\
\TT{std}~~~\ttkey{intwrd}	& signed integer & size of integer register \\
\TT{std}~~~\ttkey{floatwrd}	& IEEE floating point number
                                & size of floating point register
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unsmax}	& unsigned integer & max implemented size \\
\TT{std}~~~\ttkey{intmax}	& signed integer & max implemented size \\
\TT{std}~~~\ttkey{floatmax}	& IEEE floating point number
                                & max implemented size
\end{tabular}

\end{indpar}

These are the \key{built in number types}.  The \TT{adr} type is a
signed or unsigned integer used as an address, and is differentiated
from other integers in case hardware differentiates addresses from
integers.
The \TT{\ldots{}wrd} types
are the sizes that execute fastest, while the \TT{\ldots{}max} types
may be larger sizes for which all arithmetic and comparison
operations are \key{implemented}\label{IMPLEMENTED}.
Copying and conversion of values is always implemented for
\underline{all}
number types, regardless of implementation, except for implementations
that do not implement \underline{any} floating point types.

Here `\TT{std}' is the module abbreviation for the \TT{"standard"}
module to which builtin types and functions belong.  For convenience
the following abbreviations are builtin:
\begin{indpar}
\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{uns8} & {\tt `std~uns8'} \\
\ttkey{uns16} & {\tt `std~uns16'} \\
\ttkey{uns32} & {\tt `std~uns32'} \\
\ttkey{uns64} & {\tt `std~uns64'} \\
\ttkey{uns128} & {\tt `std~uns128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{int8} & {\tt `std~int8'} \\
\ttkey{int16} & {\tt `std~int16'} \\
\ttkey{int32} & {\tt `std~int32'} \\
\ttkey{int64} & {\tt `std~int64'} \\
\ttkey{int128} & {\tt `std~int128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{float16} & {\tt `std~float16'} \\
\ttkey{float32} & {\tt `std~float32'} \\
\ttkey{float64} & {\tt `std~float64'} \\
\ttkey{float128} & {\tt `std~float128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unsadr} & {\tt `std~unsadr'} \\
\ttkey{intadr} & {\tt `std~intadr'} \\
\ttkey{adr} & {\tt `std~adr'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unswrd} & {\tt `std~unswrd'} \\
\ttkey{intwrd} & {\tt `std~intwrd'} \\
\ttkey{floatwrd} & {\tt `std~floatwrd'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unsmax} & {\tt `std~unsmax'} \\
\ttkey{intmax} & {\tt `std~intmax'} \\
\ttkey{floatmax} & {\tt `std~floatmax'} \\
\end{tabular}
\end{indpar}

Here we use abbreviation statements of the form
\begin{center}
{\em abbreviation-name}~~\TT{\ABV}~~\TT{`}{\em replacement-name}\TT{'}
\end{center}
to specify that whenever the {\em abbreviation-name} occurs it is to be
replaced by the {\em replacement-name}.  See \itemref{ABBREVIATIONS} for
more abbreviation details. 

In this document we will use these abbreviations as the
`\skey{builtin number type}s':

\begin{indpar}
{\em builtin-number-type-name}\label{BUILTIN-NUMBER-TYPE-NAME}
    \begin{tabular}[t]{@{}cl}
    ::= & \TT{uns8} $|$ \TT{uns16} $|$ \TT{uns32} $|$ \TT{uns64}
                    $|$ \TT{uns128} \\
    $|$ & \TT{int8} $|$ \TT{int16} $|$ \TT{int32} $|$ \TT{int64}
                    $|$ \TT{int128} \\
    $|$ & \TT{float16} $|$ \TT{float32} $|$ \TT{float64} $|$ \TT{float128} \\
    $|$ & \TT{unsadr} $|$ \TT{intadr} $|$ \TT{adr} \\
    $|$ & \TT{unswrd} $|$ \TT{intwrd} $|$ \TT{floatwrd}  \\
    $|$ & \TT{unsmax} $|$ \TT{intmax} $|$ \TT{floatmax}  \\
    \end{tabular}
\end{indpar}

\subsubsection{Integer Number Types}

The \mkey{size}{of number}
of a number is the number of its bits.  Numbers can have
different sizes: for example, unsigned integers can have
sizes of 8, 16, 32, 64, or 128 bits.

Numbers are stored in registers or in random access memory (RAM).

An \key{unsigned integer} of size $S$ is a binary integer with
$S$ binary digits (\skey{bit}s) and range from $0$ to $2^S-1$.

A \key{signed integer} of size $S$ is a two's complement integer
of size $S$ and range from $-2^{S-1}$ to $+2^{S-1}-1$.
This represents the integer $I$ in the given range
by the unsigned $S$-bit integer equal to $I~\mbox{modulo}~2^S$.

An \key{address} holds a RAM byte address.
An address is a 32-bit or 64-bit signed or unsigned integer whose size
and signage are determined by the target machine.
Some of high order bits may be
required to be all 0's or all 1's, depending upon
the target machine.  The \TT{unsadr} and \TT{intadr}
unsigned and signed integer types of the same size
as an address are provided for storing indices and offsets.

A reasonable assumption for 64-bit addresses is that only the low
order 48-bits of the address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing an address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The L-Language does
\underline{not} depend upon this assumption, but does provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$ (see {\tt extract adr}, \pagref{EXTRACT-ADR}).
The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.\footnote{The I86 64-bit architecture
uses only the low order 48 bits of an address, but \underline{requires}
the high order 17 bits to all be the same, either all 1's or all 0's.
However, as it is unlikely that there will ever be an allocated memory region
that includes address 0 in its interior, it makes no significant difference
whether we consider addresses to be unsigned or signed.}

\subsubsection{Floating Point Number Types}

A \key{floating point number} of size $S$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes are as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}r@{~~~~~~}r}
                   &              &              &             & \bf Maximum \\
\bf Floating Point & \bf Exponent & \bf Mantissa & \bf Decimal & \bf Decimal\\
\bf Number Size    & \bf Size     & \bf Size     & \bf Digits  & \bf Exponent
\\[2ex]
16 bits & 5 bits & 10 bits & 3.31 & 4.51 \\
32 bits & 8 bits & 23 bits & 7.22 & 38.23 \\
64 bits & 11 bits & 52 bits & 15.95 & 307.95 \\
128 bits & 15 bits & 112 bits & 34.02 & 4931.77 \\
\end{tabular}
\end{center}

There are also three special floating point values:
\TT{+Inf} denoting positive infinity,
\TT{-Inf} denoting negative infinity,
and \TT{NaN} denoting `\key{not-a-number}' which is a value produced
when, for example, \TT{0} is divided by \TT{0}.
In this document \ttkey{NaN}\label{NAN} denotes the particular non-signaling
not-a-number value
produced by arithmetic operations that cannot produce a number.%
\footnote{For example, the x86 architecture generates a
`\key{floating indefinite NaN}' as output of such operations.}
Floating point variables can store many other not-a-number values.

\subsubsection{Number Conversion Functions}

In the following we specify builtin conversion functions using
function prototypes of the form:
\begin{center}
\tt function $T1$ r = std $F$ ( $T2$ v )
\end{center}
This says that if you apply the function $F$ to the value \TT{v} which
is of type $T2$, the function will return a value \TT{r} of type $T1$.
See \itemref{FUNCTION-PROTOTYPES-AND-CALLS} for more function prototype details.

If a conversion from type $T2$ to type $T1$ may be implied, then
in code of the form
\begin{center} \tt
\begin{tabular}{l}
$T2$ v = \ldots \\
$T1$ r = v
\end{tabular}
\end{center}
the second statement will automatically invoke the implied conversion.

The following builtin conversion functions are defined:

\begin{indpar}
{\tt function uns$x$~~~r = std \ttkey{uns$x$}~~~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{int$x$}~~~( uns$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{int$x$}~~~( int$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( int$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( float$y$ v )}
\begin{center}
for any $x>y$ for which the types are builtin
\end{center}
\begin{indpar}
For these conversion functions, no information is lost from
the value when it is converted to the new type.  These conversions
can be \ikey{implied}{implied conversion}.
\end{indpar}

{\tt function uns$x$~~~r = std \ttkey{mod}~~~( uns$y$ v )} \\
{\tt function uns$x$~~~r = std \ttkey{mod}~~~( int$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{mod}~~~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{mod}~~~( int$y$ v )}
\ttindex{mod}
\begin{center}
for any $x$ and $y$ for which the types are builtin
\end{center}
\begin{indpar}
These functions return a value equal to the argument
modulo $2^x$.
\end{indpar}

{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( float$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( float$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( float$y$ v )}
\ttindex{nearest}
\begin{center}
for any $x$ and $y$ for which the types are builtin
\end{center}
\begin{indpar}
These functions round the argument to the nearest value (ties to even)
of the result type if the result must have less precision than the argument.
If the value overflows the result type, the result is \TT{+Inf} or \TT{+Inf}
for floating point results, and the largest or smallest possible result
value for integer results.
\end{indpar}

\end{indpar}

Note the difference between \TT{mod} and \TT{nearest} when applied to
integers outside the range of the target type:
\begin{center}
\begin{tabular}{l}
{\tt uns8 ( mod ( 257 ) ) == 1} \\
{\tt uns8 ( nearest ( 257 ) ) == 255} \\
\end{tabular}
\end{center}

Floating point numbers can be converted to integer valued floating point
numbers via:

\begin{indpar}
{\tt function float$x$~~~r = std \ttkey{round}~~~~~( float$x$ v )} \\
{\tt function float$x$~~~r = std \ttkey{ceiling}~~~( float$x$ v )} \\
{\tt function float$x$~~~r = std \ttkey{floor}~~~~~( float$x$ v )}

\begin{center}
for any $x$ for which the types are builtin
\end{center}
\begin{indpar}
These functions round to nearest (ties to even),
round up, and round down respectively.
\end{indpar}
\end{indpar}


\subsubsection{Unchecked Number Conversions}

The following \underline{unchecked} conversion functions are defined.
Note that here \TT{*UNCHECKED*} is a qualifier; see \itemref{QUALIFIERS}
for qualifier details.

\begin{indpar}
{\tt function \TT{*UNCHECKED*} uns$x$~~~r =~%
	\ttmkey{uns$x$}{conversion function}~~~( int$x$ v )} \\
{\tt function \TT{*UNCHECKED*} uns$x$~~~r =~%
	\ttmkey{uns$x$}{conversion function}~~~( float$x$ v )} \\
{\tt function \TT{*UNCHECKED*} int$x$~~~r =~%
	\ttmkey{int$x$}{conversion function}~~~( uns$x$ v )} \\
{\tt function \TT{*UNCHECKED*} int$x$~~~r =~%
	\ttmkey{int$x$}{conversion function}~~~( float$x$ v )} \\
{\tt function \TT{*UNCHECKED*} float$x$~r =~%
	\ttmkey{float$x$}{conversion function}~( uns$x$ v )} \\
{\tt function \TT{*UNCHECKED*} float$x$~r =~%
	\ttmkey{float$x$}{conversion function}~( int$x$ v )}

\begin{center}
for any $x$ for which the types are builtin
\end{center}
\begin{indpar}
These functions just return the $x$-bit value of \TT{v}
unchanged except for giving it a different type.
\end{indpar}
\end{indpar}

\subsubsection{Number Constants}
\label{NUMBER-CONSTANTS}

A \key{number-constant} is a {\em number} lexeme with specific syntax
that is used to denote a number.  The syntax is:

\begin{indpar}
\emkey{number-constant}\label{NUMBER-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em decimal-constant} \\
    $|$ & {\em binary-constant} \\
    $|$ & {\em hexadecimal-constant} \\
    $|$ & \TT{+Inf}\index{Inf@\TT{+Inf}}
          ~$|$~ \TT{-Inf}\index{Inf@\TT{-Inf}}
          ~$|$~ \ttkey{NaN}
    \end{tabular}
\\[0.5ex]
\emkey{sign} :::= \TT{+} $|$ \TT{-} \\
\emkey{exponent} :::=
	\{ \TT{e} $|$ \TT{E} \} {\em sign}\QMARK{} {\em dit}\PLUS{}
\\[0.5ex]
\emkey{decimal-constant} \begin{tabular}[t]{@{}rl@{}}
                         ::= & {\em decimal-lexeme} \\
			 $|$ & {\em decimal-constant-prefix} ~
			       {\em decimal-quoted-body} ~
			       {\em exponent}\QMARK{}
			 \end{tabular}
\\[0.5ex]
\emkey{decimal-lexeme} :::= {\em sign}\QMARK{} ~ {\em decimal-integer} ~
			    {\em decimal-fraction}\QMARK{} ~
                            {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{decimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{D}
\\[0.5ex]
\emkey{decimal-quoted-body} :::= \TT{"} {\em decimal-integer} ~
				 {\em decimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{decimal-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em dit}\PLUS{} \\
     $|$ & {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
     $|$ & {\em dit} {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
     $|$ & {\em dit} {\em dit} {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
    \end{tabular} \\
\emkey{decimal-fraction} :::= \TT{.} {\em dit}\PLUS{} \\
\emkey{dit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
 \\[0.5ex]
\emkey{binary-constant} ::= {\em binary-constant-prefix} ~
                              {\em binary-quoted-body} ~
			      {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{binary-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{B}
\\[0.5ex]
\emkey{binary-quoted-body} :::= \TT{"} {\em binary-integer} ~
				{\em binary-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{binary-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em bit}\PLUS{} \\
     $|$ & {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
     $|$ & {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
     $|$ & {\em bit} {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
     $|$ & {\em bit} {\em bit} {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
    \end{tabular} \\
\emkey{binary-fraction} :::= \TT{.} {\em bit}\PLUS{} \\
\emkey{bit} :::= \TT{0} $|$ \TT{1}
 \\[0.5ex]
\emkey{hexadecimal-constant} ::= \\
\hspace*{0.5in}{\em hexadecimal-constant-prefix} ~
               {\em hexadecimal-quoted-body} ~
	       {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{hexadecimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{X}
\\[0.5ex]
\emkey{hexadecimal-quoted-body} :::= \TT{"} {\em hexadecimal-integer} ~
				     {\em hexadecimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{hexadecimal-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em hit}\PLUS{} \\
     $|$ & {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
     $|$ & {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
     $|$ & {\em hit} {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
     $|$ & {\em hit} {\em hit} {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\STAR{} \\
    \end{tabular} \\
\emkey{hexadecimal-fraction} :::= \TT{.} {\em hit}\PLUS{} \\
\emkey{hit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
	     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
	     $|$ \TT{a} $|$ \TT{b} $|$ \TT{c} $|$ \TT{d} $|$ \TT{e} $|$ \TT{f}
	     $|$ \TT{A} $|$ \TT{B} $|$ \TT{C} $|$ \TT{D} $|$ \TT{E} $|$ \TT{F}
\end{indpar}

The integer part of decimal constants may have commas
every 3 digits, and the integer part of binary and hexadecimal constants
may have commas every 4 digits.
If there is a decimal point, there \underline{must}
be at least one integer digit and
one fraction digit.

\TT{NaN} denotes a canonical non-signaling NaN such
at that produced by hardware on the target machine
(\pagref{NAN}).
\TT{+Inf} denotes positive infinity; \TT{-Inf} denotes negative infinity.

{\em Number-constants} have no type.  They can be converted to
values of number type as follows.

A {\em number-constant} can be implicitly converted to any number
type that can represent the number exactly.

A {\em number-constant} can be implicitly converted to any
floating point number type.  If it is too large, it is converted to
\TT{+Inf}, and if it is too small, it is converted to \TT{-Inf}.
If it cannot be represented exactly, it is rounded (ties to even).

A {\em number-constant} can be explicitly converted to any number
type by the \TT{mod} or \TT{nearest} functions.  It may be explicitly
converted by \TT{uns$x$}, \TT{int$x$}, or \TT{float$x$} functions only
if it may be implicitly converted to the desired type.

{\em Number-constants} are compile time values and can be combined by
the standard operators to produce compile time values.

\subsection{The Void Type}
\label{THE-VOID-TYPE}

A \ttkey{void} type variable has no value.  No value can be
assigned to such a variable.  Nevertheless such variables have
uses, for example, as base variable in clusters (\pagref{CLUSTERS}).
When used as the base variable of a cluster, an assignment statement
may appear to be assigning a value to a \TT{void} variable, but
in fact it is assigning values to cluster members.

\subsection{Defined Types and Type Names}
\label{DEFINED-TYPES-AND-TYPE-NAMES}

A declaration statement of the following form defines a new type and
specifies a {\em type-name} for that type:
\begin{indpar}
\emkey{defined-type-declaration}\label{DEFINED-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
\TT{define type}
          {\em qualifier-name}\STAR{} {\em defined-type-name}
          \TT{as} {\em base-type-expression} \\
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME} \\
\emkey{defined-type-name} ::= {\em type-name} ~~~~~ [see \pagref{TYPE-NAME}] \\
\emkey{base-type-expression} ::= {\em expression} evaluating at compile-time
				 to a \TT{type} value \\
{\em expression} ::= see \pagref{EXPRESSION}
\end{indpar}

A \TT{type} value is an enumeration value (\pagref{ENUMERATION-TYPES}),
which is basically a small integer that identifies the type.
Types can be computed
by compile-time expressions, just like integers.
A \TT{type} value can be associated with zero or more {\em type-names},
which can be used in various ways, including as the name of a constant
equal to the \TT{type} value.

In a {\em defined-type-declaration}
the {\em base-type-expression} specifies
the `\key{base type}' of the new type defined
by the {\em defined-type-declaration}.
The {\em defined-type-name} names a new `\key{defined type}'.
The simplest {\em base-type-expres\-sion} is just a {\em type-name} of the
base type.

Any {\em qualifiers} in the declaration are attached to every
variable or argument declared with the {\em defined-type-name} (see
section \itemref{QUALIFIERS} for more on {\em qualifiers}).
Such {\em qualifiers} are associated with {\em type-names} and not
with \TT{type} values.

No {\em type-name} may be a prefix of
any {\em deferred-variable} (\pagref{DEFERRED-VARIABLE})
or any {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME}).
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.

Consider the example:
\begin{indpar}\begin{verbatim}
define type T1 as int32
type T2 = int32
define type T3 as T2  // Same as `define type T3 as int32'
int32 x = 1
T1 x1 = T1 ( x )
T2 x2 = x             // Compile error: T2 is not a type-name
T3 x3 = T3 ( x )
\end{verbatim}\end{indpar}

A `{\tt \ttkey{define type} T as \ldots}'
statement defines {\tt T} to be a {\em type-name} that can be used in
a declaration of the form `{\tt T v}',
or can be used to name a constant equal a \TT{type} value
as in `{\tt T == int32}',
or can be used
as a function of one argument to convert the argument to the
type, as in `{\tt T(v)}'.
However a statement of the form `{\tt type T = \ldots}'
declares {\tt T} to be a mere variable name that can only be
use as a constant equal a \TT{type} value.

A defined type has an
`\mkey{underlying type}{of defined type}'\label{UNDERLYING-TYPE} that
is a builtin type.  Underlying types are defined recursively:
the underlying type of a defined type is the underlying type of
its base type, and the underlying type of a builtin type is
the builtin type itself.

The following builtin functions are defined:
\begin{indpar}
{\tt function \TT{*UNCHECKED*} $T$ r = $T$ ( $B$ v )} \\
{\tt function \TT{*UNCHECKED*} $B$ r = $B$ ( $T$ v )}

where $T$ is a {\em defined-type-name} and $B$ is any {\em type-name}
for the base type of $T$

\begin{indpar}
These functions do not change the actual value, but merely its
compile-time type.  Using these unchecked conversions,
implied conversions in one direction only
may be defined as desired: see \itemref{IMPLIED-CONVERSION}.
\end{indpar}\label{DEFINED-TYPE-UNCHECKED-CONVERSION}

{\tt function type r = std \ttkey{base type of} ( type t )}

\begin{indpar}
Returns the base type of the defined type {\tt t}.
\end{indpar}

{\tt function type r = std \ttkey{underlying type of} ( type t )}

\begin{indpar}
Returns the underlying type of the defined type or builtin type {\tt t}.
\end{indpar}
\end{indpar}

A type may have zero or more type names associate with it.
An addition name may be associated with a type by the statement:
\begin{indpar}
\emkey{type-name-declaration}\label{TYPE-NAME-DECLARATION} ::= \\
\hspace*{0.5in}
\TT{define type}
          {\em qualifier-name}\STAR{} {\em type-name}
          \TT{as type name of} {\em type-expression} \\
\emkey{type-expression} ::= {\em expression} evaluating at compile-time
				 to a \TT{type} value \\
{\em expression} ::= see \pagref{EXPRESSION}
\end{indpar}

Unlike the {\em defined-type-declaration}, the {\em type-name-declaration}
does \underline{not} define a new type.  It merely defines a new
{\em type-name} that references an old type.
The {\em qualifier-names} in either declaration are associated
with the {\em type-name}, and not the type, and are applied whenever
the {\em type-name} is used to declare a variable.

An example is:
\begin{indpar}\begin{verbatim}
define type T4 as type name of int32
    // Now T4 == int32
T4 x = 1              // Same as `int32 x = 1'
int32 y = T4 ( x )    // Same as `int32 y = int32 ( x )'
define type T5 as int32
    // Now T5 != int32 and T5 != T4
define *UNCHECKED* T6 as type name of int32
    // *UNCHECKED* is a builtin qualifier
    // Now T6 == int32
T6 x = 1              // Same as `*UNCHECKED* int32 x = 1'
\end{verbatim}\end{indpar}

\subsection{Enumeration Types}
\label{ENUMERATION-TYPES}

An \key{enumeration type} is a defined type whose values are
integers assigned to \skey{enumeration constant}s.
Each enumeration constant is assigned a value during compilation
that is an integer unique relative to all enumeration
constants of its enumeration type that are being compiled together.
Then during program initialization
the enumeration constant is assigned a possibly
different value that is an integer unique relative to all enumeration
constants of its enumeration type that are being initialized by
the program.

A declaration statement of the following form defines an \key{enumeration type}
that has enumeration values:
\begin{indpar}
\emkey{enum-type-declaration}\label{ENUM-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
    \TT{define type} {\em qualifier-name}\STAR{}
    \begin{tabular}[t]{@{}l@{}}
    {\em enum-type-name} \TT{as}~~~{\em enum-base} \\
    \TT{with enum range}~~~{\em enum-range} \\
    \end{tabular}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
\emkey{enum-type-name} ::= {\em type-name} ~~~~~ [see \pagref{TYPE-NAME}]
\\[0.5ex]
\emkey{enum-base}
    \begin{tabular}[t]{rl}
    ::= & {\em integer-type-expression} \\
    $|$ & {\em enum-direction}~~~{\em enum-type-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{integer-type-expression} ::= {\em expression} evaluating at compile-time
				 to a builtin integer \TT{type}
\\[0.5ex]
\emkey{enum-direction} ::= \TT{next} $|$ \TT{previous}
\\[0.5ex]
\emkey{enum-type-expression} ::= {\em expression} evaluating at compile-time
				 to an enumeration \TT{type}
\\[0.5ex]
\emkey{enum-range}
    \begin{tabular}[t]{rl}
    ::= & \TT{[} {\em first-enum} \TT{..} {\em last-enum} \TT{]} \\
    $|$ & \TT{[} {\em first-enum} \TT{..} \TT{]} \\
    $|$ & \TT{[} \TT{..} {\em last-enum} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{first-enum} ::=
    {\em expression} evaluating at compile-time to a integer
\\[0.5ex]
\emkey{last-enum} ::=
    {\em expression} evaluating at compile-time to a integer
\\[0.5ex]
\emkey{expression} ::= see \pagref{EXPRESSION}
\end{indpar}

Here {\em first-enum} and {\em last-enum} are compile time integer
values assigned to the newly defined enum type.
{\em First-enum} must be less than or equal to {\em last-enum}.
If {\em last-enum} is not given, it is assumed to be the maximum
value permitted by the {\em enum-base} that conforms to the
rules given below.
Similarly if {\em first-enum} is not given, it is assumed to be the minimum
value permitted by the {\em enum-base}.

The {\em enum-base} specifies the `\mkey{base type}{of enumeration type}'
of the enumeration type
which is either the type given by an {\em integer-type-expression} or
the type given by an {\em enum-type-expression}.
The `\mkey{underlying type}{of enumeration type}'
of the enumeration type
is the base type if that is an integer type, or is the
underlying type of the base type otherwise.
This definition is recursive, so the underlying type of an enumeration
type is always an
integer type.

Information about
an enumeration type
can be discovered by the functions:

\begin{indpar}

{\tt function type r = std \ttkey{base type of} ( type t )} \\
{\tt function type r = std \ttkey{underlying type of} ( type t )}

\begin{indpar}
Returns the base type or underlying type of the enumeration type {\tt t}.
\end{indpar}

{\tt function intwrd r = std \ttkey{enum direction of} ( type t )}

\begin{indpar}
Returns the {\em enum-direction} of the enumeration type {\tt t}.
{\tt -1} is returned if the direction is `{\tt previous}',
{\tt +1} is returned if the direction is `{\tt next}',
and {\tt 0} is returned if the direction is not given.
\end{indpar}

{\tt function $I$ r = std \ttkey{first enum of} ( type t )} \\
{\tt function $I$ r = std \ttkey{last enum of} ( type t )}

\begin{center}
where $I$ is the first type in the sequence \\
\TT{intwrd     unswrd     intmax     unsmax} \\
such that both the {\em first-enum} and the {\em last-enum} \\
of enumeration type {\tt t} are convertible to $I$
\end{center}

\begin{indpar}
Returns the {\em first-enum} or {\em last-enum} of the enumeration type {\tt t}.
\end{indpar}

\end{indpar}

Enumeration values can be assigned by assignment statements of the form
\begin{indpar}
\emkey{enum-assignment}
    \begin{tabular}[t]{rl}
    ::= & {\em enum-type-name} ~ {\em enum-constant-name}\TT{ = next enum} \\
    $|$ & {\em enum-type-name} ~ {\em enum-constant-name}\TT{ = previous enum}
    \end{tabular}
\\[0.5ex]
\emkey{enum-constant-name} ::= {\em variable-name}
		~~~~~ [see \pagref{VARIABLE-NAME}]
\end{indpar}

These statements invoke one of the builtin functions:
\begin{indpar}
{\tt function $T$ r = $ma$\QMARK{} \ttkey{next enum}} \\
{\tt function $T$ r = $ma$\QMARK{} \ttkey{previous enum}}
\begin{center}
where $T$ is the {\em enum-type-name} and $ma$ is its
{\em module-abbreviation}, if any
\end{center}


\end{indpar}

Within a compilation the compiler assigns the value {\em first-enum}
to the first constant named in a `\TT{next enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in increasing order.
It is an error if `\TT{next~enum}'
would return a value beyond the {\em last-enum} value in a range.

Similarly the compiler assigns the value {\em last-enum}
to the first constant named in a `\TT{previous enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in decreasing order.
It is an error if `\TT{previous~enum}'
would return a value below the {\em first-enum} value in a range.

It is also an error if for a given type the same value is returned
by some \TT{next~enum} and also by some \TT{previous~enum}.

In memory an enumeration value is represented by an integer value
of the underlying type of the enumeration value's enumeration type.
This is called the `\mkey{underlying value}{of enumeration value}'
of the enumeration value.

The following unchecked conversions between enumeration values are builtin:
\begin{indpar}

{\tt function \TT{*UNCHECKED*} $E1$ r = $E1$ ( $E2$ v )}
\begin{center}
where $E1$ and $E2$ are both enumeration types
and $E1$ and $E2$ have the same underlying type
\end{center}
\begin{indpar}
These conversions do nothing but change the type of the value.
\end{indpar}

\end{indpar}

The enumeration value also has a
numeric value in the range
{\tt [}{\em first-enum}{\tt ,} {\em last-enum}{\tt ]}, which is
called the `\mkey{range value}{of enumeration value}' of the
enumeration value.  The difference between the underlying value
and the range value of an enumeration value is a constant
called the `\mkey{enumeration offset}{of enumeration type}' of
the enumeration type.

In order to represent range values the `\mkey{range type}{of enumeration type}'
is used.  This is the first type $R$ in the sequence \\
\centerline{\TT{intwrd     unswrd     intmax     unsmax}}
such that both the {\em first-enum} and the {\em last-enum}
of the enumeration type are implicitly convertible to $R$.

In order to represent enumeration offset the
`\mkey{offset type}{of enumeration type}' is used.
This is the first type $O$ in the sequence \\
\centerline{\TT{intwrd     unswrd     intmax     unsmax}}
such that values of either the underlying type or the range type
of the enumeration type are implicitly convertible to $O$.

The following builtin functions can be used to find
these values:

\begin{indpar}

{\tt function $U$ r = $ma$\QMARK{} \ttkey{underlying value of} ( $E$ v )} \\
{\tt function $R$ r = $ma$\QMARK{} \ttkey{range value of} ( $E$ v )}

\begin{center}
where $E$ is an {\em enum-type-name}, 
$ma$ is the {\em module-abbreviation} of $E$ if any, \\
$U$ is the underlying type of $E$,
and $R$ is the range type of $E$
\end{center}
\begin{indpar}
The underlying value or range value of {\tt v} is returned.
\end{indpar}

{\tt function $O$ r = std \ttkey{enumeration offset of} ( type t )} \\
{\tt function type r = std \ttkey{range type of} ( type t )} \\
{\tt function type r = std \ttkey{offset type of} ( type t )}

\begin{center}
where {\tt t} is an enumeration type and $O$ is its offset type
\end{center}
\begin{indpar}
The enumeration offset, range type, or offset type of {\tt t} is returned.
\end{indpar}

\end{indpar}

Thus for a value {\tt v} of an enumeration type $E$,
\begin{center}
\tt underlying value of ( v ) \begin{tabular}[t]{@{}l@{}}
                              = range value of ( v ) \\
			      + enumeration offset of ( $E$ )
			      \end{tabular}
\end{center}

If the base type of an enumeration type is a builtin integer type,
the integer value corresponding to {\em first-enum} is {\em first-enum}
itself, and similarly for {\em last-enum}.  Thus the enumeration offset
is zero and we have the following example:
\begin{indpar}\begin{verbatim}
define type E as int32 with enum range [1 .. 20]
    // Now enumeration offset of (E) == 0
E C1 = next enum
    // Now underlying value of (C1) == 1
E C2 = next enum
    // Now underlying value of (C2) == 2
E C3 = previous enum
    // Now underlying value of (C3) == 20
E C4 = previous enum
    // Now underlying value of (C4) == 19
\end{verbatim}\end{indpar}

The enumeration offset of an {\em enum-type-name} is defined in general
as per the following cases:

\begin{indpar}
\begin{itemlist}
\item[\TT{define type} {\em qualifier-name}\STAR{} {\em enum-type-name}~~%
    \TT{as}~~{\em integer-type-expression} \ldots{}] ~\\
The enumeration offset of the {\em enum-type-name} equals \TT{0}.
\item[\TT{define type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em enum-type-name}~~\TT{as}~~%
              \TT{next}~~{\em enum-type-expression} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Has the effect of compiling the statements:
\begin{center}
\begin{tabular}{l}
{\em base-enum-type-name} {\tt ~V0~~=~~next enum} \\
{\em base-enum-type-name} {\tt ~V1~~=~~next enum} \\
{\em base-enum-type-name} {\tt ~V2~~=~~next enum} \\
\ldots\ldots\ldots \\
{\em base-enum-type-name} {\tt ~V$n$~~=~~next enum} \\
\end{tabular}
\end{center}
where $n$ = {\em last-enum} - {\em first-enum}, and then setting
\begin{center}
\TT{enumeration offset of (}{\em enum-type-name}\TT{)} = \\
{\tt ~~~~underlying value of (V0)~-~}{\em first-enum}
\end{center}
\item[\TT{define type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em enum-type-name}~~\TT{as}~~%
              \TT{previous}~~{\em enum-type-expression} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Has the effect of compiling the statements:
\begin{center}
\begin{tabular}{l}
{\em base-enum-type-name} {\tt ~V0~~=~~previous enum} \\
{\em base-enum-type-name} {\tt ~V1~~=~~previous enum} \\
{\em base-enum-type-name} {\tt ~V2~~=~~previous enum} \\
\ldots\ldots\ldots \\
{\em base-enum-type-name} {\tt ~V$n$~~=~~previous enum} \\
\end{tabular}
\end{center}
where $n$ = {\em last-enum} - {\em first-enum}, and then setting
\begin{center}
\TT{enumeration offset of (}{\em enum-type-name}\TT{)} = \\
{\tt ~~~~underlying value of (V0)~-~}{\em last-enum}
\end{center}
\end{itemlist}
\end{indpar}

The above is exemplified by:
\begin{indpar}\begin{verbatim}
define type E1 as int32 with enum range [1 .. 20]
    // Now enumeration offset of (E1) == 0
E1 C1 = previous enum
    // Now range value of (C1) == 20
    // Now underlying value of (C1) == 20
define type E2 as previous E1 with enum range [1 .. 10]
    // Now enumeration offset of (E2) == 9
E2 C2 = next enum 
    // Now range value of (C2) == 1,
    // Now underlying value of (C2) == 10
E2 C3 = previous enum 
    // Now range value of (C3) == 10,
    // Now underlying value of (C3) == 19
define type E3 as next E2 with enum range [1 .. 5]
    // Now enumeration offset of (E3) == 10
E3 C4 = next enum 
    // Now range value of (C4) == 1,
    // Now underlying value of (C4) = 11
\end{verbatim}\end{indpar}

The following builtin functions allow comparison and subtraction
of enumeration values:

\begin{indpar}

{\tt function bool r = std ( $E$ v1 ) "$cop$" ( $E$ v1 )}

\begin{center}
where $E$ is an enumeration type and $cop$ is
\ttmkey{<}{of enum values}, \ttmkey{<=}{of enum values},
\ttmkey{==}{of enum values}, \ttmkey{!=}{of enum values},
\ttmkey{>=}{of enum values}, or \ttmkey{>}{of enum values}.
\end{center}
\begin{indpar}
Returns {\tt range value of (v1) "$cop$" range value of (v2)}.
\end{indpar}

{\tt function $R$ r = ( $E$ v1 ) "\ttmkey{-}{of enum values}" ( $E$ v1 )}
\begin{center}
where $E$ is an enumeration type and $R$ is its range type
\end{center}
\begin{indpar}
Returns {\tt range value of (v1) "-" range value of (v2)}.
\end{indpar}

\end{indpar}

Two enumeration values of different types
may be compared or subtracted if they can be implicitly
converted to a common enumeration or integer type.

The following are builtin enumeration types:
\begin{indpar} \tt
define type~\ttkey{std type}~as unswrd with enum [0~..] \\
\ttkey{type} ---> `std type' \\
type \ttkey{std missing type}~= next enum // 0 \\
function std type r = \ttmkey{std missing}{type}: \\
\hspace*{0in}~~~~r = std missing type
\\[1ex]
define type~\ttkey{std qualifier}~as unswrd with enum [0~..] \\
\ttkey{qualifier} ---> `std qualifier' \\
qualifier~\ttkey{std missing qualifier}~= next enum // 0 \\
function std qualifier r = \ttmkey{std missing}{qualifier}: \\
\hspace*{0in}~~~~r = std missing qualifier
\\[1ex]
define type~\ttkey{std bool}\begin{tabular}[t]{@{}l@{}}
                            ~as unswrd with enum [0~..~1] \\
		            \end{tabular} \\
\ttkey{bool} ---> `std bool' \\
bool~\ttkey{std false}~= next enum // 0 \\
\ttkey{false} ---> `std false' \\
bool~\ttkey{std true}~~= next enum // 1 \\
\ttkey{true} ---> `std true'
\end{indpar}

Builtin types not mentioned above, such as `\TT{void}' and `\TT{int32}',
are given unspecified (i.e., implementation dependent)
`\TT{type}' enumeration values.
Similarly builtin qualifiers, such as `\TT{mem}', are given
unspecified `\TT{quali\-fier}' enumeration values.  
The `\TT{range value of}' function above
can be used to find the range value of an
enumeration constant, but unspecified builtin values may differ from
one compilation or program to the next.

Enumeration values are assigned within a compilation in
the order that {\em enum-assignments} are compiled.
Enumeration values are assigned during program initialization
according to the order
that code files containing the {\em enum-assignments} are initialized.
The program initialization
and compile values assigned by an {\em enum-assignment}
may differ.

However, within a code file, all assignments to an enumeration type
are done in the same order during program initialization as during compilation.
Thus values assigned within the same code file can be assumed to be
in the same order at compile and run times.  Also,
compile and run values of a given enumeration type
can be assumed to be the same if \underline{all} values
of that enumeration type are assigned in the a single code file.

\subsection{Enumeration Set and List Types}
\label{ENUMERATION-SET-AND-LIST-TYPES}

For every enumeration type two additional types are created,
an enumeration set type and an enumeration list type.
An \key{enumeration set} is a set of enumeration values.
An \key{enumeration list} is a list of enumeration values.
These two new types do not have {\em type-names},
but they can be discovered by the following functions:

\begin{indpar}

{\tt function type r = std \ttkey{set of} ( type E )} \\
{\tt function type r = std \ttkey{list of} ( type E )}
\begin{indpar}
Returns the type whose values are sets or lists
of elements of type {\tt E}, where
{\tt E} must have an integer underlying type.
\end{indpar}

\end{indpar}

These types can be given type names by
{\em type-name-declarations} (\pagref{TYPE-NAME-DECLARATION}) of the form
\begin{indpar}
{\tt define type }{\em type-name}{\tt ~as type name of set of ( $E$ )} \\
{\tt define type }{\em type-name}{\tt ~as type name of list of ( $E$ )}
\end{indpar}
where $E$ is the element type.

Note that the element type of an enumeration set or list can be
a builtin integer type or a non-enumeration defined type
with a builtin integer underlying type.

The syntax
for enumeration set and list constants is:
\begin{indpar}
\emkey{enum-set-constant}\label{ENUM-SET-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{~\}} \\
    $|$ &\TT{\{} {\em enum-item}
                   \{ \TT{,} {\em enum-item} \}\STAR{} \TT{\}} \\
    \end{tabular} \\
\emkey{enum-list-constant}\label{ENUM-LIST-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{[~]} \\
    $|$ &\TT{[} {\em enum-item}
                   \{ \TT{,} {\em enum-item} \}\STAR{} \TT{]} \\
    \end{tabular} \\
\emkey{enum-item}
    ::= {\em enum-value} $|$ {\em enum-range} \\
\emkey{enum-range}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em enum-value}~~~\TT{..}~~~{\em enum-value} \\
    $|$ & {\em enum-value}~~~\TT{..} \\
    $|$ & \TT{..}~~~{\em enum-value} \\
    \end{tabular} \\
\emkey{enum-value} ::= {\em expression} evaluating at compile-time to
			an enumeration or integer value
\end{indpar}

If the {\em enum-values} in an {\em enum-set-constant} or
{\em enum-list-constant} have different
types, and these are defined types or enumeration types,
implied conversions from these to their base types
are inserted until all have the same defined type, enumeration type,
or builtin integer type,
which is called the
`\key{common element type}'\label{COMMON-ELEMENT-TYPE}
of the set or list.
This is the least general type to which all the set
or list
elements can be converted (see \pagref{CONVERSION-RELATION}).
It is an error
if this cannot be done because some of the types have no implied
conversion to their base type defined for them.
The type of an enumeration set or list is the set or list type
defined for this common element type.

An {\em enum-range} designates the two values given and all
values in between.
After implied conversion, the first {\em enum-value} in an {\em enum-range}
must \underline{not} be greater than the second {\em enum-value}
in the {\em enum-range}.  If the first or second {\em enum-value} of
an {\em enum-range} is omitted, it is taken to be the lower or upper
limit of the enumeration type of the non-omitted {\em enum-value}.

The order in which values are given in an {\em enum-set-constant}
does not matter.  Overlapping and adjoining ranges are implicitly
combined.\footnote{Internally an enumeration set may be stored as a
sorted list of integers with binary indicators specifying when all
the values between one integer and the next integer are to be included
in the set.}
Thus
\begin{indpar}\begin{verbatim}
define type X as uns8 with enum range [1 .. 20]
X X1 = next enum
X X2 = next enum
. . . . . . . . . .
X X20 = next enum

// Then:
//
//    { X1, X5, X2, X10 .. X16, X19 .. X20, X15 .. X18 }
// == { X1, X2, X5, X10 .. X20 }
\end{verbatim}\end{indpar}

The order in which values are given in an {\em enum-list-constant}
does matter, and ranges are not combined.  Thus in the above
example `\TT{[X1 X2] != [X2 X1]}' and `\TT{[X1 X1] != [X1]}'.

Enumeration set and list values are used in logical expressions that
condition function lookup.  For example,
\begin{indpar}\begin{verbatim}
T v = signed max (| type T |) ( T v1, T v2 )
      [| T is in { int8, int16, int32, int64, int128 } |]:
    . . . . . . . . . . .
\end{verbatim}\end{indpar}

defines a function that takes only signed integer type
arguments, and not unsigned integer type arguments.
The logical expression inside \TT{[|~|]} must be satisfied
for the function definition to match a function call, and
the type argument \TT{T}, which is implied and need not be
given in the function call, must be in the give set of
types, where types are values of the enumeration type `\TT{type}'
(see Section~\itemref{TYPE-VALUES}).

The information about enumeration set and list types can be determined
at compile-time by:

\begin{indpar}
{\tt function bool r = \ttkey{is enumeration set type} ( type T )}
\begin{indpar}
Returns \TT{true} if {\tt T} is an enumeration set type and \TT{false}
otherwise.
\end{indpar}

{\tt function bool r = \ttkey{is enumeration list type} ( type T )}
\begin{indpar}
Returns \TT{true} if {\tt T} is an enumeration list type and \TT{false}
otherwise.
\end{indpar}

{\tt function type r = \ttkey{element type of} ( type T )}
\begin{indpar}
Returns the element type of an enumeration set or list type {\tt T}.
\end{indpar}

\end{indpar}

The following are builtin enumeration set types:
\begin{indpar} \tt
define type \ttkey{std types} as set of type \\
\ttkey{types} ---> `std types' \\
define type \ttkey{std qualifiers} as set of qualifier \\
\ttkey{qualifiers} ---> `std qualifiers'
\end{indpar}

The following unchecked conversions between enumeration
set types and enumeration list types are builtin:
\begin{indpar}
{\tt function \TT{*UNCHECKED*} $T1$ r = $T1$ ( $T2$ v )}
\begin{center}
where $T1$ and $T2$ are either both enumeration set types or both
enumeration list types \\
and the element types of $T1$ and $T2$ have the same underlying type
\end{center}
\begin{indpar}
These conversions do nothing but change the type of the value.
\end{indpar}
\end{indpar}

Variables with compile-type enumeration set or list values can be defined.
If $S$ is an enumeration set type with element type $E$, and $L$ is
an enumeration list type with the same element type $E$, the following
functions are defined at compile-time (but may not be defined at
run-time):

\begin{indpar}
{\tt function $S$ r =
    std ($S$ v1) "\ttmkey{+}{enumeration set union}" ( $S$ v2 )}
\begin{indpar}
Returns the union of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $S$ r =
    std ($S$ v1) "\ttmkey{*}{enumeration set intersection}" ( $S$ v2 )}
\begin{indpar}
Returns the intersection of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $S$ r =
    std ($S$ v1) "\ttmkey{-}{enumeration set difference}" ( $S$ v2 )}
\begin{indpar}
Returns the set difference of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function bool r =
    std ($E$ e) \ttmkey{is in}{enumeration set} ($S$ s)}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the set {\tt s}, and
\TT{false} otherwise.
\end{indpar}

{\tt function $S$ r =
    std ($E$ e) "\ttmkey{+}{enumeration set union}" ($S$ s)}
\begin{indpar}
Returns union of \{{\tt e}\} and {\tt s}.
\end{indpar}

{\tt function $S$ r =
    std ($S$ s) "\ttmkey{+}{enumeration set union}" ($E$ e)}
\begin{indpar}
Returns union of \{{\tt e}\} and {\tt s}.
\end{indpar}

{\tt function $S$ r =
    std ($S$ s) "\ttmkey{-}{enumeration set union}" ($E$ e)}
\begin{indpar}
Returns the set difference of {\tt s} and \{{\tt e}\}.
\end{indpar}

{\tt function unswrd r = std \ttmkey{size of}{enumeration set} ($S$ s)}
\begin{indpar}
Returns the size of the set {\tt s} (number of elements in {\tt s}).
\end{indpar}

{\tt function $E$ r = std ($S$ s) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of enumeration set}
\begin{indpar}
Returns the {\tt i+1}'st element of {\tt s}, where the elements
of {\tt s} are taken in the order of their integer underlying values.
It is an error if {\tt i >= size of (s)}.
\end{indpar}

{\tt function $S$ r = std $S$ ($L$ ls)}
\begin{indpar}
Convert the enumeration list {\tt ls} to an enumeration set,
removing duplicate elements.
\end{indpar}

{\tt function $L$ r = std ($L$ ls1)
		    "\ttmkey{+}{enumeration list concatenation}" ($L$ ls2)}
\begin{indpar}
Returns the concatenation of {\tt ls1} and {\tt ls2}.
\end{indpar}

{\tt function $L$ r = std ($L$ ls)
                        "\ttmkey{-}{enumeration list difference}" ($S$ s)}
\begin{indpar}
Returns the list made by removing all elements from {\tt ls} that
are in {\tt s}.
\end{indpar}

{\tt function bool r = std ($E$ e)
                        \ttmkey{in}{enumeration list} ($L$ ls)}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the list {\tt ls}, and
\TT{false} otherwise.
\end{indpar}

{\tt function $L$ r = std ($E$ e)
                        "\ttmkey{+}{enumeration list prepend}" ($L$ ls)}
\begin{indpar}
Returns the list made by prepending {\tt e} to {\tt ls}.
\end{indpar}

{\tt function $L$ r = std ($L$ ls)
                        "\ttmkey{+}{enumeration list append}" ($E$ e)}
\begin{indpar}
Returns the list made by appending {\tt e} to {\tt ls}.
\end{indpar}

{\tt function $L$ r = std ($L$ ls)
                        "\ttmkey{-}{enumeration list remove}" ($E$ e)}
\begin{indpar}
Returns the list made by removing the all occurrences of
{\tt e} in {\tt ls}.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{enumeration list} ($L$ ls)}
\begin{indpar}
Returns the length of the list {\tt ls} (number of elements in {\tt ls}).
\end{indpar}

{\tt function $E$ r = std ($L$ ls) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of enumeration list}
\begin{indpar}
Returns the {\tt i+1}'st list element of {\tt ls}.
It is an error if {\tt i >= length of (ls)}.
\end{indpar}

{\tt function $L$ r = std $L$ ($S$ s)}
\begin{indpar}
Convert the enumeration set {\tt s} to an enumeration list,
listing the elements of {\tt s} in order of their underlying values.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time enumeration
set and list variables.  If an implementation does
not implement run-time enumeration set and list variables,
enumeration set and list values computed at compile-time may
not be garbage collectible during the compilation.

\subsection{Type Values}
\label{TYPE-VALUES}

The type `\TT{type}' is a builtin enumeration type declared
by the builtin equivalent of:
\begin{indpar} \tt
define type \ttkey{std type} as unswrd with enum [0~..] \\
type \ttkey{std missing type} = next enum // 0 \\
type \ttkey{std type} = next enum // 1 \\
function std type r = std \ttmkey{missing}{type}: \\
\hspace*{3em}r = std missing type \\
\ttkey{type} \ABV{} `std type'
\end{indpar}
Each type is associated with a unique enumeration value
of type `\TT{type}', and this value can be used at both
compile and run time to test whether two `\TT{type}'s are
equal.

New types are declared by statements of the form:
\begin{center}
\tt \ttkey{define type} {\em type-name} \ldots{}
\end{center}
The {\em type-name} of a type can be used (1) before a {\em variable-name}
in a declaration, (2) as the name of an enumeration value in an
expression, or (3) as the name of a function in a {\em function-call}.

Values of one type $T1$ may be \key{explicitly converted} to another
type $T2$ if and only if an inline function with prototype:
\begin{center} \tt
function \ldots~$T2$ r = $T2$ ( \ldots~$T1$ v )
\end{center}
is defined, where the `\ldots{}' denote arbitrary qualifiers.

Values of one type $T1$ may be \key{implicitly converted} to another
type $T2$ if and only if an inline function with prototype:
\begin{center} \tt
function \ldots~$T2$ r = \ttkey{implicit conversion} ( \ldots~$T1$ v )
\end{center}
is defined, where the `\ldots{}' denote arbitrary qualifiers.
Given assignment statements
\begin{center}
\begin{tabular}{l}
\tt $T1$ w = \ldots \\
\tt $T2$ v = w \\
\end{tabular}
\end{center}

where $T2\neq T1$, the compiler will change the second statement to
\begin{center}
\tt $T2$ v = implicit conversion ( w )
\end{center}

There can be several {\tt implicit conversion} functions from $T1$
to $T2$ defined, each with different qualifiers.

If \underline{any} implicit conversion from $T1$ to $T2$ is defined,
we say the $T1$ is \mkey{more specific}{types}
than $T2$, or $T2$ is \mkey{more general}{types} than $T1$, or
symbolically,
\begin{center}
{\tt $T1~~\CNV~~T2$}
\end{center}%
\label{CONVERSION-RELATION}

The transitive closure of the $\CNV$ relation between types is
required to be a partial order,
or equivalently, the directed graph whose nodes are types
that has an arrow from $T1$ to
$T2$ if and only if $T1 \CNV T2$ is required to be acyclic.
This graph is know as the \key{implied conversion graph}.

In addition, if there are two paths from type $T1$
to type $T2$ in the implicit conversion graph that
are disjoint except for their endpoints, there must also
be a direct arrow from $T1$ to $T2$ in the graph, i.e.,
\begin{center} \tt
function \ldots~$T2$ r = \ttkey{implied conversion} ( \ldots~$T1$ v )%
\label{IMPLIED-CONVERSION}
\end{center}
must be defined.
This last rule
allows the call-prototype matching rule
\ref{MORE-RESTRICTIVE-ARGUMENT-TYPES-PREFERRED}
on page \pagref{MORE-RESTRICTIVE-ARGUMENT-TYPES-PREFERRED}
to disambiguate an implicit conversion from a $T1$ value to
a $T2$ value by always choosing the direct path $T1\CNV T2$.

For example, since
\begin{center}
{\tt uns16 $\CNV$ int32 $\CNV$ int64} \\
and \\
{\tt uns16 $\CNV$ uns32 $\CNV$ int64}
\end{center}
are both in the graph,
then {\tt uns16 $\CNV$ int64} must be too.

If the direct conversion does not exist,
the implicit conversion will be a compilation error.
If qualifiers disable the direct implicit conversion but
not the two paths, the implicit conversion will be a compilation
error for those qualifiers.
Note that by rule
\ref{ARGUMENT-CALL-PROTOTYPE-MATCHING}
on \pagref{ARGUMENT-CALL-PROTOTYPE-MATCHING}
such compilation errors may not be explicitly visible,
but may be hidden inside call-prototype match failures.

Although the compiler cannot check this, it should be true
that if there are two different paths from one type to another
in the implicit conversion graph, both paths produce the same
result.  For example:
\begin{indpar}\begin{verbatim}
int16 v1 = ...
int32 v2 = v1
float64 v3 = v2
    // Implied conversions are v1 ---> v2 ---> v3.
float64 v4 = v1
    // Implied conversion is v1 ---> v4.

// v3 == v4 should be true.
\end{verbatim}\end{indpar}

If for a set of types $\{T1,T2,\ldots\}$ there is a unique
type $T$ such that $T1\TCNV T$, $T2\TCNV T$, \ldots{}, where
$\TCNV$ is the transitive closure of $\CNV$, then
$T$ is called the `\key{least upper bound}'\label{LEAST-UPPER-BOUND}
of the set of types.

Functions can be overloaded based on the number and types
of their arguments, but also on the values of arguments that
are known at compile time.  For example, using this last,
many function declarations of the form
\begin{center}
\begin{tabular}{l}
{\tt function unsadr r = $ma$\QMARK{} size of ( type t == $T$ ):} \\
\hspace*{0in}{\tt ~~~~r = $S$}
\end{tabular}
\end{center}
be coded, where $ma$ is the {\em module-abbreviation} of the
type name $T$, if any, and $S$ is the size in bytes of values of type $T$.
As a consequence `{\tt size of ($T$)}' can be used at compile
time to determine the size in bytes of values of an arbitrary type
$T$.

It is also possible to define a default function that is used when
function declarations with known prototypes are not applicable.
For example, the following declarations are builtin:
\begin{indpar}\begin{verbatim}
function bool r = std ( type t == uns8 ):
    return true
function bool r = std ( type t == uns16 ):
    return true
function bool r = std ( type t == uns32 ):
    return true
function bool r = std ( type t == uns64 ):
    return true
function bool r = std ( type t == uns128 ):
    return true
function bool r = std ( type t ):
    return false
\end{verbatim}\end{indpar}
where the last declaration is the default when none of the others
apply.  See
rule \ref{REQUIRED-ARGUMENTS-PREFERRED},
\pagref{REQUIRED-ARGUMENTS-PREFERRED}.
In this case we refer to the last declaration as the
`\key{default declaration}' and say that the default declaration
returns \TT{false}.

The following are defined automatically for a type $T$, where
$ma$ is the {\em module-abbreviation} of the module containing
the declaration of $T$, if $T$ has such a {\em module-abbreviation}.
Only some of these functions have a default declaration, but for
those that do, the default declaration is in the \TT{std} module.

\begin{indpar}
{\tt function bool r = std ( type t == $T$ ) \ttkey{is uns}} \\
{\tt function bool r = std ( type t == $T$ ) \ttkey{is int}} \\
{\tt function bool r = std ( type t == $T$ ) \ttkey{is float}} \\
{\tt function bool r = std ( type t == $T$ ) \ttkey{is numeric}} \\
{\tt function bool r = std ( type t == $T$ )
				\ttkey{is implemented numeric}}
\begin{indpar}
These functions test {\tt t} in the current scope to see if it is
an \TT{uns$x$} type, an \TT{int$x$} type, a \TT{float$x$} type,
any of these types, or any of these types for which arithmetic
and comparison operators are
`implemented' (see \pagref{IMPLEMENTED}).
The default declaration returns \TT{false}.
\end{indpar}
\end{indpar}

\begin{indpar}
{\tt function type r = $ma$\QMARK{} \ttkey{base type of} ( type t == $T$ )}
\begin{indpar}
Returns the base type of the type {\tt t}.  For defined and enumeration
types this is the associated base type from the defined type's
declaration.
The default declaration returns {\tt t} itself.
\end{indpar}

{\tt function type r = $ma$\QMARK{} \ttkey{underlying type of}
					( type t == $T$ )}
\begin{indpar}
If {\tt t} is a defined or enumeration type, returns
\begin{center}
{\tt underlying type of ( base type of ( t ) )}
\end{center}
The default declaration returns {\tt t} itself.
\end{indpar}

{\tt function unsadr r = $ma$\QMARK{} \ttkey{size of} ( type t == $T$ )}
\begin{indpar}
Returns the number of bytes in a value of type {\tt t}.
For defined and enumeration types it is the size of their underlying type
The size of \TT{void} is \TT{0}.
There is \underline{no} default declaration.
\end{indpar}

{\tt function unsadr r = $ma$\QMARK{} \ttkey{alignment of} ( type t == $T$ )}
\begin{indpar}
Returns the alignment of {\tt t}, a strictly positive integer.
The address of a value of type {\tt t} in RAM should
optimally be a multiple of the alignment.
The alignment of builtin types is their size.
For defined and enumeration types it is the alignment of their underlying type.
There is \underline{no} default declaration.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{min value}} \\
{\tt function $T$ r = $ma$\QMARK{} \ttkey{max value}}
\begin{indpar}
Returns the minimum or maximum value of a type $T$.
These are defined only for number types and enumeration types,
and for enumeration types the values returned are the limits of
the type's {\em enum-range}.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{min unassigned value}} \\
{\tt function $T$ r = $ma$\QMARK{} \ttkey{max unassigned value}}
\begin{indpar}
Returns the minimum or maximum values not yet assigned to an
enumeration type $T$ by an {\em enum-assignment}.  Values
assigned by unchecked conversions are not considered.  If
no values have been assigned, the enumeration value corresponding
to {\em first-enum} is returned by `\TT{min unassigned value}'
and the enumeration value corresponding
to {\em last-enum} is returned by `\TT{max unassigned value}'.

These are defined only for enumeration types,

These values may change when more code is compiled or initialized.
You may only assume that constants of type $T$ whose values have
already been compiled or initialized are within
ranges bounded by these values, i.e., in the ranges:
\begin{center}
{\tt [ min value, min unassigned value )} \\
{\tt ( max unassigned value, max value ]}
\end{center}
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{missing value}}
\begin{indpar}
Returns a suitable missing value for type $T$.
Defined to return the largest possible value for builtin unsigned
integer types, the smallest (most negative) possible value for
builtin signed integer types, and \TT{NaN} for builtin
floating point number types.
May be defined by user for defined types.
\end{indpar}

{\tt function $T$ r = $ma$\QMARK{} \ttkey{default value}}
\begin{indpar}
Returns a suitable default value for type $T$.
Defined to return \TT{0} for builtin number types.
May be defined by user for defined types.  For use by allocators,
such as a user defined function that allocates a vector whose
elements are of type $T$, and the function wishes to give the elements an
initial default value.
\end{indpar}

\end{indpar}

The following function differs from the above in that it
consults an internal compiler database and does not depend
on multiple function declarations with specified argument values:

\begin{indpar}

{\tt function bool r = std ( type T1 ) "\ttkey{>}" ( type T2 )}
\begin{indpar}
Returns \TT{true} if and only if {\tt T1$\CNV$T2}, that is, values
of type {\tt T1} can be implicitly converted to values of type {\tt T2}
(see \pagref{CONVERSION-RELATION}).
\end{indpar}

\end{indpar}

\subsection{The Character Type}
\label{THE-CHARACTER-TYPE}

A `\key{character}' is a 32-bit UNICODE character.  It is
defined as the derived type:
\begin{indpar} \tt
define type~\ttkey{std character}~as uns32 \\
\ttkey{character}~\ABV~`std character'
\end{indpar}

A character constant has the syntax:
\begin{indpar}
\emkey{character-constant}\label{CHARACTER-CONSTANT}
    :::= \TT{C"}{\em character-representative}\TT{"} \\
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}

This constant has type \TT{character} and value equal to the
single character represented.

The following functions are builtin:

\begin{indpar}

{\tt function character r = std \ttkey{character} ( uns32 c )}
\begin{indpar}
Returns the character with UNICODE character code equal to {\tt c}.
No check is made that {\tt c} is a legal UNICODE character code
or is non-zero.
\end{indpar}

{\tt function uns32 r = std \ttkey{code} ( character c )}
\begin{indpar}
Returns the UNICODE character code of the character {\tt c}.
\end{indpar}

{\tt function uns32 r = std \ttmkey{implied conversion}{of character}
		( character c )}
\begin{indpar}
Implied conversion (\pagref{IMPLIED-CONVERSION})
of character {\tt c} to its UNICODE character code.

Because of this implied conversion,
characters can be compared using \TT{<}, \TT{<=}, \TT{==},
\TT{!=}, \TT{>=}, or \TT{>}.
\end{indpar}

{\tt function character r = std \ttmkey{NUL}{character value}}
\begin{indpar}
Returns \TT{C"<0>"},
the character with UNICODE code \TT{0} that is conventionally
used to represent the missing \TT{character} value.
\end{indpar}

\end{indpar}

\subsection{The String Type}
\label{THE-STRING-TYPE}

A `\key{string}' is a vector of characters, that is,
of 32-bit UNICODE characters.
It is defined as a derived type:
\begin{indpar} \tt
define type \ttkey{std string} as adr \\
\ttkey{string} \ABV{} `std string'
\end{indpar}

A {\em quoted-string} lexeme is a constant of \TT{string} type
whose characters are those represented by the lexeme with
the addition of a \TT{NUL} character (code \TT{0}) at the end:
\begin{indpar}
\emkey{string-constant}\label{STRING-CONSTANT}
    :::= \TT{"}{\em character-representative}\TT{"} \\
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}


Strings are read-only, and their characters cannot be changed.

String variables and values are implemented at compile-time.
The following are compile-time functions involving strings:

\begin{indpar}

{\tt function string r =
    std \ttmkey{string}{of character} ( character c )}
\begin{indpar}
Returns the string containing the single character {\tt c}.
\end{indpar}

{\tt function string r =
    std \ttmkey{string}{of integer} ( intmax i )}
\begin{indpar}
Returns the string that is the decimal integer representation of
the integer {\tt i}.  The value returned contains no high order
zeros or commas.  Non-negative values have no sign.
\end{indpar}

{\tt function string r =
    std ( string s1 ) "\ttmkey{+}{of strings}" ( string s2 )}
\begin{indpar}
Returns the concatenation of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function bool r =
    std ( string s1 ) "\ttmkey{<}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{<=}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{==}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{!=}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{>=}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{>}{of strings}" ( string s2 )}
\begin{indpar}
Returns whether {\tt s1} is less than, less than or equal to,
equal to, not equal to, greater than or equal to, or greater than
{\tt s2}.  Ordering of strings is lexical (note ordering of
characters is by character code).
\end{indpar}

{\tt function string r = std \ttmkey{null}{string value}}
\begin{indpar}
Returns a particular zero length \TT{string} that is conventionally
used to represent the missing \TT{string} value.
Although the string is of zero length, it does have one character:
the \TT{NUL} character at its end.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{string} ( string s )}
\begin{indpar}
Returns the length of {\tt s}, the number of characters in {\tt s}
\underline{not counting} the \TT{NUL} character at the end.
\end{indpar}

{\tt function character r = std ( string s ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st character of {\tt s}.

It is a programming error if {\tt i > length of ( s )}.

If {\tt i == length of ( s )}
the \TT{NUL} at the end of the string is returned.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time string
variables.  If an implementation does
not implement run-time string variables,
string values computed at compile-time may
not be garbage collectible during the compilation.

\subsection{The Name Type}
\label{THE-NAME-TYPE}

A `\key{name}' value is a vector of strings.  If the value is
a legal name as defined in Section~\itemref{NAMES}, the
strings are its {\em name-items} with a \TT{null} string appended.
Note that {\em natural-number} {\em name-items} are represented
by strings of digits and not by integers.

An element of a name value may be any string, so name values
may not be legal source code {\em names} as defined on \pagref{NAME}.
When a name value is used as a {\em name} in a compilation,
it is a compilation error if the value is not a source code {\em name}.

The \TT{name} type is is defined as a derived type:
\begin{indpar} \tt
define type \ttkey{std name} as adr \\
\ttkey{name} \ABV{} `std name'
\end{indpar}

A sequence of {\em name-items} in \TT{`~'} quotes is a \TT{name}
constant whose strings are the {\em name-items}
with the \TT{null} string appended:
\begin{indpar}
\emkey{name-constant}\label{NAME-CONSTANT}
    ::= \TT{`}{\em name-item}\STAR{}\TT{'} \\
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

Name values are read-only, and their elements cannot be changed.

Name variables and values are implemented at compile-time.
The following are compile-time functions involving names:

\begin{indpar}

{\tt function name r = \ttmkey{name}{of string} ( string s )}
\begin{indpar}
Returns the name containing just {\tt s} as its only {\em name-item}.
A \TT{null} is appended to the end of the name.
No check is made that {\tt s} is a legal {\em name-item}.
\end{indpar}

{\tt function name r = ( name n1 ) "\ttmkey{+}{of names}" ( name n2 )}
\begin{indpar}
Returns the concatenation of {\tt n1} and {\tt n2}.
\end{indpar}

{\tt function bool r = ( name n1 ) "\ttmkey{<}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{<=}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{==}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{!=}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{>=}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{>}{of names}" ( name n2 )}
\begin{indpar}
Returns whether {\tt n1} is less than, less than or equal to,
equal to, not equal to, greater than or equal to, or greater than
{\tt n2}.  Ordering of names is lexical.
\end{indpar}

{\tt function name r = std \ttmkey{null}{name value}}
\begin{indpar}
Returns a particular zero length \TT{name} that is conventionally
used to represent the missing \TT{name} value.
Although the name is of zero length, it does have one string,
the \TT{null} string at its end.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{name} ( name n )}
\begin{indpar}
Returns the length of {\tt n}, the number of strings in {\tt n}
\underline{not counting} the \TT{null} string at the end.
\end{indpar}

{\tt function string r = std ( name n ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st string of {\tt n}.

It is a programming error if {\tt i > length of ( n )}.

If {\tt i == length of ( n )}
the \TT{null} at the end of the name is returned.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time name
variables.  If an implementation does
not implement run-time name variables,
name values computed at compile-time may
not be garbage collectible during the compilation.

\subsection{Name Sets and Lists}
\label{NAME-SETS-AND-LISTS}

A \key{name set} is a set of names.
A \key{name list} is a list of names.  The syntax
for name set and list constants is:
\begin{indpar}
\emkey{name-set-constant}\label{NAME-SET-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{~\}} \\
    $|$ &\TT{\{} {\em name-value}
                   \{ \TT{,} {\em name-value} \}\STAR{} \TT{\}} \\
    \end{tabular} \\
\emkey{name-list-constant}\label{NAME-LIST-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{[~]} \\
    $|$ &\TT{[} {\em name-value}
                   \{ \TT{,} {\em name-value} \}\STAR{} \TT{]} \\
    \end{tabular} \\
\emkey{name-value} ::= {\em compile-time-name-expression}
\end{indpar}

The order in which names are given in a {\em name-set-constant}
does not matter, and duplicate names in the set are eliminated.
Thus
\begin{center}
`{\tt \{`X1' `X2'\} == \{`X2 `X1'\}}'\\
and\\
`{\tt \{`X1' `X1'\} == \{`X1'\}}'.
\end{center}

The order in which values are given in an {\em name-list-constant}
does matter, and duplicates are not combined.
Thus
\begin{center}
`{\tt [`X1' `X2'] != [`X2 `X1']}'\\
and\\
`{\tt [`X1' `X1'] != [`X1']}'.
\end{center}

Name set and list values are used in code expansions.
For example,
\begin{indpar}\begin{verbatim}
include for n in [`x[1]', `x[2]', `x[3]' ]:
    int n = 0
\end{verbatim}\end{indpar}

Name sets and lists can be stored in variables of the builtin name set
or list types:
\begin{indpar}
{\tt define type \ttkey{std name set} as adr} \\
{\tt define type \ttkey{std name list} as adr} \\
{\tt \ttkey{name set} -{}-{}-> `std name set'} \\
{\tt \ttkey{name list} -{}-{}-> `std name list'}
\end{indpar}

The following \TT{name set} functions are builtin:

\begin{indpar}
{\tt function name set r = std (name set s1)
                           "\ttmkey{+}{name set union}" ( name set s2 )}
\begin{indpar}
Returns the union of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function name set r = std ( name set s1 )
                           "\ttmkey{*}{name set intersection}" ( name set s2 )}
\begin{indpar}
Returns the intersection of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function name set r = std ( name set s1 )
                           "\ttmkey{-}{name set difference}" ( name set s2 )}
\begin{indpar}
Returns the set difference of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function bool r = std (name e) \ttmkey{in}{name set} ( name set s )}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the set {\tt s}, and
\TT{false} otherwise.
\end{indpar}

{\tt function name set r = std (name n)
                           "\ttmkey{+}{name set union}" ( name set s )}
\begin{indpar}
Returns union of \{{\tt n}\} and {\tt s}.
\end{indpar}

{\tt function name set r = std ( name set s )
                           "\ttmkey{+}{name set union}" (name n)}
\begin{indpar}
Returns union of \{{\tt n}\} and {\tt s}.
\end{indpar}

{\tt function name set r = std ( name set s )
                           "\ttmkey{-}{name set difference}" (name n)}
\begin{indpar}
Returns the set difference of {\tt s} and \{{\tt n}\}.
\end{indpar}

{\tt function unswrd r = std \ttmkey{size of}{name set} ( name set s )}
\begin{indpar}
Returns the size of {\tt s}, the number of names in {\tt s}.
\end{indpar}

{\tt function name r = std ( name set s ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st name of {\tt s}, where names in {\tt s}
are taken in sorted order.

It is a programming error if {\tt i >= size of ( s )}.
\end{indpar}

{\tt function name set r = std \ttkey{name set} ( name list ls )}
\begin{indpar}
Converts {\tt ls} from a list to a set, removing duplicate elements.
\end{indpar}

\end{indpar}

The following \TT{name list} functions are builtin:

\begin{indpar}
{\tt function \begin{tabular}[t]{@{}l@{}}
              name list r = \\
	      std (name list ls1)
                        "\ttmkey{+}{name list concatenation}" (name list ls2)
	      \end{tabular}}
\begin{indpar}
Returns the concatenation of {\tt ls1} and {\tt ls2}.
\end{indpar}

{\tt function \begin{tabular}[t]{@{}l@{}}
              name list r = \\
	      std (name list ls)
                        "\ttmkey{-}{name list difference}" (name set s)
	      \end{tabular}}
\begin{indpar}
Returns the list made by removing all elements from {\tt ls} that
appear anywhere in {\tt s}.
\end{indpar}

{\tt function bool r = std (name n) \ttmkey{in}{name list} (name list ls)}
\begin{indpar}
Returns \TT{true} if {\tt n} is an element of the list {\tt ls}, and
\TT{false} otherwise.
\end{indpar}

{\tt function name list r = std (name n)
                        "\ttmkey{+}{name list prepend}" (name list ls)}
\begin{indpar}
Returns the list made by prepending {\tt n} to {\tt ls}.
\end{indpar}

{\tt function name list r = std (name list ls)
                        "\ttmkey{+}{name list append}" (name n)}
\begin{indpar}
Returns the list made by appending {\tt n} to {\tt ls}.
\end{indpar}

{\tt function name list r = std (name list s)
                        "\ttmkey{-}{name list remove}" (name n)}
\begin{indpar}
Returns the list made by removing the all occurrences of
{\tt n} in {\tt ls}.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{name list} ( name list ls )}
\begin{indpar}
Returns the length of {\tt ls}, the number of names in {\tt ls}.
\end{indpar}

{\tt function name r = std ( name list ls ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st name of {\tt ls}.

It is a programming error if {\tt i >= length of ( s )}.
\end{indpar}

{\tt function name list r = std \ttkey{name list} ( name set s )}
\begin{indpar}
Converts {\tt s} from a set to a list, where elements of {\tt s}
are listed in sorted order in the result.
\end{indpar}

\end{indpar}

\subsection{Contexts}
\label{CONTEXTS}

Contexts (\pagref{CONTEXT}) exist at compile-time and can be
stored in compile-time variables.  The \TT{context} type is
defined by
\begin{indpar}
{\tt define type \ttkey{std context} as adr} \\
{\tt \ttkey{context} -{}-{}-> `std context'}
\end{indpar}

{\em Block-assignment-statements} (\itemref{BLOCK-ASSIGNMENT-STATEMENTS})
can specify a \TT{context} in which to compile the statements of
their block.

The following functions compute contexts:

\begin{indpar}

{\tt function context r = std \ttkey{current context}}
\begin{indpar}
Returns the context in effect just before
the statement containing the function call.
\end{indpar}

{\tt function context r = std \ttkey{call context}}
\begin{indpar}
Returns the context in effect just before
the statement containing the {\em function-call} that
invoked the current inline function.
\end{indpar}

{\tt function context r = std \ttkey{declaration context}}
\begin{indpar}
Returns the context in effect just before
the statement containing the {\em function-declar\-a\-tion} of
inline function whose call is currently being compiled.
\end{indpar}

\end{indpar}


\section{Qualifiers}
\label{QUALIFIERS}

Variables may be qualified by \skey{qualifier}s, which precede the
type when a variable is declared.  There are five builtin qualifiers:
\TT{mem}, \TT{*WRITABLE*}, \TT{stack}, \TT{*UNCHECKED*}, and
\TT{global}.  The first three have special effects
described in Section~\itemref{BUILTIN-QUALIFIERS}.
There is also a builtin method for defining trace qualifiers which
have special effects.
Other qualifiers that have no special effects
may be defined, and are typically used to add an
additional layer of type checking that is somewhat orthogonal to
types.

Syntactically {\em qualifier-names} immediately precede the {\em type-names}
that are before {\em variable-names}.  Some introductory examples are:
\begin{indpar}\begin{verbatim}
required qualifier fee
prohibited qualifier fie
function int32 result = F ( fee int32 value ):
    // Declares function F that computes a result of type
    // int32 from a value of type int32 and qualifier fee.
    // Requires call argument to have qualifier fee, but
    // prohibits the argument from having qualifier fie.
    //
    ... [Function body omitted] ...

// Example usage:
//
int32 x1 = ...
fee int32 x2 = ...
fie int32 x3 = ...
int32 y1 = F ( x1 )          // Illegal; x1 does not have
                             // required fee.
int32 y2 = F ( x2 )          // Legal; x2 has required fee.
int32 y3 = F ( x3 )          // Illegal; x3 has prohibited
                             // fie.
fee int32 y4 = x1            // Illegal; x1 does not have
                             // required fee.
fee int32 y5 = x2            // Legal; x2 has required fee.
int32 y6 = x3                // Illegal; x3 has prohibited
                             // fie but y6 does not.
fie int32 y7 = x3            // Legal; x3 has prohibited
                             // fie but so does y7.

protected required qualifier foo
function fo int32 result = G ( int32 value ):
    // Declares function G that computes a result of type
    // int32 from a value of type int32.  Attaches fo, which
    // is protected, to the result.
    //
    ... [Function body omitted] ...

function int32 result = H ( fo int32 value ):
    ... [Function body omitted] ...

fee int32 z1 = G ( x1 )      // Legal; z1 also acquires fo.
fee int32 z2 = H ( z1 )      // Legal; z1 has implied
                             // qualifier fo.
fo  int32 z3 = F ( x1 )      // Illegal; fo is protected, and
                             // F does not have fo on its
                             // prototype result variable.
fo  int32 z4 = G ( x1 )      // Legal; G gives z4 the
                             // protected fo qualifier so its
                             // OK for z4 to have that
                             // qualifier explicitly.

fo  int32 z5 = x1            // Illegal, x1 does NOT have
                             // protected qualifier fo.
fo  int32 z6 = y7            // Legal, y7 has protected
                             // qualifier fo.
int32 z7 = y7                // Legal, y7 has protected
                             // qualifier fo, so z7
                             // acquires fo.
\end{verbatim}\end{indpar}

The qualifiers may be declared by:
\begin{indpar}
\emkey{qualifier-declaration}\label{QUALIFIER-DECLARATION} \\
\hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define} {\em qualifier-attribute}\PLUS{} \ttkey{qualifier}
           {\em defined-qualifier-name} \\
    $|$ & {\em trace-qualifier-declaration}
    	  ~~~ [see \pagref{TRACE-QUALIFIERS}]
    \end{tabular} \\
\emkey{qualifier-attribute}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{value} \\
    $|$ & \ttkey{variable} \\
    $|$ & \ttkey{protected} \\
    $|$ & \ttkey{required} \\
    $|$ & \ttkey{prohibited} \\
    \end{tabular} \\
\emkey{defined-qualifier-name} ::= {\em qualifier-name} \\
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME}

where
\begin{enumerate}
\item
No {\em qualifier-name} may be a prefix of
any {\em type-name},
any {\em deferred-variable} (\pagref{DEFERRED-VARIABLE})
or any {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME}).
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.
\item
No qualifier name may begin with `\TT{next}'
or `\TT{previous}'.
\end{enumerate}
\end{indpar}

The builtin qualifiers are in effect declared by:
\begin{indpar}
{\tt protected variable qualifier~}\ttkey{mem} \\
{\tt protected variable qualifier~}\ttkey{*WRITABLE*} \\
{\tt prohibited protected value qualifier~}\ttkey{stack} \\
{\tt required variable qualifier~}\ttkey{*UNCHECKED*} \\
{\tt protected value qualifier~}\ttkey{global}
\end{indpar}

Each qualifier is associated with a unique enumeration value,
and this value can be used at both
compile and run time to test whether two `\TT{qualifier}'s are
equal.
The type `\TT{qualifier}' is a builtin enumeration type declared
by:
\begin{indpar} \tt
define type \ttkey{std qualifier} as unswrd with enum [0~..] \\
qualifier \ttkey{std missing qualifier} = next enum // 0 \\
function std qualifier r = std \ttmkey{missing}{qualifier}: \\
\hspace*{3em}r = std missing qualifier \\
\ttkey{qualifier} \ABV{} `std qualifier'
\end{indpar}

The {\em qualifier-name} of a qualifier
can be used (1) before a {\em type-name}
in a declaration, (2) as the name of an enumeration value in an
expression, or (3) as the name of a function in a {\em function-call}.

A `\key{variable qualifier}' qualifies variables but not values.
If $Q$ is a variable qualifier attached to a variable {\tt v}, $Q$
does \underline{not} follow the value of {\tt v} when that value
is copied to another variable.

A `\key{value qualifier}' qualifies values, although the qualifier
is attached to variables that hold these values.
If $Q$ is a value qualifier attached to a variable {\tt v}, $Q$
\underline{may} follow the value of {\tt v} to another variable
when that value is copied to that other variable.

A qualifier must be a variable qualifier or a value qualifier,
but can not be both.

A qualifier can be attached to any result variable by including
the qualifier in the source code
declaration of that variable.  More specifically it may be attached
to assignment statement or function prototype result variables.
But a value qualifier, but not a variable qualifier,
may be attached to a prototype argument variable.

A `\key{protected qualifier}' can be attached in source code
to an assignment result variable only if the assignment statement
takes the form of a function call and the assignment statement
result variable
matches a prototype result variable that has the qualifier.  Furthermore,
in this case, if the qualifier is not explicitly encoded for the
assignment statement result variable, it will be automatically added
to that variable.

This is the only way to attach a `\key{protected variable qualifier}'
to a variable.  However, as described below, protected value qualifiers
may also be propagated by copying operations.

A `\key{required variable qualifier}' \underline{must} be attached
to an assignment result variable if the assignment statement
takes the form of a function call and the assignment statement
result variable
matches a prototype result variable that has the qualifier.
If the qualifier is also \TT{protected} it will be automatically
attached to the assignment result variable, but otherwise it must
be written into the source code.

A `\key{prohibited variable qualifier}' \underline{must not}
be attached in code to an assignment result variable
if the assignment statement
takes the form of a function call and the assignment statement
result variable
matches a prototype result variable that \underline{does not have}
the qualifier.

Some examples involving builtin variable qualifiers are:
\begin{indpar}\begin{verbatim}
// Builtin declarations:
//     protected variable qualifier mem
//     required variable qualifier *UNCHECKED*

// Function to read the int32 value at RAM address A.
// Not type safe as argument A not vetted.
//
function mem int32 r, adr r.adr = read ( adr A ):
    r.adr = A
mem int32 x = read (1000)
    // Creates variable adr x.adr = 1000.  The mem variable
    // qualifier is special: x is not given a value by
    // assignment, but automatically gets its value by
    // reading location x.adr.
int32 y = read(2000)
    // Ditto but mem qualifier is automatically added to y.
int32 z = x
    // The mem variable qualifier on x is NOT propagated
    // to z.

*UNCHECKED* uns32 w = uns32 ( z )
    // *UNCHECKED* is a require variable qualifier and must
    // be written into code.  It is required to be on the
    // result variable of an unchecked conversion from
    // int32 to uns32 that just changes the type of the
    // 32 bit value without changing the value.
uns32 v = w
    // The *UNCHECKED* variable qualifier on w is NOT
    // propagated to v.
\end{verbatim}\end{indpar}

A call to {\tt read} returns a cluster of
two variables, with only the root {\tt r} of the cluster being
specified explicitly by the call, and the child {\tt r.adr} being
created implicitly by the call: see \itemref{CLUSTERS}.
The {\tt mem} qualifier has the special property that a value of a {\tt mem}
variable {\tt r} is not given explicitly, but is read implicitly from
RAM memory using the address in {\tt r.adr}: see \itemref{THE-MEM-QUALIFIER}.
As a protected variable qualifier, {\tt mem} can only be attached to
a variable by making the variable a result variable of an inline
function call.

The rules for value qualifiers differ from those for variable
qualifiers in that they involve variable copying operations.

Values may be copies from one variable to another by any of
three different kinds of assignments:
\begin{center}
\begin{tabular}{l@{~~~~~}p{4.0in}}
\tt v = w		& Copy {\tt w} to assignment statement
                          result variable {\tt v}. \\
\tt w $\Rightarrow$ v	& Copy {\tt w} to call argument variable {\tt v}. \\
\tt v $\Leftarrow$ w	& Copy {\tt w} to call result variable {\tt v}. \\
\end{tabular}
\end{center}

The second two kinds of assignments are generated by the compiler when it
matches a function or generic call to a prototype
(\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}),
and cannot
be represented explicitly in source code.  All three
kinds of assignments may include implied conversion of the value being
copied.  These kinds of assignments differ in their behavior with
respect to value qualifiers.

If a `\key{protected value qualifier}' $Q$ is attached to the source of
a copy to an assignment result variable or copy to call result variable,
then $Q$ may be attached in source code to the destination variable, and if not
so attached, will be automatically attached.  However $Q$ will \underline{not}
be automatically attached to the destination of
a copy to call argument variable.

If a `\key{required value qualifier}' $Q$ is attached to the destination of
a copy (either explicitly in source code or automatically),
it must be attached to the source.
If this rule is violated for copy to
call argument variable or copy to call result variable, the call-to-prototype
match that generated these copies fails.

If a `\key{prohibited value qualifier}' $Q$ is \underline{not}
attached to the destination of
a copy, it must not be attached to the source.
If this rule is violated for copy to
call argument variable or copy to call result variable, the call-to-prototype
match that generated these copies fails.

Some examples involving the \TT{stack} prohibited protected value
qualifier are:
\begin{indpar}\begin{verbatim}
// Builtin declaration:
//     protected prohibited value qualifier stack
//
// Assume:
//    function *UNCHECKED* stack adr r = allocate to stack
//                                         ( unswrd size )
//        // Actual allocate to stack function returns more
//        // complex cluster.
//
*UNCHECKED* adr address of x =
               allocate to stack ( size of int32 )
    // address of x is automatically given the `stack'
    // qualifier.

function mem int32 r, adr r.adr = read ( adr A ):
    r.adr = A
function mem int32 r, adr r.adr = read from stack
                                    ( stack adr A ):
    r.adr = A

int32 x1 = read ( address of x )
    // Compiler error: `read' prototype argument does not
    // have prohibited `stack' qualifier call argument has.
int32 x2 = read from stack ( address of x )
    // Legal: `read from stack' prototype and call
    // arguments both have `stack' qualifier.
\end{verbatim}\end{indpar}

\section{Expressions}
\label{EXPRESSIONS}

Expressions compute values and appear inside statements where a value is needed.
For example, in a {\em simple-assignment-statement} of the form
\begin{indpar}
{\em qualifier-name}\STAR{} ~ {\em type-name} ~ {\em variable-name}
	~ {\tt =} ~ {\em expression}
\end{indpar}
the {\em expression} computes a value to store in the variable.

The parser parses {\em expressions} and converts code into statements
that have no {\em expressions} except for {\em variable-names}
and for {\em function-calls} in statements of the form
\begin{indpar}
\ldots{} ~ {\tt =} ~{\em function-call}
\end{indpar}
where \ldots{} is an optional list of result variables for the
{\em function-call}.

\subsection{Variable Names}

A {\em variable-name} names a variable that is allocated to
the current function frame by an {\em assignment-statement}.
The syntax is:

\begin{indpar}
\emkey{variable-name}
	::= {\em variable-base-name} {\em member-selector}\STAR{} \\
\emkey{variable-base-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript } \\
\emkey{member-name}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark}
			    or {\em quoted-separator}
			\end{tabular} \\
\emkey{member-subscript}\label{MEMBER-SUBSCRIPT}
    ::= {\em enum-list-constant} \\
{\em enum-list-constant} ::= see \pagref{ENUM-LIST-CONSTANT} \\
{\em name} ::= see \pagref{NAME}
\end{indpar}

Some examples that use {\em member-subscripts} are:\label{SLICE}
\begin{indpar}\begin{verbatim}
uns8 string[0 .. 5] = .....   // Allocate slice.
..... string[0] .....         // Read one variable of slice.
..... string[1 .. 5] .....    // Read subslice of slice.
..... string[0 .. 3] .....    // Read a different subslice.
\end{verbatim}\end{indpar}

One can also assemble slices into a larger slice.  For example:
\begin{indpar}\begin{verbatim}
float64 m[0 .. 1, 0 .. 1 ] = .....   // Allocate slice.
float64 m[2 .. 6, 0 .. 1 ] = .....   // Allocate slice.
float64 m[0 .. 6, 2 .. 4 ] = .....   // Allocate slice.
..... m[0 .. 6, 0 .. 4] .....        // Read assembled slice.
\end{verbatim}\end{indpar}

\subsection{Expression Syntax}
\label{EXPRESSION-SYNTAX}

The operators that can appear in an expression in approximate
precedence order (lowest precedence topmost) are:

\begin{center}

\begin{tabular}{c}
\TT{if ~ else} \\
selection operators
\end{tabular}

\medskip

\begin{tabular}{c}
\TT{and ~ or} \\
\TT{not} \\
logical operators
\end{tabular}

\medskip

\begin{tabular}{c}
\TT{== ~ != ~ > ~ >= ~ < ~ <=} \\
comparison operators
\end{tabular}

\medskip

\begin{tabular}[t]{c}
\TT{+ ~ -} \\
summation operators
\\[2ex]
\TT{* ~ / ~ div ~ mod ~ rem } \\
product operators
\\[2ex]
\TT{\textasciicircum} \\
exponent operator
\end{tabular}
~~~~~
\begin{tabular}[t]{c}
\TT{\& ~ | ~ xor ~ <{}< ~ >{}>} \\
\TT{!} \\
bitwise operators
\end{tabular}

\end{center}

\begin{indpar}

However precedence is only a rough guide to the syntax of L-Language
operators.  Also unary \TT{+} and \TT{-} operators have the
same precedence as the binary \TT{+} and\TT{-} operators.

Two operators are said to be mixed in an expression if neither is
inside a parenthesized subexpression that does not contain the other.
The logical operators other than `\TT{not}' cannot be mixed with
each other, and similarly for the product operators and the
bitwise operators other than \TT{!} (bitwise complement).  Bitwise
operators cannot be mixed with summation and product operators.

The precise syntax of expressions is:

\emkey{expression}\label{EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em selection-expression} \\
    $|$ & {\em logical-expression} \\
    $|$ & {\em comparison-expression} \\
    $|$ & {\em bitop-expression} \\
    $|$ & {\em summation-expression} \\
    $|$ & {\em product-expression} \\
    $|$ & {\em exponent-expression} \\
    $|$ & {\em mark-expression} \\
    $|$ & {\em subexpression} \\
    $|$ & {\em primary} \\
    \end{tabular}
\\[0.5ex]
\emkey{selection-expression}\label{SELECTION-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em selection-operand} \TT{if} {\em logical-expression} \TT{else} \\
	& ~~~~~ \{ {\em selection-operand} \TT{if} {\em logical-expression}
	           \TT{else} \}\STAR{} \\
	& ~~~~~ {\em selection-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{selection-operand}\label{SELECTION-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-expression} $|$ {\em summation-expression}
                                 $|$ {\em product-expression} \\
    $|$ & {\em exponent-expression} $|$ {\em mark-expression} \\
    $|$ & {\em subexpression} $|$ {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{logical-expression}\label{LOGICAL-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & \TT{not}\QMARK{} ~  {\em logical-operand} \\
    $|$ & \TT{not}\QMARK{} ~ {\em logical-operand}
         \{ \TT{and} ~ \TT{not}\QMARK{} ~ {\em logical-operand} \}\PLUS{} \\
    $|$ & \TT{not}\QMARK{} ~ {\em logical-operand}
         \{ \TT{or} ~ \TT{not}\QMARK{} ~ {\em logical-operand} \}\PLUS{} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-operand}\label{LOGICAL-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em comparison-expression} $|$ {\em subexpression} \\
    $|$ & {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{comparison-expression}\label{COMPARISON-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em comparison-operand}
	  \{ {\em comparison-operator} ~ {\em comparison-operand} \}\PLUS{} \\
    \end{tabular}
\\[0.5ex]
\emkey{comparison-operator}\label{COMPARISON-OPERATOR} ::=
    \TT{==} $|$ \TT{!=} $|$ \TT{>} $|$ \TT{>=} $|$ \TT{<} $|$ \TT{<=}
\\[0.5ex]
\emkey{comparison-operand}\label{COMPARISON-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-expression} $|$ {\em summation-expression}
                                 $|$ {\em product-expression} \\
    $|$ & {\em exponent-expression} $|$ {\em mark-expression} \\
    $|$ & {\em subexpression} $|$ {\em primary}
    \end{tabular}
\\[0.5ex]
\emkey{bitop-expression}\label{BITOP-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & \TT{!} {\em bitop-operand} \\
    $|$ & \TT{!}\QMARK{} ~ {\em bitop-operand}
         \{ \TT{\&} ~ \TT{!}\QMARK{} ~ {\em bitop-operand} \}\PLUS{} \\
    $|$ & \TT{!}\QMARK{} ~ {\em bitop-operand}
         \{ \TT{|} ~ \TT{!}\QMARK{} ~ {\em bitop-operand} \}\PLUS{} \\
    $|$ & \TT{!}\QMARK{} ~ {\em bitop-operand}
         \{ \TT{xor}
	    ~ \TT{!}\QMARK{} ~ {\em bitop-operand} \}\PLUS{} \\
    $|$ & {\em bitop-operand}
         \{ {\em shift-operator} ~ {\em bitop-operand} \}\PLUS{} \\
    \end{tabular}
\\[0.5ex]
\emkey{shift-operator}\label{SHIFT-OPERATOR} ::= \TT{<{}<} $|$ \TT{>{}>}
\\[0.5ex]
\emkey{bitop-operand}\label{BITOP-OPERAND} ::=
    {\em mark-expression} $|$ {\em subexpression} $|$ {\em primary}
\\[0.5ex]
\emkey{summation-expression}\label{SUMMATION-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em sign}\QMARK{} ~  {\em summation-operand} ~
         \{ {\em sign} ~ {\em summation-operand} \}\PLUS{} \\
    $|$ & {\em sign} ~ {\em summation-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{sign}\label{SIGN} ::= \TT{+} $|$ \TT{-}
\\[0.5ex]
\emkey{summation-operand}\label{SUMMATION-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em product-expression} $|$ {\em exponent-expression}
                                   $|$ {\em mark-expression} \\
    $|$ & {\em subexpression} $|$ {\em primary} \\
    \end{tabular}
\\[0.5ex]
\emkey{product-expression}\label{PRODUCT-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em product-operand} ~ \{ \TT{*} ~ {\em product-operand} \}\PLUS{} \\
    $|$ & {\em product-operand} ~ \TT{/} ~ {\em product-operand} \\
    $|$ & {\em product-operand} ~ \TT{div} ~ {\em product-operand} \\
    $|$ & {\em product-operand} ~ \TT{mod} ~ {\em product-operand} \\
    $|$ & {\em product-operand} ~ \TT{rem} ~ {\em product-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{product-operand}\label{PRODUCT-OPERAND} ::=
    {\em exponent-expression} $|$ {\em mark-expression} $|$
    {\em subexpression} $|$ {\em primary}
\\[0.5ex]
\emkey{exponent-expression}\label{EXPONENT-EXPRESSION}
    ::= {\em exponent-operand} ~ \TT{\textasciicircum} ~ {\em exponent-operand}
\\[0.5ex]
\emkey{exponent-operand}\label{EXPONENT-OPERAND} ::=
    {\em mark-expression} $|$ {\em subexpression} $|$ {\em primary}
\\[0.5ex]
\emkey{mark-expression}\label{MARK-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & \{ {\em mark-operand} ~ {\em mark-operator} \}\PLUS{}
	  {\em mark-operand}\QMARK{} \\
    $|$ & \{ {\em mark-operator} ~ {\em mark-operand} \}\PLUS{}
	  {\em mark-operator}\QMARK{} \\
    \end{tabular}
\\[0.5ex]
\emkey{mark-operator}\label{MARK-OPERATOR} ::=
    {\em mark} that is not otherwise mentioned in these syntax equations
\\[0.5ex]
\emkey{mark-operand}\label{MARK-OPERAND} ::=
    {\em subexpression} $|$ {\em primary}
\\[0.5ex]
\emkey{subexpression}
    \begin{tabular}[t]{rl}
    ::= & {\em module-abbreviation} ~ \TT{(} {\em expression} \TT{)} \\
    $|$ & \TT{(} {\em expression} \TT{)} \\
    \end{tabular}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
\emkey{primary}\label{PRIMARY}
    \begin{tabular}[t]{rl}
    ::= & {\em argument-list}\STAR{}
	      \begin{tabular}[t]{l}
	      {\em primary-item}\PLUS{}\\
	      \{ {\em argument-list}\PLUS{}
		 {\em primary-item}\PLUS{} \}\STAR{} \\
	      {\em argument-list}\STAR{} \\
	      \end{tabular} \\
    $|$ & {\em argument-list} {\em argument-list}\PLUS{} \\
    $|$ & {\em bracketed-constant}
    \end{tabular}
\\[0.5ex]
\emkey{primary-item}\label{PRIMARY-ITEM}
    ::= {\em word} $|$ {\em number} $|$ {\em quoted-string}
\\[0.5ex]
\emkey{argument-list}\label{ARGUMENT-LIST}
    \begin{tabular}[t]{rl}
    ::= & \TT{( )} \\
    $|$ & \TT{(} {\em expression} \{ \TT{,} {\em expression} \}\STAR{} \TT{)} \\
    $|$ & \TT{[ ]} \\
    $|$ & \TT{[} {\em expression} \{ \TT{,} {\em expression} \}\STAR{} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{bracketed-constant}\label{BRACKETED-CONSTANT}
    \begin{tabular}[t]{rl}
    ::= & \TT{[ ]} \\
    $|$ & \TT{[} {\em range}
          \{ \TT{,} {\em range} \}\STAR{} \TT{]} \\
    $|$ & \TT{\{ \}} \\
    $|$ & \TT{\{} {\em range}
          \{ \TT{,} {\em range} \}\STAR{} \TT{\}} \\
    $|$ & \TT{`} {\em name-item}\STAR{} \TT{'}
    \end{tabular}
\\[0.5ex]
\emkey{range}\label{RANGE}
    \begin{tabular}[t]{rl}
    ::= & {\em expression} \\
    $|$ & {\em expression} \TT{..} {\em expression} \\
    $|$ & {\em expression} \TT{..} \\
    $|$ & \TT{..} {\em expression} \\
    \end{tabular}
\end{indpar}

Note that strictly binary operators such as \TT{mod} can also
be used as function names in {\em primaries}, as in
\begin{center}
{\tt uns8 x = mod ( 257 )}
\end{center}

It is the compiler, and not the parser, that analyzes {\em primaries},
because knowledge of the {\em names} in scope is required.  To the
compiler, a {\em primary} has the following syntax:
\begin{indpar}
\emkey{primary}\label{COMPILER-PRIMARY}
    \begin{tabular}[t]{rl@{\hspace*{0.4in}}l}
    ::= & {\em constant} \\
    $|$ & {\em variable-name} 		& [see \pagref{VARIABLE-NAME}] \\
    $|$ & {\em variable-declaration} \\
    $|$ & {\em qualifier-conversion} \\
    $|$ & {\em type-conversion} \\
    $|$ & {\em function-call}		& [see \pagref{FUNCTION-CALL}] \\
    \end{tabular}
\\[0.5ex]
\emkey{constant}\label{CONSTANT}
    \begin{tabular}[t]{rl@{\hspace*{0.5in}}l}
    ::= & {\em number-constant} 	& [see \pagref{NUMBER-CONSTANT}] \\
    $|$ & {\em character-constant} 	& [see \pagref{CHARACTER-CONSTANT}]  \\
    $|$ & {\em string-constant} 	& [see \pagref{STRING-CONSTANT}]  \\
    $|$ & {\em name-constant} 		& [see \pagref{NAME-CONSTANT}]  \\
    $|$ & {\em enum-set-constant}	& [see \pagref{ENUM-SET-CONSTANT}]  \\
    $|$ & {\em enum-list-constant}	& [see \pagref{ENUM-LIST-CONSTANT}]  \\
    $|$ & {\em name-set-constant}	& [see \pagref{NAME-SET-CONSTANT}]  \\
    $|$ & {\em name-list-constant}	& [see \pagref{NAME-LIST-CONSTANT}]  \\
    \end{tabular}
\\[0.5ex]
\emkey{variable-declaration} ::= {\em qualifier-name}\STAR{}
                                 {\em type-name} {\em variable-name}
\\[0.5ex]
\emkey{qualifier-conversion}
    ::= {\em qualifier-name}\PLUS{} \TT{(} {\em expression} \TT{)}
\\[0.5ex]
\emkey{type-conversion}
    ::= {\em qualifier-name}\STAR{} {\em type-name}
        \TT{(} {\em expression} \TT{)}
\end{indpar}

If the {\em primary} is not a {\em constant}, the compiler
checks the scope to see if it is a {\em variable-declaration},
{\em variable-name}, {\em qualifier-conversion}, or
{\em type-conversion}.  If it is none of these, the
compiler applies the {\em function-call} matching rules of
\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}
to match the {\em primary} to a {\em function-prototype}.

\subsection{Expression Semantics}

Expressions provide standard operators.  Expressions are compiled
into function calls, and builtin functions
implement logical and numeric operators.

\subsubsection{Expression Typing}
\label{EXPRESSION-TYPING}

L-Language uses a top-down method of assigning types to operator arguments.
Generally given the statement
\begin{center}
$T$ $v$ ~ \TT{=} ~ $e1$ ~ $op1$ ~ $e2$ ~ $op2$ ~ \ldots{}
\end{center}
where $T$ is a type of a variable $v$, where $e1$, $e2$, \ldots{} are
subexpressions, and where $op1$, $op2$, \ldots{} are operators with the
same precedence (e.g., all are either \TT{+} or \TT{-}), then
all the subexpression values are implicitly converted to type $T$
before the operations are done.  Here $T$ is called the `\key{target type}'
of the expressions $e1$, $e2$, \ldots{}.

An example is:

\begin{indpar}\begin{verbatim}
float64 w = 1.5
int64 x = 9,568
uns64 y1 = 0xFF00
uns32 y2 = 0xFF00
int64 z1 = x + y1
    // Compile error:
    //     y1 is not implicitly convertible to int64
int64 z2 = x + y2
    // OK, y2 IS implicitly convertible to int64
int64 z3 = x + y2 * w
    // Compile error:
    //     Target type of y2 * w is int64,
    //     hence target type of y2 is int64 with is OK,
    //     and target type of w is int64, but w is not
    //     implicitly convertible to int64
\end{verbatim}\end{indpar}

The target type of an expression is usually provided by the
type of the variable being set by an assignment statement, or in the
case of function arguments, by the argument type specified in the
function prototype.

The target type of a {\em logical-expression} or a {\em comparison-expression}
is \TT{bool}.

In some cases the target type is specified by special rules.  The
target type of {\em comparison-operands} is specified by special
rules given in \itemref{COMPARISON-EXPRESSIONS}.

Some special rules
make use of the `\key{natural type}'\label{NATURAL-TYPE}
that some subexpressions have.
The natural type of a variable is its type.
The natural type of an expression of the
form `\TT{$Qs$ $T$ ( \ldots{} )}' where $Qs$ is a list of qualifiers
and $T$ is a type name is $T$.
The natural type of a {\em function-call} is the type found by matching
the call to {\em function-prototypes}
(\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}), if an unambiguous
match can be found under the assumption that
the call has a result variable of unknown type.
No other expression has a natural type.

When an expression has a natural type, it also has natural qualifiers
that are found with the natural type.

If there is no target type because an expression is being used
as a {\em simple-assignment-statement} with no result variables, then
the expression must be a {\em function-call} and can only match
{\em function-prototypes} that have no result variables.

\subsubsection{Evaluation Order}
\label{EVALUATION-ORDER}

Where binary operators of the same precedence appear outside
parentheses in an expression, they are evaluated left to right.
That is, they are left associative.  For example,
`{\tt x <{}< s1 >{}> s2}' is
equivalent to `{\tt (x <{}< s1) >{}> s2}'.

For logical operators such as `\TT{and}', `\TT{or}', and
`\TT{\ldots{}~if~\ldots{}~else~\ldots{}}' the value of the expression
may be determined before all the operands have been evaluated.
In this case the unnecessary operands are never evaluated.
For example, if in `\TT{$e1$~and~$e2$}' the subexpression $e1$
evaluates to \TT{false}, the subexpression $e2$ is never evaluated.
Furthermore, if $e1$ evaluates at compile-time to \TT{false},
$e2$ is not even compiled, and any compile errors it contains
are not detected.  Similarly if in `\TT{$e1$~if~$b$~else~$e2$}' the
conditioning expression $b$ evaluates to \TT{true}, $e2$ is
never evaluated, and if $b$ evaluates to \TT{true} at compile
time, $e2$ is never compiled.  However all subexpressions are parsed and
parsing errors are detected.

\subsubsection{Logical Expressions}

In logical expressions the `\TT{not}' operator is moved inside
`\TT{and}' and `\TT{or}' operators before further evaluation.
Also double negations are deleted.

The target type for logical expressions is always \TT{bool}.

Logical expressions are evaluated from left to right and
if the value of the entire expression is discovered before all
the subexpressions are evaluated, evaluation of later subexpressions is
skipped, as per \itemref{EVALUATION-ORDER}.

\subsubsection{Comparison Expressions}
\label{COMPARISON-EXPRESSIONS}

The target type for comparison expressions is always \TT{bool}.

There is no given target type for operands of comparison operators.
So the target type of these must be specified by rules.

For numeric operands of comparison operators
the target type is the first type
in the following sequence that is such that all operands
can be implicitly converted to that type:
\begin{center}
\TT{unswrd} ~ \TT{intwrd} ~ \TT{unsmax} ~ \TT{intmax}
           ~ \TT{floatwrd} ~ \TT{floatmax}
\end{center}

An example assuming:


\begin{indpar}\begin{verbatim}
unswrd      is 32 bits
intwrd      is 32 bits
unsmax      is 64 bits
intmax      is 64 bits
\end{verbatim}\end{indpar}

is:

\begin{indpar}\begin{verbatim}
int64 x = 9,568
uns64 y1 = 0xFF00
uns32 y2 = 0xFF00
bool z1 = x < y1
    // Compile error:
    //     x and y1 cannot be implicitly converted
    //     to the same target type
bool z1 = x < y2
    // OK, x and y2 are implicitly convertible to
    // intmax (int64)
\end{verbatim}\end{indpar}

Non-numeric comparison operators require that one or more of
the operands have a natural type (\pagref{NATURAL-TYPE}) that
cannot be converted to one of the numeric types listed above.
In this case the target type is
the least upper bound (\pagref{LEAST-UPPER-BOUND})
of all these natural types.
It is a compile error if this least upper bound does
not exist, or if it is \TT{bool} and no operand natural type was \TT{bool}.
For example, given the expression `{\tt v == missing}', where \TT{v}
is of `\TT{qualifier}' type, {\tt missing}, which has no natural type, will be
evaluated with `\TT{qualifier}' target type.

Comparison expressions are evaluated from left to right and are
true if and only if all the comparisons are true.  Middle
arguments are shared between two comparison operators.
An example is:

\begin{indpar}\begin{verbatim}
int64 x = 9,568
uns16 y1 = 0xFF00
uns32 y2 = 0xFF01
bool z1 = x < y1 < y2
    // x, y1, y2 are all converted to int64.
    // y2 is only converted if x < y1 is true.
bool z2 = x < y1 and y1 < y2
    // y1 is converted to int64 to compare it with x
    // and then if x < y1 is true, y1 is separately
    // converted to uns32 to compare it with y2.
\end{verbatim}\end{indpar}

As per \itemref{EVALUATION-ORDER}, if a comparison evaluates
to \TT{false}, operands following those of the comparison
are not evaluated.

Note that a comparison operator may not have a negation that is
also simply a comparison operator, e.g., \TT{>=} may not be the
negation of \TT{<}.  For example, both return \TT{false} if an
operand is \TT{NaN}.  For this reason `{\tt x >= y}' and
`{\tt not ( x < y )}' are treated as semantically different
expressions.

\subsubsection{Integer Arithmetic Expressions}

If an integer arithmetic operator is being evaluated with
operand and target type \TT{uns$x$} or \TT{int$x$}, the
exact arithmetic result is computed and truncated to
$x$ bits, i.e., is taken modulo $2^x$ before being presented
as the result.

An exception to this is made for integer division operations.
If the divisor is zero, the results are undefined.  If the
target type is \TT{int$x$}, the dividend is $-2^{x-1}$, and
the divisor is $-1$, the result is undefined.  In both these
cases the result may be a program terminating error.

The bitwise operators are:
\begin{center}
\begin{tabular}{ll}
\TT{\&}		& bitwise AND \\
\TT{|}		& bitwise OR \\
\TT{xor}	& bitwise EXCLUSIVE OR \\
\TT{!}		& bitwise complement \\
\TT{<{}<}	& bitwise shift left \\
\TT{>{}>}	& bitwise shift right \\
\end{tabular}
\end{center}

In `{\tt v >{}> s}' and `{\tt v <{}< s}', {\tt v} is converted to the
target type which may be any integer type $T$, but {\tt s} is converted
to \TT{unswrd} and only its low order $x$ bits are used as the
shift amount, where $x$ is the size of $T$.
In other words, the shift amount is {\tt s mod 2$^x$}.

The integer division operators are:
\begin{center}
\begin{tabular}{ll}
\TT{div}	& quotient rounded towards zero \\
\TT{mod}	& modulo; remainder when quotient is rounded
                  toward negative infinity \\
\TT{rem}	& remainder when quotient is rounded toward zero \\
\end{tabular}
\end{center}

The operator \TT{/} is strictly floating point.  The operator
\TT{\textasciicircum} is \underline{not} builtin and must be
defined by library code.

\subsubsection{Floating Point Arithmetic Expressions}
\label{FLOATING-POINT-ARITHMETIC-EXPRESSIONS}

There is a `\key{floating point error register}' that holds
floating point error flags that may be set by floating point
arithmetic and comparison operations.  These flags are `\key{sticky}', in that
arithmetic and comparison
operations may set them but may never clear them.  There are also
special builtin functions to manipulate these flags
(\itemref{FLOATING-POINT-ERROR-FLAG-FUNCTIONS}).

The flags with the operation results when the flags are set are:
\begin{indpar}
\mkey{Invalid Operand}{floating point error flag}
\begin{indpar}
Set upon one of the following:
\begin{center}
\begin{tabular}{l}
Compare operand is a \TT{NaN}. \\
Adding \TT{+Inf} and \TT{-Inf}. \\
Subtracting \TT{+Inf} from \TT{+Inf}. \\
Subtracting \TT{-Inf} from \TT{-Inf}. \\
Multiplying \TT{0} by \TT{+Inf} or \TT{-Inf}. \\
Dividing \TT{+Inf} or \TT{-Inf} by \TT{+Inf} or \TT{-Inf}. \\
Dividing \TT{0} by \TT{0}. \\
\end{tabular}
\end{center}

Except for compares, the result is \TT{NaN}.
For compares, the result is \TT{false}.
\end{indpar}

\mkey{Divide By Zero}{floating point error flag}
\begin{indpar}
Set by a floating point division with a \TT{+0} or
\TT{-0} divisor and a non-zero dividend.

The result is \TT{+Inf} if both operands have the
same sign and \TT{-Inf} if they have opposite signs.
\end{indpar}

\mkey{Result Overflow}{floating point error flag}
\begin{indpar}
Set if result has magnitude too large to store in a target type value.

If the result is positive, \TT{+Inf} is stored, and if negative,
\TT{-Inf} is stored.
\end{indpar}

\mkey{Result Underflow}{floating point error flag}
\begin{indpar}
Set if the result is too small to be stored, even as a denormalized
number, in a target type value.

The result is stored as \TT{+0} if it is positive and as
\TT{-0} if it is negative.
\end{indpar}

\mkey{Result Inexact}{floating point error flag}
\begin{indpar}
Set if result cannot be exactly stored in a target type value.
This happens frequently and is not normally considered a
real error.

The result is rounded to the nearest value, with ties to even.
\end{indpar}
\end{indpar}

Except for compares, \TT{NaN} operands cause \TT{NaN} results and
do \underline{not} set the invalid operand flag.

Results may be denormalized numbers.  Except for compares,
when an operand to an arithmetic operation is a denormalized
number, it is treated as a signed zero.

The operator
\TT{\textasciicircum} is \underline{not} builtin and must be
defined by library code.

\subsection{Operator Semantics}

The following evaluation rules are applied in the order given.

For example, `{\tt not ( x > y and z )}' is evaluated by applying
the rule that rewrites it to `{\tt not x > y or not z}' instead of
the rules that evaluated `{\tt x > y and z}' first and then complement
the result.

Parentheses are inserted by the parser to separate operators of
differing precedence before these rules are applied.

Comparison operators, and the
arithmetic operators, summation, product, and bitwise, 
may be overloaded by functions that apply them to non-numeric
types other than \TT{bool}.
If $T$ is such a type, these functions must have prototypes
of the forms
\begin{indpar}
{\tt function bool r = ( $T$ $v1$ ) "$op$" ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of \TT{<}, \TT{<=}, \TT{==}, \TT{!=}, \TT{>=}, or \TT{>}
\end{indpar}

{\tt function $T$ r = ( $T$ $v1$ ) "$op$" ( unswrd $v2$ )}
\begin{indpar}
where $op$ is one of \TT{<{}<} or \TT{>{}>}
\end{indpar}

{\tt function $T$ r = "$op$" ( $T$ $v1$ )}
\begin{indpar}
where $op$ is one of \TT{-} or \TT{!}
\end{indpar}

{\tt function $T$ r = ( $T$ $v1$ ) "$op$" ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of
    \TT{+}, \TT{-},
    \TT{*}, \TT{/}, \TT{div}, \TT{mod}, \TT{rem}, \TT{\textasciicircum}
\end{indpar}

{\tt function $T$ r = "!"\QMARK{} ( $T$ $v1$ ) "$op$" "!"\QMARK{} ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of
    \TT{\&}, \TT{|}, \TT{xor}
\end{indpar}

\end{indpar}


The selection operator (\TT{if/else}) and the logical
operators (\TT{not}, \TT{and}, \TT{or}) may \underline{not}
be overloaded.

The expressions in the following are those output by the parser.
However to avoid clutter, parentheses are omitted surrounding
subexpressions $e$, $eI$, $b$, and $bI$, and quotes (\TT{"}) are omitted
surrounding operators.

\medskip

\TT{$e1$ if $b1$ else $e2$ if $b2$ \ldots{} else $e$}
\hfill [{\em selection-expression}]
\begin{indpar}
$b1$ is evaluated first.  If it is \TT{true}, $e1$ is evaluated and its
value is returned.  If it is \TT{false}, $e1$ is \underline{not}
evaluated, and instead $b2$ is evaluated.  If that is \TT{true}
$e2$ is evaluated and its value is returned.  But if $b2$ is \TT{false}
evaluation of the {\em selection-expression} continues.  If none of
the $bI$ evaluate to \TT{true}, $e$ is evaluated and returned as the result.

The target type of each $bI$ is \TT{bool} and the target type of each
$eI$ is the target type of the {\em selection-expression}.
Only one of the $eI$ is evaluated.

If any $bI$ is a compile time
\TT{false} value, the associated $eI$ is not compiled or checked
for compile errors.
If any $bI$ is a compile time
\TT{true} value, the subsequent $bJ$'s and their associated $eJ$'s,
and also $e$,
are not compiled or checked
for compile errors.
\end{indpar}

\TT{not ( $b1$ and $b2$ and \ldots{} )}
\hfill [{\em logical-expression}]
\begin{indpar}
The expression is replaced by
\TT{( ( not $b1$ ) or ( not $b2$ ) or \ldots{} )}.
\end{indpar}

\TT{not ( $b1$ or $b2$ or \ldots{} )}
\hfill [{\em logical-expression}]
\begin{indpar}
The expression is replaced by
\TT{( ( not $b1$ ) and ( not $b2$ ) and \ldots{} )}.
\end{indpar}

\TT{not ( not $b1$ )}
\hfill [{\em logical-expression}]
\begin{indpar}
The expression is replaced by $b1$.
\end{indpar}

\TT{$b1$ and $b2$ and \ldots{}}
\hfill [{\em logical-expression}]
\begin{indpar}
The $bI$ are evaluated left to right until one evaluates to
\TT{false} or none do.  If one evaluates to \TT{false},
\TT{false} is returned as the value of the {\em logical-expression}
and the remaining $bI$ are not evaluated.
Otherwise \TT{true} is returned.

The target type of all the $bI$ is \TT{bool}.  If any $bI$ is a
compile time \TT{false} value, the remaining $bI$ are not compiled
or checked for compile errors.
\end{indpar}

\TT{$b1$ or $b2$ or \ldots{}}
\hfill [{\em logical-expression}]
\begin{indpar}
The $bI$ are evaluated left to right until one evaluates to
\TT{true} or none do.  If one evaluates to \TT{true},
\TT{true} is returned as the value of the {\em logical-expression}
and the remaining $bI$ are not evaluated.
Otherwise \TT{false} is returned.

The target type of all the $bI$ is \TT{bool}.  If any $bI$ is a
compile time \TT{true} value, the remaining $bI$ are not compiled
or checked for compile errors.
\end{indpar}

\TT{not ( $e1$ $cop1$ $e2$ $cop2$ $e3$ \ldots{} )}
\hfill [{\em logical-expression}]
\begin{indpar}
where the $copI$ are comparison operators chosen from the list
\TT{==}, \TT{!=}, \TT{>}. \TT{>=}, \TT{<}, or \TT{<=}.

First $e1$ and $e2$ are evaluated.  Then the function
call `{\tt $e1$ "$cop1$" $e2$}'
is evaluated, and if it is \TT{false},
\TT{true} is returned as the value of the {\em logical-expression}.
Otherwise $e3$ and the function call `{\tt $e2$ "$cop2$" $e3$}'
are evaluated, and if the latter
evaluated to \TT{false},
\TT{true} is returned as the value of the {\em logical-expression}.
This continues until a comparison evaluates to \TT{false} or all
evaluate to \TT{true}.  In the latter case, \TT{false} is returned as
the value of the {\em logical-expression}.

No $eI$ is evaluated more than once, though the value of some $eI$
may be used more than once.

The target type of the expressions $eI$ is selected as
per \itemref{COMPARISON-EXPRESSIONS}.  The target type of the
function calls `{\tt $eI$ "$copI$" $e(I+1)$}' is \TT{bool}.
Builtin comparison operators are defined for all implemented
numeric types.

If $eI$, $e(I+1)$, and `{\tt $eI$ "$copI$" $e(I+1)$}' can be evaluated
at compile time and evaluate to \TT{false}, subsequent
$eJ$ are not compiled or checked for compile errors.
\end{indpar}

\TT{not $b$}
\hfill [{\em logical-expression}]
\begin{indpar}
$b$ is evaluated.  If it returns \TT{true}, \TT{false} is
returned as the value of the {\em logical-expression}.
Otherwise \TT{true} is returned.

The target type of the $b$ is \TT{bool}.
\end{indpar}

\TT{$e1$ $cop1$ $e2$ $cop2$ $e3$ \ldots{}}
\hfill [{\em comparison-expression}]
\begin{indpar}
where the $copI$ are comparison operators chosen from the list
\TT{==}, \TT{!=}, \TT{>}. \TT{>=}, \TT{<}, or \TT{<=}.

First $e1$ and $e2$ are evaluated.  Then the function call
`{\tt $e1$ "$cop1$" $e2$}'
is evaluated, and if it is \TT{false},
\TT{false} is returned as the value of the {\em comparison-expression}.
Otherwise $e3$ and the function call `{\tt $e2$ "$cop2$" $e3$}'
are evaluated, and if the latter
evaluated to \TT{false},
\TT{false} is returned as the value of the {\em comparison-expression}.
This continues until a comparison evaluates to \TT{false} or all
evaluate to \TT{true}.  In the latter case, \TT{true} is returned as
the value of the {\em comparison-expression}.

No $eI$ is evaluated more than once, though the value of some $eI$
may be used more than once.

The target type of the expressions $eI$ is selected as
per \itemref{COMPARISON-EXPRESSIONS}.  The target type of the
function calls `{\tt $eI$ "$copI$" $e(I+1)$}' is \TT{bool}.
Builtin comparison operators are defined for all implemented
numeric types.

If $eI$, $e(I+1)$, and `{\tt $eI$ "$copI$" $e(I+1)$}' can be evaluated
at compile time and evaluate to \TT{false}, subsequent
$eJ$ are not compiled or checked for compile errors.
\end{indpar}

\TT{! $e1$}
\hfill [{\em bitop-expression}] \\
\TT{$e1$ $bop$ $e2$ $bop$ $e3$ \ldots{}}
\hfill [{\em bitop-expression}]
\begin{indpar}
where the $bop$ is a bitop operator chosen from the list
\TT{\&}, \TT{|}, \TT{xor}

The $eI$ are evaluated left to right.
Each function call
`{\tt "!" $e1$}' or
`{\tt $eI$ "$bop$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators (other than \TT{!}) are
also evaluated left to right.

The target type of the $eI$ is the target type of the
{\em bitop-expression}.  Builtin bitop operators are defined
for all implemented integer numeric types.
\end{indpar}

\TT{$e1$ $shop1$ $e2$ $shop2$ $e3$ \ldots{}}
\hfill [{\em bitop-expression}]
\begin{indpar}
where the $shopI$ are bitop operators chosen from the list
\TT{<{}<}, \TT{>{}>}.

Each function call
`{\tt $eI$ "$shopI$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators are
also evaluated left to right.

The target type of $e1$ is the target type $T$ of the
{\em bitop-expression}.
The target type of $e2$, $e3$, \ldots{} is \TT{unswrd}.
Builtin bitop operators are defined
for all implemented integer numeric types $T$.
If $T$ is an integer type of size $x$,
the value of the shift for $shopI$
is $e(I+1)$ is taken modulo $2^x$.
\end{indpar}

\TT{$sop1$\QMARK{} $e1$ $sop2$ $e2$ $sop3$ $e3$ \ldots{}}
\hfill [{\em summation-expression}]
\begin{indpar}
where $sopI$ are summation operators chosen from the list
\TT{+} or \TT{-}.

The $eI$ are evaluated left to right.
Each function call
`{\tt "$sop1$" $e1$}' or
`{\tt $eI$ "$sop(I+1)$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators are
also evaluated left to right.

The target type of the $eI$ is the target type of the
{\em summation-expression}.
Builtin summation operators are defined
for all implemented numeric types $T$.
\end{indpar}

\TT{$e1$ * $e2$ * $e3$ \ldots{}}
\hfill [{\em product-expression}] \\
\TT{$e1$ $dop$ $e2$}
\hfill [{\em product-expression}]
\begin{indpar}
where the $dop$ is a divide operator chosen from the list
\TT{/}, \TT{div}, \TT{mod}, \TT{rem}.

The $eI$ are evaluated left to right.
Each function call
`{\tt "$eI$ "*" $e)I+1)$}' or
`{\tt $eI$ "$dop(I+1)$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators are
also evaluated left to right.

The target type of the $eI$ is the target type $T$ of the
{\em product-expression}.
Builtin \TT{*}, \TT{mod},
\TT{div}, and \TT{rem} operators are defined
for all implemented integer numeric types $T$ with size
at least 32 bits.
Builtin \TT{/} and \TT{mod} operators are defined
for all implemented floating point numeric types $T$.

\end{indpar}

\TT{$e1$ \textasciicircum{} $e2$}
\hfill [{\em exponential-expression}]
\begin{indpar}
The $eI$ are evaluated left to right.
The the function call
`{\tt $eI$ "\textasciicircum" $e(I+1)$}' is evaluated
as soon as its operands have
been evaluated.

The target type $T$ of the $eI$ is the target type of the
{\em exponential-expression}.  \underline{No} builtin
\TT{"\textasciicircum"} operators are defined.


\end{indpar}

\TT{$ma$ ( $e1$ $op1$ $e2$ $op2$ \ldots{} )}
\hfill [{\em subexpression}]
\label{MODULE-ABBREVIATION-SEMANTICS}
\begin{indpar}
where $ma$ is a {\em module-abbreviation}.

$ma$ is prefixed to the unparenthesized
operators whenever they are used according to the above
rules.  This is done by the parser, and not the compiler.

For example,
\begin{center}
\begin{tabular}{c}
{\tt $ma$ ( x + ( y1 + y2 ) + ( z1 * z2 ) )} \\
becomes \\
{\tt $ma$ x + ( y1 + y2 ) ) + ( z1 * z2 )}
\end{tabular}
\end{center}

Since the parser places parentheses implicitly, in `\TT{$ma$($e$)}'
only the lowest precedence operators in $e$ are affected.
Thus the pre-parser expression
\begin{center}
{\tt $ma$ ( x + ( y1 + y2 ) + z1 * z2 )} \\
\end{center}
is equivalent to the above example.

\end{indpar}

\TT{$Qs$ $T$ ( $e$ )}
\hfill [{\em primary}]
\begin{indpar}
where $Qs$ are zero or more {\em qualifier-names} and $T$ is a {\em type-name}.

If the {\em primary} can be compiled as a call to a
user defined function named $T$, it is evaluated as such with
target type `$Qs$ $T$'.

Otherwise $e$ is evaluated with target type `$Qs$ $T$'
and the result is implicitly
converted to the target type of the {\em primary}.
\end{indpar}

\section{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

Variables are allocated to the current function frame
and are also given their values by assignment statements.
After the assignment statement allocating a variable,
the value of the variable cannot be changed.  However,
a new variable of the same name can be allocated via
the `\TT{next}' construction which we describe below.

Assignment statements have the syntax:
\begin{indpar}
\emkey{assignment-statement}
    ::= \{ {\em result-variable-list} \TT{=} \}\QMARK{}
    		{\em assignment-right-side}
\\[0.5ex]
\emkey{result-variable-list}\label{RESULT-VARIABLE-LIST}
    ::= {\em result-variable}
	  \{ \TT{,} {\em result-variable} \}\STAR{}
\\[0.5ex]
\emkey{result-variable}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em result-variable-declaration} \\
    $|$ & {\em next-variable-declaration} \\
    $|$ & {\em deferred-variable}
    		& [see \pagref{DEFERRED-VARIABLE}] \\
    $|$ & {\em iteration-result-variable}
    		& [see \pagref{ITERATION-RESULT-VARIABLE}] \\
    \end{tabular}
\\[0.5ex]
\emkey{result-variable-declaration}\label{RESULT-VARIABLE-DECLARATION}
    ::= {\em qualifier-name}\STAR{}~{\em type-name}~{\em variable-name}
\\[0.5ex]
\emkey{next-variable-declaration}
    ::= \ttkey{next}~{\em variable-name}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{assignment-right-side}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em expression-list}
    		& [see \pagref{EXPRESSION-LIST}] \\
    $|$ & {\em function-call}
    		& [see \pagref{FUNCTION-CALL}] \\
    $|$ & {\em generic-call}
    		& [see \pagref{GENERIC-CALL}] \\
    $|$ & {\em block}
	        & [see kinds of assignment statement below] \\
    \end{tabular}
\end{indpar}

where the {\em assignment-right-side}
depends on the kind of assignment statement.
The kinds of assignment statements are:
\begin{indpar}
\emkey{assignment-statement}
    \begin{tabular}[t]{rll}
    ::= & {\em simple-assignment-statement}
	& \itemref{SIMPLE-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em block-assignment-statement}
	& \itemref{BLOCK-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em conditional-assignment-statement}
	& \itemref{CONDITIONAL-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em loop-assignment-statement}
	& \itemref{LOOP-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em call-assignment-statement}
	& \itemref{CALL-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em out-of-line-assignment-statement}
	& \itemref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em compile-and-run-assignment-statement}
	& \itemref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em compile-time-assignment-statement}
	& \itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em assembly-assignment-statement}
	& \itemref{ASSEMBLY-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em function-call}
	& \itemref{FUNCTION-PROTOTYPES-AND-CALLS} \\
    $|$ & {\em generic-call}
	& \itemref{GENERICS} \\
    \end{tabular}
\end{indpar}

If an {\em assignment-statement} has {\em result-variable-declarations}
that give {\em variable-names} with types and qualifiers,
these result variables are allocated to the current function frame, and
values produced by evaluating the {\em assign\-ment-right-side} are stored in
these variables.
The {\em assignment-right-side} produces a list of values,
and this list must have
at least as many elements as there are result variables.
If the {\em assignment-right-side} is a list of {\em expressions},
and not a {\em subblock},
the result variables are assigned their values in parallel, after the
{\em assignment-right-side} has been completely evaluated.
If the {\em assignment-right-side} is a {\em function-call} that produces
too many values, the excess values are discarded.  Otherwise there must
be exactly as many values as there are result variables.

When a variable value is set, the value is implicitly first
computed in a register, then stored in the current function
frame, and for some time
afterwards the value is left in the register which becomes a cache
on the frame value.  This caching is hidden from the programmer.

If a variable value is copied from another variable, usually the
new variable simply becomes a compile-time alias for the old variable.
No executable copy code is created, no new register is allocated, and no new
value is pushed into the stack.

Similarly if a variable value can be easily computed from previous variable
values by in-line code, 
its value may not be stored into the function frame.  Instead its
value can be recovered at any time by repeating the computation
of the variable from the other values.

The value assigned to each result variable must be implicitly convertible to
the variable's type.  In some cases the type of a result variable is
the target type of an {\em expression} in a {\em assignment-right-side}
that is an {\em expression-list}
(\itemref{SIMPLE-ASSIGNMENT-STATEMENTS}).
In some cases the result variable type is matched to
the type of a {\em function-prototype} result variable
for a {\em function-call} that is the {\em assignment-right-side}
(\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}).

A list of {\em assignment-statement}
result variables acts as a declaration of these variables,
and the scope of this declaration includes any {\em subblock} that may
constitute the {\em assignment-right-side}.
Result variables are not allowed to hide (\pagref{HIDE})
other {\em name} declarations with exceptions listed on
\pagref{HIDING-EXCEPTIONS}.

However, if an assignment statement has a {\em next-variable-declaration}
that uses the word `\ttkey{next}'\label{NEXT} in
place of the {\em qualifier-names} and {\em type-name}
of a result variable being assigned a value, then the named variable must
have been previously assigned a value within the same smallest containing block,
a new variable with the same qualifiers, type, and name
as that previous variable is allocated,
and the new variable supersedes that previous variable
in subsequent code within the block.  Thus if {\tt v} is the name
of a variable declared in a block, then after `{\tt next v}' is
assigned, {\tt v} refers to the value assigned to `{\tt next v}'.

See the example in \itemref{SIMPLE-ASSIGNMENT-STATEMENTS}, and
the more detailed discussion in 
\itemref{BLOCK-ASSIGNMENT-STATEMENTS}.

Note that `\TT{next}' behaves differently when it used as part of
the name of
a {\em deferred-variable} (\pagref{DEFERRED-VARIABLE})
or an {\em iteration-result-variable} (\pagref{ITERATION-RESULT-VARIABLE}).

The {\em result-variables} may be completely omitted if the
{\em assignment-right-side} is a {\em subblock}, is a
{\em function-call} matching a {\em function-prototype} that has
no result variables (\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}),
or is a {\em generic-call} (\itemref{GENERICS}).
Because such statements still have
the form and semantics of statements that could have result variables,
we call them `{\em assignment-statements}' even though they allocate
and assign no result variables.

Also there are statements with the form:
\begin{center}
{\em function-call} ~ \TT{=} ~ {\em expression-list}
\end{center}
which are syntactic sugar for a {\em function-call}
in which the {\em expression-list} has been made into a function argument
list and there are no result variables.
{\em Function-calls} \underline{cannot} be used as result variables.
See \itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}.

\subsection{Simple Assignment Statements}
\label{SIMPLE-ASSIGNMENT-STATEMENTS}

The simplest \skey{assignment statement}s have the syntax:

\begin{indpar}
\emkey{simple-assignment-statement}
    ::= {\em result-variable-list} \TT{=} {\em expression-list}
\\[0.5ex]
\emkey{expression-list}\label{EXPRESSION-LIST}
    ::= {\em expression} \{ \TT{,} {\em expression} \}\STAR{}
\end{indpar}

If there is more than one {\em expression} in the {\em expression-list},
or if there is a single {\em expression} that is \underline{not}
a {\em function-call},
then each {\em expression} produces a single value, and the list of these
values is the list of values assigned to the list of result variables.
The {\em expressions} are evaluated in left to
right order, and all the {\em expressions} are evaluated before any of
the result variables are given values.
In this case there must be the same number of {\em expressions}
in the {\em expression-list} as there are result variables.

If the {\em expression-list} is a single {\em expression} that
is a {\em function-call} which
returns a list of values, this list of values is used.
In this case the {\em function-call} may produce more values than
there are result variables, and the excess values are discarded,
as long as there is at least one result variable.
if there are no result variables, the
{\em function-call} must match a {\em function-prototype} that has
no result variables (\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}).

An {\em expression} may only input values that are constants,
the values of variables in the same function execution
frame (including arguments passed to the function execution), 
or the values of global variables.  In particular,
no input can come \underline{directly}
from RAM memory outside the current function execution frame or
global memory,
but see \pagref{MEM} and Section~\itemref{THE-MEM-QUALIFIER}
for ways to load RAM values into function frame variables.
See Section~\itemref{STACK-MANAGEMENT} for more information about
function frames.

The value assigned to each result variable must be implicitly convertible to
the variable's type.
In the case that an {\em expression} is producing
only a single value, the type of its associated result variable is the target
type of the {\em expression}.  If there is only one {\em expression}
and that is a {\em function-call}, the types the result variables
are matched to the types of the {\em function-prototype} result
variables (\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}).

Some examples of {\em simple-assignment-statements} are:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = x + 1         // y == 2
next x = 10 * x         // Now x == 10
next y = x + y          // Now y == 12
int32 z = 256 + y       // z == 268
int8 u = z              // ILLEGAL!  Undefined implicit
                        // conversion from int32 to int8.
int8 v = mod ( z )      // Now v == 12
int8 w = v + 257        // ILLEGAL!  Constant out of range
                        // of target type int8.
float32 m = 1.7
int64 i = m             // ILLEGAL!  Undefined implicit
                        // conversion from float32 to int64.
int32 j = nearest ( m ) // now j == 2 (round to nearest)
int32 y = x + y         // ILLEGAL! y hides y.
\end{verbatim}\end{indpar}

\subsection{Block Assignment Statements}
\label{BLOCK-ASSIGNMENT-STATEMENTS}

Another variant of the assignment statement is\index{block assignment}:

\begin{indpar}
\emkey{block-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \\
	\TT{~~~~}\{ \ttkey{do} {\em block-name}\QMARK{}
	              \{ \TT{(} {\em context-expression} \TT{)} \}\QMARK{}
	              \}\QMARK{} \TT{:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{}
	\end{tabular}
\\
\emkey{block-name} ::=
    \begin{tabular}[t]{l}
    {\em name} ~~~~~ [see \pagref{NAME}] \\
    \underline{not} containing
	`\TT{.}',~ {\em quoted-marks},~ or {\em quoted-separators} \\
    \end{tabular}
\end{indpar}

where `\TT{do} {\em block-name}\QMARK{}
	              \{ \TT{(} {\em context-expression} \TT{)} \}\QMARK{}'
may be omitted as long as \TT{=} is not omitted.

The {\em statements} within the {\em block-assignment-statement}
comprise a `\key{block}' of code.

Unless `\TT{(} {\em context-expression} \TT{)}' is given,
a {\em block-assignment-statement} is
compiled in the current context (\pagref{CONTEXT}),
and {\em names} declared within the block are \underline{not} permitted
to hide (\pagref{HIDE}) {\em names} declared before the block.
But if `\TT{(} {\em context-expression} \TT{)}' is given,
the {\em block-assignment-statement} is
compiled in the context given by {\em context-expression},
and names declared within the block
are permitted to hide names in the specified context.

Any result variables in a {\em block-assignment-statement}
are called `\skey{deferred variable}s' because they do not
immediately get a value.  They are assigned values by
{\em assignment-statements} within the block
whose {\em result-variable-lists}
include {\em deferred-variables}:
\begin{indpar}
\emkey{deferred-variable}\label{DEFERRED-VARIABLE} ::=
    {\em variable-name} $|$ \TT{next} ~ {\em variable-name}
\end{indpar}
{\em Assignment-statements} that set {\em deferred-variables}
are called `\skey{deferred assignment}s'.

No {\em qualifier-name} or {\em type-name} may be a prefix of
a {\em variable-name} used as a
{\em deferred-variable}.
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.

Variables declared in the block may not hide (\pagref{HIDE})
variables declared outside the block, including the result
variables of the block, with exceptions listed on
\pagref{HIDING-EXCEPTIONS}.

The code must be such that every deferred variable is given a value
by at most one deferred assignment, and if not a `\TT{next}' variable,
is given a value by a deferred assignment before the variable is read.
If a deferred variable is of the form `{\tt next v}', then {\tt v}
may be used in the block to refer to the variable value assigned
outside and before the {\em block-assignment-statement}, up to
the point where `{\tt next v}' is assigned a value in the block.
After that point {\tt v} refers to the value assigned to `{\tt next v}'.

An example of a {\em block-assignment-statement} is:
\begin{indpar}\begin{verbatim}
int32 x = 1
float64 y = 1.67
int64 z, uns8 w, next x =:

    z = 16,777,216   // Legal, z is deferred variable
    x = 265          // ILLEGAL, x is NOT deferred variable
    float64 y = 2.6  // ILLEGAL, y is visible outside block
    uns8 v = 55      // Legal, v is NOT visible outside block
    next x = 265 + x // Legal, next x is deferred variable,
                     //        now x == 266
    next y = 2.6     // ILLEGAL, y is visible outside block
                     //          and next y is not deferred
                     //          variable
    w = mod ( x )    // Legal, w is deferred variable,
                     // sets w to 10 as x is now 266
\end{verbatim}\end{indpar}

An exit statement may be used to jump from within a block to
the end of the block:

\begin{indpar}
\emkey{exit-statement} ::=
        \ttkey{exit} ~ {\em block-name}\QMARK{} ~
	    \{ \TT{if} ~ {\em condition-expression} \}\QMARK{}
\end{indpar}

If the {\em block-name} is not given, the smallest block containing
the {\em exit-statement} is exited.

The block exit may be conditional.  The compiler checks that
if non-conditional exits are taken and conditional
exits are either taken or not, each one of the block's
deferred variables is given a value by a single deferred assignment statement.
However, if a {\em block-name} is given and the exit statement is in
a subblock of the named block,
the deferred variables of this subblock
need not be given values.

Examples of {\em exit-statements} are:

\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
bool v = do BLOCK1:
    // sets v = ( x <= 10 or y >= 10 )
    //
    do BLOCK2:
        exit BLOCK2 if not x <= 10
        v = true
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3 if not y >= 10
        v = true
        exit BLOCK1
    v = false

next v = do BLOCK1:
    // attempts to set next v = ( x <= 20 or y >= 20 )
    next v = true
    exit BLOCK1 if x <= 20
    exit BLOCK1 if y >= 20
    next v = false          // ILLEGAL: next v set twice
\end{verbatim}\end{indpar}

L-Language parses all code, but does not compile statements that
cannot be reached from the beginning of the current top level
statement (e.g., out-of-line function declaration).  Because
of unconditional \TT{exit} statements, or \TT{exit} statements
whose conditions evaluate to \TT{true} at compile time,
some statements will be unreachable and will not be compiled.
Unreachable statements are not checked for non-parsing compile
errors.

For example, the code
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
int32 z = do BLOCK1:
    do BLOCK2:
        exit BLOCK2 if not x <= 10
        z = 55
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3 if not y >= 10
        z = "hot dog"    // Illegal conversion
        exit BLOCK1
    z = "cold dog"       // Illegal conversion
\end{verbatim}\end{indpar}

becomes after eliminating unreachable statements:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
int32 z = do BLOCK1:
    do BLOCK2:
        exit BLOCK2 if false
        z = 55
        exit BLOCK1
\end{verbatim}\end{indpar}

and therefore has no compiler errors.


\subsection{Conditional Assignment Statements}
\label{CONDITIONAL-ASSIGNMENT-STATEMENTS}

\ikey{Conditional assignment statements}{conditional assignment}
are syntactic sugar for block assignment statements
with exits (\pagref{BLOCK-ASSIGNMENT-STATEMENTS}).
Conditional assignment statements have the syntax:

\begin{indpar}
\emkey{conditional-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \ttkey{if}\TT{:} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	\TT{~~~~}\ttkey{else}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

In this case the {\em condition-expressions} are evaluated in order
until either one evaluates to true or the `\TT{else}' condition is
reached, and then the {\em statements} subject to the
first true condition (a.k.a the \key{subblock} of that condition)
are executed, or if no condition is true, the {\em statements}
of the `\TT{else}' subblock are executed.

Every variable in the {\em result-variable-list} \underline{must} be set by the
single subblock that executes, unless that subblock exits a block
that contains the {\em conditional-assignment-statement}.  A variable in the
{\em result-variable-list} cannot be read by a subblock {\em statement}
unless it is set by a previous {\em statement} in the
same subblock.

An example is:
\begin{indpar}\begin{verbatim}
function float64 result =
        max ( float64 x, float64 y, float64 z ):
    result = if:
        y <= x => z:
            result = x
        z <= y => x:
            result = y
        y <= z => x:
            result = z
        else:
            result = NaN
\end{verbatim}\end{indpar}

where \TT{NaN} means `\key{not-a-number}' and is the missing
value for \TT{float64} variables.  {\tt x~=>~y} is true if
and only if neither {\tt x} nor {\tt y} is a \TT{NaN} and
{\tt x} is equal to or greater than {\tt y}.  Thus if any of
{\tt x}, {\tt y}, or {\tt z} in the above conditional assignment
is a \TT{NaN}, none of the {\em conditional-expressions}
will be \TT{true}, and the \TT{else} subblock will be evaluated to set
the {\tt result} to a \TT{NaN}.

There are two special rules that apply to
{\em conditional-assignment-statements}:\label{CONDITIONAL-SPECIAL-RULES}

\begin{itemize}
\item
If some of the {\em conditional-expressions} can be computed at compile
time, subblocks that the compiler determines cannot execute are not
compiled or checked for compiler errors (but the subblocks are parsed
and checked for parsing errors).

Specifically, if a {\em conditional-expression} evaluates to \TT{true}
at compile time, subblocks beyond the subblock
of this {\em conditional-expression}
are not compiled.  And if a remaining {\em conditional-expression}
evaluates to \TT{false} at compile time, the subblock of this
{\em conditional-expression} is not compiled.
\end{itemize}

For example, if a {\em conditional-assignment-statement}
contained
\begin{indpar}\begin{verbatim}
    if x >= 1,000,000:
        result = NaN
\end{verbatim}\end{indpar}
where {\tt x} is a variable with value known at compile time
that is less than {\tt 1,000,000}, then
`{\tt result = NaN}' will not compile
and will not be checked for compile time errors.


A second special rule is:

\begin{itemize}
\item\label{MISSING-ELSE-RULE}
Missing `\TT{else}'s do not cause compile errors,
but will cause run time errors if needed at run time.
\end{itemize}

For example, the {\em conditional-assignment-statement}:
\begin{indpar}\begin{verbatim}
    result = if:
        x <= y:
            result = x
        y <= x:
            result = y
\end{verbatim}\end{indpar}
will suffer a run-time error if either {\tt x} or {\tt y} is
a floating point \TT{NaN} at run-time.

\subsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

\ikey{Loop assignment statements}{loop assignment}
are similar to block assignment
and conditional assignment statements.  An example is:
\begin{indpar}\begin{verbatim}
// Calculate the sum of i for i == 1 to i == n.
//
int64 n = . . .
int64 sum = loop:
    initially:
        int64 i = 1
        int64 partial sum = 0
    while i <= n:
        next partial sum = partial sum + i
        next i = i + 1
    finally:
        sum = partial sum
\end{verbatim}\end{indpar}



The general syntax of loop assignment statements is:

\begin{indpar}
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	          \ttkey{loop:} \\
	\TT{~~~~}\ttkey{initially}\TT{:} \\
	\TT{~~~~~~~~~}{\em assignment-statement}\STAR{} \\
	\TT{~~~~}\{ \ttkey{while} $|$ \ttkey{until} \}
	         {\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ttkey{finally}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

This is somewhat like the conditional assignment statement
except the `\TT{while}' or `\TT{until}'
subblock is iterated and there are iteration
variables defined by the `\TT{initially}' subblock.

The `\TT{initially}' subblock is call the `\key{initialization subblock}',
the `\TT{while/until}' subblock is call the `\key{iteration subblock}',
and the `\TT{finally}' subblock is call the `\key{finalization subblock}'.

The \skey{iteration variable}s are the
{\em result-variables} of the
{\em assignment-statements} executed by the initialization subblock.
Each iteration of the loop gives these variables new values using
`{\tt next v}' to refer to the value of {\tt v} in the next iteration,
where {\tt v} is an iteration variable.  In the example `{\tt i}' and
`{\tt partial sum}' are iteration variables.

An iteration subblock qualified by `\ttkey{while}'
{\em condition-expression}' only executes if the
{\em condition-expression} evaluates to \TT{true},
whereas an iteration subblock qualified by `\ttkey{until}'
{\em condition-ex\-pres\-sion}' only executes if the
{\em condition-expression} evaluates to \TT{false}.

Lastly, when the {\em condition-expression} evaluates so the iteration
subblock is not executed, the finalization subblock
executes, and it must set all the variables in the
loop statement's {\em result-variable-list}.  At this point the loop stops
executing.

Loops are always in effect unraveled so multiple copies of
the iteration subblock exist at one time.

Within the initialization and iteration subblocks assignment
statements may set iteration variables in adjacent subblocks
using the following syntax for assignment statement result variables:
\begin{indpar}
\emkey{iteration-result-variable}\label{ITERATION-RESULT-VARIABLE} ::=
    \ttmkey{next}{iteration result variable}~{\em variable-name}
     $|$ \ttmkey{next next}{iteration result variable}~{\em variable-name}
\end{indpar}
{\em Assignment-statements} that set {\em iteration-result-variables}
are called `\skey{iteration assignment}s'.

Let {\tt v} be an iteration variable.  After it is set in the initialization
subblock, `{\tt v}' refers to the value of the variable in both
the initialization subblock and the first iteration.
`{\tt next v}' refers to the value of the variable in the second
iteration.  In order to prevent confusion, `{\tt v}' cannot
be used in the initialization subblock after `{\tt next v}' has
been assigned, `{\tt next v}' cannot be used in the subblock
except as a result variable when it is assigned, and
`{\tt next next v}' cannot be used in the initialization subblock.

Within the iteration
subblock, `{\tt v}' refers to the value of the variable in the
current iteration, `{\tt next v}' refers to the value of the variable
in the next iteration, and `{\tt next next v}' refers to the
value of the variable in the next iteration after the next iteration.
In order to prevent confusion, `{\tt v}' cannot
be used in the iteration subblock after `{\tt next v}' or
`{\tt next next v}' has been assigned,
and `{\tt next v}' and `{\tt next next v}'
cannot be used in the subblock
except as a result variables when they are assigned.

Within the finalization
subblock, `{\tt v}' refers to the value the variable would have
for an additional iteration if such an iteration existed.
Within the finalization subblock `{\tt next v}' and
`{\tt next next v}' cannot be used.

For a given iteration variable {\tt v},
either the initialization subblock sets {\tt v}
and the iteration subblock sets `{\tt next v}',
or the initialization subblock sets both {\tt v} and `{\tt next v}'
and the iteration subblock sets `{\tt next next v}'.

There are always at least 4 iterations of the loop with variables
simultaneously in the current function frame: the current iteration,
the previous iteration (if any), and the next two iterations.
When the third iteration of the loop starts, the first
iteration can be discarded, and so forth.

Code in an initialization or iteration subblock cannot set
deferred result variables outside the subblock (including loop block
result variables), or contain \TT{exit} statements that have
no block label.

\subsection{Call Assignment Statements}
\label{CALL-ASSIGNMENT-STATEMENTS}

Note that most functions are inline, and not out-of-line.
Inline functions are described later
in Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS}.

\ikey{Call assignment statements}{call assignment}
are used to call out-of-line functions:

\begin{indpar}
\emkey{call-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em call-assignment-option}\STAR
		~\ttkey{call}~ {\em function-expression} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{}
	\end{tabular}
\\[1ex]
\emkey{call-assignment-option}
	\begin{tabular}[t]{rl}
	::= & \ttkey{*UNCHECKED*} $|$ \ttkey{*REVERSE*}
	                          $|$ \ttkey{*NO-RELOAD*} \\
	$|$ & \ttkey{*COMPILE-TIME*} $|$ \ttkey{*COMPILE-TIME-ONLY*}
	\end{tabular}
\\[1ex]
\emkey{argument-assignment-statement} ::=
    \begin{tabular}[t]{l}
    {\em assignment-statement} in which all {\em result-variables} \\
    are {\em result-variable-declarations}
    \end{tabular}
\end{indpar}

The {\em function-expression} evaluates to a function to be called,
and must have a natural type (\pagref{NATURAL-TYPE})
$T$ that has \TT{adr} as its underlying type.

The values of the variables created by the {\em argument-assignment-statements}
are the arguments to the function.
The results of the function call are stored in the
{\em result-variable-list} variables.

A call assignment must have the \TT{*UNCHECKED*} option
unless $T$ is declared by an out-of-line
function type declaration described below.  If there is no
such declaration, the arguments are presented to the out-of-line
function in the order they are listed in the {\em call-assignment-statement},
unless the \TT{*REVERSE*} option is given, in which case this order
is reversed.

If there is an out-of-line function type declaration, arguments in the
call are matched by name to arguments in the type declaration,
and then ordered as per the type declaration.  In this case
the \TT{*REVERSE*} option is not permitted.

Normally a `\TT{reload mem, mem dependent}'
statement (see \itemref{THE-RELOAD-COMMAND})
is executed automatically
upon returning from the called function, but the
\ttkey{*NO-RELOAD*} option suppresses this.
If the \TT{*NO-RELOAD*} is given, the \TT{*UNCHECKED*} option must
also be given.

If the \TT{*COMPILE-TIME*} option is given, the call
will be made at compile time only if the argument values are available
at compile time, and will otherwise be made at run time.  When the call
is made determines whether any result variable values are determined
at compile time.  If the \TT{*COMPILE-TIME-ONLY*} option is given,
the call is made at compile time, and the argument values must be
available at compile time.

An out-of-line function type declaration has the form:

\begin{indpar}
\emkey{function-type-declaration}\label{FUNCTION-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function type}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{}
		    {\em defined-type-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{}
	\end{tabular}
\\[0.5ex]
\emkey{argument-variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{function-declaration-option}
	\begin{tabular}[t]{rl}
	::= & \ttkey{*COMPILE-TIME*} \\
	$|$ & \ttkey{*COMPILE-TIME-ONLY*}
	\end{tabular}
\end{indpar}

This makes \TT{adr} the base type of the new
defined type, and declares the prototype
for the out-of-line function.
Then a call assignment block is type-checked by matching
the variable names in the call assignment block
to those in the prototype.  Thus in this case the order of variables
in the call block does not matter as they will be matched by
variable name to the prototype and then their values will be
reordered according to the prototype.  Also, in this case
a call block argument
may be of different
type than corresponding prototype argument if there is an implied
conversion from the call block
argument type to the prototype argument type,
in which case the implied conversion will be invoked.
Similarly a prototype result variable may be converted to
a call block result variable by an implied conversion.

The result and argument variables in a 
{\em function-type-declaration} are permitted to hide (\pagref{HIDE})
names in the context of the declaration, but the {\em defined-type-name}
may not.

A function type may be declared multiple times.  All these declarations
must be identical except for ordering of options and qualifiers.

Out-of-line functions may be declared by
an assignment statement of the form:
\begin{indpar}
\emkey{out-of-line-function-deferred-assignment}%
\label{OUT-OF-LINE-FUNCTION-DEFERRED-ASSIGNMENT} ::= \\
\hspace*{0.5in}{\em function-type-name}~{\em function-name} \TT{=}
    \ttmkey{deferred}{function}
\end{indpar}

The {\em function-name} is referred to as a `\key{deferred function}'.
This specifies that the body of the out-of-line function
with the given {\em function-name} will be provided later
during program initialization.  It is an error to call an uninitialized
deferred function.

An out-of-line function may be declared by
an assignment statement of the form:
\begin{indpar}
\emkey{out-of-line-function-assignment}%
\label{OUT-OF-LINE-FUNCTION-ASSIGNMENT} ::= \\
\hspace*{0.5in}{\em function-type}~~{\em function-name} \TT{=:} \\
\hspace*{1.0in}{\em statement}\STAR{}
\end{indpar}

The argument and result variable names used by the {\em statements}
are those given in the {\em function-type} declaration.
These names
and names declared within the {\em statements} of the assignment,
are permitted to hide (\pagref{HIDE})
names in the context of the assignment, but the {\em function-name}
may not.

If the {\em function-name} is deferred, the {\em function-type}
name given in the {\em out-of-line-function-deferred-assignment}
and that given in the {\em out-of-line-function-assignment}
must be identical.  It is an error if the statement initializing
a deferred function is not in the same extended module as the function's
{\em out-of-line-deferred-assignment}.

Out-of-line functions may also be declared by:

\begin{indpar}
\emkey{out-of-line-function-declaration}%
\label{OUT-OF-LINE-FUNCTION-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{}
		             ~ {\em function-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
		\TT{~~~~do:} \\
		\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}\label{OUT-OF-LINE-FUNCTIONS}

This is equivalent to defining a function type with a hidden name
and then defining {\em function-name} to be a function of that type.
The result and argument variables in a
{\em out-of-line-function-declaration},
and names declared within the {\em statements} of the declaration,
are permitted to hide (\pagref{HIDE})
names in the context of the declaration, but the {\em function-name}
may not.

For the function to be callable at compile time, the
\TT{*COMPILE-TIME*} or \TT{*COMPILE-\EOL TIME-\EOL ONLY*} options must be given.
See Section~\itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS}.
A \TT{*COMPILE-\EOL TIME*} out-of-line function will also be callable at
run time, but a \TT{*COMPILE-\EOL TIME-\EOL ONLY*}
out-of-line function will only be callable
at compile time.

Normally the standard call linkage for the computer environment of
the program is used.  Other implementation specific call options
may alter the call linkage used.

\subsection{Out-of-Line Assignment Statements}
\label{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}

An \key{out-of-line assignment statement} is like a combination of
a {\em call-assignment-statement} with
an {\em out-of-line-function-declaration} for a function
specific to the call:

\begin{indpar}
\emkey{out-of-line-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em function-declaration-option}\STAR
		~\ttkey{out-of-line} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

An {\em out-of-line-function-declaration} is constructed from this statement
by replacing the `\TT{out-\EOL of-\EOL line}' keyword by
an internally generated
{\em function-name}, and converting each {\em argument-assignment-statement}
to an {\em argument-variable-declaration}.

Then this statement is executed as a {\em call-assign\-ment-statement}
using the {\em function-name} and deleting the `\TT{do}' subblock.

{\em Out-of-line-assignment-statements} are generally included in
inline functions which preprocess arguments and may use various
{\em out-of-line-assignment-statements} to handle complex subcases.
When compiled multiple times in different contexts, the same
{\em out-of-line-assignment-statement} may be optimized in different
ways, and produce different out-of-line functions.  When it produces
the same out-of-line function more than once, this out-of-line function will
\underline{not} be duplicated.


\subsection{Compile-and-Run Assignment Statements}
\label{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}

A \key{compile-and-run assignment statement} computes a set of
variables that have values constant in a block, then compiles
the block using these constant values to optimize the compilation,
and lastly runs the block:

\begin{indpar}
\emkey{compile-and-run-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \\
	\TT{~~~~}\ttkey{compile-and-run}
		 \{ {(} {\em context-expression} \TT{)} \}\QMARK{}
		 \TT{:} \\
	\TT{~~~~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~~~~do} {\em block-name}\QMARK{} \TT{:} \\
	\TT{~~~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

The variable values are set by the {\em argument-assignment-statements}.
Then the `\TT{do}' subblock {\em statements} are compiled, using
the variable values to optimize the compilation.

Normally the
{\em compile-and-run-assignment-statement} is
compiled in its context (\pagref{CONTEXT}),
but if `\TT{(} {\em context-expression} \TT{)}'
is given, it is compiled in the context given by the
{\em context-expres\-sion}.
If the {\em context-expression}
specifies a context other than the context of the
{\em compile-and-run-assignment-statement}, the result variable names
and names declared within the block {\em statements}
are permitted to hide (\pagref{HIDE})
names in the specified context.

Then the
compiled code is executed.  The variables in the {\em result-variable-list}
may be set by either {\em argument-assignment-statements} or
`\TT{do}' subblock {\em statements} as for
a block assignment statement (see \itemref{BLOCK-ASSIGNMENT-STATEMENTS}).
If a variable \TT{v} not in the {\em result-variable-list}
is set by an {\em argument-assignment-statement},
`\TT{next v}' can be set by a `\TT{do}' subblock {\em statement}, but
this will be a new variable whose value may not be available during
the compilation.

When the compile-and-run assignment statement is executed, the compiled
code will be saved in a table indexed by the values of the
variables set by the {\em argument-assignment-statements} and the context
used in compilation.  When the
compile-and-run assignment statement is re-executed, if these
variables have the same values they had during a previous execution,
and if the same context is being used,
the compilation will be bypassed and the previously compiled code used.
This optimization is required, but such previously compiled code
may be discarded if it has not been used in a long time.


\subsection{Compile-Time Assignment Statements}
\label{COMPILE-TIME-ASSIGNMENT-STATEMENTS}

\ikey{Compile-time assignment statements}{compile-time assignment statement}
run only once, when they are compiled, and produce variable values
at compile time:

\begin{indpar}
\emkey{compile-time-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~~~ \ttkey{compile-time:} \\
	\TT{~~~~}{\em statement}\STAR{}
	\end{tabular}
\end{indpar}

A compile-time block has its own stack, which is freed when the
block finishes executing.

Compile time blocks may only use compile time variables and values,
but may use visible inline functions, out-of-line functions
that have been declared to be compile-time, and global areas
that have been declared to be compile-time.

\subsection{Deferred Assignment Statements}
\label{DEFERRED-ASSIGNMENT-STATEMENTS}

\ikey{Deferred assignment statements}{deferred assignment statement}
specifies that assignment of its result variables is deferred until later:

\begin{indpar}
\emkey{deferred-assignment-statement} ::=  \\
\hspace*{0.5in}{\em result-variable-list} \TT{=} \ttkey{deferred}
\end{indpar}


The result variables of 
a {\em deferred-assignment-statement} are called `\mkey{deferred}{variable}'.

A {\em deferred-assignment-statement} must be top level.
The statement that assigns its values later must be an assignment
statement with identical {\em result-variable-list}
that is in the same extended module as the {\em deferred-assignment-statement}.
It is a program error to read a deferred variable before it has
been assigned a value.

\subsection{Assembly Assignment Statements}
\label{ASSEMBLY-ASSIGNMENT-STATEMENTS}

\ikey{Assembly assignment statements}{assembly assignment statement}
are used to embed assembler instructions in compiled code:

\begin{indpar}
\emkey{assembly-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~\TT{*UNCHECKED*}~\ttkey{*ASSEMBLY*:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em assembler-instruction}\STAR{} \\
	\end{tabular}
\end{indpar}

The variables, those produced by the {\em argument-assignment-statements},
the {\em argument-variable-declarations},
and the result variables, are placed in machine registers
and their names become machine register names for the assembler instructions.
Assembler instructions are only permitted to reference these
machine registers, but load and store assembler instructions may be used.
The assembler instructions are written in the syntax of one of the
target machine assemblers.

The variables may have additional qualifiers which
are names of machine registers or groups of machine registers.  In this case
the variables will be allocated to the specified machine registers or
machine register groups.  Otherwise they will be allocated to target
machine specified register groups based on variable type.

The {\em argument-variable-declarations} list intermediate
variables.  Only the variables named in the {\em argument-assignment-statements}
are given initial values.  Unlike normal code, values of variables
of an {\em assembly-assignment-statement} can be overwritten by the
{\em assembler-instructions}, and there is no check to be sure that
result variables receive any value.

\section{Function Prototypes and Calls}
\label{FUNCTION-PROTOTYPES-AND-CALLS}

Inline functions are declared by {\em function-declarations}
that contain a {\em function-prototype} and the code body of the
function.  Note that inline functions cannot be called recursively.

The syntax is:

\begin{indpar}
\emkey{function-declaration}\label{FUNCTION-DECLARATION}
    ::= \begin{tabular}[t]{l}
        {\em function-prototype} \TT{:} \\
	\TT{~~~~~}{\em statement}\PLUS{}
	\end{tabular}
\\[2ex]
\emkey{function-prototype}\label{FUNCTION-PROTOTYPE}
    \begin{tabular}[t]{@{}rl}
    ::= & \ttkey{function} ~
          {\em prototype-result-variable-list} ~ \TT{=} \\
        & \TT{~~~~~}{\em module-abbreviation}\QMARK{}
	                ~ {\em function-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em function-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em function-pattern} ~ \TT{=} \\
        & \TT{~~~~~}{\em input-variable-list} \\
    $|$ & {\em function-prototype} \TT{[|} {\em conditioner} \TT{|]}
    \end{tabular}
\\[0.5ex]
\emkey{prototype-result-variable-list} ::= \\
\hspace*{0.5in}
    {\em result-variable-declaration}
    \{ \TT{,} {\em result-variable-declaration} \}\STAR{}
\\[0.5ex]
{\em result-variable-declaration} ::= see \pagref{RESULT-VARIABLE-DECLARATION}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
\emkey{input-variable-list}
    ::= {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{}
\\[0.5ex]
\emkey{argument-declaration}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
          \TT{?=} {\em default-value} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
          \TT{??} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
          \TT{==} {\em required-value} \\
    \end{tabular}
\\[0.5ex]
\emkey{default-value} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[0.5ex]
\emkey{required-value} ::= {\em expression} with compile time value
\\[0.5ex]
\emkey{function-pattern}\label{FUNCTION-PATTERN}
    \begin{tabular}[t]{rl}
    ::= & {\em first-pattern-term} ~ {\em pattern-term}\STAR{} \\
    $|$ & {\em pattern-argument-list} {\em pattern-argument-list}\PLUS{}
    \end{tabular}
\\[0.5ex]
\emkey{first-pattern-term} ::= {\em pattern-argument-list}\STAR{} ~
				{\em pattern-term}
\\[0.5ex]
\emkey{pattern-term}
    ::= {\em function-term-name} ~ {\em pattern-argument-list}\STAR{}
\\[0.5ex]
\emkey{function-term-name} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\\[0.5ex]
\emkey{function-variable-name}\label{FUNCTION-VARIABLE-NAME} ::=
    \begin{tabular}[t]{@{}p{4in}@{}}
    {\em function-term-name} $N$ that appears in a {\em function-prototype}
    of the form `{\tt function $N$ = \ldots}'
    \end{tabular}
\\[0.5ex]
\emkey{pattern-argument-list} ::= {\em regular-argument-list}
                              $|$ {\em qualifiers-type-argument-list}
\\[0.5ex]
\emkey{regular-argument-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{qualifiers-type-argument-list} ::= \\
\hspace*{0.2in}\TT{(|} {\em qualifiers-type-argument-declaration}
	 \{ \TT{,} {\em qualifiers-type-argument-declaration} \}\STAR{} \TT{|)}
\\[0.5ex]
\emkey{qualifiers-type-argument-declaration} ::= \\
\hspace*{0.2in}{\em qualifiers-argument-declaration}
               $|$ {\em type-argument-declaration}
\\[0.5ex]
\emkey{qualifiers-argument-declaration} ::= \\
\hspace*{0.2in}\TT{qualifiers} {\em variable-name}
               \{ \TT{?=} {\em default-value} \}\QMARK{}
\\[0.5ex]
\emkey{type-argument-declaration} ::= \\
\hspace*{0.2in}\TT{type} {\em variable-name}
               \{ \TT{?=} {\em default-value} \}\QMARK{}
\\[0.5ex]
\emkey{conditioner}\label{CONDITIONER}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em logical-conditioner} \\
    $|$ & {\em qualifiers-conditioner} \\
    $|$ & {\em type-conditioner} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-conditioner}\label{LOGICAL-CONDITIONER}
    ::= {\em logical-expression} ~~~~~ [see \pagref{LOGICAL-EXPRESSION}]
\\[0.5ex]
\emkey{qualifiers-conditioner}\label{QUALIFIERS-CONDITIONER}
    ::= \TT{qualifiers} {\em variable-name} \TT{=} {\em expression}
\\[0.5ex]
\emkey{type-conditioner}\label{TYPE-CONDITIONER}
    ::= \TT{type} {\em variable-name} \TT{=} {\em expression}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[4ex]
\emkey{function-call}\label{FUNCTION-CALL}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em module-abbreviation}\QMARK{} ~ {\em first-call-term}
          ~ {\em call-term}\STAR{} \\
    $|$ & {em module-abbreviation}\QMARK{}
          {\em call-argument-list} {\em call-argument-list}\PLUS{}
    \end{tabular}
\\[0.5ex]
\emkey{first-call-term} ::= {\em call-argument-list}\STAR{}
				{\em call-term}
\\[0.5ex]
\emkey{call-term}
    ::= {\em function-term-name} {\em call-argument-list}\STAR{}
\\[1ex]
\emkey{call-argument-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{]} \\
    $|$ & \TT{(|} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{|)} \\
    $|$ & \TT{()} $|$ \TT{[]} $|$ \TT{(|~|)} \\
    $|$ & {\em primary-argument}
    \end{tabular}
\\[0.5ex]
\emkey{actual-argument} ::= {\em expression} ~~~~~ [see \pagref{EXPRESSION}]
\\[0.5ex]
\emkey{primary-argument} ::= {\em primary-item}\PLUS{}
                         $|$ {\em bracketed-constant}
\\[0.5ex]
{\em primary-item} ::= {\em word} $|$ {\em number}
                   $|$ {\em quoted-string} ~~~~~ [see \pagref{PRIMARY-ITEM}]
\\[0.5ex]
{\em bracketed-constant} ::= see \pagref{BRACKETED-CONSTANT}

\begin{itemize}
\item
A {\em function-pattern} or {\em function-call}
must have either a {\em function-term-name}
or at least two {\em argu\-ment-lists}.
\item
A {\em function-prototype} {\em function-term-name} must not be
an initial segment of any other {\em function-term-name}
in the same {\em function-prototype}.
\item
An {\em function-variable-name}
should not have a {\em qualifier-name} or {\em type-name} as an initial segment.
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.
\item
\TT{"="} cannot be used as a {\em function-term-name}
in a {\em function-pattern}.
\item
The first {\em argument-declaration} in an {\em input-variable-list}
must not have a {\em default-value} or end in \TT{??}.
\item
All the result and argument {\em variable-names}
in a {\em function-prototype} must
be distinct.
\item
The {\em variable-name} in a {\em qualifiers-argument-declaration}
or a {\em qualifiers-conditioner} is treated as a {\em qualifier-name}
within the rest of the {\em function-prototype}.  The value of the
{\em variable-name} must be computable at compile-time when the
function is called.  A {\em qualifiers-argument-declaration}
can be inside `\TT{()}' or `\TT{[]}' bracketed {\em argument-lists},
as well as `\TT{(|~|)}' bracketed {\em argument-lists}.
\item
The {\em variable-name} in a {\em type-argument-declaration}
or a {\em type-conditioner} is treated as a {\em type-name}
within the rest of the {\em function-prototype}.  The value of the
{\em variable-name} must be computable at compile-time when the
function is called.  A {\em type-argument-declaration}
can be inside `\TT{()}' or `\TT{[]}' bracketed {\em argument-lists},
as well as `\TT{(|~|)}' bracketed {\em argument-lists}.
\item
In a {\em pattern-argument-list} or {\em input-variable-list}
an {\em argument-declaration} with no {\em de\-fault-value} cannot
follow an {\em argument-declaration} with a {\em default-value}.
An {\em argument-declaration} that ends with `\TT{??}' is considered
to have a \TT{bool} {\em default-value}: see \pagref{BOOL-DEFAULT}.


\end{itemize}
\end{indpar}

The result and argument variables in a
{\em function-declaration},
and names declared within the {\em statements} of the declaration,
are permitted to hide (\pagref{HIDE})
names in the context of the {\em function-declara\-tion}.

A {\em function-call} with a {\em result-variable-list}
is replaced by a {\em block-assignment-statement}
with an context option specifying the context of the
{\em function-declaration}
(\itemref{BLOCK-ASSIGNMENT-STATEMENTS}).
The result and argument variables in the {\em function-declaration}
are effectively replaced by compiler generated temporary variable names to
avoid conflicts, and variables declared inside the replacing
{\em block-assignment-statement} are permitted to hide variables outside
the statement (\pagref{HIDE}).  The values of the argument temporary
variables are computed before the block and the values of the result
temporary variables are assigned to the {\em function-call} result
variables after the block.\footnote{This can be implemented by using
two nested blocks instead of one block without actually replacing
variable names in the {\em function-declaration} by temporary variable
names.}

A {\em function-call} without any {\em result-variable-list}
is just like a {\em function-call} with an empty
{\em result-variable-list}.

A {\em function-call} with an {\em input-variable-list} is just syntactic
sugar for a {\em function-call} with neither a {\em result-variable-list}
or {\em input-variable-list}.  Specifically
\begin{center}
{\tt F(a1,a2,...)~=~b1,b2,...} \\
is syntactic sugar for \\
{\tt F(a1,a2,...)~"="~(b1,b2,...)} \\
\end{center}

in which a term with \TT{"="} as its {\em function-term-name} is
placed at the end of the {\em function-call}.

{\em Call-terms} correspond to {\em pattern-terms}.  {\em Call-terms}
other than the first may be in a different order than their matching
{\em pattern-terms}.  {\em Call-terms} other than the first may be
omitted, and if omitted, will be inserted with empty {\em call-argument-lists}.
{\em Call-argument-lists} may be omitted, and if omitted, empty
lists will be inserted if this can be done unambiguously.
If a {\em pattern-argument-list} has \TT{()} brackets and a single
argument, and the corresponding {\em call-argument-list} has a single
{\em actual-argument} that
is a {\em primary-argument} ( sequence of {\em words}, {\em numbers},
and {\em quoted-strings}, or a {\em bracketed-constant}), then
the \TT{()} parentheses may be omitted in the {\em function-call}
if there is no ambiguity involving overlap with {\em function-term-names} or
other argument lists.

Examples are:
\begin{indpar}\begin{verbatim}
function int32 r =
        fee ( int32 x ) fie ( int32 y ) foe ( int32 z ):
    ... function body omitted ...

int32 b 1 = ...
int32 c 2 = ...
int32 d 3 = ...
int32 f = fee ( b 1 ) foe ( c 2 ) fie ( d 3 )
    // Same as:
    //   int32 f = fee ( b 1 ) fie ( d 3 ) foe ( c 2 )
int32 g = fee ( b 1 ) foe ( c 2 )
    // Same as:
    //   int32 g = fee ( b 1 ) fie () foe ( c 2 )
    // Erroneous: actual argument missing
int32 h = fee b 1 foe c 2 fie d 3
    // Same as:
    //   int32 h = fee ( b 1 ) fie ( d 3 ) foe ( c 2 )
\end{verbatim}\end{indpar}

If an argument has a {\em required-value} in a {\em pattern-argument-list},
then there must be a corresponding {\em actual-argument} in the
{\em function-call} whose value is a compile-time value that equals the
{\em required-value}, which must also be a compile-time value.  An example is:
\begin{indpar}\begin{verbatim}
define type my type as int32
define type your type as uns32
function type r = companion type of ( type t == my type ):
    r = your type
function type r = companion type of ( type t == your type ):
    r = my type
\end{verbatim}\end{indpar}

{\em Actual-arguments} may be omitted at the end of a {\em call-argument-list}
if their corresponding
{\em argu\-ment-declaration} contains a {\em default-value}.
The {\em default-value} will be used as the actual argument
for such an omitted actual argument.

If the {\em argument-declaration} ends in `\TT{??}'\label{BOOL-DEFAULT}
with no explicit {\em default-value}, the
argument must have \TT{bool} type and the
{\em default-value} is taken to be \TT{true} if the
corresponding {\em call-term} was originally present, and \TT{false} if the
{\em call-term} was originally omitted and automatically inserted.

An example is:
\begin{indpar}\begin{verbatim}
int32 B = ...
int32 C = ...
context fooC = current context
function int32 r =
        foo ( int32 x ) bar ( int32 y ?= B + C, bool z ?? )
    ... function body omitted ...

int32 b 1 = ...
int32 f = foo ( b 1 )
    // Call has same effect as:
    //     int32 tmp y, bool tmp z = do ( fooC ):
    //         tmp y = B + C
    //         tmp z = false
    //     int32 f = foo ( b 1 ) bar ( tmp y, tmp z )
\end{verbatim}\end{indpar}

An {\em argument-declaration} can be a {\em type-argument-declaration}
which has the form `{\tt type T}' for some {\em variable-name} {\tt T}.
This makes {\tt T} into a {\em type-name} within the {\em function-declaration}
containing the {\em type-argument-declaration}.
If the {\em type-argument-declaration} is
in an argument list with `\TT{(|~|)}' brackets,
the actual value of {\tt T} can be implied by a {\em function-call}.
If an explicit or default value of {\tt T} is given by the call, that is used.
Otherwise if {\tt T} is the type of a prototype result variable, and there
is a corresponding {\em function-call} result variable with a known type,
the type of the leftmost such {\em function-call} result variable
is assigned as the value of {\tt T}.  Otherwise
if {\tt T} is the type of a prototype argument variable, and
the {\em actual-argument} corresponding to the variable in the call has
a natural type (\pagref{NATURAL-TYPE}), {\tt T} is assigned the natural type
corresponding to the leftmost such variable in the prototype.


For example,
\begin{indpar}\begin{verbatim}
function T result = add (| type T |) ( T v1, T v2 ):
    result = v1 + v2

// Example usage
//
int32 x = ...
int32 y = ...
int32 z = add (| int32 |) ( x, y )
    // T is explicitly given.
next z = add ( x, y )
    // T = int32 is implied because that is the type of
    // `next z'.
\end{verbatim}\end{indpar}

An {\em argument-declaration} can be a {\em qualifiers-argument-declaration}
which for some {\em variable-name} {\tt Qs}
has the form `{\tt qualifiers Qs}'.
This makes {\tt Qs} into a {\em qualifier-name}
within the {\em function-de\-clar\-a\-tion}
containing the {\em qualifiers-argument-declaration}.  Note that {\tt Qs}
is used like a {\em qualifier-name}, but its value is a set of
zero or more qualifiers.

If the {\em qualifiers-argument-declaration} is
in an argument list with `\TT{(|~|)}' brackets,
the actual value of {\tt Qs} may be implied by a {\em function-call}.
If an explicit or default value of {\tt Qs} is given by the call, that is used.
Otherwise if {\tt Qs} is the given as the \underline{only} qualifier
of a prototype result variable that is \underline{not} a variable
qualifier, and there is a corresponding {\em function-call}
result variable with known type,
the \underline{value} qualifiers of the leftmost such {\em function-call}
result variable are
assigned as the value of {\tt Qs}.  Otherwise
if {\tt Qs} is given as the \underline{only} qualifier
of a prototype argument variable,
and the {\em actual-argument} corresponding to the
variable has a natural type (\pagref{NATURAL-TYPE}),
{\tt Qs} is assigned the \underline{value} qualifiers of the
{\em actual-argument} corresponding to the
leftmost such variable in the prototype.

For example,
\begin{indpar}\begin{verbatim}
define protected required value qualifier in-range
define required prohibited value qualifier ouch
function Qs in-range T r =
        check (| qualifiers Qs, type T |) ( Qs T v ):
    if:
        v < 0:
            error "argument < 0"
        v > 100:
            error "argument > 100"
        else:
            result = v

function F ( in-range v ):
    ... function body omitted ...

// Example usage
//
ouch int32 x = ...
ouch int32 y1 = check ( x )
           // Legal: check prototype becomes:
           //   ouch in-range r = check ( ouch int32 v )
           // so argument can have qualifier ouch,
           // and y1 must have qualifier ouch.
           // Also y1 is given protected qualifier
           // `in-range'.
int32 y2 = check ( x )
           // Illegal, result `ouch in-range r' cannot
           // be converted to y2 which has no `ouch'
           // qualifier.
F ( x )    // Illegal, x does not have required in-range
F ( y1 )   // Legal, y1 has required in-range
\end{verbatim}\end{indpar}

{\em Conditioners} bracketed by `\TT{[|~|]}'
can be written at the end of a {\em function-prototype},
as in:
\begin{indpar}\begin{verbatim}
types signed-integer-types =
    { int8, int16, int32, int64, int128 }

function T result = add (| type T |) ( T v1, T v2 )
    [| T is in signed-integer-types |]:
    result = v1 + v2
\end{verbatim}\end{indpar}

which would define `{\tt add}' only for signed integer types.
Here the conditioner is a {\em logical-ex\-pres\-sion} that must
be evaluatable whenever a call to the function is compiled.

Another example is:
\begin{indpar}\begin{verbatim}
function Qs2 T r = inc (| qualifiers Qs1, type T |)
                       ( Qs1 T v )
    [| qualifiers Qs2 = Qs1 - { stack } |]:
    return v + 1
\end{verbatim}\end{indpar}

which returns {\tt v+1} with the same qualifiers as {\tt v}
except for the `{\tt stack}' qualifier which is removed.
Here the rightside of the {\em qualifiers-conditioner}
must be evaluatable when a call to the function is compiled.

The body of an inline function is parsed, but it is not checked for
errors before the function is called.  When the function is called,
compile time values passed as arguments may cause parts of the body
to never be compiled or checked for compilation errors.  If a function
is never called, it may contain code that would have compilation errors
were the function called, such as calls to non-existent functions.

\subsection{Matching Function Calls to Prototypes}
\label{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}

To compile a {\em function-call} it must be matched to a
single {\em function-prototype}.  If it matches more than one
{\em function-prototype}, the call is ambiguous and is a compilation error

The matching algorithm, given a {\em function-call} and a
{\em function-prototype}, matches the {\em function-call}
to the {\em function-pattern} in the {\em function-prototype},
and matches any call result variables to
the {\em prototype-result-variable-list}
of the {\em function-prototype}.  The call may have one or more result
variables of known types, or a single result variable of unknown
type, or no result variables (as in a {\em function-call} that is
a {\em statement} by itself).  The algorithm is as follows:

\begin{enumerate}

\item
If the {\em function-call} is in a statement of the form
\begin{center}
{\em function-call} ~ \TT{=} ~ {\em expression-list}
\end{center}
the {\em function-prototype} must be of the form
\begin{center}
{\tt function} ~ {\em function-pattern} ~ {\tt =} ~ {\em input-variable-list} \\
\end{center}
and the following will be done:
\begin{enumerate}
\item `\TT{=}' will be treated in the following as if it were the
{\em function-term-name} \TT{"="}.
\item{\em expression-list} is parenthesized.
\item {\em input-variable-list} is parenthesized.
\end{enumerate}

For example, the prototype
\begin{center}
\tt function F ( int64 i ) = int32 x, int32 y
\end{center}
behaves as if it were
\begin{center}
\tt function F ( int64 i ) "=" ( int32 x, int32 y )
\end{center}
and the assignment statement
\begin{center}
\tt F ( i ) = x, y
\end{center}
behaves as if it were the function call with no result variables
\begin{center}
\tt F ( i ) "=" ( x, y )
\end{center}

\item If the {\em function-call} begins with a {\em module-abbreviation}
(see \pagref{MODULE-ABBREVIATION}), the {\em function-pattern}
must begin with a {\em module-abbreviation}, and the two
{\em module-abbreviations} must reference the same {\em module-name}
(i.e., module file, see \itemref{MODULES}), else the
call-prototype match fails.

\item If the {\em function-call} does \underline{not} begin
with a {\em module-abbreviation}, but the {\em function-pattern}
does begin with a {\em module-abbreviation}, the match is marked
as `\key{module deficient}'\label{MODULE-DEFICIENT},
and will be disallowed later if there is
another match that is not module deficient.

\item
The {\em function-term-names} in the {\em function-call} are located by
matching segments of the {\em func\-tion-call} to
{\em function-term-names} in the {\em function-pattern}.
If a {\em function-term-name} matches more than one segment,
the call-prototype match fails.  If the first {\em function-term-name}
in the {\em function-pattern} does not match any segment,
or does not match the first matched segment, the call-prototype match fails.
(Note that {\em function-term-names} in the {\em function-pattern}
cannot be initial segments of each other, but unparenthesized
{\em variable-names} may appear in the {\em function-call} and be
mistaken for parts of {\em function-term-names}.)

\item The {\em call-terms} after the first in the {\em function-call}
are reordered so the {\em function-term-names} in the {\em function-call},
taken in order, are a subsequence of the {\em function-term-names} in the
{\em function-pattern}.
If this cannot be done, the call-prototype match fails.
(Note that {\em call-terms} other than the first all begin with
a {\em function-term-name} and extend until the next {\em function-term-name}
or the end of the {\em function-call}.)

\item\label{ADD-TERMS}
If some of the {\em function-term-names} in the {\em function-pattern}
are missing from the call,
new {\em call-terms} without argument lists
are inserted in the call to match the missing
{\em pattern-terms}.  At this point there is a 1-1 ordered correspondence
between {\em call-terms} and {\em pattern-terms}.

\item
If some of the {\em pattern-terms} have argument lists that
have a single parenthesized argument, the parentheses may be omitted
in the {\em function-call} if the actual argument is a sequence of
{\em primary-items} or a {\em bracketed-constant}.
Also {\em argument-lists}
may be completely omitted in the {\em function-call}.  At this point
missing parentheses and missing {\em argument-lists} are added to
each {\em call-term} to make it match the corresponding
{\em pattern-term}.
The {\em argument-lists} added are empty and have the same type of
bracket, \TT{()}, \TT{[]}, or \TT{(|~|)}, as the {\em pattern-term}
{\em argument-lists} they match.

If this cannot be done \underline{uniquely}
so each {\em pattern-term} {\em argument-list}
is matched to a {\em call-term} {\em argument-list}
that has the same type of bracket, then the call-prototype match fails.

\item
If the {\em function-prototype}
has cluster member arguments or result variables,
these must be implied, and they are added to the {\em function-call}
at this point.  See \itemref{CLUSTERS} for details.

\item
Now the modified {\em function-call} matches
the {\em function-pattern} in {\em function-term-names},
location and number of {\em argument-lists}, and type of bracket (\TT{()},
\TT{[]}, or \TT{(|~|)}) for each {\em argument-list}.  Some
{\em call-argument-lists} may be shorter than the corresponding
{\em pattern-argument-lists}.

If a pattern {\em argument-declaration} has a {\em required-value},
there must at this point be a matching {\em function-call} {\em actual-argument}
with a compile-time value equal to the {\em required-value},
else the call-prototype match fails.

\item
If some of the {\em call-argument-lists} are now too short, they are extended
by adding the {\em default-values} from
their matching {\em pattern-argument-lists}.
As a special case, if a prototype {\em arg\-u\-ment-de\-clar\-a\-tion} ends in
`\TT{??}' and has no {\em default-value}, then the actual
{\em default-value} used is \TT{true} if the {\em function-term-name}
appeared in the original function call and was not added in
Step~\ref{ADD-TERMS} above, or is \TT{false} if the {\em function-term-name}
did not appear in the original function call, but was added in
Step~\ref{ADD-TERMS}.

If any of the arguments that need to be inserted in a
{\em call-argument-list} matched to a {\em regular-argument-list}
do not have {\em default-values}, the call-prototype match fails.

Now the modified {\em function-call} matches
the {\em function-pattern} in {\em function-term-names},
location and number of {\em argument-lists}, and type of bracket (\TT{()},
\TT{[]}, or \TT{(|~|)}) for each {\em argument-list}.  The number of
arguments also match for \TT{()} and \TT{[]} {\em argument-lists},
and number of actual arguments in each \TT{(|~|)} {\em call-argument-list}
is not greater than the number of arguments in the corresponding
{\em pattern-argument-list}.

Note that any {\em default-values} inserted in the {\em function-call}
are evaluated in the context of the {\em function-prototype}.  For
matching purposes, this is relevant only if the {\em default-values}
are {\em expressions} with compile-time values, and such
{\em default-values} can be replaced by constants when the
{\em function-prototype} is first compiled.

\item
If any {\em qualifiers-argument-declaration} in a {\em function-pattern}
{\em qualifiers-type-argument-list} has a corresponding
actual argument, the actual argument expression
is evaluated with the `\TT{qualifiers}' target type,
and must have a compile time value which is a set of qualifiers, else
the call-prototype match fails.  If the match does not fail,
the set of qualifiers becomes the value of the {\em variable-name}
in the {\em qualifiers-argument-declaration} and
is substituted for the {\em variable-name} throughout the rest of the
{\em function-prototype}.

\item
If any {\em type-argument-declaration} in a {\em function-pattern}
{\em qualifiers-type-argument-list} has a corresponding
actual argument, the actual argument expression
is evaluated with the `\TT{type}' target type,
and must have a compile time value which is a type, else
the call-prototype match fails.  If the match does not fail,
the type value becomes the value of the {\em variable-name}
in the {\em type-argument-declaration} and
is substituted for the {\em variable-name} throughout the rest of the
{\em function-prototype}.

\item
If any {\em qualifiers-argument-declaration} in a {\em function-pattern}
{\em qualifiers-type-argument-list} does \underline{not} have
a corresponding actual argument, the value of the
{\em variable-name} in the {\em qual\-i\-fiers-argument-declaration}
is implied.

If the {\em variable-name} in the {\em qualifiers-argument-declaration}
is used as the \underline{sole} {\em qualifier-name}
of prototype result variables
with a matching actual results with known type and qualifiers,
the qualifiers of the leftmost such actual result is assigned as the
value of the {\em variable-name}.

Otherwise if the {\em variable-name}
is used as the \underline{sole} {\em qualifier-name}
of several arguments whose matching
actual arguments have natural types, the qualifiers of the leftmost
of these arguments is assigned as the
value of the {\em variable-name}.

If no value can be assigned to the {\em variable-name} by these rules,
the call-prototype match fails.

If a value is assigned,
the set of qualifiers that is the assigned value
is added as an actual argument
in the {\em call-argument-list} that corresponds
to the {\em qualifiers-argument-declaration}, and
is substituted for the {\em variable-name} throughout the rest of the
{\em function-prototype}.

\item
If any {\em type-argument-declaration} in a {\em function-pattern}
{\em qualifiers-type-argument-list} does \underline{not} have
a corresponding actual argument, the value of the
{\em variable-name} in the {\em type-argument-declaration}
is implied.

If the {\em variable-name} in the {\em type-argument-declaration}
is used as the {\em type-name} of prototype result variables
with a matching actual results with known type,
the type of the leftmost such actual result is assigned as the
value of the {\em variable-name}.

Otherwise if the {\em variable-name}
is used the {\em type-name} of several arguments whose matching
actual arguments have natural types, the type of the leftmost
of these arguments is assigned as the
value of the {\em variable-name}.

If no value can be assigned to the {\em variable-name} by these rules,
the call-prototype match fails.

If a value is assigned,
the type that is the assigned value is added as an actual argument
in the {\em call-argument-list} that corresponds
to the {\em type-argument-declaration}, and
is substituted for the {\em variable-name} throughout the rest of the
{\em function-prototype}.

\item
The modified {\em function-call} now matches the {\em function-pattern}
precisely in {\em function-term-names},
location and number of {\em argument-lists}, type of bracket, i.e. \TT{()},
\TT{[]}, or \TT{(|~|)} for each {\em argument-list}, and number of
arguments in each {\em argument-list}.
This modified function call is referred to as the
`\mkey{unfolded}{function call}' {\em function-call}.

If any actual argument value needs to be a compile-time value in what
follows, the actual argument expression is compiled at this
time with its target type taken from the corresponding
{\em function-pattern} {\em argument-declaration}.
If the result is not a compile-time value, the call-prototype
match fails.

\item
The {\em conditioners} in the {\em function-prototype} are evaluated
in order.  If any of the expressions in them do not have compile-time
values, the call-prototype match fails.
If any {\em logical-conditioner} evaluates
to \TT{false}, the call-prototype match fails.

If the value assigned to the {\em variable-name} of a
{\em type-conditioner} is not a type, the call-prototype match fails.
Otherwise this type value is substituted for the {\em variable-name}
throughout the {\em function-prototype}.

If the value assigned to the {\em variable-name} of a
{\em qualifiers-conditioner} is not a (possibly empty) set of
qualifiers, the call-prototype match fails.
Otherwise this qualifiers set value is substituted for the {\em variable-name}
throughout the {\em function-prototype}.

\item\label{ARGUMENT-CALL-PROTOTYPE-MATCHING}
If the unfolded {\em function-call} has {\em actual-argument}
expressions $e1$, $e2$, \ldots{} read from left to right
(including {\em default-values}),
and the {\em function-pattern} has
{\em argument-declarations} `$Qs1$ $T1$ $v1$', `$Qs2$ $T2$ $v2$', \ldots{}
read from left to right,
then the statement containing the
revised {\em function-call} is replace by:
\begin{indpar}
{\tt $Qs1$ $T1$ $tmp1$ = $e1$} \\
{\tt $Qs2$ $T2$ $tmp2$ = $e2$} \\
\ldots\ldots\ldots\ldots \\
statement containing {\em function-call}
with each {\em actual-argument} $eI$ replaced by $tmpI$
\end{indpar}

Here the $Qs\ldots$ are possibly empty qualifier sets,
the $T\ldots$ are types, the $v\ldots$ are argument variable
names, and the $tmp\ldots$ are
\skey{temporary variable name}s (names of the form \TT{T\$}$n$
for a natural number $n$ manufactured by the compiler and
guaranteed to a unique among all {\em names}.)

If any $eI$ is a {\em default-value}, then in the above
\begin{indpar}
{\tt $QsI$ $TI$ $tmpI$ = $eI$}
\end{indpar}
is replaced by
\begin{indpar}
{\tt $QsI$ $TI$ $tmpI$ = do ( }{\em prototype-context}{\tt ~):} \\
\hspace*{0.5in}{\tt $tmpI$ = $eI$}
\end{indpar}

If any the statements `{\tt $QsI$ $TI$ $tmpI$ = \ldots}' cannot be compiled
for reasons other than an ambiguity error, the call-prototype match fails.

If any of the statements `{\tt $QsI$ $TI$ $tmpI$ = \ldots}' cannot be compiled
because of an ambiguity error, the call-prototype match
is `\key{ambiguity deficient}' (and will be
rejected later, possibly for another reason).

\item If the {\em function-call} has no result variables, the
{\em function-prototype} must have no result variables,
else the call-prototype match fails.

\item If the {\em function-call} has one result variable of
unknown type, the {\em function-prototype} must have result variables
else the call-prototype match fails.
The type and qualifiers of the first
{\em function-prototype} result variable become the natural
type and qualifiers (\pagref{NATURAL-TYPE})
of the {\em function-call} expression if
the match ultimately is accepted according to the rules below.

\item \label{FUNCTION-CALL-ASSIGNMENT-COMPILATION}
If the {\em function-call} has result variables of known type
as in a statement of the form
\begin{center}
{\tt $QCs1$ $TC1$ $vc1$, $QCs2$ $TC2$ $vc2$, \ldots{}~=~}{\em function-call}
\end{center}
with at least one result variable of known type,
the {\em function-prototype} must be of the form
\begin{center}
{\tt function $QRs1$ $TR1$ $vr1$, $QRs2$ $TR2$ $vr2$,
     \ldots{}~=~}{\em function-pattern}
\end{center}
with at least as many result variables in the prototype as in
the {\em function-call} statement.  The statement is then
replaced by:
\begin{indpar}
{\tt $QRs1$ $TR1$ $tmp1$, $QRs2$ $TR2$ $tmp2$,
    \ldots{}~=~}{\em function-call} \\
{\tt $QCs1$ $TC1$ $vc1$ = $tmp1$} \\
{\tt $QCs2$ $TC2$ $vc2$ = $tmp2$} \\
\ldots\ldots\ldots\ldots
\end{indpar}
If any of the `{\tt $QCsI$ $TCI$ $vc1$ = $tmpI$}' statements cannot be
compiled because $QRsI$ $TRI$ is not implicitly convertible
to $QCsI$ $TCI$, the call-prototype match fails.
Note that extra prototype result variables
are never used and are ultimately ignored.

If $QRs1$ $TR1$ and $QCs1$ $TC1$ are not equal
(but $QRs1$ $TR1$ values are implicitly
convertible to $QCs1$ $TC1$ values), the match is marked
`\key{conversion deficient}'\label{CONVERSION-DEFICIENT},
and will be disallowed later
if there is another match that is not conversion deficient.
Note that only the first result variable is considered by this rule.

\end{enumerate}


The first step in compiling a {\em function-call} is to compute the
set of matches of that call.  Then the following is done in order:

\begin{enumerate}

\item If there is any match that is not conversion deficient, then
all conversion deficient matches are discarded.

\item If there is any remaining match that is not module deficient, then
all module deficient matches are discarded.

\item\label{REQUIRED-ARGUMENTS-PREFERRED}
Let $e1$, $e2$, \ldots{}~be the argument expressions of
the not-unfolded original {\em function-call}, read from left to right.
If there are two matches $X$ and $Y$ such that
some of the $eI$ have
have {\em required-values} in $X$ but not in $Y$, and none of the $eI$
have {\em required-values} in $Y$ but not in $X$,
then the $Y$ match is discarded.

\item\label{MORE-RESTRICTIVE-ARGUMENT-TYPES-PREFERRED}
Let $e1$, $e2$, \ldots{}~be the argument expressions of
the not-unfolded original {\em function-call}, read from left to right.
If there are two matches $X$ and $Y$ such that
$TX1$, $TX2$, \ldots{}~are the types of the $X$ prototype argument
variables assigned to $e1$, $e2$, \ldots{}~in order, and
$TY1$, $TY2$, \ldots{}~are the types of the $Y$ argument
variables assigned to $e1$, $e2$, \ldots{}~in order,
and values of type
$TXi$ are implicitly convertible to values of type $TYi$ for
every $i$,
then the $Y$ match is discarded.

\item If after discarding matches as above, there are no matches,
the {\em function-call} is `\key{unmatched}' and cannot be compiled.

\item If after discarding matches as above, there is more than one
match left,
the {\em function-call} is `\key{ambiguous}' and cannot be compiled.

\item If the remaining match has
an ambiguity deficiency,
the {\em function-call} is `\key{ambiguous}' and cannot be compiled.

\item Otherwise there is just one match left, and that
match has no ambiguity deficiency.  That match
is accepted and used to compile the {\em function-call}.

\end{enumerate}

\section{Special Functions}
\label{SPECIAL-FUNCTIONS}

Note that in this section `\TT{std}' is used as the
{\em module-abbreviation} (\pagref{MODULE-ABBREVIATION})
of the \TT{"standard"} module.
This {\em module-abbreviation} is commonly omitted when
a function is called.

\subsection{Memory Functions}
\label{MEMORY-FUNCTIONS}

The following functions allocate memory and compute addresses.

\begin{indpar}

{\tt function *UNCHECKED* adr r = std \begin{tabular}[t]{@{}l@{}}
				  \ttkey{allocate to static} \\
				  ( unsadr size, \\
				  ~~unswrd alignment ?=~0 )
				  \end{tabular}}

\begin{indpar}
Allocate {\tt size} bytes of memory with the given
{\tt alignment} in bytes to static memory, the memory
allocated when the program is initialized.  Return
the address of this memory.  The address viewed as an
integer is an exact multiple of the {\tt alignment}.

If the
{\tt alignment} is omitted or is given as 0 it is taken
to be equal to the \TT{size} if that is a power of 2
no greater than 16 (the size of a 128 bit value).
Otherwise it is an error if the {\em alignment} is not
a power of 2.

The memory bytes are initialized to zero.

This function does not
execute at compile-time even if its arguments are compile-time.
\end{indpar}

{\tt function *UNCHECKED* adr r = std \ttkey{allocate to static} ( $T$ v )}
\begin{center}
where $T$ is any type
\end{center}

\begin{indpar}
Allocate static memory and set it equal to {\tt v}.  
The alignment of the memory is equal to the alignment of $T$.
Return the address of this memory.  The address viewed as an
integer is an exact multiple of the alignment.

This function does not
execute at compile-time even if its arguments are compile-time.
\end{indpar}

{\tt function *UNCHECKED* adr r =} \\
\hspace*{0in}{\tt ~~~~~~~~~std \ttkey{allocate UTF-8 to static} ( string s )}

\begin{indpar}
Allocate static memory and set it equal to the UTF-8 representation of the
value of {\tt s} with a \TT{NUL} appended.  The memory allocated may be
read-only, meaning that trying to write it will cause a program memory
fault error.

This function does not
execute at compile-time even if its arguments are compile-time.
\end{indpar}

\end{indpar}

Note that
\begin{center}
{\tt allocate to static ( "Hello There" )}
\end{center}
creates a \TT{string} vector containing {\tt "Hello There"},
allocates static memory for a pointer to this vector, stores the
pointer into the static memory, and returns the address of the
pointer.

On the other hand
\begin{center}
{\tt allocate UTF-8 to static ( "Hello There" )}
\end{center}
allocates static memory in which is stored a UFT-8 representation of
{\tt "Hello There"}, and returns the address of this memory.

The following function can be used to embed addresses in 
floating point NaNs or other numeric values.

\begin{indpar}

{\tt function *UNCHECKED* adr r =} \\
\hspace*{0in}{\tt ~~~~~~~~~std \ttkey{extract adr}\label{EXTRACT-ADR}} \\
\hspace*{0in}{\tt ~~~~~~~~~~~~~ ( uns64 v,} \\
\hspace*{0in}{\tt ~~~~~~~~~~~~~~~ unswrd L, unswrd S ?= 0 )}

\begin{indpar}
Take the low order {\tt L} bits of {\tt v}, shift them left by {\tt S},
and return the result as a usable byte address.
If the target machine only uses the low order $k$ bits of a 64-bit
address, the high order $64-k$ bits of the result are set according
to the requirements of the target machine, or are undefined if there
are no such requirements.  If $k>${\tt L+S},
the {\tt L} bits are padded on the left with zero bits.

For example, for an x86 target machine $k=48$ and the high order
17 bits of the returned address must be equal (all 0's or all 1's).
If {\tt L = 40} and {\tt S = 4} then 4+16=20 zero bits of padding are
added on the left.  If {\tt L = 44} and {\tt S = 4}, the high order
bit of the low {\tt L} bits of {\tt v} is sign extended to become
the high order 17 bits of the returned address.
\end{indpar}

\end{indpar}



\subsection{Floating Pointer Error Flag Functions}
\label{FLOATING-POINT-ERROR-FLAG-FUNCTIONS}

The \skey{floating point error flag}s of
section~\itemref{FLOATING-POINT-ARITHMETIC-EXPRESSIONS}
are located in the `\key{floating point error register}' which
is a special register of \TT{unswrd} type.  The following
builtin functions test and manipulate this register.

\begin{indpar}
{\tt function unswrd r = std \ttkey{fp error flags}} \\
{\tt function std \ttkey{clear fp error flags}} \\
{\tt function std \ttkey{clear fp error flags} ( unswrd mask ) } \\
{\tt function std \ttkey{set fp error flags} ( unswrd mask ) }

\begin{indpar}
The first function
above reads the register, the second clears the floating point
error flags in the register, the third clears just the floating point
error flags selected by the bits of \TT{mask}, and the fourth sets just the
flags selected by the bits of \TT{mask}.  The value read from the register
may contain non-zero bits other than the floating point error flags.
\end{indpar}
\end{indpar}

The following functions with no arguments
return compile time constants that are
masks for the floating
point error flags in the floating point error
register.  Each mask has a single bit on.
\begin{center}
\begin{tabular}{ll}
{\tt function unswrd r = std \ttkey{FP INVALID}}	& Invalid operand. \\
{\tt function unswrd r = std \ttkey{FP DIVIDE BY ZERO}}	& Divide by zero. \\
{\tt function unswrd r = std \ttkey{FP OVERFLOW}}	& Result overflow. \\
{\tt function unswrd r = std \ttkey{FP UNDERFLOW}}	& Result underflow. \\
{\tt function unswrd r = std \ttkey{FP INEXACT}}	& Result inexact. \\
\end{tabular}
\end{center}
The value of \TT{mask} above should be a bitwise OR's of these constants.

\subsection{Abbreviation Testing Functions}
\label{ABBREVIATION-TESTING-FUNCTIONS}

The following functions provide information
about regular abbreviations (\pagref{ABBREVIATION-DECLARATION}).

It is a compile error if any argument to these
functions is not a compile time value.  The results returned by these
functions are compile time values.

\begin{indpar}
{\tt function bool r = std ( name N ) \ttkey{is abbreviation}} \\
{\tt function name r = std \ttkey{replacement of} ( name N )} \\
{\tt function name r = std \ttkey{final replacement of} ( name N )}
\begin{indpar}
The first function returns \TT{true} if and only if {\tt N} names
an abbreviation (\pagref{ABBREVIATION-DECLARATION}).

The second function returns the replacement name from the
{\em abbreviation-declaration} of {\tt N}, or returns {\tt N} itself
if {\tt N} is not an abbreviation.  The replacement name may itself
be an abbreviation.

The third function applies the second function recursively until
the name returned is not an abbreviation.
\end{indpar}
\end{indpar}

\subsection{Compiler Functions}
\label{COMPILER-FUNCTIONS}

The following function can be used to produce compile-time
generated names like `\TT{T\TMP$n$}', which are most likely
to be useful in generics (\pagref{GENERICS}).

\begin{indpar}
{\tt function name r = std \ttkey{generated name} ( character c )}%
\label{GENERATE-NAME}

\begin{indpar}
Returns the name `\TT{$c$\TMP$n$}' where $c$ is the value of the
argument and $n$ is a natural-number such that the returned name
is unique among all names generated during the compilation, either
by this function or by the compiler.  $c$ must be an ASCII
letter.
\end{indpar}
\end{indpar}

\subsection{Program Termination Functions}
\label{PROGRAM-TERMINATION-FUNCTIONS}

The following functions are used to terminate program execution
when a programming error is discovered.

\begin{indpar}

{\tt function string r = std \ttkey{call location}}
\begin{indpar}
This function returns a string of the form:
\begin{center}
{\em file-name}\TT{:~line~}{\em line-number}
\end{center}
describing the location of the {\em function-call}
that invoked an inline function containing the call to
`{\tt call location}'.  Here {\em file-name} is either
the {\em module-name} (\pagref{MODULES}) or {\em body-name}
(\pagref{BODIES}) of the file; that is, it is the name of
the file containing the {\em function-call}
relative to one of several directories
specified separately to the compiler.
{\em Line-number} is the number (1, 2, 3, \ldots) of the
line in which the statement containing the {\em function-call}
begins.

This function allows an inline function to be written that
outputs a message containing the location of the call to the
inline function.
\end{indpar}

{\tt function std \ttkey{program stop}}
\begin{indpar}
This function terminates the program abnormally.  It has
the special property that deferred variables that normally
must be set in the block need not be set in an execution
path that includes a call to this function.
\end{indpar}

\end{indpar}


\section{Generics}
\label{GENERICS}

A \key{generic} is an inline function that is completely
evaluated at compile time and that contains special
`\skey{include-statement}s' which generate code that replaces the generic call
in the program.  Within the included code compile time values are substituted
for `\skey{include-argument}s'.

An example is:
\begin{indpar}\begin{verbatim}
generic min-max ( name F, name C )
    include (F, C):
        function T result = F (| type T |) ( T x, T y ):
            result = if:
                (x) C (y):
                    result = x
                (y) C (x):
                    result = y
                T is float:
                    result = NaN

min-max functions ( `min', `"<="' )
int64 u = ...
int64 v = min ( u, -1,000,000 )
min-max functions ( `max', `">="' )
float64 w = ...
next w = max ( w, -1,000,000 )
\end{verbatim}\end{indpar}

Note that {\tt C} is a function call {\em function-term-name} and not
an operator.
Also if {\tt T is float} is \TT{false} the last condition statement
clause is not compiled or checked for errors
(\pagref{MISSING-ELSE-RULE}).

The general syntax is:
\begin{indpar}
\emkey{generic-declaration}\label{GENERIC-DECLARATION}
    ::= \begin{tabular}[t]{l}
        {\em generic-prototype}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{generic-prototype}\label{GENERIC-PROTOTYPE}
    ::= \TT{generic} ~ {\em module-abbreviation}\QMARK{}
                     ~ {\em function-pattern}
\\[0.5ex]
{\em function-pattern} ::= see \pagref{FUNCTION-PATTERN}
\\[0.5ex]
\emkey{generic-call}\label{GENERIC-CALL}
    ::= {\em function-call} ~~~~~ [see \pagref{FUNCTION-CALL}]
\\[0.5ex]
\emkey{include-statement} ::=
    \begin{tabular}[t]{l}
    \ttkey{include} ~ \begin{tabular}[t]{@{}l@{}}
                      {\em include-name}\QMARK{}
                          ~ {\em include-argument-list}\QMARK{} \\
		      \{ \TT{if} ~ {\em compile-time-expression}
		                 ~ \}\QMARK{} ~ \TT{:} \\
		      \end{tabular} \\
    \TT{~~}{\em statement}\STAR{}
    \end{tabular}
\\[0.5ex]
\emkey{include-name} ::=
    \begin{tabular}[t]{l}
    {\em name} ~~~~~ [see \pagref{NAME}] \\
    \underline{not} containing
	`\TT{.}',~ {\em quoted-marks},~ {\em quoted-separators}, or `\TT{if}'
    \end{tabular}
\\[0.5ex]
\emkey{include-argument-list} ::=
    \TT{(} {\em include-argument} \{ \TT{,} {\em include-argument} \}\STAR{}
    \TT{)}
\\[0.5ex]
\emkey{include-argument} ::= {\em word} not containing `\TT{.}'
\end{indpar}

TBD: `include for x in ...'

A {\em generic-prototype} is a {\em function-prototype} and a
{\em generic-call} is a {\em function-call}.  {\em Function-calls}
are matched to all {\em function-prototypes}, including
{\em generic-prototypes}, and those that end up matching just a
{\em generic-prototype} are {\em generic-calls}.

A {\em generic-call} is executed at compile-time and generates a list
of `\skey{included statement}s' that replace the {\em generic-call} in
the compilation.  The included statements are the {\em statements}
of the subblocks at the end of the {\em include-statements} executed
by the called generic function.  If several {\em include-statements}
are executed, the included statement lists they generate are concatenated
in execution order.

Within the included statements generated by an {\em include-statement}
the values of the {\em include-state\-ment}'s
{\em include-arguments} are substituted for the names of these
arguments.  These values must be known at compile-time within the scope
of the {\em include-statement}.  The substitutions depend on the
type of the argument variables as follows:
\begin{indpar}[0.5in]
\hspace*{-0.3in}\ttmkey{name}{include argument}
The argument name is replace by the sequence of lexemes represented by
the \TT{name}.  A {\em name-item} that has the syntax of a {\em word}
or {\em number} lexeme is represented by that lexeme, and all other
{\em name-items} are represented by {\em quoted-strings}.

\hspace*{-0.3in}\ttmkey{uns$x$}{include argument}
The argument name is replace by a single natural number lexeme.

\hspace*{-0.3in}\ttmkey{int$x$}{include argument}
The argument name is replace by a single decimal integer lexeme.

\hspace*{-0.3in}\ttmkey{float$x$}{include argument}
The argument name is replace by a single decimal floating point
number lexeme if the value can be represented exactly by that
lexeme.  Otherwise the argument name is replaced by the two lexeme
hexadecimal number constant representing the value exactly. 

\hspace*{-0.3in}\ttmkey{character}{include argument}
The argument name is replaced by the two lexeme
character constant representing the value. 

\hspace*{-0.3in}\ttmkey{string}{include argument}
The argument name is replaced by a single quoted string lexeme
representing the value.
\end{indpar}

An example is:
\begin{indpar}\begin{verbatim}
generic goo ( name N, name OP,
              character C, string S,
              int32 X, float64 Y, float64 Z )
    include ( N, OP, C, S, X, Y, Z ):
        n --> `N'
        int64 n = 0
        character c = C
        string s = S
        int32 x = X
        float64 y = Y
        float64 z = Z
        float64 v = x OP y
        float64 w = x * z OP y

goo ( `my variable', `"+"', C"<LF>", "Hi There",
      1,234, 1.5, 0.3 )
    // Equivalent to:
    //    n --> `my variable'
    //    int64 my variable = 0
    //    character c = C"<LF>"
    //    string s = "Hi There"
    //    int32 x = 1,234
    //    float64 y = 1.5
    //    float64 z = X"0.4CCCCCCCCCCCCC"
    //    float64 v = x "+" y
    //    float64 w = x "*" ( z "+" y )
\end{verbatim}\end{indpar}

The {\em generic-declaration} is parsed when first encountered
by the compiler, but the included statements are not
compiled.
This means that operators in unparsed form cannot be substituted
in included statements.  So the computation of {\tt w} in the
example substitutes in the parsed expression `{\tt (x) "*" (z OP y)}'
where {\tt OP} has not been identified as an operator by the parser.

Also note that substitution inside name constant brackets such as
\TT{`'} is allowed.

The `\TT{if }{\em compile-time-expression}' option
causes the {\em statements} to be included if and only if the
{\em compile-time-expression} evaluates to \TT{true}.  An example use is:
\begin{indpar}\begin{verbatim}
generic min-max ( name F, name C )
    include ( F, C ):
        function T result = F (| type T |) ( T x, T y ):
            include if not T is float:
                result = if:
                    (x) C (y):
                        result = x
                    (y) C (x):
                        result = y
            include if T is float:
                result = if:
                    (x) C (y):
                        result = x
                    (y) C (x):
                        result = y
                    else:
                        result = NaN
\end{verbatim}\end{indpar}

Only whole {\em statements} can be included, but {\em include-statements}
can be nested.  A nested {\em include-statement} does not have an
{\em include-argument-list} but instead inherits the {\em include-arguments}
of its containing {\em include-statement}.

If an {\em include-statement} $S$ has an {\em include-name} $N$, then
{\em include-statements} nested inside $S$ that do \underline{not}
have the {\em include-name} $N$ are treated as ordinary statements
and not as nested {\em include-statements}.  An example is:
\begin{indpar}\begin{verbatim}
generic compare function prototypes ( type T ):
    include X ( T ):
        generic compare function prototype ( name C )
            include ( C ):
                function bool r = ( T x ) C ( T y )
        compare function prototype ( "<" )
        compare function prototype ( "<=" )
        compare function prototype ( "==" )
        compare function prototype ( "!=" )
        compare function prototype ( ">=" )
        compare function prototype ( ">" )
\end{verbatim}\end{indpar}

The included statements that replace a generic call are compiled in the
current context, and \underline{not} the context of the
generic declaration.  The statements of the generic function
itself, and any default values in the generic prototype,
are compiled in the context of the generic declaration,
just as for an inline function.

If you want code compiled in another
context (\pagref{CONTEXT}), wrap that code in the body of an inline function
declared in that other context.  An example that implements a writable
parameter is:
\begin{indpar}\begin{verbatim}
module "my_module" as mymod
    *UNCHECKED* adr p = allocate to static ( float64 ( 0 ) )
    // Parameter is float64 stored at address p
    // P is not visible in other modules.

    // function to allow reading of parameter
    // by other modules.  Usage is:
    //
    //    float64 v = mymod my parameter
    //
    function mem float64 r, *UNCHECKED* adr r.adr =
            mymod my parameter:
        r.adr = p
\end{verbatim}\end{indpar}

As an additional feature of generics, whenever the word
`\TT{G\TMP*}' appears in the included code, it is replaced
by `\TT{G\TMP$n$}', where $n$ is a natural number unique
to the generic call within the compilation.  This allows
creation of names unique to the generic call.  Note that
`\TT{G\TMP*}' can be part of a name, and not the entire name,
so its replacement is not like the replacement of abbreviations.

The \TT{generate name} function (\pagref{GENERATE-NAME})
may be used to generate other names which can be substituted
for {\em include-arguments}.

\section{Clusters}
\label{CLUSTERS}

A \key{cluster} is a group of related variables.  One variable of
the cluster is the \mkey{base variable}{of cluster} of the cluster, and the
other variables have names that are derived from the
name of the base variable by adding {\em member-selectors}
to the end of the base variable name.  See \pagref{NAMES}.

Thus a cluster
is like a C/C++ structure, but it is a set of variables and not a
piece of memory.

More specifically, the members of the cluster can be named by
adding either a member name beginning with a `\TT{.}' or a
`\TT{[]}' bracketed list of
integer indices to
either the base variable name of the cluster or to another member name
of the cluster.  Two variable names with different base variable names
belong to different clusters.  The indices must be compile time
constants when the member is allocated and written, but may be run time
variables when the member is read.

Variables in clusters are thus organized into trees, with clusters
that have different bases being in disjoint trees.  Any variable in a cluster
can be considered
as the \mkey{root}{of subcluster} of a subtree of cluster members, and
the subtree is called a \key{subcluster}.

The main feature of clusters and subclusters
is that members are passed to or returned
from functions implicitly when their the root variable is named
explicitly.  Furthermore, non-root cluster members \underline{cannot}
be created except as results of function calls.

For example:
\begin{indpar}\begin{verbatim}
define type pointer pair as void
    // if pp is a pointer pair then:
    //   unsadr pp.begin is the offset of the first element
    //   unsadr pp.end is the offset just AFTER the
    //                 last element
    //   mem adr pp.base is the base address that
    //                   is added to the offsets
    //   adr pp.base.adr is the address of pp.base
    //   type pp.type is type of elements pointed at

// Function to allocate a vector of n T's to the stack.
//
function ( stack pointer pair pp,
           unsadr pp.begin,
           unsadr pp.end,
           mem adr pp.base,
           adr pp.base.adr,
           type pp.type ) =
        allocate to stack ( type T, uns32 n ):
    require ( zero value OK ( T ) )
    pp.type = T
    unsadr size = size of ( T ) * n
    *UNCHECKED* void p = allocate to stack ( size )
    pp.base.adr = p.base.adr
    pp.begin = p.offset
    pp.end = pp.begin + size


// Prefix operator to dereference a pointer pair to read
// memory.
//
function ( mem pp.type out,
           unsadr out.offset,
           mem adr out.base,
           adr out.base.adr ) =
        "*" ( stack pointer pair pp,
              type pp.type,
              unsadr pp.begin,
              unsadr pp.end,
              adr pp.base ):
    if:
        pp.begin < pp.end:
            out.offset   = pp.begin
            out.base.adr = pp.base.adr
        else:
            fatal error
                ( "Dereferencing empty pointer pair." )

// Prefix operator to increment the begin pointer of a
// pointer pair.
//
function ( next pp.begin )
        "++" ( stack pointer pair pp,
               unsadr pp.begin )
      next pp.begin = pp.begin + size of ( pp.type )

// Assignment operator for pointer pairs.
//
function ( Q pointer pair pp2,
           unsadr pp2.begin,
           unsadr pp2.end,
           mem adr pp2.base,
           adr pp2.base.adr,
           type pp2.type )
        = ( qualifiers Q,
            Q pointer pair pp,
            type pp.type,
            unsadr pp.begin,
            unsadr pp.end,
            adr pp.base.adr ):
      pp2.begin = pp.begin
      pp2.end = pp.end
      pp2.base.adr = pp.base.adr
      pp2.type = pp.type

// Example usage:
//
function ...

    // Vector of 2 int32's is allocated and the elements
    // are set equal to 100 and 101.
    //
    pointer pair pp = allocate to stack ( int32, 2 )
    next ( * pp ) = 100
    ++ pp
    next ( * pp ) = 101
    . . . .
    // Vector of 1000 float64's is summed.
    //
    pointer pair ppf = allocate to stack ( float64, 1000 )
    ... set 1000 elements ...
    float64 sum = loop:
        initially:
            float64 partial sum = 0
            pointer pair ppf2 = ppf
        while ppf2.begin < ppf2.end:
            next partial sum = partial sum + * ppf2
            ++ ppf2
        finally:
            sum = partial sum
\end{verbatim}\end{indpar}\label{NEXT-CLUSTER-BASE-EXAMPLE}

Note that although the functions defining operations on a pointer pairs
are a long winded, usage of pointer pairs is compact and easy.
This is a general characteristic of the L-Language, and derives
from the fact that the functions automatically manage the members
of a cluster.

Cluster member names may be used as prototype parameter
names, with the root of these names also being a prototype
parameter.  This specifies that the parameters are related
by being in the same cluster.  The arguments with member names
\underline{must} not be given explicit values by function calls,
they must be omitted in the call itself, as they will be given
the values taken from members of the root value given in the call.
If the cluster members named as arguments
in the function prototype do not have corresponding members of the
root value given in the call,
the function prototype does not match the call unless the prototype
member has a default (see \pagref{DEFAULTS-TO} ).

When this is done for prototype results, the cluster root must similarly
be a either a result or argument, and the designated
members of the cluster are created and set from the results.
Again the cluster members \underline{must} be omitted in calls,
but will be automatically created.
Note that when this is done any qualifiers on the omitted cluster
members will be set by the prototypes.

If all result variables are cluster members, then calls
using the prototypes will have no explicit result variables,
but will create new members of existing clusters.  For example:
\begin{indpar}\begin{verbatim}
function ( bool v.nonneg ) = test sign ( int32 v ):
    if:
        v >= 0:
            v.nonneg = true
        else:
            v.nonneg = false

int32 x = 89
int32 y = -5
test sign ( x )
test sign ( y )
// Now x.nonneg exits and is true
// and y.nonneg exits and is false.
\end{verbatim}\end{indpar}

A variable whose underlying type is \TT{void} has no actual value
and must not be assigned one.  Such variables are only useful
as cluster and subcluster roots.  The `\TT{allocate to stack}'
function requires that its result be a variable whose underlying
type is \TT{void} (see \pagref{ALLOCATE-TO-STACK}).

Cluster members may only be created as function call results.

A cluster member may be explicitly passed as a result variable
or argument if it is the root of a subcluster that is being
created or used.  The matching prototype variable must
be a cluster root, and \underline{not} a cluster member,
within the prototype.  If the cluster member being passed is a
result variable, its matching prototype variable declaration must have the
underlying type \TT{void} or be a `\TT{next ...}' result.

The `\TT{qualifiers Q}' argument to the assignment operation
is assigned by implication to qualifiers of the `\TT{pointer pair}'
argument, and these qualifiers are added to the result.

In the above example `\TT{mem}' is a special builtin qualifier
which can be applied to variables.
See \itemref{BUILTIN-QUALIFIERS}.

The `\TT{mem}' qualifier\label{MEM}
has the special property that given a variable
\TT{v} of qualifier \TT{mem}, then if \TT{v} is allocated,
and \TT{v.base} of type \TT{adr}
is allocated and assigned a value
and \TT{v.offset} of type \TT{unsadr}
is allocated and assigned a value, then
the root \TT{v} is automatically
assigned the value located at the RAM address \TT{v.base + v.offset}.
It is an error in this case to explicitly assign a value to \TT{v}.
This is how \TT{out} gets its value from
\TT{out.base}, and \TT{out.offset}.

Similarly if \TT{v.adr} is allocated an assigned a value, then
the root \TT{v} is automatically
assigned the value located at the RAM address \TT{v.adr}.
This is how \TT{out.base} and \TT{pp.base} get their values from
\TT{out.base.adr} and \TT{pp.base.adr} respectively.

For details on the `\TT{mem}' qualifier see \itemref{THE-MEM-QUALIFIER}.

The `\TT{stack}' qualifier has the property that values with
this qualifier may not be passed out of a block with a free
stack.  This keeps stack addresses from escaping contexts in
which they are valid.  See Sections~\itemref{THE-STACK-QUALIFIER} and
\itemref{STACK-MANAGEMENT}.

A qualifier may be \ikey{inherited}{qualifier}\label{INHERITED-QUALIFIER}.
If an inherited qualifier
is applied to the root variable of a cluster
or subcluster, this inherited qualifier is automatically applied to all
the member variables in the cluster or subcluster.  This is not done
for non-inherited qualifiers.

The `\TT{stack}' qualifier is inherited.

Another example of a cluster with implied next variables is:
\begin{indpar}\begin{verbatim}
define type sequence as void
    // if seq is a sequence,
    // seq.count is the number of its elements
    // seq.type is the type of the elements
    // seq[0 .. seq.count - 1] are the elements

// Function to rotate the sequence right 1 position.
//
next seq.count, next seq[0 .. seq.count - 1]
    = right rotate ( sequence seq, unsadr seq.count,
                     type seq.type,
                     seq.type seq[0 .. seq.count - 1]:
    next seq[1 .. seq.count - 1] = seq[0 .. seq.count - 2]
    next seq[0] = seq[seq.count - 1]

// Example usage
//
    sequence s = ...
    rotate ( s )
\end{verbatim}\end{indpar}
Here the \TT{seq.count} and \TT{seq.type} arguments
specify types and member indices
of results and of arguments later in the argument list.  A call's actual
\TT{seq.count} and \TT{seq.type} arguments must be compile time values
in order to be so used.

A last example of the use of clusters is the implementation of
comparison operators so that
\begin{center}
\TT{(x~<~y)~<~z}
\end{center}
is the same as
\begin{center}
\TT{(x~<~y) AND (y~<~z)}
\end{center}
where \TT{y}, if it is an expression,
is not evaluated twice:\label{COMPARISON-RESULTS}
\begin{indpar}\begin{verbatim}
define type comparison result as void
    // if cr is a comparison result then:
    //   bool cr.value is the result of the comparison
    //   type cr.type is the type of the values compared
    //   cr.type last is the last value compared

// Comparison result of x < y where x and y are type T.
//
function comparison result cr, bool cr.value,
         type cr.type, T cr.last =
        (| type T |) ( T first ) "<" ( T last ):
    cr.type = T
    cr.last = last
    cr.value = first less than last

// Comparison result of x < y where x is a comparison result.
//
function comparison result cr, bool cr.value, type cr.type,
         T cr.last =
         ( comparison result cf, bool cf.value, type cf.type,
           cf.type cf.last ) "<" ( cf.type last ):
    cr.type = cf.type
    cr.last = last
    cr.value = cf.last less than last

// Implied conversion of comparison result to bool.
//
function Qs bool result =
    (| qualifiers Qs |) ( QS comparison result cr,
    bool cr.value, type cr.type, cr.type cr.last ):
    result = cr.value
\end{verbatim}\end{indpar}

Cluster variables can be grouped into `\skey{slice}s', see
\pagref{SLICE}.  A slice can be allocated and passed
as an argument as if it were a single variable.  When cluster
variables or slices containing {\em member-indexes} are allocated,
the {\em member-indexes} must be defined at compile time.
When these variables or slices are read, the
{\em member-indexes} can be run time.

\section{Builtin Qualifiers}
\label{BUILTIN-QUALIFIERS}

The builtin qualifiers are \TT{mem}, \TT{stack}, \TT{*UNCHECKED*},
and \TT{global}.
There is also a special class of qualifiers called trace qualifiers.

\subsection{The Memory Qualifier}
\label{THE-MEM-QUALIFIER}

The \ttkey{mem} qualifier is a protected qualifier that behaves
in a special way when it is given to a variable \TT{v}.
In this situation \TT{v} is a copy of a RAM memory value and
must be in a cluster that
has either:
\begin{enumerate}
\item
A variable \TT{v.adr} of type \TT{adr} with either of the qualifiers
\TT{mem} or \TT{*UNCHECKED*} that is the RAM address of \TT{v}.

\item
A variable \TT{v.offset} of type \TT{intadr} or \TT{unsadr} and
qualifier \TT{*UNCHECKED*}, and
a variable \TT{w.base} of type \TT{adr} and qualifier \TT{mem}
or \TT{*UNCHECKED*} where \TT{w} is either \TT{v} or an ancestor
of \TT{v} in the cluster (if there are several such ancestors, the
closest to \TT{v} is selected).
In this case the RAM address of \TT{v} is \TT{v.offset+w.base}.
If \TT{w.base} has qualifier \TT{mem} it must recursively obey these
rules (so there must be either a \TT{w.base.adr} variable
or \TT{w.base.offset} and \TT{u.base} variables where \TT{u}
is either \TT{w.base} or an ancestor of \TT{w.base} in the cluster, etc.).
\end{enumerate}
The the
variable \TT{v} must \underline{not} be given a value by an
assignment statement, but will instead be loaded with a value
from its RAM address.  It is called a `\key{RAM cache variable}'.

An example is:

\begin{indpar}\begin{verbatim}
// In C/C++:
//     struct foo_struct { int a, b, c }
//     typedef foo_struct * foo
//
// Here a cluster foo, foo.a, foo.b, foo.c
// where foo is an address.
//
define type foo as void
define type foo_ptr as adr
function foo x, adr x.base,
         mem int32 x.a, x.a.offset,
         mem int32 x.b, x.b.offset,
         mem int32 x.c, x.c.offset
        = "*" ( foo_ptr x ):
    x.base = x
    x.a.offset = 0
    x.b.offset = 4
    x.c.offset = 8

// Usage:
//
foo_ptr zp = ... // assign adr to zp
foo z = * zp     // Assign to z.base, z.a.offset, ...
... z.a ...      // Use z.a
next z.a = ...   // Write z.a

\end{verbatim}\end{indpar}

If a RAM cache variable is not used, it will not actually be loaded
from RAM.  If two RAM cache variables are explicitly given the
same address, the two variables will be treated as the same variable
(i.e., a variable with two names).  For example:

\begin{indpar}\begin{verbatim}
    mem int32 w
    adr w.adr = ...
    mem int32 v
    adr v.adr = w.adr
        // v and w are two names for the same variable.
\end{verbatim}\end{indpar}

If \TT{v} is a RAM cache variable, assigning a value to `\TT{next v}'
writes the value to RAM.  For example:

\begin{indpar}\begin{verbatim}
    mem int32 v
    adr v.adr = ...
    next v = ...       // Writes value to v.adr
\end{verbatim}\end{indpar}

If the original value of \TT{v} was never used, it will not be
read from RAM even \TT{v} is written in this way.

TBD: Need a *WRITABLE* qualifier to allow writing this way.

Because \TT{mem} is a protected qualifier, \TT{v} and the required
members of the cluster of which \TT{v} is a root
must be created as matches to result variables of a function.
So only functions can effect a load of RAM contents to a variable.

There is a special function of zero arguments, \TT{NULL}, of result
type \TT{adr}, that
references a block of 4,096 bytes of virtual memory that is
inaccessible and will cause a segmentation fault if referenced.


\subsection{The Stack Qualifier}
\label{THE-STACK-QUALIFIER}

The `\ttkey{stack}' qualifier is an inherited, prohibited,
protected qualifier
attached to offsets and addresses
returned by the builtin `\TT{allocate to stack}'
function (\pagref{ALLOCATE-TO-STACK}).
It is used to keep these from being stored in
non-stack memory and in stacks who lifetime exceeds that of the
memory the stack address points at.

The special property of the `\TT{stack}' qualifier is that it cannot
be used to qualify variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
or iteration variables in a {\em loop-assignment-statement}.
This is so that stack addresses pointing into a free stack
cannot outlive the free stack.
See Section~\itemref{STACK-MANAGEMENT} for more information.

Also, as a prohibited qualifier, a \TT{stack} value cannot be
passed as an argument to a function that does not expect a
\TT{stack} value.  For example:
\begin{indpar}\begin{verbatim}
stack adr sa = ...
adr ta = ...
function adr result = F ( adr arg ):
    . . . . . . . . . .
function adr result = G ( stack adr arg ):
    . . . . . . . . . .
adr xa = F ( sa ) // Illegal; F's arg does not have
                  // stack qualifier.
adr ya = G ( sa ) // Legal; G's arg has stack qualifier.
adr za = G ( ta ) // Legal; G's arg's stack qualifier has
                  // no effect (its not required).
\end{verbatim}\end{indpar}

\subsection{The \TT{*UNCHECKED*} Qualifier}
\label{THE-UNCHECKED-QUALIFIER}

The \TT{*UNCHECKED*} qualifier is a
required qualifier that must qualify the \TT{v.adr} or
\TT{v.offset} variables
associated with a variable \TT{v} that has the \TT{mem} qualifier.
See Section~\itemref{THE-MEM-QUALIFIER}.

The \TT{*UNCHECKED*} qualifier is also required for the result variable
of an unchecked conversion.  When used for a result variable of an
assignment, the value assigned need only be convertible to the type
of the variable by an unchecked conversion, instead of by a checked
conversion.

The \TT{*UNCHECKED*} lexeme is also used as the initial part some
names. An example is the \TT{*UNCHECKED* *ASSEMBLY*} assignment statement.

\subsection{Trace Qualifiers}
\label{TRACE-QUALIFIERS}

A \key{trace qualifier} permits values to be marked so that they
can be found (i.e., `traced') by garbage collectors
(and occasionally debuggers)
when they are stored in the
stack.  A trace qualifier may be declared by:

\begin{indpar}
\emkey{trace-qualifier-declaration}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{trace qualifier}
           {\em defined-qualifier-name} \\
        & ~~~~~ \TT{with base type}~~{\em type-name}
    \end{tabular}
\end{indpar}

The base type of a trace qualifier may be determined by the
function with the prototype:
\begin{center}
{\tt (type T) = \ttkey{base type of} ( qualifier Q )}
\end{center}
The value of any variable with the trace qualifier must be
\TT{*UNCHECKED*} convertible to a value of the base type.

It is common to add a trace qualifier to the statement that
defines a type you want to trace.  An example in which the
qualifier is \TT{Q} and the type is \TT{T} is:
\begin{indpar}\begin{verbatim}
trace qualifier Q with base type adr
define type Q T as adr
\end{verbatim}\end{indpar}
which causes all values of type \TT{T} in the stack to be
traced.

More specifically, when a value \TT{V} of a variable with the trace
qualifier \TT{Q} and base type \TT{B} is added to a stack,
\TT{V} converted to type \TT{B} is also
pushed into a (virtual or physical) \TT{Q}-stack of values of
type \TT{B}.
When the stack containing \TT{V} is freed, the corresponding
value in the \TT{Q}-stack is popped.  There is a \TT{Q}-stack
associated with every process and every global area.
Using functions in the
subroutine library (see TBD), these \TT{Q}-stacks can be read.

While a value may be pushed into a stack more than once,
a value will not be pushed if the compiler can prove it is already
in the stack.  Thus given the definitions above, in
\begin{indpar}\begin{verbatim}
T v = ...
T w = v
\end{verbatim}\end{indpar}
the first statement may push the value of \TT{v} to the \TT{Q} stack
but the second statement will not push the value of \TT{w} on
the grounds that it is already in the stack.

\subsection{The Reload Statement}
\label{THE-RELOAD-COMMAND}

The reload statement has the syntax:
\begin{indpar}
\emkey{reload-statement} ::=
    \ttkey{reload} {\em qualifiers} \{ \TT{,} {\em qualifiers} \}\STAR{} \\
\emkey{qualifiers} ::= {\em qualifier} $|$ {\em qualifier-set} \\
\emkey{qualifier} ::= {\em expression} evaluating to a qualifier \\
\emkey{qualifier-set} ::= {\em expression} evaluating to a qualifier set
\end{indpar}

This statement declares the values of all variables with the designated
qualifiers to be out-of-date and unusable.  If any of these variables
is used subsequently, statements to recompute the variable value
will be inserted automatically into the code at the point of the
\TT{reload} statement.  If this is not possible the compilation will
be in error.

As a special case, if a variable that is declared to be out-of-date,
\TT{v}, has the `\TT{mem}' qualifier, and is in
a cluster that causes \TT{v} to be loaded from memory
(as per Section~\itemref{THE-MEM-QUALIFIER}), then if \TT{v} is declared
to be out-of-date, recomputing \TT{v} just means that \TT{v}
is reloaded from RAM.  The possibility that software cache
variables (with the \TT{mem} qualifier) will become out-of-date because
the RAM locations they cache have changed is the reason the \TT{reload}
statement exists.

The statement
\begin{center}
\TT{reload mem, mem dependent}
\end{center}
is commonly used to declare all
variables that act as software caches of memory, and all variables
that should be updated when the caches are updated, to be out-of-date.

Note that variables computed from out-of-date variables are \underline{not}
declared to be out-of-date.

If an out-of-date variable value is not used after the \TT{reload} statement,
it is not recomputed.

Variable values are recomputed in the same order as they were
originally computed.  How each variable is recomputed depends upon
how it was originally computed.

If a variable \TT{v} was originally computed by
a {\em simple-assignment-statement}
of the form `{\em type} \TT{v =} {\em expression}', then if
no input to {\em expression} has been recomputed, \TT{v} does not
need to be recomputed.  Otherwise \TT{v} is recomputed by re-executing
the assignment statement.

If a variable without a \TT{mem} qualifier needs to be
recomputed and was computed by other than
a {\em simple-assignment-statement}, it is a compile error if the
variable is marked out-of-date and later used.

The \TT{reload} statement behaves like an executable statement but
it has some unusual properties when it is executed inside a
nested subblock.  First, it declares out-of-date any variable with
the given qualifiers that is visible in its subblock \underline{and any
containing block}.
Second, it will recompute any out-of-date variable in its subblock
\underline{or any containing block} that may be used after the
\TT{reload} statement executes.
Third, when it recomputes variables, it overwrites
the place the variable is stored, rather than allocating a new
place as would a `\TT{next~}{\em variable-name}' expression.
These properties allow `\TT{reload Q}' to appear in an inline
or conditional subblock.

\section{Memory Write Statements}
\label{MEMORY-WRITE-STATEMENTS}

Statements that write memory make use of cluster structures
similar to those used with
\TT{mem} qualifier variables:
see Section~\itemref{THE-MEM-QUALIFIER}.

Specifically, memory needs to be addressed.  This is done by either
of the following methods of specifying a RAM address:
\begin{enumerate}
\item
An `\key{address variable} \TT{va}
of type \TT{adr} with either of the qualifiers
\TT{mem} or \TT{*UNCHECKED*} that contains the RAM address.
If \TT{va} has qualifier \TT{mem} it must obey
the rules of Section~\itemref{THE-MEM-QUALIFIER}.


\item
An `\key{address variable}' \TT{vo} of type \TT{intadr} or \TT{unsadr} and
qualifier \TT{*UNCHECKED*} in a cluster, and
a variable \TT{vb.base} of type \TT{adr} and qualifier \TT{mem}
or \TT{*UNCHECKED*} where \TT{vb} is either \TT{vo} or an ancestor
of \TT{vo} in its cluster.
In this case the RAM address is \TT{vo+vb.base}.
If \TT{vo.base} has qualifier \TT{mem} it must recursively obey
the rules of Section~\itemref{THE-MEM-QUALIFIER}.

\end{enumerate}

An address variable may be the member \TT{v.adr} or \TT{v.offset}
of a cluster with RAM cache variable \TT{v}.  In this case the
address variable is said to be the `\mkey{address}{of RAM cache variable}'
of the RAM cache variable \TT{v}.

\subsection{Single Value Write Statements}
\label{SINGLE-VALUE-WRITE-STATEMENTS}

The form of a single valued write statement is:

\begin{indpar}
\emkey{single-value-write-statement} ::=
    \TT{*WRITE*} {\em value-variable} {\em address-variable}
\end{indpar}

The value in the {\em value-variable} is written to the RAM address
in the {\em address-variable}.  If the {\em address-variable} is the
address of a RAM cache variable \TT{v}, the write statement does
\underline{not} update \TT{v} or create `\TT{next v}'.

\subsection{Memory Copy Statements}
\label{MEMORY-COPY-STATEMENTS}

The form of a memory copy statement is:

\begin{indpar}
\emkey{memory-copy-statement} ::=
    \TT{*COPY*} {\em source-variable} {\em destination-variable}
    		{\em length-variable}
\end{indpar}
Bytes are copied from the RAM address in the {\em source-variable}
to the RAM address in the {\em destin\-ation-\EOL variable}.
The number of bytes copied is in the {\em length-variable},
which must be of the \TT{unsadr} type.

If the source address is greater than the destination address,
the bytes are copied in ascending address order.  If the
source address is less than the destination address,
bytes are copied in descending address order.  If the two
addresses are equal, bytes may or may not be copied.  The effect of
all this is to copy regions of memory correctly even if they
overlap.


\subsection{Memory Set Statements}
\label{MEMORY-SET-STATEMENTS}

The form of a memory set statement is:

\begin{indpar}
\emkey{memory-set-statement} ::=
    \TT{*SET*} {\em value-variable} {\em address-variable}
    		{\em length-variable}
\end{indpar}
The `set length' is stored in the {\em length-variable} which must
be of \TT{unsadr} type.  As long as the set length is not zero,
this statement performs a \TT{*WRITE*} operation on its
first two arguments, and then increments the address by
the length of the type of the value, and decrements the set length
by one.

\subsection{Atomic Memory Statements}
\label{ATOMIC-MEMORY-STATEMENTS}

An \key{atomic-memory-statement} is a generalization of
the classic compare-and-set instruction.  It is a block assignment
statement that executes a sequence of specialized instructions:

\begin{indpar}
\emkey{atomic-memory-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \TT{( uns32 count, adr bad address ) = }\ttkey{*ATOMIC*} \TT{:} \\
	\TT{~~~~}{\em lock-instruction}\STAR{} \\
	\TT{~~~~}{\em compare-instruction}\STAR{} \\
	\TT{~~~~}{\em write-instruction}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{lock-instruction} ::= \ttkey{*LOCK*} {\em lock-variable} \\
\emkey{compare-instruction} ::= \ttkey{*COMPARE*} {\em compare-variable}
						  {\em address-variable} \\
\emkey{write-instruction} ::= \\
\hspace*{0.2in}\begin{tabular}[t]{rl}
        & \TT{*WRITE*} {\em value-variable} {\em address-variable} \\
    $|$ & \TT{*COPY*} {\em source-variable} {\em destination-variable}
    		      {\em length-variable} \\
    $|$ & \TT{*SET*} {\em value-variable} {\em address-variable}
    		     {\em length-variable} \\
    \end{tabular}
\end{indpar}

The special instructions,
which make use of clusters (Section~\itemref{CLUSTERS}),
and are as follows:
\begin{indpar}[0.4in]
\hspace*{-0.2in}{\em \bf Lock-Instruction}.
The {\em lock-variable} is of type \TT{uns32}
and identifies the lock.
The lock is a binary test-and-set lock provided by the
underlying system.  Locks are allocated to sets of processes
that share memory, so that if any process in the set gets
the lock, other processes in the set cannot.

The lock instruction sets the lock and succeeds if the lock
was not already set, and otherwise just fails.

When the {\em atomic-assignment-statement} terminates, either
successfully or when it fails, all locks gotten are released in
reverse order.

\hspace*{-0.2in}{\em \bf Compare-Instruction}.
The compare
instruction reads the value at the {\em address-variable} designated
address and compares
it to the value of the {\em compare-variable}.  The instruction
succeeds if the values are equal, and fails otherwise.

The {\em compare-variable} may be a RAM cache variable whose
address is the {\em address-variable}.  The RAM cache variable
is not changed even if the value read does not match its value.

\hspace*{-0.2in}{\em \bf Write-Instructions}.
These do what they normally do, except they are all dry-run 
before any actually execute.  During the dry-run one of these
instruction fails if any memory reference it makes would fail
were the instruction actually executed.  In particular, if any
piece of memory is paged out or not in RAM, the dry-run fails.
\end{indpar}

The `\TT{count}' value returned by the {\em atomic-memory-statement}
equals \TT{0} if the statement succeeds, or is the number of the
first failed instruction in the statement block if the statement
fails (the first instruction is number \TT{1}).
The `\TT{bad address}' value is \TT{0} unless the block
fails because of a memory fault, in which case the `\TT{bad address}'
value is set to the faulting address.  One usually deals with a faulting
address by reading it with a normal instruction if it is a read fault,
or writing it with a normal instruction that does not change its
value if it is a write fault (this may require a compare and set
assembly instruction),
and then retrying the \TT{*ATOMIC*} block.

Interrupts of all kinds are disabled during the execution of an
{\em atomic-memory-statement} so the statement will execute as
fast as the underlying hardware will allow.  However, this means
that memory paging is disabled, so instructions will fail if
they page fault.  This is the reason for the dry-run of the
{\em write-instructions}, to be sure they will not fail
when they actually write data.

A system may put restrictions on the size of the value in
a {\em length-variable}, and on the number of instructions
in an \TT{*ATOMIC*} block, in order to ensure that interrupts
are not disabled for very long.  Violation of these restrictions
causes a \TT{*ATOMIC*} block instruction fault that is distinct
from \TT{*ATOMIC*} block failures described above (such violations
are not recoverable).

\section{Stack Management}
\label{STACK-MANAGEMENT}

Each execution thread has a stack that is not in any other
stack.  Each out-of-line function
execution is a block execution that has a stack which is
by default a substack of the thread in which the function
execution is running.  Each subblock in turn has a stack
which is by default a substack of the stack of its containing block.
And each global area has a stack that is not in any other stack.

Conceptually, the assignment statements in a block each allocate memory for
their variable to the current block stack and copy values to these
variables.  As noted above (Section~\itemref{ASSIGNMENT-STATEMENTS}),
the memory and associated copies may be
optimized away in some cases.

Stacks are either free or bound.\label{FREE-STACK}
A bound stack is a substack that is
not deallocated from memory until its smallest containing free stack is
deallocated.  The main reason this is important is that stack addresses
can be passed out of a block with a bound stack to its containing block,
but cannot be passed out of a block with a free stack to its containing
or calling block.  This is implemented by giving certain
variables the `\TT{stack}' qualifier: see
Section~\itemref{THE-STACK-QUALIFIER}.

Stacks of out-of-line function executions
(\pagref{OUT-OF-LINE-FUNCTIONS}),
out-of-line assignment statement blocks
(\pagref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}),
and
compile-time assignment statement blocks
(\pagref{COMPILE-TIME-ASSIGNMENT-STATEMENTS})
are free, and variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
may \underline{not} have the `\TT{stack}' qualifier.

Stacks of loop iteration subblocks are free, and
variables in the {\em result-variable-list}
and iteration variables
of a {\em loop-assignment-statement} may not have the `\TT{stack}'
qualifier.  However, stacks of loop `\TT{initially}' and `\TT{finally}'
subblocks are not free.

Global area stacks (see Section~\itemref{GLOBAL-AREAS}) are free,
but are never deallocated and make no use of the `\TT{stack}'
qualifier.

All other stacks are bound.  Memory allocated to them
by the `\TT{allocate to stack}' function (\pagref{ALLOCATE-TO-STACK})
is actually
allocated to their smallest containing free stack, and not deallocated
until that free stack is deallocated.

Free stacks are relocatable and can be moved.
Substacks cannot move independently,
but move whenever their smallest containing free stack moves.
Any stack address is relative to its containing free stack,
which is the current free stack at the time executable code uses
the stack address.  To accommodate this builtin memory read-write
functions will not only accept an \TT{adr} value as a RAM address,
but also accept a RAM address consisting of an \TT{unsadr}
offset within the stack and a stack base address that is itself
stored in RAM.  See Sections~\itemref{THE-MEM-QUALIFIER}
and \itemref{STACK-MEMORY-ALLOCATION}
for details.

There are a couple of situations in which free stacks move.

Memory of runtime determined size can be allocated to the end of
a stack by the `\TT{allocate to stack}' and `\TT{allocate to global}'
functions described below, and such may
require that the smallest containing free stack
be moved to a memory region where there is more free memory available.

In a program being debugged, free stacks may be saved after they are no
longer needed by the program, in order to permit them to be analyzed
by a debugger if the program detects an error.  In this situation
free stacks are allocated to a very big circular buffer, and overwritten
after they are no longer needed by the program.  It may happen that
a free stack whose block is still running is in the way of allocating
a new stack to the circular buffer, in which case the still running
block's free stack may be moved.

Lastly, global area stacks (\pagref{GLOBAL-AREAS})
may be deallocated when programs that
can reference them are still running, or may not yet be allocated
when these programs run.  Deallocated global area stacks are treated as if
they were allocated to inaccessible memory, so deallocating these stacks
is like moving them to inaccessible memory, and referencing
them when they are deallocated gives a memory fault.


\subsection{Unwind Blocks}
\label{UNWIND-BLOCKS}

\ikey{Unwind blocks}{unwind block} are executed only when their
containing block terminates:

\begin{indpar}
\emkey{unwind-block}
    ::= \begin{tabular}[t]{l}
	\ttkey{*UNWIND*}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

Specifically, when an unwind block is encountered while
executing its containing block, the unwind block is marked
as enabled, but is skipped.  Then when the containing block
terminates, all its enabled unwind blocks are executed in
the reverse order of that in which they were enabled.

Unwind blocks are used to close or deallocate things that were opened.
For example, right after a statement that opens a file there may be
an unwind block that closes the file.  This ensures that the file
will be closed even if the block that opened it terminates later
prematurely with an error, such as a memory fault.

\subsection{Throw and Catch}
\label{THROW-AND-CATCH}

\TT{*THROW*} and \TT{*CATCH*} statements are used to implement
exceptions, i.e., abnormal termination.

\begin{indpar}
\emkey{throw-statement} ::= \TT{*THROW*} \\[1ex]
\emkey{catch-statement} ::= \TT{*CATCH*}
\end{indpar}

The \TT{*THROW*} statement causes its containing block to
\ikey{terminate abnormally}{abnormal termination}.
When a block terminates abnormally, its containing
block is also terminated abnormally.

\ikey{Normal termination}{normal termination}
of a block occurs at the end of the block if
the block has not executed a \TT{*THROW*} or an abnormally
terminating subblock.

Any enabled \TT{*UNWIND*} subblocks of an abnormally terminating
block are executed in reverse order, just as they would be if
the block were terminating normally.  No other part of the block
is executed.

If an \TT{*UNWIND*} subblock executing in an abnormally terminating
containing block \TT{B}
executes a \TT{*CATCH*} statement, the termination of this
containing block \TT{B}
is changed from abnormal to normal.  This means
that \TT{B}'s containing block \TT{C} will resume when the now
normally terminating block \TT{B} finishes terminating.
However, \TT{B} will not execute anything but enabled \TT{*UNWIND*}
subblocks, as it is still terminating.

Machine errors, i.e. memory segment faults, invoke callable functions
which can record error information and execute a \TT{*THROW*}.
Similarly detected programming or data errors can record
error information and execute a \TT{*THROW*}.  An \TT{*UNWIND*}
block can look at recorded error information and decide whether
or not to execute a \TT{*CATCH*}.

If a block has result variables it must assign, then these need not be
assigned if the block terminates abnormally, as they will not
be visible to enabled \TT{*UNWIND*} blocks.  However, if a block \TT{B}
that is terminating abnormally executes a \TT{*CATCH*} statement in
one of its \TT{*UNWIND*} subblocks,
all result variables that block \TT{B} must assign must be given values, even
though part of block \TT{B} may not have executed.  The compiler
will check this, and will only permit code that passes straight forward
compiler checks.

There are two ways to ensure correct code.  The first is to 
set all block result variables either in or before the
\TT{*UNWIND*} block that contains the \TT{*CATCH*} statement.
The second is to use the special variable
\ttkey{*LAST-ENABLED-UNWIND*} inside the \TT{*UNWIND*} block.
This variable is \TT{true} if and only if the \TT{*UNWIND*}
block is the last \TT{*UNWIND*} block enabled in its containing
block, and so if the variable is \TT{true}, any containing
block result variables set after the \TT{*UNWIND*} block need to be
set.  The compiler will accept a statement of the form:
\begin{indpar}\begin{verbatim}
if:
    *LAST-ENABLED-UNWIND*:
        result-variable-1 = ...
        result-variable-2 = ...
	. . . . . . . . . . . .
\end{verbatim}\end{indpar}
where the result variables set are those set after the \TT{*UNWIND*}
block, thus satisfying the requirement that all result variables be set.

[TBD: Maybe default clauses should exist for all block style
assignment statements and execute at the beginning, setting
values for result variables that will be available outside
the block if the block does not set any values itself.]

\subsection{Stack Memory Allocation}
\label{STACK-MEMORY-ALLOCATION}

The `\ttkey{allocate to stack}' function allocates \TT{N} bytes of
memory to the current free stack and returns its offset within
the stack and the address of the stack base address:

\begin{indpar}\tt\begin{tabular}{l}
function *UNCHECKED* T result, \\
~~~~~~~~~stack unsadr result.offset, \\
~~~~~~~~~stack mem adr result.base, \\
~~~~~~~~~adr result.base.adr = \\
~~~~\ttkey{allocate to stack} ( type T, unsadr N ) \\
~~~~~~~~[| underlying type of T == void |]
\end{tabular}\end{indpar}\label{ALLOCATE-TO-STACK}

Here `\TT{result.offset}' is the offset of the \TT{N} bytes within the
stack, `\TT{result.base}' is the base address of the stack, and
stack, `\TT{result.base.adr}' is the address of where this
base address is stored in RAM.  The first and last of these
are fixed but `\TT{result.base}' may change when the stack is
moved.

TBD: result.base does not need to be returned.

The returned values use
the `\TT{stack}' qualifier (see \itemref{THE-STACK-QUALIFIER}),

The memory is freed when the free stack to which it is allocated
is freed (\itemref{STACK-MANAGEMENT}).
The memory containing the \TT{base} value may also be
freed at this time.  The inherited `\TT{stack}' qualifier is used to
ensure that addresses of these values cannot survive the free stack:
see \itemref{THE-STACK-QUALIFIER}.

The memory allocated is always aligned on an \TT{8} byte boundary.

If you want a different alignment you can use:

\begin{indpar}\tt\begin{tabular}{l}
function *UNCHECKED* T result, \\
~~~~~~~~~stack unsadr result.offset, \\
~~~~~~~~~stack mem adr result.base, \\
~~~~~~~~~adr result.base.adr = \\
~~~~\ttkey{allocate to stack} \\
~~~~~~~~~~~~( type T, unsadr N, unsadr O, unsadr A ) \\
~~~~~~~~[| underlying type of T == void |]
\end{tabular}\end{indpar}

where \TT{A} must be a power of \TT{2} not greater than \TT{64}.
This will align the \TT{O+1}'st
byte of the allocated memory block
at an address which is a multiple of \TT{A}\,.
Free stacks are always allocated on a \TT{64} byte boundary.

The `\TT{allocate to stack}' inline functions may move stacks.
Therefore it executes a
\begin{center}
\TT{reload mem, mem dependent}
\end{center}
statement.


\subsection{Global Areas}
\label{GLOBAL-AREAS}

A global area is like the stack frame of a function that has no
arguments or return value, except that after this function executes,
the global area remains allocated and its variables can be referenced
by other code.  The syntax is:
\begin{indpar}
\emkey{global-area-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	{\em global-area-option}\STAR{}
	\TT{global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular} \\
\emkey{global-area-option} ::= \ttkey{*COMPILE-TIME*}
                           $|$ \ttkey{*COMPILE-TIME-ONLY*}
\end{indpar}

Several such blocks may have the same {\em global-area-name},
as long as no {\em variable-name} appears in more than one of these blocks.

In order to be accessed a global area must be named in an `\TT{extern}'
statement:
\begin{indpar}
\emkey{extern-global-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	\TT{extern} {\em global-area-abbreviation}
	            \TT{is global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em extern-variable-statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{extern-variable-statement} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & {\em variable-abbreviation} \TT{is}
          {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\end{indpar}

A variable with {\em variable-name}
\TT{V} in a global area with {\em global-area-abbreviation}
\TT{A} may be named as \TT{A.V}, or if the variable has its own
{\em variable-abbreviation} \TT{VA},
this by itself (and \underline{not} \TT{A.VA})
may be used to name the variable.  An abbreviation is only effective
withing the scope of the `\TT{extern}' statement that defines it.

A variable in an
{\em extern-variable-statement} must match its corresponding
{\em global-area-block} variable with respect to type and qualifiers
in the same manner as a function prototype argument variable
matches a function call variable.

The {\em global-area-block} containing \TT{A.V} need not be compiled
or loaded before the {\em extern-global-block} referencing
\TT{A.V} is compiled or loaded.  This means a runtime reference
can be made to \TT{A.V} when it does not exist.  Such a reference
will incur a runtime error, typically a segmentation fault.

Memory within a global area can be allocated by:

\begin{indpar}\tt\begin{tabular}{l}
( T result, \\
~~global unsadr result.offset, \\
~~mem adr result.offset.base, \\
~~global adr result.offset.base.adr  ) = \\
~~~~\ttkey{allocate to global} ( type T, unsadr N ) \\
~~~~~~~~[| underlying type of T == void |]
\\[1ex]
( T result, \\
~~global unsadr result.offset, \\
~~mem adr result.offset.base, \\
~~global adr result.offset.base.adr  ) = \\
~~~~\ttkey{allocate to global} \\
~~~~~~~~~~~~( type T, unsadr N, unsadr O, unsadr A ) \\
~~~~~~~~[| underlying type of T == void |]
\end{tabular}\end{indpar}\label{ALLOCATE-TO-GLOBAL}

Here \TT{A} must a power of \TT{2} not greater than \TT{64}.
Global areas are allocated on a \TT{64} byte boundary and
may be moved during execution.

Global area variables \underline{cannot} be written to, but memory allocated
by `\TT{allocate to global}' can be.

The `\TT{allocate to global}' function plays the same role for
global areas as the `\TT{allocate to stack}' function does for
stacks, accept that the address gets the \TT{global} qualifier
instead of the \TT{stack} qualifier.  The \TT{global} qualifier
is a protected, inherited qualifier
with \underline{none} of the special `\TT{stack}'
qualifier properties, and normally has no effect on code.

The `\TT{allocate to global}' inline functions may move
global areas and therefore executes a
\begin{center}
\TT{reload mem, mem dependent}
\end{center}
statement.

Global areas are run time by default.
The code of a run time
global area block is executed when the file containing it is
loaded, and the stack of the area is allocated and defined when
the global area block is executed.
Global areas may be deallocated or moved during execution.
References to a global area
that is not yet allocated or that has been deallocated cause runtime
errors (typically segmentation faults).

Global areas may also be made compile time, or both compile and run time,
by use of the \TT{*COM\-PILE-\EOL TIME-\EOL ONLY*} or \TT{*COMPILE-\EOL TIME*}
{\em global-\EOL area-\EOL options} above.  For a compile time
global area, global area blocks are executed in the compiler immediately
after the block compiles, and the global area stack exists in the compiler.
If the global area is also run time, its
block code will be re-executed in the run time environment when the
file containing it is loaded, and might produce different stack contents
for the area than the compile time version of the area.

\section{Memory Channels}
\label{MEMORY-CHANNELS}

OLD STUFF: REVISE.

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
structured set of elements each associated with a member of
some data set.  Each window element contains a
\key{block descriptor} that holds the address and length of the
memory block that contains the data associated with the element.
Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
The window has a \key{reference point}, and window elements are addressed
relative to this reference point.  There are shift operations that move
the reference point to a nearby window element.

Although we talk about blocks here, a block can be just a numeric array
element, and can be as small as a single bit.  Although we talk about
each element of a memory channel window having its own block descriptor,
an actual memory channel may use only block group descriptors, each of
which functions as a group of more than one individual element
block descriptor.

A memory channel is stored in a cluster.  As such it is mostly an
inline construction, though it can be passed to or returned from a
function, and the function can be all or partly out-of-line.

The most common type of memory channel has a window that appears to be
an array with \ttikey{.di\-men\-sions}{dimensions!of memory channel},
\ttdmkey{lower\_bound}{of memory channel}\TT{[}$i$\TT{]},
and \ttdmkey{upper\_bound}{of memory channel}\TT{[}$i$\TT{]}
being memory channel members.  Such are called
\key{array windows}.
If the memory channel cluster name is $M$, the window elements are
referred to by $M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]},
with $M$\TT{[0,0,}\ldots\TT{]} being the \key{reference point}.

The reference point can be shifted along any of the window's
dimensions by the command
\begin{center}
$M$\ttdkey{center}\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]}
\end{center}
This shifts
the window so that what was
$M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]} becomes
$M$\TT{[0,0,}\ldots\TT{]}.

Creating memory channels and completely resetting their reference points
are specific to the type of memory channel, and are not covered in
this section.

For most kinds of memory channels, block descriptors are computed
automatically when channel is created, when the window is
shifted, or when the data of
a neighboring window element is arrives from memory.
Immediately after a block descriptor is created, a read-ahead of
the block is initiated.  This read-ahead overlaps computation that
does not use the block contents.

If a memory channel accesses arrays stored in memory,
the channel block descriptors can be computed from the array coordinates
of the reference point.  Other memory channels use the contents
of a block to compute the block descriptors of neighboring blocks
in the window.

An example of the latter is a binary tree memory channel.
Let $M$ be such a channel, and let `\TT{.L}' denote the left
child of a binary tree element, `\TT{.R}' the right child, and
`\TT{.P}' the parent.  Then $M\!$\TT{.L.R} denotes the right
child of the left child of the reference point, $M\!$\TT{.P.L}
denotes the left child of the parent of the reference point,
and $M\!$\TT{.P.L.center} moves the reference point to this last element.
The window of such a memory channel might contain the depth 2
subtree of the reference point plus that closest 4 ancestors of the
reference point if these have been visited.  When the reference
point is moved, as soon as the reference point element has been
read from memory, the descriptors for its children are built and
the read of the children is initiated in parallel with other
computation.  When the children arrive from memory, the descriptors
of their children are built and reads of the data pointed at
are initiated.\footnote{All this can actually be done with modern
hardware: code is executed to read the reference point children and initiate the
reads of their children, and a modern processor will automatically
save the code that
executes when a read of a reference point child completes and execute
other code in parallel until the read does complete.}

Some standard memory channel types are built into the L-Language.
Others can be defined by users.

\section{To Do}

How can dynamically initialized locations be static.

Indirect address protocol.

Define `compile-time function' as a function that can only be
called at compile-time.

Add `\TT{no} {\em function-term}' as a way of saying
`{\em function-term} \TT{( false )}'.

If \TT{V} is the name of a repeatable variable (that may also
be omittable), then:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt unsadr V.\ttmkey{count}{of {\tt variable name}} } \\
Number of of times the variable name \TT{V} appears in the unfolded
pattern.  This is the number of times the {\em pattern-term} containing
the variable appears.  It is \TT{1} if the term is neither
replicated or omitted, and \TT{0} if it is omitted.

\hspace*{-0.3in}{\tt $T$ V\ttmkey{[$i$]}{of {\tt variable name}} } \\
The value of the $i$+1'st occurrence of \TT{V} in the unfolded pattern.
The index $i$ may be computed at run time, and has the range
\TT{0~..~V.count-1}.
$T$ is the type of the variable given in the {\em pattern-term}.
It is an error to use an index value that is out of range.


\end{indpar}

If \TT{V} is the name of a variable that may be omitted but not
repeated, then:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt bool V.\ttmkey{present}{of {\tt variable name}} } \\
True if the variable is present, and false if not.

\end{indpar}

In addition, if a variable can be omitted but not repeated, a default expression
must be given for the variable in a `\ttkey{defaults to}'
{\em conditioning-expression}.%
\label{DEFAULTS-TO}
If the variable \TT{V} is omitted, this
expression will be used at run time to compute the variable's value,
and `\TT{V.present}' will be set to `\TT{true}'.

\label{INDIRECT-ADDRESS-PROTOCOL}

Threads.
\label{THREADS}

\appendix

\section{Aliasing Hardware}
\label{ALIASING-HARDWARE}

The ultimate solution to the aliasing problem is new hardware.
At its simplest, registers, which currently hold a datum,
are replaced by triples of registers which hold a datum,
an address, and selection codes.  The register datum equals the value
of the memory location at the register address.  The selection
codes determine which part of this memory location is read or written
when the register is read or written.  If any memory location is
changed, the address of the location is checked against all the
register addresses, and if any match, the corresponding register
data are changed.

This is, however, not sufficient, because sometimes one register
address is a function of another register's datum.  For example,
consider the unchecked code:
\begin{indpar}[0.5em]\begin{verbatim}
struct S { ...; int32 m; ... }
S * * x
S * *& y = * x
int32 *& z = y->m
\end{verbatim}\end{indpar}
If we consider \TT{x}, \TT{y}, and \TT{z} to be registers,
the address of \TT{y} equals the value of \TT{x}, and the
address of \TT{z} equals the value of \TT{y} plus the offset of
\TT{m} in \TT{S}.

If the value of \TT{x} changes, this changes the address of \TT{y},
which may change the datum of \TT{y} and that may change the value
of \TT{y}.  If the value of \TT{y} changes, this changes the address
of \TT{z}, which may change the datum and value of \TT{z}.

The way we accommodate this is to use the selection codes of \TT{y}
to specify that the address of \TT{y} contains the value of \TT{x}
as an additive component, so
that if the value of \TT{x} is changed by adding $\Delta$\TT{x}
then the address of \TT{y} should be changed by adding $\Delta$\TT{x}.
And similarly the selection codes
of \TT{z} specify that the address of \TT{z}
contains the value of \TT{y} as an additive component.

So why should we bother with automatically updating
additive inclusions of one value in the
address of another value, and not bother with other expressions.
The reason is that expressions such as
`\TT{(*x)->m}' are likely to be reused frequently in code (actually,
in automatically generated code) and
therefore need to be cached, whereas an expressions of the form
`\TT{c*d}' will be reused comparatively rarely code
and therefore are not worth special hardware.


\bibliographystyle{plain}
\bibliography{layered-l-2012-language}

\printindex

\end{document}

