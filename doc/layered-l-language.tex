% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Layered Middle (M) Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

April 10, 2007
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language.  See the Introduction to the Layered
Programming Languages for basic syntax and for an overview of the related
Middle Layer M-Language and Higher Layer H-Language.


\section{Memory}
\label{MEMORY}

We begin with an overview of L-language memory, and then provide
details in the following subsections.

TBD

\subsection{Numbers}

\ikey{Numbers}{number} are a basic element of L-language memory.
Numbers are sequences of bits, and each number is one of
five types:

\begin{center}
\begin{tabular}{l@{~~~~~~}l}
\bf Number Type & \bf Length \\[2ex]
unsigned integer & 1 to 128 bits \\
signed integer & 1 to 128 bits \\
floating point number & 16, 32, 64, or 128 bits \\
direct address & 64 bits \\
\end{tabular}
\end{center}

The \mkey{length}{of number}
of a number is the number of its bits.  Numbers can have
different lengths: for example, unsigned integers can have any
length between 1 and 128 bits.

Numbers can be stored in registers or in random access memory (RAM).

An \key{unsigned integer} of length $L$ is a binary integer with
$L$ binary digits (\skey{bit}s).

A \key{signed integer} of length $L$ is a two's complement integer
of length $L$.  This represents an integer $I$
by the unsigned $L$-bit integer $I~\mbox{modulo}~2^L$.

A \key{floating point integer} of length $L$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes is as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l}
\bf Floating Point \\
\bf Number Size & \bf Exponent Size & \bf Mantissa Size \\[2ex]
16 bits & 5 bits & 10 bits \\
32 bits & 8 bits & 23 bits \\
64 bits & 11 bits & 52 bits \\
128 bits & 15 bits & 112 bits \\
\end{tabular}
\end{center}

A \key{direct address} holds a RAM byte address.
A direct address is a 64-bit unsigned integer, but some
of high order bits are all 0's or all 1's, depending upon
the implementation.  A reasonable assumption is that only the low
order 48-bits of the direct address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing a direct address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The Layered Languages do
\underline{not} depend upon this assumption, but do provide an instruction
with two parameters, $L$ and $S$, which takes as input
a 64-bit integer and returns a 64-bit direct address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$.  The output may have undefined high order bits if
the hardare ignores them when using the output to address memory.
If the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this instruction would just copy its input to its output
if $L\geq 44$ and $S=0$.

\subsection{Random Access Memory (RAM) and Blocks}

\ikey{RAM}{Random Access Memory}\index{random access memory!RAM}
is a set of address/bit pairs.  Each bit of RAM has \key{bit address}
that is a unsigned integer.  It is possible for two addresses to refer to the
same bit, or for an address to refer to no bit.  A bit address that
refers to a bit is said to be allocated, and a bit address that refers
to no bit is said to be deallocated.  A bit that has two distinct
addresses is said to be shared, and a bit with just one address is
unshared.

A \mkey{block}{of RAM} of RAM is a sequence of consecutive increasing addresses.
The \mkey{bit address}{of block} of the block is the address of its first bit,
and the \mkey{bit length}{of block} of the block is the number of bits.
An \mkey{alignment}{of block} of the block is any
common factor of the bit address and the bit length of the block.

A block is \key{byte aligned} if 8 bits is an alignment of the block.
The \mkey{byte address}{of block} of a byte aligned block is the
bit address of the block divided by 8.  The
\mkey{byte length}{of block} of such a block is its bit length divided by 8.

A block is \mkey{allocated}{block}
if the addresses of all its bits are allocated,
and is \mkey{deallocated}{block} if the addresses of all of its bits
are deallocated.
A block is \mkey{unshared}{block} if all its bits are unshared.
A block is \mkey{shared}{block} if
it is one of a set of several blocks (sequences of consecutive addresses)
such that the $n$'th bit of each block in the set is the same.
Note that a block can be neither shared nor unshared.

The address space is divided into \skey{page}s, which are blocks that
have an implementation determined length
that is a power of two: e.g., 2048 byte = 16386 bit pages.  There
are L-Language operations which call the operating system to
map an address page to physical memory, thus allocating a page
of RAM.  There are operations to deallocate a page, and to make
two pages be shared (map to the same bits of RAM).

The only way for two blocks to share a bit is for the blocks to
overlap shared pages.

The only blocks in L-language are frames (\pagref{FRAMES}),
code blocks(\pagref{CODE-BLOCKS}), and pages.
Numbers may be stored in registers, frames, code blocks, or pages.

\subsection{Registers}

A \key{register} is assigned a \mkey{type}{of register}
and some optional \mkey{type parameters}{of register}
and can hold any of the following:

\begin{center}
\begin{tabular}{l@{~~~~~~}l}
\bf Register Type & \bf Type Parameters \\[2ex]
unsigned integer & length \\
signed integer & length \\
floating point number & length \\
direct address \\
indirect address & level \\
linear channel & block-size window-size dimensions \\
chained channel & block-size window-size dimensions  \\
direct channel & block-size window-size dimensions \\
\end{tabular}
\end{center}

The type parameters are unsigned integers that
determine the sized of the register.

Registers with a number type can only hold numbers of the given register
type and register length.

An indirect address is consists of a direct address and a sequence of
zero or more offsets, each of which is a signed 64 bit integer.  The
number of offsets is the level of the indirect address.

A channel is a mechanism for caching a window of memory.  The window
consists of a linear array of blocks which are addressed by various
different means.  The block-size parameter specifies the maximum block
size, the window-size parameter the maximum size of any window dimension, 
and the dimensions parameter the maximum
number of dimensions in the window array.

Registers are virtual; some are implemented by hardware registers,
and some are implemented by a \key{frame}\label{FRAMES},
which is an allocated block of RAM
associated with the currently executing code.

[TBD: Add register pointers and register sharing.]

\subsection{Indirect Addresses}

An \key{indirect address} consists of a direct address $A$
and $L$ offsets, $O_1$, $O_2$, \ldots, $O_L$, where $L\geq 0$ is the
\mkey{level}{of indirect address} of the indirect address.
The indirect address represents the \mkey{target address}{of indirect address}:

\begin{center}
\begin{tabular}{l@{~~~~~~}l}
\bf Level & \bf Target Address \\[2ex]
0 & $(*A)$ \\
1 & $((*A)+O_1)$ \\
2 & $(*((*A)+O_1)+O_2)$ \\
3 & $(*(*((*A)+O_1)+O_2)+O_3)$ \\
\ldots & \ldots
\end{tabular}
\end{center}

where $*$ is the \key{indirect addressing operation}
that takes the direct address $D$ of another direct address $B$ stored
in RAM, and returns $B$.  $B$, which is called the \key{base address},
is both a direct address number and a block, and as a block
is required to have 64 bits as both its length and alignment.

The important thing about an indirect address is that the base addresses
it accesses are permitted to change at most times, as long as they
are changed according to a protocol (\pagref{INDIRECT-ADDRESS-PROTOCOL}).
The base addresses point at blocks that can be moved in memory at
any time the base addresses are permited to change.  Moving blocks in
memory is part of memory compaction, which in turn is part of garbage
collection, so indirect addresses enable real-time garbage collection.

The offsets of an indirect address are 64-bit integers whose
units are bytes.  The $+$ operator in the target address computation
is treated as addition modulo $2^{64}$ of unsigned integers, so the offsets
can be either unsigned or signed.  Addition overflow is not possible.


\subsection{Memory Channels}
\label{MEMORY-CHANNELS}

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
multi-dimensional array of block descriptors.
A \key{block descriptor} contains the address and length of a block to be
accessed.  Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
There are shift operations on the window that move all its rows or columns
(or other dimension) over and fill in with empty block descriptors.

A memory channel is stored in a register, but the register may be shared.
The type and type parameters of the register determine the type of the
channel and determine how much actual memory is allocated to the register.

The window of a memory channel
is organized in the same way for all memory channels.
It consists of a rectangular array of block descriptors, with the number
of dimensions in the array being that given by the
`\mkey{dimensions}{of window}' register type parameter.  The size of
each dimension is determined when the memory channel is initialized at
run time, but must not be greater than the `\mkey{window-size}{of window}'
register type parameter.
Similarly the size of each block is determined when the block descriptor
is created, but must not be greater than the `\mkey{block-size}{of window}'
register type parameter.

For all types of memory channel the window appears to be a subarray of
a larger square array.  The window has a \mkey{reference point}{of window}
that can be shifted along any of its dimensions.  Or the reference point
can be completely reset.  For most kinds of memory channels, window
block descriptors are computed automatically from the block descriptor
and in some cases block contents of an adjacent window position.
Typically once an initial reference point
block descriptor has been loaded into the memory channel, all other
block descriptors are computed automatically by this mechanism, and
typically the reference point is only moved by shifting it.

Memory channels differ in how block descriptors are computed.  A
linear memory channel assumes that blocks are addressed in memory according
to a linear scheme, and automatically fills in block descriptors when
the window is shifted.  A chained channel is similar except it assumes
each block points at its neighbors.  A direct channel requires programmed
instructions to load block descriptors.  In this last case, a block
descriptor may hold an instruction for computing it from the contents
of an adjacent block, so the instruction need not be delayed if the
adjacent block contents are not yet available.


\subsubsection{Linear Memory Channels}

Linear memory channels access multi-dimensional arrays of blocks
whose addresses are computable from a linear equation of the form:

\begin{center}
$\mbox{\em address} = \mbox{\em base-address}
		    + \sum_{n=1}^N \mbox{\em offset}_n\cdot i_n$
\\[2ex]
where $0\leq i_n < \mbox{\em dimension-size}_n$ for $1\leq n \leq N$
\end{center}


\section{Code Blocks}
\label{CODE-BLOCKS}

\section{To Do}

Indirect address protocol.
\label{INDIRECT-ADDRESS-PROTOCOL}

\bibliographystyle{plain}
\bibliography{layered-l-language}

\printindex

\end{document}
