% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{\,\textsuperscript{p\pageref{#1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}


\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

March 2, 2016
 
\end{center}

{\small \tableofcontents}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language.  See the Introduction to the Layered
Programming Languages for basic syntax and for an overview of the related
Middle Layer M-Language and Higher Layer H-Language.

The L-Language is intended to be a target language for compilers of
higher level languages.  As such it is optimized first to be an easy to 
use as a target language, and second to be easy to
compile into reasonably efficient debuggable assembly language code.

The L-Language is similar to the C programming language
differs in the following ways:

\begin{enumerate}

\item
L-Language facilitates isolating non-type-safe code into small inline functions.

\item
All L-Language data types are builtin number types or subtypes of
builtin number types.  All data managed directly by L-Language consists
of single numbers allocated to the stack.

Other memory is handled by code
encapsulated in small non-type-safe inline functions by the programmer.
Memory references other than those to single stack allocated numbers
are treated in a manner reminiscent of input/output.

\item
The type `\TT{type}' is first class, is a subtype of integers, and
is assigned a unique constant small integer value for each type.  Constant
argument values, such as the value of a `\TT{type}' valued
argument, can be used to select overloaded functions.

\item
All L-Language functions are inline.  Out-of-line functions can be
called using a block syntax that mirrors the overhead involved in
manipulating an argument stack in memory.

\item
L-Language associates formatting functions
with data types for use in displaying and in some cases inputting
data during debugging.

\item
L-Language uses a single-assignment style of program structure
to encourage
efficient code that leaves an audit trail for debugging in the stack.
Partial evaluation of expressions and inline code is supported without
compromising debuggability.

\item
L-Language uses the Layered Language Module Structure to manage
multi-file source code in a well-ordered and type-safe manner.


\end{enumerate}


\section{Types}
\label{TYPES}

The basic builtin types are the number types and the \TT{void} type.
All defined types are subtypes of these types.
There are two builtin defined subtypes, the `\TT{type}' type and
the `\TT{qualifier}' type.

\subsection{Number Types}
\label{NUMBER-TYPES}

Numbers are sequences of bits, and each number is one of
four kinds, unsigned integer, signed integer, floating point number,
and address:

\begin{indpar}
\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\bf Name & \bf Kind & \bf Length \\[2ex]
\ttkey{uns8}		& unsigned integer & 8 bits \\
\ttkey{uns16}		& unsigned integer & 16 bits \\
\ttkey{uns32}		& unsigned integer & 32 bits \\
\ttkey{uns64}		& unsigned integer & 64 bits \\
\ttkey{uns128}		& unsigned integer & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{int8}		& signed integer & 8 bits \\
\ttkey{int16}		& signed integer & 16 bits \\
\ttkey{int32}		& signed integer & 32 bits \\
\ttkey{int64}		& signed integer & 64 bits \\
\ttkey{int128}		& signed integer & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{float16}		& IEEE floating point number & 16 bits \\
\ttkey{float32}		& IEEE floating point number & 32 bits \\
\ttkey{float64}		& IEEE floating point number & 64 bits \\
\ttkey{float128}	& IEEE floating point number & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{unsadr}		& unsigned integer & size of address \\
\ttkey{intadr}		& signed integer & size of address \\
\ttkey{adr}		& signed or unsigned integer & size of address \\
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{unswrd}		& unsigned integer & size of machine word \\
\ttkey{intwrd}		& signed integer & size of machine word \\
\end{tabular}
\end{indpar}

These are the \key{built in number types}:
\begin{indpar}
{\em builtin-number-type-name}
    \begin{tabular}[t]{@{}cl}
    ::= & \TT{uns8} $|$ \TT{uns16} $|$ \TT{uns32} $|$ \TT{uns64}
                    $|$ \TT{uns128} \\
    $|$ & \TT{int8} $|$ \TT{int16} $|$ \TT{int32} $|$ \TT{int64}
                    $|$ \TT{int128} \\
    $|$ & \TT{float16} $|$ \TT{float32} $|$ \TT{float64} $|$ \TT{float128} \\
    $|$ & \TT{unsadr} $|$ \TT{intadr} $|$ \TT{adr}
                      $|$ \TT{unswrd} $|$ \TT{intwrd} \\
    \end{tabular}
\end{indpar}

The \mkey{length}{of number}
of a number is the number of its bits.  Numbers can have
different lengths: for example, unsigned integers can have
lengths of 8, 16, 32, 64, or 128 bits.

Numbers are stored in registers or in random access memory (RAM).

An \key{unsigned integer} of length $L$ is a binary integer with
$L$ binary digits (\skey{bit}s) and range from $0$ to $2^L-1$.

A \key{signed integer} of length $L$ is a two's complement integer
of length $L$ and range from $-2^{L-1}$ to $+2^{L-1}-1$.
This represents the integer $I$ in the given range
by the unsigned $L$-bit integer equal to $I~\mbox{modulo}~2^L$.

A \key{floating point number} of length $L$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes are as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}r@{~~~~~~}r}
                   &              &              &             & \bf Maximum \\
\bf Floating Point & \bf Exponent & \bf Mantissa & \bf Decimal & \bf Decimal\\
\bf Number Size    & \bf Size     & \bf Size     & \bf Digits  & \bf Exponent
\\[2ex]
16 bits & 5 bits & 10 bits & 3.31 & 4.51 \\
32 bits & 8 bits & 23 bits & 7.22 & 38.23 \\
64 bits & 11 bits & 52 bits & 15.95 & 307.95 \\
128 bits & 15 bits & 112 bits & 34.02 & 4931.77 \\
\end{tabular}
\end{center}

An \key{address} holds a RAM byte address.
An address is a 32-bit or 64-bit signed or unsigned integer whose size
and signage are determined by the target machine.
Some of high order bits may be
required to be all 0's or all 1's, depending upon
the target machine.  The \TT{unsadr} and \TT{intadr}
unsigned and signed integer types of the same size
as an address are provided for storing indices and offsets.

A reasonable assumption for 64-bit addresses is that only the low
order 48-bits of the address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing an address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The L-Language does
\underline{not} depend upon this assumption, but does provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$.  The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.\footnote{The I86 64-bit architecture
uses only the low order 48 bits of an address, but \underline{requires}
the high order 17 bits to all be the same, either all 1's or all 0's.
However, as it is unlikely that there will ever be an allocated memory region
that includes address 0 in its interior, it makes no significant difference
whether we consider addresses to be unsigned or signed.}

The following \underline{implicit} conversion operators are defined:
\begin{center}

\begin{tabular}{rcl}
\hspace*{2.0in} & & \hspace*{2.0in} \\[-2ex]
\TT{uns}$x$ & \TT{<{}<++} & \TT{uns}$y${\em -value} \\
\TT{int}$x$ & \TT{<{}<++} & \TT{uns}$y${\em -value} \\
\TT{float}$x$ & \TT{<{}<++} & \TT{uns}$y${\em -value} \\
\TT{int}$x$ & \TT{<{}<++} & \TT{int}$y${\em -value} \\
\TT{float}$x$ & \TT{<{}<++} & \TT{int}$y${\em -value} \\
\TT{float}$x$ & \TT{<{}<++} & \TT{float}$y${\em -value} \\
\end{tabular}

where $x>y$

\end{center}

For all these implicit conversions no information is lost from
the value when it is converted to the new type.

The following \underline{unchecked}
conversion operator is defined:
\begin{center}

\TT{*UNCHECKED*} $t2$ ~~ \TT{<{}<++} ~~ $t1${\em -type-value}%
\label{<<**}

for any two builtin number types $t1$ and $t2$.

\end{center}

The operator is always defined, but the
result of execution is undefined unless one of the following
cases applies:
\begin{itemize}
\item The implicit conversion `$t2$ \TT{<{}<++} $t1${\em -type-value}'
is defined.
\item $t1$ is a floating point type
and $t2$ is an integer type large enough to hold the integral part
of the number being converted.  The fractional part of
the floating point number is discarded, thereby rounding toward
zero.
\item $t2$ is a floating point type large
enough to hold an exact representation of the highest order
part of the $t1$-value
(i.e., the highest order digits where the
number of digits represented exactly depends only on the size of $t2$).
The result is the rounded $t1$-value,
where the method of rounding is indeterminate.
\item $t2$ is an integer type not large enough
to hold the integer part of the value being converted.
The result is the $t2$ value that
equals module $2^n$ the integer part of the $t1$-value, with any
factional part being discarded (round toward zero),
where $n$ is the length in bits
of $t2$.
\end{itemize}

Numeric constants are treated as if they had their own type,
\key{numeric-constant}.\footnote{Otherwise we would have problems
representing \TT{256}.  If we used \TT{uns16} we could not implicitly
convert to \TT{int16}, and if we used \TT{int16} we could not implicitly
convert to \TT{uns16}.}
The implicit conversion:
\begin{center}
$t2$ ~~ \TT{<{}<++} ~~ {\em numeric-constant}
\end{center}
is defined whenever either:
\begin{itemize}
\item No information about the size, sign, and
precision of the number is lost by representing the number
as a $t2$ type value.
\item $t2$ is a floating point type large enough to hold an
exact representation of the highest order part of the
{\em numeric-constant}
(i.e., the highest order digits where the
number of digits represented exactly depends only on the size of $t2$).
The result is the rounded
{\em numeric-constant},
where the method of rounding is indeterminate.
\end{itemize}

The \underline{unchecked} conversion is defined:
\begin{center}
\TT{*UNCHECKED*} $t2$ ~~ \TT{<{}<++} ~~ {\em numeric-constant}
\end{center}
provided one of the following cases applies:
\begin{itemize}
\item The implicit conversion `$t2$ \TT{<{}<++} {\em numeric-constat}'
is defined.
\item The {\em numeric-constant} is floating point with
a fractional part,
and $t2$ is an integer type large enough to hold the integral part
of the number being converted.  The fractional part of
the floating point number is discarded, thereby rounding toward
zero.
\item $t2$ is an integer type that cannot
hold the integral part of the value being converted.
Any fractional part of the
{\em numeric-constant} is discarded, and the result is the $t2$ value that
equals module $2^n$ the remaining integral part of the {\em numeric-constant},
where $n$ is the length in bits of $t2$.
\end{itemize}

TBD: Check IEEE conversions that produce NaNs.

\subsection{The Void Type}
\label{THE-VOID-TYPE}

A \ttkey{void} type variable has no value.  No value can be
assigned to such a variable.  Nevertheless such variables have
uses, for example, as base variable in clusters (\pagref{CLUSTERS}).
When used as the base variable of a cluster, an assignment statement
may appear to be assigning a value to a \TT{void} variable, but
in fact it is assigning values to cluster members.

The following implicit conversion is always defined:
\begin{center}
\TT{void} ~~ \TT{<{}<++} ~~ {\em any-value}
\end{center}


\subsection{Defined Types}
\label{DEFINED-TYPES}

A statement of the following form defines a type:
\begin{center}
\TT{type} {\em qualifier}\STAR{} {\em defined-type-name}
          \TT{is} {\em builtin-type-name}
\end{center}
Here the builtin type is called the \key{underlying type} of the
\key{defined type}, and any {\em qualifiers} are attached to every
variable or argument declared to have the defined type (see
section \itemref{QUALIFIERS} for more on this).

A value of a defined type may be converted to or from its underlying
type by the
\underline{unchecked}
operations:
\begin{center}
\begin{tabular}{rcl}
\TT{*UNCHECKED*} {\em builtin-type-name}
	& \TT{<{}<++} & {\em defined-type-value} \\
\TT{*UNCHECKED*} {\em defined-type-name}
	& \TT{<{}<++} & {\em builtin-type-value} \\
\end{tabular}
\end{center}
These operators do not change the actual value, but merely its
compile-time type.  Unchecked conversions in one direction only
may be defined as desired.


\subsection{Enumeration Values}
\label{Enumeration-VALUES}

A defined type with an integer underlying type
may have \skey{enumeration value}s.  These are unique integer
values assigned to enumeration constant names during compilation,
and then reassigned to possibly different unique integer values during linking.

A statement of the following form defines an \key{enumeration type}
that has enumeration values:
\begin{center}
\TT{type} {\em qualifier}\STAR{} {\em defined-enum-type-name}
    \begin{tabular}[t]{l}
    \TT{is}~~~{\em base-enum-type-name} \\
    \TT{with enum range}~~~{\em enum-range} \\
    \{ \TT{without implicit conversion} \}\QMARK
    \end{tabular}
\end{center}
where
\begin{center}
\begin{tabular}{rrl}
\emkey{base-enum-type-name}
    & ::= & {\em builtin-number-type-name} \\
    & $|$ & {\em enum-direction} {\em defined-enum-type-name} \\
\emkey{enum-direction}
    & ::= & \TT{next} $|$ \TT{previous} \\
\emkey{enum-range}
    & ::= & \TT{[} {\em first-enum} \TT{..} {\em last-enum} \TT{]} \\
    & $|$ & \TT{[} {\em first-enum} \TT{..} \TT{]} \\
    & $|$ & \TT{[} \TT{..} {\em first-enum} \TT{]} \\
\emkey{first-enum}
    & ::= & {\em compile-time-integer-expression} \\
\emkey{last-enum}
    & ::= & {\em compile-time-integer-expression} \\
\end{tabular}
\end{center}

Here {\em first-enum} must be less than or equal to {\em last-enum}.
If {\em last-enum} is not given, it is assumed to be the maximum
value provided by the base enumeration type.
If {\em first-enum} is not given, it is assumed to be the minimum
value provided by the base enumeration type.

Enumeration values can be assigned by statements of the form
\begin{indpar}
\emkey{enum-assignment}
    ::= {\em enum-type-name} {\em constant-name} \TT{=} \TT{next enum} \\
\emkey{enum-assignment}
    ::= {\em enum-type-name} {\em constant-name} \TT{=} \TT{previous enum}
\end{indpar}

Within a compilation the compiler assigns the value {\em first-enum}
to the first constant named in a `\TT{next enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in increasing order.
It is an error if `\TT{next~enum}'
would return a value beyond the {\em last-enum} value in a range.

Similarly the compiler assigns the value {\em last-enum}
to the first constant named in a `\TT{previous enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in decreasing order.
It is an error if `\TT{previous~enum}'
would return a value below the {\em first-enum} value in a range.

It is also an error if for a given type the same value is returned
by some \TT{next~enum} and also by some \TT{previous~enum}.

Within a linked load the process is the same, but the values assigned
to a constant may differ from those assigned during compilation,
so that all such assignments for a given type within a linked load
will be distinct.  The assignments occur when the code containing
the statements is linked, not when that code is executed.

Within a compilation module, all assignments to an enumeration type
are done in the same order during linking as during compilation.
Thus values assigned within the same module can be assumed to be
in the same order at compile and link times.  Also,
compile and link values
can be assumed to be the same if all values of the enumeration type
are assigned in the same compilation module.

When the {\em base-enum-type-name} names another enumeration type,
the {\em enum-range} given is mapped to a subrange of the
base enumeration type.  More specifically,
\begin{center}
\TT{type X is next Y with enum [m~...~n]}
\end{center}
allocates
the next \TT{n - m + 1} values of \TT{Y} as per `\TT{next enum}'
and maps them to the values
of \TT{X} beginning with \TT{m} and ending with \TT{n}.
If `\TT{next}' is replaced by `\TT{previous}', the action is the
same but the values of \TT{Y} are allocate as per `\TT{previous enum}'
and mapped to the values
of \TT{X} beginning with \TT{n} and ending with \TT{m}, so the order
of values of \TT{X} is always the same as their order when they
are viewed as values of \TT{Y}.

The conversions
\begin{center}
\begin{tabular}{rcl}
{\em base-enum-type-name}
	& \TT{<{}<++} & {\em defined-enum-type-value} \\
\TT{*UNCHECKED*} {\em base-enum-type-name}
	& \TT{<{}<++} & {\em defined-enum-type-value} \\
\TT{*UNCHECKED*} {\em defined-enum-type-name}
	& \TT{<{}<++} & {\em base-enum-type-value} \\
\end{tabular}
\end{center}
may be used to convert between enumeration values and their base enumeration
values.
It is an error if the result of one of these conversions is outside
the range of the result enumeration type.

The implicit conversion is \underline{not} defined if the
`\TT{without implicit conversion}' option is given in the
enumeration type definition.

The following are builtin enumeration types:
\begin{indpar}
\TT{type~}\ttkey{bool}\TT{~is unswrd with enum [0~..~1]} \\
\TT{bool}~\ttkey{false}\TT{~= next enum // 0} \\
\TT{bool}~\ttkey{true}\TT{~~= next enum // 1} \\
\TT{type~}\ttkey{type}\TT{~is unswrd with enum [0~..]} \\
\TT{type~}\ttkey{qualifier}\TT{~is unswrd with enum [0~..]} \\
\TT{type}~\ttkey{missing}\TT{~= next enum // 0} \\
\TT{type}~\ttkey{type}\TT{~= next enum // 1} \\
\TT{type}~\ttkey{qualifier}\TT{~= next enum // 2}
\end{indpar}

\subsection{Enumeration Sets}
\label{Enumeration-Sets}

An enumeration set is a set of enumeration values.  The syntax
for enumeration set constants is:
\begin{indpar}
\emkey{enum-set-constant}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{\{~\}\}} \\
    $|$ &\TT{\{\{} {\em enum-set-item}
                   \{ \TT{,} {\em enum-set-item} \}\STAR{} \TT{\}\}} \\
    \end{tabular} \\
\emkey{enum-set-item}
    ::= {\em enum-value} $|$ {\em enum-range} \\
\emkey{enum-range}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em enum-value}~~~\TT{..}~~~{\em enum-value} \\
    $|$ & {\em enum-value}~~~\TT{..} \\
    $|$ & \TT{..}~~~{\em enum-value} \\
    \end{tabular} \\
\emkey{enum-value} ::= {\em compile-time-enum-expression}
\end{indpar}

If the {\em enum-values} in an {\em enum-set-constant} have different
enumeration types, implicit conversions from these to their base types
are inserted until all have the same defined enumeration type,
which is called the `\key{common enumeration type}' of the set.
As few implicit conversions as possible are inserted.  It is an error
if this cannot be done because some of the types have no implicit
conversion defined for them, or if after implict conversion the
common tpe is not a defined enumeration type.
Importantly, note that the common type cannot be a builtin integer
type.

An {\em enum-range} designates the two values given and all
values in between.
After implict conversion, the first {\em enum-value} in an {\em enum-range}
must \underline{not} be greater than the second {\em enum-value}
in the {\em enum-range}.  If the first or second {\em enum-value} of
an {\em enum-range} is omitted, it is taken to be the lower or upper
limit of the enumeration type of the non-omitted {\em enum-value}.

The order in which values are given in an {\em enum-set-constant}
does not matter.  Overlapping and adjoining ranges are implictly
combined.\footnote{Internally an enumeration set may be stored as a
sorted list of integers with binary indicators specifying when all
the values between one integer and the next integer are to be included in set.}
Thus
\begin{indpar}\begin{verbatim}
type X is uns8 with enum range [1 .. 20]
X X1 is next enum
X X2 is next enum
. . . . . . . . . .
X X20 is next enum

// Then:
//
//    {{ X1, X5, X2, X10 .. X16, X19 .. X20, X15 .. X18 }}
// == {{ X1, X2, X5, X10 .. X20 }}
\end{verbatim}\end{indpar}

Enumeration set values are used in logical expressions that
condition function lookup.  For example,
\begin{indpar}\begin{verbatim}
T v = signed max ( type T, T v1, T v2 )
      [[ T in {{ int8, int16, int32, int64, int128 }} ]]:
    . . . . . . . . . . .
\end{verbatim}\end{indpar}

defines a function that takes only signed integer type
arguments, and not unsigned integer type arguments.
The logical expression inside \TT{[[~]]} must be satisfied
for the function definition to match a function call, and
the type argument \TT{T}, which is implicit and need not be
given in the function call, must be in the give set of
types, where types are values of the enumeration type `\TT{type}'.

\subsection{Type Values}
\label{TYPE-VALUES}

The type `\TT{type}' is a builtin enumeration type declared
by
\begin{center}
\TT{type type is unswrd with enum [1 ..]}
\end{center}
Each type is associated with a unique enumeration value
of type `\TT{type}', and this value can be used at both
compile and run time to test whether two `\TT{type}'s are
equal.

Functions can be overloaded based on the number and types
of their arguments and also on the values of arguments that
are known at compile time.  Thus different functions with
the common prototype
\begin{center}
\TT{(unsadr length) = size of ( type T )}
\end{center}
may be defined for different values of \TT{T}.  
This is done automatically for the following functions:

\begin{indpar}[0.5in]
\hspace*{-0.3in}{\tt (unsadr size) = \ttkey{size of}
			( type T )} \\
Returns \TT{size}, the number of bytes in a value of type \TT{T}.
For defined types it is the size of their underlying type.

\hspace*{-0.3in}{\tt (unsadr alignment) = \ttkey{alignment of}
			( type T )} \\
Returns \TT{alignment}, a strictly positive integer.
The address of a value of type \TT{T} in RAM should
optimally be a multiple of the \TT{alignment}.
The alignment of builtin types is their size.
For defined types it is the alignment of their underlying type.

\hspace*{-0.3in}{\tt (type B) = \ttkey{base type of}
			( type T )} \\
Returns the parent type \TT{B} of the type \TT{T}.  For defined
types this is the associated builtin type.  For builtin types, it is
\TT{T} itself.

\hspace*{-0.3in}{\tt (T value) = \ttkey{min of}
			( type T )} \\
\hspace*{-0.3in}{\tt (T value) = \ttkey{max of}
			( type T )} \\
Returns the minimum or maximum value of a type \TT{T}.
These are defined only for number types and enumeration types,
and for enumeration types the values returned correspond to the
minimum and maximum of the underlying type, and not the assigned
enumeration values.

\hspace*{-0.3in}{\tt (T value) = \ttkey{min limit of}
			( type T )} \\
\hspace*{-0.3in}{\tt (T value) = \ttkey{max limit of}
			( type T )} \\
Returns the minimum or maximum values of an enumeration type \TT{T}.
These are the values given or implied in the type's {\em enum-range}.
It is a compile time error if \TT{T} is not an enumeration type.

\hspace*{-0.3in}{\tt (T value) = \ttkey{min assigned of}
			( type T )} \\
\hspace*{-0.3in}{\tt (T value) = \ttkey{max assigned of}
			( type T )} \\
Returns the minimum or maximum values actually assigned to an
enumeration type \TT{T} by an {\em enum-assignment}.  Values
assigned by unchecked conversions are not considered.  If
no values have been assigned, {\em first-enum} is returned as
one of the assigned values and the other assigned value is such
that the difference of assigned values is \TT{-1}.
In any case the maximum assigned value minus the minimum assigned value
plus \TT{1} is the number of assigned values.
It is a compile time error if \TT{T} is not an enumeration type.

These values may change when more code is compiled or linked.
One should never assume that a value of type \TT{T} is necessarily within
the range given by these values.

\hspace*{-0.3in}{\tt (T value) = \ttkey{default value of}
			( type T )} \\
Returns a suitable default value for type \TT{T}.
Defined to return \TT{0} for builtin number types.
Must be defined by user for defined types.  For use by allocators,
such as a user defined function that allocates a vector whose
elements are of type \TT{T}, and the function wishes to give the elements an
initial default value.
\end{indpar}

\section{Qualifiers}
\label{QUALIFIERS}

Variables may be qualified by \skey{qualifier}s, which preceed the
type when a variable is declared.  There are four builtin qualifiers
described in Section~\itemref{BUILTIN-QUALIFIERS} that have special
effects: \TT{mem}, \TT{stack}, \TT{*UNCHECKED*}, and \TT{trace}.
Other qualifiers may be defined, and are typically used to add an
additional layer of type checking that is somewhat orthogonal to
types.

Syntactically {\em qualifier-names} immediately preceed the {\em type-names}
that are before {\em variable-names}.  Some introductory examples are:
\begin{indpar}\begin{verbatim}
qualifier foo
protection qualifier bar
foo bar int32 result = F ( foo bar int32 value ):
    // Declares function F that computes a result of type
    // int32 and qualifiers foo and bar from a value of
    // type int32 and qualifiers foo and bar.  Also
    // automatically adds qualifier bar to result because
    // bar is a protection qualifier.
    //
    ... [Function body omitted] ...

// Example usage:
//
foo bar int32 x1 = ...
foo int32 x2 = ...
foo bar int32 y1 = F ( x1 )
    // Legal.
foo bar int32 y2 = F ( x2 )
    // Illegal: x2 has no bar qualifier.
bar int32 y3 = F ( x1 )
    // Illegal: y3 has no foo qualifier.
foo int32 y4 = F ( x1 )
    // Legal: y4 is given bar qualifier automatically
    // because bar is a protection qualifier and y4 is
    // a result variable.

inverted protection qualifier oof
oof int32 result = G ( int32 value ):
    // Declares function G that DISALLOWS arguments with
    // qualifier oof because oof is inverted, and
    // automatically adds oof to result as off is a
    // protection qualifier.
    //
    ... [Function body omitted] ...

int32 x10 = ...
oof int32 x11 ...
int32 y10 = G ( x10 )
    // Legal; x10 does NOT have oof qualifier; oof is
    // a protection qualifier and is automatically
    // given to result y10.
int32 y11 = G ( x10 )
    // Illegal; x10 does NOT have oof qualifier, which
    // is inverted.
\end{verbatim}\end{indpar}

If {\em qualifiers} are given in front of the {\em defined-type-name}
of a statement that defines the later, then these qualifiers are
added to every variable that has the defined type.
See section~\itemref{TRACE-QUALIFIERS} for an example.

Some qualifiers are \skey{protection qualifier}s and some are not.
Some qualifiers are \key{inverted} but most are not.
Some qualifiers are \key{inherited} but most are not.

The qualifiers may be declared by:
\begin{indpar}
\emkey{qualifier-declaration}
    \begin{tabular}[t]{rl}
    ::= & {\em qualifier-attribute}\STAR{} \ttkey{qualifier}
           {\em defined-qualifier-name} \\
    $|$ & {\em trace-qualifier-declaration}
    	  ~~~ [see \pagref{TRACE-QUALIFIERS}]
    \end{tabular} \\
\emkey{qualifier-attribute} ::=
    \TT{protection} $|$ \TT{inverted} $|$ \TT{inherited}
\end{indpar}

In order for a function
prototype (argument or result) variable to match an actual variable,
if the prototype variable has a non-inverted qualifier, the actual
variable must have this non-inverted qualifier.

In order for a function
prototype (argument or result) variable to match an actual variable,
and if the prototype variable
does \underline{not} have an inverted qualifier, the actual variable
must \underline{not} have this inverted qualifier.

If a variable is initialized by being matched to a prototype result variable
of a function, the variable is implicitly given all the protection qualifiers
of the prototype variable.  This is the only way a non-prototype
variable may acquire
a protection qualifier.  Thus protection qualifiers may only be explicitly
given for prototype variables.

If an inherited qualifier is applied to the root variable of a cluster
or subcluster, this inherited qualifier is automatically applied to all
the member variables in the cluster or subcluster.  This is not done
for non-inherited qualifiers.

As an example of the above rules, the \TT{mem} qualifier is
a non-inverted, non-inherited
protection qualifier, so if \TT{t} is a type and \TT{v} a
variable, and the {\em value-assignment-statement} allocating \TT{v} has the
form `\TT{t v = }{\em expression}' where \TT{v} is matched
with some result variable that has the \TT{mem} qualifier of some
function called in {\em expression}, then \TT{v} will be implicitly
given the \TT{mem} qualifier.  Because \TT{mem} is non-inverting,
\TT{v} can then be matched to any prototype variable of the same type
whether or not that prototype variable has the \TT{mem} qualifier,
and thus the value of \TT{v} can be freely used.

As another example of the above rules, the \TT{stack} qualifier is
an inverted protection non-inherited qualifier given the result variable of
a call to `\TT{allocate to stack}' function (\pagref{ALLOCATE-TO-STACK}).
Values with this qualifier can only be passed to prototype variables
that also have the qualifier.  This prohibits passing stack addresses
to functions that would store them in global or heap memory.

Four qualifiers, \TT{mem}, \TT{stack}, \TT{*UNCHECKED*},
and \TT{trace}, are builtin and have special
effects described below.
In addition any qualifier can be used with the special \TT{reload} statement
descibed below.

\subsection{Qualifier Values}
\label{QUALIFIER-VALUES}

The type `\ttkey{qualifier}' is an enumeration type implicitly
declared after the manner of
\begin{center}
\TT{type qualifier is uns32 with enum [1 ..]}
\end{center}
Each qualifier is associated with a unique enumeration value
of type `\TT{qualifier}', and this value can be used at both
compile and run time to test whether two `\TT{qualifier}'s are
equal.

The type `\ttkey{qualifiers}' denotes a set of qualifier values.
Constants equal to such sets are denoted by the comma separated names of the
qualifier values in \TT{\{\{~\}\}} brackets.  For example,
`\TT{\{\{stack, mem\}\}}'.

A {\em function-prototype} can have implicit \TT{qualifiers} arguments.
These are implicitly given as their value the smallest set of qualifiers
that includes the qualifiers in the actual argument and that
allows the {\em function-prototype} to match a call.  For example:

\begin{indpar}\begin{verbatim}
Q T result = foo ( type T, qualifiers Q, Q T value )

// Example usage:
//
qualifier bar
bar int32 x = ...
int32 y = foo ( x )     
    // Q = {{bar}} as x is qualified by bar.  Call is then
    // illegal because y has no bar qualifier.  Would be
    // legal if bar were a protection qualifier.
bar int32 z = foo ( x )  // Legal.
\end{verbatim}\end{indpar}

Function prototypes can have at their end a condition in \TT{[[~]]}
brackets that must be satisfied in order for the prototype to match
a call.  This condition may use qualifier values and sets, with
\TT{\&} denoting set `AND' and `\TT{\textasciitilde}' denoting
set complement (in the universe of all possible qualifiers),
`\TT{==}' denoting set equality, `\TT{!=}' denoting set inequality,
and `\TT{<=}' denoting set subset.
An example is:

\begin{indpar}\begin{verbatim}
Q T result = fum ( type T, qualifiers Q, Q T value )
    [[ Q & {{bar}} == {{}} ]]

// Example usage:
//
qualifier bar
qualifier boo
bar int32 x = ...
boo int32 y = ...
bar int32 z = foo ( x )
    // Illegal, Q must contain bar as x and z do,
    // but condition prohibits Q from containing bar.
boo int32 w = foo ( y )  // Legal. Q == {{boo}}.
\end{verbatim}\end{indpar}

\section{Functions}
\label{FUNCTIONS}

All functions are inline.  An inline function can call an out-of-line
function by using
a call assignment statement (\itemref{CALL-ASSIGNMENT-STATEMENTS})
or the out-of-line assignment statement
(\itemref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}).

Function definitions have the form:

\begin{indpar}
\emkey{function-definition}
    ::= \begin{tabular}[t]{l}
        {\em function-prototype}\TT{:} \\
	~~~~ {\em executable-statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{function-prototype}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em result-variable-list} \TT{=} {\em function-name}
	    {\em argument-variable-list}\QMARK{} \\
    $|$ & {\em function-name} {\em argument-variable-list}\QMARK{} \\
    $|$ & {\em function-name} {\em argument-variable-list}\QMARK{}
            \TT{=} {\em input-variable-list} \\
    $|$ & {\em other} as per Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS}
    \end{tabular}
\end{indpar}

A function call with a {\em result-variable-list}
is in effect replaced by a {\em block-assignment-statement}
(Section~\itemref{BlOCK-ASSIGNMENT-STATEMENTS})
with the {\em function-definition's} {\em result-variable-list} becoming the 
{\em block-assignment-statement's} {\em variable-list} and the
{\em function-definition's} {\em executable-statements} becoming the 
{\em block-assignment-statement's} {\em executable-statements}.
Actual argument values from the function call are assigned to variables in
the definition {\em argument-variable-list}.  The values produced in
the {\em result-variable-list's} variables become the values of the
function call when it is used as part of an {\em expression}.

A function call without any {\em result-variable-list}
is just like a function call with an empty
{\em result-variable-list}.

A function call with an {\em input-variable-list} is just syntactic
sugar for a function call with neither a {\em result-variable-list}
or {\em input-variable-list}.  Specifically
\begin{center}
\TT{F(a1,a2,...)~=~(b1,b2,...)} \\
is syntactic sugar for \\
\TT{F(a1,a2,...)(b1,b2,...)} \\
\end{center}

where use is made of the fact that a function can have multiple
argument lists (Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS}).

An argument or return variable can have the `\TT{type}' type.
If an argument variable has type `\TT{type}', its value can be used as the
type of other argument variables that are
after it in the {\em argument-variable-list},
or of any result variable.  For example:

\begin{indpar}\begin{verbatim}
( T result ) = add ( type T, T v1, T v2 ):
    result = v1 + v2

// Example usage
//
int32 x = ...
int32 y = ...
int32 z = add ( int32, x, y )
\end{verbatim}\end{indpar}

Much more complex {\em function-prototypes} can be written:
see Calls, \itemref{FUNCTION-PROTOTYPES-AND-CALLS}.
Also type arguments can be implied, e.g., the first argument \TT{T}
in a call to `\TT{add}' as in:

\begin{indpar}\begin{verbatim}
int32 z = add ( x, y )
\end{verbatim}\end{indpar}

\section{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

Function executions have stacks that contain \underline{all}
their variables.
These variables are allocated and their values are computed by
assignment statements:

\begin{indpar}
\emkey{value-assignment-statement}
    ::= \{ {\em variable-list} \TT{=} \}\QMARK{}
        {\em expression}
\\[0.5ex]
\emkey{variable-list}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em variable-declaration} \\
    $|$ & \TT{(~}{\em variable-declaration}
          \{ \TT{,} {\em variable-declaration} \}\STAR{} \TT{)} \\
    \end{tabular}
\\[0.5ex]
\emkey{variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & \ttkey{next} {\em variable-name}
    \end{tabular}
\end{indpar}

This allocates new variables of the given {\em variable-names}, types,
and qualifiers
to the stack and stores values from the {\em expression} in the variables
({\em qualifiers} are not described until section \itemref{QUALIFIERS}).
The {\em expression} produces a list of values, and this list must have
at least as many elements as there are variables.  Each variable is
assigned its value in order.  If the {\em expression} produces
too many values, the excess values at the end of the value list will be
discarded.

The value assigned to each variable
must be implicitly convertable to the variable's type, unless
the variable has the \TT{*UNCHECKED*} qualifier, in which case
the value must be convertable by unchecked conversion to the
variable's type.

The {\em expression} may only input values that are constants or are
the values of other variables in the same function execution
stack (including
arguments passed to the function execution).  In particular,
no input can come from RAM memory outside the function execution stack.
See Section~\itemref{STACK-MANAGEMENT} for information about stacks.

Implicitly when a variable value is set this way, the value is first
computed in a register, then stored in the stack, and for some time
afterwards the value is left in the register which becomes a cache
on the stack value.  This cacheing is hidden from the programmer.

If a variable value is copied from another variable, usually the
new variable simply becomes a compile-time alias for the old variable.
No executable copy code is created, no new register is allocated, and no new
value is pushed into the stack.

Similarly if a variable value can be computed from previous variable
values by in-line code, 
its value may not be pushed into the stack.  Instead its
value can be recovered at any time by repeating the computation
of the variable from the other values.

Two variables in the same block of code may not have the same
name.  Thus variables are only assigned values once.

However, if an assignment statement uses the word `\TT{next}' in
place of the {\em qualifiers} and {\em type-name}
of a variable being assigned a value, and
if the variable previously exists, a new variable with the same
name, type, and qualifiers as the previous variable is allocated.

Note that `\TT{next}' behaves differently for loop interation
variables (see below) than it does for other variables.

All assignment statements have a special case where there are
no variables being assigned, the {\em variables-list} is omitted,
and the \TT{=} is also omitted.  In this case the
{\em value-assignment-statement} reduces to just an {\em expression}
that executes for side effects (such as
input/output or non-stack memory modification).

\subsection{Block Assignment Statements}
\label{BlOCK-ASSIGNMENT-STATEMENTS}

Another variant of the assignment statement is\index{block assignment}:

\begin{indpar}
\emkey{block-assignment-statement}
    ::= \begin{tabular}[t]{l}
        \{ {\em variable-list} \TT{=} \}\QMARK{}
	\ttkey{do}\QMARK{} \TT{:} \\
	\TT{~~~~}{\em executable-statement}\STAR{}
	\end{tabular}
\end{indpar}

where `\TT{do}' may be omitted as long as \TT{=} is not omitted.

The {\em executable-statements} in the block can include
{\em assignment-statements} in which {\em variable-declarations}
are replaced by simple {\em variable-names}
if these variables have the same name as a variable
in the {\em block-assignment-statement's} {\em variable-list}.
These {\em executable-statements} assign values to the variables
in the {\em block-assignment-statement's} {\em variable-list}.
Furthermore, every variable in the
{\em block-assignment-statement's} {\em variable-list}
\underline{must} be assigned a value
by exactly one of the {\em executable-statements}.
Also the value of one of these variables cannot
be input to any of the {\em executable-statements} until the
variable has been assigned a value by a previous one of the
{\em executable-statements}.

Variables allocated in the block are not visible outside the
block.  They may \underline{not} have the same name as a variable
\TT{v} visible outside the block,  but may have the name `\TT{next v}'
to indicate the next value of \TT{v} within the block.
However, this `\TT{next v}' will not be visible outside the block.

\subsection{Conditional Assignment Statements}
\label{CONDITIONAL-ASSIGNMENT-STATEMENTS}

\ikey{Conditional assignment statements}{conditional assignment}
are similar to block assignment statements:

\begin{indpar}
\emkey{conditional-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em variable-list} \TT{=} \}\QMARK{} \ttkey{if}\TT{:} \\
	\TT{~~~~}\ttkey{default}\TT{:} \\
	\TT{~~~~~~~~~}{\em executable-statement}\STAR{} \\
	\TT{~~~~}\TT{default:} \\
	\TT{~~~~~~~~~}{\em executable-statement}\STAR{} \\
	\TT{~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em executable-statement}\STAR{} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em executable-statement}\STAR{} \\
	\TT{~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	\TT{~~~~}\ttkey{else}\TT{:} \\
	\TT{~~~~~~~~~}{\em executable-statement}\STAR{} \\
	\end{tabular}
\end{indpar}

In this case the {\em condition-expressions} are evaluated in order
until either one evaluates to true or the `\TT{else}' condition is
reached, and then the {\em executable-statements} subject to the
first true condition (a.k.a the \key{subblock} of that condition)
are executed, or if no condition is true, the {\em executable-statements}
of the `\TT{else}' subblock are executed.  Each separate subblock of
{\em executable-statements} must set \underline{every} variable
in the {\em condition-assignment-statement's} {\em variable-list} exactly
once, with exceptions for defaults described next.

A {\em conditional-assignment-statement} with a
{\em variable-list} may have one or
more `\ttkey{default}\TT{:}' subblocks.  Each assigns one or more
variables in the {\em variable-list}.  After any non-default subblocks
that are going to execute have executed, if there are any unset
variables in the {\em variable-list}, enabled default subblocks are executed
in order.  A default subblock is enabled if and
only if \underline{all} of the
{\em variable-list} variables set by the default subblock have
\underline{not} been set yet.

No two default subblocks may set the same {\em variable-list}
variable.  This rule is purely to prevent overly clever code that
uses the execution of earlier default blocks to disable the
execution of later default blocks.

Every variable in the {\em variable-list} \underline{must} be set by some
single subblock that executes.  A variable in the
{\em variable-list} cannot be read by a subblock {\em executable-statement}
unless it is set by a previous {\em executable-statement} in the
same subblock.

and variables declared in the subblocks are not visible outside their
subblock.

An example is:
\begin{indpar}\begin{verbatim}
float64 result = max ( float64 x, float64 y, float64 z ):
    result = if:
        default:
            result = NaN
        x > y and x > z:
            result = x
        y > z && y > x:
            result = y
        z > y && z > x:
            result = z
\end{verbatim}\end{indpar}

where \TT{NaN} means `\key{not-a-number}' and is the missing
value for \TT{float64} variables.  \TT{x~>~y} is true if
and only if neither \TT{x} nor \TT{y} is a \TT{NaN} and
\TT{x} is strictly greater than \TT{y}.  Thus if any of
\TT{x}, \TT{y}, or \TT{z} in the above conditional assignment
is a \TT{NaN}, none of the non-\TT{default} {\em conditional-expressions}
will be true, and the \TT{default} will be evaluated to set
the \TT{result} to a \TT{NaN}.

\subsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

\ikey{Loop assignment statements}{loop assignment}
are similar to block assignment
and conditional assignment statements.  An example is:
\begin{indpar}\begin{verbatim}
// Calculate the sum of i for i == 1 to i == n.
//
int64 n = . . .
int64 sum = loop:
    initially:
        int64 i = 1
        int64 partial sum = 0
    while i <= n:
        next partial sum = partial sum + i
        next i = i + 1
    finally:
        sum = partial sum
\end{verbatim}\end{indpar}



The general syntax of loop assignment statements is:

\begin{indpar}
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	          \ttkey{loop:} \\
	\TT{~~~~}\ttkey{initially}\TT{:} \\
	\TT{~~~~~~~~~}{\em assignment-statement}\STAR{} \\
	\TT{~~~~}\ttkey{while} {\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em executable-statement}\STAR{} \\
	\TT{~~~~}\ttkey{finally}\TT{:} \\
	\TT{~~~~~~~~~}{\em executable-statement}\STAR{} \\
	\end{tabular}
\end{indpar}

This is somewhat like the conditional assignment statement
except the `\TT{while}' subblock is iterated and there are iteration
variables defined by the \TT{initially} subblock.

The \skey{iteration variable}s are the
{\em result-variables} of the
{\em assignment-statements} executed by the `\ttkey{initially}' subblock.
Each iteration of the loop gives these variables new values using
`\TT{next v}' to refer to the next value of \TT{v}, where \TT{v}
is an iteration variable.  In the example `\TT{i}' and
`\TT{partial sum}' are iteration variables.

The iteration subblock is qualified by `\ttkey{while}'
{\em condition-expression}' and only executes if the
{\em condition-expression} evaluates to true.  Then
for every iteration variable \TT{v}
it must set the variable `\TT{next v}' or `\TT{next next v}',
as indicated below.

Lastly, when
the {\em condition-expression} evaluates to false, the
subblock qualified by `\ttkey{finally}'
executes, and it must set all the variables in the
loop statement's {\em result-variable-list}.  At this point the loop stops
executing.

Loops are always in effect unravelled so multiple copies of
the `\TT{while}' subblock exist at one time.
`\TT{next v}' refers to \TT{v} in the
next iteration of the loop, which exists simultaneously with
the current iteration.  `\TT{next next v}' refers to \TT{v}
in the next iteration to the next iteration of the loop, which
also exists simultaneously with the current iteration.

For a given iteration variable \TT{v},
either the \TT{initially} subblock sets \TT{v}
and the `\TT{while}' subblock sets `\TT{next v}',
or the \TT{initially} subblock sets both \TT{v} and `\TT{next v}'
and the `\TT{while}' subblock sets `\TT{next next v}'.
Values of `\TT{next v}' and `\TT{next next v}' may be stored in
the stack memory of an iteration that will never be executed.

The \TT{finally} subblock executes at the end using the iteration
variable values that would be used for an additional iteration,
were such an iteration to exist.

There are always at least 4 iterations of the loop with variables
simultaneously in the current execution frame stack: the current iteration,
the previous iteration (if any), and the next two iterations.
When the third iteration of the loop starts, the first
iteration can be discarded, and so forth.

The stack (\itemref{STACK-MANAGEMENT})
of a loop iteration subblock may be deallocated by the time the
iteration subblock finishes executing.
However, deallocation of some of these stacks may be deferred by
an implementation, which may allow debuggers to look at them
in some circumstances.


\subsection{Call Assignment Statements}
\label{CALL-ASSIGNMENT-STATEMENTS}

\ikey{Call assignment statements}{call assignment}
are used to call out-of-line functions:

\begin{indpar}
\emkey{call-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em variable-list} \TT{=} \}\QMARK{}
	        {\em call-assignment-option}\STAR
		~\ttkey{call}~ {\em function-expression} \TT{:} \\
	\TT{~~~~}{\em assignment-statement}\STAR{}
	\end{tabular} \\[1ex]
\emkey{call-assignment-option}
	\begin{tabular}[t]{rl}
	::= & \TT{*UNCHECKED*} $|$ \TT{*REVERSE*} $|$ \TT{*NO-RELOAD*} \\
	\end{tabular}
\end{indpar}

The {\em function-expression} evaluates to a function to be called,
and its type \TT{T} must have the \TT{adr} type as its underlying type.
The values of the variables created by the {\em assignment-statements}
are the arguments to the function.
The results of the function call are stored in the
{\em variable-list} variables.

A call assignment must have the \TT{*UNCHECKED*} option
unless \TT{T} is declared by an out-of-line
function type declaration of the form:

\begin{indpar}
\emkey{function-type-declaration} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function type}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em call-assignment-option}\STAR{}
		    {\em defined-type-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-list}\STAR{}
	\end{tabular}
\end{indpar}

This makes \TT{adr} the underlying type of the new
defined type, and declares the prototype
for the function.
Then a call assignment block is type-checked by matching
the variable names in the call assignment block
to those in the prototype.  Thus the order of variables
in the call block does not matter.  Also, a call block argument
may be of different
type than corresponding prototype argument if there is an implied
conversion from the call block
argument type to the prototype argument type,
in which case the implied conversion will be invoked.

Out-of-line functions are defined by declarations of the form:

\begin{indpar}
\emkey{out-of-line-function-declaration} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em call-assignment-option}\STAR{}
		    {\em function-type-name} {\em function-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-list}\STAR{} \\
		\TT{~~~~do:} \\
		\TT{~~~~~~~~}{\em executable-statement}\STAR{} \\
	\end{tabular}
\end{indpar}\label{OUT-OF-LINE-FUNCTIONS}

This defines {\em function-name} to be both a compile-time and run-time
constant (with different values at compile and run time) of type
{\em function-type-name} and also declares {\em function-type-name}
after the manner of a {\em function-type-declaration}.  When the function
is called, the {\em executable-statements} execute to produces the
result variable values from the argument variable values.

If there is no function prototype (so the call is \TT{*UNCHECKED*}),
there is no matching of
argument variable names to prototype variable names.  In this case
normally arguments are passed to the function in the order they
appear in the call block,
top to bottom, left to right, which is the order in which they
are computed.  However, in this case the
\ttkey{*REVERSE*} option reverses the order in which the argument
are passed, so the first computed is the last passed.

Normally a `\TT{reload mem}' statement (see \itemref{THE-RELOAD-COMMAND})
is executed automatically
upon returning from the called function, but the
\ttkey{*NO-RELOAD*} option suppresses this.

The \TT{*REVERSE*} and \TT{*NO-RELOAD*} options require the \TT{*UNCHECKED*}
option.

Normally the standard call linkage for the computer environment of
the program is used.  Other implementation specific call options
may alter the call linkage used.

\subsection{Out-of-Line Assignment Statements}
\label{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}

An \key{out-of-line assignment statement} is like a combination of
an {\em call-assignment-statement} with
an {\em out-of-line-function-definition}:

\begin{indpar}
\emkey{out-of-line-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em variable-list} \TT{=} \}\QMARK{}
	        {\em call-assignment-option}\STAR
		~\ttkey{out-of-line} \TT{:} \\
	\TT{~~~~}{\em assignment-statement}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em executable-statement}\STAR{} \\
	\end{tabular}
\end{indpar}

An {\em out-of-line-function-declaration} is constructed from this statement
by adding internally generated {\em function-type-name}
and {\em function-name},
and then this statement is executed as a {call-assign\-ment-statement}
using the {\em function-name} and deleting the {\em executable-statements}.

\subsection{Compile-and-Run Assignment Statements}
\label{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}

A \key{compile-and-run assignment statement} computes a set of
variables that have values constant in a block, then compiles
the block using these constant values to optimize the compilation,
and lastly runs the block:

\begin{indpar}
\emkey{compile-and-run-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em variable-list} \TT{=} \}\QMARK{}
		~\ttkey{compile-and-run} \TT{:} \\
	\TT{~~~~}{\em assignment-statement}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em executable-statement}\STAR{} \\
	\end{tabular}
\end{indpar}

The variable values are set by the {\em assignment-statements}.
Then the {\em executable-statements} are compiled, using
the variable values to optimize the compilation.  Then the
compiled code is executed.  The variables in the {\em variable-list}
must have different names from the variables set by the
{\em assigment-statements}, and the {\em variable-list}
variables are set by the {\em executable-statements} as for
a block assignment statement (see \itemref{BlOCK-ASSIGNMENT-STATEMENTS}).
If a variable \TT{v} is set by an {\em assignment-statement},
`\TT{next v}' can be set by an {\em executable-statement}, but
this will be a new variable whose value will not be available during
the compilation.

When the compile-and-run assigment statement is executed, the compiled
code may be saved in a table indexed by the values of the
variables set by the {\em assignment-statements}.  When the
compile-and-run assigment statement is re-executed, if these
variables have the same value they had during a previous execution,
the compilation may be bypassed and the previously compiled code used.
This optimization is permitted but not required.


\subsection{Assembly Assignment Statements}
\label{ASSEMBLY-ASSIGNMENT-STATEMENTS}

\ikey{Assembly assignment statements}{assembly assignment statement}
are used to embed assembler instructions in compiled code:

\begin{indpar}
\emkey{assembly-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \\
	\TT{~~~~} \TT{*UNCHECKED*}~\ttkey{*ASSEMBLY*} ~
	          {\em argument-variable-list}\TT{:} \\
	\TT{~~~~~~~~~}{\em assembler-instruction}\STAR{} \\
	\end{tabular}
\end{indpar}

The variables, both argument and result, are placed in registers
and their names become register names for the assembler instructions.
Assembler instructions are only permitted to reference these
registers, but load and store assembler instructions may be used.
The assembly instructions are written in the syntax of one of the
target machine assemblers.

The variables may have additional qualifiers which
are names of registers or groups of registers.  In this case
the variables will be allocated to the specified registers or
register groups.  Otherwise they will be allocated to target
machine specified register groups based on variable type.

\subsection{Compile-Time Assignment Statements}
\label{COMPILE-TIME-ASSIGNMENT-STATEMENTS}

\ikey{Compile-time assignment statements}{compile-time assignment statement}
run only once, when they are compiled, and produce variable values
at compile time:

\begin{indpar}
\emkey{compile-time-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em variable-list} \TT{=} \}\QMARK{} ~~~ \ttkey{compile-time:} \\
	\TT{~~~~}{\em executable-statement}\STAR{}
	\end{tabular}
\end{indpar}

A compile-time block has its own stack, which is freed when the
block finishes executing.

Compile time blocks may only use compile time variables and values,
but may use visible inline functions, out-of-line functions
that have been declared to be compile-time, and global areas
that have been declared to be compile-time.

\section{Stack Management}
\label{STACK-MANAGEMENT}

Each execution thread has a stack that is not in any other
stack.  Each out-of-line function
execution is a block execution that has a stack which is
by default a substack of the thread in which the function
execution is running.  Each subblock in turn has a stack
which is by default a substack of the stack of its containing block.
And each global area has a stack that is not in any other stack.

Conceptually, the assignment statements in a block each allocate memory for
their variable to the current block stack and copy values to these
variables.  As noted above (Section~\itemref{ASSIGNMENT-STATEMENTS}),
the memory and associated copies may be
optimized away in some cases.

Stacks are either free or bound.\label{FREE-STACK}
A bound stack is a substack that is
not deallocated from memory until its smallest containing free stack is
deallocated.  The main reason this is important is that stack addresses
can be passed out of a block with a bound stack to its containing block,
but cannot be passed out of a block with a free stack to its containing
or calling block.  This is implemented by not allowing certain
variables in to have the `\TT{stack}' qualifier: see
Section~\itemref{THE-STACK-QUALIFIER}.

Stacks of out-of-line function executions
(\pagref{OUT-OF-LINE-FUNCTIONS}),
out-of-line assigment statement blocks
(\pagref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}),
and
compile-time assignment statement blocks
(\pagref{COMPILE-TIME-ASSIGNMENT-STATEMENTS})
are free, as is implemented by
not allowing the variables in the {\em variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assigment-statement}, or
{\em compile-time-assigment-statement},
to have the `\TT{stack}' qualifier.

Stacks of loop subblocks are free,
which is implemented by not
allowing the variables in the {\em result-variable-list}
and the iteration variables
of a {\em loop-assignment-statement} to have the `\TT{stack}'
qualifier.

Global area stacks (see Section~\itemref{GLOBAL-AREAS}) are free,
but are never deallocated and make no use of the `\TT{stack}'
qualifier.

All other stacks are bound.  Memory allocated to them
by the `\TT{allocate to stack}' function (\pagref{ALLOCATE-TO-STACK})
is actually
allocated to their smallest containing free stack, and not deallocated
until that free stack is deallocated.

Free stacks are relocatable and can be moved.
Substacks cannot move independently,
but move whenever their smallest containing free stack moves.
Any stack address is relative to its containing free stack,
which is the current free stack at the time executable code uses
the stack address.  To accommodate this builtin memory read-write
functions with not only accept an \TT{adr} value as a RAM address,
but also accept a RAM address consisting of an \TT{unsadr}
offset within the stack and a stack base address that is itself
stored in RAM.  See Section~\itemref{THE-MEM-QUALIFIER} for details.

There are a couple of situations in which free stacks move.

Memory of runtime determined size can be allocated to the end of
a stack by the `\TT{allocate to stack}' and `\TT{allocate to global}'
functions described below, and such may
require that the smallest containing free stack
be moved to a memory region where there is more free memory available.

In a program being debugged, free stacks may be saved after they are no
longer needed by the program, in order to permit them to be analyzed
by a debbugger if the program detects and error.  In this situation
free stacks are allocated to a very big circular buffer, and overwritten
after they are no longer needed by the program.  It may happen that
a free stack whose block is still running is in the way of a allocating
a new stack to the circular buffer, in which case the still running
block's free stack may be moved.

Lastly, global area stacks (\pagref{GLOBAL-AREAS})
may be deallocated when programs that
can reference them are still running, or may not yet be allocated
when these programs run.  Deallocated global area stacks are treated as if
they were allocated to inaccessible memory, so deallocating these stacks
is like moving them to inaccessible memory, and referencing
them when they are deallocated gives a memory fault.


\subsection{Unwind Blocks}
\label{UNWIND-BLOCKS}

\ikey{Unwind blocks}{unwind block} are executed only when their
containing block terminates:

\begin{indpar}
\emkey{unwind-block}
    ::= \begin{tabular}[t]{l}
	\ttkey{*UNWIND*}\TT{:} \\
	\TT{~~~~}{\em executable-statement}\STAR{} \\
	\end{tabular}
\end{indpar}

Specifically, when an unwind block is encountered while
executing its containing block, the unwind block is marked
as enabled, but is skipped.  Then when the containing block
terminates, all its enabled unwind blocks are executed in
the reverse order of that in which they were enabled.

Unwind blocks are used to close or deallocate things that were opened.
For example, right after a statement that opens a file there may be
an unwind block that closes the file.  This ensures that the file
will be closed even if the block that opened it terminates later
prematurely with an error, such as a memory fault.

\subsection{Throw and Catch}
\label{THROW-AND-CATCH}

\TT{*THROW*} and \TT{*CATCH*} statements are used to implement
exceptions, i.e., abnormal termination.

\begin{indpar}
\emkey{throw-statement} ::= \TT{*THROW*} \\[1ex]
\emkey{catch-statement} ::= \TT{*CATCH*}
\end{indpar}

The \TT{*THROW*} statement causes its containing block to
\ikey{terminate abnormally}{abnormal termination}.
When a block terminates abnormally, its containing
block is also terminated abnormally.

\ikey{Normal termination}{normal termination}
of a block occurs at the end of the block if
the block has not executed a \TT{*THROW*} or an abnormally
terminating subblock.

Any enabled \TT{*UNWIND*} subblocks of an abnormally terminating
block are executed in reverse order, just as they would be if
the block were terminating normally.  No other part of the block
is executed.

If an \TT{*UNWIND*} subblock executing in an abnormally terminating
containing block \TT{B}
executes a \TT{*CATCH*} statement, the termination of this
containing block \TT{B}
is changed from abnormal to normal.  This means
that \TT{B}'s containing block \TT{C} will resume when the now
normally terminating block \TT{B} finishes terminating.
However, \TT{B} will not execute anything but \TT{*UNWIND*}
subblocks, as it is still terminating.

Machine errors, i.e. memory segment faults, invoke callable functions
which can record error information and execute a \TT{*THROW*}.
Similarly detected programming or data errors can record
error information and execute a \TT{*THROW*}.  An \TT{*UNWIND*}
block can look at recorded error information and decide whether
or not to execute a \TT{*CATCH*}.

If a block has variables it must assign then these need not be
assigned if the block terminates abnormally, as they will not
be visible to enabled \TT{*UNWIND*} blocks.  However, if a block
that is terminating abnormally executes a \TT{*CATCH*} statement,
all variables that the block must assign must be given values, even
though part of the block may not have executed.  The compiler
will check this, and will only permit code that complies in a
straight forward manner, so it may be best to assign all such
variables in the \TT{*UNWIND*} block that contains the \TT{*CATCH*}
statement.

\subsection{Stack Memory Allocation}
\label{STACK-MEMORY-ALLOCATION}

The `\ttkey{allocate to stack}' function allocates \TT{N} bytes of
memory to the current free stack and returns its offset within
the stack and the address of the stack base address:

\begin{indpar}\begin{verbatim}
( stack *UNCHECKED* unsadr offset,
  mem adr offset.base,
  *UNCHECKED* adr offset.base.adr  ) =
allocate to stack ( unsadr N )
\end{verbatim}\end{indpar}\label{ALLOCATE-TO-STACK}

Here `\TT{offset}' is the offset of the \TT{N} bytes within the
stack, `\TT{offset.base}' is the base address of the stack, and
stack, `\TT{offset.base.adr}' is the address of where this
base address is stored in RAM.  The first and last of these
are fixed but `\TT{offset.base}' may change when the stack is
moved.

The returned values are a cluster: see Section~\itemref{CLUSTERS}.
Also used are the `\TT{stack}' qualifier (see \itemref{THE-STACK-QUALIFIER})
and `\TT{*UNCHECKED*}' qualifier (see \itemref{THE-UNCHECKED-QUALIFIER}).

The memory is freed when the free stack to which it is allocated
is freed.  The memory containing the \TT{offset.base} value is
also freed at this time.  The `\TT{stack}' qualifier is used to
ensure that addresses of these values cannot survive the free stack:
see \itemref{THE-STACK-QUALIFIER}.

The memory allocated is always alligned on an \TT{8} byte boundary.

If you want a different alignment you can use:

\begin{indpar}\begin{verbatim}
( stack *UNCHECKED* unsadr offset,
  mem adr offset.base,
  *UNCHECKED* adr offset.base.adr  ) =
    allocate to stack ( unsadr N, unsadr O, unsadr A )
\end{verbatim}\end{indpar}

where \TT{A} must be a power of \TT{2} not greater than \TT{64}.
This will align the \TT{O+1}'st
byte of the allocated memory block
at an address which is a multiple of \TT{A}\,.
Free stacks are always allocated on a \TT{64} byte boundary.


\subsection{Global Areas}
\label{GLOBAL-AREAS}

A global area is like the stack frame of a function that has no
arguments or return value, except that after this function executes,
the global area remains allocated and its variables can be referenced
by other code.  The syntax is:
\begin{indpar}
\emkey{global-area-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	\TT{global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em executable-statement}\STAR{} \\
	\end{tabular}
\end{indpar}

Several such blocks may have the same {\em global-area-name},
as long as no {\em variable-name} appears in more than one of these blocks.

In order to be accessed a global area must be named in an `\TT{extern}'
statement:
\begin{indpar}
\emkey{extern-global-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	\TT{extern} {\em global-area-abbreviation}
	            \TT{is global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em extern-variable-statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{extern-variable-statement} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & {\em variable-abbreviation} \TT{is}
          {\em qualifier}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\end{indpar}

A variable with {\em variable-name}
\TT{V} in a global area with {\em global-area-abbreviation}
\TT{A} may be named as \TT{A.V}, or if the variable has its own
{\em variable-abbreviation} \TT{VA},
this by itself (and \underline{not} \TT{A.VA})
may be used to name the variable.  Abbreviations are only affective
within the source code file containing the `\TT{extern}' statements
that define them.

The {\em type-name} and {\em qualifiers} of a variable in an
{\em extern-variable-statement} must match the {\em type-name}
and {\em qualifiers} of the variable in its {\em global-area-block},
except that TBD.


If \TT{A.V} is not defined, it is not a compile or link time error
(though there may be warning messages if requested), but accessing
\TT{A.V} will cause a runtime error (typically a segmentation fault).


Memory within a global area can be allocated by:

\begin{indpar}\begin{verbatim}
( global *UNCHECKED* unsadr offset,
  mem adr offset.base,
  *UNCHECKED* adr offset.base.adr  ) =
    allocate to global ( unsadr N )
( global *UNCHECKED* unsadr offset,
  mem adr offset.base,
  *UNCHECKED* adr offset.base.adr  ) =
    allocate to global ( unsadr N, unsadr O, unsadr A )
\end{verbatim}\end{indpar}\label{ALLOCATE-TO-GLOBAL}

Here \TT{A} must a power of \TT{2} not greater than \TT{64}.
Global areas are allocated on a \TT{64} byte boundary and
may be moved during execution.

The `\TT{allocate to global}' function plays the same role for
global areas as the `\TT{allocate to stack}' function does for
stacks, accept that the address gets the \TT{global} qualifier
instead of the \TT{stack} qualifier.  The \TT{global} qualifier
has no special properties and normally has no effect on code.

The code of a global area block is executed when the file containing it is
loaded, and the stack of the area is allocated and defined at that
time.  Global areas may be deallocated or moved during execution.
References to a global area
that is not yet allocated or that has been deallocated cause runtime
errors (typically segmentation faults).

\section{Clusters}
\label{CLUSTERS}

A \key{cluster} is a group of related variables.  One variable of
the cluster is the \mkey{base variable}{of cluster} of the cluster, and the
other variables have names that are derived from the
name of the base variable using the syntax:


\begin{indpar}
{\em variable-name} ::=
    {\em base-name} {\em member-selector}$^\star$ \\[1ex]
{\em member-selector} \begin{tabular}[t]{@{}rl}
    ::= & \TT{.}{\em member-name} \\
    $|$ & \TT{[}{\em member-index-list}\TT{]}
    \end{tabular} \\[1ex]
{\em member-index-list} \begin{tabular}[t]{@{}rl}
    ::= & {\em member-index} \\
    $|$ & {\em member-index} \TT{,} {\em member-index-list}
    \end{tabular} \\[1ex]
{\em member-index} ::= {\em integer-constant-expression}
\end{indpar}

Thus a cluster
is like a structure, but it is a set of variables and not a
piece of memory.

More specifically, the members of the cluster can be named by
adding either a member name preceded by `\TT{.}' or a
`\TT{[]}' bracketed list of
integer constant subscripts to
either the base variable name of the cluster or to another member name
of the cluster.  Two variable names with different base variable names
belong to different clusters.

Variables in clusters are thus organized into trees, with clusters
that have different bases being disjoint.  Any variable in a cluster
can be considered
as the \mkey{root}{of subcluster} of a subtree of cluster members, and
the subtree is called a \key{subcluster}.

The main feature of clusters and subclusters
is that members are passed to or returned
from functions implicitly when their the root variable is named
explicitly.  For example:
\begin{indpar}\begin{verbatim}
type pointer pair is void
    // if pointer pair pp then
    //   intadr pp.begin points at the first element
    //   intadr pp.end points just AFTER the last element
    //   adr pp.base is the address of the base address
    //   type pp.type is type of element

// Function to allocate a vector of n T's to the stack.
//
( stack pointer pair pp,
  unsadr pp.begin,
  unsadr pp.end,
  adr pp.base,
  type pp.type ) =
        allocate to stack ( type T, uns32 n ):
    pp.type = T
    require ( zero value OK ( T ) )
    unsadr length = size of ( T ) * n
    ( unsadr offset, mem adr offset.base,
                     adr offset.base.adr ) =
        allocate to stack ( length )
    pp.begin = offset
    pp.end = offset + length
    pp.base = offset.base.adr


// Prefix operator to dereference a pointer pair to read
// memory.
//
( mem pp.type out,
  *UNCHECKED* stack out.offset,
  mem adr out.offset.base,
  *UNCHECKED* out.offset.base.adr ) =
        "*" ( stack pointer pair pp,
              type pp.type,
	      unsadr pp.begin,
	      unsadr pp.end,
	      adr pp.base ):
    ( out.offset, out.base.adr ) = if:
        pp.begin < pp.end:
            ( out.offset, out.offset.base.adr ) =
	        ( pp.begin, pp.base )
        else:
            fatal error
                ( "Deferencing empty pointer pair." )

// Prefix operator to dereference a pointer pair to
// write memory.
//
"*" ( stack pointer pair pp,
      unsadr pp.begin, unsadr pp.end, adr pp.base,
      type pp.type ) =
        ( pp.type in ):
    if:
        pp.begin < pp.end:
	    unsadr offset = pp.begin
	    adr mem offset.base
	    adr offset.base.adr = pp.base
            in *UNCHECKED* ---> offset
        else:
            fatal error
                ( "Deferencing empty pointer pair." )

// Prefix operator to increment the begin pointer of a
// pointer pair.  Note the result is a NEW pointer pair.
//
( stack pointer pair pp2,
  unsadr pp2.begin, unsadr pp2.end,
  adr pp2.base, type pp2.type )
        "++" ( stack pointer pair pp,
               type pp.type,
               unsadr pp.begin, unsadr pp.end,
	       adr pp.base ):
      pp2.begin = pp.begin + size of ( T )
      pp2.end = pp.end
      pp2.base = pp.base
      pp2.type = pp.type

// Assignment operator for pointer pairs.
//
( stack pointer pair pp2,
  unsadr pp2.begin,
  unsadr pp2.end,
  adr pp2.base,
  type pp2.type ) =
        "=" ( stack pointer pair pp,
              type pp.type,
              unsadr pp.begin, unsadr pp.end,
	      adr pp.base ):
      pp2.begin = pp.begin
      pp2.end = pp.end
      pp2.base = pp.base
      pp2.type = pp.type

// Example usage:
//
    ... out-of-line function header ...

    // Vector of 2 int32's is allocated and the elements
    // are set equal to 100 and 101.
    //
    pointer pair pp = allocate to stack ( int32, 2 )
    * pp = 100
    next pp = ++ pp
    * pp = 101
    . . . .
    // Vector of 1000 float64's is summed.
    //
    pointer pair ppf = allocate to stack ( float64, 1000 )
    ... set 1000 elements ...
    float64 sum = loop:
        initially:
            float64 partial sum = 0
            pointer pari ppf2 = ppf
        while ppf2.begin < ppf2.end:
            next partial sum = partial sum + * ppf2
            next ppf2 = ++ ppf2
        finally:
            sum = partial sum
\end{verbatim}\end{indpar}

Cluster member names may be used as prototype parameter
names, with the root of these names also being a prototype
parameter.  This specifies that the parameters are related
by being in the same cluster.

When this is done for arguments, the cluster root must
also be an argument, and the cluster member values
will be derived from the root, and \underline{must}
be omitted in calls.

When this is done for results, the cluster root must similarly
be a result, and the values of the designated
members of the cluster are set from the results.
Again the cluster members \underline{must} be omitted in calls.

A variable of \TT{void} type has no actual value
and must not be assigned one.  Such variables are only useful
as cluster and subcluster roots.

In the above example `\TT{mem}' and `\TT{stack} are qualifiers
which can be applied to variables.
See \itemref{QUALIFIERS}.

The `\TT{mem}' qualifier has the special property that given a variable
\TT{v} of type \TT{T} and qualifier \TT{mem}, then if \TT{v} is allocated,
and \TT{v.adr} of type \TT{adr} and qualifier \TT{*UNCHECKED*}
is allocated and
assigned a value, the base \TT{v} will also be automatically
assigned as its value the value read from RAM address \TT{v.adr}.
It is an error in this case to explicitly assign a value to \TT{v}.
See \itemref{THE-MEM-QUALIFIER}.

The `\TT{stack}' qualifier has the property that values with
this qualifier may not be passed out of a block with a free
stack.  See Sections~\itemref{STACK-MANAGEMENT} and
\itemref{THE-STACK-QUALIFIER}.

\section{Builtin Qualifiers}
\label{BUILTIN-QUALIFIERS}

\subsection{The Memory Qualifier}
\label{THE-MEM-QUALIFIER}

The \ttkey{mem} qualifier is a non-inverted protection qualifier that behaves
in a special way when it is given to a variable \TT{v}.
In this situation \TT{v} is a copy of a RAM memory value and
must be the root of a subcluster that
has either:
\begin{enumerate}
\item
A variable \TT{v.adr} of type \TT{adr} that is the RAM address of \TT{v}.

\item
A variable \TT{v.offset} of type \TT{intadr} or \TT{unsadr} and
a variable \TT{v.offset.base} of type \TT{adr} and qualifier \TT{mem}.
In this case the RAM address of \TT{v} is \TT{v.base+v.offset} and
\TT{v.offset.base} must recursively be the root of a subcluster obeying
these rules (so there must be either a \TT{v.offset.base.adr} variable
or \TT{v.offset.base.offset} and \TT{v.offset.base.offset.base}
variables, etc.).
\end{enumerate}
Then the
variable \TT{v} must \underline{not} be given a value by an
assignment statement, but will instead be loaded with a value
from its RAM address.

Because \TT{mem} is a protection qualifier, \TT{v} and the required
members of the cluster of which \TT{v} is a root
must be created as matches to result variables of a function.
So only functions can effect a load of RAM contents to a variable.

It is further required that both \TT{v} and the required members of
the cluster of which \TT{v} is a root be created
by the same function call assignment statement, and that the required
\TT{.offset} and \TT{.adr} variables in that cluster
be given the \TT{*UNCHECKED*} qualifier by that function
call asssignment statement.
The function must assign a value to these \TT{*UNCHECKED*} variables
(but not the \TT{mem} qualified \TT{v} and \TT{.base} variables).
Thus all memory reads are hidden
inside functions which have the \TT{mem} qualifier on some of
their result variables.


\subsection{The Stack Qualifier}
\label{THE-STACK-QUALIFIER}

The `\ttkey{stack}' qualifier is an inverted, inherited,
protection qualifier
attached to offsets and addresses
returned by the builtin `\TT{allocate to stack}'
function.  It is used to keep these from being stored in
non-stack memory and in stacks who lifetime exceeds that of the
memory the stack address points at.

The special property of the `\TT{stack}' qualifier is that it cannot
be used to qualify variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assigment-statement}, or
{\em compile-time-assigment-statement},
or iteration variables in a {\em loop-assigment-statement}.
This is so that stack addresses pointing into a free stack
cannot outlive the free stack: see \pagref{FREE-STACK}.

See Section~\itemref{STACK-MANAGEMENT} for more information.

\subsection{The \TT{*UNCHECKED*} Qualifier}
\label{THE-UNCHECKED-QUALIFIER}

The \TT{*UNCHECKED*} qualifier is a non-inverted, non-inherited,
protection qualifier that must qualify the \TT{v.adr} or
\TT{v.offset} variables
associated with a variable \TT{v} that has the \TT{mem} qualifier.
See Section~\itemref{THE-MEM-QUALIFIER}.

The lexeme \TT{*UNCHECKED*} lexeme has many other uses.  It cannot
be part of a variable name, but can be part of a non-variable name,
e.g., a function name or a statement name such as
`\TT{*UN\-CHECK\-ED* *ASSEMBLER*}'.  In these other uses it is
\underline{not} a qualifier.

\subsection{Trace Qualifiers}
\label{TRACE-QUALIFIERS}

A \key{trace qualifier} permits values to be marked so that they
can be found (i.e., `traced') by garbage collectors
(and occassionally debuggers)
when they are stored in the
stack.  A trace qualifier may be declared by:

\begin{indpar}
\emkey{trace-qualifier-declaration}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{trace qualifier}
           {\em defined-qualifier-name} \\
        & ~~~~~ \TT{with base type}~~{\em type-name}
    \end{tabular}
\end{indpar}

The base type of a trace qualifier may be determined by the
function with the prototype:
\begin{center}
{\tt (type T) = \ttkey{base type of} ( qualifier Q )}
\end{center}
The value of any variable with a trace qualifier must be
\TT{*UNCHECKED*} convertable to a value of the base type.

It is common to add a trace qualifier to the statement that
defines a type you want to trace.  An example in which the
qualifier is \TT{Q} and the type is \TT{T} is:
\begin{indpar}\begin{verbatim}
trace qualifier Q with base type adr
type Q T is adr
\end{verbatim}\end{indpar}
which causes all value of type \TT{T} in the stack to be
traced.

More specifically, when a value \TT{V} of a variable with the trace
qualifier \TT{Q} is added to a stack, \TT{V} converted to the
base type of \TT{Q} is also
pushed into a (virtual or physical) \TT{Q}-stack of values with
the trace qualifier \TT{Q}.
When the stack containing \TT{V} is freed, the corresponding
value in the \TT{Q}-stack is popped.  There is a \TT{Q}-stack
associated with every process and every global area.
Using functions in the
subroutine library (see TBD), these \TT{Q}-stacks can be read.

\subsection{The Reload Statement}
\label{THE-RELOAD-COMMAND}

The reload statement has the syntax:
\begin{center}
\ttkey{reload} {\em qualifier-name} \{ \TT{,} {\em qualifier-name} \}\STAR{}
\end{center}

This statement declares the values of all variables with the designated
qualifiers to be out-of-date and unusable.  If any of these variables
is used subsequently, statements to recompute the variable value
may be inserted automatically into the code at the point of the
\TT{reload} statement.

Variable values are recomputed in the same order as they were
originally computed.  How each variable is recomputed depends upon
how it was originally computed.

If the variable \TT{v} has the `\TT{mem}' qualifier and was loaded
from RAM by setting the \TT{v.adr} address variable, then the value
in RAM is assumed to have changed, and is declared to be out-of-date.
If \TT{v.adr} is unchanged or
can be recomputed, then \TT{v} is reloaded from RAM.

If the variable \TT{v} was originally computed by
a {\em value-assignment-statement}
of the form `{\em type} \TT{v =} {\em expression}', then if
no input to {\em expression} is out-of-date, \TT{v} is not out-of-date.
Otherwise if all the inputs that are out-of-date can be recomputed,
\TT{v} is recomputed.  However, \TT{v} is not recomputed if this
recompuation requires evaluation of loops or out-of-line calls or
writes to RAM;
but it will be recomputed if evaluation can be done with a conditional
statement subblock that does not involve loops or out-of-line calls or
writes to RAM,
even if other subblocks of the conditional statement do involve such.

If a recomputed variable value is not used after the \TT{reload} statement,
if is not recomputed.

\section{Function Prototypes and Calls}
\label{FUNCTION-PROTOTYPES-AND-CALLS}

Implicit types and qualifiers.
Type sets.  Conditions using qualifier and type sets.

\section{TBD}

\TT{pure} functions that do not need recomputation and have no
visible side effects

\TT{trace} variables which can be located in stack by GC.

\section{Memory Channels}
\label{MEMORY-CHANNELS}

OLD STUFF: REVISE.

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
structured set of elements each associated with a member of
some data set.  Each window element contains a
\key{block descriptor} that holds the address and length of the
memory block that contains the data associated with the element.
Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
The window has a \key{reference point}, and window elements are addressed
relative to this reference point.  There are shift operations that move
the reference point to a nearby window element.

Although we talk about blocks here, a block can be just a numeric array
element, and can be as small as a single bit.  Although we talk about
each element of a memory channel window having its own block descriptor,
an actual memory channel may use only block group descriptors, each of
which functions as a group of more than one individual element
block descriptor.

A memory channel is stored in a cluster.  As such it is mostly an
inline construction, though it can be passed to or returned from a
function, and the function can be all or partly out-of-line.

The most common type of memory channel has a window that appears to be
an array with \ttikey{.di\-men\-sions}{dimensions!of memory channel},
\ttdmkey{lower\_bound}{of memory channel}\TT{[}$i$\TT{]},
and \ttdmkey{upper\_bound}{of memory channel}\TT{[}$i$\TT{]}
being memory channel members.  Such are called
\key{array windows}.
If the memory channel cluster name is $M$, the window elements are
referred to by $M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]},
with $M$\TT{[0,0,}\ldots\TT{]} being the \key{reference point}.

The reference point can be shifted along any of the window's
dimensions by the command
\begin{center}
$M$\ttdkey{center}\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]}
\end{center}
This shifts
the window so that what was
$M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]} becomes
$M$\TT{[0,0,}\ldots\TT{]}.

Creating memory channels and completely reseting their reference points
are specific to the type of memory channel, and are not covered in
this section.

For most kinds of memory channels, block descriptors are computed
automatically when channel is created, when the window is
shifted, or when the data of
a neighboring window element is arrives from memory.
Immediately after a block descriptor is created, a read-ahead of
the block is initiated.  This read-ahead overlaps computation that
does not use the block contents.

If a memory channel accesses arrays stored in memory,
the channel block descriptors can be computed from the array coordinates
of the reference point.  Other memory channels use the contents
of a block to compute the block descriptors of neighboring blocks
in the window.

An example of the latter is a binary tree memory channel.
Let $M$ be such a channel, and let `\TT{.L}' denote the left
child of a binary tree element, `\TT{.R}' the right child, and
`\TT{.P}' the parent.  Then $M\!$\TT{.L.R} denotes the right
child of the left child of the reference point, $M\!$\TT{.P.L}
denotes the left child of the parent of the reference point,
and $M\!$\TT{.P.L.center} moves the reference point to this last element.
The window of such a memory channel might contain the depth 2
subtree of the reference point plus that closest 4 ancestors of the
reference point if these have been visited.  When the reference
point is moved, as soon as the reference point element has been
read from memory, the descriptors for its children are built and
the read of the children is initiated in parallel with other
computation.  When the children arrive from memory, the descriptors
of their children are built and reads of the data pointed at
are initiated.\footnote{All this can actually be done with modern
hardware: code is executed to read the reference point children and initiate the
reads of their children, and a modern processor will automatically
save the code that
executes when a read of a reference point child completes and execute
other code in parallel until the read does complete.}

Some standard memory channel types are built into the L-Language.
Others can be defined by users.

\section{To Do}

How can dynamically initialized locations be static.

Indirect address protocol.
\label{INDIRECT-ADDRESS-PROTOCOL}

Threads.
\label{THREADS}

\appendix

\section{Aliasing Hardware}
\label{ALIASING-HARDWARE}

The ultimate solution to the aliasing problem is new hardware.
At its simplest, registers, which currently hold a datum,
are replaced by triples of registers which hold a datum,
an address, and selection codes.  The register datum equals the value
of the memory location at the register address.  The selection
codes determine which part of this memory location is read or written
when the register is read or written.  If any memory location is
changed, the address of the location is checked against all the
register addresses, and if any match, the corresponding register
data are changed.

This is, however, not sufficient, because sometimes one register
address is a function of another register's datum.  For example,
consider the unchecked code:
\begin{indpar}[0.5em]\begin{verbatim}
struct S { ...; int32 m; ... }
S * * x
S * *& y = * x
int32 *& z = y->m
\end{verbatim}\end{indpar}
If we consider \TT{x}, \TT{y}, and \TT{z} to be registers,
the address of \TT{y} equals the value of \TT{x}, and the
address of \TT{z} equals the value of \TT{y} plus the offset of
\TT{m} in \TT{S}.

If the value of \TT{x} changes, this changes the address of \TT{y},
which may change the datum of \TT{y} and that may change the value
of \TT{y}.  If the value of \TT{y} changes, this changes the address
of \TT{z}, which may change the datum and value of \TT{z}.

The way we accommodate this is to use the selection codes of \TT{y}
to specify that the address of \TT{y} contains the value of \TT{x}
as an additive component, so
that if the value of \TT{x} is changed by adding $\Delta$\TT{x}
then the address of \TT{y} should be changed by adding $\Delta$\TT{x}.
And similarly the selection codes
of \TT{z} specify that the address of \TT{z}
contains the value of \TT{y} as an additive component.

So why should we bother with automatically updating
additive inclusions of one value in the
address of another value, and not bother with other expressions.
The reason is that expressions such as
`\TT{(*x)->m}' are likely to be reused frequently in code (actually,
in automatically generated code) and
therefore need to be cached, whereas an expressions of the form
`\TT{c*d}' will be reused comparatively rarely code
and therefore are not worth special hardware.


\bibliographystyle{plain}
\bibliography{layered-l-2012-language}

\printindex

\end{document}

