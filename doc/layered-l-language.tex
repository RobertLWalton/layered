% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{\,\textsuperscript{p\pageref{#1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}


\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

December 12, 2014
 
\end{center}

{\small \tableofcontents}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language.  See the Introduction to the Layered
Programming Languages for basic syntax and for an overview of the related
Middle Layer M-Language and Higher Layer H-Language.

The L-Language is intended to be a target language for compilers of
higher level languages.  As such it is optimized first to be an easy to 
use as a target language, and second to be easy to
compile into reasonably efficient debuggable assembly language code.

The L-Language is similar to the C programming language
differs in the following ways:

\begin{enumerate}

\item
L-Language facilitates isolating untype-safe code into small inline functions.

\item
All L-Language data types are builtin number types or subtypes of
builtin number types.  All data managed directly by L-Language consists
of single numbers allocated to the stack.

Other memory is handled by code
encapsulated in small untype-safe inline functions by the programmer.
Memory references other than those to single stack allocated numbers
are treated in a manner reminiscent of input/output.

\item
The type `\TT{type}' is first class, is a subtype of integers, and
is assigned a unique constant address value for each type.  Constant
argument values, such as the value of a `\TT{type}' valued
argument, can be used to select overloaded functions.

\item
All L-Language functions are inline.  Programmer written untype-safe
functions are used to implement out-of-line function calls.

\item
L-Language associates formatting functions
with data types for use in displaying and in some cases inputting
data during debugging.

\item
L-Language uses a single-assignment style of program structure
to encourage
efficient code that leaves an audit trail for debugging in the stack.
Partial evaluation of expressions and inline code is supported without
compromising debuggability.

\item
L-Language uses the Layered Language Module Structure to manage
multi-file source code in a well-ordered and type-safe manner.


\end{enumerate}


\section{Types}
\label{TYPES}

The basic builtin types are the number and \TT{void} types.
All defined types are subtypes of these types.
There is one builtin define typed, the `\TT{type}' type.

\subsection{Number Types}
\label{NUMBER-TYPES}

Numbers are sequences of bits, and each number is one of
four types, unsigned integer, signed integer, floating point number,
and address:

\begin{indpar}
\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\bf Name & \bf Kind & \bf Length \\[2ex]
\ttkey{uns8}		& unsigned integer & 8 bits \\
\ttkey{uns16}		& unsigned integer & 16 bits \\
\ttkey{uns32}		& unsigned integer & 32 bits \\
\ttkey{uns64}		& unsigned integer & 64 bits \\
\ttkey{uns128}		& unsigned integer & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{int8}		& signed integer & 8 bits \\
\ttkey{int16}		& signed integer & 16 bits \\
\ttkey{int32}		& signed integer & 32 bits \\
\ttkey{int64}		& signed integer & 64 bits \\
\ttkey{int128}		& signed integer & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{float16}		& IEEE floating point number & 16 bits \\
\ttkey{float32}		& IEEE floating point number & 32 bits \\
\ttkey{float64}		& IEEE floating point number & 64 bits \\
\ttkey{float128}	& IEEE floating point number & 128 bits
\end{tabular}

\begin{tabular}{p{1in}@{~~~~~~}p{2in}@{~~~~~~}l}
\ttkey{unsadr}		& unsigned integer & size of address \\
\ttkey{intadr}		& signed integer & size of address \\
\ttkey{adr}		& signed or unsigned integer & size of address \\
\end{tabular}
\end{indpar}

These are the \key{built in number types}:
\begin{indpar}
{\em builtin-number-type-name}
    \begin{tabular}[t]{@{}cl}
    ::= & \TT{uns8} $|$ \TT{uns16} $|$ \TT{uns32} $|$ \TT{uns64}
                    $|$ \TT{uns128} \\
    $|$ & \TT{int8} $|$ \TT{int16} $|$ \TT{int32} $|$ \TT{int64}
                    $|$ \TT{int128} \\
    $|$ & \TT{float16} $|$ \TT{float32} $|$ \TT{float64} $|$ \TT{float128} \\
    $|$ & \TT{unsadr} $|$ \TT{intadr} $|$ \TT{adr} \\
    \end{tabular}
\end{indpar}

The \mkey{length}{of number}
of a number is the number of its bits.  Numbers can have
different lengths: for example, unsigned integers can have
lengths of 8, 16, 32, 64, or 128 bits.

Numbers are stored in registers or in random access memory (RAM).

An \key{unsigned integer} of length $L$ is a binary integer with
$L$ binary digits (\skey{bit}s) and range from $0$ to $2^L-1$.

A \key{signed integer} of length $L$ is a two's complement integer
of length $L$ and range from $-2^{L-1}$ to $+2^{L-1}-1$.
This represents the integer $I$ in the given range
by the unsigned $L$-bit integer equal to $I~\mbox{modulo}~2^L$.

A \key{floating point number} of length $L$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes are as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}r@{~~~~~~}r}
                   &              &              &             & \bf Maximum \\
\bf Floating Point & \bf Exponent & \bf Mantissa & \bf Decimal & \bf Decimal\\
\bf Number Size    & \bf Size     & \bf Size     & \bf Digits  & \bf Exponent
\\[2ex]
16 bits & 5 bits & 10 bits & 3.31 & 4.51 \\
32 bits & 8 bits & 23 bits & 7.22 & 38.23 \\
64 bits & 11 bits & 52 bits & 15.95 & 307.95 \\
128 bits & 15 bits & 112 bits & 34.02 & 4931.77 \\
\end{tabular}
\end{center}

An \key{address} holds a RAM byte address.
An address is a 32-bit or 64-bit signed or unsigned integer whose size
and signage are determined by the target machine.
Some of high order bits may be
required to be all 0's or all 1's, depending upon
the target machine.  The \TT{unsadr} and \TT{intadr}
unsigned and signed integer types of the same size
as an address are provided for storing indices and offsets.

A reasonable assumption for 64-bit addresses is that only the low
order 48-bits of the address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing an address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The L-Language does
\underline{not} depend upon this assumption, but does provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$.  The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.\footnote{The I86 64-bit architecture
uses only the low order 48 bits of an address, but \underline{requires}
the high order 17 bits to all be the same, either all 1's or all 0's.
However, as it is unlikely that there will ever be an allocated memory region
that includes address 0 in its interior, it makes no significant difference
whether we consider addresses to be unsigned or signed.}

The following \underline{implicit} conversion operators are defined:
\begin{center}

\begin{tabular}{rcl}
\hspace*{2.0in} & & \hspace*{2.0in} \\[-2ex]
\TT{uns}$x$ & \TT{<{}<++} & \TT{uns}$y${\em -value} \\
\TT{int}$x$ & \TT{<{}<++} & \TT{uns}$y${\em -value} \\
\TT{float}$x$ & \TT{<{}<++} & \TT{uns}$y${\em -value} \\
\TT{int}$x$ & \TT{<{}<++} & \TT{int}$y${\em -value} \\
\TT{float}$x$ & \TT{<{}<++} & \TT{int}$y${\em -value} \\
\TT{float}$x$ & \TT{<{}<++} & \TT{float}$y${\em -value} \\
\end{tabular}

where $x>y$

\end{center}

For all these implicit conversions no information is lost from
the value when it is converted to the new type.

The following \underline{unchecked} (\itemref{UNCHECKED-BLOCKS})
conversion operator is defined:
\begin{center}

$t2$ ~~ \TT{<{}<**} ~~ $t1${\em -type-value}

for any two builtin number types $t1$ and $t2$

\end{center}

Here the results are undefined if the value cannot be expressed
as type $t2$.


\subsection{The Void Type}
\label{THE-VOID-TYPE}

A \ttkey{void} type variable has no value.  No value can be
assigned to such a variable.  Nevertheless such variables have
uses, for example, as base variable in clusters (\pagref{CLUSTERS}).
When used as the base variable of a cluster, an assignment statement
may appear to be assigning a value to a \TT{void} variable, but
in fact it is assigning values to cluster members.


\subsection{Defined Types}
\label{DEFINED-TYPES}

A statement of the following form defines a type:
\begin{center}
\TT{type} {\em defined-type-name} \TT{is} {\em builtin-type-name}
\end{center}
Here the builtin type is called the \key{underlying type} of the
\key{defined type}.

A value of a defined type may be converted to or from its underlying
type by the \underline{unchecked}
\underline{unchecked} (\itemref{UNCHECKED-BLOCKS})
\TT{<{}<**} operators:
\begin{center}
\begin{tabular}{rcl}
{\em builtin-type-name} & \TT{<{}<**} & {\em defined-type-value} \\
{\em defined-type-name} & \TT{<{}<**} & {\em builtin-type-value} \\
\end{tabular}
\end{center}
These operators do not change the actual value, but merely its
compile-time type.


\subsection{Enumeration Values}
\label{Enumeration-VALUES}

A defined type with an integer underlying type
may have \skey{enumeration value}s.  These are unique integer
values assigned to enumeration constant names during compilation,
and then reassigned to possibly different values during linking.

A statement of the following form defines a type with enumeration
values:
\begin{center}
\TT{type} {\em defined-type-name} \TT{is} {\em builtin-type-name}
    \TT{with enum} {\em enum-range}\QMARK{}
\end{center}
where
\begin{center}
\begin{tabular}{rrl}
\emkey{enum-range}
    & ::= & \TT{[} {\em first-enum} \TT{...} {\em last-enum} \TT{]} \\
    & $|$ & \TT{[} {\em first-enum} \TT{...} \TT{]} \\
\emkey{first-enum}
    & ::= & {\em compile-time-integer-expression} \\
\emkey{second-enum}
    & ::= & {\em compile-time-integer-expression} \\
\end{tabular}
\end{center}

Enumeration values can be assigned by statements of the form
\begin{indpar}
\emkey{enum-assignment}
    ::= {\em type-name} {\em constant-name} \TT{=} \TT{next enum}
\end{indpar}

Within a compilation the compiler assigns the value {\em first-enum}
to the first constant named in an {\em enum-assignment} statement for
the given type, and then
assigns values in increasing order if {\em first-enum} < {\em last-enum},
or in decreasing order if {\em first-enum} > {\em last-enum}, to
constants named in subsequent {\em enum-assignment} statements for
the given type.  The assignments occur when the statements are
compiled, not when they are executed.

Within a linked load the process is the same, but the values assigned
to a constant may differ from those assigned during compilation,
so that all such assignments for a given type within a linked load
will be distinct.  The assignments occur when the code containing
the statements is linked, not when that code is executed.

These values should only be tested for equality, and not for
relative order.

If {\em last-enum} is not given, it is assumed to be the maximum
value of the underlying type.  If {\em enum-range} is not given,
it is assumed to be `\TT[0 ...]'.  It is an error if `\TT{next enum}'
would return a value beyond the {\em last-enum} value in a range.

\subsection{Type Values}
\label{TYPE-VALUES}

The type `\TT{type}' is an enumeration type implicitly declared
after the manner of
\begin{center}
\TT{type type is uns32 with enum [0 ...]}
\end{center}
Each type is associated with a unique enumeration value
of type `\TT{type}', and this value can be used at both
compile and run time to test whether two `\TT{type}'s are
equal.

Functions can be overloaded based on the number and types
of their arguments and also on the values of arguments that
are known at compile time.  Thus different functions with
the common prototype
\begin{indpar}\begin{verbatim}
(unsadr length) = size of ( type T )
\end{verbatim}\end{indpar}
may be defined for different values of \TT{T}.  
This is done automatically for the following functions:

\begin{indpar}[0.5in]
\hspace*{-0.3in}{\tt (unsadr size) = \ttkey{size of}
			( type T )} \\
Returns \TT{size}, the number of bytes in a value of type \TT{T}.

\hspace*{-0.3in}{\tt (unsadr alignment) = \ttkey{alignment of}
			( type T )} \\
Returns \TT{alignment}, a strictly positive integer.
The address of a value of type \TT{T} in RAM should
optimally be a multiple of the \TT{alignment}.
The alignment of builtin types is usually their size.

\hspace*{-0.3in}{\tt (type B) = \ttkey{base of}
			( type T )} \\
Returns the parent type \TT{B} of the type \TT{T}.  For defined
types this is the associated builtin type.  For builtin types, it is
\TT{T} itself.
\end{indpar}

\section{Unchecked Blocks}
\label{UNCHECKED-BLOCKS}

Unchecked operations, such as certain type conversions mentioned above,
can only be executed in an \mkey{unchecked}{code block}
code block of the form:

\begin{indpar}
\emkey{unchecked-block}
    ::= \begin{tabular}[t]{l}
	\TT{unchecked}\TT{:} \\
	~~~~ {\em executable-statement}\STAR{} \\
	\end{tabular}
\end{indpar}

A fully \key{type checked} piece of code will not contain any
unchecked code blocks.  A goal of the L-Language is to migrate
all unchecked code into small inline data access functions.

\section{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

In the following {\em expressions} produce a list of one
or more values of well defined types.

Function executions have stack frames that contain \underline{all}
their variables.
These variables are allocated and their values are computed by
assignment statements:

\begin{indpar}
\emkey{value-assignment-statement}
    ::= {\em variable-list} \TT{=} {\em expression}
\\[0.5ex]
\emkey{variable-list}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em variable-declaration} \\
    $|$ & \TT{(~}{\em variable-declaration}
          \{ \TT{,} {\em variable-declaration} \}\STAR{} \TT{)} \\
    \end{tabular}
\\[0.5ex]
\emkey{variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & \TT{next} {\em variable-name}
    \end{tabular}
\end{indpar}

This allocates new variables of the given {\em variable-names}, types,
and qualifiers
to the stack and stores values from the {\em expression} in the variables
({\em qualifiers} are not described until section \itemref{QUALIFIERS}).
The {\em expression} produces a list of values, and this list must have
at least as many elements as there are variables.  Each variable is
assigned its value in order, and this value must be implicitly
convertable to the variable's type.  If the {\em expression} produces
too many values, the excess values at the end of the value list will be
discarded.

See \itemref{QUALIFIERS} for a discussion of {\em qualifiers}.

The {\em expression} may only input values that are constants or are
the values of other variables in the same function execution
stack frame (including
arguments passed to the function execution).  In particular,
no input can come from RAM memory outside the function execution stack frame.

Implicitly when a variable value is set this way, the value is first
computed in a register, then stored in the stack, and for some time
afterwards the value is left in the register which becomes a cache
on the stack value.  This is hidden from the programmer.

If a variable value is copied from another variable, usually the
new variable simply becomes a compile-time alias for the old variable.
No executable copy code is created, no new register is allocated, and no new
value is pushed into the stack.

Similarly if a variable value can be computed from previous variable
values by in-line code, 
its value may not be pushed into the stack.  Instead its
value can be recovered at any time by repeating the computation
of the variable from the other values.

Two variables in the same block of code may not have the same
name.  Thus variables are only assigned values once.

However, if an assignment statement uses the word `\TT{next}' in
place of the {\em qualifiers} and {\em type-name}
of a variable being assigned a value, and
if the variable previously exists, a new variable with the same
name, type, and qualifiers as the previous variable is allocated.

Note that `\TT{next}' behaves differently for loop interation
variables (see below) than it does for other variables.

\subsection{Block Assignment Statements}
\label{BlOCK-ASSIGNMENT-STATEMENTS}

Another variant of the assignment statement is:

\begin{indpar}
\emkey{block-assignment-statement}
    ::= \begin{tabular}[t]{l}
        {\em variable-list} \TT{=:} \\
	~~~~ {\em executable-statement}\STAR{}
	\end{tabular}
\end{indpar}

The {\em executable-statements} in the block can include
{\em assignment-statements} in which {\em variable-declarations}
are replaced by simple {\em variable-names}
if these variables have the same name as a variable
in the {\em block-assignment-statement's} {\em variable-list}.
These {\em executable-statements} assign values to the variables
in the {\em block-assignment-statement's} {\em variable-list}.
Furthermore, every variable in the
{\em block-assignment-statement's} {\em variable-list}
\underline{must} be assigned a value
by one of the {\em executable-statements}.
Also the values of the variables in the {\em variable-list} cannot
be input to any of the {\em executable-statements}.

Variables allocated in the block are not visible outside the
block.

\subsection{Conditional Assignment Statements}
\label{CONDITIONAL-ASSIGNMENT-STATEMENTS}

Conditional assignment statements are similar:

\begin{indpar}
\emkey{conditional-assignment-statement}
    ::= \begin{tabular}[t]{l}
        {\em variable-list} \TT{= if:} \\
	~~~~ \TT{default:} \\
	~~~~~~~~~ {\em executable-statement}\STAR{} \\
	~~~~ \TT{default:} \\
	~~~~~~~~~ {\em executable-statement}\STAR{} \\
	~~~~ \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	~~~~ {\em condition-expression}\TT{:} \\
	~~~~~~~~~ {\em executable-statement}\STAR{} \\
	~~~~ {\em condition-expression}\TT{:} \\
	~~~~~~~~~ {\em executable-statement}\STAR{} \\
	~~~~ \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	~~~~ \TT{else:} \\
	~~~~~~~~~ {\em executable-statement}\STAR{} \\
	\end{tabular}
\end{indpar}

In this case the {\em condition-expressions} are evaluated in order
until either one evaluates to true or the `\TT{else}' condition is
reached, and then the {\em executable-statements} subject to the
first true condition (a.k.a the \key{subblock} of that condition)
are executed, or if no condition is true, the {\em executable-statements}
of the `\TT{else}' subblock are executed.  Each separate subblock of
{\em executable-statements} must set \underline{every} variable
in the {\em condition-assignment-statement's} {\em variable-list},
with exceptions for defaults described next.

A {\em conditional-assignment-statement} may have one or
more `\ttkey{default}\TT{:}' subblocks.  Each assigns one or more
variables in the {\em variable-list}.  A default subblock
executes after another subblock executes if and only if all of the
{\em variable-list} variables set by the default subblock have
\underline{not} been set yet.  This means that multiple subblocks
may execute, but only the first can be a non-default subblock.
If this happens, the non-default subblock executes first, and
the order in which the default subblocks execute
is the order that they appear in the `\TT{if}' subblock.

No two default subblocks may set the same {\em variable-list}
variable.  This rule is purely to prevent overly clever code that
uses the execution of earlier default blocks to disable the
execution of later default blocks.

Every variable in the {\em variable-list} \underline{must} be set by some
single subblock that executes, variables in the
{\em variable-list} cannot be read by subblock {\em executable-statements},
and variables declared in the subblocks are not visible outside their
subblock.

An example is:
\begin{indpar}\begin{verbatim}
int result = max ( int x, int y, int z ):
    result =
        if x > y and x > z:
	    result = x
	else if y > z:
	    result = y
	default:
	    result = z
\end{verbatim}\end{indpar}

\subsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

Lastly loop assignment statements are similar:

\begin{indpar}
\emkey{loop-assignment-statement}
    ::= \begin{tabular}[t]{l}
        {\em result-variable-list}
	    \TT{= loop} {\em iteration-variable-list}\TT{:} \\
	~~~~ \TT{initially}\TT{:} \\
	~~~~~~~~~ {\em executable-statement}\STAR{} \\
	~~~~ \TT{while} {\em condition-expression}\TT{:} \\
	~~~~~~~~~ {\em executable-statement}\STAR{} \\
	~~~~ \TT{finally}\TT{:} \\
	~~~~~~~~~ {\em executable-statement}\STAR{} \\
	\end{tabular}
\end{indpar}

This is somewhat like the conditional assignment statement
except the {\em executable-statements} are repeated.  The
{\em executable-statements} qualified by `\TT{initially}'
execute before the first repetition, and they must
set all the variables in the {\em iteration-variable-list}.
The {\em executable-statements} qualified by `\TT{while}
{\em condition-expression}' only execute if the
{\em condition-expression} evaluates to true, and
for every variable \TT{v} in the {\em iteration-variable-list}
they must set the variable `\TT{next v}' or `\TT{next next v}',
as indicated below.
Lastly, when
the {\em condition-expression} evaluates to false, the
{\em executable-statements} qualified by `\TT{finally}'
execute, and they must set all the variables in the
{\em result-variable-list}.  At this point the loop stops
executing.

Loops are always in effect unravelled so multiple copies of
the loop exist at one time.  `\TT{next v}' refers to \TT{v} in the
next iteration of the loop, which exists simultaneously with
the current iteration.  `\TT{next next v}' refers to \TT{v}
in the next iteration to the next iteration of the loop, which
also exists simultaneously with the current iteration.

For a given iteration variable \TT{v},
either the \TT{initially} subblock sets \TT{v}
and the `\TT{while}' subblock sets `\TT{next v}',
or the \TT{initially} subblock sets both \TT{v} and `\TT{next v}'
and the `\TT{while}' subblock sets `\TT{next next v}'.

There are always at least 4 iterations of the loop with variables
in the current function execution frame stack: the current iteration,
the previous iteration (if any), and the next two iterations.
When the third iteration of the loop starts, the first
iteration can be discarded, and so forth.



\section{Functions}
\label{FUNCTIONS}

All functions are inline.  An inline function can call out-of-line
code in either a classical or non-classical manner.

Function definitions have the form:

\begin{indpar}
\emkey{function-definition}
    ::= \begin{tabular}[t]{l}
        {\em function-prototype}\TT{:} \\
	~~~~ {\em executable-statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{function-prototype}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em result-variable-list} \TT{=} {\em function-name}
	    {\em argument-variable-list}\QMARK{} \\
    $|$ & {\em function-name} {\em argument-variable-list}\QMARK{} \\
    $|$ & {\em function-name} {\em argument-variable-list}\QMARK{}
            \TT{=} {\em input-variable-list} \\
    \end{tabular}
\end{indpar}

A function call with a {\em result-variable-list}
is in effect replaced by a {\em block-assignment-statement}
with the {\em function-definition's} {\em result-variable-list} becoming the 
{\em block-assignment-statement's} {\em variable-list} and the
{\em function-definition's} {\em executable-statements} becoming the 
{\em block-assignment-statement's} {\em executable-statements}.
Actual argument values from the function call are assigned to variables in
the definition {\em argument-variable-list}.  The values produced in
the {\em result-variable-list's} variables become the values of the
function call when it is used as part of an {\em expression}.

A function call without any {\em result-variable-list} or
{\em input-variable-list} is just like a function call with an empty
{\em result-variable-list}.

A function call with an {\em input-variable-list} is just syntactic
sugar for a function call with neither a {\em result-variable-list}
or {\em input-variable-list}.  Specifically
\begin{center}
{\tt F(a1,a2,...)~=~(b1,b2,...)} \\
is syntactic sugar for \\
{\tt F(a1,a2,...,b1,b2,...)} \\
\end{center}

\section{Memory Allocation}
\label{-MEMORY-ALLOCATION}

L-Language has built-in operations to allocate memory blocks to the
stack, but not to any other region of RAM.  Allocators to other
regions of RAM are provided by the function library.

The \ttkey{stack\_allocate} function allocates \TT{N} bytes of
memory to the stack and returns its address:

\begin{indpar}\begin{verbatim}
( adr address ) = stack_allocate ( unsadr N )
\end{verbatim}\end{indpar}\label{STACK-ALLOCATE}

The memory is freed when the \TT{address} variable is freed, that is,
at the end of the subblock containing the call to \TT{stack\_allocate}.

The memory allocated is always alligned on an \TT{8} byte boundary.

If you want a different alignment you can use:

\begin{indpar}\begin{verbatim}
( adr address ) =
    stack_allocate ( unsadr N, unsadr O, unsadr A )
\end{verbatim}\end{indpar}

where \TT{A} must be a power of 2.  This will align the \TT{O+1}'st
byte of the allocated memory block
at an address which is a multiple of \TT{A}\,.

TBD: prevent return of stack addresses from block allocating them


\section{Clusters}
\label{CLUSTERS}

A \key{cluster} is a group of related variables.  One variable of
the cluster is the \mkey{base variable}{of cluster} of the cluster, and the
other variables have names that are derived from the
name of the base variable using the syntax:


\begin{indpar}
{\em variable-name} ::=
    {\em base-name} {\em member-selector}$^\star$ \\[1ex]
{\em member-selector} \begin{tabular}[t]{@{}rl}
    ::= & \TT{.}{\em member-name} \\
    $|$ & \TT{[}{\em member-index-list}\TT{]}
    \end{tabular} \\[1ex]
{\em member-index-list} \begin{tabular}[t]{@{}rl}
    ::= & {\em member-index} \\
    $|$ & {\em member-index} \TT{,} {\em member-index-list}
    \end{tabular} \\[1ex]
{\em member-index} ::= {\em integer-constant-expression}
\end{indpar}

Thus a cluster
is like a structure, but it is a set of variables and not a
piece of memory.

More specifically, the members of the cluster can be named by
adding either a member name preceded by `\TT{.}' or a
`\TT{[]}' bracketed list of
integer constant subscripts to
either the base variable name of the cluster or to another member name
of the cluster.  Two variable names with different base variable names
belong to different clusters.

Variables in clusters are thus organized into trees, with clusters
that have different bases being disjoint.  Any variable in a cluster
can be considered
as the \mkey{root}{of subcluster} of a subtree of cluster members, and
the subtree is called a \key{subcluster}.

The main feature of clusters is that members are passed to or returned
from functions implicitly when their the root variable is named
explicitly.  For example:
\begin{indpar}\begin{verbatim}
type pointer pair is void
    // if pointer pair pp then
    //   adr pp.begin points at the first element
    //   adr pp.end points just AFTER the last element
    //   type pp.type is type of element

// Function to allocate a vector of n T's.
//
( mem pointer pair pp,
  adr pp.begin, adr pp.end, type pp.type ) =
        allocate ( type T, uns32 n ):
    pp.type = T
    unsadr length = size of ( T ) * n
    pp.begin = allocate ( length )
    pp.end = pp.begin + length


// Prefix operator to dereference a pointer pair to read
// memory.
//
( mem pp.type out, adr out.adr  ) =
        "*" ( mem pointer pair pp,
              type pp.type, adr pp.begin, adr pp.end ):
    out.adr = if:
        pp.begin < pp.end:
            out.adr = pp.begin
        else:
            fatal error
                ( "Deferencing empty pointer pair." )

// Prefix operator to dereference a pointer pair to
// write memory.
//
"*" ( mem pointer pair pp,
      adr pp.begin, adr pp.end, type pp.type ) =
        ( pp.type in ):
    if:
        pp.begin < pp.end:
            unchecked: in --> pp.begin
        else:
            fatal error
                ( "Deferencing empty pointer pair." )

// Prefix operator to increment the begin pointer of a
// pointer pair.  Note the result is a NEW pointer pair.
//
( mem pointer pair pp2,
  adr pp2.begin, adr pp2.end, type pp2.type ) =
        "++" ( mem pointer pair pp,
               type pp.type,
               adr pp.begin, adr pp.end ):
      pp2.begin = pp.begin + size of ( T )
      pp2.end = pp.end
      pp2.type = pp.type

// Assignment operator for pointer pairs.
//
( mem pointer pair pp2,
  adr pp2.begin, adr pp2.end, type pp2.type ) =
        "=" ( mem pointer pair pp,
              type pp.type,
              adr pp.begin, adr pp.end ):
      pp2.begin = pp.begin
      pp2.end = pp.end
      pp2.type = pp.type

// Example usage:
//
    ... out-of-line function header ...

    // Vector of 2 int32's is allocated and the elements
    // are set equal to 100 and 101.
    //
    mem pointer pair pp = allocate ( int32, 2 )
    * pp = 100
    next pp = ++ pp
    * pp = 101
    . . . .
    // Vector of 1000 float64's is summed.
    //
    mem pointer pair ppf = allocate ( float64, 1000 )
    ... set 1000 elements ...
    float64 sum = loop ( float64 partial sum,
                         mem pointer pair ppf2,
                         adr ppf2.begin,
                         adr ppf2.end,
                         type ppf2.type ):
        initially:
            partial sum = 0
            ppf2 = ppf
        while ppf2.begin < ppf2.end
            next partial sum = partial sum + * ppf2
            next ppf2 = ++ ppf2
        finally:
            sum = partial sum
\end{verbatim}\end{indpar}

Cluster member names may be used as prototype parameter
names, with the root of these names also being a prototype
parameter.  This specifies that the parameters are related
by being in the same cluster.

When this is done for arguments, the cluster root must
also be an argument, and the cluster member values
will be derived from the root, and \underline{must}
be omitted in calls.

When this is done for results, the cluster root must similarly
be a result, and the values of the designated
members of the cluster are set from the results.
Again the cluster members \underline{must} be omitted in calls.

A variable of \TT{void} type has no actual value
and must not be assigned one.  Such variables are only useful
as cluster roots.

In the above example `\TT{mem}' is a qualifier
which can be applied to variables.
A qualifier applied to a cluster root is applied automatically
to the cluster members.  See \itemref{QUALIFIERS}.

The `\TT{mem}' qualifier has the special property that given a variable
\TT{v} of type \TT{T} and qualifier \TT{mem}, then if \TT{v} is allocated,
and \TT{v.adr} of type \TT{adr} is allocated and
assigned a value, the base \TT{v} will also be automatically
assigned as its value the value read from RAM address \TT{v.adr}.
It is an error in this case to explicitly assign a value to \TT{v}.
See \itemref{THE-MEM-QUALIFIER}.

\section{Qualifiers}
\label{QUALIFIERS}

Variables may be qualified by \skey{qualifier}s, such as the
\TT{mem} qualifier in the example above.

Syntactically {\em qualifiers} immediately preceed {\em type-names}
that are before {\em variable-names}.

Some qualifiers are \skey{protection qualifier}s and some are not.
Some qualifiers are \key{inverted} but most are not.
The kinds of qualifiers may be declared by:
\begin{center}
\ttkey{qualifier} {\em defined-qualifier-name} \\
\ttkey{protection qualifier} {\em defined-protection-qualifier-name} \\
\ttkey{inverted qualifier} {\em defined-qualifier-name} \\
\ttkey{inverted protection qualifier} {\em defined-protection-qualifier-name} \\
\end{center}

A qualifier applied to the root variable of a cluster is automatically
applied to all the member variables.

In order for a function
prototype (argument or result) variable to match an actual variable,
if the prototype variable has a non-inverted qualifier, the actual
variable must have this qualifier, and if the prototype variable
does \underline{not} have an inverted qualifier, the actual variable
must \underline{not} have this qualifier.

If a variable is initialized by being matched to a prototype result variable
of a function, the variable is implicitly given all the protection qualifiers
of the prototype variable.  This is the only way a non-prototype
variable may acquire
a protection qualifier.  Thus protection qualifiers are only explicitly
given for prototype variables.

As an example of the above rules, the \TT{mem} qualifier is
a non-inverted protection qualifier, so if \TT{t} is a type and \TT{v} a
variable, and the {\em value-assignment-statement} allocating \TT{v} has the
form `\TT{t v = }{\em expression}' where \TT{v} is matched
with some result variable that has the \TT{mem} qualifier of some
function called in {\em expression}, then \TT{v} will be implicitly
given the \TT{mem} qualifier.  Because \TT{mem} is non-inverting,
\TT{v} can then be matched to any prototype variable of the same type
whether or not that prototype variable has the \TT{mem} qualifier,
and thus the value of \TT{v} can be freely used.

As another example of the above rules, the \TT{stack} qualifier is
an inverted protection qualifier given the result variable of
a call to \TT{stack\_allocate} function (\pagref{STACK-ALLOCATE}).
Values with this qualifier can only be passed to prototype variables
have also have the qualifier.

Three qualifiers, \TT{mem}, \TT{stack},
and \TT{trace}, are builtin and have special
effects described below.
In addition any qualifier can be used with the special \TT{reload} statement
descibed below.

\subsection{The Memory Qualifier}
\label{THE-MEM-QUALIFIER}

The \ttkey{mem} qualifier is a protection qualifier that behaves
in a special way when a variable \TT{v} has this qualifier and
there is a variable \TT{v.adr} of type \TT{adr}.  Then the
variable \TT{v} must \underline{not} be given a value by an
assignment statement, but will instead be loaded with a value
from RAM address \TT{v.adr}.

Because \TT{mem} is a protection qualifier, \TT{v} and \TT{v.adr}
must be created as matches to result variables of a function.
So only functions can effect a load of RAM contents to a variable.

It is further required that both \TT{v} and \TT{v.adr} be created
by the same function call assignment statement.
The function must assign a value to
\TT{v.adr}, but not to \TT{v}.  Thus all memory reads are hidden
inside functions which have the \TT{mem} qualifier on some of
their result variables.


\subsection{The Trace Qualifier}
\label{THE-TRACE-QUALIFIER}

\subsection{The Reload Statement}
\label{THE-RELOAD-COMMAND}

The reload statement has the syntax:
\begin{center}
\ttkey{reload} {\em qualifier-name} \{ \TT{,} {\em qualifier-name} \}\STAR{}
\end{center}

This statement declares the values of all variables with the designated
qualifiers to be out-of-date and unusable.  If any of these variables
is used subsequently, statements to recompute the variable value
may be inserted automatically into the code at the point of the
\TT{reload} statement.

Variable values are recomputed in the same order as they were
originally computed.  How each variable is recomputed depends upon
how it was originally computed.

If the variable \TT{v} was originally computed by being loaded from
RAM, using the statement `{\em type} \TT{v}' to allocate the variable,
it is assumed that RAM has changed.  The statement `\TT{next v}' is
generated at the point of the \TT{reload} statement in order
to reload the variable.  As \TT{v.adr}
has all the qualifiers of \TT{v} and was 
computed first, it is recomputed before \TT{v} is reloaded.

If the variable \TT{v} was originally computed by
a {\em value-assignment-statement}
of the form `{\em type} \TT{v =} {\em expression}', then if
no input to {\em expression} has been recomputed, the variable value does not
need to be recomputed, but if some input has changed, the
statement `\TT{next v =} {\em expression}' is generated at the
point of the \TT{reload} statement.

If a recomputed variable value is not used after the \TT{reload} statement,
the automatically generated
statements that recompute its value are suppressed.

TBD: conditional assignment, loop assignment, side effects

\section{TBD}

\TT{pure} functions that do not need recomputation and have no
visible side effects

\TT{trace} variables which can be located in stack by GC.

\section{Memory Channels}
\label{MEMORY-CHANNELS}

OLD STUFF: REVISE.

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
structured set of elements each associated with a member of
some data set.  Each window element contains a
\key{block descriptor} that holds the address and length of the
memory block that contains the data associated with the element.
Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
The window has a \key{reference point}, and window elements are addressed
relative to this reference point.  There are shift operations that move
the reference point to a nearby window element.

Although we talk about blocks here, a block can be just a numeric array
element, and can be as small as a single bit.  Although we talk about
each element of a memory channel window having its own block descriptor,
an actual memory channel may use only block group descriptors, each of
which functions as a group of more than one individual element
block descriptor.

A memory channel is stored in a cluster.  As such it is mostly an
inline construction, though it can be passed to or returned from a
function, and the function can be all or partly out-of-line.

The most common type of memory channel has a window that appears to be
an array with \ttikey{.di\-men\-sions}{dimensions!of memory channel},
\ttdmkey{lower\_bound}{of memory channel}\TT{[}$i$\TT{]},
and \ttdmkey{upper\_bound}{of memory channel}\TT{[}$i$\TT{]}
being memory channel members.  Such are called
\key{array windows}.
If the memory channel cluster name is $M$, the window elements are
referred to by $M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]},
with $M$\TT{[0,0,}\ldots\TT{]} being the \key{reference point}.

The reference point can be shifted along any of the window's
dimensions by the command
\begin{center}
$M$\ttdkey{center}\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]}
\end{center}
This shifts
the window so that what was
$M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]} becomes
$M$\TT{[0,0,}\ldots\TT{]}.

Creating memory channels and completely reseting their reference points
are specific to the type of memory channel, and are not covered in
this section.

For most kinds of memory channels, block descriptors are computed
automatically when channel is created, when the window is
shifted, or when the data of
a neighboring window element is arrives from memory.
Immediately after a block descriptor is created, a read-ahead of
the block is initiated.  This read-ahead overlaps computation that
does not use the block contents.

If a memory channel accesses arrays stored in memory,
the channel block descriptors can be computed from the array coordinates
of the reference point.  Other memory channels use the contents
of a block to compute the block descriptors of neighboring blocks
in the window.

An example of the latter is a binary tree memory channel.
Let $M$ be such a channel, and let `\TT{.L}' denote the left
child of a binary tree element, `\TT{.R}' the right child, and
`\TT{.P}' the parent.  Then $M\!$\TT{.L.R} denotes the right
child of the left child of the reference point, $M\!$\TT{.P.L}
denotes the left child of the parent of the reference point,
and $M\!$\TT{.P.L.center} moves the reference point to this last element.
The window of such a memory channel might contain the depth 2
subtree of the reference point plus that closest 4 ancestors of the
reference point if these have been visited.  When the reference
point is moved, as soon as the reference point element has been
read from memory, the descriptors for its children are built and
the read of the children is initiated in parallel with other
computation.  When the children arrive from memory, the descriptors
of their children are built and reads of the data pointed at
are initiated.\footnote{All this can actually be done with modern
hardware: code is executed to read the reference point children and initiate the
reads of their children, and a modern processor will automatically
save the code that
executes when a read of a reference point child completes and execute
other code in parallel until the read does complete.}

Some standard memory channel types are built into the L-Language.
Others can be defined by users.

\section{To Do}

How can dynamically initialized locations be static.

Indirect address protocol.
\label{INDIRECT-ADDRESS-PROTOCOL}

Threads.
\label{THREADS}

\appendix

\section{Aliasing Hardware}
\label{ALIASING-HARDWARE}

The ultimate solution to the aliasing problem is new hardware.
At its simplest, registers, which currently hold a datum,
are replaced by triples of registers which hold a datum,
an address, and selection codes.  The register datum equals the value
of the memory location at the register address.  The selection
codes determine which part of this memory location is read or written
when the register is read or written.  If any memory location is
changed, the address of the location is checked against all the
register addresses, and if any match, the corresponding register
data are changed.

This is, however, not sufficient, because sometimes one register
address is a function of another register's datum.  For example,
consider the unchecked code:
\begin{indpar}[0.5em]\begin{verbatim}
struct S { ...; int32 m; ... }
S * * x
S * *& y = * x
int32 *& z = y->m
\end{verbatim}\end{indpar}
If we consider \TT{x}, \TT{y}, and \TT{z} to be registers,
the address of \TT{y} equals the value of \TT{x}, and the
address of \TT{z} equals the value of \TT{y} plus the offset of
\TT{m} in \TT{S}.

If the value of \TT{x} changes, this changes the address of \TT{y},
which may change the datum of \TT{y} and that may change the value
of \TT{y}.  If the value of \TT{y} changes, this changes the address
of \TT{z}, which may change the datum and value of \TT{z}.

The way we accommodate this is to use the selection codes of \TT{y}
to specify that the address of \TT{y} contains the value of \TT{x}
as an additive component, so
that if the value of \TT{x} is changed by adding $\Delta$\TT{x}
then the address of \TT{y} should be changed by adding $\Delta$\TT{x}.
And similarly the selection codes
of \TT{z} specify that the address of \TT{z}
contains the value of \TT{y} as an additive component.

So why should we bother with automatically updating
additive inclusions of one value in the
address of another value, and not bother with other expressions.
The reason is that expressions such as
`\TT{(*x)->m}' are likely to be reused frequently in code (actually,
in automatically generated code) and
therefore need to be cached, whereas an expressions of the form
`\TT{c*d}' will be reused comparatively rarely code
and therefore are not worth special hardware.


\bibliographystyle{plain}
\bibliography{layered-l-2012-language}

\printindex

\end{document}

