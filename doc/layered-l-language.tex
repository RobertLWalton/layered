% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\TBDref}[1]{??}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

February 2, 2010
 
\end{center}

{\small \tableofcontents}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language.  See the Introduction to the Layered
Programming Languages for basic syntax and for an overview of the related
Middle Layer M-Language and Higher Layer H-Language.

Here we will give brief overviews of some of the principle issues
addressed by the L-Language.


\subsection{Code Targetting}

The L-Language is intended to be a target language for compilers of
higher level languages.  As such it is optimized first to be an easy to 
use and adequate target language, and second to be reasonably easy to
compile into efficient assembly language code.

The L-Language is similar to the C programming language
but has additional features intended to give
more control over compilation and more type safety in the use, but
not the declation, of data.  The L-Language depends upon its powerful
macro facility to allow users to define type safe data declaration
macros.

\subsection{Code Computation}

The L-Language permits code to be computed by executing programs, and then
compiled and run.  The computed code can be an entire function, or can
be embedded within a function.

A main reason for this is to support scientific computing in which
code specific to a task must be computed and then optimized.

\subsection{Data Declaration}

The L-Language supports low level declaration of data and fairly high
level typesafe optimized usage of declared data.  The L-Language also
supports macros written in the high level H-Language that extends the
L-Language, permitting very
capable macros to be written by users to give users high level
type-safe data declaration facilities taylored to specific kinds of data.

The thesis here is that a high level data declaration language that is
typesafe and efficient for all kinds of data is not practical.
So instead tools are provided to create data declaration sublanguages that are
typesafe and efficient for more limited kinds of data.

One way of explaining our approach is to say that we are taking the normal
division of programming into two layers, \key{system programming}
and \key{application programming}, and we are adding a third
layer in-between: \key{application system programming}.  This last
kind of programming uses basic and sometimes type unsafe tools to build
advanced and type safe tools for a particular application area, such
scientific programming, business accounting,
programming with particular data structures, and so forth.


\section{Memory}
\label{MEMORY}

We begin with an overview of L-Language memory, and then provide
details in the following subsections.

TBD

\subsection{Numbers}

\ikey{Numbers}{number} are a basic element of L-Language memory.
Numbers are sequences of bits, and each number is one of
four types, unsigned integer, signed integer, floating point number,
and direct address:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l}
\bf Name & \bf Kind & \bf Length \\[2ex]
\ttkey{uns8}		& unsigned integer & 8 bits \\
\ttkey{uns16}		& unsigned integer & 16 bits \\
\ttkey{uns32}		& unsigned integer & 32 bits \\
\ttkey{uns64}		& unsigned integer & 64 bits \\
\ttkey{uns128}		& unsigned integer & 128 bits
\\[1ex]
\ttkey{int8}		& signed integer & 8 bits \\
\ttkey{int16}		& signed integer & 16 bits \\
\ttkey{int32}		& signed integer & 32 bits \\
\ttkey{int64}		& signed integer & 64 bits \\
\ttkey{int128}		& signed integer & 128 bits
\\[1ex]
\ttkey{float16}		& IEEE floating point number & 16 bits \\
\ttkey{float32}		& IEEE floating point number & 32 bits \\
\ttkey{float64}		& IEEE floating point number & 64 bits \\
\ttkey{float128}	& IEEE floating point number & 128 bits
\\[1ex]
(see text)		& direct address & 32 bits or 64 bits (see text) \\
\ttkey{unsptr}		& unsigned integer & size of direct address \\
\ttkey{intptr}		& signed integer & size of direct address \\
\end{tabular}
\end{center}

The \mkey{length}{of number}
of a number is the number of its bits.  Numbers can have
different lengths: for example, unsigned integers can have
lengths of 8, 16, 32, 64, or 128 bits.

Numbers are stored in random access memory (RAM).

An \key{unsigned integer} of length $L$ is a binary integer with
$L$ binary digits (\skey{bit}s).

A \key{signed integer} of length $L$ is a two's complement integer
of length $L$.  This represents an integer $I$
by the unsigned $L$-bit integer equal to $I~\mbox{modulo}~2^L$.

A \key{floating point number} of length $L$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes is as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l}
\bf Floating Point \\
\bf Number Size & \bf Exponent Size & \bf Mantissa Size \\[2ex]
16 bits & 5 bits & 10 bits \\
32 bits & 8 bits & 23 bits \\
64 bits & 11 bits & 52 bits \\
128 bits & 15 bits & 112 bits \\
\end{tabular}
\end{center}

A \key{direct address} (a.k.a. a `\key{pointer}') holds a RAM byte address.
A direct address is a 32-bit or 64-bit unsigned integer whose size
is determined by the target machine.  Some of high order bits may be
required to be all 0's or all 1's, depending upon
the target machine.  The \verb|unsptr| and \verb|intptr|
unsigned and signed integer types of the same size
as a direct address are provided for storing indices and offsets.

A reasonable assumption for 64-bit addresses is that only the low
order 48-bits of the direct address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing a direct address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The Layered Languages do
\underline{not} depend upon this assumption, but do provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit direct address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$.  The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.

Variables can be declared to be of non-address numeric type
by declarations of the form
\begin{center}
{\em type-name} {\em variable-name} {\tt ;}
\end{center}
For example,
\begin{indpar}\begin{verbatim}
int32 i;
uns128 u;
float64 f;
\end{verbatim}\end{indpar}

Variables can be declared to be of address type by declarations of the form
\begin{center}
{\em type-name} {\tt *}$^\star$ {\tt \&}$^\star$ {\em variable-name} {\tt ;}
\end{center}
in which there is at least one {\tt *} and there are at least as many
{\tt *}'s as {\tt \&}'s.
For example,
\begin{indpar}\begin{verbatim}
int32 * ip;
int32 * & i;
\end{verbatim}\end{indpar}
are both variables that reference a direct address of an {\tt int32} type
integer stored in memory.  However, `\verb|ip|' and `\verb|& i|' reference
the direct address variable, and `\verb|* ip|' and `\verb|i|' reference
the {\tt int32} integer.

In general if there are $N$ {\tt *}'s, the variable is
the direct address of the direct address of the \ldots{} of the direct address
of the non-address type, where there are $N$ direct addresses in all.
If there are no {\tt \&}'s, the variable name references the first of
these direct addresses, and the variable name with $M$ {\tt *}'s in
front of it references the $M+1$'st of the addresses, or the non-address
number of $M=N$.  If instead there are $M$ {\tt \&}'s in the declaration,
$M\leq N$,
the variable name references the $M+1$'st direct address, or the non-address
number if $M=N$, and to get a previous direct address one must put a
{\tt \&} in front of the variable name, whereas to get a subsequent direct
address or the non-address number one puts a {\tt *} in front.

For example,
\begin{indpar}\begin{verbatim}
int32 *** ippp;
int32 *** & ipp;
int32 *** && ip;
int32 *** &&& i;
\end{verbatim}\end{indpar}
are all variables referencing a direct address of a direct address of a
direct address of an {\tt int32} number stored in memory.
The first of these direct addresses is accessed with
`\verb|ippp|', `\verb|& ipp|', `\verb|& & ip|', or `\verb|& & & i|'.
The second of these direct addresses is accessed with
`\verb|* ippp|', `\verb|ipp|', `\verb|& ip|', or `\verb|& & i|'.
The third of these direct addresses is accessed with
`\verb|* * ippp|', `\verb|* ipp|', `\verb|ip|', or `\verb|& i|'.
The {\tt int32} number is accessed with
`\verb|* * * ippp|', `\verb|* * ipp|', `\verb|* ip|', or `\verb|i|'.
Also note that in `\verb|* &|' the operators cancel each other out:
e.g., `\verb|* ip|', `\verb|* * & ip|', and `\verb|* * * & & ip|'
all reference the same thing.

\subsection{Random Access Memory (RAM) and Blocks}

\ikey{RAM}{Random Access Memory}\index{random access memory!RAM}
is a set of address/byte pairs.  Each 8-bit byte of RAM has an \key{address}
that is a unsigned integer.  It is possible for two addresses to refer to the
same byte, or for an address to refer to no byte.  An address that
refers to a byte is said to be \key{allocated}, and an address that refers
to no byte is said to be \key{deallocated}.  A byte that has two (or more)
distinct
addresses is said to be \key{shared}, and a byte with just one address is
\key{unshared}.

A \mkey{block}{of RAM} of RAM is a sequence of bytes with
consecutively increasing addresses.
The \mkey{origin}{of block} of the block is the first address,
and the \mkey{length}{of block} of the block is the number of bytes.

A block is \mkey{allocated}{block}
if the addresses of all its bytes are allocated,
and is \mkey{deallocated}{block} if the addresses of all of its bytes
are deallocated.
A block is \mkey{unshared}{block} if all its bytes are unshared.
A block is \mkey{shared}{block} if
it is one of a set of several blocks (sequences of consecutive addresses)
such that the $n$'th byte of each block in the set is the same.
Note that a block can be neither allocated or deallocated or
neither shared nor unshared; i.e., some of the block's bytes may be
allocated and some deallocated, or some may be shared and some unshared.

The address space is divided into \skey{page}s, which are blocks that
have an implementation determined length that is a power of two,
e.g., 4096 byte pages, and an address that is an exact multiple of
this length.  There
are L-Language operations which call the operating system to
map an address page to physical memory, thus allocating a page
of RAM.  There are operations to deallocate a page, and to make
two pages be shared (map to the same bytes of RAM).

Pages are the units of allocation and sharing.  Each page of the
address space is either allocated or deallocated, and each page is
either shared or unshared.  The only way for an abitrary block to
have allocated bytes is to overlap an allocated page, and similarly
for deallocated bytes, shared bytes, and unshared bytes.

A \key{segment} is a contiguous sequence of pages all of which have
the same allocation and sharing status.

The builtin blocks in L-Language are frame blocks (\pagref{FRAME-BLOCKS}),
code blocks(\pagref{CODE-BLOCKS}), numbers, and segments.  All non-segment
blocks are contained within segments.  User defined blocks can be 
contained within segments.

User defined block data types may be declared by declarations of the form
\begin{center}
\ttkey{deftype} {\em type-name} {\tt (} {\em length}{\tt ,}
				        {\em alignment}{\tt ,}
				        {\em offset}
					{\tt )} {\tt ;}
\end{center}

The layout of a block of the defined type in memory is:

\begin{center}
\begin{picture}(4.0,1.6)
\put(2.0,1.5){\framebox(0.1,0.1){}}
\put(0.0,1.5){\makebox(1.5,0.1)[r]{origin}}
\put(1.6,1.55){\vector(1,0){0.3}}
\put(2.7,1.55){\vector(-1,0){0.5}}
\put(2.0,1.4){\framebox(0.1,0.1){}}
\put(2.0,1.13){\makebox(0.1,0.3){\vdots}}
\put(2.0,1.0){\framebox(0.1,0.1){}}
\put(2.0,0.9){\framebox(0.1,0.1){}}
\put(0.0,0.9){\makebox(1.5,0.1)[r]{address}}
\put(1.6,0.95){\vector(1,0){0.3}}
\put(2.5,0.95){\vector(-1,0){0.3}}
\put(2.4,1.25){\vector(0,1){0.3}}
\put(2.4,1.25){\vector(0,-1){0.3}}
\put(2.4,1.25){\line(1,0){0.6}}
\put(3.1,1.20){\makebox(0.5,0.1)[l]{\em offset}}
\put(2.0,0.8){\framebox(0.1,0.1){}}
\put(2.0,0.7){\framebox(0.1,0.1){}}

\put(2.0,0.43){\makebox(0.1,0.3){\vdots}}
\put(2.0,0.3){\framebox(0.1,0.1){}}
\put(2.0,0.2){\framebox(0.1,0.1){}}
\put(2.7,0.15){\vector(-1,0){0.5}}
\put(2.6,0.85){\vector(0,1){0.7}}
\put(2.6,0.85){\vector(0,-1){0.7}}
\put(2.6,0.85){\line(1,0){0.4}}
\put(3.1,0.80){\makebox(0.5,0.1)[l]{\em length}}
\end{picture}
\\[1ex]
address modulo {\em alignment} = 0
\end{center}

The \mkey{address}{of block} of the block is offset from the origin
of the block by the \mkey{offset}{of block} of block.  The address must be an
exact multiple of the \mkey{alignment}{of block} of the block.
The length of the block is an unsigned integer.  The alignment is an
unsigned integer equal to a power of two that defaults to {\tt 1}.
The offset is a signed integer that defaults to {\tt 0}.

A block can actually have bytes both before and after those described by
its type.  Thus the type specifies that every allocated block of the
type will contain allocated bytes at the addresses

\begin{center}
\begin{tabular}{l}
address - offset \\
address - offset + 1 \\
address - offset + 2 \\
\ldots\ldots\\
address - offset + length - 1
\end{tabular}
\end{center}

These are the \smkey{required byte}s{of a block} of the block.
In addition the block may contain \smkey{optional byte}s{of a block}
either before or after the required bytes.

Note that if the {\em offset} is negative, the block address does not
address a required byte, and may not address any block byte.  Similarly
if the {\em offset} is greater than the block {\em length}.


Blocks contain numbers (including direct addresses) and subblocks.
Access to these is provided by
unchecked pointer computation functions.  For example
\begin{indpar}\begin{verbatim}
deftype type1 (48,8);
uns16 *&   .member1 ( *& type1 @ m ) unchecked = m@0;
int16 *&   .member2 ( *& type1 @ m ) unchecked = m@2;
int32 *&   .member3 ( *& type1 @ m ) unchecked = m@4;
float32 *& .member4 ( *& type1 @ m ) unchecked = m@8;
type1 * *& .member5 ( *& type1 @ m ) unchecked = m@16;
. . . . .
type1 x;
x.member1 = 9;
x.member2 = -19;
x.member3 = 190;
x.member4 = -0.01 * x.member3;
x.member5 = & x;
\end{verbatim}\end{indpar}

Here $x${\tt @}$y$ is an operation that takes the byte address of
$x$ (i.e., `{\tt \&}$x$'), adds to it the integer $y$, and
returns it as a value of type `{\tt *\& void}'.  In an
{\tt unchecked} function the {\tt void} type can be implicitly converted to
any other type.  The `{\tt @}' before the `{\tt m}' in the argument
list indicates
that the return value is a subblock of the block denoted by `{\tt m}',
and as such, inherits certain qualifiers from `{\tt m}', as we
will describe in \TBDref{TBD}.  There is also a commonly used abbreviation
for function definitions such as the above, of which
\begin{indpar}\begin{verbatim}
uns16 *&   .member1 ( *& type1 m ) unchecked @= 0;
\end{verbatim}\end{indpar}
is representative.  This is described in \TBDref{TBD}.

\subsection{Tuples}
\label{TUPLES}

A tuple is a sequence of zero or more values, where the values
need not all have the same type.  A tuple is \underline{not}
a first class datum; it cannot be stored in most kinds of memory.
Tuples are temporary data used to pass values to functions and
return values from functions.  A call to a function involves
two tuples, one holding the input arguments and one holding the
output arguments.

[TBD: what is the difference between input and output?]

TBD: flattening??

\subsection{Memories}
\label{MEMORIES}

There are three basic kinds of memories: static memories,
stack memories, and heap memories.  Each of these memories
consists of disjoint blocks (which in turn can contain
subblocks).

Blocks allocated to \ikey{static memories}{static memory} 
are never deallocated.

Blocks allocated to \ikey{stack memories}{stack memory} 
are allocated during the execution of a block of code and
deallocated when the block terminates.  Each thread
has an associated stack memory to which blocks executed
by the thread allocate memory locations.

Blocks allocated to \ikey{heap memories}{heap memory} 
are garbage collected.  For each heap there is a list of
static memory locations that might hold pointers into
blocks in the heap.  And for each heap and each stack
memory there is a separate list of stack memory locations
that might hold pointers into blocks in the heap.


\subsection{Arrays}
\label{ARRAYS}

Array variables can be declared by declarations of the form
\begin{center}
{\em type-name} {\tt *}$^\star$ {\tt \&}$^\star$ {\em variable-name}
	{\tt [} {\em dimension-spec}
	       \{ {\tt ,} {\em dimension-spec} \}$^\star$ {\tt ]}{\tt ;}
\end{center}
where
\begin{indpar}
{\em dimension-spec} ::= {\em bound-spec}~~{\em step-spec-option} \\[1ex]
{\em bound-spec} ::= {\em length}
    $|$ {\em lower-bound}~~{\tt ..}~~{\em upper-bound} \\[1ex]
{\em step-spec} ::= {\tt ++} {\em step}
\end{indpar}
For example,
\begin{indpar}\begin{verbatim}
int32 iarray[5];
int32 * piarray[1 .. 5];
int32 * & irarray[10,20];
int32 * & tirarray[10++1,20++10];
\end{verbatim}\end{indpar}

Here
\begin{itemize}
\item {\tt iarray[i]} is an {\tt int32} variable for {\tt i} =
{\tt 0}, {\tt 1}, {\tt 2}, {\tt 3}, and {\tt 4}.  The {\tt length}, which is
{\tt 5}, specifies the number of elements in the array's one dimension,
and array indexing begins at {\tt 0}.

\item {\tt piarray[i]} is a `direct address of {\tt int32}'
variable for {\tt i} =
{\tt 1}, {\tt 2}, {\tt 3}, {\tt 4}, and {\tt 5}.  The {\em lower-bound}
and {\em upper-bound} of the dimension index, {\tt 1} and {\tt 5} respectively,
are given.

\item {\tt \& irarray[i,j]}
is a `direct address of {\tt int32} variable', and
{\tt irarray[i,j]} is the {\tt int32} location so addressed,
for {\tt i} = {\tt 0}, {\tt 1}, \ldots, {\tt 9} and
for {\tt j} = {\tt 0}, {\tt 1}, \ldots, {\tt 19}, where the two
dimension {\em lengths} are given, respectively {\tt 10} and {\tt 20}.
The elements of the array are stored in {\tt 10*20} consecutive
memory locations that in memory order
have indices {\tt (0,0), (0,1), \ldots, (0,19),
(1,0), (1,1), \ldots, (9,19)}, with the last index {\tt j} varying
most rapidly.  This means that the implied step size of the first
dimension is {\tt 20} and of the second dimension is {\tt 1}.

\item {\tt tirarray[i,j]} is just like {\tt irarray[i,j]} but the
elements are stored in memory in transposed order:
{\tt (0,0), (1,0), \ldots, (9,0),
(0,1), (1,1), \ldots, (9,19)}, with the first index {\tt i} varying
most rapidly.  The step size of the first dimension is
given as {\tt 1} and of the second is given as {\tt 10}.

\end{itemize}

An array has parameters such that

\begin{center}
\begin{tabular}[t]{lrl}
\multicolumn{3}{l}{
address of $array${\tt [}$i_0${\tt ,}$i_1${\tt ,}\ldots{\tt ,}$i_{n-1}${\tt ]}
= } \\\hspace*{2em}
&   & $array${\tt .base} \\
& + & $array${\tt .step[0]} * $i_0$ * {\em element-size}  \\
& + & $array${\tt .step[1]} * $i_1$ * {\em element-size}  \\
& + & \ldots\ldots \\
& + & $array${\tt .step[}$n-1${\tt ]} * $i_{n-1}$ * {\em element-size} \\
\end{tabular}

\end{center}

where

\begin{center}
\begin{tabular}{l}
$array${\tt .lower\_bound[0]} $\leq$ $i_0$ $\leq$ $array${\tt .upper\_bound[0]}
\\
$array${\tt .lower\_bound[1]} $\leq$ $i_1$ $\leq$ $array${\tt .upper\_bound[1]}
\\
\ldots\ldots
\\
$array${\tt .lower\_bound[}$n-1${\tt 1]}
    $\leq$ $i_{n-1}$ $\leq$ $array${\tt .upper\_bound[}$n-1${\tt ]}
\end{tabular}

\end{center}

[TBD: array mapping function that would allow, e.g., symmetric arrays.]

The parameters of an array $A$ whose element type is $T$ and whose
inheritable qualifiers are $Q$ are

\begin{indpar}

\begin{list}{}{}

\item[\ttdkey{first}] Type: `$Q$ $X$ {\tt *\&}'.
The first element of the array,
that is, the lowest addressed array element that can be accessed
using subscripts within the range indicated by the subscript bounds.
`\verb|& |$A$\verb|.first|' is {\tt NULL} if there are no
accessible elements (i.e., if some
upper bound is not at least as great as the corresponding lower bound).

\item[\ttdkey{length}] Type: `{\tt unsptr}'.
The total number of elements in the array.
The last used element of the array has address
\begin{center}
$array${\tt .first} + ( $array${\tt .length} - 1 ) * {\em element-size}
\end{center}

{\tt 0} if the array has no accessible elements.

\item[\ttdkey{base}] Type: `{\tt noaccess} $X$ {\tt *}'.
The address of the {\tt [0,0,}\ldots{\tt ,0]}
element of the array.  This may not actually be inside the array,
as {\tt 0} subscripts may not be within bounds.

\item[\ttdkey{step}{$[i]$}]
Type: any integer type.
The multiplier
of the $i+1$'st subscript of the array for the purpose of determining
the address offset of the element in the array.
An integer (may be negative).
The unit of these multipliers is the size of the array element.

\item[\ttdkey{lower\_bound}{$[i]$}]
Type: any integer type.
The lower bound (smallest value)
of the $i+1$'st
subscript of the array.
An integer (may be negative).

\item[\ttdkey{upper\_bound}{$[i]$}]
Type: any integer type.
The upper bound (largest value)
of the $i+1$'st subscript of the array.
An integer (may be negative).

\end{list}

\end{indpar}

All the parameters except {\tt .first} and {\tt .length}
are given to describe an array.  The {\tt .first} and {\tt .length}
parameters are then computed from the other parameters.\footnote{
Note that these are functions and not C language members, and as
such only {\tt .first} returns an lvalue in the sense of the
C language.}

Given the example from above,
\begin{indpar}\begin{verbatim}
int32 iarray[5];
int32 * piarray[1 .. 5];
int32 * & irarray[10,20];
int32 * & tirarray[10++1,20++10];
\end{verbatim}\end{indpar}
we have
\begin{indpar}\begin{verbatim}
iarray.lower_bound[0] == 0
iarray.upper_bound[0] == 4
iarray.step[0] == 1
iarray.length == 5

piarray.lower_bound[0] == 1
piarray.upper_bound[0] == 5
piarray.step[0] == 1
piarray.length == 5

irarray.lower_bound[0] == 0
irarray.upper_bound[0] == 9
irarray.step[0] == 20
irarray.lower_bound[1] == 0
irarray.upper_bound[1] == 19
irarray.step[1] == 1
irarray.length == 200

tirarray.lower_bound[0] == 0
tirarray.upper_bound[0] == 9
tirarray.step[0] == 1
tirarray.lower_bound[1] == 0
tirarray.upper_bound[1] == 19
tirarray.step[1] == 10
tirarray.length == 200

\end{verbatim}\end{indpar}

When an array is allocated to the stack or to static memory,
the length of the array is just enough to include all the elements of the
array.  There can be unused elements.  Thus given
\begin{indpar}\begin{verbatim}
int32 x[1 .. 4 ++ 3];
\end{verbatim}\end{indpar}
then in memory the array {\tt x} is laid out as
\begin{center}
{\tt x[1]}, unused, unused,
{\tt x[2]}, unused, unused,
{\tt x[3]}, unused, unused,
{\tt x[4]}
\end{center}
and we have {\tt x.length == 10}, {\tt x.first == x[1]},
{\tt x.base == \&x[1] - 3}.

The parameters of an array can be any expression that evaluates
to an integer at the time the array is allocated.  For example,
\begin{indpar}\begin{verbatim}
uns32 constant number = ...
int64 constant first = ...
uns32 constant step = ...

int32 x[number];
int32 y[first .. first + number - 1 ++ step];
\end{verbatim}\end{indpar}

The variables used to determine the parameters
of an array must be `{\tt constant}' or
`{\tt readonly}' so that checked code cannot modify them.
More on this below.

\subsubsection{Array Function Parameters}
\label{ARRAY-FUNCTION-PARAMETERS}

An array can be passed to a function and returned as the value
of a function.  Some examples are:
\begin{indpar}\begin{verbatim}
void sort ( int64 vector[length], int32 length );
void transpose ( float64 array[lb .. ub ++ step1, lb .. ub ++ step2],
                 int64 lb, int64 ub, int64 step1, int64 step2 );
(float64 array[length,length]) unit ( uns32 length );
(string output[olength], uns32 olength) sort
        ( string input[ilength], uns32 ilength );
\end{verbatim}\end{indpar}

When an array is passed to a function, the parameters needed to
describe the array must be expressions computatable from parameters
passed to the function.  When an array is returned by a function,
the parameters needed to describe the array must be expressions
computable from parameters either passed to or returned from the
function.  Note that integer function parameters are `{\tt constant}'
by default.

When a function that takes arrays as input parameters or computes
arrays as output results is called, the array parameters that are
function parameters or results may be implicitly specified.  Examples using
the function declarations above are:
\begin{indpar}\begin{verbatim}
int64 x[1 .. 100];
. . . compute x . . .
sort ( x[] );   // length implictly passed.
float y[1 .. 5][1 .. 5];
. . . compute y . . .
transpose ( y[] );    // lb, ub, step1, step 2 implicitly passed.
float z[] = unit ( 10 );    // computes z and its parameters.
string s[10];
. . . compute s . . .
string t[] = sort ( s[] );    // ilength and olength implicitly passed.
                              // computes t and its parameters.
\end{verbatim}\end{indpar}

In order to indicate that implicit array parameter passing is
desired, the empty brackets `\ttkey{[]}' must be appended to the
array name.

Checked functions can only allocate arrays to static or stack
memory.  Unchecked functions can be written to allocate arrays
in a heap and return them.

The parameters of an array need not be constants: they can be
variables.  However, the variables must be qualified (see
\secref{QUALIFIERS}) in such a way that checked code cannot
modify them.  Unchecked functions may then be written to change the
array parameter variables and reconfigure the array: e.g., the
array may be expanded.  An example is:

\begin{indpar}\begin{verbatim}
deftype myarray (16,8);
readonly uns64 *& .n ( *& myarray @ a ) unchecked = a@0;
float64 (*&b) [1 .. a.n] .void ( *& myarray a ) unchecked = a@8;
myarray *& .constructor.() unchecked
{
    a.n = 0;
    a.void.base = NULL;
}
void push ( *& myarray a, float64 value ) unchecked
{
    uns64 n = a.n;
    float64 * ap = malloc ( sizeof ( float64 ) * ( n+1 ) );
    if ( a.void != NULL )
        memcpy ( ap, a.void.base,
                 n * sizeof ( float64 ) );
    mfree ( a.void.base );
    a.void.base = ap;
    ap[a.n] = value;
    ++ a.n;
}

myarray a;
push ( a, 1.0 );
push ( a, 2.0 );
a[1]; // Equals 1.0.
a[2]; // Equals 2.0.
a[0]; // Run time error.
a[3]; // Run time error.
\end{verbatim}\end{indpar}

There are a number of language features introduced in the above code.

First, {\tt a@8} is of type `{\tt void *\&}' which is
converted to type `{\tt float (*\&) [1 .. a.n]}' by the
`{\tt unchecked}' code of the {\tt .void} function.

Second, an array value is just a pointer.  Viewed as the
element of an object, {\tt a.void} is a pointer.  Here
we treat pointers as being 8 byte long values that are
aligned on 8 byte boundaries, but as 4 byte pointers will
fit into 8 bytes, the code will work even with 4 byte pointers.

Third, if $Y$ is an array of type `$X$ $Y${\tt [ ... ]}' then
$Y${\tt .base} is a value of type `{\tt noaccess} $X$ {\tt *}'.  If an array
is being returned, what is actually returned is its {\tt .base}.
Unchecked code can store a pointer of type `$X$ {\tt *}'
in $Y${\tt .base}.  The line `{\tt a.void.base = ap;}' above
does just this.  Unchecked code can also read the base, as in
the line `{\tt memcpy ( ap, a.void.base, n );}', and implicitly
convert the base to a pointer to a `{\tt readwrite}' value.  Checked code
can also read the base, but the value returned will be given
the type `noaccess $X$ {\tt *}' since base pointers may not
point at real memory (e.g., given $Y${\tt [1 .. 2]} then
$Y${\tt .base} points to an unusable location just before
the first element).

Fourth, `{\tt unchecked}' code can use a pointer as if it were
a 1-dimensional array with step {\tt +1} and no bounds.  This is
done in the statement `{\tt ap[a.n] = value;}' above.

Fifth, `{\tt .base}' when applied to an array,
and `{\tt .void}' applied to any expression,
can always be omitted, as long as the
result can be disambiguated.  Thus in the above
`{\tt a.void.base}' could be replaced by either
`{\tt a.void}' or just `{\tt a}'.  In the code at the end
after the functions, `{\tt a.void}' is replaced by `{\tt a}'.

Note also that `\verb|float64 (*&b) [1 .. a.n]|' differs from
`\verb|float64 *&b [1 .. a.n]|' which is equivalent to
`\verb|float64 *& (b [1 .. a.n])|'.  The first subexpression
means that the value returned is a pointer to the location holding
the base of an array whose elements are {\tt float64} values.
The second subexpression means that the value returned is the base
of an array whose elements are pointers to `{\tt float64}' values
(and {\tt b[i]} refers to the `{\tt float64}' value pointed at by the
array element indexed by {\tt i}).

\subsubsection{Copying Arrays}
\label{COPYING-ARRAYS}

If you want to copy entire arrays you have to apply the `{\tt *}'
operator to them.  Thus
\begin{indpar}\begin{verbatim}
declare alias qualifier same_data;
same_data int32 x[1 .. 10];
same_data int32 y[1 .. 10] = x;
// Now x and y are the same piece of memory.  This would not be
// legal without the alias qualifier (described later).
y[1] = ..., etc.
int32 z[1 .. 10];
* z = * y;
// Now the elements of x (and y) have been copied to
// the elements of z.
\end{verbatim}\end{indpar}

\subsubsection{Subarrays}
\label{SUBARRAYS}

Subarrays can be computed by expressions of the form
\begin{center}
{\em array-expression}
	{\tt [} {\em selector-spec}
	       \{ {\tt ,} {\em selector-spec} \}$^\star$ {\tt ]}{\tt ;}
\end{center}
where
\begin{indpar}
{\em selector-spec} ::=
    {\em lower-bound}~~{\tt ..}~~{\em upper-bound}~~{\em step-spec-option}
\end{indpar}

Here the bounds are valid subscripts for the given array, and the
steps are increments in these valid subsecripts.

For example,
\begin{indpar}\begin{verbatim}
declare alias qualifier first_half, second_half;
first_half second_half int32 x[1 .. 10];
first_half int32 x1[1 .. 5] = x[1 .. 5];
second_half int32 x2[1 .. 5] = x[6 .. 10];

declare alias qualifier odd_half, even_half;
odd_half even_half int32 y[1 .. 10];
odd_half int32 y1[1 .. 5] = y[1 .. 9 ++ 2];
even_half int32 y2[1 .. 5] = x[2 .. 10 ++ 2];
\end{verbatim}\end{indpar}

Here {\tt x1} is the first half of {\tt x} and is the second
half.  Similarly {\tt y1} is all the elements of {\tt y} with
odd subscripts, and {\tt y2} is all the elements with even
subscripts.

The `{\tt =}' operator used with arrays overlays and does not
copy.  It can only be used to initialize subarray names, and
only requires that the arrays involved have equal numbers of
subscripts in each dimension.

In somewhat more generality a subarray of an array may be
given a \key{linear view} defined by any linear map between
arbitrary subscripts and the subscripts of the array.  For
example:
\begin{indpar}\begin{verbatim}
declare alias same_data;
same_data int32 x[1 .. 70];
same_data int32 y[1 .. 10, 1 .. 7] = ([i,j] ===> x[(i-1)*7 + j]);
same_data int32 z[1 .. 7, 1 .. 10] = ([i,j] ===> y[j,i]);
same_data int32 w[1 .. 6] = ([i] ===> y[i,i+1]);
\end{verbatim}\end{indpar}

Here {\tt y} is a 2-dimensional array overlayed on the vector {\tt x},
{\tt z} is the transpose of {\tt y}, and {\tt w} is a subdiagonal of
{\tt y}.

[TBD: is there any way of having a non-linear view?  The problem
is passing arrays as arguments and results of functions that are
not inlined.]

\subsection{Qualifiers}
\label{QUALIFIERS}

The L-Language controls the way memory is accessed via \skey{qualifier}s.
A qualifier has a name that is an identifier with optional type parameters,
just as a function has a name that is an identifier with optional
type parameters.  The type parameter part of the name can be useful
in applications where only certain functions are allowed to write
a datum of a particular type, or where languages are being compiled that
wish to enforce the rule that only data of the same type can be aliased.

Qualifiers are applied to locations of memory.  For example,
the following declarations apply the qualifier {\tt Q}
to various memory locations:
\begin{indpar}[0.5em]\begin{verbatim}
                     // Q is applied to:
Q int32 x;           // x
Q int32 * x;         // * x;
int32 * Q x;         // x;
Q int32 a[5];        // a[i] for i = 0 .. 4
int32 (Q a)[5];      // a (== a.base)
\end{verbatim}\end{indpar}
Locations specify a specific set of bytes.  Note that unlike
the C programming language, L-Language does not specify arrays by
simply giving a single pointer; there is always a specification of
array extent.

Qualifiers may be given in type definitions, and apply to all
locations of the defined type.  For example, if {\tt Q} is a qualifier,
\begin{indpar}[0.5em]\begin{verbatim}
deftype Q type1 (48,8);
type1 x;
type1 * y;
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}[0.5em]\begin{verbatim}
deftype type1 (48,8);
Q type1 x;
Q type1 * y;
\end{verbatim}\end{indpar}

Qualifiers may also be applied to functions.  A qualifier after the
name of the function in a function definition applies to the code in the
body of a function.  For example, if {\tt Q} is a qualifier,
\begin{indpar}[0.5em]\begin{verbatim}
int32 function1 () Q = ... ;
int32 function2 () Q
{
   . . .
}
\end{verbatim}\end{indpar}
apply {\tt Q} to the body of the functions.

A qualifier just before the name of a function in a function definition
or declaration applies to calls to the function.  Such qualifiers are
generally protection qualifiers.  For example,
\begin{indpar}[0.5em]\begin{verbatim}
int32 Q function3 ();
int32 *& Q function4 ();
\end{verbatim}\end{indpar}
Note that in this last case qualifiers appearing immediately
before function names
in function definitions and declarations are always assumed to apply
to the function and not the returned value.  If you want
qualifiers to apply to the returned values, you may want to put
return values in parentheses like an argument list.  For example,
\begin{indpar}[0.5em]\begin{verbatim}
(int32 Q *& a, int32 * Q b) function5 ();
\end{verbatim}\end{indpar}

If in the above examples we assume that
{\tt Q} is a protection qualifier, then {\tt function3}
and {\tt function4} can only be called by functions whose bodies have
the {\tt Q} qualifier, and in particular these functions can be called
by {\tt function1} and {\tt function2}.

There are several kinds of qualifiers.

\ikey{Lifetime qualifiers}{lifetime qualifier}
specify the lifetime of a memory location.  This in turn controls where
addresses of the memory location may be stored: the address of a location
must not be stored by checked code in a place that will exists after the
location ceases to exist.

The `{\tt static}' qualifier specifies that the location
has unlimited lifetime.
The `{\tt stack}' qualifier specifies that the location
is in the stack of the current thread.
The `{\tt caller}' qualifier
specifies that the location will last at least as long as the caller of
a function.
\ikey{Collectable qualifiers}{collectible qualifier} may be declared that
indicate that the location is garbage collectable and its address needs
to be protected against collection.
Generally a block of code
may store the address of a location in the code block's
stack frame as long as the block knows the location will exist until
the end of the block's execution.  Addresses of static locations can
be stored anywhere.  Addresses of collectible locations can be stored
in a block's stack frame if there is reason to believe the locations
will not be garbage collected while the code block is running.

\ikey{Caching qualifiers}{caching qualifier} specify when memory locations
may be changed, and thence when they may be cached in registers.  The
`{\tt constant}' qualifier specifies that a location will never be changed,
and may be cached indefinitely in registers.
The `{\tt unique}' qualifier specifies that a location has no overlaps
with other locations that are not known to the currently executing
function, and, in particular, that a location passed from a caller to
a called function does not overlap with any other location so passed
or with any location accessible from global data.
\ikey{Alias qualifiers}{alias qualifier} may be declared to indicate when
memory locations may overlap because they have compatible types.
Normally memory locations that are referenced differently are assumed by the
L-Language to be different memory locations that do not overlap.
To specify that two memory locations might overlap, they must
be given overlapping alias qualifiers.  Checking code checks for illegal
overlaps.
\ikey{Parallel qualifiers}{parallel qualifier} may be declared to
identify memory locations whose register \underline{and hardware}
caches are to be flushed by explicit cache flushing statements in the
L-Language.
These are used for memory locations shared between different hardware
processing units (e.g., between a central processing unit and an
IO device, or between two different central processing units).

\ikey{Protection qualifiers}{protection qualifier} may be declared
to control which functions can access a memory location or call other
functions.
A memory location with protection qualifier $X$ can only be
accessed by functions whose bodies have qualifier $X$, and
a function with qualifier $X$ can only be called by functions
whose bodies have qualifier $X$.  There is one builting protection
qualifier, `{\tt unchecked}', which permits access to various
builtin operations that explicitly or implicitly involve type
conversion.


[TBD: delete this?
Memory locations can be assigned qualifier expressions that are logical
combinations of qualifier names and the operators `\verb/|/' and
`\verb/&/'.  For example, a memory location may be assigned the expression
`$X$\verb/|constant/' where $X$ is a protection qualifier.  A function body
with qualifier $X$ will be able to access such a memory location to both
read and write it, but a function body without qualifier $X$ will treat the
location as having the `\verb|constant|' qualifier, will not be able
to write the location, and will assume that the location will
not be written by others.  In order for this to work properly, the functions
with qualifier $X$ that are permitted to write the location must be called
first, before functions without qualifier $X$ are allowed to access the
location.  Alternatively, `{\tt constant}' can be replaced by `{\tt readonly}',
which forbids writing the location but does \underline{not} promise that
other code will not write the location.]

\ikey{Containing qualifiers}{containing qualifier} specify that a location
might contain an encoded value, such as a pointer to a collectable location.
For example, a value possibly containing an encoded pointer to
the collectable location will be restricted as if it were a pointer to
a collectable location.

\ikey{Traceable qualifiers}{traceable qualifier} may be applied to
stack locations.  All stack locations with a particular traceable
qualifier may be found by code via builtin L-language primitives.
For example, if values of a particular type may hold pointers
to garbage collectable locations, making these values
traceable permits all such values allocated to the stack to
be located by the garbage collector.

A single qualifier may be of several kinds at once.  For example,
a qualifier may be collectable, containing, and traceable.

\subsubsection{Lifetime Qualifiers}
\label{LIFETIME-QUALIFIERS}

Lifetime qualifiers determine where pointers to locations can be stored.
Two lifetime qualifiers are builtin:  `{\tt static}', and `{\tt caller}'.
One kind of lifetime qualifier is declarable: collectable qualifiers.
If no lifetime qualifier is supplied for a location, `{\tt caller}'
is assumed.

\begin{indpar}

\hspace*{-1em}\ttkey{static}~~~~~Specifies
the location lives forever.  Locations allocated at load time
or at program initialization time may be declared static.

\hspace*{-1em}\ttkey{caller}~~~~~Only
used in a function $F$'s value or return type to qualify a location
whose address is passed to the function.  Specifies the function's caller
must provide the `{\tt caller}' location, but the location need not be
in a frame, and may be `{\tt static}' or collectible instead.  Asserting
that such a location is `{\tt caller}' is only a promise by the
function $F$ not to store the location's address anywhere but in its
frame or in a `pointer to {\tt caller} location'
argument to or return value from another function it calls.

For example:
\begin{indpar}[0.5em]\begin{verbatim}
int32 function1 ( static int32 * caller * arg1 );
    // The argument is a pointer to a caller allocated location
    // holding a pointer to a statically allocated int32.  The
    // caller need not provide a useful value in the caller
    // allocated location, and function1 can use `* arg1 = value'
    // to return a pointer to a static int32 value in this location,
    // but cannot use `arg1 = value' to reset the argument.
int32 function2 ( caller int32 * caller * arg1 );
    // The argument is a pointer to caller allocated location
    // holding a pointer to a caller allocated location holding
    // an int32.  Both pointers must be provided by the caller and
    // cannot be reset by function2.  function2 can use
    // `**arg1 = value' but not `*arg1 = value' or `arg1 = value'.
int32 function3 ( caller int32 * static * arg1 );
    // Illegal; a pointer not set by the caller cannot point to a
    // pointer that must be set by the caller.
(static int32 * caller * res1) = function4 ( int32 arg1 );
    // Here the result behaves like an extra argument named res1
    // passed to function4 which has the same properties as arg1 in
    // function1.  The statement `return value' is illegal here
    // as it would be equivalent to `return res1 = value' and
    // reset the pointer to the caller location.  However
    // `return * res1 = value' is legal.
static int32 * caller *& function5 ( int32 arg1 );
    // Same as function4 but `return value' is legal and sets the
    // pointer to the statically allocated int32.
(caller int32 * caller * res1) = function6 ( int32 arg1 );
    // The result behaves like an extra argument passed to function6
    // which has the same properties as arg1 in function2.
    // `return ** res1 = value' must be used to return an integer.
caller int32 * static * function7 ( int32 arg1 );
    // Illegal; the result behaves like an extra argument passed to
    // function7 which has the same properties as arg1 in function3.
\end{verbatim}\end{indpar}

The `{\tt caller}' lifetime qualifier is implied by the `{\tt stack}'
cache qualifier (see below).  The `{\tt caller}' lifetime qualifier
is the default lifetime qualifier for any location that has no
lifetime qualifier.  Thus in the above example the `{\tt caller}'
qualifiers could have been omitted.

\hspace*{-1em}\ikey{Collectable Qualifiers}%
{collectable qualifier}~~~~~Collectable
qualifiers are declared by the programmer and are used to tag
memory locations that can be garbage collected.

Addresses of collectable locations are like addresses of `{\tt caller}'
locations, and may only be written to stack frames.  An exception
to this rule
is that functions whose bodies are given the collectable qualifier may write
such addresses to any otherwise legal location.
These functions generally have to perform
other operations related to garbage collection, such as
maintaining reference counts or garbage collection flags
when addresses are written.

\end{indpar}

An address of a location with any lifetime qualifier
(including the default `{\tt caller}')
may \underline{not} be re-cast as the address of a location
with a different lifetime qualifier (here two different
collectable qualifiers are considered to be different),
with the exception that
the address of a location with a `{\tt static}' qualifier
\underline{may} be re-cast as the an address of a location with a
`{\tt caller}' qualifier.

\subsubsection{Caching Qualifiers}
\label{CACHING-QUALIFIERS}

When a memory location is moved into a register, the register becomes
a \key{software cache}\index{cache!software}
of the memory location.  Thus memory locations
are cached in registers under the control of software, and not hardware.
Unfortunately this makes things very difficult for the compiler
(the ultimate fix is a radical change in computer architecture).

Two caching qualifiers are builtin: `{\tt constant}' and `{\tt stack}.
Two kinds are declarable: alias qualifiers and parallel qualifiers.

\begin{indpar}

\hspace*{-1em}\ttkey{constant}~~~~~The memory location is constant and will not
be modified at all.

The memory location can be cached in registers without
restriction.

Memory locations declared `{\tt constant}' must be written during their
initialization.  This is managed by not declaring a location to be
`{\tt constant}' when it is passed as a result value to the function
that initializes the location.

The following code has some examples:
\begin{indpar}[0.5em]\begin{verbatim}
int32 function1 ( stack constant *& arg1 );
int32 function2 ( stack readonly *& arg1 );
int32 function3 ( stack *& arg1 );
. . . . . . . . . .
constant int32 value1 = 5;
   // Permitted:
   //   stack int32 *& .assign. ( 5 ) is called.
value1 = 10; 
   // Erroneous:
   //   stack constant int32 *& .assign. ( 10 ) is called.
function1 ( value1 );  // Permitted; arg1 constant.
function2 ( value1 );  // Permitted; arg1 readonly.
function3 ( value1 );  // Erroneous; arg1 NOT constant or readonly.
\end{verbatim}\end{indpar}

Note that the `{\tt constant}' qualifier in an argument type is a promise
that \underline{no code} will \underline{ever} modify the location.  By contrast
a `{\tt readonly}' argument qualifier (like `{\tt const}' in C/C++)
is a promise only that the location will not be modified during
the course of the call.  The difference is that a called function
may construct a long-lived cache of a `{\tt constant}' location
but not of a `{\tt readonly}' location.

The `{\tt constant}' qualifier obeys the following special rules:
\begin{enumerate}
\item
`{\tt constant}' is removed from a location passed to a
function as the result location in the initializer statement
of the location.
\item
`{\tt constant}' is the default cache qualifier for function parameters
that are passed by value and not by reference.
\end{enumerate}

\hspace*{-1em}\ttkey{stack}~~~~~The memory location is in the stack of
the current thread.

A `{\tt stack}' memory location may be cached in a register.
This cache must be flushed when an out-of-line function is called
only if the address of the location is passed to the out-of-line
function.

A `{\tt stack}' cache qualifier implies a `{\tt caller}' lifetime
qualifier and is incompatible with other lifetime qualifiers.
Note, however, that `{\tt static}' locations can also be type-recast
as `{\tt caller}' locations, so a location known merely to be
a `{\tt caller}' location might be passed to a function via
addresses in static locations instead of by arguments, whereas
a location known to be `{\tt stack}' can only be passed by addresses
in arguments.

\hspace*{-1em}\ikey{Alias Qualifiers}%
{alias qualifier}~~~~~Alias
qualifiers are declared by the programmer and are used to tag
memory locations that may be aliased with each other.

At compile time the L-Language converts location
addresses into a form that is the sum
of a \key{base address} and an integer \key{offset}.
In addition the location may have associated
alias qualifiers.  The L-Language assumes two locations do not overlap
unless they have a common alias qualifier, or unless the locations have
identical base addresses and their offsets indicate they overlap.

A base address is one of the following:

\begin{enumerate}
\item The address of a memory block allocated by the loader.
\item The address of a memory block allocated to the current function frame.
\item An address passed into the current function as the location
of an argument or return value.
\item An address returned from a function call or builtin operation,
      including addresses read from memory locations.
\end{enumerate}

For example:
\begin{indpar}[0.5em]\begin{verbatim}
void copy1 ( uns8 source[length],
             uns8 destination[length],
             uns32 length )
{
    uns32 i = 0;
    loop: {
        if ( i >= length ) break loop;
        destination[i] = source[i];
        ++ i;
    }
}
declare alias qualifier same_data;
void copy2 ( same_data uns8 source[length],
             same_data uns8 destination[length],
             uns32 length )
{
    uns32 i = 0;
    loop: {
        if ( i >= length ) break loop;
        destination[i] = source[i];
        ++ i;
    }
}
uns8 x[16];
x[0] = 0;
copy1 ( x[0 .. 14], x[1 .. 15], 15 );   // Erroneous.
copy2 ( x[0 .. 14], x[1 .. 15], 15 );   // Zeros x.
\end{verbatim}\end{indpar}

The call to {\tt copy1} is erroneous because
arguments that are not supposed to be aliased are in fact aliased.

Aliasing is checked as necessary by the compiler and at run time.
The run-time checks can be suppressed by compilation switches.

\hspace*{-1em}\ikey{Parallel Qualifiers}%
{parallel qualifier}~~~~~Parallel
qualifiers are declared by the programmer and are used to tag
memory locations that may be flushed from software and hardware
caches in order to permit separate central processing units
to communicate through shared memory.

There are three L-Language statements that flush caches.  Each gives
a list of parallel qualifiers that names all the locations accessible
at the point of the statement that are tagged with these qualifiers.  An
example is:
\begin{indpar}[0.5em]\begin{verbatim}
declare parallel qualifier pdata, pflag;
pdata float64 x[3];
pflag bool done_flag = false;
. . . . . . .
// Output data
x[0] = 35.87;
x[1] = -2.90;
parallel flush write pdata;
// Set flag indicating data output
done_flag = true;
parallel flush write pflag;
// Wait for data to be consumed
loop: {
    spin ( 5000 ); // 5000 nanosecond spin
    parallel flush read pflag;
    if ( done_flag = false ) break loop;
}
// Data has been consumed
\end{verbatim}\end{indpar}

\end{indpar}

\subsubsection{Protection Qualifiers}
\label{PROTECTION-QUALIFIERS}

Five protection qualifiers are builtin:
`{\tt readwrite}', `{\tt readonly}', `{\tt writeonly}', `{\tt noaccess}',
and `{\tt unchecked}'.
Additional protection qualifiers may be declared.

\begin{indpar}

\hspace*{-1em}\ttkey{readwrite}, \ttkey{readonly}, \ttkey{writeonly},
\ttkey{noaccess}~~~~~Specifies whether execution may read or write a location.

\hspace*{-1em}\ttkey{unchecked}~~~~~Specifies that the execution of
a function body may
invoke builtin operators that perform explicit or implicit
type conversions.

\hspace*{-1em}\ikey{Protection Qualifiers}%
{protection qualifier}~~~~~Non-builtin protection
qualifiers may be declared by the programmer and used to qualify
functions.  They may then be used in `\skey{qualifier expression}s'
that qualify memory locations.

\end{indpar}

A \key{qualifier expression} is an expression composed of qualifiers,
the operators `\ttmkey{\BAR}{in qualifier expression}'
and `\ttmkey{\&}{in qualifier expression}', and parentheses.
In order for a memory location to be accessible by a function,
each of the location's qualifier expressions must evaluate to true
according to the following rules.  First, each protection qualifier
is given the value true if it qualifies the function and false otherwise.
Second, every non-protection qualifier is given the value true if and only if
doing so is necessary and sufficient to make all
the subexpressions containing the non-protection
qualifier true.  This last rule is applied from left to right.
Any non-protection qualifiers
given the value true for any qualifier expression of the location then
qualify the location when it is accessed by the function, while
non-protection qualifiers given the value false are ignored.

For example, given the code
\begin{indpar}[0.5em]\begin{verbatim}
deftype type1 (24,4);
declare protection qualifier constructor(type1);
(constructor(type1)|constant) type1 my_data;
void function1 ( type1 *& arg1 );
void function2 ( constant type1 *& arg1 );
void function3 ( type1 *& arg1 ) constructor(type1);
. . . . . . .
function1 ( my_data);   // Erroneous; my_data is constant for
                        // function1.
function2 ( my_data);   // Legal; my_data is constant for
                        // function2 and so is arg1.
function3 ( my_data);   // Legal; my_data is NOT constant for
                        // function3.
\end{verbatim}\end{indpar}

Note the left-to-right clause in the rule for evaluating non-protection
qualifiers.  For example, given the code:
\begin{indpar}[0.5em]\begin{verbatim}
deftype type1 (24,4);
declare protection qualifier A;
((A&readonly)|constant) type1 my_data1;
((A&readonly)|(A&readwrite)|constant) type1 my_data2;
\end{verbatim}\end{indpar}

then to a function with protection qualifier {\tt A}, {\tt my\_data1}
is {\tt readonly} and \underline{not}
{\tt constant}, whereas to all other functions, {\tt my\_data1}
is {\tt constant} and \underline{not} {\tt readonly}.  {\tt My\_data2}
behaves just like {\tt my\_data1}, as the subexpression `{\tt (A\&readwrite)}'
can never have any effect.

The precise specification for evaluating qualifier expressions
is as follows:

\begin{enumerate}
\item
A protection qualifier evaluates to true or false according to whether
the invoking code has or does not have the qualifier.
\item
Any other qualifier evaluates to true when it is evaluated.
When this happens the qualifier is asserted for the
location qualified by the qualifier expression.  Note that evaluation
may skip over subexpressions and thereby not encounter qualifiers
therein.
\item
Evaluation of the subexpression $x$\verb/|/$y$ evaluates $x$ first.
If $x$ evaluates to true, the subexpression evaluates to true and
evaluation of $y$ is skipped.  If $x$ evaluates to false, $y$ is
evaluated and its value becomes the value of the subexpression.
Note that \verb/|/ is left associative:
$x$\verb/|/$y$\verb/|/$z$ $\equiv$
($x$\verb/|/$y$)\verb/|/$z$.
\item
Evaluation of the subexpression $x$\verb/&/$y$ evaluates $x$ first.
If $x$ evaluates to false, the subexpression evaluates to false and
evaluation of $y$ is skipped.  If $x$ evaluates to true, $y$ is
evaluated and its value becomes the value of the subexpression.
Note that \verb/&/ is left associative:
$x$\verb/&/$y$\verb/&/$z$ $\equiv$
($x$\verb/&/$y$)\verb/&/$z$.
\end{enumerate}

\subsubsection{Containing Qualifiers}
\label{CONTAINING-QUALIFIERS}

\subsubsection{Traceable Qualifiers}
\label{TRACEABLE-QUALIFIERS}




\subsection{Memory Channels}
\label{MEMORY-CHANNELS}

TBD

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
multi-dimensional array of block descriptors.
A \key{block descriptor} contains the address and length of a block to be
accessed.  Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
There are shift operations on the window that move all its rows or columns
(or other dimension) over and fill in with empty block descriptors.

A memory channel is stored in a register, but the register may be shared.
The type and type parameters of the register determine the type of the
channel and determine how much actual memory is allocated to the register.

The window of a memory channel
is organized in the same way for all memory channels.
It consists of a rectangular array of block descriptors, with the number
of dimensions in the array being that given by the
`\mkey{dimensions}{of window}' register type parameter.  The size of
each dimension is determined when the memory channel is initialized at
run time, but must not be greater than the `\mkey{window-size}{of window}'
register type parameter.
Similarly the size of each block is determined when the block descriptor
is created, but must not be greater than the `\mkey{block-size}{of window}'
register type parameter.

For all types of memory channel the window appears to be a subarray of
a larger square array.  The window has a \mkey{reference point}{of window}
that can be shifted along any of its dimensions.  Or the reference point
can be completely reset.  For most kinds of memory channels, window
block descriptors are computed automatically from the block descriptor
and in some cases block contents of an adjacent window position.
In the typical case, once an initial reference point
block descriptor has been loaded into the memory channel, all other
block descriptors are computed automatically by this mechanism, and
typically the reference point is only moved by shifting it.

Memory channels differ in how block descriptors are computed.  A
linear memory channel assumes that blocks are addressed in memory according
to a linear scheme, and automatically fills in block descriptors when
the window is shifted.  A chained channel is similar except it assumes
each block points at its neighbors.  A direct channel requires programmed
instructions to load block descriptors.  In this last case, a block
descriptor may hold an instruction for computing it from the contents
of an adjacent block, so the instruction need not be delayed if the
adjacent block contents are not yet available.

When a window is shifted, block descriptors may be computed automatically
for new window elements, and the referenced blocks may be loaded into
a cache.  The part of the window for which blocks are loaded into the
cache in advance of any specific instruction referencing the blocks
is called the lookahead window, and is a subarray of the full window.


\subsubsection{Linear Memory Channels}

Linear memory channels access multi-dimensional arrays of blocks
whose addresses are computable from a linear equation of the form:

\begin{center}
$\mbox{\em address} = \mbox{\em base-address}
		    + \sum_{n=1}^N \mbox{\em offset}_n\cdot i_n$
\\[2ex]
where $0\leq i_n < \mbox{\em dimension-size}_n$ for $1\leq n \leq N$
\end{center}

\subsubsection{Chained Memory Channels}

For a chained memory channel there are a fixed set of instructions
that tell how to compute the address of a block from the contents
of adjacent blocks.


\section{Frame Blocks}
\label{FRAME-BLOCKS}

\section{Code Blocks}
\label{CODE-BLOCKS}

\section{To Do}

How can dynamically initialized locations be static.

Indirect address protocol.
\label{INDIRECT-ADDRESS-PROTOCOL}

Functions.
\label{FUNCTIONS}

Threads.
\label{THREADS}

\bibliographystyle{plain}
\bibliography{layered-l-language}

\printindex

\end{document}
