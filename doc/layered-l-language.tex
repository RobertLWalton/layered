% The Layered Low (L) Programming Language
%
% File:         layered-l-language.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{makeidx}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emmkey}[2]{{\bf \em #1}\index{#1@{\em #1}!#2}}
\newcommand{\emsmkey}[3]{{\bf \em #1#2}\index{#1@{\em #1}!#3}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\itemref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{\,\textsuperscript{p\pageref{#1}}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\TMP}{\$}			% Compiler Temporary
\newcommand{\ABV}{-{}-{}->}		% Abbreviates
\newcommand{\CNV}{\longrightarrow}	% Converts to
\newcommand{\TCNV}{\Longrightarrow}	% Transitive closure

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][0.5in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
	                \setlength{\leftmargin}{#1}%
		        \addtolength{\leftmargin}{\labelsep}}}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Lower (L) Layered Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

March 1, 2018
 
\end{center}

{\small \tableofcontents}

\newpage

\section{Introduction}

This document describes the Lower Layer Programming Language, or
L-Language.  See the Introduction to the Layered
Programming Languages for basic syntax and for an overview of the related
Middle Layer M-Language and Higher Layer H-Language (these overviews
have not yet been written).

The L-Language is intended to be a target language for compilers of
higher level languages.  As such it is optimized first to be an easy to 
use as a target language, and second to be easy to
compile into reasonably efficient debuggable assembly language code.

The L-Language is similar to the C programming language
but differs in the following ways:

\begin{enumerate}

\item
L-Language facilitates isolating non-type-safe code into small inline functions.

\item
All L-Language data types are builtin number types or subtypes of
builtin number types.  All data managed directly by L-Language consists
of single numbers allocated to the stack.

\item
Memory references other than those to single stack allocated numbers
are handled by code
encapsulated in small inline functions written by the programmer.
These memory references
are treated in a manner reminiscent of input/output.
The bodies of these inline functions are not type-safe, but if
there are written correctly, usage of these functions is type-safe.

\item
There is no concept of a memory structure in the L-Language.  There
is a new concept, the `cluster', which is a collection of stack
variables that can be passed to inline functions
and returned from inline functions as a syntactic unit.

\item
The type `\TT{type}' is first class, is a subtype of integers, and
each `\TT{type}' value is assigned
a unique constant small integer value.  Constant
argument values, such as the value of a `\TT{type}' valued
argument, can be used to select overloaded functions.

\item
Most L-Language functions are inline.  Out-of-line functions can be
called using a block syntax that mirrors the overhead involved in
manipulating an argument stack in memory.

\item
L-Language uses a single-assignment style of program structure
to encourage
efficient code that leaves an audit trail for debugging in the stack.
Partial evaluation of expressions and inline code is supported without
compromising debuggability.

\item
L-Language allows code to be compiled at run-time just before
it is run, for extra efficiency.

\item
L-Language allows code to be compiled into the compiler, to support
language enhancements.

\item
L-Language uses the Layered Language Module Structure to manage
multi-file source code in a well-ordered and type-safe manner.


\end{enumerate}


\section{Lexemes}
\label{LEXEMES}

An L-Language source file is a sequence of bytes that is a UTF-8 encoding
of a sequence of UNICODE characters.  This is scanned into a sequence
of \skey{lexeme}s.

Unless otherwise specified, the term `\key{character}' in this
document means a 32-bit UNICODE character.

Lexemes are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes single space) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} ::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::=
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe}, \\
    and \TT{Pf}; includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{decimal-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em decimal-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\label{COMMENT}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

One kind of {\em horizontal-space} is given special distinction:
\begin{indpar}
\emkey{indent} ::=
	\begin{tabular}[t]{l}
        {\em horizontal-space} just before the first \\
	{\em graphic} character on a line
	\end{tabular}
\end{indpar}

The \skey{indent lexeme}s have no characters, but
do have an \mkey{indent}{of indent lexeme}, which is the indent of
the graphic character after the indent lexeme.
The \mkey{indent}{of character} of a character is the number
of columns that precede the character in the character's physical line.
Indent lexemes are used to form logical lines and blocks
(\itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

A non-{\em indent}, non-{\em line-break} {\em white-space}, such as occurs
in the middle of text or code outside comments, is discarded and not treated
as a lexeme.  Such {\em white-space} may be used to separate lexemes.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::=
    \begin{tabular}[t]{l}
    {\em horizontal-space-character}, other than \\ single space
    \end{tabular}
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= {\em vertical-space-character}
	other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::=
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} \\
    or {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::=
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these strings generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

\begin{boxedfigure}[!p]
\begin{indpar}

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em word} $|$ {\em mark} $|$ {\em number} $|$
	      {\em separator} $|$ {\em quoted-string} $|$ {\em indent} \\
	$|$ & {\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}\label{CHARACTER-REPRESENTATIVE}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{number} \begin{tabular}[t]{rl}
    ::= & {\em middle-lexeme} with a {\em digit} before any {\em letter} \\
    $|$ & {\em middle-lexeme} with a {\em digit} immediately after
                               a `\TT{+}' or `\TT{-}' \\
	\end{tabular}
\\[0.5ex]
\emkey{natural-number}\label{NATURAL-NUMBER}
	:::= {\em decimal-digit}\PLUS{} not beginning with \TT{0} $|$ \TT{0}
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme} containing a {\em letter} that is not
                  a {\em number}
\\[0.5ex]
\emkey{mark} :::= {\em middle-lexeme} that is not a {\em word} or
		  {\em number}

\end{indpar}
\caption{L-Langauge Program Lexemes}
\label{L-LANGUAGE-PROGRAM-LEXEMES}
\end{boxedfigure}

The lexemes in a L-Language program are specified in
Figure~\itemref{L-LANGUAGE-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see page \pageref{ILLEGAL-CHARACTERS}
above to account for such characters.

The symbol `\ttmkey{:::=}{in syntax equation}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttmkey{::=}{in syntax equation}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file} lexeme that occurs only at the
end of a file.

Files are scanned into sequences of lexemes which are then divided
into logical lines as per \itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}.
After each logical line is formed,
{\em indent}, {\em comment},
{\em line-break}, and {\em end-of-file} lexemes are deleted
from the logical line.

\ikey{Quoted string lexemes}{quoted strings!concatenated}
separated by the `\TT{\#}' mark
are glued together if they are in the
same logical line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence" #
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

A \emkey{special-character-representative} can consist of
a UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.

A {\em special-character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.

\section{Logical Lines, Blocks, and Statements}
\label{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}

Each non-blank physical line begins with an {\em indent} lexeme
that is followed by a
lexeme that is not an {\em indent}, {\em line-break}, or
{\em end-of-file}.

Lexemes are organized into \skey{logical line}s.  A logical line
begins immediately after an {\em indent} lexeme, and the
\mkey{indent}{of logical line} of the logical line is the
indent of this {\em indent} lexeme (i.e., the indent of the
first graphic character of the logical line).

A logical line ends with the next {\em indent} lexeme whose indent
is not greater than the indent of the logical line, or with an
{\em end-of-file}.  Thus physical
lines with indent greater than that of the current logical line
are \skey{continuation line}s for that logical line.

A code file is a sequence of `\key{top level}' logical lines that
are required to have indent \TT{0}.

A logical line may end with a \key{block} that is itself a sequence of
logical lines that have indents greater than the indent of the
logical line containing the block.
The block is introduced by a `\TT{:}' at the end
of a physical line.  If the first {\em indent} lexeme after the
`\TT{:}' has an indent that is \underline{not} greater than the indent
of the logical line containing the `\TT{:}', the block is empty.
Otherwise the indent of this {\em indent} lexeme becomes the
\mkey{indent}{of block} of the block and the indent of all the
logical lines in the block.  The first logical line of the block
starts immediately after this {\em indent} lexeme.
The block ends just before the first
logical line with lesser indent than the block indent, or the end of file.
More specifically, the last logical line of the block ends with an
{\em indent} whose indent is less than the block indent, or with an
{\em end-of-file}.

Examples are:
\begin{indpar}\begin{verbatim}
this is a top level logical line ending with a block:
    this is the first line of the block
    this is the
         second line of the block
    this is the third line of the block:
        this is the first line of a subblock
        this is the second line
                of the subblock:
            this is the only line of a sub-subblock
        this is the third line of the subblock
    this is the fourth line
            of the block:
        this is the only line of the second subblock
      this line has erroneous indent as its indent
           is less that the second subblock indent
           but greater than the indent of the line
           that contains the second subblock
    this is the fifth line of the block
         and it ends with an empty subblock:
this is the second top level
     logical line
\end{verbatim}\end{indpar}

A warning message is output if the indents of any two
consecutive logical lines differ by more than \TT{0} and
less than \TT{2} columns, in order to better detect
indentation mistakes.

{\em Line-break} lexemes are effectively ignored.  A sequence
of {\em line-break} lexemes is followed by an {\em indent}
or {\em end-of-file} which is not ignored.
Blank physical lines are represented by sequences of
more than one {\em line-break} lexeme, and are effectively
ignored.

A logical line that contains {\em comments}, but no
lexemes other than {\em comments}, {\em line-breaks}, {\em indents}
and a possible {\em end-of-file}, is
a `\key{comment line}', and is ignored.

It is an error to begin non-comment logical lines with
a {\em comment}.
{\em Comments} can be used freely in the middle of or at the
end of any logical line, or at the beginning of a comment line.

It is an error for the first logical line of a file
to have an indent that is greater than \TT{0}, the top level
indent.

It is an error for a block to be in the middle of a logical
line.  This means that the first {\em indent} following the
block must have an indent no greater than that of the logical
line containing the block.

Examples are:
\begin{indpar}\begin{verbatim}
// this is a logical line that is a single comment

// this is a logical line that has two
    // comments

this is a logical line // with a comment
     // and another comment
     with three comments // and a last comment

this is a logical line ending with a block:
     First line of the block
     Second line of the block
// Comment that ends block, but is in error because

    it begins a logical line that this continues

this is a logical line with a block:
     First line of the block
     Second line of the block
  but the block is in error because it is before
  this continuation of the logical line that contains
  the block

this is a logical line ending with a block:
        First line of the block
        Second line of the block
  // comments that end the block, but are in error,
  // because they continue the logical line
  // containing the block
\end{verbatim}\end{indpar}

After a logical line
has been formed, any {\em indent},
{\em comment}, {\em line-break}, and {\em end-of-file}
lexemes in the logical line
are removed from the logical line.  If the result is
empty, i.e., the logical line is a comment line, it is discarded.
Otherwise the
modified logical line becomes a L-Langauge `\emkey{statement}'.

Therefore a file is a sequence of top-level statements.

Since a logical line can end with a block that itself consists
of a sequence of logical lines, a statement can end with
a block that itself consists of a sequence of statements.


\section{Names}
\label{NAMES}

A \key{name} is a sequence of lexemes used to name things like
variables and functions.

\begin{indpar}
\emkey{name}\label{NAME} ::=
    {\em initial-name-item} {\em continuing-name-item}\STAR{} \\
\emkey{initial-name-item} ::= {\em name-item} other than {\em natural-number} \\
\emkey{continuing-name-item} ::= {\em name-item} not containing `\TT{.}' \\
\emkey{name-item}\label{NAME-ITEM}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} containing no `\TT{.}' following a character
                     that is not a `\TT{.}' \\
        & [see text about splitting words with embedded `\TT{.}'s] \\
    $|$ & {\em natural-number} \\
    $|$ & {\em quoted-mark} not containing `\TT{.}'s \\
    $|$ & {\em quoted-separator} not containing `\TT{.}'s \\
    \end{tabular} \\
\emkey{quoted-mark} :::= \TT{"} {\em mark} \TT{"} \\
\emkey{quoted-separator} :::= \TT{"} {\em separator} \TT{"}
\end{indpar}

{\em Words} containing embedded `\TT{.}'s are split into
{\em name-items} which can only contain `\TT{.}'s at their beginning.
Thus
\begin{center}
\TT{bills.wife.1.weight..size}
\end{center}
is split into
\begin{center}
\TT{bills~~~.wife~~~.1~~~.weight~~~~..size}
\end{center}
However, `\TT{.1}' is not a legal {\em name-item} and so cannot
be part of a legal {\em name}.

Names can be computed at compile time:
see~\itemref{THE-NAME-TYPE}.
One name can be used to abbreviate another:
see~\itemref{ABBREVIATIONS}.
A name may begin with a {\em word} that is a {\em module-abbreviation}
that designates a code module: see~\itemref{MODULES}.

A {\em name} may be an abbreviation for another name.  Such abbreviations
can be introduced by statements of the form
\begin{center}
{\em abbreviation-name} \TT{\ABV} \TT{`}{\em replacement-name}\TT{'}
\end{center}
See the section on abbreviations
(\itemref{ABBREVIATIONS})
for more details.

The builtin names in this document are implicitly in the
\TT{"standard"} module whose {\em module-abbreviation} is `\TT{std}'.
See the section on modules (\itemref{MODULES}) for details.
For example the name `\TT{bool}' of the boolean data type is actually a builtin
abbreviation defined by:
\begin{center}
\TT{bool {\ABV} `std bool'}
\end{center}
and the builtin type name proper is `\TT{std bool}' and not `\TT{bool}'.


Similarly the  builtin function such as \TT{round} as used in:
\begin{center}
{\tt float$x$ r = round ( float$x$ v )} \\
\end{center}
actually has the function prototype (\pagref{FUNCTION-PROTOTYPE}):
\begin{center}
{\tt function std float$x$ r = std round ( std float$x$ v )} \\
\end{center}
so its proper name is `\TT{std round}' and not `\TT{round}',
but in this case it is not necessary (or desirable) to make `\TT{round}'
an abbreviation because its module can be implied in a function call
(see `module deficient' on \pagref{MODULE-DEFICIENT}).
\subsection{Kinds of Names}

The L-Language uses several kinds of names:

\begin{indpar}
\emkey{type-name}\label{TYPE-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{qualifier-name}\label{QUALIFIER-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{variable-base-name}\label{VARIABLE-BASE-NAME}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{variable-name}\label{VARIABLE-NAME}
	::= {\em variable-base-name} {\em member-selector}\STAR{} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript } \\
\emkey{member-name}\label{MEMBER-NAME}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark}
			    or {\em quoted-separator}
			\end{tabular} \\
\emkey{member-subscript} ::= see \pagref{MEMBER-SUBSCRIPT} \\
\emkey{function-term-name} ::= {\em name} \\
\emkey{initial-function-term-name} ::=
    \begin{tabular}[t]{@{}l@{}}
    {\em function-term-name} that can appear \\
    at the beginning of a {\em statement};
    see \pagref{INITIAL-FUNCTION-TERM-NAME}
    \end{tabular}

where
\begin{enumerate}
\item A {\em type-name} may not be an initial segment of another
{\em type-name}, of a {\em variable-base-name},
or of an {\em initial-function-term-name}.
\item A {\em qualifier-name} may not be an initial segment of another
{\em qualifier-name}, of a {\em type-name},
or of a {\em initial-function-term-name}.
\item
A {\em type-name}, {\em qualifier-name}, or {\em variable-base-name}
may not begin with the word `\TT{next}' or `\TT{previous}'.
\item
{\em Name-items} ending with `\TT{\TMP$n$}',
where $n$ is a {\em natural-number}, are
reserved for use by the compiler.
\item
{\em Name-items} beginning with `\TT{..}' (possibly followed by more
`\TT{.}'s) are reserved
for use by systems and compilers (e.g., \TT{..size} in the last example).
\end{enumerate}
\end{indpar}

The first two rules are required because the syntax
\begin{center}
{\em qualifier-name}\STAR{} {\em type-name} {\em variable-name}
\end{center}
is used in {\em variable-declarations} that may begin {\em statements}
and in {\em prototype-argument-declara\-tions}.  Also, a
{\em function-call} beginning with a {\em function-intial-term-name}
may also begin a {\em statement}.
The third rule is because {\em variable-declarations} are prefaced by
`\TT{next}' and `\TT{previous}' with special meanting in certain contexts.
The fourth rule is because the compiler generates names like \TT{T\TMP$n$}
for temporary variables and \TT{B\TMP$n$} for compiler created blocks.

\subsection{Abbreviations}
\label{ABBREVIATIONS}

An \key{abbreviation} is a {\em name} that is replaced
by another {\em name} everywhere it occurs in code outside name constants.
Replacement occurs after expressions are parsed.

Abbreviations are declared by:
\begin{indpar}
\emkey{abbreviation-declaration}\label{ABBREVIATION-DECLARATION}
    ::= {\em abbreviation} ~ \ttkey{-{}-{}->} ~ {\em abbreviation-replacement}
\\[1ex]
\emkey{abbreviation} ::= {\em name} ~~~~~ [see \pagref{NAME}]
\\[1ex]
\emkey{abbreviation-replacement} ::= \\
\hspace*{0.5in}
    {\em expression} that evaluates at compile time to a \TT{name};
    see \itemref{THE-NAME-TYPE}
\end{indpar}

The most common {\em abbreviation-replacement} is a {\em name-constant}:

\begin{indpar}
\emkey{name-constant}
    ::= \TT{`}{\em name-item}\STAR{}\TT{'} \\
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

Abbreviation is recursive: an {\em abbreviation-replacement} can
itself be an abbreviation.
Abbreviation loops are possible and result in compile errors when
the abbreviation is used.
For example:
\begin{indpar}\begin{verbatim}
    X ---> `Y'
    int64 X = 5       // Same as: int64 Y = 5
    Y ---> `Z'
    int64 X = 5       // Same as: int64 Z = 5
    Z ---> `X'
    int64 X = 5       // Compile error replacing X.
\end{verbatim}\end{indpar}

Abbreviation replacement occurs after expressions are parsed, hence
the following example:
\begin{indpar}\begin{verbatim}
    foo ---> "+"
    int64 y = (5) foo (7)
        // OK: right side same as (5) "+" (7)
        // and is a function call.
    int64 x = 5 foo 7
        // Compile error: 5 "+" 7 is not function call
        // as arguments are not parenthesized.
\end{verbatim}\end{indpar}

Abbreviation replacement occurs before
{\em module-abbreviations} (see \pagref{MODULE-ABBREVIATION}) are
mapped onto modules.  Thus a name beginning with a
{\em module-abbreviation} can be either an abbreviation or an
abbreviation replacement.  There are a number of builtin
abbreviations exemplifying this, for example:
\begin{indpar}\begin{verbatim}
int32 ---> `std int32'
bool  ---> `std bool'
\end{verbatim}\end{indpar}

If the {\em abbreviation-replacement} is a type name in the
context of the abbreviation, the abbreviation is marked as a type
name. 
If the {\em abbreviation-replacement} is a qualifier name in the
context of the abbreviation, the abbreviation is marked as a qualifier
name.
Thus a variable declaration of the
form
\begin{center}
{\em qualifier-name}\STAR{} ~ {\em type-name} ~ {\em variable-name}
\end{center}
will work when {\em qualifier-names} and {\em type-names} are
{\em abbreviations}.
\begin{indpar}\begin{verbatim}
int32 ---> `std int32'
    // Builtin type abbreviation
*UNCHECKED*  ---> `std *UNCHECKED*'
    // Builtin qualifier abbreviation
*UNCHECKED* int32 x 1 = 99
    // Same as: std *UNCHECKED* std int32 x 1 = 99
\end{verbatim}\end{indpar}

Abbreviations are never external (\pagref{EXTERNAL}),%
\label{ABBREVIATIONS-ARE-NOT-EXTERNAL}
even if they begin with a {\em module-abbreviation}.
They do have scope like other declarations, but their scope
never extends beyond the file in which they are declared.


\section{Program Organization}
\label{PROGRAM-ORGANIZATION}

Code is organized into two kinds of files: \skey{module}s
and \ikey{bodies}{body}.  These files consist of a sequence
of \skey{declaration}s:
\begin{indpar}
\emkey{declaration}
    \begin{tabular}[t]{rll}
    ::= & {\em module-declaration}
        & [see \pagref{MODULE-DECLARATION}] \\
    $|$ & {\em body-declaration}
        & [see \pagref{BODY-DECLARATION}] \\
    $|$ & {\em defined-type-declaration}
        & [see \pagref{DEFINED-TYPE-DECLARATION}] \\
    $|$ & {\em enum-type-declaration}
        & [see \pagref{ENUM-TYPE-DECLARATION}] \\
    $|$ & {\em enum-set-type-declaration}
        & [see \pagref{ENUM-SET-TYPE-DECLARATION}] \\
    $|$ & {\em enum-list-type-declaration}
        & [see \pagref{ENUM-LIST-TYPE-DECLARATION}] \\
    $|$ & {\em qualifier-declaration }
        & [see \pagref{QUALIFIER-DECLARATION}] \\
    $|$ & {\em function-type-declaration }
        & [see \pagref{FUNCTION-TYPE-DECLARATION}] \\
    $|$ & {\em function-declaration }
        & [see \pagref{FUNCTION-DECLARATION}] \\
    $|$ & {\em out-of-line-function-declaration }
        & [see \pagref{OUT-OF-LINE-FUNCTION-DECLARATION}] \\
    $|$ & {\em abbreviation-declaration }
        & [see \pagref{ABBREVIATION-DECLARATION}] \\
    $|$ & {\em assignment-statement }
        & [see \itemref{ASSIGNMENT-STATEMENTS}] \\
    \end{tabular}
\end{indpar}

Declarations declare names.  An {\em assignment-statement}
is also a {\em declaration} of its result variables.

Names shared between modules begin with {\em module-abbreviations}
that designate the module in which the name is declared.
Such names are called `\key{external}'.\label{EXTERNAL}
External names can only be declared in module files, and
never in body files.  External names cannot be declared inside
statement blocks, but must be declared at `top level' outside
blocks.

As an exception, abbreviations are never external, even if
they begin with a module name (\pagref{ABBREVIATIONS-ARE-NOT-EXTERNAL}).

In inline function calls the
{\em module-abbreviation} may be omitted
if the {\em function-prototype} matching the call
can be unambiguously determined: see
`module deficient' on \pagref{MODULE-DEFICIENT}.
This may not be done
for other names (e.g., external types, external variables).

An example is:
\begin{indpar}\begin{verbatim}
module "lib/math" as math

define type math complex is void
    // Given `math complex x', x[0] it the real part of a
    // complex number and x[1] is the imaginary part.

function math complex r, float64 r[0], float64 r[1] =
    math complex ( float64 real, float64 imaginary ):
    r[0] = real
    r[1] = imaginary

function math complex r, float64 r[0], float64 r[1] =
    math ( math complex a1, float64 a1[0], float64 a1[1] )
    "+"  ( math complex a2, float64 a2[0], float64 a2[1] ):
    r[0] = a1[0] + a2[0]
    r[1] = a1[1] + a2[1]

---------------------------------------------
module "my-module" as mine
    import "lib/math" as math

.............................
math complex x = math complex ( 1, 0 )
math complex y = complex ( 0, 1 )
    // The second `complex' in each line is a function name
    // so `math' may be omitted.  In this case the function
    // prototype that applies is selected by the y result
    // variable type.
math complex z1 = x + y
    // Parses to `math complex z1 = ( (x) "+" (y) )'.
    // Standard "+" does not apply because it does not match
    // result type.  `math' module abbreviator is implied so
    // that `math' module "+" applies.
math complex z2 = math ( x + y )
    // Parses to `math complex z2 = ( math (x) "+" (y) )'.
    // 1math' module abbreviator is explicit and NOT implied.
\end{verbatim}\end{indpar}

\subsection{Modules}
\label{MODULES}

A \key{module} is a file that begins with a {\em module-declaration}:

\begin{indpar}
\emkey{module-declaration}\label{MODULE-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= & {\em simple-module-declaration} \\
    $|$ & {\em simple-module-declaration}\TT{:} \\
	& \TT{~~~~}{\em import-clause}\STAR{} \\
    \end{tabular} \\
\emkey{simple-module-declaration} ::= \TT{module} {\em module-file}
        \TT{as} {\em module-abbreviation} \\
\emkey{module-file} ::= {\em quoted-string} \\
\emkey{module-abbreviation}\label{MODULE-ABBREVIATION}
	::= \TT{word} not containing any `\TT{.}'s \\
\emkey{import-clause}\label{IMPORT-CLAUSE} ::= \TT{import} {\em module-file}
        \TT{as} {\em module-abbreviation}

\begin{itemize}

\item
In a {\em module-declaration} all {\em module-abbreviations} must be
distinct, and all {\em module-files} must be distinct.
\end{itemize}
\end{indpar}

A {\em module-file} is a UNIX file name without its final extension.
The {\em module-file} of a {\em module-declaration} must match the
non-extension part of the name of the file containing the
{\em module-declaration}, relative to one of several directories
specified separately to the compiler.

The conceptual directed graph whose nodes are modules and whose
arrows connect each module to the modules it imports is called
the `\key{module graph}'.\label{MODULE-GRAPH}
This graph \underline{must be acyclic}.

The module \TT{"standard"}\index{standard@\TT{"standard"}} with
module abbreviation \ttkey{std} contains the builtin types and
their functions.  The {\em import-clause}
\begin{center}
{\tt import }\TT{"standard"}\ttindex{standard@\TT{"standard"}}{\tt{}
    as \ttkey{std}}
\end{center}
is implied in every {\em module-declaration} and
{\em body-declaration} (see \itemref{BODIES}).

When a type is declared, functions with arguments or result
values of that type are automatically declared.  For example,
the declaration
\begin{center}
{\tt define type $T1$ is $T2$}
\end{center}
automatically declares
\begin{center}
\begin{tabular}{l}
{\tt function bool r = ( $T1$ x ) "==" ( $T1$ y ):} \\
{\tt ~~~~r = ( $T2$ ( x ) ) "==" ( $T2$  ( y ) )}
\end{tabular}
\end{center}

If the declared type begins with module abbreviation $ma$, the function
will also be given this module abbreviation.  Thus if $T1$ begins with
$ma$, the function will be
\begin{center}
\begin{tabular}{l}
{\tt function bool r = $ma$ ( $T1$ x ) "==" ( $T1$ y ):} \\
{\tt ~~~~r = ( $T2$ ( x ) ) "==" ( $T2$  ( y ) )}
\end{tabular}
\end{center}


\subsection{Scope}
\label{SCOPE}

A {\em declaration} has a \key{scope},
that is the set of statements in which any
names or function prototypes defined by the {\em declaration}
are recognized.  The scope of a {\em declaration}
begins just after the {\em declaration}
itself, and
lasts to the end of smallest block containing the {\em declaration},
or until the end of the file containing the {\em declaration} if
the {\em declaration} is not inside any subblock.

The scope of a {\em name} or {\em function-prototype}
is the scope of the declaration that defines it.

Two different declarations of the same name may \underline{not}
have overlapping scope, except when the second declaration is
for `\TT{next} {\em variable-name}' and both declarations are
in the same smallest containing block.
(`\TT{next v}' is a new variable with the same name and type
as `\TT{v}': see \pagref{NEXT}.)

The scope of a name consists of statements and subblocks.
By the last rule, a name may not be
redeclared in a subblock that is in the name's scope.
So `\TT{next v}' cannot be declared in a subblock if `\TT{v}' was
declared outside the subblock and the entire subblock is within
the scope of `\TT{v}', so the smallest containing subblock of
`\TT{v}' is not the same as the smallest containing subblock of
`\TT{next v}'.

The \key{context}\label{CONTEXT} of a statement is the set of declarations
whose scope the statement is in.

When a function call to an inline function is compiled, or the
default expressions of function prototype are compiled,
the context of the compilation is \underline{not} the current context but
rather the context of the inline function declaration or of the function
prototype containing the default expression.

A declaration not inside a block is said to be `\key{top level}'.

A top level assignment statement may not include references to
out-of-line functions or to inline functions that in turn include
references to out-of-line functions.  This implies that all code needed
to initialize a top level variable will be initialized before the
variable is initialized.

A top level declaration
may \underline{not} have `\TT{next} {\em variable-name}' as
a result variable.

The name or the pattern of the prototype
declared by a top level declaration in a module may begin with
the {\em module-abbreviation} of the module.  In this case the
name or prototype is `\key{external}', and its scope is extended
to include modules and bodies that import the declaring module.
All other names and prototypes declared in the module are `\key{internal}',
and these names and the patterns of these prototypes may not begin
with any {\em module-abbreviation}.

Any name or prototype declared to be external in an imported module is
said to be `\key{imported}'.  Imported names can be used only if they begin
with the {\em module-abbreviation} that references the module in which
they are declared.  Imported prototypes may be used by calls beginning with
the {\em module-abbreviation} that references the module in which
they are declared, or if there is no ambiguity the {\em module-abbreviation}
may be omitted from the calls according to 
the module deficiency rules of
section~\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}.

An example is:
\begin{indpar}\begin{verbatim}
module "my_own_module" as mom:
    // `import "standard" as std' is implied
    import "George's_own_module" as gom
    // gom contains:
    //    function int32 z = gom ( int32 x ) "+" ( int32 y )

int32 mom my external constant = ...
int32 my internal constant = ...

function int32 y = mom my external function ( int32 x ):
    ... function body omitted ...
function int32 y = my internal function ( int32 x ):
    ... function body omitted ...

function int32 z = my inline function ( int32 x, int32 y ):
    int32 z1 = gom ( x + y )
        // Uses gom's + operator.
        // Compiles as as `gom (x) "+" (y)'.
    int32 z2 = std ( x + y )
        // Uses builtin std's + operator.
        // Compiles as as `std (x) "+" (y)'.
    z  = z1 + z2 
        // Compiles as `z = ( (x) "+" (y) )'.
        // Compile error, ambiguous: both std + operator
        // and gom's + operator match the call to "+".
\end{verbatim}\end{indpar}\label{EXTERNAL-INTERNAL-EXAMPLE}

\subsection{Bodies}
\label{BODIES}

A \key{body}
is a file that begins with an {\em body-declaration}:

\begin{indpar}
\emkey{body-declaration}\label{BODY-DECLARATION} ::=
    \begin{tabular}[t]{l}
    \TT{body }{\em body-name}\TT{ of }{\em module-name}\TT{:} \\
    \TT{~~~~}{\em import-clause}\STAR{} \\
    \TT{~~~~}{\em after-clause}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{body-name} ::= {\em quoted-string}
\\[0.5ex]
{\em import-clause} ::= see \pagref{IMPORT-CLAUSE}
\\[0.5ex]
{\em after-clause} ::= \TT{initialize after }{\em body-name}
\end{indpar}

A \key{body} is an extension of the module named in the first
line of the {\em body-declaration}.  The body cannot itself
declare any external names.  It can provide out-of-line
declarations for functions whose prototype as included in the
module it extends.  It can also declare internal names that
are used in these functions, and provide for the module
initialization code that may call out-of-line functions (unlike
code in the module file proper).

A body implicitly imports the module it extends.  Within the
body that module has the same {\em module-abbreviation} that it
had in the module's own file.  The other modules imported in the
module's own file are \underline{not} implicitly imported
to the body.  The body must import whatever other modules it uses
explicitly.

The {\em after-clauses} name other bodies that extend the same
module, and control initialization: see \itemref{PROGRAM-INITIALIZATION}.

\subsection{Program Initialization}
\label{PROGRAM-INITIALIZATION}

Modules must be initialized.  A module is initialized after every
module that it imports is initialized.  Otherwise the order of
initializing modules is indeterminate.  Because the module graph
(\pagref{MODULE-GRAPH}) is acyclic, it is always possible to
initialize imported modules before the importing module.

A module is initialized by executing assignment statements
in the module file, and then initializing
body files that extend the module.  A body file is initialized
by executing the assignment statements in the body file.
Note that some of these assignment statements may not have
result variables.

Unless specified by {\em after-clauses}, the order of initializing the
body files that extend a particular module is indeterminate.
An `\TT{initialized after "$B1$"}' clause for module \TT{"$B2$"} causes
\TT{"$B2$"} to be initialized after \TT{"$B1$"}.

Each module has a `\key{body graph}'\label{BODY-GRAPH}
whose nodes are bodies that extend
the module and whose arrows connect each body to the bodies it
initializes after.  This graph must be acyclic.



\section{Data Types}
\label{DATA-TYPES-TYPES}

The basic builtin types are the number types and the \TT{void} type.
All defined types are subtypes of these types.
One of the builtin defined subtypes is the `\TT{type}' type.

\subsection{Number Types}
\label{NUMBER-TYPES}

Numbers are sequences of bits, and each number is one of
four kinds, unsigned integer, signed integer, floating point number,
or address:

\begin{indpar}
\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\bf Name & \bf Kind & \bf Size \\[2ex]
\TT{std}~~~\ttkey{uns1}		& unsigned integer & 1 bits \\
\TT{std}~~~\ttkey{uns8}		& unsigned integer & 8 bits \\
\TT{std}~~~\ttkey{uns16}	& unsigned integer & 16 bits \\
\TT{std}~~~\ttkey{uns32}	& unsigned integer & 32 bits \\
\TT{std}~~~\ttkey{uns64}	& unsigned integer & 64 bits \\
\TT{std}~~~\ttkey{uns128}	& unsigned integer & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{int8}		& signed integer & 8 bits \\
\TT{std}~~~\ttkey{int16}	& signed integer & 16 bits \\
\TT{std}~~~\ttkey{int32}	& signed integer & 32 bits \\
\TT{std}~~~\ttkey{int64}	& signed integer & 64 bits \\
\TT{std}~~~\ttkey{int128}	& signed integer & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{float16}	& IEEE floating point number & 16 bits \\
\TT{std}~~~\ttkey{float32}	& IEEE floating point number & 32 bits \\
\TT{std}~~~\ttkey{float64}	& IEEE floating point number & 64 bits \\
\TT{std}~~~\ttkey{float128}	& IEEE floating point number & 128 bits
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unsadr}	& unsigned integer & size of address \\
\TT{std}~~~\ttkey{intadr}	& signed integer & size of address \\
\TT{std}~~~\ttkey{adr}		& signed or unsigned integer
                                & size of address \\
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unswrd}	& unsigned integer & size of integer register \\
\TT{std}~~~\ttkey{intwrd}	& signed integer & size of integer register \\
\TT{std}~~~\ttkey{floatwrd}	& floating point number & size of floating
\end{tabular}

\begin{tabular}{p{1.5in}@{~~~~~~}p{2in}@{~~~~~~}l}
\TT{std}~~~\ttkey{unsmax}	& unsigned integer & max implemented size \\
\TT{std}~~~\ttkey{intmax}	& signed integer & max implemented size \\
\TT{std}~~~\ttkey{floatmax}	& floating point number & max implemented size
\end{tabular}

\end{indpar}

These are the \key{built in number types}.  The \TT{\ldots{}wrd} types
are the sizes that execute fastest, while the \TT{\ldots{}max} types
may be larger sizes for which all arithmetic operations are implemented.
Copying and conversion of values is always implemented for
\underline{all}
number types, regardless of implementation, except for implementations
that do not implement \underline{any} floating point types.

Here `\TT{std}' is the module abbreviation for the \TT{"standard"}
module to which builtin types and functions belong.  For convenience
the following abbreviations are builtin:
\begin{indpar}
\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{uns1} & {\tt `std~uns1'} \\
\ttkey{uns8} & {\tt `std~uns8'} \\
\ttkey{uns16} & {\tt `std~uns16'} \\
\ttkey{uns32} & {\tt `std~uns32'} \\
\ttkey{uns64} & {\tt `std~uns64'} \\
\ttkey{uns128} & {\tt `std~uns128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{int8} & {\tt `std~int8'} \\
\ttkey{int16} & {\tt `std~int16'} \\
\ttkey{int32} & {\tt `std~int32'} \\
\ttkey{int64} & {\tt `std~int64'} \\
\ttkey{int128} & {\tt `std~int128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{float16} & {\tt `std~float16'} \\
\ttkey{float32} & {\tt `std~float32'} \\
\ttkey{float64} & {\tt `std~float64'} \\
\ttkey{float128} & {\tt `std~float128'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unsadr} & {\tt `std~unsadr'} \\
\ttkey{intadr} & {\tt `std~intadr'} \\
\ttkey{adr} & {\tt `std~adr'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unswrd} & {\tt `std~unswrd'} \\
\ttkey{intwrd} & {\tt `std~intwrd'} \\
\ttkey{floatwrd} & {\tt `std~floatwrd'} \\
\end{tabular}

\begin{tabular}{p{0.8in}@{\tt ~\ABV~}l}
\ttkey{unsmax} & {\tt `std~unsmax'} \\
\ttkey{intmax} & {\tt `std~intmax'} \\
\ttkey{floatmax} & {\tt `std~floatmax'} \\
\end{tabular}
\end{indpar}

Here we use abbreviation statements of the form
\begin{center}
{\em abbreviation-name}~~\TT{\ABV}~~\TT{`}{\em replacement-name}\TT{'}
\end{center}
to specify that whenever the {\em abbreviation-name} occurs it is to be
replaced by the {\em replacement-name}.  See \itemref{ABBREVIATIONS} for
more abbreviation details. 

In this document we will use these abbreviations as the
`\skey{builtin number type}s':

\begin{indpar}
{\em builtin-number-type-name}\label{BUILTIN-NUMBER-TYPE-NAME}
    \begin{tabular}[t]{@{}cl}
    ::= & \TT{uns1} $|$ \TT{uns8} $|$ \TT{uns16} $|$ \TT{uns32} $|$ \TT{uns64}
                    $|$ \TT{uns128} \\
    $|$ & \TT{int8} $|$ \TT{int16} $|$ \TT{int32} $|$ \TT{int64}
                    $|$ \TT{int128} \\
    $|$ & \TT{float16} $|$ \TT{float32} $|$ \TT{float64} $|$ \TT{float128} \\
    $|$ & \TT{unsadr} $|$ \TT{intadr} $|$ \TT{adr} \\
    $|$ & \TT{unswrd} $|$ \TT{intwrd} $|$ \TT{floatwrd}  \\
    $|$ & \TT{unsmax} $|$ \TT{intmax} $|$ \TT{floatmax}  \\
    \end{tabular}
\end{indpar}

\subsubsection{Integer Number Types}

The \mkey{size}{of number}
of a number is the number of its bits.  Numbers can have
different sizes: for example, unsigned integers can have
sizes of 1, 8, 16, 32, 64, or 128 bits.

Numbers are stored in registers or in random access memory (RAM).

An \key{unsigned integer} of size $S$ is a binary integer with
$S$ binary digits (\skey{bit}s) and range from $0$ to $2^S-1$.

A \key{signed integer} of size $S$ is a two's complement integer
of size $S$ and range from $-2^{S-1}$ to $+2^{S-1}-1$.
This represents the integer $I$ in the given range
by the unsigned $S$-bit integer equal to $I~\mbox{modulo}~2^S$.

An \key{address} holds a RAM byte address.
An address is a 32-bit or 64-bit signed or unsigned integer whose size
and signage are determined by the target machine.
Some of high order bits may be
required to be all 0's or all 1's, depending upon
the target machine.  The \TT{unsadr} and \TT{intadr}
unsigned and signed integer types of the same size
as an address are provided for storing indices and offsets.

A reasonable assumption for 64-bit addresses is that only the low
order 48-bits of the address are actually used.  This assumption can
be used to put other information in the high order 16 bits
of a 64-bit number containing an address.  For example, an address
can be embedded in a 64-bit floating point NaN.  The L-Language does
\underline{not} depend upon this assumption, but does provide a builtin function
that takes as input a 64-bit integer and two small integers, $L$ and $S$,
and returns a 64-bit address containing
the byte address equal to the low order $L$ bits of the input integer
left shifted by $S$.  The output may have undefined high order bits if
the hardware ignores them when using the output to address memory.
For example, if the hardware ignores the high order 20 bits, and uses only the
low order 44 bits,
this function would just copy its input 64-bit integer to its output
if $L\geq 44$ and $S=0$.\footnote{The I86 64-bit architecture
uses only the low order 48 bits of an address, but \underline{requires}
the high order 17 bits to all be the same, either all 1's or all 0's.
However, as it is unlikely that there will ever be an allocated memory region
that includes address 0 in its interior, it makes no significant difference
whether we consider addresses to be unsigned or signed.}

\subsubsection{Floating Point Number Types}

A \key{floating point number} of size $S$ is a floating point number
represented according to the IEEE 754 standard.  The sizes of exponents
and mantissas for various floating point number sizes are as follows:

\begin{center}
\begin{tabular}{l@{~~~~~~}l@{~~~~~~}l@{~~~~~~}r@{~~~~~~}r}
                   &              &              &             & \bf Maximum \\
\bf Floating Point & \bf Exponent & \bf Mantissa & \bf Decimal & \bf Decimal\\
\bf Number Size    & \bf Size     & \bf Size     & \bf Digits  & \bf Exponent
\\[2ex]
16 bits & 5 bits & 10 bits & 3.31 & 4.51 \\
32 bits & 8 bits & 23 bits & 7.22 & 38.23 \\
64 bits & 11 bits & 52 bits & 15.95 & 307.95 \\
128 bits & 15 bits & 112 bits & 34.02 & 4931.77 \\
\end{tabular}
\end{center}

There are also three special floating point values:
\TT{+Inf} denoting positive infinity,
\TT{-Inf} denoting negative infinity,
and \TT{NaN} denoting `\key{not-a-number}' which is a value produced
when, for example, \TT{0} is divided by \TT{0}.
In this document \ttkey{NaN} denotes the particular non-signaling
not-a-number value
produced by arithmetic operations that cannot produce a number.
Floating point variables can store many other not-a-number values.

\subsubsection{Number Conversion Functions}

In the following we specify builtin conversion functions using
function prototypes of the form:
\begin{center}
\tt function $T1$ r = std $F$ ( $T2$ v )
\end{center}
This says that if you apply the function $F$ to the value \TT{v} which
is of type $T2$, the function will return a value \TT{r} of type $T2$.
See \itemref{FUNCTION-PROTOTYPES-AND-CALLS} for more function prototype details.

The following builtin conversion functions are defined:

\begin{indpar}
{\tt function uns$x$~~~r = std \ttkey{uns$x$}~~~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{int$x$}~~~( uns$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{int$x$}~~~( int$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( int$y$ v )} \\
{\tt function float$x$~r = std \ttkey{float$x$}~( float$y$ v )}

for any $x\geq y$ for which the types are builtin
\begin{indpar}
For these conversion functions, no information is lost from
the value when it is converted to the new type.  These conversions
can be \ikey{implied}{implied conversion}.
\end{indpar}

{\tt function uns$x$~~~r = std \ttkey{mod}~~~( uns$y$ v )} \\
{\tt function uns$x$~~~r = std \ttkey{mod}~~~( int$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{mod}~~~( uns$y$ v )} \\
{\tt function int$x$~~~r = std \ttkey{mod}~~~( int$y$ v )}
\ttindex{mod}

for any $x$ and $y$ for which the types are builtin

\begin{indpar}
These functions return a value equal to the argument
modulo $2^x$.
\end{indpar}

{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function uns$x$~~~~~r = std \ttkey{nearest}~~~( float$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function int$x$~~~~~r = std \ttkey{nearest}~~~( float$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( uns$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( int$y$ v )} \\
{\tt function float$x$~~~r = std \ttkey{nearest}~~~( float$y$ v )}
\ttindex{nearest}

for any $x$ and $y$ for which the types are builtin

\begin{indpar}
These functions round the argument to the nearest value (ties to even)
of the result type if the result must have less precision than the argument.
If the value overflows the result type, the result is \TT{+Inf} or \TT{+Inf}
for floating point results, and the largest or smallest possible result
value for integer results.
\end{indpar}

\end{indpar}

Note the difference between \TT{mod} and \TT{nearest} when applied to
integers outside the range of the target type:
\begin{center}
\begin{tabular}{l}
{\tt uns8 ( mod ( 257 ) ) == 1} \\
{\tt uns8 ( nearest ( 257 ) ) == 255} \\
\end{tabular}
\end{center}

Floating point numbers can be converted to integer valued floating point
numbers via:

\begin{indpar}
{\tt function float$x$~~~r = std \ttkey{round}~~~~~( float$x$ v )} \\
{\tt function float$x$~~~r = std \ttkey{ceiling}~~~( float$x$ v )} \\
{\tt function float$x$~~~r = std \ttkey{floor}~~~~~( float$x$ v )}

for any $x$ for which the types are builtin
\begin{indpar}
These functions round to nearest (ties to even),
round up, and round down respectively.
\end{indpar}
\end{indpar}


\subsubsection{Unchecked Number Conversions}

The following \underline{unchecked} conversion functions are defined.
Note that here \TT{*UNCHECKED*} is a qualifier; see \itemref{QUALIFIERS}
for qualifier details.

\begin{indpar}
{\tt function \TT{*UNCHECKED*} uns$x$~~~r =~%
	\ttmkey{uns$x$}{conversion function}~~~( int$x$ v )} \\
{\tt function \TT{*UNCHECKED*} uns$x$~~~r =~%
	\ttmkey{uns$x$}{conversion function}~~~( float$x$ v )} \\
{\tt function \TT{*UNCHECKED*} int$x$~~~r =~%
	\ttmkey{int$x$}{conversion function}~~~( uns$x$ v )} \\
{\tt function \TT{*UNCHECKED*} int$x$~~~r =~%
	\ttmkey{int$x$}{conversion function}~~~( float$x$ v )} \\
{\tt function \TT{*UNCHECKED*} float$x$~r =~%
	\ttmkey{float$x$}{conversion function}~( uns$x$ v )} \\
{\tt function \TT{*UNCHECKED*} float$x$~r =~%
	\ttmkey{float$x$}{conversion function}~( int$x$ v )}

for any $x$ for which the types are builtin
\begin{indpar}
These functions just return the $x$-bit value of \TT{v}
unchanged except for giving it a different type.
\end{indpar}
\end{indpar}

\subsubsection{Number Constants}
\label{NUMBER-CONSTANTS}

A \key{number-constant} is a {\em number} lexeme with specific syntax
that is used to denote a number.  The syntax is:

\begin{indpar}
\emkey{number-constant}\label{NUMBER-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em decimal-constant} \\
    $|$ & {\em binary-constant} \\
    $|$ & {\em hexadecimal-constant} \\
    $|$ & \TT{+Inf}\index{Inf@\TT{+Inf}}
          ~$|$~ \TT{-Inf}\index{Inf@\TT{-Inf}}
          ~$|$~ \ttkey{NaN}
    \end{tabular}
\\[0.5ex]
\emkey{sign} :::= \TT{+} $|$ \TT{-} \\
\emkey{exponent} :::=
	\{ \TT{e} $|$ \TT{E} \} {\em sign}\QMARK{} {\em dit}\PLUS{}
\\[0.5ex]
\emkey{decimal-constant} \begin{tabular}[t]{@{}rl@{}}
                         ::= & {\em decimal-lexeme} \\
			 $|$ & {\em decimal-body-lexeme} ~ {\em exponent} \\
			 $|$ & {\em decimal-constant-prefix} ~
			       {\em decimal-quoted-body} ~
			       {\em exponent}\QMARK{}
			 \end{tabular}
\\[0.5ex]
\emkey{decimal-lexeme} :::= {\em decimal-body-lexeme} ~ {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{decimal-body-lexeme} :::= {\em sign}\QMARK{} ~ {\em decimal-integer} ~
				 {\em decimal-fraction}\QMARK{}
\\[0.5ex]
\emkey{decimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{D}
\\[0.5ex]
\emkey{decimal-quoted-body} :::= \TT{"} {\em decimal-integer} ~
				 {\em decimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{decimal-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em dit}\PLUS{} \\
     $|$ & {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\PLUS{} \\
     $|$ & {\em dit} {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\PLUS{} \\
     $|$ & {\em dit} {\em dit} {\em dit}
           \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\PLUS{} \\
    \end{tabular} \\
\emkey{decimal-fraction} :::= \TT{.} {\em dit}\PLUS{} \\
\emkey{dit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
 \\[0.5ex]
\emkey{binary-constant} ::= {\em binary-constant-prefix} ~
                              {\em binary-quoted-body} ~
			      {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{binary-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{B}
\\[0.5ex]
\emkey{binary-quoted-body} :::= \TT{"} {\em binary-integer} ~
				{\em binary-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{binary-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em bit}\PLUS{} \\
     $|$ & {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\PLUS{} \\
     $|$ & {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\PLUS{} \\
     $|$ & {\em bit} {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\PLUS{} \\
     $|$ & {\em bit} {\em bit} {\em bit} {\em bit}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\PLUS{} \\
    \end{tabular} \\
\emkey{binary-fraction} :::= \TT{.} {\em bit}\PLUS{} \\
\emkey{bit} :::= \TT{0} $|$ \TT{1}
 \\[0.5ex]
\emkey{hexadecimal-constant} ::= \\
\hspace*{0.5in}{\em hexadecimal-constant-prefix} ~
               {\em hexadecimal-quoted-body} ~
	       {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{hexadecimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{B}
\\[0.5ex]
\emkey{hexadecimal-quoted-body} :::= \TT{"} {\em hexadecimal-integer} ~
				     {\em hexadecimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{hexadecimal-integer}
    \begin{tabular}[t]{@{}cl}
    :::= & {\em hit}\PLUS{} \\
     $|$ & {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\PLUS{} \\
     $|$ & {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\PLUS{} \\
     $|$ & {\em hit} {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\PLUS{} \\
     $|$ & {\em hit} {\em hit} {\em hit} {\em hit}
           \{ \TT{,} {\em hit} {\em hit} {\em hit} {\em hit} \}\PLUS{} \\
    \end{tabular} \\
\emkey{hexadecimal-fraction} :::= \TT{.} {\em hit}\PLUS{} \\
\emkey{hit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
	     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
	     $|$ \TT{a} $|$ \TT{b} $|$ \TT{c} $|$ \TT{d} $|$ \TT{e} $|$ \TT{f}
	     $|$ \TT{A} $|$ \TT{B} $|$ \TT{C} $|$ \TT{D} $|$ \TT{E} $|$ \TT{F}
\end{indpar}

The integer part of decimal constants may have commas
every 3 digits, and the integer part of binary and hexadecimal constants
may have commas every 4 digits.
If there is a decimal point, there must be at least one fraction digit.

\TT{NaN} denotes a canonical non-signaling NaN such
at that produced by hardware on the target machine.
\TT{+Inf} denotes positive infinity; \TT{-Inf} denotes negative infinity.

{\em Number-constants} have no type.  They can be converted to
values of number type as follows.

A {\em number-constant} can be implicitly converted to any number
type that can represent the number exactly.

A {\em number-constant} can be implicitly converted to any
floating point number type.  If it is too large, it is converted to
\TT{+Inf}, and if it is too small, it is converted to \TT{-Inf}.
If it cannot be represented exactly, it is rounded (ties to even).

A {\em number-constant} can be explicitly converted to any number
type by the \TT{mod} or \TT{nearest} functions.  It may be explicitly
converted by \TT{uns$x$}, \TT{int$x$}, or \TT{float$x$} functions only
if it may be implicitly converted to the desired type.

{\em Number-constants} are compile time values and can be combined by
the standard operators to produce compile time values
(see \itemref{COMPILE-TIME-EVALUATION}).

\subsection{The Void Type}
\label{THE-VOID-TYPE}

A \ttkey{void} type variable has no value.  No value can be
assigned to such a variable.  Nevertheless such variables have
uses, for example, as base variable in clusters (\pagref{CLUSTERS}).
When used as the base variable of a cluster, an assignment statement
may appear to be assigning a value to a \TT{void} variable, but
in fact it is assigning values to cluster members.

\subsection{Defined Types}
\label{DEFINED-TYPES}

A declaration statement of the following form defines a type by
specifying its {\em type-name}:
\begin{indpar}
\emkey{defined-type-declaration}\label{DEFINED-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
\TT{define type} {\em qualifier-name}\STAR{} {\em defined-type-name}
          \TT{as} {\em base-type-name} \\
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME} \\
\emkey{defined-type-name} ::= {\em type-name} \\
\emkey{base-type-name} ::= {\em type-name} \\
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\end{indpar}

Any {\em qualifiers} in the declaration are attached to every
variable or argument declared to have the defined type (see
section \itemref{QUALIFIERS} for more on {\em qualifiers}).

No {\em type-name} may be a prefix of another {\em type-name}, a
{\em variable-name}, or the first {\em function-term-name} of a 
{\em function-prototype} if that {\em function-term-name} does not
follow an \TT{=} sign or {\em argument-list} in the prototype.
No qualifier name may be a prefix of a type name.
No type name may begin with `\TT{next}'.

A value of a defined type may be converted to or from its base
type by the
\underline{unchecked}
builtin functions:
\begin{indpar}
{\tt function \TT{*UNCHECKED*} $B$ r = $B$ ( $D$ v )} \\
{\tt function \TT{*UNCHECKED*} $D$ r = $D$ ( $B$ v )}

where $B$ is the {\em base-type-name} used to define
the {\em defined-type-name} $D$

\begin{indpar}
These functions do not change the actual value, but merely its
compile-time type.  Using these unchecked conversions,
implied conversions in one direction only
may be defined as desired: see \itemref{IMPLIED-CONVERSION-FUNCTIONS}.
\end{indpar}
\end{indpar}\label{DEFINED-TYPE-UNCHECKED-CONVERSION}


\subsection{Enumeration Values}
\label{Enumeration-VALUES}

An \key{enumeration type} is a defined type whose values are
integers assigned to \skey{enumeration constant}s.
Each enumeration constant is assigned a value during compilation
that is an integer unique relative to all enumeration
constants of its enumeration type that are being compiled together.
Then during linking the enumeration constant is assigned a possibly
different value that is an integer unique relative to all enumeration
constants of its enumeration type that are being linked together.

A declaration statement of the following form defines an \key{enumeration type}
that has enumeration values:
\begin{indpar}
\emkey{enum-type-declaration}\label{ENUM-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
    \TT{define type} {\em qualifier-name}\STAR{}
    \begin{tabular}[t]{@{}l@{}}
    {\em enum-type-name} \TT{as}~~~{\em base-enum-type-name} \\
    \TT{with enum range}~~~{\em enum-range} \\
    \{ \TT{without implied conversion} \}\QMARK \\
    \end{tabular}
\\[0.5ex]
\emkey{base-enum-type-name}
    \begin{tabular}[t]{rl}
    ::= & {\em integer-type-name} \\
    $|$ & {\em enum-direction}\QMARK{}~~~{\em enum-type-name} \\
    \end{tabular} \\
\emkey{enum-direction} ::= \TT{next} $|$ \TT{previous} \\
\emkey{integer-type-name}
    ::= {\em builtin-number-type-name}%
            \,$^{\pagref{BUILTIN-NUMBER-TYPE-NAME}}$ naming an integer type \\
\emkey{enum-range}
    \begin{tabular}[t]{rl}
    ::= & \TT{[} {\em first-enum} \TT{..} {\em last-enum} \TT{]} \\
    $|$ & \TT{[} {\em first-enum} \TT{..} \TT{]} \\
    $|$ & \TT{[} \TT{..} {\em last-enum} \TT{]} \\
    \end{tabular} \\
\emkey{first-enum} ::= {\em compile-time-integer-expression} \\
\emkey{last-enum} ::= {\em compile-time-integer-expression}
\end{indpar}

Here {\em first-enum} and {\em last-enum} are compile time integer
values assigned to the newly defined enum type.
{\em First-enum} must be less than or equal to {\em last-enum}.
If {\em last-enum} is not given, it is assumed to be the maximum
value permitted by the base enumeration type that conforms to the
rules given below.
Similarly if {\em first-enum} is not given, it is assumed to be the minimum
value permitted by the base enumeration type.

Enumeration values can be assigned by declaration statements of the form
\begin{indpar}
\emkey{enum-assignment}
    \begin{tabular}[t]{rl}
    ::= & {\em enum-type-name} ~ {\em constant-name}\TT{ is next enum} \\
    $|$ & {\em enum-type-name} ~ {\em constant-name}\TT{ is previous enum}
    \end{tabular}
\end{indpar}

Within a compilation the compiler assigns the value {\em first-enum}
to the first constant named in a `\TT{next enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in increasing order.
It is an error if `\TT{next~enum}'
would return a value beyond the {\em last-enum} value in a range.

Similarly the compiler assigns the value {\em last-enum}
to the first constant named in a `\TT{previous enum}'
{\em enum-assignment} statement for
the given type, and then for subsequent such statements
assigns values in decreasing order.
It is an error if `\TT{previous~enum}'
would return a value below the {\em first-enum} value in a range.

It is also an error if for a given type the same value is returned
by some \TT{next~enum} and also by some \TT{previous~enum}.

An enumeration type is a defined type with integer base type and
extra apparatus provided by the range which provides a special
mechanism for assigning enumeration type values.
Given an enumeration type $E$ with its base type $B$
the following conversions are defined:
\begin{indpar}
{\tt function ~~~~~~~~~~~ $B$ r = $B$ ( $E$ v )} \\
{\tt function \TT{*UNCHECKED*} $B$ r = $B$ ( $E$ v )} \\
{\tt function \TT{*UNCHECKED*} $E$ r = $E$ ( $B$ v )}
\begin{indpar}
These conversions actually do nothing but change the type of the
value.  The first two have identical effect.  The first is an implied
conversion, and is only defined if the
`\TT{without implied conversion}' option is \underline{not} given in the
enumeration type definition.  The last two conversions are the
\TT{*UNCHECKED*} conversions defined for all enum types.
\end{indpar}
\end{indpar}

If the base type of an enumeration type is a builtin integer type,
the integer value corresponding to {\em first-enum} is {\em first-enum}
itself, and similarly for {\em last-enum}.  Thus the following
example:
\begin{indpar}\begin{verbatim}
define type E as int32 with enum range [1 .. 20]
E C1 = next enum
    // Now int32 (C1) == 1
E C2 = next enum
    // Now int32 (C2) == 2
E C3 = previous enum
    // Now int32 (C3) == 20
E C4 = previous enum
    // Now int32 (C4) == 19
\end{verbatim}\end{indpar}

The \key{underlying type}\label{UNDERLYING-TYPE}
of a type $T$ is $T$ itself if
$T$ is builtin, and is the underlying
type of the base type of $T$ if $T$ is a defined type or an
enumeration type.
Thus every enumeration type $E$ has an underlying integer
type $I$.  As long as the `\TT{without implied conversion}'
option is \underline{not} used, a value of an enumeration type
can always be implicitly converted to a value of its underlying
type.  Thus the following example:
\begin{indpar}\begin{verbatim}
define type D as int32
define type E as D with enum range [1 .. 20]
E C1 = next enum
    // Now int32 (C1) == 1
E C3 = previous enum
    // Now int32 (C3) == 20
\end{verbatim}\end{indpar}

If the base type of an enumeration type is another enumeration type,
the map from values of the first enumeration type to underlying
integer values consists of adding a constant, called the
`\key{enumeration offset}', and the
following are defined, where $I$ is the underlying
integer type of enumeration type $E$:

\begin{indpar}
{\tt function $I$ r = \ttkey{enumeration offset of}~( type E )}
\begin{indpar}
Returns the enumeration offset of \TT{E}.
\end{indpar}
{\tt function $I$ r = \ttkey{range value of}~( $E$ v )}
\begin{indpar}
Returns ~~ {\tt $I$~( v ) - enumeration offset of ( $E$ )}.
\end{indpar}

\end{indpar}

The enumeration offset of an {\em enum-type-name} is more specifically
defined for the following cases:

\begin{indpar}
\begin{itemlist}
\item[\TT{type} {\em qualifier-name}\STAR{} {\em enum-type-name}~~%
    \TT{is}~~{\em builtin-integer-type-name} \ldots{}] ~\\
The enumeration offset of the {\em enum-type-name} equals \TT{0}.
\item[\TT{type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em enum-type-name}~~\TT{is}~~%
              \TT{next}~~{\em base-enum-type-name} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Has the effect of compiling the statements:
\begin{center}
\begin{tabular}{l}
{\em base-enum-type-name} {\tt ~V0~~=~~next enum} \\
{\em base-enum-type-name} {\tt ~V1~~=~~next enum} \\
{\em base-enum-type-name} {\tt ~V2~~=~~next enum} \\
\ldots\ldots\ldots \\
{\em base-enum-type-name} {\tt ~V$n$~~=~~next enum} \\
\end{tabular}
\end{center}
where $n$ = {\em last-enum} - {\em first-enum}.
If $I$ is the underlying integer type of the {\em base-enum-type-name},
and thence also of {\em enum-type-name}, then
\begin{center}
\TT{enumeration offset of (}{\em enum-type-name}\TT{)} \\
{\tt =~$I$(V0)~-~}{\em first-enum}
\end{center}
Therefore if implied conversions are allowed, the first statement of the form
\begin{center}
{\em enum-type-name} \TT{~V~~=~~next enum} \\
\end{center}
compiled after the {\em enum-type-declaration} will make
{\tt $I$(V) == $I$(V0)}, and the first statement of the form
\begin{center}
{\em enum-type-name} \TT{~V~~=~~previous enum} \\
\end{center}
compiled after the {\em enum-type-declaration} will make
{\tt $I$(V) == $I$(V$n$)}.
\item[\TT{type} {\em qualifier-name}\STAR{}]
              \begin{tabular}[t]{@{}l@{}}
              {\em enum-type-name}~~\TT{is}~~%
              \TT{previous}~~{\em enum-type-name} \\
	      \TT{with enum range [}
	         {\em first-enum} \TT{..} {\em last-enum} \TT{]} \ldots{} \\
	      \end{tabular} \\
Ditto with every `\TT{next}' replaced everywhere by `\TT{previous}' and
\begin{center}
\TT{enumeration offset of (}{\em enum-type-name}\TT{)} \\
{\tt =~$I$(V0)~-~}{\em last-enum}
\end{center}
\end{itemlist}
\end{indpar}

The above is examplified by:
\begin{indpar}\begin{verbatim}
define type E1 as int32 with enum range [1 .. 20]
    // Now enumeration offset of (E1) == 0
E1 C1 = previous enum
    // Now range value of (C1) == 20 == int32(C1)
define type E2 as previous E1 with enum range [1 .. 10]
    // Now enumeration offset of (E2) == 9
E2 C2 = next enum 
    // Now range value of (C2) == 1,
    // Now range value of ( E1(C2) ) == 10 = int32(C2)
E2 C3 = previous enum 
    // Now range value of (C3) == 10,
    // Now range value of ( E1(C3) ) == 19 = int32(C3)
define type E3 as next E2 with enum range [1 .. 5]
    // Now enumeration offset of (E3) == 10
E3 C4 = next enum 
    // Now range value of (C4) == 1,
    // range value of ( E2(C4) ) == 2,
    // range value of ( E1(E2(C4)) ) = 11 = int32(C4)
\end{verbatim}\end{indpar}

If $E$ is an enumeration type with underlying
type $I$, the following comparison and subtraction
of values of type $E$ are defined as if implied conversion
of $E$ values to $I$ values were allowed (even if they
are not):

\begin{indpar}
{\tt function bool r = ( $E$ v1 ) "$cop$" ( $E$ v1 )}

where $cop$ is
\ttmkey{<}{of enum values}, \ttmkey{<=}{of enum values},
\ttmkey{==}{of enum values}, \ttmkey{!=}{of enum values},
\ttmkey{>=}{of enum values}, or \ttmkey{>}{of enum values}.
\begin{indpar}
Returns {\tt $I$(v1) "$cop$" $I$(v2)}.
\end{indpar}

{\tt function $I$ r = ( $E$ v1 ) "\ttmkey{-}{of enum values}" ( $E$ v1 )}
\begin{indpar}
Returns {\tt $I$(v1) "-" $I$(v2)}.
\end{indpar}
\end{indpar}

Two enumeration values of different types
may be compared or subtracted if they can be implicitly
converted to a common enumeration or integer type.

The following are builtin enumeration types:
\begin{indpar} \tt
define type~\ttkey{type}~as unswrd with enum [0~..] \\
type~\ttmkey{missing}{type}~is next enum // 0 \\
type~\ttkey{type}~is next enum // 1
\\[1ex]
type~\ttkey{qualifier}~is unswrd with enum [0~..] \\
qualifier~\ttmkey{missing}{qualifier}~is next enum // 0
\\[1ex]
type~\ttkey{bool}\begin{tabular}[t]{@{}l@{}}
                       ~is unswrd with enum [0~..~1] \\
                       ~without implied conversion \\
		       \end{tabular} \\
bool~\ttkey{false}~is next enum // 0 \\
bool~\ttkey{true}~~is next enum // 1
\end{indpar}

Builtin types not mentioned above, such as `\TT{void}' and `\TT{int32}',
are given unspecified (i.e., implementation dependent)
`\TT{type}' enumeration values.
Similarly builtin qualifiers, such as `\TT{mem}', are given
unspecified `\TT{quali\-fier}' enumeration values.  Conversions and
`\TT{range value of}' functions above
can be used to find the integer values associated with any
enumeration constant, but unspecified builtin values may differ from
one compilation or linking to the next.

Enumeration values are assigned within a compilation in
the order that {\em enum-assignments} are compiled.
Enumeration values are assigned during linking according to the order
that modules containing the {\em enum-assignments} are linked.
The link and compile values assigned by an {\em enum-assignment}
may differ.

However, within a compilation module, all assignments to an enumeration type
are done in the same order during linking as during compilation.
Thus values assigned within the same module can be assumed to be
in the same order at compile and link times.  Also,
compile and link values of a given enumeration type
can be assumed to be the same if \underline{all} values
of that enumeration type are assigned in the a single compilation module.

\subsection{Enumeration Sets and Lists}
\label{Enumeration-Sets-And-Lists}

An \key{enumeration set} is a set of enumeration values.
An \key{enumeration list} is a list of enumeration values.  The syntax
for enumeration set and list constants is:
\begin{indpar}
\emkey{enum-set-constant}\label{ENUM-SET-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{~\}} \\
    $|$ &\TT{\{} {\em enum-item}
                   \{ \TT{,} {\em enum-item} \}\STAR{} \TT{\}} \\
    \end{tabular} \\
\emkey{enum-list-constant}\label{ENUM-LIST-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{[~]} \\
    $|$ &\TT{[} {\em enum-item}
                   \{ \TT{,} {\em enum-item} \}\STAR{} \TT{]} \\
    \end{tabular} \\
\emkey{enum-item}
    ::= {\em enum-value} $|$ {\em enum-range} \\
\emkey{enum-range}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em enum-value}~~~\TT{..}~~~{\em enum-value} \\
    $|$ & {\em enum-value}~~~\TT{..} \\
    $|$ & \TT{..}~~~{\em enum-value} \\
    \end{tabular} \\
\emkey{enum-value} ::= {\em compile-time-enum-expression}
\end{indpar}

If the {\em enum-values} in an {\em enum-set-constant} or
{\em enum-list-constant} have different
enumeration types, implied conversions from these to their base types
are inserted until all have the same defined enumeration type,
which is called the
`\key{common enumeration type}'\label{COMMON-ENUMERATION-TYPE}
of the set or list.
This is the most specific least general type to which all the set
or list
values can be converted (see \pagref{CONVERSION-RELATION}).
It is an error
if this cannot be done because some of the types have no implied
conversion defined for them, or if after implict conversion the
common type is not a defined enumeration type.
Note that the common type can be an integer type if all
{\em enum-values} are implicitly convertable to integer values.

An {\em enum-range} designates the two values given and all
values in between.
After implict conversion, the first {\em enum-value} in an {\em enum-range}
must \underline{not} be greater than the second {\em enum-value}
in the {\em enum-range}.  If the first or second {\em enum-value} of
an {\em enum-range} is omitted, it is taken to be the lower or upper
limit of the enumeration type of the non-omitted {\em enum-value}.

The order in which values are given in an {\em enum-set-constant}
does not matter.  Overlapping and adjoining ranges are implictly
combined.\footnote{Internally an enumeration set may be stored as a
sorted list of integers with binary indicators specifying when all
the values between one integer and the next integer are to be included
in the set.}
Thus
\begin{indpar}\begin{verbatim}
define type X as uns8 with enum range [1 .. 20]
X X1 is next enum
X X2 is next enum
. . . . . . . . . .
X X20 is next enum

// Then:
//
//    { X1, X5, X2, X10 .. X16, X19 .. X20, X15 .. X18 }
// == { X1, X2, X5, X10 .. X20 }
\end{verbatim}\end{indpar}

The order in which values are given in an {\em enum-list-constant}
does matter, and ranges are not combined.  Thus in the above
example `\TT{[X1 X2] != [X2 X1]}' and `\TT{[X1 X1] != [X1]}'.

Enumeration set and list values are used in logical expressions that
condition function lookup.  For example,
\begin{indpar}\begin{verbatim}
T v = signed max ( type T, T v1, T v2 )
      [* T is in { int8, int16, int32, int64, int128 } *]:
    . . . . . . . . . . .
\end{verbatim}\end{indpar}

defines a function that takes only signed integer type
arguments, and not unsigned integer type arguments.
The logical expression inside \TT{[*~*]} must be satisfied
for the function definition to match a function call, and
the type argument \TT{T}, which is implied and need not be
given in the function call, must be in the give set of
types, where types are values of the enumeration type `\TT{type}'
(see Section~\itemref{TYPE-VALUES}).

At compile-time
enumeration sets and lists can be stored in variables of enumeration set
or list types, which can be declared by:
\begin{indpar}
\emkey{enum-set-type-declaration}\label{ENUM-SET-TYPE-DECLARATION} ::= \\
\hspace*{0.2in} \TT{define type}
		\begin{tabular}[t]{@{}l@{}}
                {\em qualifier-name}\STAR{} {\em enum-set-type-name} \\
		\TT{as set of } {\em element-enum-type-name}
		\end{tabular}
\\[0.5ex]
\emkey{enum-list-type-declaration}\label{ENUM-LIST-TYPE-DECLARATION} ::= \\
\hspace*{0.2in} \TT{define type}
		\begin{tabular}[t]{@{}l@{}}
                {\em qualifier-name}\STAR{} {\em enum-list-type-name} \\
		\TT{as list of } {\em element-enum-type-name}
		\end{tabular}
\end{indpar}

The information about enumeration set and list types can be determined
at compile-time by:

\begin{indpar}
{\tt function bool r = \ttkey{is enumeration set type} ( type T )}
\begin{indpar}
Returns \TT{true} if {\tt T} is an enumeration set type and \TT{false}
otherwise.
\end{indpar}

{\tt function bool r = \ttkey{is enumeration list type} ( type T )}
\begin{indpar}
Returns \TT{true} if {\tt T} is an enumeration list type and \TT{false}
otherwise.
\end{indpar}

{\tt function type r = \ttkey{element type of} ( type T )}
\begin{indpar}
Returns the element type of an enumeration set or list type {\tt T}.
For a set or list constant, this is the common enumeration type.
\end{indpar}

\end{indpar}

The following are builtin enumeration set types:
\begin{indpar}
{\tt define type~}\ttkey{types}{\tt ~as set of type} \\
{\tt define type~}\ttkey{qualifiers}{\tt ~as set of qualifier}
\end{indpar}

An enumeration set or list constant is an enumeration set or list
whose element type 
is its common enumeration type, even if this enumeration set or list
type has not been
declared and is not builtin.

Given an enumeration set or list type $T1$ with base type $B1$ and
an enumeration set or list type $T2$ with base type $B2$, the following
conversions are defined:
\begin{indpar}
{\tt function ~~~~~~~~~~~ $T2$ r = ( $T1$ v )}
\begin{indpar}
    Defined as an implied conversion \underline{but only if}
    an implied conversion from $B1$ to $B2$ is defined
\end{indpar}
{\tt function \TT{*UNCHECKED*} $T2$ r = ( $T1$ v )}
\begin{indpar}
    Defined as an \TT{*UNCHECKED} explicit conversion \underline{but only if}
    an \TT{*UNCHECKED*} explicit conversion from $B1$ to $B2$ is defined
\end{indpar}
\end{indpar}
A set type can only be converted to a set type, and a list type can
only be converted to a list type.
These conversions actually do nothing but change the type of the
value.

If $S$ is an enumeration set type with element type $E$, the following
functions are defined at compile-time:

\begin{indpar}
{\tt function $S$ r =
    ($S$ v1) "\ttmkey{+}{enumeration set union}" ( $S$ v2 )}
\begin{indpar}
Returns the union of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $S$ r =
    ($S$ v1) "\ttmkey{*}{enumeration set intersection}" ( $S$ v2 )}
\begin{indpar}
Returns the intersection of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $S$ r =
    ($S$ v1) "\ttmkey{-}{enumeration set difference}" ( $S$ v2 )}
\begin{indpar}
Returns the set difference of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function bool r =
    ($E$ e) \ttmkey{is in}{enumeration set} ($S$ s)}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the set {\tt s}, and
\TT{false} otherwise.
\end{indpar}

{\tt function $S$ r =
    ($E$ e) "\ttmkey{+}{enumeration set union}" ($S$ s)}
\begin{indpar}
Returns union of \{{\tt e}\} and {\tt s}.
\end{indpar}

{\tt function $S$ r =
    ($S$ s) "\ttmkey{+}{enumeration set union}" ($E$ e)}
\begin{indpar}
Returns union of \{{\tt e}\} and {\tt s}.
\end{indpar}

{\tt function $S$ r =
    ($S$ s) "\ttmkey{-}{enumeration set union}" ($E$ e)}
\begin{indpar}
Returns the set difference of {\tt s} and \{{\tt e}\}.
\end{indpar}

\end{indpar}

If $L$ is an enumeration list type with element type $E$, the following
functions are defined at compile-time:

\begin{indpar}
{\tt function $L$ r = ($L$ v1)
		    "\ttmkey{+}{enumeration list concatenation}" ($L$ v2)}
\begin{indpar}
Returns the concatenation of {\tt v1} and {\tt v2}.
\end{indpar}

{\tt function $L$ r = ($L$ v1)
                        "\ttmkey{-}{enumeration set difference}" ($L$ v2)}
\begin{indpar}
Returns the list made by removing all elements from {\tt v1} that
appear anywhere in {\tt v2}.
\end{indpar}

{\tt function bool r = ($E$ e)
                        \ttmkey{in}{enumeration list} ($L$ v)}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the list {\tt v}, and
\TT{false} otherwise.
\end{indpar}

{\tt function $L$ r = ($E$ e)
                        "\ttmkey{+}{enumeration list prepend}" ($L$ v)}
\begin{indpar}
Returns the list made by prepending {\tt e} to {\tt v}.
\end{indpar}

{\tt function $L$ r = ($L$ v)
                        "\ttmkey{+}{enumeration list append}" ($E$ e)}
\begin{indpar}
Returns the list made by appending {\tt e} to {\tt v}.
\end{indpar}

{\tt function $L$ r = ($L$ s)
                        "\ttmkey{-}{enumeration list remove}" ($E$ e)}
\begin{indpar}
Returns the list made by removing the all occurences of
{\tt e} in {\tt v}.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time enumeration
set and list variables.  If an implementation does
not implement run-time enumeration set and list variables,
enumeration set and list values computed at compile-time may
not be garbage collectable during the compilation.

\subsection{Type Values}
\label{TYPE-VALUES}

The type `\TT{type}' is a builtin enumeration type declared
by the builtin equivalent of:
\begin{indpar} \tt
define type \ttkey{std type} as unswrd with enum [0~..] \\
type \ttkey{std missing type} is next enum // 0 \\
type \ttkey{std type} is next enum // 1 \\
function std type r = std \ttmkey{missing}{type}: \\
\hspace*{3em}r = std missing type \\
\ttkey{type} \ABV `std type'
\end{indpar}
Each type is associated with a unique enumeration value
of type `\TT{type}', and this value can be used at both
compile and run time to test whether two `\TT{type}'s are
equal.

New types are declared by statements of the form:
\begin{center}
\tt define type {\em type-name} \ldots{}
\end{center}
The {\em type-name} of a type can be used (1) before a {\em variable-name}
in a declaration, (2) as the name of an enumeration value in an
expression, or (3) as the name of a function in a {\em function-call}.

Values of one type $T1$ can be converted implicitly to another
type $T2$ if and only if an inline function with prototype:
\begin{indpar}
{\tt function Q $T2$ r = ( qualifiers Q, Q $T1$ v )}
\end{indpar}
is defined.  In this case we say the $T1$ is \mkey{more specific}{types}
than $T2$, or $T2$ is \mkey{more general}{types} than $T1$, or
\begin{center}
{\tt $T1~~\CNV~~T2$}
\end{center}%
\label{CONVERSION-RELATION}

The transitive closure of the $\CNV$ relation between types is
required to be a partial order,
or equivalently, the directed graph whose nodes are types
which has an edge from $T1$ to
$T2$ if and only if \TT{$T1~\CNV~T2$} is required to be acyclic.
In addition, two different paths from one type to another are
required to produce the same result.  For example:
\begin{indpar}\begin{verbatim}
int16 v1 = ...
int32 v2 = v1
float64 v3 = v2
float64 v4 = v1
// Given the two implied conversion paths v1 ---> v2 ---> v3
// and v1 ---> v4, necessarily v3 == v4.
\end{verbatim}\end{indpar}

If for a set of types $\{T1,T2,\ldots\}$ there is a unique
type $T$ such that $T1\TCNV T$, $T2\TCNV T$, \ldots{}, where
$\TCNV$ is the transitive closure of $\CNV$, then
$T$ is called the `\key{least upper bound}'\label{LEAST-UPPER-BOUND}
of the set of types.

Functions can be overloaded based on the number and types
of their arguments and also on the values of arguments that
are known at compile time.  Thus different functions with
the common prototype
\begin{center}
{\tt function unsadr r = size of ( type T )}
\end{center}
may be defined for different values of {\tt T}.  
With this in mind, the following compile-time builtin functions may be
defined automatically:

\begin{indpar}
{\tt function type r = \ttkey{base type of} ( type T )}
\begin{indpar}
Returns the base type of the type {\tt T}.  For enumeration
types this is the associated base type from the defined type's
declaration.  For builtin types, it is
{\tt T} itself.
\end{indpar}

{\tt function type r = \ttkey{underlying type of} ( type T )}
\begin{indpar}
Returns {\tt T} if {\tt T} is a builtin type.
Otherwise if {\tt T} is a defined or enumeration type,
\begin{center}
\TT{underlying type of ( base type of ( T ) )}
\end{center}
is returned.  See \pagref{UNDERLYING-TYPE}.
\end{indpar}

{\tt function unsadr r = \ttkey{size of} ( type T )}
\begin{indpar}
Returns the number of bytes in a value of type {\tt T}.
For defined types it is the size of their underlying type
(the size of \TT{void} is \TT{0}).
\end{indpar}

{\tt function unsadr r = \ttkey{alignment of} ( type T )}
\begin{indpar}
Returns the alignment of {\tt T}, a strictly positive integer.
The address of a value of type {\tt T} in RAM should
optimally be a multiple of the alignment.
The alignment of builtin types is their size.
For defined types it is the alignment of their underlying type.
\end{indpar}

{\tt function T r = \ttkey{min of} ( type T )} \\
{\tt function T r = \ttkey{max of} ( type T )}
\begin{indpar}
Returns the minimum or maximum value of a type {\tt T}.
These are defined only for number types and enumeration types,
and for enumeration types the values returned are the limits of
the type's {\em enum-range}.
\end{indpar}

{\tt function T r = \ttkey{min unassigned of} ( type T )} \\
{\tt function T r = \ttkey{max unassigned of} ( type T )}
\begin{indpar}
Returns the minimum or maximum values not yet assigned to an
enumeration type {\tt T} by an {\em enum-assignment}.  Values
assigned by unchecked conversions are not considered.  If
no values have been assigned, the enumeration value corresponding
to {\em first-enum} is returned by `\TT{min unassigned of}'
and the enumeration value corresponding
to {\em last-enum} is returned by `\TT{max unassigned of}'.

These are defined only for enumeration types,

These values may change when more code is compiled or linked.
You may only assume that constants of type {\tt T} whose values have
already been compiled or linked are within
ranges bounded by these values, i.e., in the ranges:
\begin{center}
{\tt [ min of (T), min unassigned of (T) )} \\
{\tt ( max unassigned of (T), max of (T) ]}
\end{center}
\end{indpar}

{\tt function T r = \ttkey{missing value of} ( type T )}
\begin{indpar}
Returns a suitable missing value for type {\tt T}.
Defined to return the largest possible value for builtin unsigned
integer types, the smallest (most negative) possible value for
builtin signed integer types, and \TT{NaN} for builtin
floating point number types.
May be defined by user for defined types.
\end{indpar}

{\tt function T r = \ttkey{default value of} ( type T )}
\begin{indpar}
Returns a suitable default value for type {\tt T}.
Defined to return \TT{0} for builtin number types.
May be defined by user for defined types.  For use by allocators,
such as a user defined function that allocates a vector whose
elements are of type {\tt T}, and the function wishes to give the elements an
initial default value.
\end{indpar}

{\tt function bool r = ( type T1 ) "\ttkey{>}" ( type T2 )}
\begin{indpar}
Returns \TT{true} if and only if {\tt T1 > T2} in the sense that values
of type {\tt T1} can be implicitly converted to values of type {\tt T2}
(see \pagref{CONVERSION-RELATION}).
\end{indpar}

\end{indpar}

\subsection{The Character Type}
\label{THE-CHARACTER-TYPE}

A `\key{character}' is a 32-bit UNICODE character.  It is
defined as the derived type:
\begin{indpar} \tt
define type~\ttkey{std character}~as uns32 \\
\ttkey{character}~\ABV~`std character'
\end{indpar}

A character constant has the syntax:
\begin{indpar}
\emkey{character-constant}\label{CHARACTER-CONSTANT}
    :::= \TT{C"}{\em character-representative}\TT{"} \\
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}

This constant has type \TT{character} and value equal to the
single character represented.

The following functions are builtin:

\begin{indpar}

{\tt function character r = std \ttkey{character} ( uns32 c )}
\begin{indpar}
Returns the character with UNICODE character code equal to {\tt c}.
No check is made that {\tt c} is a legal UNICODE character code
or is non-zero.
\end{indpar}

{\tt function uns32 r = std \ttkey{code} ( character c )}
\begin{indpar}
Returns the UNICODE character code of the character {\tt c}.
\end{indpar}

{\tt function QS uns32 r = std ( qualifiers QS, QS \ttkey{character} c )}
\begin{indpar}
Implied conversion (\pagref{IMPLIED-CONVERSION-FUNCTIONS})
of character {\tt c} to its UNICODE character code.

Because of this implied conversion,
characters can be compared using \TT{<}, \TT{<=}, \TT{==},
\TT{!=}, \TT{>=}, or \TT{>}.
\end{indpar}

{\tt function character r = std \ttmkey{NUL}{character value}}
\begin{indpar}
Returns \TT{C"<0>"},
the character with UNICODE code \TT{0} that is conventionally
used to represent the missing \TT{character} value.
\end{indpar}

\end{indpar}

\subsection{The String Type}
\label{THE-STRING-TYPE}

A `\key{string}' is a vector of characters, that is,
of 32-bit UNICODE characters.
It is defined as a derived type:
\begin{indpar} \tt
define type \ttkey{std string} as adr \\
\ttkey{string} \ABV `std string'
\end{indpar}

A {\em quoted-string} lexeme is a constant of \TT{string} type
whose characters are those represented by the lexeme with
the addition of a \TT{NUL} character (code \TT{0}) at the end:
\begin{indpar}
\emkey{string-constant}\label{STRING-CONSTANT}
    :::= \TT{"}{\em character-representative}\TT{"} \\
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}


Strings are read-only, and their characters cannot be changed.

String variables and values are implemented at compile-time.
The following are compile-time functions involving strings:

\begin{indpar}

{\tt function string r =
    std \ttmkey{string}{of character} ( character c )}
\begin{indpar}
Returns the string containing the single character {\tt c}.
\end{indpar}

{\tt function string r =
    std \ttmkey{string}{of integer} ( int128 i )}
\begin{indpar}
Returns the string that is the decimal integer representation of
the integer {\tt i}.  The value returned contains no high order
zeros.  Non-negative values have no sign.
\end{indpar}

{\tt function string r =
    std ( string s1 ) "\ttmkey{+}{of strings}" ( string s2 )}
\begin{indpar}
Returns the concatenation of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function bool r =
    std ( string s1 ) "\ttmkey{==}{of strings}" ( string s2 )} \\
{\tt function bool r =
    std ( string s1 ) "\ttmkey{!=}{of strings}" ( string s2 )}
\begin{indpar}
Returns whether {\tt s1} and {\tt s2} are equal or not.
\end{indpar}

{\tt function string r = std \ttmkey{null}{string value}}
\begin{indpar}
Returns a particular zero length \TT{string} that is conventionally
used to represent the missing \TT{string} value.
Although the string is of zero length, it does have one character:
the \TT{NUL} character at its end.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{string} ( string s )}
\begin{indpar}
Returns the length of {\tt s}, the number of characters in {\tt s}
\underline{not counting} the \TT{NUL} character at the end.
\end{indpar}

{\tt function character r = std ( string s ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st character of {\tt s}.

It is a programming error if {\tt i > length of ( s )}.

If {\tt i == length of ( s )}
the \TT{NUL} at the end of the string is returned.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time string
variables.  If an implementation does
not implement run-time string variables,
string values computed at compile-time may
not be garbage collectable during the compilation.

\subsection{The Name Type}
\label{THE-NAME-TYPE}

A `\key{name}' value is a vector of strings.  If the value is
a legal name as defined in Section~\itemref{NAMES}, the
strings are its {\em name-items} with a \TT{null} string appended.
Note that {\em natural-number} {\em name-items} are represented
by strings of digits and not by integers.

The \TT{name} type is is defined as a derived type:
\begin{indpar} \tt
define type \ttkey{std name} as adr \\
\ttkey{name} \ABV `std name'
\end{indpar}

A sequence of {\em name-items} in \TT{`~'} quotes is a \TT{name}
constant whose strings are the {\em name-items}
with the \TT{null} string appended:
\begin{indpar}
\emkey{name-constant}\label{NAME-CONSTANT}
    ::= \TT{`}{\em name-item}\STAR{}\TT{'} \\
{\em name-item} ::= see \pagref{NAME-ITEM}
\end{indpar}

Name values are read-only, and their elements cannot be changed.

Name variables and values are implemented at compile-time.
The following are compile-time functions involving names:

\begin{indpar}

{\tt function name r = \ttmkey{name}{of string} ( string s )}
\begin{indpar}
Returns the name containing just {\tt s} as its only {\em name-item}.
A \TT{null} is appended to the end of the name.
No check is made that {\tt s} is a legal {\em name-item}.
\end{indpar}

{\tt function name r = ( name n1 ) "\ttmkey{+}{of names}" ( name n2 )}
\begin{indpar}
Returns the concatenation of {\tt n1} and {\tt n2}.
\end{indpar}

{\tt function bool r = ( name n1 ) "\ttmkey{==}{of names}" ( name n2 )} \\
{\tt function bool r = ( name n1 ) "\ttmkey{!=}{of names}" ( name n2 )}
\begin{indpar}
Returns whether {\tt n1} and {\tt n2} are equal or not.
\end{indpar}

{\tt function name r = std \ttmkey{null}{name value}}
\begin{indpar}
Returns a particular zero length \TT{name} that is conventionally
used to represent the missing \TT{name} value.
Although the name is of zero length, it does have one string,
the \TT{null} string at its end.
\end{indpar}

{\tt function unswrd r = std \ttmkey{length of}{name} ( name n )}
\begin{indpar}
Returns the length of {\tt n}, the number of strings in {\tt n}
\underline{not counting} the \TT{null} string at the end.
\end{indpar}

{\tt function string r = std ( name n ) \TT{[} unswrd i \TT{]}}%
\ttmindex{[]}{of string}
\begin{indpar}
Returns the {\tt i+1}'st string of {\tt n}.

It is a programming error if {\tt i > length of ( n )}.

If {\tt i == length of ( n )}
the \TT{null} at the end of the name is returned.
\end{indpar}

\end{indpar}

An implementation is not required to implement run-time name
variables.  If an implementation does
not implement run-time name variables,
name values computed at compile-time may
not be garbage collectable during the compilation.

\subsection{Name Sets and Lists}
\label{NAME-SETS-AND-LISTS}

An \key{name set} is a set of names.
An \key{name list} is a list of names.  The syntax
for name set and list constants is:
\begin{indpar}
\emkey{name-set-constant}\label{NAME-SET-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{\{~\}} \\
    $|$ &\TT{\{} {\em name-value}
                   \{ \TT{,} {\em name-value} \}\STAR{} \TT{\}} \\
    \end{tabular} \\
\emkey{name-list-constant}\label{NAME-LIST-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= &\TT{[~]} \\
    $|$ &\TT{[} {\em name-value}
                   \{ \TT{,} {\em name-value} \}\STAR{} \TT{]} \\
    \end{tabular} \\
\emkey{name-value} ::= {\em compile-time-name-expression}
\end{indpar}

The order in which names are given in a {\em name-set-constant}
does not matter, and duplicate names in the set are eliminated.
Thus
\begin{center}
`\TT{\{`X1' `X2'\} = \{`X2 `X1'\}}'\\
and\\
`\TT{\{`X1' `X1'\} = \{`X1'\}}'.
\end{center}

The order in which values are given in an {\em name-list-constant}
does matter, and duplicates are not combined.
Thus
\begin{center}
`\TT{[`X1' `X2'] != [`X2 `X1']}'\\
and\\
`\TT{[`X1' `X1'] != [`X1']}'.
\end{center}

Name set and list values are used in code expansions.
For example,
\begin{indpar}\begin{verbatim}
include for n in [`x[1]', `x[2]', `x[3]' ]:
    int n = 0
\end{verbatim}\end{indpar}

Name sets and lists can be stored in variables of the builtin name set
or list types:
\begin{indpar}
{\tt define type \ttkey{name set} is adr} \\
{\tt define type \ttkey{name list} is adr}
\end{indpar}

The following \TT{name set} functions are buitin:

\begin{indpar}
{\tt function name set r = (name set s1)
                        "\ttmkey{+}{name set union}" ( name set s2 )}
\begin{indpar}
Returns the union of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function name set r = ( name set s1 )
                        "\ttmkey{*}{name set intersection}" ( name set s2 )}
\begin{indpar}
Returns the intersection of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function name set r = ( name set s1 )
                        "\ttmkey{-}{name set difference}" ( name set s2 )}
\begin{indpar}
Returns the set difference of {\tt s1} and {\tt s2}.
\end{indpar}

{\tt function bool r = (name e) \ttmkey{in}{name set} ( name set s )}
\begin{indpar}
Returns \TT{true} if {\tt e} is an element of the set {\tt s}, and
\TT{false} otherwise.
\end{indpar}

{\tt function name set r = (name n) "\ttmkey{+}{name set union}" ( name set s )}
\begin{indpar}
Returns union of \{{\tt n}\} and {\tt s}.
\end{indpar}

{\tt function name set r = ( name set s )
                        "\ttmkey{+}{name set union}" (name n)}
\begin{indpar}
Returns union of \{{\tt n}\} and {\tt s}.
\end{indpar}

{\tt function name set r = ( name set s )
                        "\ttmkey{-}{name set union}" (name n)}
\begin{indpar}
Returns the set difference of {\tt s} and \{{\tt n}\}.
\end{indpar}

\end{indpar}

The following \TT{name list} functions are buitin:

\begin{indpar}
{\tt function name list r = (name list ls1)
		    "\ttmkey{+}{name list concatenation}" (name list ls2)}
\begin{indpar}
Returns the concatenation of {\tt ls1} and {\tt ls2}.
\end{indpar}

{\tt function name list r = (name list ls1)
                        "\ttmkey{-}{name list difference}" (name list ls2)}
\begin{indpar}
Returns the list made by removing all elements from {\tt ls1} that
appear anywhere in {\tt ls2}.
\end{indpar}

{\tt function bool r = (name n) \ttmkey{in}{name list} (name list ls)}
\begin{indpar}
Returns \TT{true} if {\tt n} is an element of the list {\tt ls}, and
\TT{false} otherwise.
\end{indpar}

{\tt function name list r = (name n)
                        "\ttmkey{+}{name list prepend}" (name list ls)}
\begin{indpar}
Returns the list made by prepending {\tt n} to {\tt ls}.
\end{indpar}

{\tt function name list r = (name list ls)
                        "\ttmkey{+}{name list append}" (name n)}
\begin{indpar}
Returns the list made by appending {\tt n} to {\tt ls}.
\end{indpar}

{\tt function name list r = (name list s)
                        "\ttmkey{-}{name list remove}" (name n)}
\begin{indpar}
Returns the list made by removing the all occurences of
{\tt n} in {\tt ls}.
\end{indpar}

\end{indpar}


\section{Qualifiers}
\label{QUALIFIERS}

Variables may be qualified by \skey{qualifier}s, which preceed the
type when a variable is declared.  There are four builtin qualifiers
described in Section~\itemref{BUILTIN-QUALIFIERS} that have special
effects: \TT{mem}, \TT{stack}, \TT{*UNCHECKED*}, and \TT{global}.
There is also a builtin method for defining trace qualifiers which
have special effects.
Other qualifiers that have no special effects
may be defined, and are typically used to add an
additional layer of type checking that is somewhat orthogonal to
types.

Syntactically {\em qualifier-names} immediately preceed the {\em type-names}
that are before {\em variable-names}.  Some introductory examples are:
\begin{indpar}\begin{verbatim}
required qualifier fee
prohibited qualifier fie
function int32 result = F ( fee int32 value ):
    // Declares function F that computes a result of type
    // int32 from a value of type int32 and qualifier fee.
    // Requires call argument to have qualifier fee, but
    // prohibits the argument from having qualifier fie.
    //
    ... [Function body omitted] ...

// Example usage:
//
int32 x1 = ...
fee int32 x2 = ...
fie int32 x3 = ...
int32 y1 = F ( x1 )          // Illegal; x1 does not have
                             // required fee.
int32 y2 = F ( x2 )          // Legal; x2 has required fee.
int32 y3 = F ( x3 )          // Illegal; x3 has prohibited
                             // fie.
fee int32 y4 = x1            // Illegal; x1 does not have
                             // required fee.
fee int32 y5 = x2            // Legal; x2 has required fee.
int32 y6 = x3                // Illegal; x3 has prohibited
                             // fie but y6 does not.
fie int32 y7 = x3            // Legal; x3 has prohibited
                             // fie but so does y7.

protected required qualifier foo
function fo int32 result = G ( int32 value ):
    // Declares function G that computes a result of type
    // int32 from a value of type int32.  Attaches fo, which
    // is protected, to the result.
    //
    ... [Function body omitted] ...

function int32 result = H ( fo int32 value ):
    ... [Function body omitted] ...

fee int32 z1 = G ( x1 )      // Legal; z1 also acquires fo.
fee int32 z2 = H ( z1 )      // Legal; z1 has implied
                             // qualifier fo.
fo  int32 z3 = F ( x1 )      // Illegal; fo is protected, and
                             // F does not have fo on its
                             // prototype result variable.
fo  int32 z4 = G ( x1 )      // Legal; G gives z4 the
                             // protected fo qualifier so its
                             // OK for z4 to have that
                             // qualifier explicitly.

fo  int32 z5 = x1            // Illegal, x1 does NOT have
                             // protected qualifier fo.
fo  int32 z6 = y7            // Legal, y7 has protected
                             // qualifier fo.
int32 z7 = y7                // Legal, y7 has protected
                             // qualifier fo, so z7
                             // acquires fo.
\end{verbatim}\end{indpar}

The qualifiers may be declared by:
\begin{indpar}
\emkey{qualifier-declaration}\label{QUALIFIER-DECLARATION} \\
\hspace*{0.5in}
    \begin{tabular}[t]{rl}
    ::= & \TT{define} {\em qualifier-attribute}\PLUS{} \ttkey{qualifier}
           {\em defined-qualifier-name} \\
    $|$ & {\em trace-qualifier-declaration}
    	  ~~~ [see \pagref{TRACE-QUALIFIERS}]
    \end{tabular} \\
\emkey{qualifier-attribute}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{required} \\
    $|$ & \ttkey{prohibited} \\
    $|$ & \ttkey{protected} \\
    $|$ & \ttkey{inherited} \\
    \end{tabular} \\
\emkey{defined-qualifier-name} ::= {\em qualifier-name} \\
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME}

where
\begin{enumerate}
\item
No {\em qualifier-name} may be a prefix of another {\em qualifier-name},
or of any {\em type-name}, or of any {\em initial-function-term-name}.
\item
No qualifier name may begin with `\TT{next}'
or `\TT{previous}'.
\end{enumerate}
\end{indpar}

If a function prototype variable (argument or result) has
a \key{required qualifier}, any call variable matched to this
prototype variable must have the required qualifier.

If a function prototype variable (argument or result)
does \underline{not}
have a \key{prohibited qualifier}, any call variable matched to this
prototype variable must \underline{not} have the prohibited qualifier.

A qualifier \underline{must} be required or prohibited or both.
Given a function prototype variable with a qualifier that is
both required and prohibited,
a matching call variable must always have the qualifier,
and given a function prototype variable without such a qualifier,
a matching call variable must never have the qualifier.

If a function prototype result variable has a \key{protected
qualifier}, any call variable matched to this
prototype variable will be given the protected qualifier
(if it does not already have it).  Furthermore, no variable
may have a protected qualifier unless it is matched to
a function result variable with the qualifier.

In the above example, 
any call variable matched to the argument of {\tt F}
must have the `{\tt fie}' qualifier, which is required.
Any call variable matched to the argument of {\tt G}
must \underline{not} have the `{\tt fo}' qualifier, which is prohibited.
The `{\tt fo}' qualifier can only be placed on a variable that is
the result of a function like {\tt G} which attaches it to its result,
as `{\tt fo}' is protected.  `{\tt fee}' and `{\tt fie}' can be attached
to any variable, as they are \underline{not} protected.

Inherited qualifiers affect cluster variables and their behavior is
specified on page~\pageref{INHERITED-QUALIFIER}. 

The builtin qualifiers are in effect declared by:
\begin{indpar}
{\tt protected~qualifier~}\ttkey{mem} \\
{\tt prohibited~protected~inherited~qualifier~}\ttkey{stack} \\
{\tt required qualifier~}\ttkey{*UNCHECKED*} \\
{\tt protected~inherited~qualifier~}\ttkey{global}
\end{indpar}

The type `\TT{qualifier}' is a builtin enumeration type declared
by:
\begin{indpar} \tt
define type \ttkey{std qualifier} as unswrd with enum [0~..] \\
qualifier \ttkey{std missing qualifier} is next enum // 0 \\
function std qualifier r = std \ttmkey{missing}{qualifier}: \\
\hspace*{3em}r = std missing qualifier \\
\ttkey{qualifier} \ABV `std qualifier'
\end{indpar}
Each qualifier is associated with a unique enumeration value
of type `\TT{qualifier}', and this value can be used at both
compile and run time to test whether two `\TT{qualifier}'s are
equal.

The {\em qualifier-name} of a qualifier
can be used (1) before a {\em type-name}
in a declaration, (2) as the name of an enumeration value in an
expression, or (3) as the name of a function in a {\em function-call}.


\section{Conversions}
\label{CONVERSIONS}

Conversions of a value of one data type $T1$ to a value of another
data type $T2$ play a very important role in a typed language.
For example:
\begin{indpar}\begin{verbatim}
int64 x = y + 1,000 * z
    // Compiles to:
    //   int64 T$1 = y            // Conversion
    //   int64 T$2 = 1,000        // Conversion
    //   int64 T$3 = z            // Conversion
    //   int64 T$4 = T$2 "*" T$3  // Function call (of "*")
    //   int64 x = T$1 "+" T$4    // Function call (of "+")
\end{verbatim}\end{indpar}

Here the {\tt T\$\ldots} variables are temporary variables
introduced by the compiler, and {\tt int64} is the type
of these because being the type of {\tt x} it becomes the
`target type' of the expression and its subexpressions
(see \itemref{EXPRESSION-TYPING} for more on target types).

An \key{implied conversion} is a simple assignment statement whose
right side is a variable or a constant.

\subsection{Implied Conversion Functions}
\label{IMPLIED-CONVERSION-FUNCTIONS}

Implied conversions are defined by function prototypes of the form:
\begin{center} \tt
function \ldots{}~$T2$ r = ( \ldots{}~$T1$ v )
\end{center}
where `\ldots{}' denotes information about qualifiers.

An implied conversion function that copies qualifiers from the
argument has the form:
\begin{center} \tt
function Qs $T2$ r = (qualifiers Qs, Qs $T1$ v )
\end{center}

Here the {\tt Qs} argument may be implied as the list of
qualifiers of the actual argument.

Implied conversion functions are only called by implied conversions, that
is, by simple assignment statements whose right side is
a variable or constant.  The parentheses that would normally
surround the {\em function-call} argument may be omitted
in this case.

\subsection{The Conversion Graph}
\label{THE-CONVERSION-GRAPH}

An ordering is induced on types by implied conversions.  Let
$T1\CNV T2$ mean that there is an implied conversion from
values of type $T1$ to values of type $T2$.  Let $T1~\TCNV~T2$
be the transitive closure of $T1\CNV T2$, which means
that a value of type $T1$ may be converted to a value
of type $T2$ by applying zero or more implied conversions.
Then we \underline{require}
that $T1\TCNV T2$ be a partial order, which means that:
\begin{itemize}
\item $\TCNV$ is reflexive: $T1\TCNV T1$.
\item $\TCNV$ is transitive: $T1\TCNV T2$ and $T2\TCNV T3$
imply that $T1\TCNV T3$.
\item $\TCNV$ is anti-symmetric:
$T1\TCNV T2$ and $T2\TCNV T1$
imply that $T1 = T2$.
\end{itemize}

Importantly, the anti-symmetric rules \underline{requires} that
if values of type $T1$ can be implicitly converted to
values of a different type type $T2$, then values of type $T2$
\underline{cannot} be implicitly converted to values of type $T1$.

It is a compiler error for an implicit conversion function
prototype to cause $\TCNV$ to violate the anti-symmetric rule.

We define the \key{implied conversion graph} to be the directed
graph whose nodes are types and which has an arrow from $T1$ to
$T2$ if and only if $T1\CNV T2$.
Or equivalently, there is an implied conversion function defined
whose argument is of type $T1$ and whose result is of type $T2$.
Then $T1\TCNV T2$ if and only if there is a (possibly zero size)
path in this graph from $T1$ to $T2$.

It is a good idea if that all paths
from $T1$ to $T2$ give the same result, though we do not require
this.
This means, for example, that
if one can implicitly convert a $T1$ value directly to
either a $T2$ or $T3$ value, and one can implicitly convert
a $T2$ value to a $T3$ value, then converting a $T1$ value
to a $T2$ value and then converting that to a $T3$ value
must give the same resulting value as converting the $T1$ value
directly to a $T3$ value.

Various builtin implied conversions are described
in this document.

Note that $T1\CNV T2$ does \underline{not} imply that every
value of type $T1$ can be fully represented by a value of type
$T2$.  For example, an implied conversion $T1\CNV bool$
might be introduced to map all non-missing $T1$ values to \TT{true}
and any missing $T1$ value to \TT{false}.

\subsection{Qualifier Conversions}
\label{QUALIFIER-CONVERSIONS}

A simple assignment statement with variable or constant right
side that has the same type as the result variable on the left
side is a \key{qualifier conversion}.  These are builtin and
obey the following rules:

\begin{enumerate}
\item If there is a protected qualifier $Q$ on the right side, it
is automatically added to the left side.
\item If there is a required qualifier $Q$ on the left side, it
must also be on the right side.
\item If there is a prohibited qualifier $Q$ not on the left side, it
must also not be on the right side.
\end{enumerate}

Note that constants are considered to not have any qualifiers.
Also the case where the qualifiers and both side are the same,
as well as the types, is considered to be a `qualifier conversion'
even though nothing is actually converted.


\subsection{Explicit Conversions}
\label{EXPLICIT-CONVERSIONS}

In addition to implied conversions there are `\skey{explicit conversion}s'
defined by function prototypes of the form:
\begin{center} \tt
function \ldots{}~$T2$ r = $T2$ ( \ldots{}~$T1$ v )
\end{center}
where `\ldots{}' denotes information about qualifiers.
Here $T2$ is used as the name of a function that performs the
conversion.

A type $T2$ may be implicitly convertable to type $T1$ while
$T1$ is explicitly convertable to $T2$.

\section{Expressions}
\label{EXPRESSIONS}

Expressions compute values and appear inside statements where a value is needed.
For example, in a {\em simple-assignment-statement} of the form
\begin{indpar}
{\em qualifier-name}\STAR{} ~ {\em type-name} ~ {\em variable-name}
	~ {\tt =} ~ {\em expression}
\end{indpar}
the {\em expression} computes a value to store in the variable.

The parser parses {\em expressions} and converts code into statements
that have no {\em expressions} except for {\em variable-names}
and for {\em function-calls} in statements of the form
\begin{indpar}
\ldots{} ~ {\tt =} ~{\em function-call}
\end{indpar}
where \ldots{} is an optional list of result variables for the
{\em function-call}.

\subsection{Variable Names}

A {\em variable-name} names a variable that is allocated to
the current function frame by an {\em assignment-statement}.
The syntax is:

\begin{indpar}
\emkey{variable-name}
	::= {\em variable-base-name} {\em member-selector}\STAR{} \\
\emkey{variable-base-name}
	::= {\em name} not containing a `\TT{.}',
			 {\em quoted-mark}, or {\em quoted-separator} \\
\emkey{member-selector} ::= {\em member-name} $|$ {\em member-subscript } \\
\emkey{member-name}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark}
			    or {\em quoted-separator}
			\end{tabular} \\
\emkey{member-subscript}\label{MEMBER-SUBSCRIPT}
    ::= {\em enum-list-constant} \\
{\em enum-list-constant} ::= see \pagref{ENUM-LIST-CONSTANT} \\
{\em name} ::= see \pagref{NAME}
\end{indpar}

Some examples that use {\em member-subscripts} are:\label{SLICE}
\begin{indpar}\begin{verbatim}
uns8 string[0 .. 5] = .....   // Allocate slice.
..... string[0] .....         // Read one variable of slice.
..... string[1 .. 5] .....    // Read subslice of slice.
..... string[0 .. 3] .....    // Read a different subslice.
\end{verbatim}\end{indpar}

One can also assemble slices into a larger slice.  For example:
\begin{indpar}\begin{verbatim}
float64 m[0 .. 1, 0 .. 1 ] = .....   // Allocate slice.
float64 m[2 .. 6, 0 .. 1 ] = .....   // Allocate slice.
float64 m[0 .. 6, 2 .. 4 ] = .....   // Allocate slice.
..... m[0 .. 6, 0 .. 4] .....        // Read assembled slice.
\end{verbatim}\end{indpar}

\subsection{Expression Syntax}

The operators that can appear in an expression in approximate
precedence order (lowest precedence first) are:

\begin{center}

\begin{tabular}{c}
\TT{if ~ else} \\
selection operators
\end{tabular}

\medskip

\begin{tabular}{c}
\TT{and ~ or} \\
\TT{not} \\
logical operators
\end{tabular}

\medskip

\begin{tabular}{c}
\TT{== ~ != ~ > ~ >= ~ < ~ <=} \\
comparison operators
\end{tabular}

\medskip

\begin{tabular}[t]{c}
\TT{+ ~ -} \\
summation operators
\\[2ex]
\TT{* ~ / ~ div ~ mod ~ rem } \\
product operators
\\[2ex]
\TT{\textasciicircum} \\
exponent operator
\end{tabular}
~~~~~
\begin{tabular}[t]{c}
\TT{\& ~ | ~ xor ~ <{}< ~ >{}>} \\
\TT{!} \\
bitwise operators
\end{tabular}

\end{center}

\begin{indpar}

However precedence is only a rough guide to the syntax of L-Language
operators.  Also there is no unary \TT{-} operator.

Two operators are said to be mixed in an expression if neither is
inside a parenthesized subexpression that does not contain the other.
The logical operators other than `\TT{not}' cannot be mixed with
each other, and similarly for the product operators and the
bitwise operators other than \TT{!} (bitwise complement).  Bitwise
operators cannot be mixed with summation and product operators.

The precise syntax of expressions is:

\emkey{expression}\label{EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em selection-expression} \\
    $|$ & {\em logical-expression} \\
    $|$ & {\em comparison-expression} \\
    $|$ & {\em bitop-expression} \\
    $|$ & {\em summation-expression} \\
    $|$ & {\em product-expression} \\
    $|$ & {\em exponent-expression} \\
    $|$ & {\em data-expression} \\
    $|$ & {\em subexpression} \\
    \end{tabular}
\\[0.5ex]
\emkey{selection-expression}\label{SELECTION-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em selection-operand} \TT{if} {\em logical-expression} \TT{else} \\
	& ~~~~~ \{ {\em selection-operand} \TT{if} {\em logical-expression}
	           \TT{else} \}\STAR{} \\
	& ~~~~~ {\em selection-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{selection-operand}\label{SELECTION-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-expression} $|$ {\em summation-expression}
                                 $|$ {\em product-expression} \\
    $|$ & {\em exponent-expression} $|$ {\em data-expression}
                                    $|$ {\em subexpression}
    \end{tabular}
\\[0.5ex]
\emkey{logical-expression}\label{LOGICAL-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & \TT{not}\QMARK{} ~  {\em logical-operand} \\
    $|$ & \TT{not}\QMARK{} ~ {\em logical-operand}
         \{ \TT{and} ~ \TT{not}\QMARK{} ~ {\em logical-operand} \}\PLUS{} \\
    $|$ & \TT{not}\QMARK{} ~ {\em logical-operand}
         \{ \TT{or} ~ \TT{not}\QMARK{} ~ {\em logical-operand} \}\PLUS{} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-operand}\label{LOGICAL-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em comparison-expression} $|$ {\em data-expression} \\
    $|$ & {\em subexpression}
    \end{tabular}
\\[0.5ex]
\emkey{comparison-expression}\label{COMPARISON-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em comparison-operand}
	  \{ {\em comparison-operator} ~ {\em comparison-operand} \}\PLUS{} \\
    \end{tabular}
\\[0.5ex]
\emkey{comparison-operator}\label{COMPARISON-OPERATOR} ::=
    \TT{==} $|$ \TT{!=} $|$ \TT{>} $|$ \TT{>=} $|$ \TT{<} $|$ \TT{<=}
\\[0.5ex]
\emkey{comparison-operand}\label{COMPARISON-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em bitop-expression} $|$ {\em summation-expression}
                                 $|$ {\em product-expression} \\
    $|$ & {\em exponent-expression} $|$ {\em data-expression}
                                    $|$ {\em subexpression}
    \end{tabular}
\\[0.5ex]
\emkey{bitop-expression}\label{BITOP-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & \TT{!} {\em bitop-operand} \\
    $|$ & \TT{!}\QMARK{} ~ {\em bitop-operand}
         \{ \TT{\&} ~ \TT{!}\QMARK{} ~ {\em bitop-operand} \}\PLUS{} \\
    $|$ & \TT{!}\QMARK{} ~ {\em bitop-operand}
         \{ \TT{|} ~ \TT{!}\QMARK{} ~ {\em bitop-operand} \}\PLUS{} \\
    $|$ & \TT{!}\QMARK{} ~ {\em bitop-operand}
         \{ \TT{xor}
	    ~ \TT{!}\QMARK{} ~ {\em bitop-operand} \}\PLUS{} \\
    $|$ & {\em bitop-operand}
         \{ {\em shift-operator} ~ {\em bitop-operand} \}\PLUS{} \\
    \end{tabular}
\\[0.5ex]
\emkey{shift-operator}\label{SHIFT-OPERATOR} ::= \TT{<{}<} $|$ \TT{>{}>}
\\[0.5ex]
\emkey{bitop-operand}\label{BITOP-OPERAND} ::=
    {\em data-expression} $|$ {\em subexpression}
\\[0.5ex]
\emkey{summation-expression}\label{SUMMATION-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em sign}\QMARK{} ~  {\em summation-operand} ~
         \{ {\em sign} ~ {\em summation-operand} \}\PLUS{} \\
    $|$ & {\em sign} ~ {\em summation-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{sign}\label{SIGN} ::= \TT{+} $|$ \TT{-}
\\[0.5ex]
\emkey{summation-operand}\label{SUMMATION-OPERAND}
    \begin{tabular}[t]{rl}
    ::= & {\em product-expression} $|$ {\em exponent-expression} \\
    $|$ & {\em data-expression} $|$ {\em subexpression} \\
    \end{tabular}
\\[0.5ex]
\emkey{product-expression}\label{PRODUCT-EXPRESSION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & {\em product-operand} ~ \{ \TT{*} ~ {\em product-operand} \}\PLUS{} \\
    $|$ & {\em product-operand} ~ \TT{/} ~ {\em product-operand} \\
    $|$ & {\em product-operand} ~ \TT{div} ~ {\em product-operand} \\
    $|$ & {\em product-operand} ~ \TT{mod} ~ {\em product-operand} \\
    $|$ & {\em product-operand} ~ \TT{rem} ~ {\em product-operand} \\
    \end{tabular}
\\[0.5ex]
\emkey{product-operand}\label{PRODUCT-OPERAND} ::=
    {\em exponent-expression} $|$
    {\em data-expression} $|$ {\em subexpression}
\\[0.5ex]
\emkey{exponent-expression}\label{EXPONENT-EXPRESSION}
    ::= {\em exponent-operand} ~ \TT{\textasciicircum} ~ {\em exponent-operand}
\\[0.5ex]
\emkey{exponent-operand}\label{EXPONENT-OPERAND} ::=
    {\em data-expression} $|$ {\em subexpression}
\\[0.5ex]
\emkey{data-expression}\label{DATA-EXPRESSION}
    \begin{tabular}[t]{rl}
    ::= & {\em constant} \\
    $|$ & {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{constant}\label{CONSTANT}
    \begin{tabular}[t]{@{}rll@{}}
    ::= & {\em number-constant} & [see \pagref{NUMBER-CONSTANT}] \\
    $|$ & {\em enum-set-constant} & [see \pagref{ENUM-SET-CONSTANT}] \\
    $|$ & {\em enum-list-constant} & [see \pagref{ENUM-LIST-CONSTANT}] \\
    $|$ & {\em character-constant} & [see \pagref{CHARACTER-CONSTANT}] \\
    $|$ & {\em string-constant} & [see \pagref{STRING-CONSTANT}] \\
    $|$ & {\em name-constant} & [see \pagref{NAME-CONSTANT}] \\
    $|$ & {\em name-set-constant} & [see \pagref{NAME-SET-CONSTANT}] \\
    $|$ & {\em name-list-constant} & [see \pagref{NAME-LIST-CONSTANT}] \\
    \end{tabular}
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{subexpression}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em function-call} ~~~~~ [see \pagref{FUNCTION-CALL}] \\
    $|$ & {\em qualifier-name}\STAR{} ~ {\em type-name}
          ~ \TT{(} {\em expression} \TT{)} \\
    $|$ & {\em module-abbreviation} ~ \TT{(} {\em expression} \TT{)} \\
    $|$ & \TT{(} {\em expression} \TT{)} \\
    \end{tabular}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}

\end{indpar}

Note that strictly binary operators such as \TT{mod} can also
be used as function names, as in
\begin{center}
{\tt uns8 x = mod ( 257 )}
\end{center}

\subsection{Expression Semantics}

Expressions provide standard operators on numbers plus logical and
memory reference operators.

\subsubsection{Expression Typing}
\label{EXPRESSION-TYPING}

L-Language uses a top-down method of assigning types to operator arguments.
Generally given the statement
\begin{center}
$T$ $v$ ~ \TT{=} ~ $e1$ ~ $op1$ ~ $e2$ ~ $op2$ ~ \ldots{}
\end{center}
where $T$ is a type of a variable $v$, where $e1$, $e2$, \ldots{} are
subexpressions, and where $op1$, $op2$, \ldots{} are operators with the
same precedence (e.g., all are either \TT{+} or \TT{-}), then
all the subexpression values are implicitly converted to type $T$
before the operations are done.  Here $T$ is called the `\key{target type}'
of the expressions $e1$, $e2$, \ldots{}.

An example is:

\begin{indpar}\begin{verbatim}
float64 w = 1.5
int64 x = 9,568
uns64 y1 = 0xFF00
uns32 y2 = 0xFF00
int64 z1 = x + y1
    // Compile error:
    //     y1 is not implicitly convertible to int64
int64 z2 = x + y2
    // OK, y2 IS implicitly convertible to int64
int64 z3 = x + y2 * w
    // Compile error:
    //     Target type of y2 * w is int64,
    //     hence target type of y2 is int64 with is OK,
    //     and target type of w is int64, but w is not
    //     implicitly convertiable to int64
\end{verbatim}\end{indpar}

The target type of an expression is usually provided by the
type of the variable being set by an assignment statement, or in the
case of function arguments, by the argument type specified in the
function prototype.

The target type of a {\em logical-expression} or a {\em comparison-expression}
must be \TT{bool}.

In some cases the target type is specified by special rules.  The
target type of {\em comparison-operands} is specified by special
rules given in \itemref{COMPARISON-EXPRESSIONS}.

Some special rules
make use of the `\key{natural type}'\label{NATURAL-TYPE}
that some subexpressions have, provided this is not a number type.
The natural type of a variable is its type.  The natural
type of a vector element reference expression is the type of the
vector element, unless that type is a number type of size not
equal to a power of \TT{2}, in which case the natural type is
the number type with size rounded up to a power of \TT{2}.
The natural type of an expression of the
form `\TT{$T$ ( \ldots{} )}' where $T$ is a type name is $T$.
No other expression has a natural type.  In particular,
{\em function-calls} do not have a natural type, even if
they have a unique unambiguous result type.

If there is no target type because an expression is being used
as an assignment statement with no result variables, then
the expression is in error and will not be compiled.
The only exception to this rule
is evaluation of function calls.  If a function call has no
result variables, there may be greater ambiguity because the
type of the first result variable cannot be used to discard function
prototypes (see `conversion deficient', \pagref{CONVERSION-DEFICIENT}),
but if there is no ambiguity for a particular
function call, that call will be compiled.

\subsubsection{Evaluation Order}
\label{EVALUATION-ORDER}

Where binary operators of the same precedence appear outside
parentheses in an expression, they are evaluated left to right.
This is, they are left associative.  For example,
`{\tt x <{}< s1 >{}> s2}' is
equivalent to `{\tt (x <{}< s1) >{}> s2}'.

For logical operators such as `\TT{and}', `\TT{or}', and
`\TT{\ldots{}~if~\ldots{}~else~\ldots{}}' the value of the expression
may be determined before all the operands have been evaluated.
In this case the unnecessary operands are never evaluated.
For example, if in `\TT{$e1$~and~$e2$}' the subexpression $e1$
evaluates to \TT{false}, the subexpression $e2$ is never evaluated.
Furthermore, if $e1$ evaluates at compile-time to \TT{false},
$e2$ is not even compiled, and any compile errors it contains
are not detected.  Similarly if in `\TT{$e1$~if~$b$~else~$e2$}' the
conditioning expression $b$ evaluates to \TT{true}, $e2$ is
never evaluated, and if $b$ evaluates to \TT{true} at compile
time, $e2$ is never compiled.  However all subexpressions are parsed and
parsing errors are detected.

\subsubsection{Logical Expressions}

In logical expressions the `\TT{not}' operator is moved inside
`\TT{and}' and `\TT{or}' operators before further evaluation.
Also double negations are deleted.

The target type for logical expressions is always \TT{bool}.

Logical expressions are evaluated from left to right and
if the value of the entire expression is discovered before all
the subexpressions are evaluated, evaluation of later subexpressions is
skipped, as per \itemref{EVALUATION-ORDER}.

\subsubsection{Comparison Expressions}
\label{COMPARISON-EXPRESSIONS}

The target type for comparison expressions is always \TT{bool}.

There is no given target type for operands of comparison operators.
So the target type of these must be specified by rules.

For numeric operands of comparison operators
the target type is the first type
in the following sequence that is such that all operands
can be implicitly converted to that type:
\begin{center}
\TT{unswrd} ~ \TT{intwrd} ~ \TT{unsmax} ~ \TT{intmax}
           ~ \TT{floatwrd} ~ \TT{floatmax}
\end{center}

An example assuming:


\begin{indpar}\begin{verbatim}
unswrd ---> `uns32'
intwrd ---> `int32'
floatwrd ---> `float32'
unsmax ---> `uns64'
intmax ---> `int64'
floatmax ---> `float32'
\end{verbatim}\end{indpar}

is:

\begin{indpar}\begin{verbatim}
int64 x = 9,568
uns64 y1 = 0xFF00
uns32 y2 = 0xFF00
bool z1 = x < y1
    // Compile error:
    //     x and y1 cannot be implicitly converted
    //     to the same target type
bool z1 = x < y2
    // OK, x and y2 are implicitly convertible to
    // intmax (int64)
\end{verbatim}\end{indpar}

Non-numeric comparison operators require that one or more of
the operands have a natural type (\pagref{NATURAL-TYPE}),
and use as the target type
the least upper bound (\pagref{LEAST-UPPER-BOUND})
of all these natural types.
It is a compile error if this least upper bound does
not exist, or if it is \TT{bool} and no operand natural type was \TT{bool}.
For example, given the expression `{\tt v == missing}', where \TT{v}
is of `\TT{qualifier}' type, {\tt missing}, which has no natural type, will be
evaluated with `\TT{qualifier}' target type.

Comparison expressions are evaluated from left to right and are
true if and only if all the comparisons are true.  Middle
arguments are shared between two comparison operators.
An example is:

\begin{indpar}\begin{verbatim}
int64 x = 9,568
uns16 y1 = 0xFF00
uns32 y2 = 0xFF01
bool z1 = x < y1 < y2
    // x, y1, y2 are all converted to int64.
    // y2 is only converted if x < y1 is true.
bool z2 = x < y1 and y1 < y2
    // y1 is converted to int64 to compare it with x
    // and then if x < y1 is true, y1 is separately
    // converted to uns32 to compare it with y2.
\end{verbatim}\end{indpar}

As per \itemref{EVALUATION-ORDER}, if a comparison evaluates
to \TT{false}, operands following those of the comparison
are not evaluated.

Note that a comparison operator may not have a negation that is
also simply a comparison operator, e.g., \TT{>=} may not be the
negation of \TT{<}.  For example, both return \TT{false} if an
operand is \TT{NaN}.  For this reason `{\tt x < y}' and
`{\tt not ( x < y )}' are treated as semantically different
expressions.

\subsubsection{Integer Arithmetic Expressions}

If an integer arithmetic operator is being evaluated with
operand and target type \TT{uns$x$} or \TT{int$x$}, the
exact arithmetic results is computed and truncated to
$x$ bits, i.e., is taken modulo $2^x$ before being presented
as the result.

An exception to this is made for integer division operations.
If the divisor is zero, the results are undefined.  If the
target type is \TT{int$x$}, the dividend is $-2^{x-1}$, and
the divisor is $-1$, the result is undefined.  In both these
cases the result may be a program terminating error.

The bitwise operators are:
\begin{center}
\begin{tabular}{ll}
\TT{\&}		& bitwise AND \\
\TT{|}		& bitwise OR \\
\TT{xor}	& bitwise EXCLUSIVE OR \\
\TT{!}		& bitwise complement \\
\TT{<{}<}	& bitwise shift left \\
\TT{>{}>}	& bitwise shift right \\
\end{tabular}
\end{center}

In `{\tt v >{}> s}' and `{\tt v <{}< s}', {\tt v} is converted to the
target type which may be any integer type $T$, but {\tt s} is converted
to \TT{unswrd} and only its low order $x$ bits are used as the
shift amount, where $x$ is the size of $T$.
In other words, the shift amount is {\tt s mod 2$^x$}.

The integer division operators are:
\begin{center}
\begin{tabular}{ll}
\TT{div}	& quotient rounded towards zero \\
\TT{mod}	& modulo; remainder when quotient is rounded
                  toward negative infinity \\
\TT{rem}	& remainder when quotient is rounded toward zero \\
\end{tabular}
\end{center}

The operator \TT{/} is strictly floating point.  The operator
\TT{\textasciicircum} is \underline{not} builtin and must be
defined by library code.

\subsubsection{Floating Point Arithmetic Expressions}
\label{FLOATING-POINT-ARITHMETIC-EXPRESSIONS}

There is a `\key{floating point error register}' that holds
floating point error flags that may be set by floating point
arithmetic and comparison operations.  These flags are `\key{sticky}', in that
operations may set them but may never clear them.  There are also
special builtin functions to manipulate these flags
(\itemref{FLOATING-POINT-ERROR-FLAG-FUNCTIONS}).

The flags with the operation results when the flags are set are:
\begin{indpar}
\mkey{Invalid Operand}{floating point error flag}
\begin{indpar}
Set upon one of the following:
\begin{center}
\begin{tabular}{l}
Compare operand is a \TT{NaN}. \\
Adding \TT{+Inf} and \TT{-Inf}. \\
Subtracting \TT{+Inf} from \TT{+Inf}. \\
Subtracting \TT{-Inf} from \TT{-Inf}. \\
Multiplying \TT{0} by \TT{+Inf} or \TT{-Inf}. \\
Dividing \TT{+Inf} or \TT{-Inf} by \TT{+Inf} or \TT{-Inf}. \\
Dividing \TT{0} by \TT{0}. \\
\end{tabular}
\end{center}

Except for compares, the result is \TT{NaN}.
For compares, the result is \TT{false}.
\end{indpar}

\mkey{Divide By Zero}{floating point error flag}
\begin{indpar}
Set by a floating point division with a \TT{+0} or
\TT{-0} divisor and a non-zero dividend.

The result is \TT{+Inf} if both operands have the
same sign and \TT{-Inf} if they have opposite signs.
\end{indpar}

\mkey{Result Overflow}{floating point error flag}
\begin{indpar}
Set if result has magnitude too large to store in a target type value.

If the result is positive, \TT{+Inf} is stored, and if negative,
\TT{-Inf} is stored.
\end{indpar}

\mkey{Result Underflow}{floating point error flag}
\begin{indpar}
Set if the result is too small to be stored, even as a denormalized
number, in a target type value.

The result is stored as \TT{+0} if it is positive and as
\TT{-0} if it is negative.
\end{indpar}

\mkey{Result Inexact}{floating point error flag}
\begin{indpar}
Set if result cannot be exactly stored in a target type value.
This happens frequently and is not normally considered a
real error.

The result is rounded to the nearest value, with ties to even.
\end{indpar}
\end{indpar}

Except for compares, \TT{NaN} operands cause \TT{NaN} results and
do \underline{not} set the invalid operand flag.

Results may be denormalized numbers.  Except for compares,
when an operand to an arithmetic operation is a denormalized
number, it is treated as zero.

The operator
\TT{\textasciicircum} is \underline{not} builtin and must be
defined by library code.

\subsection{Operator Semantics}

The following evaluation rules are applied in the order given.

For example, `{\tt not ( x > y and z )}' is evaluated by applying
the rule that rewrites it to `{\tt not x > y or not z}' instead of
the rules that evaluated `{\tt x > y and z}' first and then complement
the result.

Parentheses are inserted by the parser to separate operators of
differing precedence before these rules are applied.

Comparison operators, and the
arithmetic operators, summation, product, and bitwise, 
may be overloaded by functions that apply them to non-numeric
types other than \TT{bool}.
If $T$ is such a type, these functions must have prototypes
of the forms
\begin{indpar}
{\tt function bool r = ( $T$ $v1$ ) "$op$" ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of \TT{<}, \TT{<=}, \TT{==}, \TT{!=}, \TT{>=}, or \TT{>}
\end{indpar}

{\tt function $T$ r = ( $T$ $v1$ ) "$op$" ( unswrd $v2$ )}
\begin{indpar}
where $op$ is one of \TT{<{}<} or \TT{>{}>}
\end{indpar}

{\tt function $T$ r = "$op$" ( $T$ $v1$ )}
\begin{indpar}
where $op$ is one of \TT{-} or \TT{!}
\end{indpar}

{\tt function $T$ r = ( $T$ $v1$ ) "$op$" ( $T$ $v2$ )}
\begin{indpar}
where $op$ is one of
    \TT{+}, \TT{-}, \TT{\&}, \TT{|}, \TT{xor},
    \TT{*}, \TT{/}, \TT{div}, \TT{mod}, \TT{rem}, \TT{\textasciicircum}
\end{indpar}
\end{indpar}


The selection operator (\TT{if/else}) and the logical
operators (\TT{not}, \TT{and}, \TT{or}) may \underline{not}
be overloaded.

\medskip

\TT{$e1$ if $b1$ else $e2$ if $b2$ \ldots{} else $e$}
\hfill [{\em selection-expression}]
\begin{indpar}
$b1$ is evaluated first.  If it is \TT{true}, $e1$ is evaluated and its
value is returned.  If it is \TT{false}, $e1$ is \underline{not}
evaluated, and instead $b2$ is evaluated.  If that is \TT{true}
$e2$ is evaluated and its value is returned.  But if $b2$ is \TT{false}
evaluation of the {\em selection-expression} continues.  If none of
the $bI$ evaluate to \TT{true}, $e$ is evaluated and returned as the result.

The target type of each $bI$ is \TT{bool} and the target type of each
$eI$ is the target type of the {\em selection-expression}.
Only one of the $eI$ is evaluated.  If any $bI$ is a compile time
\TT{false} value, the associated $eI$ is not compiled or checked
for compile errors.
\end{indpar}

\TT{not ( $b1$ and $b2$ and \ldots{} )}
\hfill [{\em logical-expression}]
\begin{indpar}
The expression is replaced by
\TT{( ( not $b1$ ) or ( not $b2$ ) or \ldots{} )}.
\end{indpar}

\TT{not ( $b1$ or $b2$ or \ldots{} )}
\hfill [{\em logical-expression}]
\begin{indpar}
The expression is replaced by
\TT{( ( not $b1$ ) and ( not $b2$ ) and \ldots{} )}.
\end{indpar}

\TT{not ( not $b1$ )}
\hfill [{\em logical-expression}]
\begin{indpar}
The expression is replaced by $b1$.
\end{indpar}

\TT{$b1$ and $b2$ and \ldots{}}
\hfill [{\em logical-expression}]
\begin{indpar}
The $bI$ are evaluated left to right until one evaluates to
\TT{false} or none do.  If one evaluates to \TT{false},
\TT{false} is returned as the value of the {\em logical-expression}
and the remaining $bI$ are not evaluated.
Otherwise \TT{true} is returned.

The target type of all the $bI$ is \TT{bool}.  If any $bI$ is a
compile time \TT{false} value, the remaining $bI$ are not compiled
or checked for compile errors.
\end{indpar}

\TT{$b1$ or $b2$ or \ldots{}}
\hfill [{\em logical-expression}]
\begin{indpar}
The $bI$ are evaluated left to right until one evaluates to
\TT{true} or none do.  If one evaluates to \TT{true},
\TT{true} is returned as the value of the {\em logical-expression}
and the remaining $bI$ are not evaluated.
Otherwise \TT{false} is returned.

The target type of all the $bI$ is \TT{bool}.  If any $bI$ is a
compile time \TT{true} value, the remaining $bI$ are not compiled
or checked for compile errors.
\end{indpar}

\TT{not $e1$ $cop1$ $e2$ $cop2$ $e3$ \ldots{}}
\hfill [{\em logical-expression}]
\begin{indpar}
where the $copI$ are comparison operators chosen from the list
\TT{==}, \TT{!=}, \TT{>}. \TT{>=}, \TT{<}, or \TT{<=}.

First $e1$ and $e2$ are evaluated.  Then the function
call `{\tt $e1$ "$cop1$" $e2$}'
is evaluated, and if it is \TT{false},
\TT{true} is returned as the value of the {\em logical-expression}.
Otherwise $e3$ and the function call `{\tt $e2$ "$cop2$" $e3$}'
are evaluated, and if the latter
evaluated to \TT{false},
\TT{true} is returned as the value of the {\em logical-expression}.
This continues until a comparison evaluates to \TT{false} or all
evaluate to \TT{true}.  In the latter case, \TT{false} is returned as
the value of the {\em logical-expression}.

No $eI$ is evaluated more than once, though the value of some $eI$
may be used more than once.

The target type $T$ of the expressions $eI$ is selected as
per \itemref{COMPARISON-EXPRESSIONS}.
\end{indpar}

\TT{not $b$}
\hfill [{\em logical-expression}]
\begin{indpar}
$b$ is evaluated.  If it returns \TT{true}, \TT{false} is
returned as the value of the {\em logical-expression}.
Otherwise \TT{true} is returned.

The target type of the $b$ is \TT{bool}.
\end{indpar}

\TT{$e1$ $cop1$ $e2$ $cop2$ $e3$ \ldots{}}
\hfill [{\em comparison-expression}]
\begin{indpar}
where the $copI$ are comparison operators chosen from the list
\TT{==}, \TT{!=}, \TT{>}. \TT{>=}, \TT{<}, or \TT{<=}.

First $e1$ and $e2$ are evaluated.  Then the function call
`{\tt $e1$ "$cop1$" $e2$}'
is evaluated, and if it is \TT{false},
\TT{false} is returned as the value of the {\em comparison-expression}.
Otherwise $e3$ and the function call `{\tt $e2$ "$cop2$" $e3$}'
are evaluated, and if the latter
evaluated to \TT{false},
\TT{false} is returned as the value of the {\em comparison-expression}.
This continues until a comparison evaluates to \TT{false} or all
evaluate to \TT{true}.  In the latter case, \TT{true} is returned as
the value of the {\em comparison-expression}.

No $eI$ is evaluated more than once, though the value of some $eI$
may be used more than once.

The target type $T$ of the expressions $eI$ is selected as
per \itemref{COMPARISON-EXPRESSIONS}.  The target type of the
function calls `{\tt $eI$ "$copI$" $e(I+1)$}' is \TT{bool}.
\end{indpar}

\TT{! $e1$}
\hfill [{\em bitop-expression}] \\
\TT{$e1$ $bop$ $e2$ $bop$ $e3$ \ldots{}}
\hfill [{\em bitop-expression}]
\begin{indpar}
where the $bop$ is a bitop operator chosen from the list
\TT{\&}, \TT{|}, \TT{xor}

The $eI$ are evaluated left to right.
Each function call
`{\tt "!" $e1$}' or
`{\tt $eI$ "$bop$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators (other than \TT{!}) are
also evaluated left to right.

The target type of the $eI$ is the target type of the
{\em bitop-expression} and must \underline{not} be floating
point number type.
\end{indpar}

\TT{$e1$ $shop1$ $e2$ $shop2$ $e3$ \ldots{}}
\hfill [{\em bitop-expression}]
\begin{indpar}
where the $shopI$ are bitop operators chosen from the list
\TT{<{}<}, \TT{>{}>}.

Each function call
`{\tt $eI$ "$shopI$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators are
also evaluated left to right.

The target type of $e1$ is the target type of the
{\em bitop-expression} and must \underline{not} be floating
point number type.
The target type of $e2$, $e3$, \ldots{} is \TT{unswrd}.
If $T$ is an integer type of size $x$,
the value of the shift for $shopI$
is $e(I+1)$ is taken modulo $2^x$.
\end{indpar}

\TT{$sop1$\QMARK{} $e1$ $sop2$ $e2$ $sop3$ $e3$ \ldots{}}
\hfill [{\em summation-expression}]
\begin{indpar}
where $sopI$ are summation operators chosen from the list
\TT{+} or \TT{-}.

The $eI$ are evaluated left to right.
Each function call
`{\tt "$sop1$" $e1$}' or
`{\tt $eI$ "$sop(I+1)$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators are
also evaluated left to right.

The target type of the $eI$ is the target type of the
{\em summation-expression}.
\end{indpar}

\TT{$e1$ * $e2$ * $e3$ \ldots{}}
\hfill [{\em product-expression}] \\
\TT{$e1$ $dop$ $e2$}
\hfill [{\em product-expression}]
\begin{indpar}
where the $dop$ is a divide operator chosen from the list
\TT{/}, \TT{div}, \TT{mod}, \TT{rem}.

The $eI$ are evaluated left to right.
Each function call
`{\tt "$eI$ "*" $e)I+1)$}' or
`{\tt $eI$ "$dop(I+1)$" $e(I+1)$}' is evaluated as soon as its operands have
been evaluated, so the operators are
also evaluated left to right.

The target type $T$ of the $eI$ is the target type of the
{\em product-expression}.  For \TT{div} and \TT{rem}, $T$ may
\underline{not} be a floating point number type.
For \TT{/}, $T$ may \underline{not} be an integer type.
If $T$ is an integer type, it must have size at least 32 bits.

\end{indpar}

\TT{$e1$ \textasciicircum{} $e2$}
\hfill [{\em exponential-expression}]
\begin{indpar}
The $eI$ are evaluated left to right.
The the function call
`{\tt $eI$ "\textasciicircum" $e(I+1)$}' is evaluated
as soon as its operands have
been evaluated.

The target type $T$ of the $eI$ is the target type of the
{\em exponential-expression}.

\end{indpar}

\TT{$ma$ ( $e1$ $op1$ $e2$ $op2$ \ldots{} )}
\hfill [{\em subexpression}]
\label{MODULE-ABBREVIATION-SEMANTICS}
\begin{indpar}
where $ma$ is a {\em module-abbreviation}.

$ma$ is prefixed to the unparenthesized
operators whenever they are used according to the above
rules.

For example,
\begin{center}
\begin{tabular}{c}
{\tt $ma$ ( x + ( y1 + y2 ) + ( z1 * z2 ) )} \\
becomes \\
{\tt $ma$ x + ( y1 + y2 ) ) + ( z1 * z2 )}
\end{tabular}
\end{center}

Since the parser places parentheses implicitly, in `\TT{$ma$($e$)}'
only the lowest precedence operators in $e$ are affected.
Thus the pre-parser expression
\begin{center}
{\tt $ma$ ( x + ( y1 + y2 ) + z1 * z2 )} \\
\end{center}
is equivalent to the above example.

\end{indpar}

\TT{$Qs$ $T$ ( $e$ )}
\hfill [{\em subexpression}]
\begin{indpar}
where $Qs$ are zero or more {\em qualifier-names} and $T$ is a {\em type-name}.

If the {\em subexpression} can be treated as a call to a
user defined function named $T$, it is evaluated as such with
target type `$Qs$ $T$'.

Otherwise $e$ is evaluated with target type `$Qs$ $T$'
and the result is implcitly
converted to the target type of the {\em subexpression}.
\end{indpar}

\section{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

Variables are allocated to the current function frame
and are also given their values by assignment statements.
After the assignment statement allocating a variable,
the value of the variable cannot be changed.  However,
a new variable of the same name can be allocated via
the `\TT{next}' construction which we describe below.

Assignment statements have the syntax:
\begin{indpar}
\emkey{assignment-statement}
    ::= \{ {\em result-variable-list} \TT{=} \}\QMARK{}
    		{\em assignment-right-side}
\\[0.5ex]
\emkey{result-variable-list}\label{RESULT-VARIABLE-LIST}
    ::= {\em result-variable}
	  \{ \TT{,} {\em result-variable} \}\STAR{}
\\[0.5ex]
\emkey{result-variable}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em result-variable-declaration} \\
    $|$ & {\em next-variable-declaration} \\
    $|$ & {\em deferred-result-variable}
    		& [see \pagref{DEFERRED-RESULT-VARIABLE}] \\
    $|$ & {\em iteration-result-variable}
    		& [see \pagref{ITERATION-RESULT-VARIABLE}] \\
    \end{tabular}
\\[0.5ex]
\emkey{result-variable-declaration}
    ::= {\em qualifier-name}\STAR{}~{\em type-name}~{\em variable-name}
\\[0.5ex]
\emkey{next-variable-declaration}
    ::= \ttkey{next}~{\em variable-name}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{assignment-right-side}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em expression-list}
    		& [see \pagref{EXPRESSION-LIST}] \\
    $|$ & {\em function-call}
    		& [see \pagref{FUNCTION-CALL}] \\
    $|$ & {\em subblock}
	        & [see kinds of assignment statement below] \\
    \end{tabular}
\end{indpar}

where the {\em assignment-right-side}
depends on the kind of assignment statement.
The kinds of assignment statements are:
\begin{indpar}
\emkey{assignment-statement}
    \begin{tabular}[t]{rll}
    ::= & {\em simple-assignment-statement}
	& \itemref{SIMPLE-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em block-assignment-statement}
	& \itemref{BLOCK-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em conditional-assignment-statement}
	& \itemref{CONDITIONAL-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em loop-assignment-statement}
	& \itemref{LOOP-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em call-assignment-statement}
	& \itemref{CALL-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em out-of-line-assignment-statement}
	& \itemref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em compile-and-run-assignment-statement}
	& \itemref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em compile-time-assignment-statement}
	& \itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em assembly-assignment-statement}
	& \itemref{ASSEMBLY-ASSIGNMENT-STATEMENTS} \\
    $|$ & {\em function-call}
	& \itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES} \\
    \end{tabular}
\end{indpar}

If an {\em assignment-statement} has {\em result-variable-declarations}
that give {\em variable-names} with types and qualifiers,
these result variables are allocated to the current function frame, and
values produced by evaluating the {\em assign\-ment-right-side} are stored in
these variables.
The {\em assignment-right-side} produces a list of values,
and this list must have
at least as many elements as there are result variables.
Result variables are assigned their values in parallel, after the
{\em assignment-right-side} has been completely evaluated.
If the {\em assignment-right-side} produces
too many values, the excess values at the end of the value list are
discarded.

When a variable value is set, the value is implicitly first
computed in a register, then stored in the current function
frame, and for some time
afterwards the value is left in the register which becomes a cache
on the frame value.  This cacheing is hidden from the programmer.

If a variable value is copied from another variable, usually the
new variable simply becomes a compile-time alias for the old variable.
No executable copy code is created, no new register is allocated, and no new
value is pushed into the stack.

Similarly if a variable value can be easily computed from previous variable
values by in-line code, 
its value may not be stored into the function frame.  Instead its
value can be recovered at any time by repeating the computation
of the variable from the other values.

The value assigned to each result variable must be implicitly convertible to
the variable's type.  In some cases the type of a result variable is
the target type of an {\em expression} in a {\em assignment-right-side}
that is an {\em expression-list}
(\itemref{SIMPLE-ASSIGNMENT-STATEMENTS}).
In some cases the result variable type is matched to
the type of a {\em function-prototype} result variable
for a {\em function-call} that is the {\em assignment-right-side}
(\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}).

The code of a function is organized into blocks.
Two variables allocated in the same block of code may not have the same
name, even if one is allocated in a subblock of the block allocating
the other.
Thus variables are only assigned values once within a function.

However, if an assignment statement has a {\em next-variable-declaration}
that uses the word `\TT{next}'\label{NEXT} in
place of the {\em qualifier-names} and {\em type-name}
of a result variable being assigned a value, then the named variable must
have been previously assigned a value within the same smallest containing block,
and a new variable with the same qualifiers, type, and name
as the previous variable is allocated,
and the new variable supersedes the previous variable
in subsequent code within the block.

See the example in \itemref{SIMPLE-ASSIGNMENT-STATEMENTS}, and
the more detailed discussion in 
\itemref{BLOCK-ASSIGNMENT-STATEMENTS}.

Note that `\TT{next}' behaves differently when it used as part of
the name of
a {\em deferred-result-variable} (\pagref{DEFERRED-RESULT-VARIABLE})
or an {\em iteration-result-variable} (\pagref{ITERATION-RESULT-VARIABLE}).

The {\em result-variables} may be completely omitted in most forms
of {\em assignment-statements}.  Because these statements still have
the form and semantics of statements that could have result variables,
we call them `{\em assignment-statements}' even thought they allocate
and assign no result variables.

Sometimes assignment statements with no explicit
result variables have implied `\TT{next}' result variables:
see \pagref{IMPLIED-NEXT-VARIABLES}.

There are also statements that have the form:
\begin{center}
{\em function-call} ~ \TT{=} ~ {\em expression-list}
\end{center}
which are syntactic sugar for {\em function-call}
in which the {\em expression-list} has been made into a function argument
list and there are no result variables.
{\em Function-calls} \underline{cannot} be used as result variables.
See \itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}.

\subsection{Simple Assignment Statements}
\label{SIMPLE-ASSIGNMENT-STATEMENTS}

The simplest \skey{assignment statement}s have the syntax:

\begin{indpar}
\emkey{simple-assignment-statement}
    ::= {\em result-variable-list} \TT{=} {\em expression-list}
\\[0.5ex]
\emkey{expression-list}\label{EXPRESSION-LIST}
    ::= {\em expression} \{ \TT{,} {\em expression} \}\STAR{}
\end{indpar}

If there is more than one {\em expression} in the {\em expression-list},
or if there is a single {\em expression} that is \underline{not}
a {\em function-call},
then each {\em expression} produces a single value, and the list of these
values is the list of values assigned to the list of result variables.
The {\em expressions} are evaluated in left to
right order, and all the {\em expressions} are evaluated before any of
the result variables are given values.

There must be at least as many {\em expressions} as there are result
variables.  If there are too many {\em expressions}, the values of the
extra {\em expressions} are discarded, and these extra {\em expressions} 
may be completely or partly optimized away, never compiled, and never executed.
See section \itemref{OPTIMIZATION}.
However function calls are never optimized away, although if they are
to inline functions, the function body code that replaces the function
call may be optimized away.

An {\em expression} may only input values that are constants,
the values of variables in the same function execution
frame (including arguments passed to the function execution), 
or the values of global variables.  In particular,
no input can come \underline{directly}
from RAM memory outside the current function execution frame or
global memory,
but see \pagref{MEM} and Section~\itemref{THE-MEM-QUALIFIER}
for ways to load RAM values into function frame variables.
See Section~\itemref{STACK-MANAGEMENT} for more information about
function frames.

If the {\em expression-list} is a single {\em expression} that
is a {\em function-call} which returns a list of values,
this list of values is used.

The value assigned to each result variable must be implicitly convertible to
the variable's type.
In the case that an {\em expression} is producing
only a single value, the type of its associated result variable is the target
type of the {\em expression}.  If there is only one {\em expression}
and that is a {\em function-call}, the types the result variables
are matched to the types of the {\em function-prototype} result
variables (\itemref{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}).

Some examples of {\em simple-assignment-statements} are:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = x + 1         // y == 2
next x = 10 * x         // Now x == 10
next y = x + y          // Now y == 12
int32 z = 256 + y       // z == 268
int8 u = z              // ILLEGAL!  Undefined implicit
                        // conversion from int32 to int8.
int8 v = mod ( z )      // Now v == 12
int8 w = v + 257        // ILLEGAL!  Constant out of range
                        // of target type int8.
float32 m = 1.7
int64 i = m             // ILLEGAL!  Undefined implicit
                        // conversion from float32 to int64.
int32 j = nearest ( m ) // now j == 2 (round to nearest)
\end{verbatim}\end{indpar}

\subsection{Block Assignment Statements}
\label{BLOCK-ASSIGNMENT-STATEMENTS}

Another variant of the assignment statement is\index{block assignment}:

\begin{indpar}
\emkey{block-assignment-statement}
    ::= \begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	\{ \ttkey{do} {\em block-name}\QMARK{} \}\QMARK{} \TT{:} \\
	\TT{~~~~}{\em statement}\STAR{}
	\end{tabular}
\\
\emkey{block-name} ::=
    \begin{tabular}[t]{l}
    {\em name} ~~~~~ [see \pagref{NAME}] \\
    \underline{not} containing
	`\TT{.}',~ {\em quoted-marks},~ or {\em quoted-separators}
    \end{tabular}
\end{indpar}

where `\TT{do} {\em block-name}\QMARK{}'
may be omitted as long as \TT{=} is not omitted.

The {\em statements} within the {\em block-assignment-statement}
comprise a `\key{block}' of code.

Any result variables in a {\em block-assignment-statement}
are called `\skey{deferred variable}s' because they do not
immediately get a value.  They are assigned values by
{\em assignment-statements} within the block
in which {\em result-variable-declara\-tions}
include {\em deferred-result-variables}.
\begin{indpar}
\emkey{deferred-result-variable}\label{DEFERRED-RESULT-VARIABLE} ::=
    {\em variable-name} $|$ \TT{next} ~ {\em variable-name}
\end{indpar}
{\em Assignment-statements} that set {\em deferred-result-variables}
are called `\skey{deferred assignment}s'.

The code must be such that every deferred variable is given a value
by at most one deferred assignment, and if not a `\TT{next}' variable,
is given a value by a deferred assignment before the variable is read.

A variable allocated within the block is not visible outside the
block, but may \underline{not} have the same name as any variable
allocated outside the block that is visible in the block
(this includes the block's deferred variables).\footnote{
This is more restrictive than other block structured
languages such as C.}.  The name `{\tt next v}' \underline{cannot}
be given a value inside the block if {\tt v} is a variable allocated
outside the block, except for the case that `{\tt next v}' is a
block result variable.  In this last case, the name `{\tt v}' used
inside the block before `{\tt next v}' is assigned a value refers
to the value of `{\tt v}' at the beginning of the block, and the
name `{\tt v}' used inside the block after `{\tt next v}' is assigned
a value refers to the value assigned to `{\tt next v}'.  See
the following example.

An example of a {\em block-assignment-statement} is:
\begin{indpar}\begin{verbatim}
int32 x = 1
float64 y = 1.67
int64 z, uns8 w, next x =:

    z = 16,777,216   // Legal, z is result variable
    x = 265          // ILLEGAL, x is NOT result variable
    float64 y = 2.6  // ILLEGAL, y is visible outside block
    uns8 v = 55      // Legal, v is NOT visible outside block
    next x = 265 + x // Legal, next x is result variable,
                     //        now x == 266
    next y = 2.6     // ILLEGAL, y is visible outside block
                     //          and next y is not result
                     //          variable
    w = mod ( x )    // Legal, sets w to 10 as x is now 266
\end{verbatim}\end{indpar}

An exit statement may be used to jump from within a block to
the end of the block:

\begin{indpar}
\emkey{exit-statement} ::=
        \ttkey{exit} ~ {\em block-name}\QMARK{} ~
	    \{ \TT{if} ~ {\em condition-expression} \}\QMARK{}
\end{indpar}

If the {\em block-name} is not given, the smallest block containing
the {\em exit-statement} is exited.

The block exit may be conditional.  The compiler checks that
every one of the block's deferred variables is given a value
by a deferred assignment statement, no matter whether conditional
exits are taken or not.  However, if a {\em block-name} is given
and the block being exited is not the smallest block containing
the exit statement, the deferred variables of this smallest
block need not be given values.

Examples of {\em exit-statements} are:

\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
bool v = do BLOCK1:
    // sets v = ( x <= 10 or y >= 10 )
    //
    do BLOCK2:
        exit BLOCK2 if ( x > 10 )
        v = true
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3 if ( y < 10 )
        v = true
        exit BLOCK1
    v = false

next v = do BLOCK1:
    // attempts to set next v = ( x <= 20 or y >= 20 )
    next v = true
    exit BLOCK1 if x <= 20
    exit BLOCK1 if y >= 20
    next v = false          // ILLEGAL: next v set twice
\end{verbatim}\end{indpar}

SAFE parses all code, but does not compile statements that
cannot be reached from the beginning of the current top level
statement (e.g., out-of-line function declaration).  Because
of unconditional \TT{exit} statements, or \TT{exit} statements
whose conditions evaluate to \TT{true} at compile time,
some statements will be unreachable and will not be compiled.
Unreachable statements are not checked for non-parsing compile
errors.

For example, the code
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
int32 z = do BLOCK1:
    do BLOCK2:
        exit BLOCK2 if ( x > 10 )
        z = 55
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3 if ( y < 10 )
        z = "hot dog"    // Illegal conversion
        exit BLOCK1
    z = "cold dog"       // Illegal conversion
\end{verbatim}\end{indpar}

becomes after eliminating unreachable statements:
\begin{indpar}\begin{verbatim}
int32 x = 1
int32 y = 1
int32 z = do BLOCK1:
    do BLOCK2:
        exit BLOCK2 if false
        z = 55
        exit BLOCK1
    do BLOCK3:
        exit BLOCK3
\end{verbatim}\end{indpar}

and therefore has no compiler errors.


\subsection{Conditional Assignment Statements}
\label{CONDITIONAL-ASSIGNMENT-STATEMENTS}

\ikey{Conditional assignment statements}{conditional assignment}
are syntactic sugar for block assignment statements
with exits (\pagref{BLOCK-ASSIGNMENT-STATEMENTS}).
Conditional assignment statements have the syntax:

\begin{indpar}
\emkey{conditional-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{} \ttkey{if}\TT{:} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	\TT{~~~~}\ttkey{else}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

In this case the {\em condition-expressions} are evaluated in order
until either one evaluates to true or the `\TT{else}' condition is
reached, and then the {\em statements} subject to the
first true condition (a.k.a the \key{subblock} of that condition)
are executed, or if no condition is true, the {\em statements}
of the `\TT{else}' subblock are executed.

Every variable in the {\em result-variable-list} \underline{must} be set by the
single subblock that executes, unless that subblock exits a block
that contains the {\em conditional-assignment-statement}.  A variable in the
{\em result-variable-list} cannot be read by a subblock {\em statement}
unless it is set by a previous {\em statement} in the
same subblock.

An example is:
\begin{indpar}\begin{verbatim}
function float64 result =
        max ( float64 x, float64 y, float64 z ):
    result = if:
        y <= x => z:
            result = x
        z <= y => x:
            result = y
        y <= z => x:
            result = z
        else:
            result = NaN
\end{verbatim}\end{indpar}

where \TT{NaN} means `\key{not-a-number}' and is the missing
value for \TT{float64} variables.  {\tt x~=>~y} is true if
and only if neither {\tt x} nor {\tt y} is a \TT{NaN} and
{\tt x} is equal to or greater than {\tt y}.  Thus if any of
{\tt x}, {\tt y}, or {\tt z} in the above conditional assignment
is a \TT{NaN}, none of the {\em conditional-expressions}
will be \TT{true}, and the \TT{else} subblock will be evaluated to set
the {\tt result} to a \TT{NaN}.

There are a couple of special rules applying to
{\em conditional-assignment=statements}:\label{CONDITIONAL-SPECIAL-RULES}

\begin{indpar}
If some of the {\em conditional-expressions} can be computed at compile
time, subblocks that the compiler determines cannot execute are not
compiled or checked for compiler errors (but the subblocks are parsed
and checked for parsing errors).

Specifically, if a {\em conditional-expression} evaluates to \TT{true}
at compile time, subblocks beyond that of this {\em conditional-expression}
are not compiled.  And if a remaining {\em conditional-expression}
evaluates to \TT{false} at compile time, the subblock of this
{\em conditional-expression} is not compiled.
\end{indpar}

For example, if a {\em conditional-assignment-statement}
contained
\begin{indpar}\begin{verbatim}
    if x >= 1,000,000:
        result = NaN
\end{verbatim}\end{indpar}
where {\tt x} is a variable with value known at compile time
that is less than {\tt 1,000,000}, then
`{\tt result = NaN}' will not compile
and will not be checked for compile time errors.


A second special rule is:

\begin{indpar}
Missing `\TT{else}'s do not cause compile errors,
but will cause run time errors if needed at run time.
\end{indpar}

For example, the {\em conditional-assignment-statement}:
\begin{indpar}\begin{verbatim}
    result = if:
        x <= y:
            result = x
        y <= x:
            result = y
\end{verbatim}\end{indpar}
will suffer a run-time error if {\tt x} or {\tt y} are
a floating point \TT{NaN} at run-time.

\subsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

\ikey{Loop assignment statements}{loop assignment}
are similar to block assignment
and conditional assignment statements.  An example is:
\begin{indpar}\begin{verbatim}
// Calculate the sum of i for i == 1 to i == n.
//
int64 n = . . .
int64 sum = loop:
    initially:
        int64 i = 1
        int64 partial sum = 0
    while i <= n:
        next partial sum = partial sum + i
        next i = i + 1
    finally:
        sum = partial sum
\end{verbatim}\end{indpar}



The general syntax of loop assignment statements is:

\begin{indpar}
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	          \ttkey{loop:} \\
	\TT{~~~~}\ttkey{initially}\TT{:} \\
	\TT{~~~~~~~~~}{\em assignment-statement}\STAR{} \\
	\TT{~~~~}\{ \ttkey{while} $|$ \ttkey{until} \}
	         {\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ttkey{finally}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

This is somewhat like the conditional assignment statement
except the `\TT{while}' or `\TT{until}'
subblock is iterated and there are iteration
variables defined by the `\TT{initially}' subblock.

The `\TT{initially}' subblock is call the `\key{initialization subblock}',
the `\TT{while/until}' subblock is call the `\key{iteration subblock}',
and the `\TT{finally}' subblock is call the `\key{finalization subblock}'.

The \skey{iteration variable}s are the
{\em result-variables} of the
{\em assignment-statements} executed by the initialization subblock.
Each iteration of the loop gives these variables new values using
`{\tt next v}' to refer to the next value of {\tt v}, where {\tt v}
is an iteration variable.  In the example `{\tt i}' and
`{\tt partial sum}' are iteration variables.

An iteration subblock qualified by `\ttkey{while}'
{\em condition-expression}' only executes if the
{\em condition-expression} evaluates to \TT{true},
whereas an iteration subblock qualified by `\ttkey{until}'
{\em condition-ex\-pres\-sion}' only executes if the
{\em condition-expression} evaluates to \TT{false}.

Lastly, when the {\em condition-expression} evaluates so the iteration
subblock is not executed, the finalization subblock
executes, and it must set all the variables in the
loop statement's {\em result-variable-list}.  At this point the loop stops
executing.

Loops are always in effect unraveled so multiple copies of
the iteration subblock exist at one time.

Within the initialization and iteration subblocks assignment
statements may set iteration variables in adjacent subblocks
using the following syntax for assignment statement result variables:
\begin{indpar}
\emkey{iteration-result-variable}\label{ITERATION-RESULT-VARIABLE} ::=
    \ttmkey{next}{iteration result variable}~{\em variable-name}
     $|$ \ttmkey{next next}{iteration result variable}~{\em variable-name}
\end{indpar}
{\em Assignment-statements} that set {\em iteration-result-variables}
are called `\skey{iteration assignment}s'.

Let {\tt v} be an iteration variable.  After it is set in the initialization
subblock, `{\tt v}' refers to the value of the variable in both
the initialization subblock and the first iteration.
`{\tt next v}' refers to the value of the variable in the second
iteration.  In order to prevent confusion, `{\tt v}' cannot
be used in the initialization subblock after `{\tt next v}' has
been assigned, `{\tt next v}' cannot be used in the subblock
except as a result variable when it is assigned, and
`{\tt next next v}' cannot be used in the initialization subblock.

Within the iteration
subblock, `{\tt v}' refers to the value of the variable in the
current iteration, `{\tt next v}' refers to the value of the variable
in the next iteration, and `{\tt next next v}' refers to the
value of the variable in the next iteration after the next iteration.
In order to prevent confusion, `{\tt v}' cannot
be used in the iteration subblock after `{\tt next v}' or
`{\tt next next v}' has been assigned,
and `{\tt next v}' and `{\tt next next v}'
cannot be used in the subblock
except as a result variables when they are assigned.

Within the finalization
subblock, `{\tt v}' refers to the value the variable would have
for an additional iteration if such an iteration existed.
Within the finalization subblock `{\tt next v}' and
`{\tt next next v}' cannot be used.

For a given iteration variable {\tt v},
either the initialization subblock sets {\tt v}
and the iteration subblock sets `{\tt next v}',
or the initialization subblock sets both {\tt v} and `{\tt next v}'
and the iteration subblock sets `{\tt next next v}'.

There are always at least 4 iterations of the loop with variables
simultaneously in the current function frame: the current iteration,
the previous iteration (if any), and the next two iterations.
When the third iteration of the loop starts, the first
iteration can be discarded, and so forth.

Code in an initialization or iteration subblock cannot set
deferred variables outside the subblock (including loop block
result variables), or contain \TT{exit} statements that have
not block label.



\subsection{Call Assignment Statements}
\label{CALL-ASSIGNMENT-STATEMENTS}

Note that functions are most commonly inline, and not out-of-line.
Inline functions are described later
in Section~\itemref{FUNCTION-PROTOTYPES-AND-CALLS}.

\ikey{Call assignment statements}{call assignment}
are used to call out-of-line functions:

\begin{indpar}
\emkey{call-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em call-assignment-option}\STAR
		~\ttkey{call}~ {\em function-expression} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{}
	\end{tabular}
\\[1ex]
\emkey{call-assignment-option}
	\begin{tabular}[t]{rl}
	::= & \ttkey{*UNCHECKED*} $|$ \ttkey{*REVERSE*}
	                          $|$ \ttkey{*NO-RELOAD*} \\
	$|$ & \ttkey{*COMPILE-TIME*} $|$ \ttkey{*COMPILE-TIME-ONLY*}
	\end{tabular}
\\[1ex]
\emkey{argument-assignment-statement} ::=
    \begin{tabular}[t]{l}
    {\em assignment-statement} in which all {\em result-variables} \\
    are {\em result-variable-declarations}
    \end{tabular}
\end{indpar}

The {\em function-expression} evaluates to a function to be called,
and its type $T$ must have the \TT{adr} type as its underlying type.
The values of the variables created by the {\em argument-assignment-statements}
are the arguments to the function.
The results of the function call are stored in the
{\em result-variable-list} variables.

A call assignment must have the \TT{*UNCHECKED*} option
unless $T$ is declared by an out-of-line
function type declaration described below.  If there is no
such declaration, the arguments are presented to the out-of-line
function in the order they are listed in the {\em call-assigment-statement},
unless the \TT{*REVERSE*} option is given, in which case this order
is reversed.

If there is an out-of-line function type declaration, arguments in the
call are matched by name to arguments in the type declaration,
and then ordered as per the type declaration.  In this case
the \TT{*REVERSE*} option is not permitted.

Normally a `\TT{reload mem, mem dependent}'
statement (see \itemref{THE-RELOAD-COMMAND})
is executed automatically
upon returning from the called function, but the
\ttkey{*NO-RELOAD*} option suppresses this.
If the \TT{*NO-RELOAD*} is given, the \TT{*UNCHECKED*} option must
also be given.

If the \TT{*COMPILE-TIME*} option is given, the call
will be made at compile time only if the argument values are available
at compile time, and will otherwise be made at run time.  When the call
is made determines whether any result variable values are determined
at compile time.  If the \TT{*COMPILE-TIME-ONLY*} option is given,
the call is made at compile time, and the argument values must be
available at compile time.

An out-of-line function type declaration has the form:

\begin{indpar}
\emkey{function-type-declaration}\label{FUNCTION-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function type}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{}
		    {\em defined-type-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{}
	\end{tabular}
\\[0.5ex]
\emkey{argument-variable-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{function-declaration-option}
	\begin{tabular}[t]{rl}
	::= & \ttkey{*COMPILE-TIME*} \\
	$|$ & \ttkey{*COMPILE-TIME-ONLY*}
	\end{tabular}
\end{indpar}

This makes \TT{adr} the base type of the new
defined type, and declares the prototype
for the function.
Then a call assignment block is type-checked by matching
the variable names in the call assignment block
to those in the prototype.  Thus in this case the order of variables
in the call block does not matter as they will be matched by
variable name to the prototpye and then their values will be
reordered according to the prototype.  Also, in this case
a call block argument
may be of different
type than corresponding prototype argument if there is an implied
conversion from the call block
argument type to the prototype argument type,
in which case the implied conversion will be invoked.
Similarly a prototype result variable may be converted to
a call block result variable by an implied conversion.

Out-of-line functions are defined by declarations of the form:

\begin{indpar}
\emkey{out-of-line-function-declaration}%
\label{OUT-OF-LINE-FUNCTION-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
		\TT{function}
		    \{ {\em result-variable-list } \TT{=} \}\QMARK{} \\
		\TT{~~~~~~~~}{\em function-declaration-option}\STAR{} \\
		\TT{~~~~~~~~}{\em function-type-name} ~~
		             {\em function-name}\TT{:} \\
		\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
		\TT{~~~~do:} \\
		\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}\label{OUT-OF-LINE-FUNCTIONS}

This defines {\em function-name} to be both a compile-time and run-time
constant (with different values at compile and run time) of type
{\em function-type-name} and also declares {\em function-type-name}
after the manner of a {\em function-type-declaration}.  When the function
is called, the {\em statements} of its `\TT{do}' subblock execute to produce the
result variable values from the argument variable values.

For the function to be callable at compile time, the
\TT{*COMPILE-TIME*} or \TT{*COMPILE-\EOL TIME-\EOL ONLY*} options must be given.
Then the function may not reference Global Areas that
do not have the same options (see Section~\itemref{GLOBAL-AREAS}).
See Section~\itemref{COMPILE-TIME-ASSIGNMENT-STATEMENTS}.
A \TT{*COMPILE-\EOL TIME*} out-of-line function will also be callable at
run time, but a \TT{*COMPILE-\EOL TIME-\EOL ONLY*}
out-of-line function will only be callable
at compile time.

A function type may be declared multiple times.  All these declarations
must be identical except for ordering of options and qualifiers.

Normally the standard call linkage for the computer environment of
the program is used.  Other implementation specific call options
may alter the call linkage used.

\subsection{Out-of-Line Assignment Statements}
\label{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}

An \key{out-of-line assignment statement} is like a combination of
a {\em call-assignment-statement} with
an {\em out-of-line-function-declaration}:

\begin{indpar}
\emkey{out-of-line-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	        {\em function-declaration-option}\STAR
		~\ttkey{out-of-line} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

An {\em out-of-line-function-declaration} is constructed from this statement
by replacing the `\TT{out-\EOL of-\EOL line}' keyword by
an internally generated {\em function-type-name}
and {\em function-name}, and converting each {\em argument-assignment-statement}
to an {\em argument-variable-declaration}.

Then this statement is executed as a {\em call-assign\-ment-statement}
using the {\em function-name} and deleting the `\TT{do}' subblock.

{\em Out-of-line-assignment-statements} are generally included in
inline functions which preprocess arguments and may use various
{\em out-of-line-assignment-statements} to handle complex subcases.
When compiled multiple times in different contexts, the same
{\em out-of-line-assignment-statement} may be optimized in different
ways, and produce different out-of-line functions.  When it produces
the same out-of-line function more than once, this out-of-line function will
\underline{not} be duplicated.


\subsection{Compile-and-Run Assignment Statements}
\label{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS}

A \key{compile-and-run assignment statement} computes a set of
variables that have values constant in a block, then compiles
the block using these constant values to optimize the compilation,
and lastly runs the block:

\begin{indpar}
\emkey{compile-and-run-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
		~\ttkey{compile-and-run} \TT{:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~do} \{ \TT{in} {\em context-expression} \}\QMARK{} \TT{:} \\
	\TT{~~~~~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

The variable values are set by the {\em argument-assignment-statements}.
Then the `\TT{do}' subblock {\em statements} are compiled, using
the variable values to optimize the compilation.
If the `\TT{in} {\em context-expression}' clause is given, the
compilation is in the context given by the clause, instead of the
current context: see \itemref{CONTEXTS}.

Then the
compiled code is executed.  The variables in the {\em result-variable-list}
may be set by either {\em argument-assignment-statements} or
`\TT{do}' subblock {\em statements} as for
a block assignment statement (see \itemref{BlOCK-ASSIGNMENT-STATEMENTS}).
If a variable \TT{v} not in the {\em result-variable-list}
is set by an {\em argument-assignment-statement},
`\TT{next v}' can be set by a `\TT{do}' subblock {\em statement}, but
this will be a new variable whose value may not be available during
the compilation.

When the compile-and-run assignment statement is executed, the compiled
code will be saved in a table indexed by the values of the
variables set by the {\em argument-assignment-statements} and the context
used in compilation.  When the
compile-and-run assignment statement is re-executed, if these
variables have the same values they had during a previous execution,
and if the same context is being used,
the compilation will be bypassed and the previously compiled code used.
This optimization is required, but such previously compiled code
may be discarded if it has not been used in a long time.


\subsection{Compile-Time Assignment Statements}
\label{COMPILE-TIME-ASSIGNMENT-STATEMENTS}

\ikey{Compile-time assignment statements}{compile-time assignment statement}
run only once, when they are compiled, and produce variable values
at compile time:

\begin{indpar}
\emkey{compile-time-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~~~ \ttkey{compile-time:} \\
	\TT{~~~~}{\em statement}\STAR{}
	\end{tabular}
\end{indpar}

A compile-time block has its own stack, which is freed when the
block finishes executing.

Compile time blocks may only use compile time variables and values,
but may use visible inline functions, out-of-line functions
that have been declared to be compile-time, and global areas
that have been declared to be compile-time.

\subsection{Deferred Assignment Statements}
\label{DEFERRED-ASSIGNMENT-STATEMENTS}

\ikey{Deferred assignment statements}{deferred assignment statement}
can only be used in global areas (\itemref{GLOBAL-AREAS}).  They
specify that assigment of the result variables is deferred.

\begin{indpar}
\emkey{deferred-assignment-statement} ::=  \\
\hspace*{0.5in}{\em result-variable-list} \TT{=} \ttkey{deferred}
\end{indpar}

When a variable assignment is deferred, the variable must be
reassigned later in the compilation or loading of the program.
The variable thus appears in many assignment statements, all
within the same global area (but usually not in the same global
block or some code file), and all but the last of these assignments
are deferred.  See bodies: \itemref{BODIES}.

\subsection{Assembly Assignment Statements}
\label{ASSEMBLY-ASSIGNMENT-STATEMENTS}

\ikey{Assembly assignment statements}{assembly assignment statement}
are used to embed assembler instructions in compiled code:

\begin{indpar}
\emkey{assembly-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em result-variable-list} \TT{=} \}\QMARK{}
	    ~\TT{*UNCHECKED*}~\ttkey{*ASSEMBLY*:} \\
	\TT{~~~~}{\em argument-assignment-statement}\STAR{} \\
	\TT{~~~~}{\em argument-variable-declaration}\STAR{} \\
	\TT{~~~~do:} \\
	\TT{~~~~~~~~}{\em assembler-instruction}\STAR{} \\
	\end{tabular}
\end{indpar}

The variables, those produced by the {\em argument-assignment-statements},
the {\em argument-variable-declarations},
and the result variables, are placed in machine registers
and their names become machine register names for the assembler instructions.
Assembler instructions are only permitted to reference these
machine registers, but load and store assembler instructions may be used.
The assembler instructions are written in the syntax of one of the
target machine assemblers.

The variables may have additional qualifiers which
are names of machine registers or groups of machine registers.  In this case
the variables will be allocated to the specified machine registers or
machine register groups.  Otherwise they will be allocated to target
machine specified register groups based on variable type.

The {\em argument-variable-declarations} list intermediate
variables.  Only the variables named in the {\em argument-assignment-statements}
are given initial values.  Unlike normal code, values of variables
of an {\em assembly-assignment-statement} can be overwritten by the
{\em assembler-instructions}, and there is no check to be sure that
result variables receive any value.

\section{Function Prototypes and Calls}
\label{FUNCTION-PROTOTYPES-AND-CALLS}

Inline functions are declared by {\em function-declarations}
that contain a {\em function-prototype} and the code body of the
function.  Note that inline functions cannot be called recursively.

The syntax is:

\begin{indpar}
\emkey{function-declaration}\label{FUNCTION-DECLARATION}
    ::= \begin{tabular}[t]{l}
        {\em function-prototype} \TT{:} \\
	\TT{~~~~~}{\em statement}\PLUS{}
	\end{tabular}
\\[2ex]
\emkey{function-prototype}\label{FUNCTION-PROTOTYPE}
    \begin{tabular}[t]{@{}rl}
    ::= & \ttkey{function} ~
          {\em prototype-result-variable-list} ~ \TT{=} \\
        & \TT{~~~~~}{\em module-abbreviation}\QMARK{}
	                ~ {\em function-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em function-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em function-pattern} ~ \TT{=} \\
        & \TT{~~~~~}{\em input-variable-list} \\
    $|$ & {\em function-prototype} \TT{[*} {\em conditioner} \TT{*]}
    \end{tabular}
\\[0.5ex]
\emkey{prototype-result-variable-list} ::= \\
\hspace*{0.5in}
    {\em result-variable-declaration}
    \{ \TT{,} {\em result-variable-declaration} \}\STAR{}
\\[0.5ex]
{\em result-variable-declaration} ::= see \pagref{RESULT-VARIABLE-DECLARATION}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
\emkey{input-variable-list}
    ::= {\em first-input-argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{}
\\[0.5ex]
\emkey{first-input-argument-declaration} ::= {\em argument-declaration}
	without a {\em default-value}
\\[0.5ex]
\emkey{function-pattern}\label{FUNCTION-PATTERN}
    ::= {\em first-prototype-term} ~ {\em prototype-term}\STAR{}
\\[0.5ex]
\emkey{first-prototype-term} ::= {\em prototype-argument-list}\STAR{} ~
				{\em prototype-term}
\\[0.5ex]
\emkey{prototype-term}
    ::= {\em function-term-name} ~ {\em prototype-argument-list}\PLUS{}
\\[0.5ex]
\emkey{function-term-name} ::= {\em name} \underline{not} containing `\TT{.}'
                                ~~~~~ [see \pagref{NAMES}]
\\[0.5ex]
\emkey{initial-function-term-name}\label{INITIAL-FUNCTION-TERM-NAME} ::=
    \begin{tabular}[t]{@{}l@{}}
    first {\em function-term-name} in any {\em function-pattern} \\
    that does not begin with a {\em prototype-argument-list} \\
    and does not follow an \TT{=} in the {\em function-prototype} \\
    (an {\em initial-function-term-name} may begin a {\em statement}) \\
    \end{tabular}
\\[0.5ex]
\emkey{prototype-argument-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{argument-declaration}
    ::= {\em type-name} {\em variable-name}
        \{ \TT{?=} {\em default-value} \}\QMARK{}
\\[0.5ex]
\emkey{qualifiers-argument-declaration} ::= \TT{qualifiers} {\em variable-name}
\\[0.5ex]
\emkey{type-argument-declaration} ::= \TT{type} {\em variable-name}
\\[0.5ex]
\emkey{default-value} ::= \TT{??} $|$ {\em expression}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[0.5ex]
\emkey{conditioner}\label{CONDITIONER}
    \begin{tabular}[t]{@{}rl@{}}
    ::= & {\em logical-conditioner} \\
    $|$ & {\em qualifiers-conditioner} \\
    $|$ & {\em type-conditioner} \\
    \end{tabular}
\\[0.5ex]
\emkey{logical-conditioner}\label{LOGICAL-CONDITIONER}
    ::= {\em logical-expression}
\\[0.5ex]
\emkey{qualifiers-conditioner}\label{QUALIFIERS-CONDITIONER}
    ::= \TT{qualifiers} {\em variable-name} \TT{=} {\em expression}
\\[0.5ex]
\emkey{type-conditioner}\label{TYPE-CONDITIONER}
    ::= \TT{type} {\em variable-name} \TT{=} {\em expression}
\\[2ex]
\emkey{function-call}\label{FUNCTION-CALL}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em module-abbreviation}\QMARK{} ~ {\em first-call-term}
          ~ {\em call-term}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{first-call-term} ::= {\em call-argument-list}\STAR{}
				{\em call-term}
\\[0.5ex]
\emkey{call-term}
    ::= {\em function-term-name} {\em call-argument-list}\STAR{}
\\[1ex]
\emkey{call-argument-list}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em actual-argument}
                 \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{]} \\
    $|$ & \TT{()} $|$ \TT{[]} \\
    \end{tabular}
\\[0.5ex]
\emkey{actual-argument} ::= {\em expression}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}

\begin{itemize}
\item
A {\em function-prototype} {\em function-term-name} must not be
an initial segment of any other {\em function-term-name}
in the same {\em function-prototype}.
\item
An {\em initial-function-term-name}
must not have a {\em qualifier-name} or {\em type-name} as an initial segment.
(see Type Name Rule, \pagref{TYPE-NAME-RULE}).
\item
\TT{"="} cannot be used as a {\em function-term-name}
in a {\em function-prototype}.
\item
All the {\em variable-names} in a {\em function-prototype} must
be distinct.
\item
The {\em variable-name} in a {\em qualifiers-argument-declaration}
or a {\em qualifiers-conditioner} is treated as a {\em qualifier-name}
within the {\em function-prototype}.
\item
The {\em variable-name} in a {\em type-argument-declaration}
or a {\em type-conditioner} is treated as a {\em type-name}
within the {\em function-prototype}.
\item
In a {\em prototype-argument-list} or {\em input-variable-list}
an {\em argument-declaration} with no {\em de\-fault-value} cannot
follow an {\em argument-declaration} with a {\em default-value}.

\end{itemize}
\end{indpar}

A {\em function-call} with a {\em result-variable-list}
is in effect replaced by a {\em block-assignment-statement}
(Section~\itemref{BLOCK-ASSIGNMENT-STATEMENTS})
with the {\em function-declaration's} {\em result-variable-list} becoming the 
{\em result-variable-list} of the {\em block-assignment-statement} and the
{\em function-declaration's} {\em statements} becoming the 
{\em block-\EOL assign\-ment-\EOL state\-ment's} subblock {\em statements}.
Actual argument values from the function call are assigned to variables in
the {\em function-declaration's} {\em argument-lists}.  The values produced in
the declaration's {\em result-variable-list's} variables
become the values of the {\em function-call}.

A function call without any {\em result-variable-list}
is just like a function call with an empty
{\em result-variable-list}.

A function call with an {\em input-variable-list} is just syntactic
sugar for a function call with neither a {\em result-variable-list}
or {\em input-variable-list}.  Specifically
\begin{center}
{\tt F(a1,a2,...)~=~(b1,b2,...)} \\
is syntactic sugar for \\
{\tt F(a1,a2,...)~"="~(b1,b2,...)} \\
\end{center}

in which a term with \TT{"="} as its {\em function-term-name} is
placed at the end of the function call.

The context (\pagref{CONTEXT})
in which the replacing block {\em statements} are executed
is the context of the {\em function-declaration}, and
\underline{not} the context of the {\em function-call}.

All the names declared in the block replacing the {\em function-call}
have the word \TT{C\$$n$} prepended to them to make them unique,
where $n$ is a natural number unique to the {\em function-call}.
But names used and not declared in the replacing block are
resolved in the context of the {\em function-declaration}.

An {\em argument-declaration} can be a {\em type-argument-declaration}
of the form `{\tt type T}' for some {\em variable-name} {\tt T}.
This makes {\tt T} into a {\em type-name} within the {\em function-declaration}
containing the {\em type-argument-declaration}.  Also it allows the
actual value of {\tt T} to be implied by a {\em function-call}.
If an explicit value of {\tt T} is given in the call, that is used.
Otherwise if {\tt T} is the type of a prototype result variable, and there
is a corresponding {\em function-call} result variable, the type of
that result variable is assigned as the value of {\tt T}.  Otherwise
if {\tt T} is the type of some prototype argument variables, and
the actual values of some of those variables in the call have
natural types (\pagref{NATURAL-TYPE}), {\tt T} is assigned the least
upper bound (\pagref{LEAST-UPPER-BOUND}) of these types (if there
is no least upper bound the {\em function-prototype} does not
match the {\em function-call}).


For example,
\begin{indpar}\begin{verbatim}
function ( T result ) = add ( type T, T v1, T v2 ):
    result = v1 + v2

// Example usage
//
int32 x = ...
int32 y = ...
int32 z = add ( int32, x, y )  // T is explicitly given
next z = add ( x, y )          // T = uns32 is implied
\end{verbatim}\end{indpar}

An {\em argument-declaration} can be a {\em qualifiers-argument-declaration}
of the form `{\tt qualifiers Qs}' for some {\em variable-name} {\tt Qs}.
This makes {\tt Qs} into a {\em qualifier-name}
within the {\em function-de\-clar\-a\-tion}
containing the {\em type-argument-declaration}.  Note that {\tt Qs}
is used like a {\em qualifier-name}, but its value is a set of
zero or more qualifiers.

The actual value of {\tt Qs} to be implied by a {\em function-call}.
If an explicit value of {\tt Qs} is given in the call, that is used.
Otherwise if {\tt Qs} is the given as the \underline{only} qualifier
of a prototype result variable, and there is a corresponding {\em function-call}
result variable, the qualifiers of that call result variable are
assigned as the value of {\tt Qs}.  Otherwise
if {\tt Qs} is given as the \underline{only} qualifier
of some prototype argument variables,
and the actual values of some of those variables in the call have
natural types (\pagref{NATURAL-TYPE}), {\tt Qs} is assigned the union
of the qualifiers for these actual values.


For example,
\begin{indpar}\begin{verbatim}
define required protected required qualifier in-range
define required prohibited qualifier ouch
function Qs in-range T r =
        check ( qualifiers Qs, type T, Qs T v ):
    if:
        v < 0:
            error "argument < 0"
        v > 100:
            error "argument > 100"
        else:
            result = v

function F ( in-range v ):
    ... function body omitted ...

// Example usage
//
ouch int32 x = ...
ouch int32 y1 = check ( x )
           // Legal: check prototype becomes:
           //   ouch in-range r = check ( ouch int32 v )
           // so argument can have qualifier ouch,
           // and y1 must have qualifier ouch.
int32 y2 = check ( x )
           // Illegal, result `ouch in-range r' cannot
           // be converted to y2 which has no `ouch'
           // qualifer.
F ( x )    // Illegal, x does not have protected in-range
F ( y1 )   // Legal, y1 has protected in-range
\end{verbatim}\end{indpar}

{\em Conditioners} can be written at the end of a {\em function-prototype},
as in:
\begin{indpar}\begin{verbatim}
types signed-integer-types =
    { int8, int16, int32, int64, int128 }

function ( T result ) = add ( type T, T v1, T v2 )
    [* T is in signed-integer-types *]:
    result = v1 + v2
\end{verbatim}\end{indpar}

which would define `\TT{add}' only for signed integer types.
Here the conditioner is a {\em logical-ex\-pres\-sion} that must
be evaluatable whenever a call to the function is compiled.

Another example is:
\begin{indpar}\begin{verbatim}
function Qs2 T r = inc ( qualifiers Qs1, type T, Qs1 T v )
    [* qualifiers Qs2 = Qs1 - { stack } *]:
    return v + 1
\end{verbatim}\end{indpar}

which returns {\tt v+1} with the same qualifiers as {\tt v}
except for the `{\tt stack}' qualifier which is removed.
Here the rightside of the {\em qualifiers-conditioner}
must be evaluatable whenever the function is compiled.

A third example is:
\begin{indpar}\begin{verbatim}
function ( T r1, T r2 ) =
        sort2 ( type T, T x, T y, name less-than )
        [* lt ---> less-than *]
    if:
        lt ( x, y ):
            r1 = x; r2 = y
        else
            r1 = y; r2 = x

// Function that is like < except it makes a NaN less than
// a non-NaN ( < is false if either argument is NaN ).
//
function bool r = less-than-float64 ( float64 x, float64 y ):
    if:
        is-NaN ( y ):
            r = false
        is-NaN ( x ):
            r = true
        x < y:
            r = true
        else:
            r = false

float64 b1 = 5.37857
float64 b2 = 5.37289
( float64 c1, float64 c2 ) =
    sort2 ( b1, b2, `less-than-float64' )
\end{verbatim}\end{indpar}

Here the name of a function, {\tt `less-than-float64'}, is
passed as an argument and used by an {\em abbreviation-conditioner}.

Note, however, that as names in a function block are resolved in the context
of the function block declaration, and not in the context of a
call, the following fails:
\begin{indpar}\begin{verbatim}
function ( T r1, T r2 ) = sort2 ( type T, T x, T y ):
    if:
        less-than ( x, y ):
            r1 = x; r2 = y
        else
            r1 = y; r2 = x

// Function that is like < except it makes a NaN less than
// a non-NaN ( < is false if either argument is NaN ).
//
function bool r = less-than ( float64 x, float64 y ):
    if:
        is-NaN ( y ):
            r = false
        is-NaN ( x ):
            r = true
        x < y:
            r = true
        else:
            r = false

float64 b1 = 5.37857
float64 b2 = 5.37289
( float64 c1, float64 c2 ) = sort2 ( b1, b2  )
    // Illegal because `less-than' in sort2 declaration
    // was not defined when sort2 was declared.
\end{verbatim}\end{indpar}

The body of an inline function is parsed, but it is not checked for
errors before the function is called.  When the function is called,
compile time values passed as arguments may cause parts of the body
to never be compiled or checked for compilation errors.  If a function
is never called, it may contain code that would have compilation errors
were the function called, such as calls to non-existent functions.

\subsection{Matching Function Calls to Prototypes}
\label{MATCHING-FUNCTION-CALLS-TO-PROTOTYPES}

To compile a {\em function-call} it must be matched to a
single {\em function-prototype}.  If it matches more than one
{\em function-prototype}, the call is ambiguous and is a compilation error

The matching algorithm, given a {\em function-call} and a
{\em function prototype}, is as follows:

\begin{enumerate}

\item
If the {\em function-call} is in a statement of the form
\begin{center}
{\em function-call} ~ \TT{=} ~ {\em expression-list}
\end{center}
the {\em function-prototype} must be of the form
\begin{center}
{\tt function} ~ {\em function-pattern} ~ {\tt =} ~ {\em input-variable-list} \\
\end{center}
and the following will be done:
\begin{enumerate}
\item `\TT{=}' will be treated in the following as if it were the
{\em function-term-name} \TT{"="}.
\item{\em expression-list} is parenthesized.
\item {\em input-variable-list} is parenthesized.
\end{enumerate}

For example, the prototype
\begin{center}
\tt function F ( int64 i ) = int32 x, int32 y
\end{center}
behaves as if it were
\begin{center}
\tt function F ( int64 i ) "=" ( int32 x, int32 y )
\end{center}
and the assignment statement
\begin{center}
\tt F ( i ) = x, y
\end{center}
behaves as if it were the function call with no result variables
\begin{center}
\tt F ( i ) "=" ( x, y )
\end{center}

\item If the {\em function-call} begins with a {\em module-abbreviation}
(see \pagref{MODULE-ABBREVIATION}), the {\em function-prototype}
must begin with a {\em module-abbreviation}, and the two
{\em module-abbreviations} must reference the same module file
(see \itemref{MODULES}).

\item If the {\em function-call} does \underline{not} begin
with a {\em module-abbreviation}, but the {\em function-prototype}
does begin with a {\em module-abbreviation}, the match is marked
as `\key{module deficient}'\label{MODULE-DEFICIENT},
and will be disallowed later if there is
another match that is not module deficient.

\item
The {\em function-term-names} in the {\em function-call} are matched to
{\em function-term-names} in the {\em function-prototype} by a left to right
scan of the {\em function-call}.  Since {\em function-term-names} in the
{\em function-prototype} cannot be initial segments of each other,
this match will be unique even if argument lists are missing
from the {\em function-call}.  If this {\em function-term-name} match
cannot be made, the match fails.

\item The first {\em function-term-name} in the {\em function-call}
must match the first {\em function-term-name} in the {\em function-prototype},
else the match fails.

\item The {\em call-terms} after the first in the {\em function-call}
are reordered so the {\em function-term-names} in the {\em function-call},
taken in order, are a subsequence of the {\em function-term-names} in the
{\em function-prototype}.
If this cannot be done, the match fails.

\item\label{ADD-TERMS}
If some of the prototype {\em function-term-names} are missing from the call,
new {\em call-terms} without argument lists
are inserted in the call to match the missing
{\em prototype-terms}.  At this point there is a 1-1 correspondence
between {\em call-terms} and {\em prototype-terms}.

\item
If some of the {\em prototype-terms} have argument lists that
are missing in the matching {\em call-terms}, empty argument lists
with the same type of bracket, \TT{()} or \TT{[]}, are inserted.
If this cannot be done \underline{unambiguously}
so each {\em prototype-term} argument
list is matched to an argument list of the associated {\em call-term}
that has the same type of bracket, then the match fails.

\item
If the prototype has cluster member arguments or result variables,
these must be implied, and they are added to the {\em function-call}
at this point.  See \pagref{CLUSTER-ARGUMENTS} for details.

\item
The first of the following rules that is applicable is applied,
and then this is done repeatedly until none of the following
rules apply:

\begin{enumerate}

\item
If a prototype argument list begins with a {\em type-argument-declaration}
and the matching actual argument list begins with an
actual argument that is a compile time value that is a type,
the {\em variable-name} of the {\em type-argument-declaration}
is given this value and the {\em type-argument-declaration}.
Otherwise this rule does not apply.

If this rule applies, the {\em type-argument-declaration}
is removed from the beginning of its argument list.

\item
If a prototype argument list begins with a {\em type-argument-declaration}
(and the previous rule does not apply)
then the type argument is implied.  If the {\em variable-name}
in the {\em type-argument-declaration} is used as the {\em type-name}
of a prototype result variable with a matching actual result,
the type of the actual result is assigned as the value of the
{\em variable-name}.  Otherwise if the {\em variable-name}
is used as the {\em type-name} of several arguments whose matching
actual arguments have natural types, and the set of these types
has a least upper bound, this least upper bound is assigned as the
value of the {\em variable-name}.
Otherwise this rule does not apply.

If this rule applies, the {\em type-argument-declaration}
is removed from the beginning of its argument list.

\item
If a prototype argument list begins with a {\em qualifiers-argument-declaration}
and the matching actual argument list begins with an
actual argument that is a compile time value that is a qualifiers set,
the {\em variable-name} of the {\em qualifiers-argument-declaration}
is given this value.
Otherwise this rule does not apply.

If this rule applies, the {\em qualifiers-argument-declaration}
is removed from the beginning of its argument list.


\item
If a prototype argument list begins with a {\em qualifiers-argument-declaration}
(and the previous rule does not apply)
then the qualifiers argument is implied.  If the {\em variable-name}
in the {\em qualifiers-argument-declaration} is used as the sole
{\em qualifier-name} of a prototype result variable with a matching
actual result, the qualifiers of the actual result is assigned as the
value of the {\em variable-name}.  Otherwise if the {\em variable-name}
is used as the sole {\em qualifier-name} of several arguments whose matching
actual arguments have natural types, and the union of the sets of qualifiers
of these arguments is assigned as the
value of the {\em variable-name}.
Otherwise this rule does not apply.

If this rule applies, the {\em type-argument-declaration}
is removed from the beginning of its argument list.

\end{enumerate}

\item
If some of the actual argument lists are too short, they are extended
by adding the {\em default-values} of their matching prototype
arguments.  As a special case, if a {\em default-value} is `\TT{??}',
the actual {\em default-value} used is \TT{true} if the {\em function-term-name}
appeared in the original function call and was not added in
Step~\ref{ADD-TERMS} above, or is \TT{false} if the {\em function-term-name}
did not appear in the original function call, but was added in
Step~\ref{ADD-TERMS}.
If any of the arguments that
need to be inserted do not have {\em default-values}, the match
fails.

Otherwise the revised function call is referred to as the
`\mkey{unfolded}{function call}' {\em function-call}.

The unfolded {\em function-call} now matches
the {\em function-prototype} in {\em function-term-names},
location and number of argument lists, type of bracket, i.e. \TT{()} or
\TT{[]} for each argument list, and number of arguments in each
list.

Note that since default values are evaluated in the context of
the {\em function-declaration}, if they can be evaluated at compile-time,
they will already have been evaluated and are constants at this point.

\item
The {\em conditioners} in the {\em function-prototype} are evaluated
in order.  If any of the expressions in them do not have compile-time
values, the match fails.  If any {\em logical-conditioner} evaluates
to \TT{false}, the match fails.

\item If the unfolded {\em function-call} has {\em actual-argument}
expressions $e1$, $e2$, \ldots{} read from left to right
(including {\em default-values}),
and the {\em function-prototype} has (non-result)
{\em argument-declarations} `$Qs1$ $T1$ $v1$', `$Qs2$ $T2$ $v2$', \ldots{}
read from left to right, where the $Qs\ldots$ are possibly empty
qualifier sets and the $T\ldots$ are types,
then the statement containing the
revised {\em function-call} is replace by:
\begin{indpar}
{\tt $Qs1$ $T1$ $tmp1$ = $e1$} \\
{\tt $Qs2$ $T2$ $tmp2$ = $e2$} \\
\ldots\ldots\ldots\ldots \\
statement containing {\em function-call}
with each {\em actual-argument} $eI$ replaced by $tmpI$
\end{indpar}

If all the statements `{\tt $QsI$ $TI$ $tmpI$ = $eI$}' can be compiled
without error, the match succeeds.

If any of the statements `{\tt $QsI$ $TI$ $tmpI$ = $eI$}' cannot be compiled
for a reason other than an ambiguity error, the match fails.

Otherwise the match is `\key{ambiguity deficient}' (and will be
rejected later, possibly for another reason).

\item \label{FUNCTION-CALL-ASSIGNMENT-COMPILATION}
If the {\em function-call} is in a statement of the form
\begin{center}
{\tt $QCs1$ $TC1$ $VC1$, $QCs2$ $TC2$ $VR2$, \ldots{}~=~}{\em function-call}
\end{center}
with at least one result variable,
the {\em function-prototype} must be of the form
\begin{center}
{\tt function $QRs1$ $TR1$ $VR1$, $QRs2$ $TR2$ $VR2$,
     \ldots{}~=~}{\em function-pattern}
\end{center}
with at least as many result variables in the prototype as in
the {\em function-call} statement.  The statement is then
replaced by:
\begin{indpar}
{\tt $QRs1$ $TR1$ $tmp1$, $QRs2$ $TR2$ $tmp2$,
    \ldots{}~=~}{\em function-call} \\
{\tt $QCs1$ $TC1$ $VC1$ = $tmp1$} \\
{\tt $QCs2$ $TC2$ $VC2$ = $tmp2$} \\
\ldots\ldots\ldots\ldots
\end{indpar}
If any of the `{\tt $QCsI$ $TCI$ $VC1$ = $tmpI$}' statements cannot be
compiled because $QRsI$ $TRI$ is not implicitly convertible
to $QCsI$ $TCI$, the match fails.  Note that extra prototype result variables
are never used and are ultimately ignored.

If $QRs1$ $TR1$ and $QCs1$ $TC1$ are not equal
(but $QRs1$ $TR1$ values are implicitly
convertible to $QCs1$ $TC1$ values), the match is marked
`\key{conversion deficient}'\label{CONVERSION-DEFICIENT},
and will be disallowed later
if there is another match that is not conversion deficient.
Note that only the first result variable is considered by this rule.

\item If the {\em function-call} has no result variables, the
{\em function-prototype} must have no result variables.

\end{enumerate}


The first step in compiling a {\em function-call} is to compute the
set of matches of that call.  Then the following is done in order:

\begin{enumerate}

\item If there is any match that is not conversion deficient, then
all conversion deficient matches are discarded.

\item If there is any remaining match that is not module deficient, then
all module deficient matches are discarded.

\item Let $e1$, $e2$, \ldots{}~be the argument expressions of
the not-unfolded original {\em function-call}, read from left to right.
If there are two matches $X$ and $Y$ such that
$TX1$, $TX2$, \ldots{}~are the types of the $X$ prototype argument
variables assigned to $e1$, $e2$, \ldots{}~in order, and
$TY1$, $TY2$, \ldots{}~are the types of the $Y$ argument
variables assigned to $e1$, $e2$, \ldots{}~in order,
and values of type
$TXi$ are implicitly convertible to values of type $TYi$ for
every $i$,
then the $Y$ match is discarded.

\item If after discarding matches as above, there are no matches,
the {\em function-call} is `\key{unmatched}' and cannot be compiled.

\item If after discarding matches as above, there is a match left
with an ambiguity deficiency,
the {\em function-call} is `\key{ambiguous}' and cannot be compiled.

\item If after discarding matches as above, there is more than one
match left,
the {\em function-call} is `\key{ambiguous}' and cannot be compiled.

\item Otherwise there is just one match left, and that
match has no ambiguity deficiency.  That match
is accepted and used to compile the {\em function-call}.
\end{enumerate}

As an application of these rules consider the example:
\begin{indpar}\begin{verbatim}
// mymod is module abbreviation of current module.
//
type mymod T is packed tuple:
    int32 x
    int32 y
type mymod PV is pointer to vector of mymod T
type mymod PE is pointer to mymod T
mymod PV p = NULL
    // Of the many NULL functions, only one has
    // result type mymod PV.  Another with
    // result type mymod PE is conversion deficient.
    // Both are module deficient.  So the one with
    // type mymod PV is chosen.
\end{verbatim}\end{indpar}

\section{Includes}
\label{INCLUDES}

An \key{include statement} invokes compile time code that
generates code which replaces the include statement in the compiler
input.  The statement has the form:


\begin{indpar}
\emkey{include-statement} ::=
    \ttkey{include} {\em include-assignment-statement}
\\[0.5ex]
\emkey{include-assignment-statement} ::=
    \begin{tabular}[t]{l}
    {\em assignment-statement} without {\em result-variables} \\
    completely executable at compile time
    \end{tabular}
\end{indpar}

The {\em include-assignment-statement} is executed at
compile time code and contains \skey{include block}s that generate
the code that replaces the {\em include-statement}.  These have
the syntax:

\begin{indpar}
\emkey{include-block} ::=
        \begin{tabular}[t]{l}
	\ttkey{include}\TT{:} \\
	~~~~~ {\em statement}\STAR{}
	\end{tabular}
\end{indpar}

When executed at compile time the {\em include-block} statements
are not executed but are added to the list of statements that
will replace the invoking {\em include-statement}.  Before being
added any abbreviations or variables in the statements that have
compile time values within the context of the {\em include-block}
are substituted for.  The compile time code executed by an
{\em include-statement} may execute many {\em include-blocks},
and the statements produced by these are concatenated in the
order of block execution.

An example is:
\begin{indpar}\begin{verbatim}
function min-max functions ( type T )
    include:
        function T result = min ( T x, T y ):
            result = if:
                x <= y:
                    result = x
                y <= x:
                    result = y
                T is in floating-types:
                    result = NaN
        function T result = max ( T x, T y ):
            result = - min ( -x, -y )

include min-max functions ( int64 )
int64 u = ...
int64 v = min ( u, -1,000,000 )
int64 w = max ( u, 1,000,000 )
\end{verbatim}\end{indpar}

The special conditional assignment statement
rules described on page \pageref{CONDITIONAL-SPECIAL-RULES}
are applied here to enable \TT{T} to be any integer or
floating point number type.

\section{Scopes and Modules}
\label{SCOPES-AND-MODULES}

A \key{declaration} is a statement the defines names that
can be referenced in code.  {\em Function-declara\-tions}
and {\em generic-declarations} are declarations.
{\em Global-blocks} are declarations.
Assignment statements also
introduce the names of their result variables, and serve
as declarations of these result variables.

Code is organized into two kinds of files: \skey{module}s
and \ikey{bodies}{body}.  Names shared
between modules begin with {\em module-abbreviations}
that designate the module in which the name is declared.
Such names are called `\key{external}'.

External names can only be declared in module files, and
never in body files.
When names are used, the {\em module-abbreviation} may
be omitted if the declaration defining the name can be
unambiguously determined and is a function declaration.

\subsection{Scope}
\label{SCOPE}

A declaration statement has
a \key{scope}, that is the set of statements in which any
names defined by the declaration is recognized.  The scope
of a declaration that is inside a block
begins just after the declaration itself, and
lasts to the end of smallest block containing the declaration.
A name declared inside a block may not be external and
must \underline{not} begin with a {\em module-abbreviation}.

A declaration not inside a block is said to be `\key{top level}'.
If a result variable name in a top level declaration \underline{begins} with
the {\em module-abbreviation} of the containing module,
the name is `\key{external}'.
If the part of a function or generic prototype that is after any \TT{=}
in a declaration begins with the {\em module-abbreviation} of the
containing module, the declaration
is external.
Other top level names and declarations are `\key{internal}'.

A module contained within a module file has a {\em module-abbreviation}
effective within the file.
External names and declarations in the file with this
{\em module-abbreviation} are `\skey{export}{ed}' to
other modules.
External names and declaration usages in the file with other
{\em module-abbreviations} are `\skey{import}{ed}' from other
modules.

An example is:
\begin{indpar}\begin{verbatim}
module "my_own_module" as mom:
    import "George's_own_module" as gom
    // gom contains:
    //    int32 z = gom (int32 x) "+" (int32 y)
mom int32 x = ...
function int32 y = mom my external function ( int32 x )
function int32 y = my internal function ( int32 x )
int32 y = my external function ( x )
int32 zg = gom x + y    // Uses gom's + operator.
int32 zg = std x + y    // Uses builtin std's + operator.
int32 z  = x + y        // Ambiguous: either std + operator
                        // or gom's + operator.
\end{verbatim}\end{indpar}\label{EXTERNAL-INTERNAL-EXAMPLE}

There is a builtin standard module with abbreviation `\TT{std}'
that is always implicitly imported.  The standard module defines
the builtin language operators and functions.

The scope of a top level declaration includes the statements
after the declaration in the declaration's containing module.
For an internal declaration, this is the entire scope of
the declaration.

The scope of an external top level declaration also includes
all modules and bodies that import the module containing the declaration.
Note that the module abbreviation used to name the
module in an importing module or body
may differ from the module abbreviation
used to name the module in the exporting module.

The scope of a name is the scope of the declaration that defines
it.

Two different declarations of the same name may \underline{not}
have overlapping scope, except when the second declaration is
for `\TT{next} {\em variable-name}' and both declarations are
in the same smallest containing block.

The scope of a name consists of statements and subblocks.
By the last rule, a name may not be
redeclared in a subblock that is in the name's scope.
So `\TT{next v}' cannot be declared in a subblock that is inside the scope
of `\TT{v}'.  Also by the last rule, `\TT{next v}' cannot be used
at top level.

When a function declaration is used, the {\em module-abbreviation}
following any \TT{=} may be omitted if the function declaration is
the only function declaration within scope that matches the usage.
Thus in the context of the above example the lines:
\begin{indpar}\begin{verbatim}
int32 y = mom my external function ( x )
int32 y = my external function ( x )
\end{verbatim}\end{indpar}
are equivalent provided no imported module defines `\TT{my external function}'
with one \TT{int32} argument.

\subsection{Modules}
\label{MODULES}

A \key{module} is a file that begins with a {\em module-declaration}:

\begin{indpar}
\emkey{module-declaration}
    \begin{tabular}[t]{rl}
    ::= & {\em simple-module-declaration} \\
    $|$ & {\em simple-module-declaration}\TT{:} \\
	& \TT{~~~~}{\em module-import-clause}\STAR{} \\
    \end{tabular} \\
\emkey{simple-module-declaration} ::= \TT{module} {\em module-name}
        \TT{as} {\em module-abbreviation} \\
\emkey{module-name} ::= {\em quoted-string} \\
\emkey{module-abbreviation} ::= \TT{word} not containing any `\TT{.}'s \\
\emkey{module-import-clause} ::= \TT{import} \TT{`}{\em module-name}\TT{'}
        \TT{as} {\em module-abbreviation}
\end{indpar}

A {\em module-name} is a UNIX file name without its final extension.
The {\em module-name} of a {\em module-declaration} must match the
non-extension part of the name of the file containing the
{\em module-declaration}, relative to one of several directories
specified separately to the compiler.

The module declared by a {\em module-declaration} is within the scope
of the external declarations of modules imported by the
{\em module-declaration}.  The {\em module-abbreviations} used in this
module to refer to these declarations are those associated with the
{\em module-names} by the {\em module-import-clauses}
in the {\em module-declaration}.
The scope of these {\em module-abbreviations} is just the module
begun by the {\em module-declaration}, and not any other module.
In otherwords, {\em module-abbreviations} are always internal, and
never external.
Therefore the abbreviation for a given {\em module-name}
may be different in different modules.

Several imported modules may be given the same module abbreviation,
but imported module abbreviations must not be the same as the
importing module abbreviation.

The UNIX wildcards `\TT{*}' and `\TT{?}' can be used in the
{\em import-clause} {\em module-name} to name multiple modules
in a single {\em import-clause}.  These wildcards cannot be
used in the {\em module-name} of the {\em simple-module-declaration}.

If we consider the conceptual directed graph whose nodes
are modules and whose arrows connect each module to the
modules it imports, then this graph \underline{must be acyclic}.


\subsection{Bodies}

A \key{body}
is a file that begins with an {\em body-declaration}:

\begin{indpar}
\emkey{body-declaration}
    \begin{tabular}[t]{rl}
    ::= & {\em simple-body-declaration} \\
    $|$ & {\em simple-body-declaration}\TT{:} \\
	& \TT{~~~~}{\em body-clause}\STAR{} \\
    \end{tabular} \\
\emkey{simple-body-declaration} ::= \TT{body} {\em body-name} \\
\emkey{body-name} ::= {\em quoted-string} \\
\emkey{body-clause} ::= {\em module-import-clause}
                    $|$ {\em body-after-clause} \\
\emkey{body-after-clause} ::= \TT{after} {\em body-name}
\end{indpar}

A \key{body} is just like a module except it has no
abbreviation or external declarations
and cannot export names or declarations.

A body contains out of line function code and assignments
for deferred global variables.

Global variables in exported global areas must be declared
in modules, but their assignment may be deferred to a body
or another module.

The \key{order graph} is the graph whose nodes
are modules and bodies and whose arrows connect each module or body to the
modules it imports and bodies it is after.  The descendents of a module
or body in this graph are compiled (or loaded) before the module or body
is compiled (or loaded).

It is an error to evaluate deferred global variable
at compile time if the global variable is not assigned a value
previously in the evaluating module or body or in one of its
descendents in the order graph.

An example is a deferred global variable whose value is a function
generated by an {\em out-of-line-function-declaration}
(\pagref{OUT-OF-LINE-FUNCTIONS}).  If the variable is used to
call the function at compile (or load) time, the 
{\em out-of-line-function-declaration} must appear previously in
in the module or body using the variable, or must appear in one of its
descendents in the order graph.

\subsection{Contexts}
\label{CONTEXTS}

A \key{context} is a set of module name/abbreviation pairs.
A {\em module-declaration} defines a context in which the
code of the module is compiled, and similarly an
{\em body-declaration} defines a context in which the
code of the body is compiled.

Contexts can also be computed, stored in variables and
passed as arguments, and code in a \TT{com\-pile-\EOL and-\EOL run}
assignment statement
(\pagref{COMPILE-AND-RUN-ASSIGNMENT-STATEMENTS})
can be compiled in a computed context.  Contexts have the type:
\begin{indpar}
\TT{type~}\ttkey{context}\TT{~is adr}
\end{indpar}
The only expression that can be used to compute a new context is:

\begin{indpar}
\emkey{context-expression}
    \begin{tabular}[t]{rl}
    ::= & \TT{new context:} \\
	& \TT{~~~~}{\em context-import-clause}\STAR{} \\
    \end{tabular} \\
\emkey{context-import-clause}
    \begin{tabular}[t]{rl}
    ::= & {\em module-import-clause} \\
    $|$ & \TT{import} {\em context-expression} \\
    $|$ & \TT{import current} \\
    \end{tabular}
\end{indpar}

A {\em context-expression} in a {\em context-import-clause}
is evaluated to a context all of whose pairs are then included
in the new context.  The name `\TT{current}' can be used as
a context expression to denote the context of the module or
body containing `\TT{new context}' expression.


\section{Clusters}
\label{CLUSTERS}

A \key{cluster} is a group of related variables.  One variable of
the cluster is the \mkey{base variable}{of cluster} of the cluster, and the
other variables have names that are derived from the
name of the base variable by adding {\em member-selectors}
to the end of the base variable name.  See \pagref{NAMES}.

Thus a cluster
is like a C/C++ structure, but it is a set of variables and not a
piece of memory.

More specifically, the members of the cluster can be named by
adding either a member name beginning with a `\TT{.}' or a
`\TT{[]}' bracketed list of
integer indices to
either the base variable name of the cluster or to another member name
of the cluster.  Two variable names with different base variable names
belong to different clusters.  The indices must be compile time
constants when the member is allocated and written, but may be run time
variables when the member is read.

Variables in clusters are thus organized into trees, with clusters
that have different bases being in disjoint trees.  Any variable in a cluster
can be considered
as the \mkey{root}{of subcluster} of a subtree of cluster members, and
the subtree is called a \key{subcluster}.

The main feature of clusters and subclusters
is that members are passed to or returned
from functions implicitly when their the root variable is named
explicitly.  Furthermore, non-root cluster members \underline{cannot}
be created except as results of function calls.

For example:
\begin{indpar}\begin{verbatim}
type pointer pair is void
    // if pp is a pointer pair then:
    //   unsadr pp.begin is the offset of the first element
    //   unsadr pp.end is the offset just AFTER the
    //                 last element
    //   mem adr pp.base is the base address that
    //                   is added to the offsets
    //   *UNCHECKED* adr pp.base.adr is the address of
    //                                  pp.base
    //   type pp.type is type of elements pointed at

// Function to allocate a vector of n T's to the stack.
//
function ( stack pointer pair pp,
           unsadr pp.begin,
           unsadr pp.end,
           mem adr pp.base,
           *UNCHECKED* adr pp.base.adr,
           type pp.type ) =
        allocate to stack ( type T, uns32 n ):
    require ( zero value OK ( T ) )
    pp.type = T
    unsadr size = size of ( T ) * n
    pp = allocate to stack ( size )
        // This sets pp.offset, pp.base and
        // pp.base.adr.
    pp.begin = pp.offset
    pp.end = pp.begin + size
        // pp.offset is not returned to caller


// Prefix operator to dereference a pointer pair to read
// memory.
//
function ( mem pp.type out,
           *UNCHECKED* unsadr out.offset,
           mem adr out.base,
           *UNCHECKED* adr out.base.adr ) =
        "*" ( stack pointer pair pp,
              type pp.type,
              unsadr pp.begin,
              unsadr pp.end,
              *UNCHECKED* adr pp.base ):
    if:
        pp.begin < pp.end:
            out.offset   = pp.begin
            out.base.adr = pp.base.adr
        else:
            fatal error
                ( "Deferencing empty pointer pair." )

// Prefix operator to increment the begin pointer of a
// pointer pair.
//
function ( next pp.begin )
        "++" ( stack pointer pair pp,
               unsadr pp.begin )
      next pp.begin = pp.begin + size of ( pp.type )

// Assignment operator for pointer pairs.
//
function ( Q pointer pair pp2,
           unsadr pp2.begin,
           unsadr pp2.end,
           mem adr pp2.base,
           *UNCHECKED* adr pp2.base.adr,
           type pp2.type )
        = ( qualifiers Q,
            Q pointer pair pp,
            type pp.type,
            unsadr pp.begin,
            unsadr pp.end,
            *UNCHECKED* adr pp.base.adr ):
      pp2.begin = pp.begin
      pp2.end = pp.end
      pp2.base.adr = pp.base.adr
      pp2.type = pp.type

// Example usage:
//
function ...

    // Vector of 2 int32's is allocated and the elements
    // are set equal to 100 and 101.
    //
    pointer pair pp = allocate to stack ( int32, 2 )
    next ( * pp ) = 100
    ++ pp
    next ( * pp ) = 101
    . . . .
    // Vector of 1000 float64's is summed.
    //
    pointer pair ppf = allocate to stack ( float64, 1000 )
    ... set 1000 elements ...
    float64 sum = loop:
        initially:
            float64 partial sum = 0
            pointer pair ppf2 = ppf
        while ppf2.begin < ppf2.end:
            next partial sum = partial sum + * ppf2
            ++ ppf2
        finally:
            sum = partial sum
\end{verbatim}\end{indpar}\label{NEXT-CLUSTER-BASE-EXAMPLE}

Note that although the functions defining operations on a pointer pairs
are a long winded, usage of pointer pairs is compact and easy.
This is a general characteristic of the L-Language, and derives
from the fact that the functions automatically manage the members
of a cluster.

Cluster member names may be used as prototype parameter
names, with the root of these names also being a prototype
parameter.  This specifies that the parameters are related
by being in the same cluster.  The arguments with member names
\underline{must} not be given explicit values by function calls,
they must be omitted in the call itself, as they will be given
the values taken from members of the root value given in the call.
If the cluster members named as arguments
in the function prototype do not have corresponding members of the
root value given in the call,
the function prototype does not match the call unless the prototype
member has a default (see \pagref{DEFAULTS-TO} ).

When this is done for prototype results, the cluster root must similarly
be a either a result or argument, and the designated
members of the cluster are created and set from the results.
Again the cluster members \underline{must} be omitted in calls,
but will be automatically created.
Note that when this is done any qualifiers on the omitted cluster
members will be set by the prototypes.

If all result variables are cluster members, then calls
using the prototypes will have no explicit result variables,
but will create new members of existing clusters.  For example:
\begin{indpar}\begin{verbatim}
function ( bool v.nonneg ) = test sign ( int32 v ):
    if:
        v >= 0:
            v.nonneg = true
        else:
            v.nonneg = false

int32 x = 89
int32 y = -5
test sign ( x )
test sign ( y )
// Now x.nonneg exits and is true
// and y.nonneg exits and is false.
\end{verbatim}\end{indpar}

A variable whose underlying type is \TT{void} has no actual value
and must not be assigned one.  Such variables are only useful
as cluster and subcluster roots.  The `\TT{allocate to stack}'
function requires that its result be a variable whose underlying
type is \TT{void} (see \pagref{ALLOCATE-TO-STACK}).

Cluster roots and members may be implied next variable
(see \pagref{IMPLIED-NEXT-VARIABLES}).  Some members of a cluster
may be next variables while other members of the same cluster are
not.  The variables of a cluster are independent of each other
in this respect.

Cluster members may only be created as function call results.
A {\em result-declaration} of the form `\TT{next} {\em v}' where
{\em v} denotes a cluster member or root can only be used in
a function result prototype: 
see \pagref{IMPLIED-NEXT-VARIABLES}.

A cluster member may be explicitly passed as a result variable
or argument if it is the root of a subcluster that is being
created or used.  The matching prototype variable must
be a cluster root, and \underline{not} a cluster member,
within the prototype.  If the cluster member being passed is a
result variable, its matching prototype variable declaration must have the
underlying type \TT{void} or be a `\TT{next ...}' result.

The `\TT{qualifiers Q}' argument to the assignment operation
is assigned by implication to qualifiers of the `\TT{pointer pair}'
argument, and these qualifiers are added to the result.

In the above example `\TT{mem}' is a special builtin qualifier
which can be applied to variables.
See \itemref{BUILTIN-QUALIFIERS}.

The `\TT{mem}' qualifier\label{MEM}
has the special property that given a variable
\TT{v} of qualifier \TT{mem}, then if \TT{v} is allocated,
and \TT{v.base} of type \TT{adr} and qualifier \TT{*UNCHECKED*}
is allocated and assigned a value
and \TT{v.offset} of type \TT{unsadr} and qualifier \TT{*UNCHECKED*}
is allocated and assigned a value, then
the root \TT{v} is automatically
assigned the value located at the RAM address \TT{v.base + v.offset}.
It is an error in this case to explicitly assign a value to \TT{v}.
This is how \TT{out} gets its value from
\TT{out.base}, and \TT{out.offset}.

Similarly if \TT{v.adr} is allocated an assigned a value, then
the root \TT{v} is automatically
assigned the value located at the RAM address \TT{v.adr}.
This is how \TT{out.base} and \TT{pp.base} get their values from
\TT{out.base.adr} and \TT{pp.base.adr} respectively.

For details on the `\TT{mem}' qualifier see \itemref{THE-MEM-QUALIFIER}.

The `\TT{stack}' qualifier has the property that values with
this qualifier may not be passed out of a block with a free
stack.  This keeps stack addresses from escaping contexts in
which they are valid.  See Sections~\itemref{THE-STACK-QUALIFIER} and
\itemref{STACK-MANAGEMENT}.

A qualifier may be \ikey{inherited}{qualifier}\label{INHERITED-QUALIFIER}.
If an inherited qualifier
is applied to the root variable of a cluster
or subcluster, this inherited qualifier is automatically applied to all
the member variables in the cluster or subcluster.  This is not done
for non-inherited qualifiers.

The `\TT{stack}' qualifier is inherited.

Another example of a cluster with implied next variables is:
\begin{indpar}\begin{verbatim}
type sequence is void
    // if seq is a sequence,
    // seq.count is the number of its elements
    // seq.type is the type of the elements
    // seq[0 .. seq.count - 1] are the elements

// Function to rotate the sequence right 1 position.
//
( next seq.count, next seq[0 .. seq.count - 1] )
    = right rotate ( sequence seq, unsadr seq.count,
                     type seq.type,
                     seq.type seq[0 .. seq.count - 1]:
    next seq[1 .. seq.count - 1] = seq[0 .. seq.count - 2]
    next seq[0] = seq[seq.count - 1]

// Example usage
//
    sequence s = ...
    rotate ( s )
\end{verbatim}\end{indpar}
Here the \TT{seq.count} and \TT{seq.type} arguments
specify types and member indices
of results and of arguments later in the argument list.  A call's actual
\TT{seq.count} and \TT{seq.type} arguments must be compile time values
in order to be so used.

A last example of the use of clusters is the implementation of
comparison operators so that
\begin{center}
\TT{(x~<~y)~<~z}
\end{center}
is the same as
\begin{center}
\TT{(x~<~y) AND (y~<~z)}
\end{center}
where \TT{y}, if it is an expression,
is not evaluated twice:\label{COMPARISON-RESULTS}
\begin{indpar}\begin{verbatim}
type comparison result is void
    // if cr is a comparison result then:
    //   bool cr.value is the result of the comparison
    //   type cr.type is the type of the values compared
    //   cr.type last is the last value compared

// Comparison result of x < y where x and y are type T.
//
function ( comparison result cr, bool cr.value,
           type cr.type, T cr.last ) =
        ( type T, T first ) "<" ( T last ):
    cr.type = T
    cr.last = last
    cr.value = first less than last

// Comparison result of x < y where x is a comparison result.
//
function ( comparison result cr, bool cr.value, type cr.type,
           T cr.last ) =
         ( comparison result cf, bool cf.value, type cf.type,
           cf.type cf.last ) "<" ( cf.type last ):
    cr.type = cf.type
    cr.last = last
    cr.value = cf.last less than last

// Implied conversion of comparison result to bool.
//
function ( Qs bool result ) =
    ( qualifiers Qs, QS comparison result cr,
      bool cr.value, type cr.type, cr.type cr.last ):
    result = cr.value
\end{verbatim}\end{indpar}

Cluster variables can be grouped into `\skey{slice}s', see
\pagref{SLICE}.  A slice can be allocated and passed
as an argument as if it were a single variable.  When cluster
variables or slices containing {\em member-indexes} are allocated,
the {\em member-indexes} must be defined at compile time.
When these variables or slices are read, the
{\em member-indexes} can be run time.

\section{Builtin Qualifiers}
\label{BUILTIN-QUALIFIERS}

The builtin qualifiers are \TT{mem}, \TT{stack}, \TT{*UNCHECKED*},
and \TT{global}.
There is also a special class of qualifiers called trace qualifiers.

\subsection{The Memory Qualifier}
\label{THE-MEM-QUALIFIER}

The \ttkey{mem} qualifier is a protected qualifier that behaves
in a special way when it is given to a variable \TT{v}.
In this situation \TT{v} is a copy of a RAM memory value and
must be in a cluster that
has either:
\begin{enumerate}
\item
A variable \TT{v.adr} of type \TT{adr} with either of the qualifiers
\TT{mem} or \TT{*UNCHECKED*} that is the RAM address of \TT{v}.

\item
A variable \TT{v.offset} of type \TT{intadr} or \TT{unsadr} and
qualifier \TT{*UNCHECKED*}, and
a variable \TT{w.base} of type \TT{adr} and qualifier \TT{mem}
or \TT{*UNCHECKED*} where \TT{w} is either \TT{v} or an ancestor
of \TT{v} in the cluster (if there are several such ancestors, the
closest to \TT{v} is selected).
In this case the RAM address of \TT{v} is \TT{v.offset+w.base}.
If \TT{w.base} has qualifier \TT{mem} it must recursively obey these
rules (so there must be either a \TT{w.base.adr} variable
or \TT{w.base.offset} and \TT{u.base} variables where \TT{u}
is either \TT{w.base} or an ancestor of \TT{w.base} in the cluster, etc.).
\end{enumerate}
The the
variable \TT{v} must \underline{not} be given a value by an
assignment statement, but will instead be loaded with a value
from its RAM address.  It is called a `\key{RAM cache variable}'.

An example is:

\begin{indpar}\begin{verbatim}
// In C/C++:
//     struct foo_struct { int a, b, c }
//     typedef foo_struct * foo
//
// Here a cluster foo, foo.a, foo.b, foo.c
// where foo is an address.
//
type foo is void
type foo_ptr is adr
function ( foo x, *UNCHECKED* adr x.base,
           mem int32 x.a, *UNCHECKED* x.a.offset,
           mem int32 x.b, *UNCHECKED* x.b.offset,
           mem int32 x.c, *UNCHECKED* x.c.offset )
        = "*" ( foo_ptr x ):
    x.base = x
    x.a.offset = 0
    x.b.offset = 4
    x.c.offset = 8

// Usage:
//
foo_ptr zp = ... // assign adr to zp
foo z = * zp     // Assign to z.base, z.a.offset, ...
... z.a ...      // Use z.a
next z.a = ...   // Write z.a

\end{verbatim}\end{indpar}

If a RAM cache variable is not used, it will not actually be loaded
from RAM.  If two RAM cache variables are explicitely given the
same address, the two variables will be treated as the same variable
(i.e., a variable with two names).  For example:

\begin{indpar}\begin{verbatim}
    mem int32 w
    adr w.adr = ...
    mem int32 v
    adr v.adr = w.adr
        // v and w are two names for the same variable.
\end{verbatim}\end{indpar}

If \TT{v} is a RAM cache variable, assigning a value to `\TT{next v}'
writes the value to RAM.  For example:

\begin{indpar}\begin{verbatim}
    mem int32 v
    adr v.adr = ...
    next v = ...       // Writes value to v.adr
\end{verbatim}\end{indpar}

If the original value of \TT{v} was never used, it will not be
read from RAM even \TT{v} is written in this way.

Because \TT{mem} is a protected qualifier, \TT{v} and the required
members of the cluster of which \TT{v} is a root
must be created as matches to result variables of a function.
So only functions can effect a load of RAM contents to a variable.

There is a special function of zero arguments, \TT{NULL}, of result
type \TT{adr}, that
references a block of 4,096 bytes of virtual memory that is
inaccessible and will cause a segmentation fault if referenced.


\subsection{The Stack Qualifier}
\label{THE-STACK-QUALIFIER}

The `\ttkey{stack}' qualifier is an inherited, prohibited,
protected qualifier
attached to offsets and addresses
returned by the builtin `\TT{allocate to stack}'
function (\pagref{ALLOCATE-TO-STACK}).
It is used to keep these from being stored in
non-stack memory and in stacks who lifetime exceeds that of the
memory the stack address points at.

The special property of the `\TT{stack}' qualifier is that it cannot
be used to qualify variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
or iteration variables in a {\em loop-assignment-statement}.
This is so that stack addresses pointing into a free stack
cannot outlive the free stack.
See Section~\itemref{STACK-MANAGEMENT} for more information.

Also, as a prohibited qualifier, a \TT{stack} value cannot be
passed as an argument to a function that does not expect a
\TT{stack} value.  For example:
\begin{indpar}\begin{verbatim}
stack adr sa = ...
adr ta = ...
function adr result = F ( adr arg ):
    . . . . . . . . . .
function adr result = G ( stack adr arg ):
    . . . . . . . . . .
adr xa = F ( sa ) // Illegal; F's arg does not have
                  // stack qualifier.
adr ya = G ( sa ) // Legal; G's arg has stack qualifier.
adr za = G ( ta ) // Legal; G's arg's stack qualifier has
                  // no effect (its not required).
\end{verbatim}\end{indpar}

\subsection{The \TT{*UNCHECKED*} Qualifier}
\label{THE-UNCHECKED-QUALIFIER}

The \TT{*UNCHECKED*} qualifier is a
required qualifier that must qualify the \TT{v.adr} or
\TT{v.offset} variables
associated with a variable \TT{v} that has the \TT{mem} qualifier.
See Section~\itemref{THE-MEM-QUALIFIER}.

The \TT{*UNCHECKED*} qualifier is also required for the result variable
of an unchecked conversion.  When used for a result variable of an
assignment, the value assigned need only be convertable to the type
of the variable by an unchecked conversion, instead of by a checked
conversion.

The \TT{*UNCHECKED*} lexeme is also used as the initial part some
names. An example is the \TT{*UNCHECKED* *ASSEMBLY*} assignment statement.

\subsection{Trace Qualifiers}
\label{TRACE-QUALIFIERS}

A \key{trace qualifier} permits values to be marked so that they
can be found (i.e., `traced') by garbage collectors
(and occassionally debuggers)
when they are stored in the
stack.  A trace qualifier may be declared by:

\begin{indpar}
\emkey{trace-qualifier-declaration}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{trace qualifier}
           {\em defined-qualifier-name} \\
        & ~~~~~ \TT{with base type}~~{\em type-name}
    \end{tabular}
\end{indpar}

The base type of a trace qualifier may be determined by the
function with the prototype:
\begin{center}
{\tt (type T) = \ttkey{base type of} ( qualifier Q )}
\end{center}
The value of any variable with the trace qualifier must be
\TT{*UNCHECKED*} convertable to a value of the base type.

It is common to add a trace qualifier to the statement that
defines a type you want to trace.  An example in which the
qualifier is \TT{Q} and the type is \TT{T} is:
\begin{indpar}\begin{verbatim}
trace qualifier Q with base type adr
type Q T is adr
\end{verbatim}\end{indpar}
which causes all values of type \TT{T} in the stack to be
traced.

More specifically, when a value \TT{V} of a variable with the trace
qualifier \TT{Q} and base type \TT{B} is added to a stack,
\TT{V} converted to type \TT{B} is also
pushed into a (virtual or physical) \TT{Q}-stack of values of
type \TT{B}.
When the stack containing \TT{V} is freed, the corresponding
value in the \TT{Q}-stack is popped.  There is a \TT{Q}-stack
associated with every process and every global area.
Using functions in the
subroutine library (see TBD), these \TT{Q}-stacks can be read.

While a value may be pushed into a stack more than once,
a value will not be pushed if the compiler can prove it is already
in the stack.  Thus given the definitions above, in
\begin{indpar}\begin{verbatim}
T v = ...
T w = v
\end{verbatim}\end{indpar}
the first statement may push the value of \TT{v} to the \TT{Q} stack
but the second statement will not push the value of \TT{w} on
the grounds that it is already in the stack.

\subsection{The Reload Statement}
\label{THE-RELOAD-COMMAND}

The reload statement has the syntax:
\begin{indpar}
\emkey{reload-statement} ::=
    \ttkey{reload} {\em qualifiers} \{ \TT{,} {\em qualifiers} \}\STAR{} \\
\emkey{qualifiers} ::= {\em qualifier} $|$ {\em qualifier-set} \\
\emkey{qualifier} ::= {\em expression} evaluating to a qualifier \\
\emkey{qualifier-set} ::= {\em expression} evaluating to a qualifier set
\end{indpar}

This statement declares the values of all variables with the designated
qualifiers to be out-of-date and unusable.  If any of these variables
is used subsequently, statements to recompute the variable value
will be inserted automatically into the code at the point of the
\TT{reload} statement.  If this is not possible the compilation will
be in error.

As a special case, if a variable that is declared to be out-of-date,
\TT{v}, has the `\TT{mem}' qualifier, and is in
a cluster that causes \TT{v} to be loaded from memory
(as per Section~\itemref{THE-MEM-QUALIFIER}), then if \TT{v} is declared
to be out-of-date, recomputing \TT{v} just means that \TT{v}
is reloaded from RAM.  The possibility that software cache
variables (with the \TT{mem} qualifier) will become out-of-date because
the RAM locations they cache have changed is the reason the \TT{reload}
statement exists.

The statement
\begin{center}
\TT{reload mem, mem dependent}
\end{center}
is commonly used to declare all
variables that act as software caches of memory, and all variables
that should be updated when the caches are updated, to be out-of-date.

Note that variables computed from out-of-date variables are \underline{not}
declared to be out-of-date.

If an out-of-date variable value is not used after the \TT{reload} statement,
it is not recomputed.

Variable values are recomputed in the same order as they were
originally computed.  How each variable is recomputed depends upon
how it was originally computed.

If a variable \TT{v} was originally computed by
a {\em simple-assignment-statement}
of the form `{\em type} \TT{v =} {\em expression}', then if
no input to {\em expression} has been recomputed, \TT{v} does not
need to be recomputed.  Otherwise \TT{v} is recomputed by re-executing
the assignment statement.

If a variable without a \TT{mem} qualifier needs to be
recomputed and was computed by other than
a {\em simple-assigment-statement}, it is a compile error if the
variable is marked out-of-date and later used.

The \TT{reload} statement behaves like an executable statement but
it has some unusual properties when it is executed inside a
nested subblock.  First, it declares out-of-date any variable with
the given qualifiers that is visible in its subblock \underline{and any
containing block}.
Second, it will recompute any out-of-date variable in its subblock
\underline{or any containing block} that may be used after the
\TT{reload} statement executes.
Third, when it recomputes variables, it overwrites
the place the variable is stored, rather than allocating a new
place as would a `\TT{next~}{\em variable-name}' expression.
These properties allow `\TT{reload Q}' to appear in an inline
or conditional subblock.

\section{Memory Write Statements}
\label{MEMORY-WRITE-STATEMENTS}

Statements that write memory make use of cluster structures
similar to those used with
\TT{mem} qualifier variables:
see Section~\itemref{THE-MEM-QUALIFIER}.

Specifically, memory needs to be addressed.  This is done by either
of the following methods of specifying a RAM address:
\begin{enumerate}
\item
An `\key{address variable} \TT{va}
of type \TT{adr} with either of the qualifiers
\TT{mem} or \TT{*UNCHECKED*} that contains the RAM address.
If \TT{va} has qualifier \TT{mem} it must obey
the rules of Section~\itemref{THE-MEM-QUALIFIER}.


\item
An `\key{address variable}' \TT{vo} of type \TT{intadr} or \TT{unsadr} and
qualifier \TT{*UNCHECKED*} in a cluster, and
a variable \TT{vb.base} of type \TT{adr} and qualifier \TT{mem}
or \TT{*UNCHECKED*} where \TT{vb} is either \TT{vo} or an ancestor
of \TT{vo} in its cluster.
In this case the RAM address is \TT{vo+vb.base}.
If \TT{vo.base} has qualifier \TT{mem} it must recursively obey
the rules of Section~\itemref{THE-MEM-QUALIFIER}.

\end{enumerate}

An address variable may be the member \TT{v.adr} or \TT{v.offset}
of a cluster with RAM cache variable \TT{v}.  In this case the
address variable is said to be the `\mkey{address}{of RAM cache variable}'
of the RAM cache variable \TT{v}.

\subsection{Single Value Write Statements}
\label{SINGLE-VALUE-WRITE-STATEMENTS}

The form of a single valued write statement is:

\begin{indpar}
\emkey{single-value-write-statement} ::=
    \TT{*WRITE*} {\em value-variable} {\em address-variable}
\end{indpar}

The value in the {\em value-variable} is written to the RAM address
in the {\em address-variable}.  If the {\em address-variable} is the
address of a RAM cache variable \TT{v}, the write statement does
\underline{not} update \TT{v} or create `\TT{next v}'.

\subsection{Memory Copy Statements}
\label{MEMORY-COPY-STATEMENTS}

The form of a memory copy statement is:

\begin{indpar}
\emkey{memory-copy-statement} ::=
    \TT{*COPY*} {\em source-variable} {\em destination-variable}
    		{\em length-variable}
\end{indpar}
Bytes are copied from the RAM address in the {\em source-variable}
to the RAM address in the {\em destin\-ation-\EOL variable}.
The number of bytes copied is in the {\em length-variable},
which must be of the \TT{unsadr} type.

If the source address is greater than the destination address,
the bytes are copied in ascending address order.  If the
source address is less than the destination address,
bytes are copied in descending address order.  If the two
addresses are equal, bytes may or may not be copied.  The effect of
all this is to copy regions of memory correctly even if they
overlap.


\subsection{Memory Set Statements}
\label{MEMORY-SET-STATEMENTS}

The form of a memory set statement is:

\begin{indpar}
\emkey{memory-set-statement} ::=
    \TT{*SET*} {\em value-variable} {\em address-variable}
    		{\em length-variable}
\end{indpar}
The `set length' is stored in the {\em length-variable} which must
be of \TT{unsadr} type.  As long as the set length is not zero,
this statement performs a \TT{*WRITE*} operation on its
first two arguments, and then increments the address by
the length of the type of the value, and decrements the set length
by one.

\subsection{Atomic Memory Statements}
\label{ATOMIC-MEMORY-STATEMENTS}

An \key{atomic-memory-statement} is a generalization of
the classic compare-and-set instruction.  It is a block assignment
statement that executes a sequence of specialized instructions:

\begin{indpar}
\emkey{atomic-memory-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \TT{( uns32 count, adr bad address ) = }\ttkey{*ATOMIC*} \TT{:} \\
	\TT{~~~~}{\em lock-instruction}\STAR{} \\
	\TT{~~~~}{\em compare-instruction}\STAR{} \\
	\TT{~~~~}{\em write-instruction}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{lock-instruction} ::= \ttkey{*LOCK*} {\em lock-variable} \\
\emkey{compare-instruction} ::= \ttkey{*COMPARE*} {\em compare-variable}
						  {\em address-variable} \\
\emkey{write-instruction} ::= \\
\hspace*{0.2in}\begin{tabular}[t]{rl}
        & \TT{*WRITE*} {\em value-variable} {\em address-variable} \\
    $|$ & \TT{*COPY*} {\em source-variable} {\em destination-variable}
    		      {\em length-variable} \\
    $|$ & \TT{*SET*} {\em value-variable} {\em address-variable}
    		     {\em length-variable} \\
    \end{tabular}
\end{indpar}

The special instructions,
which make use of clusters (Section~\itemref{CLUSTERS}),
and are as follows:
\begin{indpar}[0.4in]
\hspace*{-0.2in}{\em \bf Lock-Instruction}.
The {\em lock-variable} is of type \TT{uns32}
and identifies the lock.
The lock is a binary test-and-set lock provided by the
underlying system.  Locks are allocated to sets of processes
that share memory, so that if any process in the set gets
the lock, other processes in the set cannot.

The lock instruction sets the lock and succeeds if the lock
was not already set, and otherwise just fails.

When the {\em atomic-assignment-statement} terminates, either
successfully or when it fails, all locks gotten are released in
reverse order.

\hspace*{-0.2in}{\em \bf Compare-Instruction}.
The compare
instruction reads the value at the {\em address-variable} designated
address and compares
it to the value of the {\em compare-variable}.  The instruction
succeeds if the values are equal, and fails otherwise.

The {\em compare-variable} may be a RAM cache variable whose
address is the {\em address-variable}.  The RAM cache variable
is not changed even if the value read does not match its value.

\hspace*{-0.2in}{\em \bf Write-Instructions}.
These do what they normally do, except they are all dry-run 
before any actually execute.  During the dry-run one of these
instruction fails if any memory reference it makes would fail
were the instruction actually executed.  In particular, if any
piece of memory is paged out or not in RAM, the dry-run fails.
\end{indpar}

The `\TT{count}' value returned by the {\em atomic-memory-statement}
equals \TT{0} if the statement succeeds, or is the number of the
first failed instruction in the statement block if the statement
fails (the first instruction is number \TT{1}).
The `\TT{bad address}' value is \TT{0} unless the block
fails because of a memory fault, in which case the `\TT{bad address}'
value is set to the faulting address.  One usually deals with a faulting
address by reading it with a normal instruction if it is a read fault,
or writing it with a normal instruction that does not change its
value if it is a write fault (this may require a compare and set
assembly instruction),
and then retrying the \TT{*ATOMIC*} block.

Interrupts of all kinds are disabled during the execution of an
{\em atomic-memory-statement} so the statement will execute as
fast as the underlying hardware will allow.  However, this means
that memory paging is disabled, so instructions will fail if
they page fault.  This is the reason for the dry-run of the
{\em write-instructions}, to be sure they will not fail
when they actually write data.

A system may put restrictions on the size of the value in
a {\em length-variable}, and on the number of instructions
in an \TT{*ATOMIC*} block, in order to ensure that interrupts
are not disabled for very long.  Violation of these restrictions
causes a \TT{*ATOMIC*} block instruction fault that is distinct
from \TT{*ATOMIC*} block failures described above (such violations
are not recoverable).

\section{Stack Management}
\label{STACK-MANAGEMENT}

Each execution thread has a stack that is not in any other
stack.  Each out-of-line function
execution is a block execution that has a stack which is
by default a substack of the thread in which the function
execution is running.  Each subblock in turn has a stack
which is by default a substack of the stack of its containing block.
And each global area has a stack that is not in any other stack.

Conceptually, the assignment statements in a block each allocate memory for
their variable to the current block stack and copy values to these
variables.  As noted above (Section~\itemref{ASSIGNMENT-STATEMENTS}),
the memory and associated copies may be
optimized away in some cases.

Stacks are either free or bound.\label{FREE-STACK}
A bound stack is a substack that is
not deallocated from memory until its smallest containing free stack is
deallocated.  The main reason this is important is that stack addresses
can be passed out of a block with a bound stack to its containing block,
but cannot be passed out of a block with a free stack to its containing
or calling block.  This is implemented by giving certain
variables the `\TT{stack}' qualifier: see
Section~\itemref{THE-STACK-QUALIFIER}.

Stacks of out-of-line function executions
(\pagref{OUT-OF-LINE-FUNCTIONS}),
out-of-line assignment statement blocks
(\pagref{OUT-OF-LINE-ASSIGNMENT-STATEMENTS}),
and
compile-time assignment statement blocks
(\pagref{COMPILE-TIME-ASSIGNMENT-STATEMENTS})
are free, and variables in the {\em result-variable-list}
of a {\em call-assignment-statement},
{\em out-of-line-assignment-statement}, or
{\em compile-time-assignment-statement},
may \underline{not} have the `\TT{stack}' qualifier.

Stacks of loop iteration subblocks are free, and
variables in the {\em result-variable-list}
and iteration variables
of a {\em loop-assignment-statement} may not have the `\TT{stack}'
qualifier.  However, stacks of loop `\TT{initially}' and `\TT{finally}'
subblocks are not free.

Global area stacks (see Section~\itemref{GLOBAL-AREAS}) are free,
but are never deallocated and make no use of the `\TT{stack}'
qualifier.

All other stacks are bound.  Memory allocated to them
by the `\TT{allocate to stack}' function (\pagref{ALLOCATE-TO-STACK})
is actually
allocated to their smallest containing free stack, and not deallocated
until that free stack is deallocated.

Free stacks are relocatable and can be moved.
Substacks cannot move independently,
but move whenever their smallest containing free stack moves.
Any stack address is relative to its containing free stack,
which is the current free stack at the time executable code uses
the stack address.  To accommodate this builtin memory read-write
functions will not only accept an \TT{adr} value as a RAM address,
but also accept a RAM address consisting of an \TT{unsadr}
offset within the stack and a stack base address that is itself
stored in RAM.  See Sections~\itemref{THE-MEM-QUALIFIER}
and \itemref{STACK-MEMORY-ALLOCATION}
for details.

There are a couple of situations in which free stacks move.

Memory of runtime determined size can be allocated to the end of
a stack by the `\TT{allocate to stack}' and `\TT{allocate to global}'
functions described below, and such may
require that the smallest containing free stack
be moved to a memory region where there is more free memory available.

In a program being debugged, free stacks may be saved after they are no
longer needed by the program, in order to permit them to be analyzed
by a debbugger if the program detects an error.  In this situation
free stacks are allocated to a very big circular buffer, and overwritten
after they are no longer needed by the program.  It may happen that
a free stack whose block is still running is in the way of allocating
a new stack to the circular buffer, in which case the still running
block's free stack may be moved.

Lastly, global area stacks (\pagref{GLOBAL-AREAS})
may be deallocated when programs that
can reference them are still running, or may not yet be allocated
when these programs run.  Deallocated global area stacks are treated as if
they were allocated to inaccessible memory, so deallocating these stacks
is like moving them to inaccessible memory, and referencing
them when they are deallocated gives a memory fault.


\subsection{Unwind Blocks}
\label{UNWIND-BLOCKS}

\ikey{Unwind blocks}{unwind block} are executed only when their
containing block terminates:

\begin{indpar}
\emkey{unwind-block}
    ::= \begin{tabular}[t]{l}
	\ttkey{*UNWIND*}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular}
\end{indpar}

Specifically, when an unwind block is encountered while
executing its containing block, the unwind block is marked
as enabled, but is skipped.  Then when the containing block
terminates, all its enabled unwind blocks are executed in
the reverse order of that in which they were enabled.

Unwind blocks are used to close or deallocate things that were opened.
For example, right after a statement that opens a file there may be
an unwind block that closes the file.  This ensures that the file
will be closed even if the block that opened it terminates later
prematurely with an error, such as a memory fault.

\subsection{Throw and Catch}
\label{THROW-AND-CATCH}

\TT{*THROW*} and \TT{*CATCH*} statements are used to implement
exceptions, i.e., abnormal termination.

\begin{indpar}
\emkey{throw-statement} ::= \TT{*THROW*} \\[1ex]
\emkey{catch-statement} ::= \TT{*CATCH*}
\end{indpar}

The \TT{*THROW*} statement causes its containing block to
\ikey{terminate abnormally}{abnormal termination}.
When a block terminates abnormally, its containing
block is also terminated abnormally.

\ikey{Normal termination}{normal termination}
of a block occurs at the end of the block if
the block has not executed a \TT{*THROW*} or an abnormally
terminating subblock.

Any enabled \TT{*UNWIND*} subblocks of an abnormally terminating
block are executed in reverse order, just as they would be if
the block were terminating normally.  No other part of the block
is executed.

If an \TT{*UNWIND*} subblock executing in an abnormally terminating
containing block \TT{B}
executes a \TT{*CATCH*} statement, the termination of this
containing block \TT{B}
is changed from abnormal to normal.  This means
that \TT{B}'s containing block \TT{C} will resume when the now
normally terminating block \TT{B} finishes terminating.
However, \TT{B} will not execute anything but enabled \TT{*UNWIND*}
subblocks, as it is still terminating.

Machine errors, i.e. memory segment faults, invoke callable functions
which can record error information and execute a \TT{*THROW*}.
Similarly detected programming or data errors can record
error information and execute a \TT{*THROW*}.  An \TT{*UNWIND*}
block can look at recorded error information and decide whether
or not to execute a \TT{*CATCH*}.

If a block has result variables it must assign, then these need not be
assigned if the block terminates abnormally, as they will not
be visible to enabled \TT{*UNWIND*} blocks.  However, if a block \TT{B}
that is terminating abnormally executes a \TT{*CATCH*} statement in
one of its \TT{*UNWIND*} subblocks,
all result variables that block \TT{B} must assign must be given values, even
though part of block \TT{B} may not have executed.  The compiler
will check this, and will only permit code that passes straight forward
compiler checks.

There are two ways to ensure correct code.  The first is to 
set all block result variables either in or before the
\TT{*UNWIND*} block that contains the \TT{*CATCH*} statement.
The second is to use the special variable
\ttkey{*LAST-ENABLED-UNWIND*} inside the \TT{*UNWIND*} block.
This variable is \TT{true} if and only if the \TT{*UNWIND*}
block is the last \TT{*UNWIND*} block enabled in its containing
block, and so if the variable is \TT{true}, any containing
block result variables set after the \TT{*UNWIND*} block need to be
set.  The compiler will accept a statement of the form:
\begin{indpar}\begin{verbatim}
if:
    *LAST-ENABLED-UNWIND*:
        result-variable-1 = ...
        result-variable-2 = ...
	. . . . . . . . . . . .
\end{verbatim}\end{indpar}
where the result variables set are those set after the \TT{*UNWIND*}
block, thus satisying the requirement that all result variables be set.

[TBD: Maybe default clauses should exist for all block style
assignment statements and execute at the beginning, setting
values for result variables that will be available outside
the block if the block does not set any values itself.]

\subsection{Stack Memory Allocation}
\label{STACK-MEMORY-ALLOCATION}

The `\ttkey{allocate to stack}' function allocates \TT{N} bytes of
memory to the current free stack and returns its offset within
the stack and the address of the stack base address:

\begin{indpar}\tt\begin{tabular}{l}
( T result, \\
~~stack *UNCHECKED* unsadr result.offset, \\
~~stack mem adr result.base, \\
~~*UNCHECKED* adr result.base.adr  ) = \\
~~~~\ttkey{allocate to stack} ( type T, unsadr N ) \\
~~~~~~~~[* underlying type of T == void *]
\end{tabular}\end{indpar}\label{ALLOCATE-TO-STACK}

Here `\TT{result.offset}' is the offset of the \TT{N} bytes within the
stack, `\TT{result.base}' is the base address of the stack, and
stack, `\TT{result.base.adr}' is the address of where this
base address is stored in RAM.  The first and last of these
are fixed but `\TT{result.base}' may change when the stack is
moved.

The returned values use
the `\TT{stack}' qualifier (see \itemref{THE-STACK-QUALIFIER})
and `\TT{*UNCHECKED*}' qualifier (see \itemref{THE-UNCHECKED-QUALIFIER}).

The memory is freed when the free stack to which it is allocated
is freed (\itemref{STACK-MANAGEMENT}).
The memory containing the \TT{base} value may also be
freed at this time.  The inherited `\TT{stack}' qualifier is used to
ensure that addresses of these values cannot survive the free stack:
see \itemref{THE-STACK-QUALIFIER}.

The memory allocated is always aligned on an \TT{8} byte boundary.

If you want a different alignment you can use:

\begin{indpar}\tt\begin{tabular}{l}
( T result, \\
~~stack *UNCHECKED* unsadr result.offset, \\
~~stack mem adr result.base, \\
~~*UNCHECKED* adr result.base.adr  ) = \\
~~~~\ttkey{allocate to stack} \\
~~~~~~~~~~~~( type T, unsadr N, unsadr O, unsadr A ) \\
~~~~~~~~[* underlying type of T == void *]
\end{tabular}\end{indpar}

where \TT{A} must be a power of \TT{2} not greater than \TT{64}.
This will align the \TT{O+1}'st
byte of the allocated memory block
at an address which is a multiple of \TT{A}\,.
Free stacks are always allocated on a \TT{64} byte boundary.

The `\TT{allocate to stack}' inline functions may move stackes and
therefore executes a `\TT{reload mem, mem dependent}' statement.


\subsection{Global Areas}
\label{GLOBAL-AREAS}

A global area is like the stack frame of a function that has no
arguments or return value, except that after this function executes,
the global area remains allocated and its variables can be referenced
by other code.  The syntax is:
\begin{indpar}
\emkey{global-area-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	{\em global-area-option}\STAR{}
	\TT{global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\end{tabular} \\
\emkey{global-area-option} ::= \ttkey{*COMPILE-TIME*}
                           $|$ \ttkey{*COMPILE-TIME-ONLY*}
\end{indpar}

Several such blocks may have the same {\em global-area-name},
as long as no {\em variable-name} appears in more than one of these blocks.

In order to be accessed a global area must be named in an `\TT{extern}'
statement:
\begin{indpar}
\emkey{extern-global-block} ::= \\
\hspace*{3em}\begin{tabular}[t]{@{}l}
	\TT{extern} {\em global-area-abbreviation}
	            \TT{is global} {\em global-area-name} \TT{:} \\
	\TT{~~~~}{\em extern-variable-statement}\STAR{} \\
	\end{tabular}
\\[1ex]
\emkey{extern-variable-statement} \\
\hspace*{3em}\begin{tabular}[t]{@{}rl}
    ::= & {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    $|$ & {\em variable-abbreviation} \TT{is}
          {\em qualifier-name}\STAR{} {\em type-name} {\em variable-name} \\
    \end{tabular}
\end{indpar}

A variable with {\em variable-name}
\TT{V} in a global area with {\em global-area-abbreviation}
\TT{A} may be named as \TT{A.V}, or if the variable has its own
{\em variable-abbreviation} \TT{VA},
this by itself (and \underline{not} \TT{A.VA})
may be used to name the variable.  An abbreviation is only effective
withing the scope of the `\TT{extern}' statement that defines it.

A variable in an
{\em extern-variable-statement} must match its corresponding
{\em global-area-block} variable with respect to type and qualifiers
in the same manner as a function prototype argument variable
matches a function call variable.

The {\em global-area-block} containing \TT{A.V} need not be compiled
or linked before the {\em extern-global-block} referencing
\TT{A.V} is compiled or linked.  This means a runtime reference
can be made to \TT{A.V} when it does not exist.  Such a reference
will incure a runtime error, typically a segmentation fault.

Memory within a global area can be allocated by:

\begin{indpar}\tt\begin{tabular}{l}
( T result, \\
~~global *UNCHECKED* unsadr result.offset, \\
~~mem adr result.offset.base, \\
~~global *UNCHECKED* adr result.offset.base.adr  ) = \\
~~~~\ttkey{allocate to global} ( type T, unsadr N ) \\
~~~~~~~~[* underlying type of T == void *]
\\[1ex]
( T result, \\
~~global *UNCHECKED* unsadr result.offset, \\
~~mem adr result.offset.base, \\
~~global *UNCHECKED* adr result.offset.base.adr  ) = \\
~~~~\ttkey{allocate to global} \\
~~~~~~~~~~~~( type T, unsadr N, unsadr O, unsadr A ) \\
~~~~~~~~[* underlying type of T == void *]
\end{tabular}\end{indpar}\label{ALLOCATE-TO-GLOBAL}

Here \TT{A} must a power of \TT{2} not greater than \TT{64}.
Global areas are allocated on a \TT{64} byte boundary and
may be moved during execution.

Global area variables \underline{cannot} be written to, but memory allocated
by `\TT{allocate to global}' can be.

The `\TT{allocate to global}' function plays the same role for
global areas as the `\TT{allocate to stack}' function does for
stacks, accept that the address gets the \TT{global} qualifier
instead of the \TT{stack} qualifier.  The \TT{global} qualifier
is a protected, inherited qualifier
with \underline{none} of the special `\TT{stack}'
qualifier properties, and normally has no effect on code.

The `\TT{allocate to global}' inline functions may move
global areas and threfore executes a
\begin{center}
\TT{reload mem, mem dependent}
\end{center}
statement.

Global areas are run time by default.
The code of a run time
global area block is executed when the file containing it is
loaded, and the stack of the area is allocated and defined when
the global area block is executed.
Global areas may be deallocated or moved during execution.
References to a global area
that is not yet allocated or that has been deallocated cause runtime
errors (typically segmentation faults).

Global areas may also be made compile time, or both compile and run time,
by use of the \TT{*COM\-PILE-\EOL TIME-\EOL ONLY*} or \TT{*COMPILE-\EOL TIME*}
{\em global-\EOL area-\EOL options} above.  For a compile time
global area, global area blocks are executed in the compiler immediately
after the block compiles, and the global area stack exists in the compiler.
If the global area is also run time, its
block code will be re-executed in the run time environment when the
file containing it is linked, and might produce different stack contents
for the area than the compile time version of the area.

\section{Memory Channels}
\label{MEMORY-CHANNELS}

OLD STUFF: REVISE.

A \key{memory channel} is a mechanism for accessing a set of blocks in RAM
that permits blocks to be announced substantially in advance of being
accessed.  Thus memory channels implement `\key{look ahead}' for
memory accesses.

A memory channel implements a \key{window}, which is a
structured set of elements each associated with a member of
some data set.  Each window element contains a
\key{block descriptor} that holds the address and length of the
memory block that contains the data associated with the element.
Block descriptors can also be marked as
\mkey{empty}{block descriptor}, meaning there is no block to be accessed.
The window has a \key{reference point}, and window elements are addressed
relative to this reference point.  There are shift operations that move
the reference point to a nearby window element.

Although we talk about blocks here, a block can be just a numeric array
element, and can be as small as a single bit.  Although we talk about
each element of a memory channel window having its own block descriptor,
an actual memory channel may use only block group descriptors, each of
which functions as a group of more than one individual element
block descriptor.

A memory channel is stored in a cluster.  As such it is mostly an
inline construction, though it can be passed to or returned from a
function, and the function can be all or partly out-of-line.

The most common type of memory channel has a window that appears to be
an array with \ttikey{.di\-men\-sions}{dimensions!of memory channel},
\ttdmkey{lower\_bound}{of memory channel}\TT{[}$i$\TT{]},
and \ttdmkey{upper\_bound}{of memory channel}\TT{[}$i$\TT{]}
being memory channel members.  Such are called
\key{array windows}.
If the memory channel cluster name is $M$, the window elements are
referred to by $M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]},
with $M$\TT{[0,0,}\ldots\TT{]} being the \key{reference point}.

The reference point can be shifted along any of the window's
dimensions by the command
\begin{center}
$M$\ttdkey{center}\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]}
\end{center}
This shifts
the window so that what was
$M$\TT{[}$i_0$\TT{,}$i_1$\TT{,}\ldots\TT{]} becomes
$M$\TT{[0,0,}\ldots\TT{]}.

Creating memory channels and completely reseting their reference points
are specific to the type of memory channel, and are not covered in
this section.

For most kinds of memory channels, block descriptors are computed
automatically when channel is created, when the window is
shifted, or when the data of
a neighboring window element is arrives from memory.
Immediately after a block descriptor is created, a read-ahead of
the block is initiated.  This read-ahead overlaps computation that
does not use the block contents.

If a memory channel accesses arrays stored in memory,
the channel block descriptors can be computed from the array coordinates
of the reference point.  Other memory channels use the contents
of a block to compute the block descriptors of neighboring blocks
in the window.

An example of the latter is a binary tree memory channel.
Let $M$ be such a channel, and let `\TT{.L}' denote the left
child of a binary tree element, `\TT{.R}' the right child, and
`\TT{.P}' the parent.  Then $M\!$\TT{.L.R} denotes the right
child of the left child of the reference point, $M\!$\TT{.P.L}
denotes the left child of the parent of the reference point,
and $M\!$\TT{.P.L.center} moves the reference point to this last element.
The window of such a memory channel might contain the depth 2
subtree of the reference point plus that closest 4 ancestors of the
reference point if these have been visited.  When the reference
point is moved, as soon as the reference point element has been
read from memory, the descriptors for its children are built and
the read of the children is initiated in parallel with other
computation.  When the children arrive from memory, the descriptors
of their children are built and reads of the data pointed at
are initiated.\footnote{All this can actually be done with modern
hardware: code is executed to read the reference point children and initiate the
reads of their children, and a modern processor will automatically
save the code that
executes when a read of a reference point child completes and execute
other code in parallel until the read does complete.}

Some standard memory channel types are built into the L-Language.
Others can be defined by users.

\section{To Do}

How can dynamically initialized locations be static.

Indirect address protocol.

Define `compile-time function' as a function that can only be
called at compile-time.

Add `\TT{no} {\em function-term}' as a way of saying
`{\em function-term} \TT{( false )}'.

If \TT{V} is the name of a repeatable variable (that may also
be omittable), then:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt unsadr V.\ttmkey{count}{of {\tt variable name}} } \\
Number of of times the variable name \TT{V} appears in the unfolded
pattern.  This is the number of times the {\em pattern-term} containing
the variable appears.  It is \TT{1} if the term is neither
replicated or omitted, and \TT{0} if it is omitted.

\hspace*{-0.3in}{\tt $T$ V\ttmkey{[$i$]}{of {\tt variable name}} } \\
The value of the $i$+1'st occurance of \TT{V} in the unfolded pattern.
The index $i$ may be computed at run time, and has the range
\TT{0~..~V.count-1}.
$T$ is the type of the variable given in the {\em pattern-term}.
It is an error to use an index value that is out of range.


\end{indpar}

If \TT{V} is the name of a variable that may be omitted but not
repeated, then:

\begin{indpar}[0.5in]

\hspace*{-0.3in}{\tt bool V.\ttmkey{present}{of {\tt variable name}} } \\
True if the variable is present, and false if not.

\end{indpar}

In addition, if a variable can be omitted but not repeated, a default expression
must be given for the variable in a `\ttkey{defaults to}'
{\em conditioning-expression}.%
\label{DEFAULTS-TO}
If the variable \TT{V} is omitted, this
expression will be used at run time to compute the variable's value,
and `\TT{V.present}' will be set to `\TT{true}'.

\label{INDIRECT-ADDRESS-PROTOCOL}

Threads.
\label{THREADS}

\appendix

\section{Aliasing Hardware}
\label{ALIASING-HARDWARE}

The ultimate solution to the aliasing problem is new hardware.
At its simplest, registers, which currently hold a datum,
are replaced by triples of registers which hold a datum,
an address, and selection codes.  The register datum equals the value
of the memory location at the register address.  The selection
codes determine which part of this memory location is read or written
when the register is read or written.  If any memory location is
changed, the address of the location is checked against all the
register addresses, and if any match, the corresponding register
data are changed.

This is, however, not sufficient, because sometimes one register
address is a function of another register's datum.  For example,
consider the unchecked code:
\begin{indpar}[0.5em]\begin{verbatim}
struct S { ...; int32 m; ... }
S * * x
S * *& y = * x
int32 *& z = y->m
\end{verbatim}\end{indpar}
If we consider \TT{x}, \TT{y}, and \TT{z} to be registers,
the address of \TT{y} equals the value of \TT{x}, and the
address of \TT{z} equals the value of \TT{y} plus the offset of
\TT{m} in \TT{S}.

If the value of \TT{x} changes, this changes the address of \TT{y},
which may change the datum of \TT{y} and that may change the value
of \TT{y}.  If the value of \TT{y} changes, this changes the address
of \TT{z}, which may change the datum and value of \TT{z}.

The way we accommodate this is to use the selection codes of \TT{y}
to specify that the address of \TT{y} contains the value of \TT{x}
as an additive component, so
that if the value of \TT{x} is changed by adding $\Delta$\TT{x}
then the address of \TT{y} should be changed by adding $\Delta$\TT{x}.
And similarly the selection codes
of \TT{z} specify that the address of \TT{z}
contains the value of \TT{y} as an additive component.

So why should we bother with automatically updating
additive inclusions of one value in the
address of another value, and not bother with other expressions.
The reason is that expressions such as
`\TT{(*x)->m}' are likely to be reused frequently in code (actually,
in automatically generated code) and
therefore need to be cached, whereas an expressions of the form
`\TT{c*d}' will be reused comparatively rarely code
and therefore are not worth special hardware.


\bibliographystyle{plain}
\bibliography{layered-l-2012-language}

\printindex

\end{document}

