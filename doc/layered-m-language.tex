% The Layered Middle (M) Programming Language
%
% File:         layered-m-language.tex
% Author:       Bob Walton (walton@deas.harvard.edu)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\ttikey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Layered Middle (M) Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

February 14, 2007
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Introduction}

This document describes the Middle Layer Programming Language, or
M-Language.  See the Introduction to the Layered
Programming Languages for an a description of the syntax of
the M-Language and an overview of the related
Lower Layer L-Language and Higher Layer H-Language.


\section{Memory}
\label{MEMORY}

We begin with an overview of M-language memory, and then provide
details in the following subsections.

\subsection{Blocks}

An M-language memory \key{block} is a sequence of bits.
Blocks can be contained in other blocks or can overlap.

A block contains a subblock called the \ikey{root}{of block}
of the block.  For many blocks the root and the block are the same.
For blocks that can grow, the root is the part of the block that
is always there, and which contains information telling how much
the block has grown.

When a block is stored in memory, it has a \ikey{bit address}{of block}.
The bit address plus some constant offset is the bit address of the first
bit of the root of the block.

Blocks have the following attributes:

\begin{indpar}\begin{tabular}{p{1.0in}p{4.0in}}
\ttikey{size}{of block}
    & Number of bits in the root of the block.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.0in}}
\ttikey{growth}{of block}
    & \ttikey{up}{block growth} and/or \ttikey{down}{block growth} or neither;
      Both {\tt up} and {\tt down} mean the block may be larger than its root.
      {\tt up} means there may be extra bits after the
      root, and {\tt down} means there may be extra bits before the root.
      If the {\tt growth} of a block is neither {\tt up} nor {\tt down},
      the block is the same as its root.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.0in}}
\ttikey{offset}{of block}
    & Offset in bits of the bit address of the first bit of the block
      root from the bit address of the block, when the block is stored
      in RAM memory.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.0in}}
\ttikey{alignment}{of block}
    & Exact divisor of bit address of the first bit of the root of
      the block, when the block is stored in RAM memory.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.0in}}
\ttikey{mobility}{of block}
    & \ttikey{fixed}{block mobility},
      \ttikey{movable}{block mobility},
      or \ttikey{free}{block mobility}.
      A {\tt fixed} block is stored in RAM memory at a fixed address.
      A {\tt movable} block is stored in RAM memory at an address that
      may be either fixed or may be changed according to the
      protocol defined in \secref{TBD}.
      A {\tt free} block may be stored in register or RAM memory
      and moved at any time.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.0in}}
\ttikey{operability}{of block}
    & \ttikey{integer}{block operability},
      \ttikey{float}{block operability},
      \ttikey{address}{block operability}, or
      \ttikey{container}{block operability}.
      The {\tt operability} of a block determines the kind of
      register the block is stored in, if the block is moved to
      a register.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.0in}}
\ttikey{status}{of block}
    & \ttikey{constant}{block status} or
      \ttikey{variable}{block status}.  A {\tt constant}
      block cannot be change, while a {\tt variable} block can be.
\end{tabular}\end{indpar}

This is just enough information to allow the M-language implementation
to allocate blocks to memory and move blocks in memory.  A {\tt growth}
of `{\tt up}' means the {\tt size} is the minimum size and the actual size
is larger with the block extending above its address.  Similarly for
`{\tt down}' with the block extending below its address.  The {\tt alignment}
and {\tt offset} only affects blocks when they are stored in memory.
{\tt Fixed} blocks must have a fixed unchanging address;
{\tt movable} blocks must have an address but that can either be fixed
or can be changeable in a restricted way (see heavy weight addresses below);
{\tt free} blocks need not have any fixed address
and can be moved around in memory.
{\tt Operability} determines the kind of register
a block is copied into, when a block is placed in a register.  {\tt Status}
allows a block to be marked as {\tt constant} permitting it to be in
several places at once.

Both blocks and addresses are classified as `light weight'
or `heavy weight'.

A heavy weight block is a movable block that
has a reference pointer stored at a fixed location which
points at the block and which changes when the block moves.
A heavy weight address has
two parts: the address of a reference pointer, and an offset within
the heavy weight block that is pointed at by the reference pointer.

A lightweight block is a free block,
a fixed block allocated to a fixed address,
or a subblock of another block.  It can be a subblock of a
heavy weight block.
A heavy weight address is used to address a light weight subblock
of a heavy weight block.
A light weight address is just the address of a fixed, non-movable
(light weight) block.

The entire heavy weight block can be
addressed by a light weight address pointing at the reference pointer
of the block, but an addressing indirection is required to address
the block.  Such an address, which is just a heavy weight address
without any offset part, is called a `middle weight' address.
A heavy weight block that is never addressed by a heavy
weight address, but only by middle weight addresses, is called a
`middle weight block'.

Reference pointers can all be elements of a vector, in which case
a vector index can be used in place of the address of 
a reference pointer.  Alternatively reference pointers can be allocated
as the first thing in their movable heavyweight block, in which
case they must be addressed and not identified by index.  In this last
case, the entire heavy weight block must be allocated as a
subblock of a fixed block, so the location of the
reference pointer will be fixed.
However, a reference pointer can be garbage collected by keeping
two copies, the old and the new, with identical contents, and
then replacing all addresses or indices of the old pointer by
the address or index of the new pointer.

A heavy weight block can be moved almost anytime by
changing its reference pointer.  The block can be deallocated
almost anytime by moving it to unimplemented virtual memory.

A heavy weight block can be a stack that grows up or down, and
subblocks can be allocated to or deallocated from the growing
boundary of a stack.  Other blocks can also be stacks; but they
must have memory above or below them reserved for allocation
of subblocks.

A value is a sequence of blocks.  The last block is
the proper value.  The initial subsequence of all blocks except the last
is the `type' of the value, and is itself a value.
The type descibes the format of the value proper, and is used
to select function code when the value is given as an argument
to a function.  Some example types are 
`32-bit signed integer' and `64-bit floating point number'.
The type must specify the attributes of the value proper; e.g.,
the block size of the value proper.

As a special case, an empty sequence is taken as equal to
a particular value that is a type which specifies that the
value proper is a type and is constant.

A type defines a view of a value proper.  A value proper can
have several different views, i.e., can be the value proper
of several different values with different types.

Although a type is a value, it is constrained in many ways.
First, it must exist both at compile time and at run time.
Therefore it must be possible to copy a type to an external medium
and read it back into memory.
Second, types must be suitable for type-inference, a process in
which parts of the type are discovered and filled in, so
types must be able to exhibit partial information as well
as complete information.  Type inference is a search algorithm
that adds information to types, and may backup up the state
of a type to some previous state.  Asside from that actions
of type inference, types may not change their value.

A variable is a place in memory that holds a value.  A constant is just
a variable whose value may not be changed.

Normally at run time a variable is a sequence of just two blocks,
the first being a constant type, and the second the value proper,
which may or may not be constant, as is indicated by the type.
Normally during type inference at compile time a variable is a sequence of three
blocks, the first begin a constant type that indicates that the
second is a type that is not constant and can be changed, and the
third block being the value proper.  If the type (second block)
indicates, the third block can be constant.  If the type (second block)
does not have enough information, the value proper may not exist
(e.g., if the type does not have enough information to determine the
block size of the value proper).

However, there is no prohibition
against values having types that are not constant at run time, though
the available operations on such values are few and slow.  Such
values are well suited to compute inputs to delayed compilation
(see~\secref{EXPRESSIONS}).

A component of a value V is a value C that can be computed from V
by a designated `read function'.  The read function may take
agruments in addition to V, and these are called indices.
The components of a variable are just a components of the variable's value.
A component of a variable can itself be a variable if there is a
designated `write function' that changes the value returned for the
component.  Read and write functions for a component must obey
some rules: for example, two successive reads must return the same
value, and a read immediately following a write must return the value
written, when the value and index arguments given to successive functions
calls are the same.  In addition to read and write functions a component
may have update, accumulate, and test functions.

The different components of a variable obey different protocols.
The {\tt rw} protocol says that a component is readable and writable
at any time.  {\tt w/r} says that all writes occur before all reads.
{\tt w/a/r} says that writes occur first, then accumulates, then reads,
where accumulates are operations that may be exchanged, such as incrementing
the variable component by various amounts.

Types and type inference are not described in detail until
\secref{EXPRESSIONS}.
Components and protocols are not describe in detail until
\secref{PROTOCOLS}.  The other concepts just introduced are
defined in detail in the following subsections.

\section{Expressions}
\label{EXPRESSIONS}

The task of an expression is to compute values from other values.
This is straightforward except for issues in parsing, overloading,
implicit variable creation, implicit typing, implicit conversion,
and protection.

Parsing involves inserting implied parentheses and then rewriting
expressions, particularly those involving operators.  Overloading
involves picking which function to call given many functions with the
same name.  Implicit variable creation involves creating variables to
hold values output by one function and input by another.\footnote{
What we call `implicit variables' are usually called `temporary variables'.
We make the implicit variable creation process explicit for two reasons:
first, we have a more complex situation in which one function may
output many results, as is explained a bit further
in the text, and second, M-language debuggers have a mode of
operation in which instead of displaying location within the program
code, which can be a problematic concept given all the rewriting that
is done, they display the status of ordinary and implicit variables, making
it important to explain implicit variables carefully to novice programmers.}
Implicit typing involves assigning types to variables, such as implicit
variables, that were given no type or only a partial type in the code.
Implicit conversion involves inserting conversion operators to change the
type of a value.
Protection involves ensuring that code in a restricted protection domain
cannot be called or referenced from another protection domain without
explicit permission.

Parsing begins by identifying operators in an expression.  By using
a precedence level assigned to each operator/fixity pair (operators
can have three fixities: prefix, infix, or postfix), implied parentheses
are inserted.  The M-language differs from other computer languages
in not using associativity rules in doing this, so that, for
instance, `\verb|(0 < x <= y)|' has \underline{no} implied parentheses
inserted, and can be rewritten later to be the equivalent of
`\verb|(0 < x AND x <= y)|'.  After inserting implied parentheses,
expressions are rewritten using macros.  In the example just given,
`\verb|<|' and `\verb|<=|' have the same precedence level and invoke
the same rewrite macro.

Program code begins as text, a sequence of characters.  It is first
scanned to become a sequence of lexemes (words and numbers and
punctuation marks), and then parsed.  The lexemes are tagged with
their location within the text, and with the subexpression they
belong to after insertion of implied parentheses.  These tags
are carried through the rewriting of expressions, and may be copied
to new lexemes introduced during rewriting, so that eventually
a debugger can associate operations executed when the program runs with
particular lexemes and subexpressions in the program code text.

Parsing and rewriting use data constructs and operations provided
by the H-Language, the higher level layered language.  This language
provides, for example, for strings used to encode lexemes and
lists used to encode expressions.  Macros are user written H-language code
executed by the M-language compiler.

Overloading, implicit variable creation, implicit typing, and implicit
conversion are all
done together.  Each function definition has a component function called
the typer which takes as input a partial description of the types
and movement modes of the arguments of a call to the function
and any available values of compile time constant arguments
input to the function,
and produces as output possible completions of this information which
would allow the function definition to be used.  The movement modes
of an argument are `in' for an input argument, `out' for an output
argument, and `inout' for an argument that is both input and output.
The result of a function is treated here as an argument.
The typer succeeds or fails when it is given enough information to
ensure that the function definition can or cannot be used, and if it
is not given enough information, the typer proposes additions to the
information it is given, if it can.  Note that if all inputs to a function
are compile time constants, it may happen that the typer can produce
compile time constants for all outputs, and thus eliminate the need to execute
the function at run time.

Specification of argument movement modes determines what implicit
variables are needed.  Specification of argument types determines
implicit types of both implicit variables and of explicit variables
that are declared without types (or with incomplete types).

In addition to typers for explicitly named functions,
typers for implicitly named conversion functions are executed.
Conversion functions convert values of one type to values of a
different type: e.g., convert 32-bit integers to 64-bit floating
point numbers.  Implicit conversions are inserted into the value
flow wherever necessary and possible so that all the needed
types can be computed.

All this is a search that specifies implicit type information,
movement modes, implicit conversions, and compile time constants.
This search may have
multiple successful answers.  If it does the result is deemed
ambiguous and a compile error.  The user who provides multiple
definitions for a given function may elect to given them a priority
order, so that lower priority definitions will not be examined by
the search if a higher priority definition can be used, and ambiguity
may be avoided.  Similarly implied conversions have priorities, with not using
an implied conversion being given higher priority
than using any implicit conversion.

If the search fails to find any answer within a reasonable time, compilation
fails.  If this happens, the coder can explicitly specify as many more types,
variables, and conversions as is necessary to get the search to complete within
a reasonable time.  Here time is measured by counting certain operations
performed by the search, so the measure of reasonable time will be hardware
independent.

Typer functions can be implicitly declared using M-language function
declarations, or can be explicitly coded by the user.  The later option
is of course more flexible.

After all types are computed and all overloaded function definitions
have been selected, the function definitions generate function code.
The generated code may just be a fixed block of M-language code,
or it may be generated by calling a generation component function of the
function definition.  Such a generation function is written in the H-language
and returns the code for the function, given the types and movement modes
of its arguments, and any compile time constant argument values.

The M-language also supports delayed compilation of both code blocks and
functions.   In either case some set of arguments or variables or types
is specified to be the set of parameters input to a code generator
that generates the block or function code.
The generated code may be a constant
block of M-Language code that has implied types or uses parameters as
compile time constants, or the generated code may be
M-Language code output by a user supplied H-Language code generator function.
Every time the function or block executes the current values of its
parameters may be input to the code generator to generate the code to be
executed.  The result is cached according to the
parameter values, so that when the function or block is invoked again,
if the parameters are the same the compiled code may be taken from the
cache and not recompiled.

\section{Protocols}
\label{PROTOCOLS}


\bibliographystyle{plain}
\bibliography{layered-m-language}

\printindex

\end{document}

