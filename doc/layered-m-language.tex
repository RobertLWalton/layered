% The Layered Middle (M) Programming Language
%
% File:         layered-m-language.tex
% Author:       Bob Walton (walton@acm.org)
% Version:      1a
  
\documentclass[12pt]{article}

\usepackage{makeidx}
\usepackage{pictex}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\raggedbottom

\setlength{\unitlength}{1in}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\ttkey}[1]{{\tt \bf #1}\index{#1@{\tt #1}}}
% < and > do not work for \tt \bf, hence:
\newcommand{\ttnbkey}[1]{{\tt #1}\index{#1@{\tt #1}}}
\newcommand{\ttmkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttmnbkey}[2]{{\tt #1}\index{#1@{\tt #1}!#2}}
\newcommand{\ttfkey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}
\newcommand{\ttakey}[2]{{\tt \bf #1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{{\tt \bf #1}\index{#2@{\tt #1}!#3}}
\newcommand{\ttdkey}[1]{{\tt \bf .#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{{\tt \bf .#1}\index{#1@{\tt .#1}!#2}}
\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\ttikey}[2]{{\tt \bf #1}\index{#1@{\tt #1}!#2}}
\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\secref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\stepref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\appref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\figref}[1]{\ref{#1}$^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newcount\TildeCatcode
\TildeCatcode=\catcode`\~
\catcode`~=12
\newcommand{\Tilde}{~}
\catcode`~=\TildeCatcode

\newcount\CircumflexCatcode
\CircumflexCatcode=\catcode`\^
\catcode`^=12
\newcommand{\Circumflex}{^}
\catcode`^=\CircumflexCatcode

\newcount\CurlyBraCatcode
\newcount\CurlyKetCatcode
\newcount\SquareBraCatcode
\newcount\SquareKetCatcode
\CurlyBraCatcode=\catcode`{
\CurlyKetCatcode=\catcode`}
\SquareBraCatcode=\catcode`[
\SquareKetCatcode=\catcode`]

\catcode`{=\SquareBraCatcode
\catcode`}=\SquareKetCatcode
\catcode`[=\CurlyBraCatcode
\catcode`]=\CurlyKetCatcode

\newcommand[\CurlyBra][{]
\newcommand[\CurlyKet][}]

\catcode`{=\CurlyBraCatcode
\catcode`}=\CurlyKetCatcode
\catcode`[=\SquareBraCatcode
\catcode`]=\SquareKetCatcode

\newcommand{\ttbrackets}{%
    \renewcommand{\{}{\CurlyBra}%
    \renewcommand{\}}{\CurlyKet}}

\newsavebox{\TILDEBOX}
\begin{lrbox}{\TILDEBOX}
\verb|~|
\end{lrbox}
\newcommand{\TILDE}{\usebox{\TILDEBOX}}

\newsavebox{\BACKSLASHBOX}
\begin{lrbox}{\BACKSLASHBOX}
\verb|\|
\end{lrbox}
\newcommand{\BACKSLASH}{\usebox{\BACKSLASHBOX}}

\newsavebox{\LEFTBRACKETBOX}
\begin{lrbox}{\LEFTBRACKETBOX}
\verb|{|
\end{lrbox}
\newcommand{\LEFTBRACKET}{\usebox{\LEFTBRACKETBOX}}

\newsavebox{\RIGHTBRACKETBOX}
\begin{lrbox}{\RIGHTBRACKETBOX}
\verb|}|
\end{lrbox}
\newcommand{\RIGHTBRACKET}{\usebox{\RIGHTBRACKETBOX}}

\newsavebox{\UNDERLINEBOX}
\begin{lrbox}{\UNDERLINEBOX}
\verb|_|
\end{lrbox}
\newcommand{\UNDERLINE}{\usebox{\UNDERLINEBOX}}

\newsavebox{\CIRCUMFLEXBOX}
\begin{lrbox}{\CIRCUMFLEXBOX}
\verb|^|
\end{lrbox}
\newcommand{\CIRCUMFLEX}{\usebox{\CIRCUMFLEXBOX}}

\newsavebox{\BARBOX}
\begin{lrbox}{\BARBOX}
\verb/|/
\end{lrbox}
\newcommand{\BAR}{\usebox{\BARBOX}}

\newsavebox{\LESSTHANBOX}
\begin{lrbox}{\LESSTHANBOX}
\verb/</
\end{lrbox}
\newcommand{\LESSTHAN}{\usebox{\LESSTHANBOX}}

\newsavebox{\GREATERTHANBOX}
\begin{lrbox}{\GREATERTHANBOX}
\verb/>/
\end{lrbox}
\newcommand{\GREATERTHAN}{\usebox{\GREATERTHANBOX}}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}
	 \begin{center}
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{center}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\begin{document}
        
\begin{center}

{\Large
The Middle (M) Layer Programming Language \\[0.5ex]
(Draft 1a)}

\medskip

Robert L. Walton\footnote{This document is dedicated to the memory
of Professor Thomas Cheatham of Harvard University.}

May 1, 2007
 
\end{center}

{\small
\tableofcontents 
}

\newpage

\section{Introduction}

This document describes the Middle Layer Programming Language, or
M-Language.  See the Introduction to the Layered
Programming Languages for an a description of the syntax of
the M-Language and an overview of the related
Lower Layer L-Language and Higher Layer H-Language.


\section{Memory}
\label{MEMORY}

We begin with an overview of M-language memory, and then provide
details in the following subsections.

TBD

\subsection{Blocks}
\label{BLOCKS}

An M-language memory \key{block} is a sequence of consecutive bit addresses.
Blocks can be contained in other blocks or can overlap.

A block contains a subblock called the \ikey{base}{of block}
of the block.  For many blocks the base and the block are the same.
For blocks that can grow, the base is the part of the block that
is always there.

When a block is stored in RAM (random access memory),
it has a \ikey{bit address}{of block}.  The block bit address plus
some constant offset is the bit address of the first
bit of the base of the block.

Blocks have the following attributes:

\begin{indpar}\begin{tabular}{p{1.0in}p{4.5in}}
\ttikey{size}{of block}
    & Number of bits in the base of the block.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.5in}}
\ttikey{growth}{of block}
    & \ttikey{up}{block growth} and/or \ttikey{down}{block growth} or neither;
      Both {\tt up} and {\tt down} mean the block may be larger than its base.
      {\tt up} means there may be extra bits after the
      base, and {\tt down} means there may be extra bits before the base.
      If the {\tt growth} of a block is neither {\tt up} nor {\tt down},
      the block is the same as its base.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.5in}}
\ttikey{offset}{of block}
    & Offset in bits of the bit address of the first bit of the block
      base from the bit address of the block, when the block is stored
      in RAM.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.5in}}
\ttikey{alignment}{of block}
    & A strictly positive integer, the exact divisor of the block bit address,
      when the block is stored in RAM.  Usually a power of 2, frequently
      at least 8.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.5in}}
\ttikey{mobility}{of block}
    & \ttikey{fixed}{block mobility},
      \ttikey{movable}{block mobility},
      or \ttikey{free}{block mobility}.
      A {\tt fixed} block is stored in RAM at a fixed address.
      A {\tt movable} block is stored in RAM at an address that
      may be either fixed or may be changed according to the
      rules for managing indirect addresses below
      (\secref{BLOCK-MOVEMENT-PROTOCOL}).
      A {\tt free} block may be stored in register or RAM
      and moved at any time.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.5in}}
\ttikey{operability}{of block}
    & \ttikey{integer}{block operability},
      \ttikey{float}{block operability},
      \ttikey{direct-address}{block operability},
      \ttikey{indirect-address}{block operability},
      \ttikey{contain\-er}{block operability}, or
      \ttikey{memory-channel}{block operability}.
      The {\tt opera\-bility} of a block determines the kind of
      register the block is stored in, if the block is moved to
      a register.  The block must be {\tt free}, but non-{\tt free}
      blocks also have operability in case their contents are copied
      to another block in a register.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.0in}p{4.5in}}
\ttikey{status}{of block}
    & \ttikey{constant}{block status} or
      \ttikey{variable}{block status}.  A {\tt constant}
      block cannot be changed, while a {\tt variable} block can be.
\end{tabular}\end{indpar}

This is just enough information to allow the M-language implementation
to allocate blocks to memory and move blocks in memory.

If any bit address is a multiple of 8, then the bit address divided by
8 is its corresponding \key{byte address}.  If the alignment of a block
is a multiple of 8, the byte address of the block is its bit address
divided by 8.

Blocks with `{\tt integer}', `{\tt float}', or `{\tt direct-address}'
{\tt operability}
are numbers.  The block {\tt size} is the size of the number, and is
constrained by the {\tt operability}: for example, all
`{\tt direct-address}' blocks must have {\tt size} {\tt 64}.
These numbers are as described in the `Numbers' section of the
Lower (L) Layer Programming Language manual.  Recall that direct
addresses are 64 bit integers that hold byte addresses in their
low order bits (typically the low order 44 bits, but there is no
standard for how many low order bits are used).


Similarly blocks with `{\tt indirect-address}' {\tt operability}
are as described in the `Indirect Addresses' section of the
Lower (L) Layer Programming Language manual.  Here the {\tt size}
is {\tt 64} times the `level' of the indirect address.

Recall that as stated in the
Lower (L) Layer Programming Language manual, an
\key{indirect address} consists of a direct address $A$
and $L$ offsets, $O_1$, $O_2$, \ldots, $O_L$, where $L\geq 0$ is the
\mkey{level}{of indirect address} of the indirect address.
The indirect address represents the \mkey{target address}{of indirect address}:

\begin{center}
\begin{tabular}{l@{~~~~~~}l}
\bf Level & \bf Target Address \\[2ex]
0 & $(*A)$ \\
1 & $((*A)+O_1)$ \\
2 & $(*((*A)+O_1)+O_2)$ \\
3 & $(*(*((*A)+O_1)+O_2)+O_3)$ \\
\ldots & \ldots
\end{tabular}
\end{center}

where $*$ is the \key{indirect addressing operation}
that takes the direct address $D$ of another direct address $F$ stored
in RAM, and returns $F$.  $F$, which is called the \key{forwarding address},
is both a direct address number and a block, and as a block
is required to have 64 bits as both its length and alignment.
Recall that all direct addresses are byte addresses, and the the offsets
in an indirect address are offsets in bytes.

Recall that forwarding
addresses are permitted to change at most times, as long as they
change according to a particular protocol.
Moveable blocks must be pointed at by indirect addresses, hence by
forwarding addresses, except for
short pieces of code during which block movement is prohibited.
See~\secref{BLOCK-MOVEMENT-PROTOCOL} for details.

Lastly blocks with `{\tt memory-channel}' {\tt operability}
are as described in the `Memory Channel' section of the
Lower (L) Layer Programming Language manual.

\subsection{Block Graphs}
\label{BLOCK-GRAPHS}

A \key{pointer} is a list of constant free blocks
from which a block bit address can be
computed by some \key{pointer function}.
The block whose bit address is computed is the
\key{target} of the pointer.

A direct or indirect address can be used as a pointer.  A pointer
can also be in integer that is an index into some structure holding
direct or indirect addresses, for example.

A \key{block graph} is:

\begin{itemize}

\item A set of blocks.

\item For each of these blocks, a (possibly empty) set of pointers to blocks
      in the graph.  These are the pointers of the graph.
      Each block is the \key{source} of the pointers in its set.
      Each block that is a target of one of these pointers must be stored
      in RAM, but blocks that are not targets can be free.

\item A particular subset of the blocks of the graph whose elements
      are called the \ikey{roots}{root!of block graph} of the
      block graph.

\end{itemize}

A \key{object} is a subgraph of a block graph that consists of
a single root block and all blocks reachable from this root
by following graph pointers whose targets are not root blocks.
Thus there is only one root block in a object, which is called
the \ikey{root}{of object} of the object.

A object points at another object if some block of the first
object sources a graph pointer whose target is the root of
the second object.  A set of objects is \ikey{closed}{set of objects}
if no object in the set points at a object outside the set.

Block graph blocks that are not stored in RAM cannot have bit
addresses or be targets of pointers.  Roots of objects can be such blocks.
All non-root blocks in an object
must be have bit addresses and be stored in RAM,
as they are all pointer targets.

An object whose root is stored in RAM is called a \key{RAM object}.
The \mkey{bit address}{of RAM object}
of a RAM object is the bit address of its root.
The \mkey{byte address}{of RAM object}
of a RAM object is the byte address of its root, if that exists
(e.g., if the root block has an alignment that is a multiple of 8).

An object is called {\tt moveable}, {\tt fixed}, or {\tt free}
according to whether or not its root is {\tt moveable},
{\tt fixed}, or {\tt free}.  Pointers to {\tt moveable} objects
are either indirect addresses, or themselves indirectly reference
indirect addresses.

A block graph is really a way of viewing the contents of memory.  The same
memory contents can be viewed in many ways using different block graphs:
in general there is no one unique block graph in a computational process.
Blocks of memory may also be outside any block graph of the process.

A block graph is said to be \key{non-overlapping} if no two blocks
in the graph overlap and no two objects in the graph overlap.
The latter statement is equivalent to saying that
no non-root block in the graph is reachable from
two different roots by following pointers whose targets are not roots.

A \key{constituent} of a block is a subblock.  The larger
block is the \ikey{container}{of constituent} of the constitutent.
Note that elsewhere we define a \key{component} of a block to
be a value that can be computed from the block, which is a much
more general concept.

The pointers sourced by a block may be constituents of the block,
or may be components -- i.e., values that can be computed from the
block.

An object is said to be a \mkey{constant}{object}\label{CONSTANT-OBJECT}
if no part of it changes
except for bits in any graph pointer constituents it contains,
and if its graph does
not change.

A block graph is said to be \key{exportable} if it is non-overlapping,
if the pointers sourced at each graph block are non-overlapping constituents
of the block, if all its objects are RAM objects (all roots have bit addresses),
and if a closed set of objects can be copied to another
memory, or to a disjoint part of the memory holding the graph,
by copying the blocks of the
set and then changing only the bits of the graph pointer constituents
of these copies so the graph structure of the set of copies is the same
as the graph structure of the copied closed set of objects.

Intuitively a copy of a closed set of objects of an
exportable block graph should have the same information content as the
copied original.  But this cannot be rigorously defined for the general
case.  All we can do is rigorously define the copy operation, and assert
that the copy can be used to provide the same information as the original.

An \key{exportable object} is an object in an exportable block graph.

It is possible to copy a non-closed set of objects of an exportable
block graph using stubs.  A \key{stub} for an object
is a copy of some of the information in the object, with enough information
being present to identify the object.  When copying a non-closed set of
objects, stubs can be created for any non-copied objects pointed at by
copied objects.  If stubs already exist for these objects, they can be
located and used instead of creating new stubs.  If an object is copied
that already has a stub copy, that stub can be replaced by the copied object.
Note that in order to be able to replace a stub by an object, either the
stub must be as big as the root of the object, or the object must be
moveable (have a moveable stub and root) so the root can be expanded.

\subsection{Values and Types}
\label{VALUES}

A \key{value} is a sequence of objects.  The last object is
the \key{value proper}.
The initial subsequence of all objects except the last
is the \key{type} of the value, and is itself a value.

The block graph of each object in a value can be \underline{different}.
The objects in a value need not be RAM objects.

The type of a value descibes the format of the value proper, and is used
to select function code when the value is given as an argument
to a function.  Some example types are 
`32-bit signed integer' and `64-bit floating point number'.
The type must specify the attributes of the root of the value proper; e.g.,
the size of the root.  The type must also specify the block graph
to which the value proper belongs.

Since a type is a value, its last object is a value proper for the type,
and the sequence of preceding objects is the type of the type.
As a special case, the empty sequence is taken as equal to
a particular value that is a type that specifies that the
associated value proper is a type.

A type defines a view of a value proper.  A value proper can
have several different views, i.e., can be the value proper
of several different values with different types.

A type has some special properties.  First, there is a partial order
relation on types, such that if type $T_2$ is greater than
type $T_1$, then $T_2$ contains all the information $T_1$ does and
more.  Second, there is a component of each type that tells whether
the type is `\ikey{constant}{type}', which means the type may not
be changed.  In particular, information cannot be added to a constant
type.  However, some types are never constant in the sense for the {\tt status}
block attribute, as if they were the component that says they are constant
could not be set.

Types must be exportable.

When code is compiled that uses a value, the compilation makes the
type of the value constant, if it is not already constant.
Compilation may first run the `type inference algorithm', described below,
that adds information to the type.  Any value used by compiled
always has a constant type.

A type may specify that any associated value proper is a constant that
may not change.  What is meant by this is that the bits of the blocks
in the value proper (which is an object) will not change, except that
pointer constituents may change, as long as the graph of the object
does not change.  A value with such a type is called a \key{constant}.
Other values are called \skey{variable}s.

Types are computed by compile-time operations with
the help of type inference functions that are associated with run-time
operations whose invocations are being compiled.
The \skey{type inference function}s are compile-time operations that
take a set of values as input and produce
the same set as output, thus replacing their inputs by their outputs.
The values may be incomplete, in that information is missing from
their types, and that their value proper may be missing.
The type inference functions add information to make the values
more complete.

To support type inference, the partial order of on types is extended
to a partial order on values.  Usually this is done by using the
vacuous ordering on value propers: each value proper is neither greater than
nor less than any other value proper.  However, a missing value proper is always
less than a present value proper.

Given the partial order on values, the type inference functions are required
to be monotonic, in that they may only replace values by greater values,
in the sense of the information partial order on values.  Remember that by this
order 3 is neither greater than nor less than 2;
these two values a not compatible pieces of information,
and therefore they are not orderable using the
information partial ordering.

The \key{type inference algorithm} takes as input
a set of values (typically with unknown value propers)
and a set of calls to type inference functions, each with a subset
of the values as input and output.  The algorithm executes the calls
repeatedly until all calls make no changes.  The resulting values
are called a \ikey{stable point}{of type inference}.  It can be shown
that this is uniquely determined by the original inputs and type
inference functions, because the latter are monotonic.
It is an error if this algorithm
takes too long to run, as determined in a machine independent manner.
Such an error can be corrected by supplying more direct type (and sometimes
value) information in the program being compiled, so that the type
inference algorithm needs to add less information.
Note that it is not possible for the type inference
algorithm to run indenfinitely without the values becoming
indefinitely large.

In actual practice there are several possible sets of type inference
functions, due to overloading of run-time operation names,
and the compiler must select which
one to use.  Each type inference function may decide that its inputs
are not consistent for its purposes, in which case the set of inference
functions being tested cannot be used.  By this means a single set
of inference functions, corresponding to a single mapping of run-time
operation names to overloaded actual run-time operations,
must be selected, or the type inference
algorithm will be in error.

\subsection{TBD}
\label{TBD}

A component of a value V is a value C that can be computed from V
by a designated `read function'.  The read function may take
agruments in addition to V, and these are called indices.
The components of a variable are just a components of the variable's value.
A component of a variable can itself be a variable if there is a
designated `write function' that changes the value returned for the
component.  Read and write functions for a component must obey
some rules: for example, two successive reads must return the same
value, and a read immediately following a write must return the value
written, when the value and index arguments given to successive functions
calls are the same.  In addition to read and write functions a component
may have update, accumulate, and test functions.

The different components of a variable obey different protocols.
The {\tt rw} protocol says that a component is readable and writable
at any time.  {\tt w/r} says that all writes occur before all reads.
{\tt w/a/r} says that writes occur first, then accumulates, then reads,
where accumulates are operations that may be exchanged, such as incrementing
the variable component by various amounts.

Types and type inference are not described in detail until
\secref{EXPRESSIONS}.
Components and protocols are not describe in detail until
\secref{PROTOCOLS}.  The other concepts just introduced are
defined in detail in the following subsections.

\section{Expressions}
\label{EXPRESSIONS}

The task of an expression is to compute values from other values.
This is straightforward except for issues in parsing, overloading,
implicit variable creation, implicit typing, implicit conversion,
and protection.

Parsing involves inserting implied parentheses and then rewriting
expressions, particularly those involving operators.  Overloading
involves picking which function to call given many functions with the
same name and parsing properties.
Implicit variable creation involves creating variables to
hold values output by one function and input by another.\footnote{
What we call `implicit variables' are usually called `temporary variables'.
We make the implicit variable creation process explicit for two reasons:
first, we have a more complex situation in which one function may
output many results, as is explained a bit further
in the text, and second, M-language debuggers have a mode of
operation in which instead of displaying location within the program
code, which can be a problematic concept given all the rewriting that
is done, they display the status of ordinary and implicit variables, making
it important to explain implicit variables carefully to novice programmers.}
Implicit typing involves assigning types to variables, such as implicit
variables, that were given no type or only a partial type in the code.
Implicit conversion involves inserting conversion operators to change the
type of a value.
Protection involves ensuring that code in a restricted protection domain
cannot be called or referenced from another protection domain without
explicit permission.

Parsing begins by identifying operators in an expression.  By using
a precedence level assigned to each operator/fixity pair (operators
can have three fixities: prefix, infix, or postfix), implied parentheses
are inserted.  The M-language differs from other computer languages
in not using associativity rules in doing this, so that, for
instance, `\verb|(0 < x <= y)|' has \underline{no} implied parentheses
inserted, and can be rewritten later to be the equivalent of
`\verb|(0 < x AND x <= y)|'.  After inserting implied parentheses,
expressions are rewritten using macros.  In the example just given,
`\verb|<|' and `\verb|<=|' have the same precedence level and invoke
the same rewrite macro.

Program code begins as text, a sequence of characters.  It is first
scanned to become a sequence of lexemes (words and numbers and
punctuation marks), and then parsed.  The lexemes are tagged with
their location within the text, and with the subexpression they
belong to after insertion of implied parentheses.  These tags
are carried through the rewriting of expressions, and may be copied
to new lexemes introduced during rewriting, so that eventually
a debugger can associate operations executed when the program runs with
particular lexemes and subexpressions in the program code text.

Parsing and rewriting use data constructs and operations provided
by the H-Language, the higher level layered language.  This language
provides, for example, for strings used to encode lexemes and
lists used to encode expressions.  Macros are user written H-language code
executed by the M-language compiler.

Overloading, implicit variable creation, implicit typing, and implicit
conversion are all
done together.  Each function definition has a component function called
the typer which takes as input a partial description of the types
and movement modes of the arguments of a call to the function
and any available values of compile time constant arguments
input to the function,
and produces as output possible completions of this information which
would allow the function definition to be used.  The movement modes
of an argument are `in' for an input argument, `out' for an output
argument, and `inout' for an argument that is both input and output.
The result of a function is treated here as an argument.
The typer succeeds or fails when it is given enough information to
ensure that the function definition can or cannot be used, and if it
is not given enough information, the typer proposes additions to the
information it is given, if it can.  Note that if all inputs to a function
are compile time constants, it may happen that the typer can produce
compile time constants for all outputs, and thus eliminate the need to execute
the function at run time.

Specification of argument movement modes determines what implicit
variables are needed.  Specification of argument types determines
implicit types of both implicit variables and of explicit variables
that are declared without types (or with incomplete types).

In addition to typers for explicitly named functions,
typers for implicitly named conversion functions are executed.
Conversion functions convert values of one type to values of a
different type: e.g., convert 32-bit integers to 64-bit floating
point numbers.  Implicit conversions are inserted into the value
flow wherever necessary and possible so that all the needed
types can be computed.

All this is a search that specifies implicit type information,
movement modes, implicit conversions, and compile time constants.
This search may have
multiple successful answers.  If it does the result is deemed
ambiguous and a compile error.  The user who provides multiple
definitions for a given function may elect to given them a priority
order, so that lower priority definitions will not be examined by
the search if a higher priority definition can be used, and ambiguity
may be avoided.  Similarly implied conversions have priorities, with not using
an implied conversion being given higher priority
than using any implicit conversion.

If the search fails to find any answer within a reasonable time, compilation
fails.  If this happens, the coder can explicitly specify as many more types,
variables, and conversions as is necessary to get the search to complete within
a reasonable time.  Here time is measured by counting certain operations
performed by the search, so the measure of reasonable time will be hardware
independent.

Typer functions can be implicitly declared using M-language function
declarations, or can be explicitly coded by the user.  The later option
is of course more flexible.

After all types are computed and all overloaded function definitions
have been selected, the function definitions generate function code.
The generated code may just be a fixed block of M-language code,
or it may be generated by calling a generation component function of the
function definition.  Such a generation function is written in the H-language
and returns the code for the function, given the types and movement modes
of its arguments, and any compile time constant argument values.

The M-language also supports delayed compilation of both code blocks and
functions.   In either case some set of arguments or variables or types
is specified to be the set of parameters input to a code generator
that generates the block or function code.
The generated code may be a constant
block of M-Language code that has implied types or uses parameters as
compile time constants, or the generated code may be
M-Language code output by a user supplied H-Language code generator function.
Every time the function or block executes the current values of its
parameters may be input to the code generator to generate the code to be
executed.  The result is cached according to the
parameter values, so that when the function or block is invoked again,
if the parameters are the same the compiled code may be taken from the
cache and not recompiled.

\section{Protocols}
\label{PROTOCOLS}

\subsection{Block Movement Protocol}
\label{BLOCK-MOVEMENT-PROTOCOL}

\section{TBD}
Add discussion of indirect addresses and weight.\label{WEIGHT}


\bibliographystyle{plain}
\bibliography{layered-m-language}

\printindex

\end{document}

