// Layers Language Lexeme Nested Description Language
// Internal Data
//
// File:	ll_lexeme_ndl_data.h
// Author:	Bob Walton (walton@acm.org)
// Date:	Mon Jan 12 07:12:48 EST 2015
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.

// Table of Contents
//
//	Usage and Setup
//	Data

// Usage and Setup
// ----- --- -----

# ifndef LL_LEXEME_NDL_DATA_H
# define LL_LEXEME_NDL_DATA_H

# include <ll_lexeme.h>

// Data
// ----

namespace ll { namespace lexeme
    { namespace ndl { namespace data {

    using ll::lexeme::uns8;
    using ll::lexeme::uns32;

    // Various things are pushed into and popped from
    // the stacks.
    //
    // A begin_table, begin_dispatcher, and begin_atom_
    // pattern push a dispatcher to the dispatchers
    // stack.  Whenever a dispatcher is pushed an
    // instruction is simultaneously pushed into the
    // instructions stack, and ELSE's push additional
    // instructions into that stack.  An end_table,
    // end_dispatcher, and end_atom_pattern pop these
    // stacks.
    //
    // The <character-adder>s of a <dispatch> add char-
    // acters to the SECOND from topmost dispatcher.
    // Successive <dispatch> siblings get consecutive
    // character types within this second from topmost
    // dispatcher, beginning with 1.  An OTHERS sibling
    // gets type 0.
    //
    // Characters-adder's that add ASCII characters
    // modify the ascii_map of the second from topmost
    // dispatchers stack entry.
    //
    // Characters-adder's that add sequences of non-
    // ASCII characters are recorded in a separate
    // uns32_stack and the number of these is counted
    // in the topmost dispatchers stack entry.
    //
    // Instructions are recorded in the instructions
    // stack, and any translation strings they use
    // are recorded in the uns32_stack.
    //
    // Repetition counts are recorded in the topmost
    // entry.
    //
    // When the topmost dispatchers stack entry is
    // popped, it may or may not generate a dispatcher.
    // The topmost instructions stack entry is popped
    // simultaneously, and may or may not generate an
    // instruction.  The dispatcher ID of any generated
    // dispatcher and instruction ID of any generated
    // instruction, along with the number of non-ASCII
    // character sequences added and the repetition
    // count, are all pushed into the uns32_stack for
    // use in generating a dispatcher from the next
    // to topmost dispatchers stack entry.  All these
    // are associated in that dispatcher with the
    // character type associated with the topmost
    // dispatcher stack entry being popped.
    //
    // The begin_table function pushes 1 entry into the
    // dispatchers stack, and this generates the dispat-
    // cher of the table.  Each begin_dispatch pushes
    // another entry.  If a <dispatch> has no sub-<dis-
    // patch>es, its dispatchers stack entry does NOT
    // generate an actual dispatcher when the entry is
    // popped, but the other dispatchers stack entries
    // created within a table do generate actual dispat-
    // chers when they are popped.
    //
    // Begin_atom_pattern pushes two entries into the
    // dispatchers stack.  Each NEXT() pushes one more
    // entry.  End_atom_pattern pops all these entries
    // and generates a dispatcher for each but the
    // topmost.  All characters added have character
    // type 1, and there are no instructions.
    //
    // When the dispatchers and instructions stacks are
    // popped, the uns32_stack has the following in
    // order, where d is the dispatcher at the top of
    // the dispatchers stack before popping that stack:
    //    
    //	  d.type_map_count pairs from add_characters
    //        calls for this dispatcher:
    //		char_min
    //		char_max
    //    for each non-OTHERS subdispatcher (child of
    //		  this dispatcher):
    //	      subdispatcher type_map_count pairs:
    //		char_min
    //		char_max
    //	      the quadruple:
    //		subdispatcher dispatcher_ID
    //		subdispatcher instruction_ID
    //		subdispatcher repeat_count
    //		subdispatcher type_map_count
    //    for each instruction in the instruction stack,
    //	      translate_to_length uns32's giving the
    //	      translate vector in memory order
    //
    // Popping a dispatcher in a table pops an instruc-
    // tion group from the instruction stack and removes
    // the instruction and subdispatcher elements from
    // the uns32_stack, leaving the d.type_map_count
    // pairs from add_characters for the dispatcher d
    // being popped.  It then pushes into this stack the
    // new quadruple:
    //
    //	  dispatcher_ID of dispatcher generated by
    //	                popped dispatchers stack entry,
    //	                or 0 if no dispatcher generated
    //	  instruction_ID of instruction generated by
    //	                 popped instructions stack
    //	                 entry, or 0 if no instruction
    //	                 generated
    //	  d.repeat_count
    //	  d.type_map_count
    //
    // describing the popped dispatcher and instruction
    // group and giving information needed to map char-
    // acters to the character type of the popped entry.
    // The dispatchers stack entry being popped might
    // not create a dispatcher, in which case the pushed
    // dispatcher_ID will be 0; and similarly there may
    // have been no instruction, so the instructions
    // stack entry popped contains no instruction, in
    // which case the instruction_ID is 0.
    //
    // However, if the popped dispatcher is an OTHERS
    // dispatcher, this last quadruple is not pushed,
    // and the dispatcher_ID and instruction_ID are
    // instead copied to the parent dispatcher (the
    // repeat_count and type_map_count will be zero).
    //
    // Note that `popping an instruction group' means
    // popping all the instructions in a sequence
    //
    //	 <instruction> { ELSE(); <instruction> }*.
    //
    // and returning the instruction_ID of the first
    // instruction (last instruction popped) as the
    // instruction_ID of the group.
    //
    extern min::packed_vec_insptr<uns32> uns32_stack;

    // Accumulated information use to construct a
    // dispatch table for an atom pattern or <dispatch>.
    //
    // Add_characters calls edit the SECOND TO TOPMOST
    // dispatcher on the dispatchers stack to map the
    // characters indicated to this dispatcher's max_
    // type_code.
    // 
    struct dispatcher
    {
        uns32 line_number;
	    // Line number of begin_dispatch,
	    // begin_atom_pattern, begin_table,
	    // or NEXT.
        uns8 ascii_map[128];
	    // Type codes of ASCII characters.
	    // 0 if none.  Subdispatchers modify this
	    // when they add ASCII characters to their
	    // character patterns via their begin_
	    // dispatcher call or add_characters calls
	    // with ASCII quoted strings.
	uns8 max_type_code;
	    // Last type code assigned to this dispat-
	    // cher.  Incremented when a non-OTHER's
	    // subdispatcher is pushed into the dispat-
	    // chers stack.  This subdispatcher uses the
	    // incremented value as the type code to
	    // attach to.  OTHER's subdispatchers attach
	    // to type code 0.
	uns32 type_map_count;
	    // Number of min_char,max_char pairs in
	    // the uns32_stack for the type code in
	    // this dispatcher's parent that this
	    // dispatcher will be attached to.
	    // Pushed into the uns32_stack with the
	    // other data from this dispatcher for
	    // use by its parent dispatcher.
	    //
	    // Must be 0 for an OTHER's dispatcher.
	uns32 repeat_count;
	    // Repeat_count value for the character
	    // type in this dispatcher's parent that
	    // this dispatcher will be attached to.
	    // Pushed into the uns32_stack with the
	    // other data from this dispatcher for
	    // use by its parent dispatcher.
	uns32 others_dispatcher_ID;
	uns32 others_instruction_ID;
	    // Data from an OTHER's subdispatcher.
	    // Attached to type code 0 of this
	    // dispatcher.
	bool is_others_dispatcher;
	    // True if and only if this is an OTHER's
	    // dispatcher.
    };

    extern min::packed_vec_insptr<dispatcher>
           dispatchers;

    // Accumulated information to use in constructing
    // an instruction.  Pushed into the instructions
    // stack when a new dispatcher is pushed into the
    // dispatchers stack.  Also pushed by ELSE() to form
    // a multi-instruction instruction group.  The top-
    // most instruction group is popped when a dispat-
    // cher is popped.
    //
    struct instruction
    {
	uns32 line_number;
	    // Line number of first function to set
	    // instruction operation.  0 if none yet.
	uns32 operation;
	uns32 atom_table_ID;
	uns32 require_dispatcher_ID;
	uns32 erroneous_atom_type;
	uns32 output_type;
	uns32 goto_table_ID;
	uns32 call_table_ID;
	    // Arguments for ll::lexeme::create_
	    // instruction.  If ll::lexeme::translate_
	    // to_length ( operation ) is > 0, then it
	    // is the number of uns32's in the stack
	    // that represent the translation vector.
	    //
	    // Else_instruction_ID is not stored here
	    // but is set from the last instruction
	    // popped from the instruction stack when
	    // an instruction containing an ELSE flag
	    // is popped.
	bool accept;
	    // True if and only if this is an accept
	    // instruction.
    };

    extern min::packed_vec_insptr<instruction>
           instructions;

} } } }

# endif // LL_LEXEME_NDL_DATA_H
