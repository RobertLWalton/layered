// Layered Languages C++ Lexical Analyzer
//
// File:	ll_lexeme_c++.lexcc
// Author:	Bob Walton (walton@acm.org)
// Date:	Fri May 29 04:31:43 EDT 2015
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.

// Lines beginning with `lex<HT>' and lines equal to
// `lex' are copied to ll_lexeme_c++.lex and then
// to the C++ Lexical Program appendix of ../doc/
// layered-introduction.tex.
//
// Lines beginning with `cc<HT>' and lines equal to `cc'
// are copied to ll_lexeme_c++.cc and compiled to
// produce code that can create a C++ lexical program.
// Other lines are replaced by `//' so that line numbers
// in the .cc file will be the same as those in this
// .lexcc file.

// Table of Contents
//
//	Usage and Setup
//	Program Construction

// Usage and Setup
// ----- --- -----

cc	// This file was automatically generated from
cc	// ll_lexeme_c++.lexcc.
cc
lex	// This file was automatically generated from
lex	// ll_lexeme_c++.lexcc.
lex
cc	# include <ll_lexeme_ndl.h>
cc	# include <ll_lexeme_c++.h>
cc	using namespace ll::lexeme::ndl;
cc	# define LEX ll::lexeme
cc	# define LEXCPP ll::lexeme::cpp
cc	using namespace LEXCPP;
cc

// Program Construction
// ------- ------------

cc	min::locatable_var<LEX::program>
cc	    LEXCPP::default_program;
cc
cc	const char * const
cc		LEXCPP::type_names[MAX_TYPE+1] = {
cc
cc	    NULL,
cc	    "WHITESPACE",
cc	    "COMMENT",
cc	    "BRACKETED_HEADER_NAME",
cc	    "QUOTED_HEADER_NAME",
cc	    "OPERATOR",
cc	    "IDENTIFIER",
cc	    "DECIMAL_INTEGER",
cc	    "OCTAL_INTEGER",
cc	    "HEXADECIMAL_INTEGER",
cc	    "FLOAT",
cc	    "PP_NUMBER",
cc	    "CHARACTER_LITERAL",
cc	    "u_CHARACTER_LITERAL",
cc	    "U_CHARACTER_LITERAL",
cc	    "L_CHARACTER_LITERAL",
cc	    "STRING_LITERAL",
cc	    "u_STRING_LITERAL",
cc	    "U_STRING_LITERAL",
cc	    "L_STRING_LITERAL",
cc	    "NEWLINE",
cc	    "END_OF_FILE",
cc	    "MISPLACED_CHARACTER",
cc	    "ASCII_UNIVERSAL_CHARACTER",
cc	    "MISPLACED_UNIVERSAL_CHARACTER",
cc	    "SHORT_UNIVERSAL_CHARACTER",
cc	    "PREMATURE_NEWLINE",
cc	    "PREMATURE_END_OF_FILE",
cc	    "ILL_FORMED_ESCAPE",
cc	    "TOO_LONG_HEX_ESCAPE" };
cc
cc	const char * LEXCPP::type_codes =
cc	    "?w/bq+idohfnccccssssleMAUSLEPH";
cc
cc	void LEXCPP::init_cpp_program ( void )
cc	{
cc	    if ( LEXCPP::default_program != NULL_STUB )
cc	        return;
cc

lex	begin c++ lexical program;
lex
lex	// Before this lexical program is used the input
lex	// should be preprocessed to
lex	//
lex	//    (1) Replace trigraph sequences.
lex	//    (2) Eliminate carriage-returns next to a
lex	//        newline (others become misplaced)
lex	//    (3) Eliminate sequences of the form:
lex	//        backslash newline
lex	//
lex	// After this lexical program is used the output
lex	// should be post-processed to
lex	//
lex	//    (4) Perform C/C++ macro preprocessing
lex	//        (macro expansion).
lex	//    (5) Delete whitespace and newlines.
lex	//    (6) Concatenate adjacent quoted strings
lex	//        of the same character type (ordinary,
lex	//        u, U, or L).
lex
cc	    NDL::begin_program
cc		( type_names, type_codes, MAX_TYPE );
cc
cc	    uns32 whitespace;
cc	    NDL::new_table ( whitespace, whitespace_t );
cc
cc	    uns32 slash_star_comment;
cc	    NDL::new_table ( slash_star_comment,
cc	                     comment_t );
cc	    uns32 slash_slash_comment;
cc	    NDL::new_table ( slash_slash_comment,
cc	                     comment_t );
cc
cc	    uns32 bracketed_header_name;
cc	    NDL::new_table ( bracketed_header_name,
cc	                     bracketed_header_name_t );
cc	    uns32 quoted_header_name;
cc	    NDL::new_table ( quoted_header_name,
cc	                     quoted_header_name_t );
cc
cc	    uns32 identifier;
cc	    NDL::new_table ( identifier, identifier_t );
cc
cc	    uns32 decimal_integer;
cc	    NDL::new_table ( decimal_integer,
cc			     decimal_integer_t );
cc	    uns32 octal_integer;
cc	    NDL::new_table ( octal_integer,
cc			     octal_integer_t );
cc	    uns32 hexadecimal_integer;
cc	    NDL::new_table ( hexadecimal_integer,
cc			     hexadecimal_integer_t );
cc	    uns32 suffix;
cc	    NDL::new_table ( suffix, NONE );
cc	    uns32 float_integer;
cc	    NDL::new_table ( float_integer, float_t );
cc	    uns32 fraction;
cc	    NDL::new_table ( fraction, float_t );
cc	    uns32 exponent;
cc	    NDL::new_table ( exponent, float_t );
cc	    uns32 pp_number;
cc	    NDL::new_table ( pp_number, pp_number_t );
cc
cc	    uns32 char_literal;
cc	    NDL::new_table ( char_literal, NONE );
cc	    uns32 string_literal;
cc	    NDL::new_table ( string_literal, NONE );
cc
cc	    uns32 initial;
cc	    NDL::new_table ( initial, MASTER );
cc	    uns32 pp_beginning;
cc	    NDL::new_table ( pp_beginning, MASTER );
cc	    uns32 pp_include;
cc	    NDL::new_table ( pp_include, MASTER );
cc	    uns32 normal;
cc	    NDL::new_table ( normal, MASTER );
cc	    uns32 premature_newline;
cc	    NDL::new_table ( premature_newline,
cc	                     MASTER );
cc	    uns32 premature_end_of_file;
cc	    NDL::new_table ( premature_end_of_file,
cc	                     MASTER );
cc
cc	    uns32 operator_atom;
cc	    NDL::new_table ( operator_atom, ATOM );
cc	    uns32 escaped_char;
cc	    NDL::new_table ( escaped_char, ATOM );
cc	    uns32 universal_char;
cc	    NDL::new_table ( universal_char, ATOM );
cc	    uns32 short_universal_char;
cc	    NDL::new_table
cc		( short_universal_char, ATOM );
cc
lex	"<digit>" = "0-9";
lex
lex	"<non-zero-digit>" = "1-9";
lex
lex	"<oct-digit>" = "0-7";
lex
lex	"<hex-digit>" = "0-9" | "a-f" | "A-F";
lex
cc	    const char * digit = "0123456789";
cc	    const char * non_zero_digit = "123456789";
cc	    const char * oct_digit = "01234567";
cc	    const char * hex_digit =
cc	        "0123456789ABCDEFabcdef";
cc
lex	"<ascii-letter>" = "a-z" | "A-Z";
lex
cc	    const char * ascii_letter =
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
cc
lex	"<letter>" = "<UNICODE-CATEGORY-L>"
lex
lex	"<non-ascii-letter>" =   "<letter>"
lex			     & ~ <ascii-letter>
lex
cc	   uns32 non_ascii_letter;
cc	   NDL::begin_atom_pattern ( non_ascii_letter );
cc	       NDL::add_category ( "L" );
cc	       NDL::sub_chars ( ascii_letter );
cc	   NDL::end_atom_pattern();
cc
lex	"<ascii-character>" =   "<00-3F>"
lex
cc	   uns32 ascii_char;
cc	   NDL::begin_atom_pattern ( ascii_char );
cc	       for ( unsigned c = 0; c < 128; ++ c )
cc	           NDL::add_char ( c );
cc	   NDL::end_atom_pattern();
cc
lex	// <non-spacing-combining-char> ::=
lex	//         "<UNICODE-CATEGORY-Mn>"
lex
lex	// Universal characters are only permitted in
lex	// identifiers, character literals, and string
lex	// literals.  In identifiers they must represent
lex	// non-ASCII-letters or non-ASCII combining
lex	// characters, and the latter cannot be the
lex	// initial character of an identifier.
lex
lex	"<identifier-non-digit>" = "_" | "<letter>";
lex
lex	"<identifier-char>" =
lex	      "<identifier-non-digit>"
lex	    | "<digit>"
lex	    | "<non-spacing-combining_char>"
lex
lex	"<non-ascii-identifier-char>" =
lex	      "<identifier-char>" & ~ <ascii-char>
lex
cc	   uns32 non_ascii_identifier_char;
cc	   NDL::begin_atom_pattern
cc	           ( non_ascii_identifier_char );
cc	       NDL::add_category ( "L" );
cc	       NDL::sub_chars ( ascii_letter );
cc	       NDL::add_category ( "Mn" );
cc	   NDL::end_atom_pattern();
cc
lex	// Because `u', `U', or `L' can start a char-
lex	// acter or string literal, we must define:
lex	//
lex	"<u_U_L>" = "u" | "U" | "L";
lex	"<identifier-non-literal>" =
lex	          "<identifier-non-digit>"
lex	        & ~ "<u_U_L>";
lex
lex	"<whitespace-char>" =
lex	    " " | "<HT>" | "<VT>" | "<FF>";
lex	    // newline is treated separately
lex
cc	    const char * whitespace_char = " \t\v\f";
cc
lex
lex	// The following can begin an operator or punc-
lex	// tuation mark.
lex	//
lex	// / not followed by / or * and . not followed
lex	// by <digit> are handled separately.
lex	//
lex	"<op-char>" = "#" | "<" | ">" | ":" | "%" |
lex	            | "?" | "+" | "-" | "*" | "="
lex	            | "^" | "&" | "|" | "~" | "!" | ","
lex	            | "(" | ")" | "[" | "]" | "{" | "}"
lex	            | ";";
lex
cc	    const char * op_char =
cc	        "#<>:%?+-*=^&|~!,()[]{};";
cc
lex	"<sign>" = "+" | "-" ;
lex
cc	    const char * sign = "+-";
cc
lex	"<u_U>" = "u" | "U" ;
lex
cc	    const char * u_U = "uU";
cc
lex
lex	// C/C++ preprocessing is hereafter abbreviated
lex	// as `pp'.
lex
lex	// Alternative operators that are not identi-
lex	// fiers are translated.  E.g., <: becomes [ in
lex	// the lexeme translation.
lex
lex	// C++ punctuation are treated as `operators'.
lex
lex	// Pp numbers are divided into 5 categories
lex	// (note that a `suffix' is an identifier):
lex	//
lex	//      decimal integer
lex	//          nothing but digits not beginning
lex	//          with 0, with an optional suffix
lex	//      octal integer
lex	//          nothing but octal digits beginning
lex	//          with 0, with an optional suffix
lex	//      hexadecimal integer
lex	//          nothing but hexadecimal digits
lex	//          refaced by 0x or 0X, with an
lex	//          optional suffix
lex	//      float
lex	//          legal floating point #'s, with an
lex	//          optional suffix
lex	//      pp number
lex	//          all other pp numbers
lex
lex	// Because of pp control lines, lexical scanning
lex	// is slightly context dependent.  There are
lex	// several contexts, each corresponding to a
lex	// different master table:
lex	//
lex	//    initial master
lex	//        Used in line beginning situations to
lex	//        recognize the # token that introduces
lex	//        a pp control line.
lex	//    pp beginning master
lex	//        Used to scan the beginning of a pp
lex	//        control line after the # has been
lex	//        scanned but before anything else is
lex	//        scanned.
lex	//    pp include master
lex	//        Used to scan the pp-header token in a
lex	//        #include line after #include has been
lex	//        scanned.
lex	//    normal master
lex	//        Used to scan a non pp control line or
lex	//        the rest of a pp control line after
lex	//        any #include header.
lex	//
lex	// The whitespace lexeme types are:
lex	//
lex	//    newline
lex	//        a single <NL>
lex	//    horizontal-space
lex	//        sequence of "<whitespace-char>"s
lex	//        (excludes <NL>'s)
lex	//    comment
lex	//        "/*" comment (including /* and */)
lex	//        "//" comment (including // but not
lex	//                      ending newline)
lex	//
lex	// This allows line feeds to be used to end pp
lex	// control lines.
lex
lex
lex	// Characters that are not part of legal lexemes
lex	// and which are outside character literal ''s
lex	// and and quoted string literal ""s are made
lex	// into error lexemes that can separate other
lex	// lexemes in exactly the same way that white-
lex	// space can.
lex	//
lex	// Note that ## cannot be used to move charac-
lex	// ters inside a character or string literal ''
lex	// or "".  Also, we do NOT allow ## to append a
lex	// combining character to another character.
lex	// Therefore ## cannot be used to create a legal
lex	// pp token by concatenating a legal pp token
lex	// with a stray character that is not part of a
lex	// legal pp token.  Thus we can treat all stay
lex	// characters as errors, instead of making them
lex	// into pp tokens.
lex
lex	// Characters that are part of erroneous atoms
lex	// INSIDE character literal ''s or quoted string
lex	// ""s are announced as part of an erroneous
lex	// atom which is translated to "" and ignored as
lex	// if it did not appear at all in the input.
lex
lex	begin initial master table;
lex
cc	    NDL::begin_table ( initial );
cc
lex	    "<whitespace-char>" call whitespace;
lex
cc		NDL::begin_dispatch ( whitespace_char );
cc		   NDL::call ( whitespace );
cc		NDL::end_dispatch();
cc
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur INSIDE
lex	    // a pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
lex
cc		NDL::begin_dispatch ( "/" );
cc		   NDL::begin_dispatch ( "*" );
cc		      NDL::call ( slash_star_comment );
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    "#" output operator goto pp beginning;
lex	    "##" output operator goto normal;
lex
cc		NDL::begin_dispatch ( "#" );
cc		   NDL::begin_dispatch ( "#" );
cc		      NDL::output ( operator_t );
cc		      NDL::go ( normal );
cc		   NDL::end_dispatch();
cc
cc		   NDL::output ( operator_t );
cc		   NDL::go ( pp_beginning );
cc		NDL::end_dispatch();
cc
lex	    "%:" translate to "#" output operator
lex	         goto pp beginning;
lex	    "%:%:" translate to "##" output operator
lex	           goto normal;
lex
cc		NDL::begin_dispatch ( "%" );
cc		   NDL::begin_dispatch ( ":" );
cc		      NDL::begin_dispatch ( "%" );
cc		         NDL::begin_dispatch ( ":" );
cc		            NDL::translate_to ( "##" );
cc		            NDL::output ( operator_t );
cc		            NDL::go ( normal );
cc		         NDL::end_dispatch();
cc		      NDL::end_dispatch();
cc
cc		      NDL::translate_to ( "#" );
cc	              NDL::output ( operator_t );
cc	              NDL::go ( pp_beginning );
cc
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    goto normal;
lex
cc		NDL::go ( normal );
cc
lex	end initial master table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin pp beginning master table;
lex
cc	    NDL::begin_table ( pp_beginning );
cc
lex	    "<whitespace-char>" call whitespace;
lex
cc		NDL::begin_dispatch ( whitespace_char );
cc		   NDL::call ( whitespace );
cc		NDL::end_dispatch();
cc
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur inside
lex	    // pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
lex
cc		NDL::begin_dispatch ( "/" );
cc		   NDL::begin_dispatch ( "*" );
cc		      NDL::call ( slash_star_comment );
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    // "include" identifier must be followed by
lex	    // one of the following for a header to be
lex	    // recognized:
lex	    //
lex	    //     <whitespace-char>
lex	    //     /* comment
lex	    //     <...> header
lex	    //     "..." header
lex	    //
lex	    "include<whitespace-char>"
lex	        keep 7 output identifier
lex	        goto pp include;
lex	    "include/"
lex	        keep 7 output identifier
lex	        goto pp include;
lex	    "include<"
lex	        keep 7 output identifier
lex	        goto pp include;
lex	    "include<Q>"
lex	        keep 7 output identifier
lex	        goto pp include;
lex
cc		NDL::begin_dispatch ( "i" );
cc		NDL::begin_dispatch ( "n" );
cc		NDL::begin_dispatch ( "c" );
cc		NDL::begin_dispatch ( "l" );
cc		NDL::begin_dispatch ( "u" );
cc		NDL::begin_dispatch ( "d" );
cc		NDL::begin_dispatch ( "e" );
cc		   NDL::begin_dispatch
cc			    ( " \t\v\f/<\"" );
cc		      NDL::keep ( 7 );
cc		      NDL::output ( identifier_t );
cc		      NDL::go ( pp_include );
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    goto normal;
lex
cc	    NDL::go ( normal );
cc
lex	end pp beginning master table;
lex
cc	    NDL::end_table();
cc
lex	begin pp include master table;
lex
cc	    NDL::begin_table ( pp_include );
cc
lex	    "<whitespace-char>" call whitespace;
lex
cc		NDL::begin_dispatch ( whitespace_char );
cc		   NDL::call ( whitespace );
cc		NDL::end_dispatch();
cc
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur inside
lex	    // pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
lex
cc		NDL::begin_dispatch ( "/" );
cc		   NDL::begin_dispatch ( "*" );
cc		      NDL::call ( slash_star_comment );
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    "<" translate to ""
lex	        goto bracketed header name;
lex
cc		NDL::begin_dispatch ( "<" );
cc		   NDL::translate_to ( "" );
cc		   NDL::go ( bracketed_header_name );
cc		NDL::end_dispatch();
cc
lex	    "<Q>" translate to ""
lex	        goto quoted header name;
lex
cc		NDL::begin_dispatch ( "\"" );
cc		   NDL::translate_to ( "" );
cc		   NDL::go ( quoted_header_name );
cc		NDL::end_dispatch();
cc
lex	    goto normal;
lex
cc	        NDL::go ( normal );
cc
lex	end pp include master table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin premature newline master table;
lex
cc	    NDL::begin_table ( premature_newline );
cc
lex	    output premature newline goto normal;
lex
cc		NDL::output ( premature_newline_t );
cc		NDL::go ( normal );
cc
lex	end premature newline master table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin premature end of file master table;
lex
cc	    NDL::begin_table ( premature_end_of_file );
cc
lex	    output premature end of file goto initial;
lex
cc	        NDL::output ( premature_end_of_file_t );
cc	        NDL::go ( initial );
cc
lex	end premature end of file master table;
lex
cc	    NDL::end_table();
cc
lex	begin whitespace lexeme table;
lex
cc	    NDL::begin_table ( whitespace );
cc
lex	    "<whitespace-char>" accept;
lex
cc		NDL::begin_dispatch ( whitespace_char );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    return;
lex
cc		NDL::ret();
cc
lex	end whitespace lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin "/*" comment lexeme table;
lex
cc	    NDL::begin_table ( slash_star_comment );
cc
lex	    "*/" return;
lex	    "*" accept;
lex
cc		NDL::begin_dispatch ( "*" );
cc		   NDL::begin_dispatch ( "/" );
cc		      NDL::ret();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "<other>" accept;
lex
cc		NDL::begin_dispatch ( OTHER );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    translate_to "*/"
lex	    goto premature end of file;
lex
cc		NDL::translate_to ( "*/" );
cc		NDL::go ( premature_end_of_file );
cc
lex	end "/*" comment lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin "//" comment lexeme table;
lex
cc	    NDL::begin_table ( slash_slash_comment );
cc
lex	    "<NL>" keep 0 return;
lex
cc		NDL::begin_dispatch ( "\n" );
cc		   NDL::keep ( 0 );
cc		   NDL::ret();
cc		NDL::end_dispatch();
cc
lex	    "<other>" accept;
lex
cc		NDL::begin_dispatch ( OTHER );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    goto premature end of file;
lex
cc		NDL::go ( premature_end_of_file );
cc
lex	end "//" comment lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin bracketed header name lexeme table;
lex
cc	    NDL::begin_table ( bracketed_header_name );
cc
lex	    ">" translate to "" goto normal;
lex
cc		NDL::begin_dispatch ( ">" );
cc		   NDL::translate_to ( "" );
cc		   NDL::go ( normal );
cc		NDL::end_dispatch();
cc
lex	    "<NL>"
lex	        keep 0 goto premature newline;
lex
cc		NDL::begin_dispatch ( "\n" );
cc		   NDL::keep ( 0 );
cc		   NDL::go ( premature_newline );
cc		NDL::end_dispatch();
cc
lex	    "<other>" accept;
lex
cc		NDL::begin_dispatch ( OTHER );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    goto premature end of file;
lex
cc		NDL::go ( premature_end_of_file );
cc
lex	end bracketed header name lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	// Quoted header names are not the same as
lex	// quoted strings, and cannot have escape
lex	// sequences.
lex	//
lex	begin quoted header name lexeme table;
lex
cc	    NDL::begin_table ( quoted_header_name );
cc
lex	    "<Q>" translate to "" goto normal;
lex
cc		NDL::begin_dispatch ( "\"" );
cc		   NDL::translate_to ( "" );
cc		   NDL::go ( normal );
cc		NDL::end_dispatch();
cc
lex	    "<NL>"
lex	        keep 0 goto premature newline;
lex
cc		NDL::begin_dispatch ( "\n" );
cc		   NDL::keep ( 0 );
cc		   NDL::go ( premature_newline );
cc		NDL::end_dispatch();
cc
lex	    "<other>" accept;
lex
cc		NDL::begin_dispatch ( OTHER );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    goto premature end of file;
lex
cc		NDL::go ( premature_end_of_file );
cc
lex	end quoted header name lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin normal master table;
lex
cc	    NDL::begin_table ( normal );
cc
lex	    "<whitespace-char>" call whitespace;
lex
cc		NDL::begin_dispatch ( whitespace_char );
cc		   NDL::call ( whitespace );
cc		NDL::end_dispatch();
cc
lex	    "/*" call "/*" comment;
lex	    "//" call "//" comment;
lex	    "/" match operator output operator
lex	        // match should always succeed
lex
cc		NDL::begin_dispatch ( "/" );
cc		   NDL::begin_dispatch ( "*" );
cc		      NDL::call ( slash_star_comment );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch ( "/" );
cc		      NDL::call ( slash_slash_comment );
cc		   NDL::end_dispatch();
cc
cc		   NDL::match ( operator_atom );
cc		   NDL::output ( operator_t );
cc		NDL::end_dispatch();
cc
lex	    "<op-char>"
lex	        match operator output operator
lex	        // match should always succeed
lex
cc		NDL::begin_dispatch ( op_char );
cc		   NDL::match ( operator_atom );
cc		   NDL::output ( operator_t );
cc		NDL::end_dispatch();
cc
lex	    "<identifier-non-literal>"
lex	        call identifier;
lex	        // Also see "u/U/L..." etc. below.
lex
cc		NDL::begin_dispatch ( "_" );
cc		   NDL::add_category ( "L" );
cc		   NDL::sub_chars ( "uUL" );
cc		   NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex	    "u'" translate to ""
lex	         output u char literal
lex	         call char literal;
lex	    "u<Q>" translate to ""
lex	           output u string literal
lex	           call string literal;
lex	    "u"  call identifier;
lex
cc		NDL::begin_dispatch ( "u" );
cc		   NDL::begin_dispatch ( "'" );
cc		      NDL::translate_to ( "" );
cc		      NDL::output ( u_char_literal_t );
cc		      NDL::call ( char_literal );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( "\"" );
cc		      NDL::translate_to ( "" );
cc		      NDL::output
cc			    ( u_string_literal_t );
cc		      NDL::call ( string_literal );
cc		   NDL::end_dispatch();
cc
cc		   NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex	    "U'" translate to ""
lex	         output U char literal
lex	         call char literal;
lex	    "U<Q>" translate to ""
lex	           output U string literal
lex	           call string literal;
lex	    "U"  call identifier;
lex
cc		NDL::begin_dispatch ( "U" );
cc		   NDL::begin_dispatch ( "'" );
cc		      NDL::translate_to ( "" );
cc		      NDL::output ( U_char_literal_t );
cc		      NDL::call ( char_literal );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( "\"" );
cc		      NDL::translate_to ( "" );
cc		      NDL::output
cc			    ( U_string_literal_t );
cc		      NDL::call ( string_literal );
cc		   NDL::end_dispatch();
cc
cc		   NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex	    "L'" translate to ""
lex	         output L char literal
lex	         call char literal;
lex	    "L<Q>" translate to ""
lex	           output L string literal
lex	           call string literal;
lex	    "L"  call identifier;
lex
cc		NDL::begin_dispatch ( "L" );
cc		   NDL::begin_dispatch ( "'" );
cc		      NDL::translate_to ( "" );
cc		      NDL::output ( L_char_literal_t );
cc		      NDL::call ( char_literal );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( "\"" );
cc		      NDL::translate_to ( "" );
cc		      NDL::output
cc			    ( L_string_literal_t );
cc		      NDL::call ( string_literal );
cc		   NDL::end_dispatch();
cc
cc		   NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex	    "\<u_U>" match universal char
lex	             require <non-ascii-letter>
lex	             call identifier
lex	        else match universal char
lex	             require "<ascii-char>"
lex	             output ascii universal char
lex	        else match universal char
lex	             output misplaced universal char
lex	        else match short universal char
lex	             output universal char
lex	             // Match should always succeed.
lex	    "\" output misplaced char
lex
cc	        NDL::begin_dispatch ( "\\" );
cc	           NDL::begin_dispatch ( u_U );
cc	              NDL::match ( universal_char );
cc		      NDL::require ( non_ascii_letter );
cc		      NDL::call ( identifier );
cc		   NDL::ELSE();
cc		      NDL::match ( universal_char );
cc		      NDL::require ( ascii_char );
cc		      NDL::output
cc			    ( ascii_universal_char_t );
cc		   NDL::ELSE();
cc		      NDL::match ( universal_char );
cc		      NDL::output
cc			 ( misplaced_universal_char_t );
cc		   NDL::ELSE();
cc		      NDL::match
cc			    ( short_universal_char );
cc		      NDL::output
cc			    ( short_universal_char_t );
cc		   NDL::end_dispatch();
cc
cc		   NDL::output ( misplaced_char_t );
cc		NDL::end_dispatch();
cc
lex	    "<non-zero-digit>" call decimal integer;
lex
cc		NDL::begin_dispatch ( non_zero_digit );
cc		   NDL::call ( decimal_integer );
cc		NDL::end_dispatch();
cc
lex	    "0x" call hexadecimal integer;
lex	    "0X" call hexadecimal integer;
lex	    "0" call octal integer;
lex
cc		NDL::begin_dispatch ( "0" );
cc		   NDL::begin_dispatch ( "xX" );
cc		      NDL::call ( hexadecimal_integer );
cc		   NDL::end_dispatch();
cc
cc		   NDL::call ( octal_integer );
cc		NDL::end_dispatch();
cc
lex	    ".<digit>" call fraction;
lex	    "." match operator output operator
lex	        // match should always succeed
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::begin_dispatch ( digit );
cc		      NDL::call ( fraction );
cc		   NDL::end_dispatch();
cc
cc		   NDL::match ( operator_atom );
cc		   NDL::output ( operator_t );
cc		NDL::end_dispatch();
cc
lex	    "'" translate to ""
lex	        output char literal
lex	        call char literal;
lex
cc		NDL::begin_dispatch ( "'" );
cc		   NDL::translate_to ( "" );
cc		   NDL::output ( char_literal_t );
cc		   NDL::call ( char_literal );
cc		NDL::end_dispatch();
cc
lex	    "<Q>" translate to ""
lex	          output string literal
lex	          call string literal;
lex
cc		NDL::begin_dispatch ( "\"" );
cc		   NDL::translate_to ( "" );
cc		   NDL::output ( string_literal_t );
cc		   NDL::call ( string_literal );
cc		NDL::end_dispatch();
cc
lex	    "<NL>" output newline goto initial;
lex
cc		NDL::begin_dispatch ( "\n" );
cc		   NDL::output ( newline_t );
cc		   NDL::go ( initial );
cc		NDL::end_dispatch();
cc
lex	    "<other>" output misplaced char;
lex
cc		NDL::begin_dispatch ( OTHER );
cc		   NDL::output ( misplaced_char_t );
cc		NDL::end_dispatch();
cc
lex	    output end of file;
lex
cc		NDL::output ( end_of_file_t );
cc
lex	end normal master table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin operator atom table;
lex
cc	    NDL::begin_table ( operator_atom );
cc
lex	    "("; ")"; "["; "]"; "{"; "}"; ";"; ","; "?";
lex	    "~";
lex
cc		NDL::begin_dispatch ( "()[]{};,?~" );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "#";
lex	    "##";
lex
cc		NDL::begin_dispatch ( "#" );
cc		   NDL::begin_dispatch ( "#" );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "<:" translate to "[";
lex	    "<%"; translate to "{";
lex	    "<<="; "<<"; "<";
lex
cc		NDL::begin_dispatch ( "<" );
cc		   NDL::begin_dispatch ( ":" );
cc		      NDL::translate_to ( "[" );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( "%" );
cc		      NDL::translate_to ( "{" );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( "<" );
cc		      NDL::begin_dispatch ( "=" );
cc		         NDL::accept();
cc		      NDL::end_dispatch();
cc
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    ">>="; ">>"; ">";
lex
cc		NDL::begin_dispatch ( ">" );
cc		   NDL::begin_dispatch ( ">" );
cc		      NDL::begin_dispatch ( "=" );
cc		         NDL::accept();
cc		      NDL::end_dispatch();
cc
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    ":>" translate to "]";
lex	    "::"; ":";
lex
cc		NDL::begin_dispatch ( ":" );
cc		   NDL::begin_dispatch ( ">" );
cc		      NDL::translate_to ( "]" );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( ":" );
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "%>" translate to "}";
lex	    "%:%:" translate to "##";
lex	    "%:" translate to "#";
lex	    "%="; "%";
lex
cc		NDL::begin_dispatch ( "%" );
cc		   NDL::begin_dispatch ( ">" );
cc		      NDL::translate_to ( "}" );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( ":" );
cc		      NDL::begin_dispatch ( "%" );
cc		         NDL::begin_dispatch ( ":" );
cc		            NDL::translate_to ( "##" );
cc		         NDL::end_dispatch();
cc		      NDL::end_dispatch();
cc
cc		      NDL::translate_to ( "#" );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( "=" );
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "..."; ".*"; ".";
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::begin_dispatch ( "." );
cc		      NDL::begin_dispatch ( "." );
cc		         NDL::accept();
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( "*" );
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "++"; "+="; "+";
lex
cc		NDL::begin_dispatch ( "+" );
cc		   NDL::begin_dispatch ( "+=" );
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "->*"; "->"; "--"; "-="; "-";
lex
cc		NDL::begin_dispatch ( "-" );
cc		   NDL::begin_dispatch ( ">" );
cc		      NDL::begin_dispatch ( "*" );
cc		         NDL::accept();
cc		      NDL::end_dispatch();
cc
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( "=-" );
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "*="; "*";
lex	    "/="; "/";
lex	    "^="; "^";
lex	    "!="; "!";
lex	    "=="; "=";
lex
cc		NDL::begin_dispatch ( "*/^!=" );
cc		   NDL::begin_dispatch ( "=" );
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "&&"; "&="; "&";
lex
cc		NDL::begin_dispatch ( "&" );
cc		   NDL::begin_dispatch ( "&=" );
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "||"; "|="; "|";
lex
cc		NDL::begin_dispatch ( "|" );
cc		   NDL::begin_dispatch ( "|=" );
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    fail;
lex
cc		NDL::fail();
cc
lex	end operator atom table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin identifier lexeme table;
lex
cc	    NDL::begin_table ( identifier );
cc
lex	    "<identifier-non-digit>" accept;
lex	    "<digit>" accept;
lex
cc		NDL::begin_dispatch ( "_" );
cc		   NDL::add_category ( "L" );
cc	    	   NDL::add_chars ( digit );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "\<u_U>" match universal char
lex	             require "<non-ascii-letter>"
lex	        else keep 0 return
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::begin_dispatch ( u_U );
cc		      NDL::match ( universal_char );
cc		      NDL::require
cc			  ( non_ascii_letter );
cc		   NDL::ELSE();
cc		      NDL::keep ( 0 );
cc		      NDL::ret();
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    return;
lex
cc		NDL::ret();
cc
lex	end identifier lexeme table;
lex
cc	    NDL::end_table();
cc
lex	"<e_E> = "e" | "E";
lex	"<identifier-non-digit-except-eE>" =
lex	    "<identifier-non-digit>" & ~ "<e_E>";
lex
lex
lex	begin decimal integer lexeme table;
lex
cc	    NDL::begin_table ( decimal_integer );
cc
lex	    "<digit>" accept;
lex
cc		NDL::begin_dispatch ( digit );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "." goto fraction;
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::go ( fraction );
cc		NDL::end_dispatch();
cc
lex	    "<e_E><sign><digit>" goto exponent;
lex	    "<e_E><sign>" goto pp number;
lex	    "<e_E><digit>" goto exponent;
lex	    "<identifier-non-digit>" goto suffix;
lex
cc		NDL::begin_dispatch ( "eE" );
cc		   NDL::begin_dispatch ( sign );
cc		      NDL::begin_dispatch ( digit );
cc		         NDL::go ( exponent );
cc		      NDL::end_dispatch();
cc
cc		      NDL::go ( pp_number );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( digit );
cc		      NDL::go ( exponent );
cc		   NDL::end_dispatch();
cc
cc		   NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( "_" );
cc		   NDL::add_category ( "L" );
cc		   NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
lex	    "\"      match universal char
lex	             require "<non-ascii-letter>"
lex	             goto suffix
lex	        else keep 0 return
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::match ( universal_char );
cc		   NDL::require ( non_ascii_letter );
cc		   NDL::go ( suffix );
cc		NDL::ELSE();
cc		   NDL::keep ( 0 );
cc		   NDL::ret();
cc		NDL::end_dispatch();
cc
lex	    return;
lex
cc	        NDL::ret();
cc
lex	end decimal integer lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin octal integer lexeme table;
lex
cc	    NDL::begin_table ( octal_integer );
cc
lex	    "<oct-digit>" accept;
lex
cc		NDL::begin_dispatch ( oct_digit );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "8" goto float integer;
lex	    "9" goto float integer;
lex
cc		NDL::begin_dispatch ( "89" );
cc		   NDL::go ( float_integer );
cc		NDL::end_dispatch();
cc
lex	    "." goto fraction;
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::go ( fraction );
cc		NDL::end_dispatch();
cc
lex	    "<e_E><sign><digit>" goto exponent;
lex	    "<e_E><sign>" goto pp number;
lex	    "<e_E><digit>" goto exponent;
lex	    "<identifier-non-digit>" goto suffix;
lex
cc		NDL::begin_dispatch ( "eE" );
cc		   NDL::begin_dispatch ( sign );
cc		      NDL::begin_dispatch ( digit );
cc		         NDL::go ( exponent );
cc		      NDL::end_dispatch();
cc
cc		      NDL::go ( pp_number );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( digit );
cc		      NDL::go ( exponent );
cc		   NDL::end_dispatch();
cc
cc		   NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( "_" );
cc		   NDL::add_category ( "L" );
cc		   NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
lex	    "\"      match universal char
lex	             require "<non-ascii-letter>"
lex	             goto suffix
lex	        else keep 0 return
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::match ( universal_char );
cc		   NDL::require ( non_ascii_letter );
cc		   NDL::go ( suffix );
cc		NDL::ELSE();
cc		   NDL::keep ( 0 );
cc		   NDL::ret();
cc		NDL::end_dispatch();
cc
lex	    return;
lex
cc	        NDL::ret();
cc
lex	end octal integer lexeme table;
lex
cc	    NDL::end_table();
cc
lex	"<identifier-non-hex-digit>" =
lex	    "<identifier-non-digit>" & ~ "<hex-digit>";
lex
lex
lex	begin hexadecimal integer lexeme table;
lex
cc	    NDL::begin_table ( hexadecimal_integer );
cc
lex	    "<hex-digit>" accept;
lex
cc		NDL::begin_dispatch ( hex_digit );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "<identifier-non-hex-digit>" goto suffix;
lex
cc		NDL::begin_dispatch ( "_" );
cc		   NDL::add_category ( "L" );
cc		   NDL::sub_chars ( hex_digit );
cc		   NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
lex	    "\"      match universal char
lex	             require "<non-ascii-letter>"
lex	             goto suffix
lex	        else keep 0 return
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::match ( universal_char );
cc		   NDL::require ( non_ascii_letter );
cc		   NDL::go ( suffix );
cc		NDL::ELSE();
cc		    NDL::keep ( 0 );
cc		    NDL::ret();
cc		NDL::end_dispatch();
cc
lex	    return;
lex
cc	        NDL::ret();
cc
lex	end hexadecimal integer lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex     // Same as decimal integer lexeme table but
lex	// integer began with 0 and then included a
lex	// non-octal digit.
lex	//
lex	begin float integer lexeme table;
lex
cc	    NDL::begin_table ( float_integer );
cc
lex	    "<digit>" accept;
lex
cc		NDL::begin_dispatch ( digit );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "." goto fraction;
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::go ( fraction );
cc		NDL::end_dispatch();
cc
lex	    "<e_E><sign><digit>" goto exponent;
lex	    "<e_E><sign>" goto pp number;
lex	    "<e_E><digit>" goto exponent;
lex	    "<identifier-non-digit>" goto pp number;
lex
cc		NDL::begin_dispatch ( "eE" );
cc		   NDL::begin_dispatch ( sign );
cc		      NDL::begin_dispatch ( digit );
cc		         NDL::go ( exponent );
cc		      NDL::end_dispatch();
cc
cc		      NDL::go ( pp_number );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( digit );
cc		      NDL::go ( exponent );
cc		   NDL::end_dispatch();
cc
cc		   NDL::go ( pp_number );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( "_" );
cc		   NDL::add_category ( "L" );
cc		   NDL::go ( pp_number );
cc		NDL::end_dispatch();
cc
lex	    "\"      match universal char
lex	             require "<non-ascii-letter>"
lex	             goto pp_number
lex	        else keep 0 goto pp number
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::match ( universal_char );
cc		   NDL::require ( non_ascii_letter );
cc		   NDL::go ( pp_number );
cc		NDL::ELSE();
cc		   NDL::keep ( 0 );
cc		   NDL::go ( pp_number );
cc		NDL::end_dispatch();
cc
lex	    goto pp number;
lex
cc	        NDL::go ( pp_number );
cc
lex	end float integer lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	// Come here to process suffix at end of integer
lex	// or float lexeme.  Similar to identifier but
lex	// changes lexeme type to pp number when certain
lex	// character sequences are encountered.
lex	//
lex	begin suffix sublexeme table;
lex
cc	    NDL::begin_table ( suffix );
cc
lex	    "<identifier-non-digit-except-eE>" accept;
lex	    "<digit>" accept;
lex
cc		NDL::begin_dispatch ( "_" );
cc		   NDL::add_category ( "L" );
cc		   NDL::sub_chars ( "eE" );
cc	    	   NDL::add_chars ( digit );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "<e_E><sign>" goto pp number;
lex	    "<e_E>" accept;
lex
cc		NDL::begin_dispatch ( "eE" );
cc		   NDL::begin_dispatch ( sign );
cc		      NDL::go ( pp_number );
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "." goto pp number;
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::go ( pp_number );
cc		NDL::end_dispatch();
cc
lex	    "\<u_U>" match universal char
lex	             require
lex	                 "<non-ascii-identifier-char>"
lex	             else keep 0 return;
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::begin_dispatch ( u_U );
cc		      NDL::match ( universal_char );
cc		      NDL::require
cc		          ( non_ascii_identifier_char );
cc	 	   NDL::ELSE();
cc		      NDL::keep ( 0 );
cc		      NDL::ret();
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    return;
lex
cc		NDL::ret();
cc
lex	end suffix sublexeme table;
lex
cc	    NDL::end_table();
cc
lex	begin pp number lexeme table;
lex
cc	    NDL::begin_table ( pp_number );
cc
lex	    "<identifier-non-digit-except-eE>" accept;
lex	    "<digit>" accept;
lex
cc		NDL::begin_dispatch ( "_" );
cc		   NDL::add_category ( "L" );
cc	    	   NDL::add_chars ( digit );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "<e_E><sign>" accept;
lex	    "<e_E>" accept;
lex
cc		NDL::begin_dispatch ( "eE" );
cc		   NDL::begin_dispatch ( sign );
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "." accept;
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "\<u_U>" match universal char
lex	             require
lex	                 "<non-ascii-identifier-char>"
lex	             else keep 0 return;
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::begin_dispatch ( u_U );
cc		      NDL::match ( universal_char );
cc		      NDL::require
cc		          ( non_ascii_identifier_char );
cc	 	   NDL::ELSE();
cc		      NDL::keep ( 0 );
cc		      NDL::ret();
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    return;
lex
cc		NDL::ret();
cc
lex	end pp number lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin fraction lexeme table;
lex
cc	    NDL::begin_table ( fraction );
cc
lex	    "<digit>" accept;
lex
cc		NDL::begin_dispatch ( digit );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "." goto pp number;
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::go ( pp_number );
cc		NDL::end_dispatch();
cc
lex	    "<e_E><sign><digit>" goto exponent;
lex	    "<e_E><digit>" goto exponent;
lex	    "<e_E><sign>" goto pp number;
lex	    "<identifier-non-digit>" goto suffix;
lex
cc		NDL::begin_dispatch ( "eE" );
cc		   NDL::begin_dispatch ( sign );
cc		      NDL::begin_dispatch ( digit );
cc		         NDL::go ( exponent );
cc		      NDL::end_dispatch();
cc
cc		      NDL::go ( pp_number );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( digit );
cc		      NDL::go ( exponent );
cc		   NDL::end_dispatch();
cc
cc		   NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( "_" );
cc		    NDL::add_category ( "L" );
cc		    NDL::sub_chars ( "eE" );
cc		    NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
lex	    "\<u_U>" match universal char
lex	             require "<non-ascii-letter>"
lex	             goto suffix
lex	             else keep 0 return;
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::begin_dispatch ( u_U );
cc		      NDL::match ( universal_char );
cc		      NDL::require ( non_ascii_letter );
cc		      NDL::go ( suffix );
cc		   NDL::ELSE();
cc		      NDL::keep ( 0 );
cc		      NDL::ret();
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    return;
lex
cc		NDL::ret();
cc
lex	end fraction lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin exponent lexeme table;
lex
cc	    NDL::begin_table ( exponent );
cc
lex	    "<digit>" accept;
lex
cc		NDL::begin_dispatch ( digit );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "." goto pp number;
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::go ( pp_number );
cc		NDL::end_dispatch();
cc
lex	    "<e_E><sign>" goto pp number;
lex	    "<identifier-non-digit>" goto suffix;
lex
cc		NDL::begin_dispatch ( "eE" );
cc		   NDL::begin_dispatch ( sign );
cc		      NDL::go ( pp_number );
cc		   NDL::end_dispatch();
cc
cc		   NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( "_" );
cc		    NDL::add_category ( "L" );
cc		    NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
lex	    "\<u_U>" match universal char
lex	             require "<non-ascii-letter>"
lex	             goto suffix
lex	             else keep 0 return;
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::begin_dispatch ( u_U );
cc		      NDL::match ( universal_char );
cc		      NDL::require ( non_ascii_letter );
cc		      NDL::go ( suffix );
cc		   NDL::ELSE();
cc		      NDL::keep ( 0 );
cc		      NDL::ret();
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    return;
lex
cc		NDL::ret();
cc
lex	end exponent lexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin char literal sublexeme table;
lex
cc	    NDL::begin_table ( char_literal );
cc
lex	    "'" translate to "" return;
lex
cc		NDL::begin_dispatch ( "'" );
cc		   NDL::translate_to ( "" );
cc		   NDL::ret();
cc		NDL::end_dispatch();
cc
lex	    "<NL>" keep 0 goto premature newline
lex
cc		NDL::begin_dispatch ( "\n" );
cc		   NDL::keep ( 0 );
cc		   NDL::go ( premature_newline );
cc		NDL::end_dispatch();
cc
lex	    "\" match escaped char
lex	        // match should always succeed
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::match ( escaped_char );
cc		NDL::end_dispatch();
cc
lex	    "<other>" accept
lex
cc		NDL::begin_dispatch ( OTHER );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    goto premature end of file
lex
cc	        NDL::go ( premature_end_of_file );
cc
lex	end char literal sublexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	begin string literal sublexeme table;
lex
cc	    NDL::begin_table ( string_literal );
cc
lex	    "<Q>" translate to "" return;
lex
cc		NDL::begin_dispatch ( "\"" );
cc		   NDL::translate_to ( "" );
cc		   NDL::ret();
cc		NDL::end_dispatch();
cc
lex	    "<NL>" keep 0 goto premature newline
lex
cc		NDL::begin_dispatch ( "\n" );
cc		   NDL::keep ( 0 );
cc		   NDL::go ( premature_newline );
cc		NDL::end_dispatch();
cc
lex	    "\" match escaped char
lex	        // match should always succeed
lex
cc		NDL::begin_dispatch ( "\\" );
cc		   NDL::match ( escaped_char );
cc		NDL::end_dispatch();
cc
lex	    "<other>" accept
lex
cc		NDL::begin_dispatch ( OTHER );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    goto premature end of file
lex
cc	        NDL::go ( premature_end_of_file );
cc
lex	end string literal sublexeme table;
lex
cc	    NDL::end_table();
cc
lex
lex	// This atom table is used when the next atom
lex	// begins with \ and is in a character or string
lex	// literal.  This atom table always succeeds,
lex	// but may produce an erroneous atom with ""
lex	// translation.
lex	//
lex	// We allow only a maximum of 8 hexadecimal
lex	// digits after \x; 9 digits is an error.  The
lex	// C++ standard permits any number of hexa-
lex	// decimal digits.
lex	//
lex	begin escaped char atom table;
lex
cc	    NDL::begin_table ( escaped_char );
cc
cc	    // All table entries begin with \.
cc	    NDL::begin_dispatch ( "\\" );
cc
lex	    "\n" translate to "<NL>";
lex
cc	        NDL::begin_dispatch ( "n" );
cc		   NDL::translate_to ( "\n" );
cc		NDL::end_dispatch();
cc
lex	    "\t" translate to "<HT>";
lex
cc	        NDL::begin_dispatch ( "t" );
cc		   NDL::translate_to ( "\t" );
cc		NDL::end_dispatch();
cc
lex	    "\v" translate to "<VT>";
lex
cc	        NDL::begin_dispatch ( "v" );
cc		   NDL::translate_to ( "\v" );
cc		NDL::end_dispatch();
cc
lex	    "\b" translate to "<BS>";
lex
cc	        NDL::begin_dispatch ( "b" );
cc		   NDL::translate_to ( "\b" );
cc		NDL::end_dispatch();
cc
lex	    "\r" translate to "<CR>";
lex
cc	        NDL::begin_dispatch ( "r" );
cc		   NDL::translate_to ( "\r" );
cc		NDL::end_dispatch();
cc
lex	    "\f" translate to "<FF>";
lex
cc	        NDL::begin_dispatch ( "f" );
cc		   NDL::translate_to ( "\f" );
cc		NDL::end_dispatch();
cc
lex	    "\a" translate to "<BEL>";
lex
cc	        NDL::begin_dispatch ( "a" );
cc		   NDL::translate_to ( "\a" );
cc		NDL::end_dispatch();
cc
lex	    "\\" translate to "\";
lex
cc	        NDL::begin_dispatch ( "\\" );
cc		   NDL::translate_to ( "\\" );
cc		NDL::end_dispatch();
cc
lex	    "\?" translate to "?";
lex
cc	        NDL::begin_dispatch ( "?" );
cc		   NDL::translate_to ( "?" );
cc		NDL::end_dispatch();
cc
lex	    "\<Q>" translate to "<Q>";
lex
cc	        NDL::begin_dispatch ( "\"" );
cc		   NDL::translate_to ( "\"" );
cc		NDL::end_dispatch();
cc
lex	    "\'" translate to "'";
lex
cc	        NDL::begin_dispatch ( "'" );
cc		   NDL::translate_to ( "'" );
cc		NDL::end_dispatch();
cc
lex	    "\<oct-digit><oct-digit><oct-digit>"
lex	        translate oct 1 0;
lex	    "\<oct-digit><oct-digit>"
lex	        translate oct 1 0;
lex	    "\<oct-digit>"
lex	        translate oct 1 0;
lex
cc	        NDL::begin_dispatch ( oct_digit );
cc	           NDL::begin_dispatch ( oct_digit );
cc	              NDL::begin_dispatch ( oct_digit );
cc		         NDL::translate_oct ( 1, 0 );
cc		      NDL::end_dispatch();
cc
cc		      NDL::translate_oct ( 1, 0 );
cc		   NDL::end_dispatch();
cc
cc		   NDL::translate_oct ( 1, 0 );
cc		NDL::end_dispatch();
cc
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        error too long hex escape
lex	        translate to "";
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x" error ill formed escape
lex	        translate to "";
lex
cc
cc	#	define HEX NDL::begin_dispatch \
cc		                   ( hex_digit )
cc	#	define END NDL::translate_hex \
cc			           ( 2, 0 ); \
cc	                   NDL::end_dispatch()
cc
cc		NDL::begin_dispatch ( "x" );
cc		   HEX;HEX;HEX;HEX;HEX;HEX;HEX;HEX;
cc		      NDL::begin_dispatch ( hex_digit );
cc			 NDL::erroneous_atom
cc			      ( too_long_hex_escape_t );
cc			 NDL::translate_to ( "" );
cc		      NDL::end_dispatch();
cc		   END;END;END;END;END;END;END;END;
cc
cc		   NDL::erroneous_atom
cc			( ill_formed_escape_t );
cc		   NDL::translate_to ( "" );
cc		NDL::end_dispatch();
cc
cc	#	undef HEX
cc	#	undef END
cc
lex	    "\<u_U>" match universal char
lex	        else match short universal char
lex	             error short universal char
lex	             translate to "";
lex	             // This should always succeed
lex
cc	    NDL::begin_dispatch ( u_U );
cc	       NDL::match ( universal_char );
cc	    NDL::ELSE();
cc	       NDL::match ( short_universal_char );
cc	       NDL::erroneous_atom
cc		    ( short_universal_char_t );
cc	       NDL::translate_to ( "" );
cc	    NDL::end_dispatch();
cc
lex	"\<NL>" keep 1
lex	        error ill formed escape
lex	        translate to "";
lex
cc	        NDL::begin_dispatch ( "\n" );
cc	           NDL::keep ( 1 );
cc	           NDL::erroneous_atom
cc		        ( ill_formed_escape_t );
cc		   NDL::translate_to ( "" );
cc	        NDL::end_dispatch();
cc
lex	"\<other>" error ill formed escape
lex	           translate to "";
lex
cc	        NDL::begin_dispatch ( OTHER );
cc	           NDL::erroneous_atom
cc		        ( ill_formed_escape_t );
cc		   NDL::translate_to ( "" );
cc	        NDL::end_dispatch();
cc
cc
lex	"\" error ill formed escape
lex	    translate to "";
lex	    // In case \ followed by end of file
lex
cc	        NDL::erroneous_atom
cc		    ( ill_formed_escape_t );
cc		NDL::translate_to ( "" );
cc
lex	// This table should always succeed.
lex
lex	end escaped char atom table;
lex
cc	    // End of \ dispatch
cc	    //
cc	    NDL::end_dispatch();
cc
cc	    NDL::end_table();
cc
lex
lex	// This atom table is called when the next
lex	// atom begins with \U or \u.  If the atom
lex	// has the correct number of hexadecimal
lex	// digits after the \U or \u, it is recognized
lex	// and translated.
lex	//
lex	begin universal char atom table;
lex
cc	    NDL::begin_table ( universal_char );
cc
cc	    // All table entries begin with \.
cc	    NDL::begin_dispatch ( "\\" );
cc
cc	#	define HEX NDL::begin_dispatch \
cc		                   ( hex_digit )
cc	#	define END    NDL::end_dispatch()
cc
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex
cc		NDL::begin_dispatch ( "U" );
cc		   HEX;HEX;HEX;HEX;HEX;HEX;HEX;HEX;
cc		      NDL::translate_hex ( 2, 0 );
cc		   END;END;END;END;END;END;END;END;
cc		NDL::end_dispatch();
cc
lex	    "\u<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex
cc		NDL::begin_dispatch ( "u" );
cc		   HEX;HEX;HEX;HEX;
cc		      NDL::translate_hex ( 2, 0 );
cc		   END;END;END;END;
cc		NDL::end_dispatch();
cc
cc	#	undef HEX
cc	#	undef END
cc
cc	    // End \ dispatch.
cc	    NDL::end_dispatch();
cc
lex	    fail;
lex
cc	        NDL::fail();
cc
lex	end universal char atom table;
lex
cc	    NDL::end_table();
cc
lex
lex	// This atom table is called when the next
lex	// atom begins with \U or \u but there are too
lex	// few hexadecimal digits following.  An atom
lex	// is always recognized but is NOT translated.
lex	//
lex	begin short universal char atom table;
lex
cc	    NDL::begin_table ( short_universal_char );
cc
cc	    // All table entries begin with \.
cc	    NDL::begin_dispatch ( "\\" );
cc
cc	#	define HEX NDL::begin_dispatch \
cc		                   ( hex_digit )
cc	#	define END    NDL::accept(); \
cc			      NDL::end_dispatch()
cc
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>";
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>";
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>";
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>";
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit>";
lex	    "\U<hex-digit><hex-digit>";
lex	    "\U<hex-digit>";
lex	    "\U";
lex
cc		NDL::begin_dispatch ( "U" );
cc		    HEX;HEX;HEX;HEX;HEX;HEX;HEX;
cc		    END;END;END;END;END;END;END;
cc
cc		NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "\u<hex-digit><hex-digit>"
lex	      "<hex-digit>";
lex	    "\u<hex-digit><hex-digit>";
lex	    "\u<hex-digit>";
lex	    "\u";
lex
cc		NDL::begin_dispatch ( "u" );
cc		    HEX;HEX;HEX;
cc		    END;END;END;
cc
cc		NDL::accept();
cc		NDL::end_dispatch();
cc
cc	#	undef HEX
cc	#	undef END
cc
cc	    // End \ dispatch.
cc	    NDL::end_dispatch();
cc
lex	    // The above should always succeed.
lex
lex	end short universal char atom table;
lex
cc	    NDL::end_table();
cc
lex
lex	end c++ lexical program;
lex
cc	    NDL::end_program();
cc
cc	    LEXCPP::default_program =
cc		LEX::default_program;
cc	}
