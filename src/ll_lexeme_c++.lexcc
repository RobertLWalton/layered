// Layers Language C++ Lexical Analyzer
//
// File:	ll_lexeme_c++.lexcc
// Author:	Bob Walton (walton@acm.org)
// Date:	Sun May 29 19:19:48 EDT 2011
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.

// Lines beginning with `lex<HT>' and lines equal to
// `lex' are copied to ll_lexeme_c++.lex and then
// to the C++ Lexical Program appendix of ../doc/
// layered-introduction.tex.
//
// Lines beginning with `cc<HT>' and lines equal to `cc'
// are copied to ll_lexeme_c++.cc and compiled to
// produce code that can create a C++ lexical
// program.

// Table of Contents
//
//	Usage and Setup
//	Program Construction

// Usage and Setup
// ----- --- -----

cc	// This file was automatically generated from
cc	// ll_lexeme_c++.lexcc.
cc
lex	// This file was automatically generated from
lex	// ll_lexeme_c++.lexcc.
lex
cc	# include <ll_lexeme_ndl.h>
cc	# include <ll_lexeme_c++.h>
cc	using namespace ll::lexeme::ndl;
cc	# define LEX ll::lexeme
cc	# define LEXCPP ll::lexeme::cpp
cc	using namespace LEXCPP;
cc

// Program Construction
// ------- ------------

cc	min::locatable_var<LEX::program>
cc	    LEXCPP::default_program;
cc
cc	const char * const
cc		LEXCPP::type_name[MAX_TYPE+1] = {
cc
cc	    NULL,
cc	    "HORIZONTAL_SPACE",
cc	    "COMMENT",
cc	    "BRACKETED_HEADER_NAME",
cc	    "QUOTED_HEADER_NAME",
cc	    "OPERATOR",
cc	    "IDENTIFIER",
cc	    "INTEGER",
cc	    "FLOAT",
cc	    "NUMBER",
cc	    "CHARACTER_LITERAL",
cc	    "WIDE_CHARACTER_LITERAL",
cc	    "STRING_LITERAL",
cc	    "WIDE_STRING_LITERAL",
cc	    "NEW_LINE",
cc	    "END_OF_FILE",
cc	    "PREMATURE_NEW_LINE",
cc	    "PREMATURE_END_OF_FILE",
cc	    "ILLEGAL_CHARACTER",
cc	    "ILLEGAL_UNIVERSAL_CHARACTER",
cc	    "ILLEGAL_VERTICAL_SPACE" };
cc
cc	const char * LEXCPP::type_code =
cc	    "Xh/BQoIifncCsSleLFUNV";
cc
cc	static struct char_range { uns32 min, max; }
cc	    non_ascii_letters[] =
cc	{
cc		// { min,		max },
cc	#include <ll_lexeme_non_ascii_letters.h>
cc		   { 0,                0 }
cc	};
cc
cc	static void add_non_ascii_letters ( void )
cc	{
cc	    for ( char_range *p = non_ascii_letters;
cc		  p->min || p->max != 0; ++ p )
cc		NDL::add_characters ( p->min, p->max );
cc	}
cc
cc	void LEXCPP::init_cpp_program ( void )
cc	{
cc	    if ( LEXCPP::default_program != NULL_STUB )
cc	        return;
cc

lex	begin standard lexical program;
lex
cc	    begin_program ( type_name, MAX_TYPE );
cc
cc	    uns32 xtype = MAX_TYPE + 1;
cc	    uns32 slash_slash_comment_t = xtype ++;
cc	    uns32 slash_star_comment_t = xtype ++;
cc	    uns32 done_integer_t = xtype ++;
cc	    uns32 fraction_t = xtype ++;
cc	    uns32 exponent_t = xtype ++;
cc
cc	    uns32 horizontal_space;
cc	    NDL::new_table
cc		( horizontal_space,
cc		  horizontal_space_t );
cc	    uns32 new_line;
cc	    NDL::new_table
cc		( new_line, new_line_t );
cc	    uns32 new_line_finish;
cc	    NDL::new_table
cc		( new_line_finish, new_line_t );
cc
cc	    uns32 slash_star_comment;
cc	    NDL::new_table ( slash_star_comment,
cc	                     slash_star_comment_t );
cc	    uns32 slash_slash_comment;
cc	    NDL::new_table ( slash_slash_comment,
cc	                     slash_slash_comment_t );
cc
cc	    uns32 bracketed_header_name;
cc	    NDL::new_table ( bracketed_header_name,
cc	                     bracketed_header_name_t );
cc	    uns32 quoted_header_name;
cc	    NDL::new_table ( quoted_header_name,
cc	                     quoted_header_name_t );
cc
cc	    uns32 identifier;
cc	    NDL::new_table ( identifier, identifier_t );
cc
cc	    uns32 integer;
cc	    NDL::new_table ( integer, integer_t );
cc	    uns32 done_integer;
cc	    NDL::new_table ( done_integer,
cc	                     done_integer_t );
cc	    uns32 fraction;
cc	    NDL::new_table ( fraction, fraction_t );
cc	    uns32 exponent;
cc	    NDL::new_table ( exponent, exponent_t );
cc
cc	    uns32 character_literal;
cc	    NDL::new_table ( character_literal,
cc	                     character_literal_t );
cc	    uns32 wide_character_literal;
cc	    NDL::new_table ( wide_character_literal,
cc	                     wide_character_literal_t );
cc	    uns32 string_literal;
cc	    NDL::new_table ( string_literal,
cc	                     string_literal_t );
cc	    uns32 wide_string_literal;
cc	    NDL::new_table ( wide_string_literal,
cc	                     wide_string_literal_t );
cc
cc	    uns32 initial;
cc	    NDL::new_table ( initial, MASTER );
cc	    uns32 pp_beginning;
cc	    NDL::new_table ( pp_beginning, MASTER );
cc	    uns32 pp_include;
cc	    NDL::new_table ( pp_include, MASTER );
cc	    uns32 normal;
cc	    NDL::new_table ( normal, MASTER );
cc	    uns32 premature_new_line;
cc	    NDL::new_table ( premature_new_line,
cc	                     MASTER );
cc	    uns32 premature_end_of_file;
cc	    NDL::new_table ( premature_end_of_file,
cc	                     MASTER );
cc
cc	    uns32 operator;
cc	    NDL::new_table ( operator, ATOM );
cc	    uns32 universal_char;
cc	    NDL::new_table ( universal_char, ATOM );
cc
cc	    // Abbreviations:
cc
cc	    uns32 ill_universal_char_t =
cc		illegal_universal_character_t;
lex
lex
lex	begin c++ lexical program;
lex
lex	// Before this lexical program is used the input
lex	// should be preprocessed to
lex	//
lex	//    (1) Replace trigraph sequences.
lex	//    (2) Eliminate carriage returns next to
lex	//        newlines.
lex	//    (3) Eliminate backslash newline pairs.
lex	//
lex	// After this lexical program is used the output
lex	// should be post-processed to
lex	//
lex	//    (4) Perform C/C++ macro preprocessing
lex	//        (macro expansion).
lex	//    (5) Delete space and newlines.
lex	//    (6) Concatenate adjacent ordinary quoted
lex	//        strings and adjacent wide quoted
lex	//        strings.
lex
lex	"<digit>" = "0-9";
cc	    const char * digit = "0123456789";
lex	"<oct-digit>" = "0-7";
cc	    const char * oct_digit = "01234567";
lex	"<hex-digit>" = "0-9" | "a-f" | "A-F";
cc	    const char * hex_digit =
cc	        "0123456789ABCDEFabcdef";
lex
lex	"<ascii-letter>" = "a-z" | "A-Z";
cc	    const char * ascii_letter =
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
cc
lex	"<letter>" = "<ascii-letter>"
lex	           | "<non-ascii-letter>
lex
lex	// <non-ascii-letter> ::= UNICODE character in
lex	// one of the code ranges designated in
lex	// ../include/ll_lexeme_non_ascii_letters.h
lex	//
lex	// Universal characters are only permitted in
lex	// identifiers, character literals, and string
lex	// literals.  In identifiers they must represent
lex	// non-ASCII-letters.
lex
cc	    uns32 non_ascii_letter;
cc	    NDL::begin_atom_pattern
cc		    ( non_ascii_letter );
cc		add_non_ascii_letters();
cc	    NDL::end_atom_pattern();
cc
lex	"<identifier-non-digit>" = "_" | "<letter>";
cc	    const char * identifier_non_ditir =
cc	        "_"
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
cc		// Must also use add_non_ascii_letters.
cc
lex
lex	"<horizontal-space-char>" = " " | "<HT>";
cc	    const char * horizontal_space_char = " \t";
cc
lex
lex	"<vertical-space-char>" =
lex	    "<VT>" | "<FF>" | "<CR>" | "<NL>";
cc	    const char * vertical-space_char =
cc	        "\v\f\r\n";
cc
lex
lex	// The following can begin an operator,
lex	// a separator, or either.
lex	//
lex	"<op-char>" = "#" | "<" | ">" | ":" | "%" |
lex	            | "." | "?" | "+" | "-" | "*" | "/"
lex	            | "^" | "&" | "|" | "~" | "!" | ","
lex	            | "(" | ")" | "[" | "]" | "{" | "}"
lex	            | ";";
cc	    const char * op_char =
cc	        "#<>:%.?+-*/^&|~!,()[]{};";
cc
lex
lex	"<basic-char>" = "<ascii-letter>"
lex	               | "<digit>"
lex	               | "_"
lex	               | "<op-char>"
lex	               | "\" | "<Q>" | "'"
lex	               | "<horizontal-space-char>"
lex	               | "<vertical-space-char>";
cc	    const char * basic_char =
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
cc		"_"
cc	        "#<>:%.?+-*/^&|~!,()[]{};"
cc		"\\\"'"
cc	        " \t"
cc	        "\v\f\r\n";
cc
lex
lex	"<sign>" = "+" | "-" ;
cc	    const char * sign = "+-";
cc
lex
lex	"<u-or-U>" = "u" | "U" ;
cc	    const char * u_or_U = "uU";
cc
lex
lex
lex	// C/C++ preprocessing is hereafter abbreviated
lex	// as `pp'.
lex
lex	// Alternative operators that are not identi-
lex	// fiers are translated.  E.g., <: becomes [ in
lex	// the lexeme // translation.
lex
lex	// C++ punctuation are treated as `operators'.
lex
lex	// Pp numbers are divided into 3 categories:
lex	//      integers        nothing but digits
lex	//      floating point  legal floating point #'s
lex	//      number          all other pp numbers
lex
lex	// Because of pp control lines, lexical scanning
lex	// is slightly context dependent.  There are
lex	// several contexts, each corresponding to a
lex	// different master table:
lex	//
lex	//    initial master
lex	//        Used in line beginning situations to
lex	//	  recognize the # token that introduces
lex	//	  a pp control line.
lex	//    pp beginning master
lex	//        Used to scan the beginning of a pp
lex	//	  control line after the # has been
lex	//        scanned but before anything else is
lex	//        scanned.
lex	//    pp include master
lex	//        Used to scan the pp-header token in a
lex	//        #include line after #include has been
lex	//        scanned.
lex	//    normal master
lex	//        Used to scan a non pp control line or
lex	//        the rest of a non-#include pp control
lex	//        line.
lex	//
lex	// The whitespace lexeme types are:
lex	//
lex	//    newline
lex	//        a sequence of zero or more <FF>, <VT>
lex	//        and <CR>'s followed by a single <NL>
lex	//        followed by zero or more <CR>'s.
lex	//    horizontal-space
lex	//        sequence of "<horizontal-space-char>"s
lex	//        <FF>, <VT>, <CR>, and <NL>'s are
lex	//        excluded
le	//    comment
lex	//        "/*" comment (including /* and */)
lex	//        "//" comment (including // but not
lex	//                      ending newline)
lex	//    end of file (lexeme is "")
lex	//    premature line feed (lexeme is "<NL>")
lex	//    premature end of file (lexeme is "")
lex	//
lex	// This allows line feeds to be used to end pp
lex	// control lines.  The `premature' lexemes are
lex	// errors: the previous lexeme is treated as if
lex	// there were no error (i.e., as if there were a
lex	// ", ', */, etc.) and the next lexeme is a
lex	// `premature ...' lexeme.
lex	//
lex	// Characters that are not part of any C++
lex	// lexeme and universal characters that are not
lex	// part of any C++ lexeme are made into lexemes
lex	// or erroneous atoms of the types:
lex	//
lex	//    illegal character
lex	//        A single character
lex	//    illegal universal character
lex	//        A \UXXXXXXXX or \uXXXX sequence
lex	//
lex	// These are untranslated.
lex
lex	begin initial master table;
cc	    NDL::begin_table ( initial );
cc
lex
lex	    "<horizontal-space-char>"
lex	        call horizontal_space;
cc		NDL::begin_dispatch
cc			( horizontal_space_char );
cc		    NDL::call ( horizontal_space );
cc		NDL::end_dispatch();
cc
lex
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur inside
lex	    // pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    "#" output operator goto pp beginning;
lex	    "##" output operator goto normal;
cc		NDL::begin_dispatch ( "#" );
cc		    NDL::begin_dispatch ( "#" );
cc		        NDL::output ( operator_t );
cc		        NDL::goto ( normal );
cc		    NDL::end_dispatch();
cc		    NDL::output ( operator_t );
cc		    NDL::goto ( pp_beginning );
cc		NDL::end_dispatch();
cc
lex
lex	    "%:" translate to "#" output operator
lex	        goto pp beginning;
lex	    "%:%:" translate to "##" output operator
lex	        goto normal;
cc		NDL::begin_dispatch ( "%" );
cc		  NDL::begin_dispatch ( ":" );
cc		    NDL::begin_dispatch ( "%" );
cc		      NDL::begin_dispatch ( ":" );
cc		        NDL::translate_to ( "##" );
cc		        NDL::output ( operator_t );
cc		        NDL::goto ( normal );
cc		      NDL::end_dispatch();
cc		    NDL::end_dispatch();
cc
cc		    NDL::translate_to ( "#" );
cc	            NDL::output ( operator_t );
cc	            NDL::goto ( pp_beginning );
cc
cc		  NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    goto normal;
cc		NDL::goto ( normal );
cc
lex
lex	end initial master table;
cc	    NDL::end_table();
cc
lex
lex	begin horizontal space lexeme table;
cc	    NDL::begin_table ( horizontal_space );
cc
lex
lex	    "<horizontal-space-char>" accept;
cc		NDL::begin_dispatch
cc			( horizontal_space_char );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end horizontal lexeme table;
cc	    NDL::end_table();
cc
lex
lex	begin new line lexeme table;
cc	    NDL::begin_table ( new_line );
cc
lex
lex	    "<vertical-space-char>" accept;
lex	    "<CR>" accept;
cc		NDL::begin_dispatch ( "\f\v\r" );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<NL>" goto new line finish;
cc		NDL::begin_dispatch
cc			( "\n" );
cc		    NDL::goto ( new_line_finish );
cc		NDL::end_dispatch();
cc
lex
lex	    output illegal vertical characters return;
cc		NDL::output
cc		    ( illegal_vertical_space_t );
cc		NDL::ret();
cc
lex
lex	end new line table;
cc	    NDL::end_table();
cc
lex
lex	begin new line finish lexeme table;
cc	    NDL::begin_table ( new_line_finish );
cc
lex
lex	    "<CR>" accept;
cc		NDL::begin_dispatch ( "\r" );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end new line finish lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin "/*" comment lexeme table;
cc	    NDL::begin_table ( slash_star_comment );
cc
lex
lex	    "*/" return;
lex	    "*" accept;
cc		NDL::begin_dispatch ( "*" );
cc		    NDL::begin_dispatch ( "/" );
cc		        NDL::ret();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::goto ( premature_end_of_file );
cc
lex
lex	end "/*" comment lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin "//" comment lexeme table;
cc	    NDL::begin_table ( slash_slash_comment );
cc
lex
lex	    "<NL>" keep 0 return;
cc		NDL::begin_dispatch ( "\n" );
cc		    NDL::keep ( 0 );
cc		    NDL::ret();
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::goto ( premature_end_of_file );
cc
lex
lex	end "//" comment lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin premature new line master table;
cc	    NDL::begin_table ( premature_new_line );
cc
lex
lex	    "<NL>" output premature new line
lex	        goto initial;
cc		NDL::begin_dispatch ( "\n" );
cc		    NDL::output
cc			( premature_new_line );
cc		    NDL::goto ( initial );
cc		NDL::end_dispatch();
cc
lex
lex	end premature new line master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin premature end of file master table;
cc	    NDL::begin_table ( premature_end_of_file );
cc
lex
lex	    output premature end of file goto initial;
cc	        NDL::output ( premature_end_of_file_t );
cc	        NDL::goto ( initial );
lex
lex	end premature end of file master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin pp beginning master table;
cc	    NDL::begin_table ( pp_beginning );
cc
lex
lex	    "<horizontal-space-char>"
lex	        call horizontal_space;
cc		NDL::begin_dispatch
cc			( horizontal_space_char );
cc		    NDL::call ( horizontal_space );
cc		NDL::end_dispatch();
cc
lex
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur inside
lex	    // pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    "include<identifier-non-digit>"
lex	        keep 0 goto normal;
lex	    "include<digit>"
lex	        keep 0 goto normal;
lex	    "include"
lex	        output identifier goto pp include;
lex	    goto normal;
cc		NDL::begin_dispatch ( "i" );
cc		NDL::begin_dispatch ( "n" );
cc		NDL::begin_dispatch ( "c" );
cc		NDL::begin_dispatch ( "l" );
cc		NDL::begin_dispatch ( "u" );
cc		NDL::begin_dispatch ( "d" );
cc		NDL::begin_dispatch ( "e" );
cc		    NDL::begin_dispatch
cc			    ( identifier_non_digit );
cc		        add_non_ascii_letters();
cc	    	        NDL::add_characters ( digit );
cc		        NDL::keep ( 0 );
cc		        NDL::goto ( normal );
cc		    NDL::end_dispatch();
cc		    NDL::output ( identifier_t );
cc		    NDL::goto ( pp_include );
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	end pp beginning master table;
cc	    NDL::end_table();
cc
lex
lex	begin pp include master table;
cc	    NDL::begin_table ( pp_include );
cc
lex
lex	    "<horizontal-space-char>"
lex	        call horizontal space;
cc		NDL::begin_dispatch
cc			( horizontal_space_char );
cc		    NDL::call ( horizontal_space );
cc		NDL::end_dispatch();
cc
lex
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur inside
lex	    // pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex
lex	    "<" translate to ""
lex	        goto bracketed header name;
cc		NDL::begin_dispatch ( "<" );
cc		    NDL::translate_to ( "" );
cc		    NDL::goto ( bracketed_header );
cc		NDL::end_dispatch();
cc
lex
lex	    "<Q>" translate to ""
lex	        goto quoted header name;
cc		NDL::begin_dispatch ( "\"" );
cc		    NDL::translate_to ( "" );
cc		    NDL::goto ( quoted_header );
cc		NDL::end_dispatch();
cc
lex
lex	    goto normal;
cc	        NDL::goto ( normal );
cc
lex
lex	end pp include master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin bracketed header name lexeme table;
cc	    NDL::begin_table ( bracketed_header_name );
cc
lex
lex	    ">" translate to "" goto normal;
cc		NDL::begin_dispatch ( ">" );
cc		    NDL::translate_to ( "" );
cc		    NDL::goto ( normal );
cc		NDL::end_dispatch();
cc
lex
lex	    "<vertical-space-char>"
lex	        keep 0 goto premature new line;
cc		NDL::begin_dispatch
cc		    ( vertical_space_char );
cc		    NDL::keep ( 0 );
cc		    NDL::goto ( premature_new_line );
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::goto ( premature_end_of_file );
cc
lex
lex	end bracketed header name lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	// Quoted header names are not the same as
lex	// quoted strings, and cannot have escape
lex	// sequences.
lex	//
lex	begin quoted header name lexeme table;
cc	    NDL::begin_table ( quoted_header_name );
cc
lex
lex	    "<Q>" translate to "" goto normal;
cc		NDL::begin_dispatch ( "\"" );
cc		    NDL::translate_to ( "" );
cc		    NDL::goto ( normal );
cc		NDL::end_dispatch();
cc
lex
lex	    "<vertical-space-char>"
lex	        keep 0 goto premature new line;
cc		NDL::begin_dispatch
cc		    ( vertical_space_char );
cc		    NDL::keep ( 0 );
cc		    NDL::goto ( premature_new_line );
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::goto ( premature_end_of_file );
cc
lex
lex	end quoted header name lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin normal master table;
cc	    NDL::begin_table ( normal );
cc
lex
lex	    "<horizontal-space-char>"
lex             call horizontal space;
cc		NDL::begin_dispatch
cc			( horizontal_space_char );
cc		    NDL::call ( horizontal_space );
cc		NDL::end_dispatch();
cc
lex
lex	    "/*" call "/*" comment;
lex	    "//" call "//" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "/" );
cc		        NDL::call
cc	                    ( slash_slash_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    "<identifier-non-digit>" call identifier;
cc		NDL::begin_dispatch
cc			( identifier_non_digit );
cc		    add_non_ascii_letters();
cc		    NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "\<u-or-U>"
lex	             match escaped character
lex	             require <non-ascii-letter>
lex	                 call identifier
lex	        else match escaped character
lex		     output illegal universal
lex	                    character
lex	        else keep 1 output illegal character;
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::begin_dispatch ( u_or_U );
cc		        NDL::match
cc			     ( escaped_character );
cc		        NDL::require
cc			     ( non_ascii_letter );
cc		        NDL::call ( identifier );
cc		    NDL::ELSE();
cc		        NDL::match
cc			     ( escaped_character );
cc		        NDL::output
cc			     ( ill_universal_char_t );
cc		    NDL::ELSE();
cc			NDL::keey ( 1 );
cc		        NDL::output
cc			     ( illegal_character_t );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex
lex	    "<digit>" call integer;
lex	    ".<digit>" call fraction;
lex
lex	    "'" translate to ""
lex	        call character literal;
lex	    "L'" translate to ""
lex	         call wide character literal;
lex	    "<Q>" translate to ""
lex	          call string literal;
lex	    "L<Q>" translate to ""
lex	           call wide string literal;
lex
lex	    "<op-char>"
lex	        match operator output operator
lex	        else output unrecognized character;
lex
lex	    "<NL>" output line feed goto initial;
lex	    "<other>" output unrecognized character
lex	              goto initial;
lex	    output end of file goto initial;
lex	end normal master table;
lex
lex	begin operator atom table;
lex	    "(";
lex	    ")";
lex	    "[";
lex	    "]";
lex	    "{";
lex	    "}";
lex	    "#";
lex	    "##";
lex	    "<:";
lex	    ":>";
lex	    "<%";
lex	    "%>";
lex	    "%:";
lex	    "%:%:";
lex	    ";";
lex	    ":";
lex	    "...";
lex	    "?";
lex	    "::";
lex	    ".";
lex	    ".*";
lex	    "+";
lex	    "-";
lex	    "*";
lex	    "/";
lex	    "%";
lex	    "^";
lex	    "&";
lex	    "|";
lex	    "~";
lex	    "!";
lex	    "=";
lex	    "<";
lex	    ">";
lex	    "+=";
lex	    "-=";
lex	    // etc.
lex
lex	    fail;
lex	end operator atom table;
lex
lex
lex	"<u-or-U>" = "u" | "U";
lex
lex	begin identifier lexeme table;
lex	    "<non-digit>" accept;
lex	    "\<u-or-U>" match escaped character
lex	                require "<letter>"
lex	                else keep 0 return;
lex	    goto normal;
lex	end identifier lexeme table;
lex
lex	"<non-digit-except-lLuU> =
lex	    <non-digit> & ~ "l" & ~ "u" & ~ "L" & ~ "U";
lex
lex	begin integer lexeme table;
lex	    "<digit>" accept;
lex	    "." goto fraction;
lex	    "e<sign><digit>" goto exponent;
lex	    "E<sign>"<digit> goto exponent;
lex	    "ul" goto done integer;
lex	    "uL" goto done integer;
lex	    "Ul" goto done integer;
lex	    "UL" goto done integer;
lex	    "lu" goto done integer;
lex	    "lU" goto done integer;
lex	    "Lu" goto done integer;
lex	    "LU" goto done integer;
lex	    "u"  goto done integer;
lex	    "U"  goto done integer;
lex	    "l"  goto done integer;
lex	    "L"  goto done integer;
lex	    "e<sign>" goto pp number;
lex	    "E<sign>" goto pp number;
lex	    "<non-digit-except-lLuU>" goto pp number;
lex	    output integer return;
lex	end integer lexeme table;
lex
lex	begin done integer lexeme table;
lex	    "<digit>" goto pp number;
lex	    "e<sign>" goto pp number;
lex	    "E<sign>" goto pp number;
lex	    "<non-digit>" goto pp number;
lex	    "." goto pp number;
lex	    output integer return;
lex	end done integer lexeme table;
lex
lex	"<non-digit-except-lLfF> =
lex	    <non-digit> & ~ "l" & ~ "f" & ~ "L" & ~ "F";
lex
lex	begin fraction lexeme table;
lex	    "<digit>" accept;
lex	    "." goto pp number;
lex	    "e<sign><digit>" goto exponent;
lex	    "E<sign>"<digit> goto exponent;
lex	    "f"  goto done floating point;
lex	    "F"  goto done floating point;
lex	    "l"  goto done floating point;
lex	    "L"  goto done floating point;
lex	    "e<sign><digit>" goto exponent;
lex	    "E<sign><digit>" goto exponent;
lex	    "e<sign>" goto pp number;
lex	    "E<sign>" goto pp number;
lex	    "<non-digit-except-lLfF>" goto pp number;
lex	    output floating point return;
lex	end fraction lexeme table;
lex
lex	begin exponent lexeme table;
lex	    "<digit>" accept;
lex	    "." goto pp number;
lex	    "f"  goto done floating point;
lex	    "F"  goto done floating point;
lex	    "l"  goto done floating point;
lex	    "L"  goto done floating point;
lex	    "e<sign>" goto pp number;
lex	    "E<sign>" goto pp number;
lex	    "<non-digit-except-lLfF>" goto pp number;
lex	    output floating point return;
lex	end exponent lexeme table;
lex
lex	begin floating point done lexeme table;
lex	    "<digit>" goto pp number;
lex	    "e<sign>" goto pp number;
lex	    "E<sign>" goto pp number;
lex	    "<non-digit>" goto pp number;
lex	    "." goto pp number;
lex	    output floating point return;
lex	end floating point done lexeme table;
lex
lex	begin pp number lexeme table;
lex	    "<digit>" goto pp number;
lex	    "e<sign>" goto pp number;
lex	    "E<sign>" goto pp number;
lex	    "<non-digit>" goto pp number;
lex	    "." goto pp number;
lex	    output pp number return;
lex	end pp number lexeme table;
lex
lex	"<character-literal-char>" =
lex	    "<source-char>" & ~ "'" & ~ "\/" & ~ "\lf/";
lex
lex	begin character literal lexeme table;
lex	    "'" translate to "" goto normal;
lex	    "<NL>" keep 0 goto premature new line;
lex	    "\" match escaped character
lex	        else error bad escape character;
lex	    "<character-literal-char>" accept;
lex	    "<other>" error bad character literal
lex                   character;
lex	    goto premature end of file;
lex	end character literal lexeme table;
lex
lex	begin wide character literal lexeme table;
lex	    "'" translate to "" goto normal;
lex	    "<NL>" keep 0 goto premature new line;
lex	    "\" match escaped character
lex	        else error bad escape character;
lex	    "<character-literal-char>" accept;
lex	    "<other>" error bad character literal
lex                   character;
lex	    goto premature end of file;
lex	end wide character literal lexeme table;
lex
lex	"<string-literal-char>" =
lex	    "<source-char>"
lex	    & ~ "\"/" & ~ "\/" & ~ "\lf/";
lex
lex	begin string literal lexeme table;
lex	    "<Q>" translate to "" goto normal;
lex	    "<NL>" keep 0 goto premature new line;
lex	    "\" match escaped character
lex	        else error bad escape character;
lex	    "<string-literal-char>" accept;
lex	    "<other>" error bad character literal
lex	                        character;
lex	    goto premature end of file;
lex	end string literal lexeme table;
lex
lex	begin wide string literal lexeme table;
lex	    "<Q>" translate to ""
lex               goto normal line master;
lex	    "<NL>" keep 0
lex                goto premature new line master;
lex	    "\" match escaped character
lex	        else error bad escape character;
lex	    "<string-literal-char>" accept;
lex	    "<other>" error bad character literal
lex	                        character;
lex	    goto premature end of file;
lex	end wide string literal lexeme table;
lex
lex	// This atom table is used when the next atom
lex	// begins with \ and is in a character or string
lex	// literal.
lex	//
lex	// We allow only a maximum of 8 hexadecimal
lex	// digits after \x; 9 digits is an error.  The
lex	// C++ standard permits any number of hexa-
lex	// decimal digits.
lex	//
lex	begin escaped character atom table;
lex	    "\n" translate to "<NL>";
lex	    "\t" translate to "<HT>";
lex	    "\v" translate to "<VT>";
lex	    "\b" translate to "<BS>";
lex	    "\r" translate to "<CR>";
lex	    "\f" translate to "<FF>";
lex	    "\a" translate to "<BEL>";
lex	    "\\" translate to "\";
lex	    "\?" translate to "?";
lex	    "\<Q>" translate to "<Q>";
lex	    "\'" translate to "'";
lex	    "\<oct-digit>"
lex	        translate oct 1 0;
lex	    "\<oct-digit><oct-digit>"
lex	        translate oct 1 0;
lex	    "\<oct-digit><oct-digit><oct-digit>"
lex	        translate oct 1 0;
lex	    "\x<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>" fail;
lex	    "\u<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    fail;
lex	end escaped character atom table;
lex
lex	end c++ lexical program;
