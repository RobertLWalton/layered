// Layers Language C++ Lexical Analyzer
//
// File:	ll_lexeme_c++.lexcc
// Author:	Bob Walton (walton@acm.org)
// Date:	Sun Jun 12 07:01:46 EDT 2011
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.

// Lines beginning with `lex<HT>' and lines equal to
// `lex' are copied to ll_lexeme_c++.lex and then
// to the C++ Lexical Program appendix of ../doc/
// layered-introduction.tex.
//
// Lines beginning with `cc<HT>' and lines equal to `cc'
// are copied to ll_lexeme_c++.cc and compiled to
// produce code that can create a C++ lexical
// program.

// Table of Contents
//
//	Usage and Setup
//	Program Construction

// Usage and Setup
// ----- --- -----

cc	// This file was automatically generated from
cc	// ll_lexeme_c++.lexcc.
cc
lex	// This file was automatically generated from
lex	// ll_lexeme_c++.lexcc.
lex
cc	# include <ll_lexeme_ndl.h>
cc	# include <ll_lexeme_c++.h>
cc	# include <ll_lexeme_non_ascii_characters.h>
cc	using namespace ll::lexeme::ndl;
cc	# define LEX ll::lexeme
cc	# define LEXCPP ll::lexeme::cpp
cc	using namespace LEXCPP;
cc

// Program Construction
// ------- ------------

cc	min::locatable_var<LEX::program>
cc	    LEXCPP::default_program;
cc
cc	const char * const
cc		LEXCPP::type_name[MAX_TYPE+1] = {
cc
cc	    NULL,
cc	    "WHITESPACE",
cc	    "COMMENT",
cc	    "BRACKETED_HEADER_NAME",
cc	    "QUOTED_HEADER_NAME",
cc	    "OPERATOR",
cc	    "IDENTIFIER",
cc	    "DECIMAL_INTEGER",
cc	    "OCTAL_INTEGER",
cc	    "HEXADECIMAL_INTEGER",
cc	    "FLOAT",
cc	    "PP_NUMBER",
cc	    "CHARACTER_LITERAL",
cc	    "u_CHARACTER_LITERAL",
cc	    "U_CHARACTER_LITERAL",
cc	    "L_CHARACTER_LITERAL",
cc	    "STRING_LITERAL",
cc	    "u_STRING_LITERAL",
cc	    "U_STRING_LITERAL",
cc	    "L_STRING_LITERAL",
cc	    "NEWLINE",
cc	    "END_OF_FILE",
cc	    "MISPLACED_CHARACTER",
cc	    "ASCII_UNIVERSAL_CHARACTER",
cc	    "MISPLACED_UNIVERSAL_CHARACTER",
cc	    "SHORT_UNIVERSAL_CHARACTER",
cc	    "PREMATURE_NEWLINE",
cc	    "PREMATURE_END_OF_FILE",
cc	    "ILL_FORMED_ESCAPE",
cc	    "TOO_LONG_HEX_ESCAPE" };
cc
cc	const char * LEXCPP::type_code =
cc	    "?w/bq+idohfnccccssssleMAUSLEPH";
cc
cc	static struct char_range { uns32 min, max; }
cc	    non_ascii_letters[] =
cc	{
cc		// { min,		max },
cc		NON_ASCII_LETTERS,
cc		   { 0,                0 }
cc	};
cc
cc	static void add_non_ascii_letters ( void )
cc	{
cc	    for ( char_range *p = non_ascii_letters;
cc		  p->min || p->max != 0; ++ p )
cc		NDL::add_characters ( p->min, p->max );
cc	}
cc
cc	char_range non_ascii_combining_chars[] =
cc	{
cc		// { min,		max },
cc		   NON_ASCII_COMBINING_CHARACTERS,
cc		   { 0,                0 }
cc	};
cc
cc	static void add_non_ascii_combining_chars
cc		( void )
cc	{
cc	    for ( char_range *p =
cc		      non_ascii_combining_chars;
cc		  p->min != 0 || p->max != 0; ++ p )
cc		NDL::add_characters ( p->min, p->max );
cc	}
cc
lex	"<non-NL> :: = ~ "<NL>"
cc	static void add_non_nl ( void )
cc	{
cc	    NDL::add_characters ( 0, '\n' - 1 );
cc	    NDL::add_characters ( '\n' + 1, 0xFFFFFFFF );
cc	}
cc
cc	void LEXCPP::init_cpp_program ( void )
cc	{
cc	    if ( LEXCPP::default_program != NULL_STUB )
cc	        return;
cc

lex	begin standard lexical program;
lex
cc	    begin_program ( type_name, MAX_TYPE );
cc
cc	    uns32 whitespace;
cc	    NDL::new_table
cc		( whitespace, whitespace_t );
cc
cc	    uns32 slash_star_comment;
cc	    NDL::new_table ( slash_star_comment,
cc	                     comment_t );
cc	    uns32 slash_slash_comment;
cc	    NDL::new_table ( slash_slash_comment,
cc	                     comment_t );
cc
cc	    uns32 bracketed_header_name;
cc	    NDL::new_table ( bracketed_header_name,
cc	                     bracketed_header_name_t );
cc	    uns32 quoted_header_name;
cc	    NDL::new_table ( quoted_header_name,
cc	                     quoted_header_name_t );
cc
cc	    uns32 identifier;
cc	    NDL::new_table ( identifier, identifier_t );
cc
cc	    uns32 decimal_integer;
cc	    NDL::new_table ( decimal_integer,
cc			     decimal_integer_t );
cc	    uns32 octal_integer;
cc	    NDL::new_table ( octal_integer,
cc			     octal_integer_t );
cc	    uns32 hexadecimal_integer;
cc	    NDL::new_table ( hexadecimal_integer,
cc			     hexadecimal_integer_t );
cc	    uns32 suffix;
cc	    NDL::new_table ( suffix, NONE );
cc	    uns32 float_integer;
cc	    NDL::new_table ( float_integer, float_t );
cc	    uns32 fraction;
cc	    NDL::new_table ( fraction, float_t );
cc	    uns32 exponent;
cc	    NDL::new_table ( exponent, float_t );
cc	    uns32 pp_number;
cc	    NDL::new_table ( pp_number, pp_number_t );
cc
cc	    uns32 char_literal;
cc	    NDL::new_table ( char_literal, NONE );
cc	    uns32 string_literal;
cc	    NDL::new_table ( string_literal, NONE );
cc
cc	    uns32 initial;
cc	    NDL::new_table ( initial, MASTER );
cc	    uns32 pp_beginning;
cc	    NDL::new_table ( pp_beginning, MASTER );
cc	    uns32 pp_include;
cc	    NDL::new_table ( pp_include, MASTER );
cc	    uns32 normal;
cc	    NDL::new_table ( normal, MASTER );
cc	    uns32 premature_newline;
cc	    NDL::new_table ( premature_newline,
cc	                     MASTER );
cc	    uns32 premature_end_of_file;
cc	    NDL::new_table ( premature_end_of_file,
cc	                     MASTER );
cc	    uns32 erroneous_universal_char;
cc	    NDL::new_table ( erroneous_universal_char,
cc	                     NONE );
cc
cc	    uns32 operator_atom;
cc	    NDL::new_table ( operator_atom, ATOM );
cc	    uns32 escaped_char;
cc	    NDL::new_table ( escaped_char, ATOM );
cc	    uns32 universal_char;
cc	    NDL::new_table
cc		( universal_char, ATOM );
cc	    uns32 short_universal_char;
cc	    NDL::new_table
cc		( short_universal_char, ATOM );
cc
lex
lex
lex	begin c++ lexical program;
lex
lex	// Before this lexical program is used the input
lex	// should be preprocessed to
lex	//
lex	//    (1) Replace trigraph sequences.
lex	//    (2) Eliminate carriage-returns next to a
lex	//	    newline
lex	//    (3) Eliminate sequences of the form:
lex	//	    backslash newline
lex	//
lex	// After this lexical program is used the output
lex	// should be post-processed to
lex	//
lex	//    (4) Perform C/C++ macro preprocessing
lex	//        (macro expansion).
lex	//    (5) Delete space and newlines.
lex	//    (6) Concatenate adjacent quoted strings
lex	//        of the same character type (ordinary,
lex	//        u, U, or L).
lex
lex	"<digit>" = "0-9";
cc	    const char * digit = "0123456789";
lex	"<non-zero-digit>" = "1-9";
cc	    const char * non_zero_digit = "123456789";
lex	"<oct-digit>" = "0-7";
cc	    const char * oct_digit = "01234567";
lex	"<hex-digit>" = "0-9" | "a-f" | "A-F";
cc	    const char * hex_digit =
cc	        "0123456789ABCDEFabcdef";
cc
lex
lex	"<ascii-letter>" = "a-z" | "A-Z";
cc	    const char * ascii_letter =
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
cc
lex
lex	"<letter>" = "<ascii-letter>"
lex	           | "<non-ascii-letter>
lex
lex	// <non-ascii-letter> ::= UNICODE character in
lex	// one of the code ranges designated in
lex	// NON_ASCII_LETTERS in ll_lexeme_non_ascii_
lex	// characters.h.
lex
lex	// <combining-char> ::= UNICODE character in
lex	// one of the code ranges designated in
lex	// NON_ASCII_COMBINING_CHARACTERS in ll_lexeme_
lex	// non_ascii_characters.h.
lex
lex	// Universal characters are only permitted in
lex	// identifiers, character literals, and string
lex	// literals.  In identifiers they must represent
lex	// non-ASCII-letters or non-ASCII combining
lex	// characters, and the latter cannot be the
lex	// initial character of an identifier.
lex
lex	"<identifier-non-digit>" = "_" | "<letter>";
cc	    const char * identifier_non_digit =
cc	        "_"
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
cc		// Must also use add_non_ascii_letters.
cc
cc	    uns32 non_ascii_letter;
cc	    NDL::begin_atom_pattern
cc		    ( non_ascii_letter );
cc		add_non_ascii_letters();
cc	    NDL::end_atom_pattern();
cc
lex
lex	"<identifier-char>" = "<identifier-non-digit>"
lex	                    | "<digit>"
lex	                    | "<combining_char>"
cc	    const char * identifier_char =
cc	        "_"
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
cc	        "0123456789";
cc		// Must also use add_non_ascii_letters
cc		// and add_non_combining_chars.
cc
lex
lex	"<non-ascii-identifier-char>" =
lex	          "<non-ascii-letter>"
lex	        | "<combining_char>"
cc	    uns32 non_ascii_identifier_char;
cc	    NDL::begin_atom_pattern
cc		    ( non_ascii_identifier_char );
cc		add_non_ascii_letters();
cc		add_non_ascii_combining_chars();
cc	    NDL::end_atom_pattern();
cc
lex
lex	// Because `u', `U', or `L' can start a char-
lex	// acter or string literal, we must define:
lex	//
lex	"<u_U_L>" = "u" | "U" | "L";
lex	"<identifier-non-literal>" =
lex	          "<identifier-non-digit>"
lex	        & ~ "<u_U_L>";
cc	    const char * u_U_L = "uUL";
cc	    const char * identifier_non_literal =
cc	        "_"
cc	        "abcdefghijklmnopqrstvwxyz"
cc	        "ABCDEFGHIJKMNOPQRSTVWXYZ";
cc		// Must also use add_non_ascii_letters.
cc
lex
lex	"<whitespace-char>" =
lex	    " " | "<HT>" | "<VT>" | "<FF>";
lex	    // newline is treated separately
cc	    const char * whitespace_char = " \t\v\f";
cc
lex
lex	// The following can begin an operator or punc-
lex	// tuation mark.
lex	//
lex	// / not followed by / or * and . not followe
lex	// by <digit> are handled separately.
lex	//
lex	"<op-char>" = "#" | "<" | ">" | ":" | "%" |
lex	            | "?" | "+" | "-" | "*"
lex	            | "^" | "&" | "|" | "~" | "!" | ","
lex	            | "(" | ")" | "[" | "]" | "{" | "}"
lex	            | ";";
cc	    const char * op_char =
cc	        "#<>:%?+-*^&|~!,()[]{};";
cc
lex
lex	"<basic-char>" = "<ascii-letter>"
lex	               | "<digit>"
lex	               | "_"
lex	               | "<op-char>" | "."
lex	               | "\" | "<Q>" | "'"
lex	               | "<horizontal-space-char>"
lex	               | "<vertical-space-char>";
cc	    const char * basic_char =
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
cc		"_"
cc	        "#<>:%.?+-*/^&|~!,()[]{};"
cc		"\\\"'"
cc	        " \t"
cc	        "\v\f\r\n";
cc
lex
lex	"<sign>" = "+" | "-" ;
cc	    const char * sign = "+-";
cc
lex
lex	"<u_U>" = "u" | "U" ;
cc	    const char * u_U = "uU";
cc
lex
lex	"<ascii-char>" = ASCII Character
cc	    uns32 ascii_char;
cc	    NDL::begin_atom_pattern ( ascii_char );
cc		add_characters ( 0, 0x7F );
cc	    NDL::end_atom_pattern();
cc
lex
lex
lex	// C/C++ preprocessing is hereafter abbreviated
lex	// as `pp'.
lex
lex	// Alternative operators that are not identi-
lex	// fiers are translated.  E.g., <: becomes [ in
lex	// the lexeme translation.
lex
lex	// C++ punctuation are treated as `operators'.
lex
lex	// Pp numbers are divided into 3 categories:
lex	//      dec integer   nothing but digits
lex	//                    not begining with 0
lex	//      oct integer   nothing but digits
lex	//                    begining with 0
lex	//      hex integer   nothing but hex digits
lex	//                    prefaced by 0x or 0X
lex	//      float         legal floating point #'s
lex	//      pp_number     all other pp numbers
lex
lex	// Because of pp control lines, lexical scanning
lex	// is slightly context dependent.  There are
lex	// several contexts, each corresponding to a
lex	// different master table:
lex	//
lex	//    initial master
lex	//        Used in line beginning situations to
lex	//        recognize the # token that introduces
lex	//        a pp control line.
lex	//    pp beginning master
lex	//        Used to scan the beginning of a pp
lex	//        control line after the # has been
lex	//        scanned but before anything else is
lex	//        scanned.
lex	//    pp include master
lex	//        Used to scan the pp-header token in a
lex	//        #include line after #include has been
lex	//        scanned.
lex	//    normal master
lex	//        Used to scan a non pp control line or
lex	//        the rest of a non-#include pp control
lex	//        line.
lex	//
lex	// The whitespace lexeme types are:
lex	//
lex	//    newline
lex	//        a sequence of zero or more <FF>, <VT>
lex	//        and <CR>'s followed by a single <NL>
lex	//        followed by zero or more <CR>'s.
lex	//    horizontal-space
lex	//        sequence of "<horizontal-space-char>"s
lex	//        <FF>, <VT>, <CR>, and <NL>'s are
lex	//        excluded
le	//    comment
lex	//        "/*" comment (including /* and */)
lex	//        "//" comment (including // but not
lex	//                      ending newline)
lex	//
lex	// This allows line feeds to be used to end pp
lex	// control lines.
lex	//
lex	// Characters that are not part of any C++
lex	// lexeme and universal characters that are not
lex	// part of any C++ lexeme are made into erron-
lex	// eous atoms of the types:
lex	//
lex	//    illegal char
lex	//        A single char
lex	//    illegal universal char
lex	//        A \UXXXXXXXX or \uXXXX sequence
lex	//
lex	// Aside from generating calls to the erroneous
lex	// atom closure, these are treated as if they
lex	// did not exist.
lex
lex	begin initial master table;
cc	    NDL::begin_table ( initial );
cc
lex
lex	    "<whitespace-char>"
lex	        call whitespace;
cc		NDL::begin_dispatch
cc			( whitespace_char );
cc		    NDL::call ( whitespace );
cc		NDL::end_dispatch();
cc
lex
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur INSIDE
lex	    // a pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    "#" output operator goto pp beginning;
lex	    "##" output operator goto normal;
cc		NDL::begin_dispatch ( "#" );
cc		    NDL::begin_dispatch ( "#" );
cc		        NDL::output ( operator_t );
cc		        NDL::go ( normal );
cc		    NDL::end_dispatch();
cc		    NDL::output ( operator_t );
cc		    NDL::go ( pp_beginning );
cc		NDL::end_dispatch();
cc
lex
lex	    "%:" translate to "#" output operator
lex	        goto pp beginning;
lex	    "%:%:" translate to "##" output operator
lex	        goto normal;
cc		NDL::begin_dispatch ( "%" );
cc		  NDL::begin_dispatch ( ":" );
cc		    NDL::begin_dispatch ( "%" );
cc		      NDL::begin_dispatch ( ":" );
cc		        NDL::translate_to ( "##" );
cc		        NDL::output ( operator_t );
cc		        NDL::go ( normal );
cc		      NDL::end_dispatch();
cc		    NDL::end_dispatch();
cc
cc		    NDL::translate_to ( "#" );
cc	            NDL::output ( operator_t );
cc	            NDL::go ( pp_beginning );
cc
cc		  NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    goto normal;
cc		NDL::go ( normal );
cc
lex
lex	end initial master table;
cc	    NDL::end_table();
cc
lex
lex	begin whitespace lexeme table;
cc	    NDL::begin_table ( whitespace );
cc
lex
lex	    "<whitespace-char>" accept;
cc		NDL::begin_dispatch
cc			( whitespace_char );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end whitespace lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin "/*" comment lexeme table;
cc	    NDL::begin_table ( slash_star_comment );
cc
lex
lex	    "*/" return;
lex	    "*" accept;
cc		NDL::begin_dispatch ( "*" );
cc		    NDL::begin_dispatch ( "/" );
cc		        NDL::ret();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    translate_to "*/"
lex	    goto premature end of file;
cc		NDL::translate_to ( "*/" );
cc		NDL::go ( premature_end_of_file );
cc
lex
lex	end "/*" comment lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin "//" comment lexeme table;
cc	    NDL::begin_table ( slash_slash_comment );
cc
lex
lex	    "<NL>" keep 0 return;
cc		NDL::begin_dispatch ( "\n" );
cc		    NDL::keep ( 0 );
cc		    NDL::ret();
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::go ( premature_end_of_file );
cc
lex
lex	end "//" comment lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin premature newline master table;
cc	    NDL::begin_table ( premature_newline );
cc
lex
lex	    output premature newline
lex	    goto initial;
cc		NDL::output ( premature_newline_t );
cc		NDL::go ( initial );
cc
lex
lex	end premature newline master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin premature end of file master table;
cc	    NDL::begin_table ( premature_end_of_file );
cc
lex
lex	    output premature end of file
lex	    goto initial;
cc	        NDL::output ( premature_end_of_file_t );
cc	        NDL::go ( initial );
lex
lex	end premature end of file master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin pp beginning master table;
cc	    NDL::begin_table ( pp_beginning );
cc
lex
lex	    "<whitespace-char>"
lex	        call whitespace;
cc		NDL::begin_dispatch ( whitespace_char );
cc		    NDL::call ( whitespace );
cc		NDL::end_dispatch();
cc
lex
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur inside
lex	    // pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    // "include" identifier must be followed by
lex	    // one of the following for a header to be
lex	    // recognized:
lex	    //     <whitespace-char>
lex	    //     /* comment
lex	    //     <...> header
lex	    //     "..." header
lex	    //
lex	    "include<whitespace-char>"
lex	        keep 7 output identifier
lex	        goto pp include;
lex	    "include/"
lex	        keep 7 output identifier
lex	        goto pp include;
lex	    "include<"
lex	        keep 7 output identifier
lex	        goto pp include;
lex	    "include<Q>"
lex	        keep 7 output identifier
lex	        goto pp include;
cc		NDL::begin_dispatch ( "i" );
cc		NDL::begin_dispatch ( "n" );
cc		NDL::begin_dispatch ( "c" );
cc		NDL::begin_dispatch ( "l" );
cc		NDL::begin_dispatch ( "u" );
cc		NDL::begin_dispatch ( "d" );
cc		NDL::begin_dispatch ( "e" );
cc		    NDL::begin_dispatch
cc			    ( " \t\v\f/<\"" );
cc		        NDL::keep ( 7 );
cc		        NDL::output ( identifier_t );
cc		        NDL::go ( pp_include );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    goto normal;
cc	    NDL::go ( normal );
cc
lex
lex	end pp beginning master table;
cc	    NDL::end_table();
cc
lex
lex	begin pp include master table;
cc	    NDL::begin_table ( pp_include );
cc
lex
lex	    "<whitespace-char>"
lex	        call whitespace;
cc		NDL::begin_dispatch
cc			( whitespace_char );
cc		    NDL::call ( whitespace );
cc		NDL::end_dispatch();
cc
lex
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur inside
lex	    // pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex
lex	    "<" translate to ""
lex	        goto bracketed header name;
cc		NDL::begin_dispatch ( "<" );
cc		    NDL::translate_to ( "" );
cc		    NDL::go ( bracketed_header_name );
cc		NDL::end_dispatch();
cc
lex
lex	    "<Q>" translate to ""
lex	        goto quoted header name;
cc		NDL::begin_dispatch ( "\"" );
cc		    NDL::translate_to ( "" );
cc		    NDL::go ( quoted_header_name );
cc		NDL::end_dispatch();
cc
lex
lex	    goto normal;
cc	        NDL::go ( normal );
cc
lex
lex	end pp include master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin bracketed header name lexeme table;
cc	    NDL::begin_table ( bracketed_header_name );
cc
lex
lex	    ">" translate to "" goto normal;
cc		NDL::begin_dispatch ( ">" );
cc		    NDL::translate_to ( "" );
cc		    NDL::go ( normal );
cc		NDL::end_dispatch();
cc
lex
lex	    "<NL>"
lex	        keep 0 goto premature newline;
cc		NDL::begin_dispatch ( "\n" );
cc		    NDL::keep ( 0 );
cc		    NDL::go ( premature_newline );
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::go ( premature_end_of_file );
cc
lex
lex	end bracketed header name lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	// Quoted header names are not the same as
lex	// quoted strings, and cannot have escape
lex	// sequences.
lex	//
lex	begin quoted header name lexeme table;
cc	    NDL::begin_table ( quoted_header_name );
cc
lex
lex	    "<Q>" translate to "" goto normal;
cc		NDL::begin_dispatch ( "\"" );
cc		    NDL::translate_to ( "" );
cc		    NDL::go ( normal );
cc		NDL::end_dispatch();
cc
lex
lex	    "<NL>"
lex	        keep 0 goto premature newline;
cc		NDL::begin_dispatch ( "\n" );
cc		    NDL::keep ( 0 );
cc		    NDL::go ( premature_newline );
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::go ( premature_end_of_file );
cc
lex
lex	end quoted header name lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin normal master table;
cc	    NDL::begin_table ( normal );
cc
lex
lex	    "<whitespace-char>"
lex	        call whitespace;
cc		NDL::begin_dispatch
cc			( whitespace_char );
cc		    NDL::call ( whitespace );
cc		NDL::end_dispatch();
cc
lex
lex	    "/*" call "/*" comment;
lex	    "//" call "//" comment;
lex	    "/" match operator output operator
lex	        else error misplaced char;
lex	             // error should never happen
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "/" );
cc		        NDL::call
cc	                    ( slash_slash_comment );
cc		    NDL::end_dispatch();
cc
cc		    NDL::match ( operator_atom );
cc		    NDL::output ( operator_t );
cc		NDL::ELSE();
cc		    NDL::erroneous_atom
cc			( misplaced_char_t );
cc		NDL::end_dispatch();
cc
lex
lex	    "<op-char>"
lex	        match operator output operator
lex	        else error misplaced char;
lex	             // error should never happen
cc		NDL::begin_dispatch ( op_char );
cc		        NDL::match ( operator_atom );
cc		        NDL::output ( operator_t );
cc		    NDL::ELSE();
cc		        NDL::erroneous_atom
cc			    ( misplaced_char_t );
cc		NDL::end_dispatch();
cc
lex
lex	    "<identifier-non-literal>"
lex	        output identifier call identifier;
lex	        // Also see "u..." etc. below.
cc		NDL::begin_dispatch
cc			( identifier_non_literal );
cc		    add_non_ascii_letters();
cc		    NDL::output ( identifier_t );
cc		    NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "u'" translate to ""
lex	         output u char literal
lex	         call char literal;
lex	    "u<Q>" translate to ""
lex	           output u string literal
lex	         call string literal;
lex	    "u"  output identifier call identifier;
cc		NDL::begin_dispatch ( "u" );
cc		    NDL::begin_dispatch ( "'" );
cc		        NDL::translate_to ( "" );
cc		        NDL::output
cc			    ( u_char_literal_t );
cc		        NDL::call
cc			    ( char_literal );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "\"" );
cc		        NDL::translate_to ( "" );
cc		        NDL::output
cc			    ( u_string_literal_t );
cc		        NDL::call
cc			    ( string_literal );
cc		    NDL::end_dispatch();
cc
cc		    NDL::output ( identifier_t );
cc		    NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "U'" translate to ""
lex	         output U char literal
lex	         call char literal;
lex	    "U<Q>" translate to ""
lex	           output U string literal
lex	         call string literal;
lex	    "U"  output identifier call identifier;
cc		NDL::begin_dispatch ( "U" );
cc		    NDL::begin_dispatch ( "'" );
cc		        NDL::translate_to ( "" );
cc		        NDL::output
cc			    ( U_char_literal_t );
cc		        NDL::call
cc			    ( char_literal );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "\"" );
cc		        NDL::translate_to ( "" );
cc		        NDL::output
cc			    ( U_string_literal_t );
cc		        NDL::call
cc			    ( string_literal );
cc		    NDL::end_dispatch();
cc
cc		    NDL::output ( identifier_t );
cc		    NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "L'" translate to ""
lex	         output L char literal
lex	         call char literal;
lex	    "L<Q>" translate to ""
lex	           output L string literal
lex	         call string literal;
lex	    "L"  output identifier call identifier;
cc		NDL::begin_dispatch ( "L" );
cc		    NDL::begin_dispatch ( "'" );
cc		        NDL::translate_to ( "" );
cc		        NDL::output
cc			    ( L_char_literal_t );
cc		        NDL::call
cc			    ( char_literal );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "\"" );
cc		        NDL::translate_to ( "" );
cc		        NDL::output
cc			    ( L_string_literal_t );
cc		        NDL::call
cc			    ( string_literal );
cc		    NDL::end_dispatch();
cc
cc		    NDL::output ( identifier_t );
cc		    NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex	    "\<u_U>" match universal char
lex	             require <non-ascii-letter>
lex	             output identifier call identifier
lex	        else match universal char
lex		     require "<ascii-char>"
lex	             output ascii universal char
lex	        else match universal char
lex	             output misplaced universal char
lex	        else match short universal char
lex	             output universal char
lex		     // This should always succeed.
lex	    "\" output misplaced char
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::begin_dispatch ( u_U );
cc		        NDL::match ( universal_char );
cc		        NDL::require
cc			     ( non_ascii_letter );
cc		        NDL::output ( identifier_t );
cc		        NDL::call ( identifier );
cc		    NDL::ELSE();
cc		        NDL::match ( universal_char );
cc		        NDL::require
cc			     ( ascii_char );
cc		        NDL::output
cc			    ( ascii_universal_char_t );
cc		    NDL::ELSE();
cc		        NDL::match ( universal_char );
cc		        NDL::output
cc			 ( misplaced_universal_char_t );
cc		    NDL::ELSE();
cc		        NDL::match
cc			    ( short_universal_char );
cc		        NDL::output
cc			    ( short_universal_char_t );
cc		    NDL::end_dispatch();
cc
cc		    NDL::output ( misplaced_char_t );
cc		NDL::end_dispatch();
cc
lex
lex	    "<non-zero-digit>" call decimal integer;
cc		NDL::begin_dispatch ( non_zero_digit );
cc		    NDL::call ( decimal_integer );
cc		NDL::end_dispatch();
cc
lex
lex	    "0x" call hexadecimal integer;
lex	    "0X" call hexadecimal integer;
lex	    "0" call octal integer;
cc		NDL::begin_dispatch ( "0" );
cc		    NDL::begin_dispatch ( "xX" );
cc		        NDL::call
cc			    ( hexadecimal_integer );
cc		    NDL::end_dispatch();
cc		    NDL::call ( octal_integer );
cc		NDL::end_dispatch();
cc
lex
lex	    ".<digit>" call fraction;
lex	    "." match operator output operator
lex	        else error misplaced char;
cc		NDL::begin_dispatch ( "." );
cc		    NDL::begin_dispatch ( digit );
cc		        NDL::call ( fraction );
cc		    NDL::end_dispatch();
cc		    NDL::match ( operator_atom );
cc		    NDL::output ( operator_t );
cc		NDL::ELSE();
cc		    NDL::erroneous_atom
cc			    ( misplaced_char_t );
cc		NDL::end_dispatch();
cc
lex
lex	    "'" translate to ""
lex		output char literal
lex	        call char literal;
cc		NDL::begin_dispatch ( "'" );
cc		    NDL::translate_to ( "" );
cc		    NDL::output ( char_literal_t );
cc		    NDL::call ( char_literal );
cc		NDL::end_dispatch();
cc
lex
lex	    "<Q>" translate to ""
lex		  output string literal
lex	          call string literal;
cc		NDL::begin_dispatch ( "'" );
cc		    NDL::translate_to ( "" );
cc		    NDL::output ( string_literal_t );
cc		    NDL::call ( string_literal );
cc		NDL::end_dispatch();
cc
lex
lex	    "<NL>" output newline;
cc		NDL::begin_dispatch ( "\n" );
cc		    NDL::output ( newline_t );
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" error misplaced char;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::erroneous_atom
cc			( misplaced_char_t );
cc		NDL::end_dispatch();
cc
lex
lex	    output end of file;
cc		NDL::output ( end_of_file_t );
cc
lex
lex	end normal master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin operator atom table;
cc	    NDL::begin_table ( operator_atom );
cc
lex
lex	    "("; ")"; "["; "]"; "{"; "}"; ";"; ","; "?";
lex	    "~";
cc		NDL::begin_dispatch ( "()[]{};,?~" );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "#";
lex	    "##";
cc		NDL::begin_dispatch ( "#" );
cc		    NDL::begin_dispatch ( "#" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<:" translate to "[";
lex	    "<%"; translate to "{";
lex	    "<<="; "<<"; "<";
cc		NDL::begin_dispatch ( "<" );
cc		    NDL::begin_dispatch ( ":" );
cc		        NDL::translate_to ( "[" );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "%" );
cc		        NDL::translate_to ( "{" );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "<" );
cc		        NDL::begin_dispatch ( "=" );
cc		            NDL::accept();
cc		        NDL::end_dispatch();
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    ">>="; ">>"; ">";
cc		NDL::begin_dispatch ( ">" );
cc		    NDL::begin_dispatch ( ">" );
cc		        NDL::begin_dispatch ( "=" );
cc		            NDL::accept();
cc		        NDL::end_dispatch();
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    ":>" translate to "]";
lex	    "::"; ":";
cc		NDL::begin_dispatch ( ":" );
cc		    NDL::begin_dispatch ( ">" );
cc		        NDL::translate_to ( "]" );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( ":" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "%:%:" translate to "##";
lex	    "%>" translate to "}";
lex	    "%:" translate to "#";
lex	    "%="; "%";
cc		NDL::begin_dispatch ( "%" );
cc		    NDL::begin_dispatch ( ">" );
cc		        NDL::translate_to ( "}" );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( ":" );
cc		        NDL::begin_dispatch ( "%" );
cc		            NDL::begin_dispatch ( ":" );
cc		                NDL::translate_to
cc				    ( "##" );
cc		            NDL::end_dispatch();
cc		        NDL::end_dispatch();
cc		        NDL::translate_to ( "#" );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "=" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "..."; ".*"; ".";
cc		NDL::begin_dispatch ( "." );
cc		    NDL::begin_dispatch ( "." );
cc		        NDL::begin_dispatch ( "." );
cc		            NDL::accept();
cc		        NDL::end_dispatch();
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "++"; "+="; "+";
cc		NDL::begin_dispatch ( "+" );
cc		    NDL::begin_dispatch ( "+=" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "->*"; "->"; "--"; "-="; "-";
cc		NDL::begin_dispatch ( "-" );
cc		    NDL::begin_dispatch ( ">" );
cc		        NDL::begin_dispatch ( "*" );
cc		            NDL::accept();
cc		        NDL::end_dispatch();
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "=-" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "*="; "*";
lex	    "/="; "/";
lex	    "^="; "^";
lex	    "!="; "!";
lex	    "=="; "=";
cc		NDL::begin_dispatch ( "*/^!=" );
cc		    NDL::begin_dispatch ( "=" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "&&"; "&="; "&";
cc		NDL::begin_dispatch ( "&" );
cc		    NDL::begin_dispatch ( "&=" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "||"; "|="; "|";
cc		NDL::begin_dispatch ( "|" );
cc		    NDL::begin_dispatch ( "|=" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    fail;
cc		NDL::fail();
cc
lex
lex	end operator atom table;
cc	    NDL::end_table();
cc
lex
lex	begin identifier lexeme table;
cc	    NDL::begin_table ( identifier );
cc
lex
lex	    "<identifier-non-digit>" accept;
lex	    "<digit>" accept;
cc		NDL::begin_dispatch
cc		        ( identifier_non_digit );
cc		    add_non_ascii_letters();
cc	    	    NDL::add_characters ( digit );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "\<u_U>" match universal char
lex	             require
lex	                 "<non-ascii-identifier-char>"
lex	        else keep 0 return
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::begin_dispatch ( u_U );
cc		        NDL::match ( universal_char );
cc		        NDL::require
cc			  ( non_ascii_identifier_char );
cc		    NDL::ELSE();
cc		        NDL::keep ( 0 );
cc		        NDL::ret();
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end identifier lexeme table;
cc	    NDL::end_table();
cc
lex
lex	"<e_E> = "e" | "E";
lex	"<identifier-non-digit-except-eE>" =
lex	    "<identifier-non-digit>" & ~ "<e_E>";
cc	    const char * e_E = "eE";
cc	    const char * id_non_digit_except_eE
cc		= "_"
cc	          "abcdfghijklmnopqrstuvwxyz"
cc	          "ABCDFGHIJKLMNOPQRSTUVWXYZ";
cc		  // Must use add_non_ascii_letters.
cc
lex
lex
lex	begin decimal integer sublexeme table;
cc	    NDL::begin_table ( decimal_integer );
cc
lex
lex	    "<digit>" accept;
cc		NDL::begin_dispatch ( digit );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "." goto fraction;
cc		NDL::begin_dispatch ( digit );
cc		    NDL::go ( fraction );
cc		NDL::end_dispatch();
cc
lex
lex	    "<e_E><sign><digit>" goto exponent;
lex	    "<e_E><sign>" goto pp number;
lex	    "<e_E><digit>" goto exponent;
lex	    "<identifier-non-digit>" goto identifier;
cc		NDL::begin_dispatch ( e_E );
cc		    NDL::begin_dispatch ( sign );
cc		        NDL::begin_dispatch ( digit );
cc		            NDL::go ( exponent );
cc		        NDL::end_dispatch();
cc		        NDL::go ( pp_number );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( digit );
cc		        NDL::go ( exponent );
cc		    NDL::end_dispatch();
cc		    NDL::go ( identifier );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch
cc		        ( id_non_digit_except_eE );
cc		    add_non_ascii_letters();
cc		    NDL::go ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "\"      match universal char
lex	             require "<non-ascii-letter>"
lex	             goto identifier
lex	        else keep 0 return
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::match ( universal_char );
cc		    NDL::require
cc			( non_ascii_letter );
cc		    NDL::go ( identifier );
cc		NDL::ELSE();
cc		    NDL::keep ( 0 );
cc		    NDL::ret();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc	        NDL::ret();
cc
lex
lex	end decimal integer sublexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin octal integer sublexeme table;
cc	    NDL::begin_table ( octal_integer );
cc
lex
lex	    "<oct-digit>" accept;
cc		NDL::begin_dispatch ( oct_digit );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "8" goto float integer;
lex	    "9" goto float integer;
cc		NDL::begin_dispatch ( "89" );
cc		    NDL::go ( float_integer );
cc		NDL::end_dispatch();
cc
lex
lex	    "." goto fraction;
cc		NDL::begin_dispatch ( digit );
cc		    NDL::go ( fraction );
cc		NDL::end_dispatch();
cc
lex
lex	    "<e_E><sign><digit>" goto exponent;
lex	    "<e_E><sign>" goto pp number;
lex	    "<e_E><digit>" goto exponent;
lex	    "<identifier-non-digit>" goto identifier;
cc		NDL::begin_dispatch ( e_E );
cc		    NDL::begin_dispatch ( sign );
cc		        NDL::begin_dispatch ( digit );
cc		            NDL::go ( exponent );
cc		        NDL::end_dispatch();
cc		        NDL::go ( pp_number );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( digit );
cc		        NDL::go ( exponent );
cc		    NDL::end_dispatch();
cc		    NDL::go ( identifier );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch
cc		        ( id_non_digit_except_eE );
cc		    add_non_ascii_letters();
cc		    NDL::go ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "\"      match universal char
lex	             require "<non-ascii-letter>"
lex	             goto identifier
lex	        else keep 0 return
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::match ( universal_char );
cc		    NDL::require
cc			( non_ascii_letter );
cc		    NDL::go ( identifier );
cc		NDL::ELSE();
cc		    NDL::keep ( 0 );
cc		    NDL::ret();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc	        NDL::ret();
cc
lex
lex	end octal integer sublexeme table;
cc	    NDL::end_table();
cc
lex
lex	"<identifier-non-hex-digit>" =
lex	    "<identifier-non-digit>" & ~ "<hex-digit>";
cc	    const char * id_non_hex_digit
cc		= "_"
cc	          "ghijklmnopqrstuvwxyz"
cc	          "GHIJKLMNOPQRSTUVWXYZ";
cc		  // Must use add_non_ascii_letters.
cc
lex
lex
lex	begin hexadecimal integer sublexeme table;
cc	    NDL::begin_table ( hexadecimal_integer );
cc
lex
lex	    "<hex-digit>" accept;
cc		NDL::begin_dispatch ( hex_digit );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "<identifier-non-hex-digit>" goto identifier;
cc		NDL::begin_dispatch
cc		        ( id_non_hex_digit );
cc		    add_non_ascii_letters();
cc		    NDL::go ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "\"      match universal char
lex	             require "<non-ascii-letter>"
lex	             goto identifier
lex	        else keep 0 return
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::match ( universal_char );
cc		    NDL::require
cc			( non_ascii_letter );
cc		    NDL::go ( identifier );
cc		NDL::ELSE();
cc		    NDL::keep ( 0 );
cc		    NDL::ret();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc	        NDL::ret();
cc
lex
lex	end hexadecimal integer sublexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex     // Same as decimal integer sublexeme table
lex	// but integer began with 0 and then included
lex	// a non-octal digit.
lex	//
lex	begin float integer sublexeme table;
cc	    NDL::begin_table ( float_integer );
cc
lex
lex	    "<digit>" accept;
cc		NDL::begin_dispatch ( digit );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "." goto fraction;
cc		NDL::begin_dispatch ( digit );
cc		    NDL::go ( fraction );
cc		NDL::end_dispatch();
cc
lex
lex	    "<e_E><sign><digit>" goto exponent;
lex	    "<e_E><sign>" goto pp number;
lex	    "<e_E><digit>" goto exponent;
lex	    "<identifier-non-digit>" goto identifier;
cc		NDL::begin_dispatch ( e_E );
cc		    NDL::begin_dispatch ( sign );
cc		        NDL::begin_dispatch ( digit );
cc		            NDL::go ( exponent );
cc		        NDL::end_dispatch();
cc		        NDL::go ( pp_number );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( digit );
cc		        NDL::go ( exponent );
cc		    NDL::end_dispatch();
cc		    NDL::go ( identifier );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch
cc		        ( id_non_digit_except_eE );
cc		    add_non_ascii_letters();
cc		    NDL::go ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "\"      match universal char
lex	             require "<non-ascii-letter>"
lex	             goto identifier
lex	        else keep 0 goto pp number
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::match ( universal_char );
cc		    NDL::require
cc			( non_ascii_letter );
cc		    NDL::go ( identifier );
cc		NDL::ELSE();
cc		    NDL::keep ( 0 );
cc		    NDL::go ( pp_number );
cc		NDL::end_dispatch();
cc
lex
lex	    goto pp number;
cc	        NDL::go ( pp_number );
cc
lex
lex	end float integer sublexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	// Come here to process suffix at end of integer
lex	// or float lexeme.
lex	//
lex	begin suffix sublexeme table;
cc	    NDL::begin_table ( pp_number );
cc
lex
lex	    "<identifier-non-digit-except-eE>" accept;
lex	    "<digit>" accept;
cc		NDL::begin_dispatch
cc		    ( id_non_digit_except_eE );
cc		    add_non_ascii_letters();
cc	    	    NDL::add_characters ( digit );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<e_E><sign>" goto pp number;
lex	    "<e_E>" accept;
cc		NDL::begin_dispatch ( e_E );
cc		    NDL::begin_dispatch ( sign );
cc			NDL::go ( pp_number );
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "." goto pp number;
cc		NDL::begin_dispatch ( "." );
cc		    NDL::go ( pp_number );
cc		NDL::end_dispatch();
cc
lex
lex	    "\<u_U>" match escaped char
lex	             require
lex	                 "<non-ascii-identifier-char>"
lex	             else keep 0 return;
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::begin_dispatch ( u_U );
cc		        NDL::match ( escaped_char );
cc		        NDL::require
cc		          ( non_ascii_identifier_char );
cc	 	    NDL::ELSE();
cc			NDL::keep ( 0 );
cc			NDL::ret();
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end suffix sublexeme table;
cc	    NDL::end_table();
cc
lex
lex	begin pp number lexeme table;
cc	    NDL::begin_table ( pp_number );
cc
lex
lex	    "<identifier-non-digit-except-eE>" accept;
lex	    "<digit>" accept;
cc		NDL::begin_dispatch
cc		    ( id_non_digit_except_eE );
cc		    add_non_ascii_letters();
cc	    	    NDL::add_characters ( digit );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<e_E><sign>" accept;
lex	    "<e_E>" accept;
cc		NDL::begin_dispatch ( e_E );
cc		    NDL::begin_dispatch ( sign );
cc			NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "." accept;
cc		NDL::begin_dispatch ( "." );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "\<u_U>" match escaped char
lex	             require
lex	                 "<non-ascii-identifier-char>"
lex	             else keep 0 return;
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::begin_dispatch ( u_U );
cc		        NDL::match ( escaped_char );
cc		        NDL::require
cc		          ( non_ascii_identifier_char );
cc	 	    NDL::ELSE();
cc			NDL::keep ( 0 );
cc			NDL::ret();
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end pp number lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin fraction lexeme table;
cc	    NDL::begin_table ( fraction );
cc
lex
lex	    "<digit>" accept;
cc		NDL::begin_dispatch ( digit );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "." goto pp number;
cc		NDL::begin_dispatch ( "." );
cc		    NDL::go ( pp_number );
cc		NDL::end_dispatch();
cc
lex
lex	    "<e_E><sign><digit>" goto exponent;
lex	    "<e_E><digit>" goto exponent;
lex	    "<e_E><sign>" goto pp number;
lex	    "<identifier-non-digit>" goto suffix;
cc		NDL::begin_dispatch ( e_E );
cc		    NDL::begin_dispatch ( sign );
cc		        NDL::begin_dispatch ( digit );
cc		            NDL::go ( exponent );
cc		        NDL::end_dispatch();
cc		        NDL::go ( pp_number );
cc		    NDL::end_dispatch();
cc
cc		    NDL::begin_dispatch ( digit );
cc		        NDL::go ( exponent );
cc		    NDL::end_dispatch();
cc
cc		    NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch
cc		        ( id_non_digit_except_eE );
cc		    add_non_ascii_letters();
cc		    NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
lex
lex	    "\<u_U>" match escaped char
lex	             require "<non-ascii-letter>"
lex	             goto suffix
lex	             else keep 0 return;
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::begin_dispatch ( u_U );
cc		        NDL::match ( escaped_char );
cc		        NDL::require
cc			    ( non_ascii_letter );
cc		        NDL::go ( suffix );
cc		    NDL::ELSE();
cc			NDL::keep ( 0 );
cc			NDL::ret();
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end fraction lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin exponent lexeme table;
cc	    NDL::begin_table ( exponent );
cc
lex
lex	    "<digit>" accept;
cc		NDL::begin_dispatch ( digit );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "." goto pp number;
cc		NDL::begin_dispatch ( "." );
cc		    NDL::go ( pp_number );
cc		NDL::end_dispatch();
cc
lex
lex	    "<identifier-non-digit>"
lex	        keep 0 goto suffix;
cc		NDL::begin_dispatch
cc		        ( identifier_non_digit );
cc		    add_non_ascii_letters();
cc		    NDL::keep ( 0 );
cc		    NDL::go ( suffix );
cc		NDL::end_dispatch();
cc
lex
lex	    "\<u_U>" match escaped char
lex	             require "<non-ascii-letter>"
lex	             goto suffix
lex	             else keep 0 return;
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::begin_dispatch ( u_U );
cc		            NDL::match
cc			        ( escaped_char );
cc		            NDL::require
cc			        ( non_ascii_letter );
cc		            NDL::go ( suffix );
cc			NDL::ELSE();
cc			    NDL::keep ( 0 );
cc			    NDL::ret();
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end exponent lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin char literal sublexeme table;
cc	    NDL::begin_table ( char_literal );
cc
lex
lex	    "'" translate to "" return;
cc		NDL::begin_dispatch ( "'" );
cc		    NDL::translate_to ( "" );
cc		    NDL::ret();
cc		NDL::end_dispatch();
cc
lex
lex	    "<NL>" keep 0 goto premature newline
cc		NDL::begin_dispatch ( "\n" );
cc		    NDL::keep ( 0 );
cc		    NDL::go ( premature_newline );
cc		NDL::end_dispatch();
cc
lex
lex	    "\" match escaped char
lex		// match should always succeed
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::match ( escaped_char );
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file
cc	        NDL::go ( premature_end_of_file );
cc
lex
lex	end char literal sublexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin string literal sublexeme table;
cc	    NDL::begin_table ( string_literal );
cc
lex
lex	    "<Q>" translate to "" return;
cc		NDL::begin_dispatch ( "\"" );
cc		    NDL::translate_to ( "" );
cc		    NDL::ret();
cc		NDL::end_dispatch();
cc
lex
lex	    "<NL>" keep 0 goto premature newline
cc		NDL::begin_dispatch ( "\n" );
cc		    NDL::keep ( 0 );
cc		    NDL::go ( premature_newline );
cc		NDL::end_dispatch();
cc
lex
lex	    "\" match escaped char
lex		// match should always succeed
cc		NDL::begin_dispatch ( "\\" );
cc		        NDL::match
cc			    ( escaped_char );
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file
cc	        NDL::go ( premature_end_of_file );
cc
lex
lex	end string literal sublexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	// This atom table is used when the next atom
lex	// begins with \ and is in a character or string
lex	// literal.  This atom table always succeeds,
lex	// but may produce an erroneous atom with ""
lex	// translation.
lex	//
lex	// We allow only a maximum of 8 hexadecimal
lex	// digits after \x; 9 digits is an error.  The
lex	// C++ standard permits any number of hexa-
lex	// decimal digits.
lex	//
lex	begin escaped char atom table;
cc	    NDL::begin_table ( escaped_char );
cc	    // All table entries begin with \.
cc	    NDL::begin_dispatch ( "\\" );
cc
lex
lex	    "\n" translate to "<NL>";
cc	        NDL::begin_dispatch ( "n" );
cc		    NDL::translate_to ( "\n" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\t" translate to "<HT>";
cc	        NDL::begin_dispatch ( "t" );
cc		    NDL::translate_to ( "\t" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\v" translate to "<VT>";
cc	        NDL::begin_dispatch ( "v" );
cc		    NDL::translate_to ( "\v" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\b" translate to "<BS>";
cc	        NDL::begin_dispatch ( "b" );
cc		    NDL::translate_to ( "\b" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\r" translate to "<CR>";
cc	        NDL::begin_dispatch ( "r" );
cc		    NDL::translate_to ( "\r" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\f" translate to "<FF>";
cc	        NDL::begin_dispatch ( "f" );
cc		    NDL::translate_to ( "\f" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\a" translate to "<BEL>";
cc	        NDL::begin_dispatch ( "a" );
cc		    NDL::translate_to ( "\a" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\\" translate to "\";
cc	        NDL::begin_dispatch ( "\\" );
cc		    NDL::translate_to ( "\\" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\?" translate to "?";
cc	        NDL::begin_dispatch ( "?" );
cc		    NDL::translate_to ( "?" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\<Q>" translate to "<Q>";
cc	        NDL::begin_dispatch ( "\"" );
cc		    NDL::translate_to ( "\"" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\'" translate to "'";
cc	        NDL::begin_dispatch ( "'" );
cc		    NDL::translate_to ( "'" );
cc		NDL::end_dispatch();
cc
lex
lex	    "\<oct-digit><oct-digit><oct-digit>"
lex	        translate oct 1 0;
lex	    "\<oct-digit><oct-digit>"
lex	        translate oct 1 0;
lex	    "\<oct-digit>"
lex	        translate oct 1 0;
cc	        NDL::begin_dispatch ( oct_digit );
cc	            NDL::begin_dispatch ( oct_digit );
cc	                NDL::begin_dispatch
cc			        ( oct_digit );
cc		            NDL::translate_oct ( 1, 1 );
cc		        NDL::end_dispatch();
cc		        NDL::translate_oct ( 1, 1 );
cc		    NDL::end_dispatch();
cc		    NDL::translate_oct ( 1, 1 );
cc		NDL::end_dispatch();
cc
lex
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        error too long hex escape
lex		translate to "";
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x" error ill formed escape
lex		translate to "";
cc
cc	#	define HEX NDL::begin_dispatch \
cc		                   ( hex_digit )
cc	#	define END NDL::translate_hex \
cc			           ( 2, 0 ); \
cc	                   NDL::end_dispatch()
cc
cc		NDL::begin_dispatch ( "x" );
cc		    HEX;HEX;HEX;HEX;HEX;HEX;HEX;HEX;
cc			NDL::begin_dispatch
cc			    ( hex_digit );
cc			    NDL::erroneous_atom
cc			      ( too_long_hex_escape_t );
cc			    NDL::translate_to ( "" );
cc			NDL::end_dispatch();
cc		    END;END;END;END;END;END;END;END;
cc		NDL::end_dispatch();
cc
cc	#	undef HEX
cc	#	undef END
cc
lex
lex	    "\<u_U>" match universal char
lex		 else match short universal char
lex		      error short universal char
lex		      translate to "";
lex		      // This should always succeed
cc	    NDL::begin_dispatch ( u_U );
cc	        NDL::match ( universal_char );
cc	    NDL::ELSE();
cc	        NDL::match ( short_universal_char );
cc	        NDL::erroneous_atom
cc		    ( short_universal_char );
cc		NDL::translate_to ( "" );
cc	    NDL::end_dispatch();
cc
lex	"\<NL>" keep 1
lex	        error ill formed escape
lex	        translate to "";
cc	        NDL::begin_dispatch ( "\n" );
cc	            NDL::keep ( 1 );
cc	            NDL::erroneous_atom
cc		        ( ill_formed_escape_t );
cc		    NDL::translate_to ( "" );
cc	        NDL::end_dispatch();
cc
lex	"\<other>" error ill formed escape
lex	           translate to "";
cc	        NDL::begin_dispatch ( OTHER );
cc	            NDL::erroneous_atom
cc		        ( ill_formed_escape_t );
cc		    NDL::translate_to ( "" );
cc	        NDL::end_dispatch();
cc
cc
lex	"\" error ill formed escape
lex	    translate to "";
lex	    // In case \ followed by end of file
cc	        NDL::erroneous_atom
cc		    ( ill_formed_escape_t );
cc		NDL::translate_to ( "" );
cc
cc	    // End of \ dispatch
cc	    //
cc	    NDL::end_dispatch();
cc
lex
lex	// This table should always succeed.
lex
lex	end escaped char atom table;
cc	    NDL::end_table();
cc
lex
lex
lex	// This atom table is called when the next
lex	// atom begins with \U or \u.  If the atom
lex	// has the correct number of hexadecimal
lex	// digits after the \U or \u, it is recognized
lex	// and translated.
lex	//
lex	begin universal char atom table;
cc	    NDL::begin_table ( universal_char );
cc
cc	    // All table entries begin with \.
cc	    NDL::begin_dispatch ( "\\" );
cc
cc	#	define HEX NDL::begin_dispatch \
cc		                   ( hex_digit )
cc	#	define TRANS  NDL::translate_hex \
cc			           ( 2, 0 )
cc	#	define END    NDL::end_dispatch()
cc
lex
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
cc		NDL::begin_dispatch ( "u" );
cc		    HEX;HEX;HEX;HEX;HEX;HEX;HEX;HEX;
cc		    TRANS;
cc		    END;END;END;END;END;END;END;END;
cc		NDL::end_dispatch();
cc
lex
lex	    "\u<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
cc		NDL::begin_dispatch ( "u" );
cc		    HEX;HEX;HEX;HEX;
cc		    TRANS;
cc		    END;END;END;END;
cc		NDL::end_dispatch();
cc
cc	#	undef HEX
cc	#	undef TRANS
cc	#	undef END
cc
cc	    // End \ dispatch.
cc	    NDL::end_dispatch();
cc
lex
lex	    fail;
cc	        NDL::fail();
cc
lex
lex	end universal char atom table;
cc	    NDL::end_table();
cc
lex
lex
lex	// This atom table is called when the next
lex	// atom begins with \U or \u but there are too
lex	// few hexadecimal digits following.  An atom
lex	// is always recognized but is NOT translated.
lex	//
lex	begin short universal char atom table;
cc	    NDL::begin_table ( short_universal_char );
cc
cc	    // All table entries begin with \.
cc	    NDL::begin_dispatch ( "\\" );
cc
cc	#	define HEX NDL::begin_dispatch \
cc		                   ( hex_digit )
cc	#	define END    NDL::accept(); \
cc			      NDL::end_dispatch()
cc
lex
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>";
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>";
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>";
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>";
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit>";
lex	    "\U<hex-digit><hex-digit>";
lex	    "\U<hex-digit>";
lex	    "\U";
cc		NDL::begin_dispatch ( "u" );
cc		    HEX;HEX;HEX;HEX;HEX;HEX;HEX;
cc		    END;END;END;END;END;END;END;
cc		NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "\u<hex-digit><hex-digit>"
lex	      "<hex-digit>";
lex	    "\u<hex-digit><hex-digit>";
lex	    "\u<hex-digit>";
lex	    "\u";
cc		NDL::begin_dispatch ( "u" );
cc		    HEX;HEX;HEX;
cc		    END;END;END;
cc		NDL::accept();
cc		NDL::end_dispatch();
cc
cc	#	undef HEX
cc	#	undef END
cc
cc	    // End \ dispatch.
cc	    NDL::end_dispatch();
cc
lex	    // The above should always succeed.
lex
lex	end short universal char atom table;
cc	    NDL::end_table();
cc
lex
lex
lex	end c++ lexical program;
cc	    NDL::end_program();
cc
cc	    LEXCPP::default_program =
cc		LEX::default_program;
cc	}
