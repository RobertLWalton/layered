// Layers Language C++ Lexical Analyzer
//
// File:	ll_lexeme_c++.lexcc
// Author:	Bob Walton (walton@acm.org)
// Date:	Wed Jun  1 15:42:15 EDT 2011
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.

// Lines beginning with `lex<HT>' and lines equal to
// `lex' are copied to ll_lexeme_c++.lex and then
// to the C++ Lexical Program appendix of ../doc/
// layered-introduction.tex.
//
// Lines beginning with `cc<HT>' and lines equal to `cc'
// are copied to ll_lexeme_c++.cc and compiled to
// produce code that can create a C++ lexical
// program.

// Table of Contents
//
//	Usage and Setup
//	Program Construction

// Usage and Setup
// ----- --- -----

cc	// This file was automatically generated from
cc	// ll_lexeme_c++.lexcc.
cc
lex	// This file was automatically generated from
lex	// ll_lexeme_c++.lexcc.
lex
cc	# include <ll_lexeme_ndl.h>
cc	# include <ll_lexeme_c++.h>
cc	using namespace ll::lexeme::ndl;
cc	# define LEX ll::lexeme
cc	# define LEXCPP ll::lexeme::cpp
cc	using namespace LEXCPP;
cc

// Program Construction
// ------- ------------

cc	min::locatable_var<LEX::program>
cc	    LEXCPP::default_program;
cc
cc	const char * const
cc		LEXCPP::type_name[MAX_TYPE+1] = {
cc
cc	    NULL,
cc	    "HORIZONTAL_SPACE",
cc	    "COMMENT",
cc	    "BRACKETED_HEADER_NAME",
cc	    "QUOTED_HEADER_NAME",
cc	    "OPERATOR",
cc	    "IDENTIFIER",
cc	    "INTEGER",
cc	    "FLOAT",
cc	    "NUMBER",
cc	    "CHARACTER_LITERAL",
cc	    "u_CHARACTER_LITERAL",
cc	    "U_CHARACTER_LITERAL",
cc	    "L_CHARACTER_LITERAL",
cc	    "STRING_LITERAL",
cc	    "u_STRING_LITERAL",
cc	    "U_STRING_LITERAL",
cc	    "L_STRING_LITERAL",
cc	    "NEW_LINE",
cc	    "END_OF_FILE",
cc	    "PREMATURE_NEW_LINE",
cc	    "PREMATURE_END_OF_FILE",
cc	    "ILLEGAL_CHARACTER",
cc	    "ILLEGAL_UNIVERSAL_CHARACTER",
cc	    "ILLEGAL_VERTICAL_SPACE" };
cc
cc	const char * LEXCPP::type_code =
cc	    "Xh/BQoIifnccccssssleNECUV";
cc
cc	static struct char_range { uns32 min, max; }
cc	    non_ascii_letters[] =
cc	{
cc		// { min,		max },
cc	#include <ll_lexeme_non_ascii_letters.h>
cc		   { 0,                0 }
cc	};
cc
cc	static void add_non_ascii_letters ( void )
cc	{
cc	    for ( char_range *p = non_ascii_letters;
cc		  p->min || p->max != 0; ++ p )
cc		NDL::add_characters ( p->min, p->max );
cc	}
cc
cc	void LEXCPP::init_cpp_program ( void )
cc	{
cc	    if ( LEXCPP::default_program != NULL_STUB )
cc	        return;
cc

lex	begin standard lexical program;
lex
cc	    begin_program ( type_name, MAX_TYPE );
cc
cc	    uns32 xtype = MAX_TYPE + 1;
cc	    uns32 slash_slash_comment_t = xtype ++;
cc	    uns32 slash_star_comment_t = xtype ++;
cc	    uns32 done_integer_t = xtype ++;
cc	    uns32 fraction_t = xtype ++;
cc	    uns32 exponent_t = xtype ++;
cc
cc	    uns32 horizontal_space;
cc	    NDL::new_table
cc		( horizontal_space,
cc		  horizontal_space_t );
cc	    uns32 newline;
cc	    NDL::new_table
cc		( newline, newline_t );
cc	    uns32 newline_finish;
cc	    NDL::new_table
cc		( newline_finish, newline_t );
cc
cc	    uns32 slash_star_comment;
cc	    NDL::new_table ( slash_star_comment,
cc	                     slash_star_comment_t );
cc	    uns32 slash_slash_comment;
cc	    NDL::new_table ( slash_slash_comment,
cc	                     slash_slash_comment_t );
cc
cc	    uns32 bracketed_header_name;
cc	    NDL::new_table ( bracketed_header_name,
cc	                     bracketed_header_name_t );
cc	    uns32 quoted_header_name;
cc	    NDL::new_table ( quoted_header_name,
cc	                     quoted_header_name_t );
cc
cc	    uns32 identifier;
cc	    NDL::new_table ( identifier, identifier_t );
cc
cc	    uns32 integer;
cc	    NDL::new_table ( integer, integer_t );
cc	    uns32 done_integer;
cc	    NDL::new_table ( done_integer,
cc	                     done_integer_t );
cc	    uns32 fraction;
cc	    NDL::new_table ( fraction, fraction_t );
cc	    uns32 exponent;
cc	    NDL::new_table ( exponent, exponent_t );
cc
cc	    uns32 character_literal;
cc	    NDL::new_table ( character_literal,
cc	                     character_literal_t );
cc	    uns32 string_literal;
cc	    NDL::new_table ( string_literal,
cc	                     string_literal_t );
cc
cc	    uns32 initial;
cc	    NDL::new_table ( initial, MASTER );
cc	    uns32 pp_beginning;
cc	    NDL::new_table ( pp_beginning, MASTER );
cc	    uns32 pp_include;
cc	    NDL::new_table ( pp_include, MASTER );
cc	    uns32 normal;
cc	    NDL::new_table ( normal, MASTER );
cc	    uns32 premature_newline;
cc	    NDL::new_table ( premature_newline,
cc	                     MASTER );
cc	    uns32 premature_end_of_file;
cc	    NDL::new_table ( premature_end_of_file,
cc	                     MASTER );
cc
cc	    uns32 operator;
cc	    NDL::new_table ( operator, ATOM );
cc	    uns32 universal_char;
cc	    NDL::new_table ( universal_char, ATOM );
cc
cc	    // Abbreviations:
cc
cc	    uns32 ill_universal_char_t =
cc		illegal_universal_character_t;
lex
lex
lex	begin c++ lexical program;
lex
lex	// Before this lexical program is used the input
lex	// should be preprocessed to
lex	//
lex	//    (1) Replace trigraph sequences.
lex	//    (2) Eliminate carriage returns next to
lex	//        newlines.
lex	//    (3) Eliminate backslash newline pairs.
lex	//
lex	// After this lexical program is used the output
lex	// should be post-processed to
lex	//
lex	//    (4) Perform C/C++ macro preprocessing
lex	//        (macro expansion).
lex	//    (5) Delete space and newlines.
lex	//    (6) Concatenate adjacent quoted strings
lex	//        of the same character type (ordinary,
lex	//	  u, U, or L).
lex
lex	"<digit>" = "0-9";
cc	    const char * digit = "0123456789";
lex	"<oct-digit>" = "0-7";
cc	    const char * oct_digit = "01234567";
lex	"<hex-digit>" = "0-9" | "a-f" | "A-F";
cc	    const char * hex_digit =
cc	        "0123456789ABCDEFabcdef";
lex
lex	"<ascii-letter>" = "a-z" | "A-Z";
cc	    const char * ascii_letter =
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
cc
lex	"<letter>" = "<ascii-letter>"
lex	           | "<non-ascii-letter>
lex
lex	// <non-ascii-letter> ::= UNICODE character in
lex	// one of the code ranges designated in
lex	// ../include/ll_lexeme_non_ascii_letters.h
lex	//
lex	// Universal characters are only permitted in
lex	// identifiers, character literals, and string
lex	// literals.  In identifiers they must represent
lex	// non-ASCII-letters.
lex
cc	    uns32 non_ascii_letter;
cc	    NDL::begin_atom_pattern
cc		    ( non_ascii_letter );
cc		add_non_ascii_letters();
cc	    NDL::end_atom_pattern();
cc
lex	"<identifier-non-digit>" = "_" | "<letter>";
cc	    const char * identifier_non_digit =
cc	        "_"
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
cc		// Must also use add_non_ascii_letters.
cc
lex
lex	// Because `u', `U', or `L' can start a char-
lex	// acter or string literal, we must define:
lex	//
lex	"<u_U_L>" = "u" | "U" | "L";
lex	"<identifier-non-literal>" =
lex	          "<identifier-non-digit>"
lex             & ~ "<u_U_L>";
cc	    const char * u_U_L = "uUL";
cc	    const char * identifier_non_literal =
cc	        "_"
cc	        "abcdefghijklmnopqrstvwxyz"
cc	        "ABCDEFGHIJKMNOPQRSTVWXYZ";
cc		// Must also use add_non_ascii_letters.
cc
lex
lex	"<horizontal-space-char>" = " " | "<HT>";
cc	    const char * horizontal_space_char = " \t";
cc
lex
lex	"<vertical-space-char>" =
lex	    "<VT>" | "<FF>" | "<CR>" | "<NL>";
cc	    const char * vertical-space_char =
cc	        "\v\f\r\n";
cc
lex
lex	// The following can begin an operator or punc-
lex	// tuation mark.
lex	//
lex	// . not followed by <digit> is handled separa-
lex	// tely.
lex	//
lex	"<op-char>" = "#" | "<" | ">" | ":" | "%" |
lex	            | "?" | "+" | "-" | "*" | "/"
lex	            | "^" | "&" | "|" | "~" | "!" | ","
lex	            | "(" | ")" | "[" | "]" | "{" | "}"
lex	            | ";";
cc	    const char * op_char =
cc	        "#<>:%?+-*/^&|~!,()[]{};";
cc
lex
lex	"<basic-char>" = "<ascii-letter>"
lex	               | "<digit>"
lex	               | "_"
lex	               | "<op-char>"
lex	               | "\" | "<Q>" | "'"
lex	               | "<horizontal-space-char>"
lex	               | "<vertical-space-char>";
cc	    const char * basic_char =
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
cc		"_"
cc	        "#<>:%.?+-*/^&|~!,()[]{};"
cc		"\\\"'"
cc	        " \t"
cc	        "\v\f\r\n";
cc
lex
lex	"<sign>" = "+" | "-" ;
cc	    const char * sign = "+-";
cc
lex
lex	"<u_U>" = "u" | "U" ;
cc	    const char * u_or_U = "uU";
cc
lex
lex
lex	// C/C++ preprocessing is hereafter abbreviated
lex	// as `pp'.
lex
lex	// Alternative operators that are not identi-
lex	// fiers are translated.  E.g., <: becomes [ in
lex	// the lexeme // translation.
lex
lex	// C++ punctuation are treated as `operators'.
lex
lex	// Pp numbers are divided into 3 categories:
lex	//      integers        nothing but digits
lex	//      floating point  legal floating point #'s
lex	//      number          all other pp numbers
lex
lex	// Because of pp control lines, lexical scanning
lex	// is slightly context dependent.  There are
lex	// several contexts, each corresponding to a
lex	// different master table:
lex	//
lex	//    initial master
lex	//        Used in line beginning situations to
lex	//	  recognize the # token that introduces
lex	//	  a pp control line.
lex	//    pp beginning master
lex	//        Used to scan the beginning of a pp
lex	//	  control line after the # has been
lex	//        scanned but before anything else is
lex	//        scanned.
lex	//    pp include master
lex	//        Used to scan the pp-header token in a
lex	//        #include line after #include has been
lex	//        scanned.
lex	//    normal master
lex	//        Used to scan a non pp control line or
lex	//        the rest of a non-#include pp control
lex	//        line.
lex	//
lex	// The whitespace lexeme types are:
lex	//
lex	//    newline
lex	//        a sequence of zero or more <FF>, <VT>
lex	//        and <CR>'s followed by a single <NL>
lex	//        followed by zero or more <CR>'s.
lex	//    horizontal-space
lex	//        sequence of "<horizontal-space-char>"s
lex	//        <FF>, <VT>, <CR>, and <NL>'s are
lex	//        excluded
le	//    comment
lex	//        "/*" comment (including /* and */)
lex	//        "//" comment (including // but not
lex	//                      ending newline)
lex	//    end of file (lexeme is "")
lex	//    premature line feed (lexeme is "<NL>")
lex	//    premature end of file (lexeme is "")
lex	//
lex	// This allows line feeds to be used to end pp
lex	// control lines.  The `premature' lexemes are
lex	// errors: the previous lexeme is treated as if
lex	// there were no error (i.e., as if there were a
lex	// ", ', */, etc.) and the next lexeme is a
lex	// `premature ...' lexeme.
lex	//
lex	// Characters that are not part of any C++
lex	// lexeme and universal characters that are not
lex	// part of any C++ lexeme are made into lexemes
lex	// or erroneous atoms of the types:
lex	//
lex	//    illegal character
lex	//        A single character
lex	//    illegal universal character
lex	//        A \UXXXXXXXX or \uXXXX sequence
lex	//
lex	// These are untranslated.
lex
lex	begin initial master table;
cc	    NDL::begin_table ( initial );
cc
lex
lex	    "<horizontal-space-char>"
lex	        call horizontal_space;
cc		NDL::begin_dispatch
cc			( horizontal_space_char );
cc		    NDL::call ( horizontal_space );
cc		NDL::end_dispatch();
cc
lex
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur inside
lex	    // pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    "#" output operator goto pp beginning;
lex	    "##" output operator goto normal;
cc		NDL::begin_dispatch ( "#" );
cc		    NDL::begin_dispatch ( "#" );
cc		        NDL::output ( operator_t );
cc		        NDL::goto ( normal );
cc		    NDL::end_dispatch();
cc		    NDL::output ( operator_t );
cc		    NDL::goto ( pp_beginning );
cc		NDL::end_dispatch();
cc
lex
lex	    "%:" translate to "#" output operator
lex	        goto pp beginning;
lex	    "%:%:" translate to "##" output operator
lex	        goto normal;
cc		NDL::begin_dispatch ( "%" );
cc		  NDL::begin_dispatch ( ":" );
cc		    NDL::begin_dispatch ( "%" );
cc		      NDL::begin_dispatch ( ":" );
cc		        NDL::translate_to ( "##" );
cc		        NDL::output ( operator_t );
cc		        NDL::goto ( normal );
cc		      NDL::end_dispatch();
cc		    NDL::end_dispatch();
cc
cc		    NDL::translate_to ( "#" );
cc	            NDL::output ( operator_t );
cc	            NDL::goto ( pp_beginning );
cc
cc		  NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex	    goto normal;
cc		NDL::goto ( normal );
cc
lex
lex	end initial master table;
cc	    NDL::end_table();
cc
lex
lex	begin horizontal space lexeme table;
cc	    NDL::begin_table ( horizontal_space );
cc
lex
lex	    "<horizontal-space-char>" accept;
cc		NDL::begin_dispatch
cc			( horizontal_space_char );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end horizontal lexeme table;
cc	    NDL::end_table();
cc
lex
lex	begin newline lexeme table;
cc	    NDL::begin_table ( newline );
cc
lex
lex	    "<FF>" accept;
lex	    "<VT>" accept;
lex	    "<CR>" accept;
cc		NDL::begin_dispatch ( "\f\v\r" );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<NL>" goto newline finish;
cc		NDL::begin_dispatch
cc			( "\n" );
cc		    NDL::goto ( newline_finish );
cc		NDL::end_dispatch();
cc
lex
lex	    output illegal vertical characters return;
cc		NDL::output
cc		    ( illegal_vertical_space_t );
cc		NDL::ret();
cc
lex
lex	end newline table;
cc	    NDL::end_table();
cc
lex
lex	begin newline finish lexeme table;
cc	    NDL::begin_table ( newline_finish );
cc
lex
lex	    "<CR>" accept;
cc		NDL::begin_dispatch ( "\r" );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end newline finish lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin "/*" comment lexeme table;
cc	    NDL::begin_table ( slash_star_comment );
cc
lex
lex	    "*/" return;
lex	    "*" accept;
cc		NDL::begin_dispatch ( "*" );
cc		    NDL::begin_dispatch ( "/" );
cc		        NDL::ret();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::goto ( premature_end_of_file );
cc
lex
lex	end "/*" comment lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin "//" comment lexeme table;
cc	    NDL::begin_table ( slash_slash_comment );
cc
lex
lex	    "<NL>" keep 0 return;
cc		NDL::begin_dispatch ( "\n" );
cc		    NDL::keep ( 0 );
cc		    NDL::ret();
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::goto ( premature_end_of_file );
cc
lex
lex	end "//" comment lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin premature newline master table;
cc	    NDL::begin_table ( premature_newline );
cc
lex
lex	    "<NL>" output premature newline
lex	        goto initial;
cc		NDL::begin_dispatch ( "\n" );
cc		    NDL::output
cc			( premature_newline );
cc		    NDL::goto ( initial );
cc		NDL::end_dispatch();
cc
lex
lex	end premature newline master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin premature end of file master table;
cc	    NDL::begin_table ( premature_end_of_file );
cc
lex
lex	    output premature end of file goto initial;
cc	        NDL::output ( premature_end_of_file_t );
cc	        NDL::goto ( initial );
lex
lex	end premature end of file master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin pp beginning master table;
cc	    NDL::begin_table ( pp_beginning );
cc
lex
lex	    "<horizontal-space-char>"
lex	        call horizontal_space;
cc		NDL::begin_dispatch
cc			( horizontal_space_char );
cc		    NDL::call ( horizontal_space );
cc		NDL::end_dispatch();
cc
lex
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur inside
lex	    // pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    "include<identifier-non-digit>"
lex	        keep 0 goto normal;
lex	    "include<digit>"
lex	        keep 0 goto normal;
lex	    "include"
lex	        output identifier goto pp include;
lex	    goto normal;
cc		NDL::begin_dispatch ( "i" );
cc		NDL::begin_dispatch ( "n" );
cc		NDL::begin_dispatch ( "c" );
cc		NDL::begin_dispatch ( "l" );
cc		NDL::begin_dispatch ( "u" );
cc		NDL::begin_dispatch ( "d" );
cc		NDL::begin_dispatch ( "e" );
cc		    NDL::begin_dispatch
cc			    ( identifier_non_digit );
cc		        add_non_ascii_letters();
cc	    	        NDL::add_characters ( digit );
cc		        NDL::keep ( 0 );
cc		        NDL::goto ( normal );
cc		    NDL::end_dispatch();
cc		    NDL::output ( identifier_t );
cc		    NDL::goto ( pp_include );
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	end pp beginning master table;
cc	    NDL::end_table();
cc
lex
lex	begin pp include master table;
cc	    NDL::begin_table ( pp_include );
cc
lex
lex	    "<horizontal-space-char>"
lex	        call horizontal space;
cc		NDL::begin_dispatch
cc			( horizontal_space_char );
cc		    NDL::call ( horizontal_space );
cc		NDL::end_dispatch();
cc
lex
lex	    // We only need handle /*...*/ comments
lex	    // because only these can occur inside
lex	    // pp directive line.
lex	    //
lex	    "/*" call "/*" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex
lex	    "<" translate to ""
lex	        goto bracketed header name;
cc		NDL::begin_dispatch ( "<" );
cc		    NDL::translate_to ( "" );
cc		    NDL::goto ( bracketed_header );
cc		NDL::end_dispatch();
cc
lex
lex	    "<Q>" translate to ""
lex	        goto quoted header name;
cc		NDL::begin_dispatch ( "\"" );
cc		    NDL::translate_to ( "" );
cc		    NDL::goto ( quoted_header );
cc		NDL::end_dispatch();
cc
lex
lex	    goto normal;
cc	        NDL::goto ( normal );
cc
lex
lex	end pp include master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin bracketed header name lexeme table;
cc	    NDL::begin_table ( bracketed_header_name );
cc
lex
lex	    ">" translate to "" goto normal;
cc		NDL::begin_dispatch ( ">" );
cc		    NDL::translate_to ( "" );
cc		    NDL::goto ( normal );
cc		NDL::end_dispatch();
cc
lex
lex	    "<vertical-space-char>"
lex	        keep 0 goto premature newline;
cc		NDL::begin_dispatch
cc		    ( vertical_space_char );
cc		    NDL::keep ( 0 );
cc		    NDL::goto ( premature_newline );
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::goto ( premature_end_of_file );
cc
lex
lex	end bracketed header name lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	// Quoted header names are not the same as
lex	// quoted strings, and cannot have escape
lex	// sequences.
lex	//
lex	begin quoted header name lexeme table;
cc	    NDL::begin_table ( quoted_header_name );
cc
lex
lex	    "<Q>" translate to "" goto normal;
cc		NDL::begin_dispatch ( "\"" );
cc		    NDL::translate_to ( "" );
cc		    NDL::goto ( normal );
cc		NDL::end_dispatch();
cc
lex
lex	    "<vertical-space-char>"
lex	        keep 0 goto premature newline;
cc		NDL::begin_dispatch
cc		    ( vertical_space_char );
cc		    NDL::keep ( 0 );
cc		    NDL::goto ( premature_newline );
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" accept;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    goto premature end of file;
cc		NDL::goto ( premature_end_of_file );
cc
lex
lex	end quoted header name lexeme table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin normal master table;
cc	    NDL::begin_table ( normal );
cc
lex
lex	    "<horizontal-space-char>"
lex             call horizontal space;
cc		NDL::begin_dispatch
cc			( horizontal_space_char );
cc		    NDL::call ( horizontal_space );
cc		NDL::end_dispatch();
cc
lex
lex	    "/*" call "/*" comment;
lex	    "//" call "//" comment;
cc		NDL::begin_dispatch ( "/" );
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::call
cc	                    ( slash_star_comment );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "/" );
cc		        NDL::call
cc	                    ( slash_slash_comment );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    "<identifier-non-literal>" call identifier;
lex	        // Also see "u..." etc. below.
cc		NDL::begin_dispatch
cc			( identifier_non_literal );
cc		    add_non_ascii_letters();
cc		    NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "\<u_U>"
lex	             match escaped character
lex	             require <non-ascii-letter>
lex	                 call identifier
lex	        else match escaped character
lex	             output illegal universal
lex	                    character
lex	        else keep 1 output illegal character;
cc		NDL::begin_dispatch ( "\\" );
cc		    NDL::begin_dispatch ( u_or_U );
cc		        NDL::match
cc			     ( escaped_character );
cc		        NDL::require
cc			     ( non_ascii_letter );
cc		        NDL::call ( identifier );
cc		    NDL::ELSE();
cc		        NDL::match
cc			     ( escaped_character );
cc		        NDL::output
cc			     ( ill_universal_char_t );
cc		    NDL::ELSE();
cc			NDL::keep ( 1 );
cc		        NDL::output
cc			     ( illegal_character_t );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    "<digit>" call integer;
cc		NDL::begin_dispatch ( digit_char );
cc		    NDL::call ( integer );
cc		NDL::end_dispatch();
cc
lex
lex	    ".<digit>" call fraction;
lex	    "." match operator output operator
lex	        else output illegal character;
cc		NDL::begin_dispatch ( "." );
cc		    NDL::begin_dispatch ( digit_char );
cc		        NDL::call ( fraction );
cc		    NDL::end_dispatch();
cc		        NDL::match ( operator );
cc		        NDL::output ( operator_t );
cc		    NDL::ELSE();
cc		        NDL::output
cc			    ( illegal_character_t );
cc		NDL::end_dispatch();
cc
lex
lex	    "<op-char>"
lex	        match operator output operator
lex	        else output illegal character;
cc		NDL::begin_dispatch ( op_char );
cc		        NDL::match ( operator );
cc		        NDL::output ( operator_t );
cc		    NDL::ELSE();
cc		        NDL::output
cc			    ( illegal_character_t );
cc		NDL::end_dispatch();
cc
lex
lex	    "'" translate to ""
lex	        call character literal;
cc		NDL::begin_dispatch ( "'" );
cc		    NDL::translate_to ( "" );
cc		    NDL::call ( character_literal );
cc		NDL::end_dispatch();
cc
lex
lex	    "<Q>" translate to ""
lex	          call string literal;
cc		NDL::begin_dispatch ( "'" );
cc		    NDL::translate_to ( "" );
cc		    NDL::call ( string_literal );
cc		NDL::end_dispatch();
cc
lex
lex	    "u'" translate to ""
lex	         call u character literal;
lex	    "u<Q>" translate to ""
lex	           call u string literal;
lex	    "u"  call identifier;
cc		NDL::begin_dispatch ( "u" );
cc		    NDL::begin_dispatch ( "'" );
cc		        NDL::translate_to ( "" );
cc		        NDL::call
cc			    ( u_character_literal );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "\"" );
cc		        NDL::translate_to ( "" );
cc		        NDL::call
cc			    ( u_string_literal );
cc		    NDL::end_dispatch();
cc		    NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "U'" translate to ""
lex	         call U character literal;
lex	    "U<Q>" translate to ""
lex	           call U string literal;
lex	    "U"  call identifier;
cc		NDL::begin_dispatch ( "U" );
cc		    NDL::begin_dispatch ( "'" );
cc		        NDL::translate_to ( "" );
cc		        NDL::call
cc			    ( U_character_literal );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "\"" );
cc		        NDL::translate_to ( "" );
cc		        NDL::call
cc			    ( U_string_literal );
cc		    NDL::end_dispatch();
cc		    NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "L'" translate to ""
lex	         call L character literal;
lex	    "L<Q>" translate to ""
lex	           call L string literal;
lex	    "L"  call identifier;
cc		NDL::begin_dispatch ( "L" );
cc		    NDL::begin_dispatch ( "'" );
cc		        NDL::translate_to ( "" );
cc		        NDL::call
cc			    ( L_character_literal );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "\"" );
cc		        NDL::translate_to ( "" );
cc		        NDL::call
cc			    ( L_string_literal );
cc		    NDL::end_dispatch();
cc		    NDL::call ( identifier );
cc		NDL::end_dispatch();
cc
lex
lex	    "<vertical-space-char>"
lex	        keep 0 goto newline;
cc		NDL::begin_dispatch
cc		    ( vertical_space_char );
cc		    NDL::keep ( 0 );
cc		    NDL::call ( newline );
cc		NDL::end_dispatch();
cc
lex
lex	    "<other>" output illegal character;
cc		NDL::begin_dispatch ( OTHER );
cc		    NDL::output ( illegal_character_t );
cc		NDL::end_dispatch();
cc
lex
lex	    output end of file;
cc		NDL::output ( end_of_file_t );
cc
lex
lex	end normal master table;
cc	    NDL::end_table();
cc
lex
lex
lex	begin operator atom table;
cc	    NDL::begin_table ( operator );
cc
lex
lex	    "("; ")"; "["; "]"; "{"; "}"; ";"; ","; "?";
lex	    "~";
cc		NDL::begin_dispatch ( "()[]{};,?~" );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "#";
lex	    "##";
cc		NDL::begin_dispatch ( "#" );
cc		    NDL::begin_dispatch ( "#" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<:" translate to "[";
lex	    "<%"; translate to "{";
lex	    "<<="; "<<"; "<";
cc		NDL::begin_dispatch ( "<" );
cc		    NDL::begin_dispatch ( ":" );
cc		        NDL::translate_to ( "[" );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "%" );
cc		        NDL::translate_to ( "{" );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "<" );
cc		        NDL::begin_dispatch ( "=" );
cc		            NDL::accept();
cc		        NDL::end_dispatch();
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    ">>="; ">>"; ">";
cc		NDL::begin_dispatch ( ">" );
cc		    NDL::begin_dispatch ( ">" );
cc		        NDL::begin_dispatch ( "=" );
cc		            NDL::accept();
cc		        NDL::end_dispatch();
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    ":>" translate to "]";
lex	    "::"; ":";
cc		NDL::begin_dispatch ( ":" );
cc		    NDL::begin_dispatch ( ">" );
cc		        NDL::translate_to ( "]" );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( ":" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "%:%:" translate to "##";
lex	    "%>" translate to "}";
lex	    "%:" translate to "#";
lex	    "%="; "%";
cc		NDL::begin_dispatch ( "%" );
cc		    NDL::begin_dispatch ( ">" );
cc		        NDL::translate_to ( "}" );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( ":" );
cc		        NDL::begin_dispatch ( "%" );
cc		            NDL::begin_dispatch ( ":" );
cc		                NDL::translate_to
cc				    ( "##" );
cc		            NDL::end_dispatch();
cc		        NDL::end_dispatch();
cc		        NDL::translate_to ( "#" );
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "=" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "..."; ".*"; ".";
cc		NDL::begin_dispatch ( "." );
cc		    NDL::begin_dispatch ( "." );
cc		        NDL::begin_dispatch ( "." );
cc		            NDL::accept();
cc		        NDL::end_dispatch();
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "*" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "++"; "+="; "+";
cc		NDL::begin_dispatch ( "+" );
cc		    NDL::begin_dispatch ( "+=" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "->*"; "->"; "--"; "-="; "-";
cc		NDL::begin_dispatch ( "-" );
cc		    NDL::begin_dispatch ( ">" );
cc		        NDL::begin_dispatch ( "*" );
cc		            NDL::accept();
cc		        NDL::end_dispatch();
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::begin_dispatch ( "=-" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "*="; "*";
lex	    "/="; "/";
lex	    "^="; "^";
lex	    "!="; "!";
lex	    "=="; "=";
cc		NDL::begin_dispatch ( "*/^!=" );
cc		    NDL::begin_dispatch ( "=" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "&&"; "&="; "&";
cc		NDL::begin_dispatch ( "&" );
cc		    NDL::begin_dispatch ( "&=" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "||"; "|="; "|";
cc		NDL::begin_dispatch ( "|" );
cc		    NDL::begin_dispatch ( "|=" );
cc		        NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    fail;
cc		NDL::fail();
cc
lex
lex	end operator atom table;
cc	    NDL::end_table();
cc
lex
lex
lex	"<u_U>" = "u" | "U";
cc	    const char * u_U = "uU";
lex
lex	begin identifier lexeme table;
cc	    NDL::begin_table ( identifier );
cc
lex
lex	    "<identifier-non-digit>" accept;
lex	    "<digit>" accept;
cc		NDL::begin_dispatch
cc		        ( identifier_non_digit );
cc		    add_non_ascii_letters();
cc	    	    NDL::add_characters ( digit );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "\<u_U>" match universal character
lex	             require "<non-ascii-letter>"
lex	             else keep 0 return;
cc		NDL::begin_dispatch ( "\" );
cc		    NDL::begin_dispatch ( u_U );
cc		            NDL::match
cc			        ( universal_character );
cc		            NDL::require
cc			        ( non_ascii_letter );
cc			NDL::ELSE();
cc			    NDL::keep ( 0 );
cc			    NDL::ret();
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end identifier lexeme table;
cc	    NDL::end_table();
cc
lex
lex	"<e_E> = "e" | "E";
lex	"<identifier-non-digit-except-eE>" =
lex	    "<identifier-non-digit>" & ~ "<e_E>";
cc	    const char * e_E = "eE";
cc	    const char * identifier_non_digit_except_eE
cc		= "_"
cc	          "abcdfghijklmnopqrstuvwxyz"
cc	          "ABCDFGHIJKLMNOPQRSTUVWXYZ";
cc		  // Must use add_non_ascii_letters.
cc
lex
lex
lex	begin decimal integer lexeme table;
lex	    "<digit>" accept;
lex	    "." goto fraction;
lex	    "<e_E><sign><digit>" goto exponent;
lex	    "<e_E><digit>" goto exponent;
lex	    "<e_E><sign>" goto pp number;
lex	    "<identifier-non-digit>" call suffix;
lex	    output integer return;
lex	end decimal integer lexeme table;
lex
lex
lex	begin octal integer lexeme table;
lex	    "<octal-digit>" accept;
lex	    "8-9" goto pp number;
lex	    "." goto pp number;
lex	    "<e_E><sign>" goto pp number;
lex	    "<identifier-non-digit>" call suffix;
lex	    output integer return;
lex	end octal integer lexeme table;
lex
lex
lex	begin hexadecimal integer lexeme table;
lex	    "<hexadecimal-digit>" accept;
lex	    "." goto pp number;
lex	    "<e_E><sign>" goto pp number;
lex	    "<identifier-non-digit>" call suffix;
lex	    output integer return;
lex	end hexadecimal integer lexeme table;
lex
lex
lex
lex	begin suffix lexeme table;
cc	    NDL::begin_table ( suffix );
cc
lex
lex	    "<identifier-non-digit-except-eE>" accept;
lex	    "<digit>" accept;
cc		NDL::begin_dispatch
cc		    ( identifier_non_digit_except_eE );
cc		    add_non_ascii_letters();
cc	    	    NDL::add_characters ( digit_char );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<e_E><sign>" goto pp number;
lex	    "<e_E>" accept;
cc		NDL::begin_dispatch ( e_E );
cc		    NDL::begin_dispatch ( sign_char );
cc			NDL::goto ( pp_number );
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "." goto pp number;
cc		NDL::begin_dispatch ( "." );
cc		    NDL::goto ( pp_number );
cc		NDL::end_dispatch();
cc
lex
lex	    "\<u_U>" match universal character
lex	             require "<non-ascii-letter>"
lex	             else keep 0 return;
cc		NDL::begin_dispatch ( "\" );
cc		    NDL::begin_dispatch ( u_U );
cc		            NDL::match
cc			        ( universal_character );
cc		            NDL::require
cc			        ( non_ascii_letter );
cc			NDL::ELSE();
cc			    NDL::keep ( 0 );
cc			    NDL::ret();
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    return;
cc		NDL::ret();
cc
lex
lex	end suffix lexeme table;
cc	    NDL::end_table();
cc
lex
lex	begin pp number lexeme table;
cc	    NDL::begin_table ( pp_number );
cc
lex
lex	    "<identifier-non-digit-except-eE>" accept;
lex	    "<digit>" accept;
cc		NDL::begin_dispatch
cc		    ( identifier_non_digit_except_eE );
cc		    add_non_ascii_letters();
cc	    	    NDL::add_characters ( digit_char );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "<e_E><sign>" accept;
lex	    "<e_E>" accept;
cc		NDL::begin_dispatch ( e_E );
cc		    NDL::begin_dispatch ( sign_char );
cc			NDL::accept();
cc		    NDL::end_dispatch();
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex	    "." accept;
cc		NDL::begin_dispatch ( "." );
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc
lex
lex	    "\<u_U>" match universal character
lex	             require "<non-ascii-letter>"
lex	             else keep 0 goto normal;
cc		NDL::begin_dispatch ( "\" );
cc		    NDL::begin_dispatch ( u_U );
cc		            NDL::match
cc			        ( universal_character );
cc		            NDL::require
cc			        ( non_ascii_letter );
cc			NDL::ELSE();
cc			    NDL::keep ( 0 );
cc			    NDL::goto ( normal );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc
lex
lex	    goto normal;
cc		NDL::goto ( normal );
cc
lex
lex	end pp number lexeme table;
cc	    NDL::end_table();
cc
lex
lex	"<non-digit-except-lLfF> =
lex	    <non-digit> & ~ "l" & ~ "f" & ~ "L" & ~ "F";
lex
lex	begin fraction lexeme table;
lex	    "<digit>" accept;
lex	    "." goto pp number;
lex	    "<e_E><sign><digit>" goto exponent;
lex	    "<e_E><digit>" goto exponent;
lex	    "<e_E><sign>" goto pp number;
lex	    "<identifier-non-digit>" call suffix;
lex	    output floating point return;
lex	end fraction lexeme table;
lex
lex	begin exponent lexeme table;
lex	    "<digit>" accept;
lex	    "." goto pp number;
lex	    "<identifier-non-digit>" call suffix;
lex	    output floating point return;
lex	end exponent lexeme table;
lex
lex
lex	begin character literal lexeme table;
lex	    "'" translate to "" return;
lex	    "<NL>" keep 0 goto premature newline
lex	    "\" match universal character
lex	        else error illegal character
lex	    "<other>" accept
lex	    goto premature end of file
lex	end character literal lexeme table;
lex
lex
lex	begin u character literal lexeme table;
lex	    "'" translate to "" return;
lex	    "<NL>" keep 0 goto premature newline
lex	    "\" match universal character
lex	        else error illegal character
lex	    "<other>" accept
lex	    goto premature end of file
lex	end u character literal lexeme table;
lex
lex
lex	begin U character literal lexeme table;
lex	    "'" translate to "" return;
lex	    "<NL>" keep 0 goto premature newline
lex	    "\" match universal character
lex	        else error illegal character
lex	    "<other>" accept
lex	    goto premature end of file
lex	end U character literal lexeme table;
lex
lex
lex	begin L character literal lexeme table;
lex	    "'" translate to "" return;
lex	    "<NL>" keep 0 goto premature newline
lex	    "\" match universal character
lex	        else error illegal character
lex	    "<other>" accept
lex	    goto premature end of file
lex	end L character literal lexeme table;
lex
lex
lex	begin string literal lexeme table;
lex	    "<Q>" translate to "" return;
lex	    "<NL>" keep 0 goto premature newline;
lex	    "\" match universal character
lex	        else error illegal character;
lex	    "<other>" accept
lex	    goto premature end of file;
lex	end string literal lexeme table;
lex
lex
lex	begin u string literal lexeme table;
lex	    "<Q>" translate to "" return;
lex	    "<NL>" keep 0 goto premature newline;
lex	    "\" match universal character
lex	        else error illegal character;
lex	    "<other>" accept
lex	    goto premature end of file;
lex	end u string literal lexeme table;
lex
lex
lex	begin U string literal lexeme table;
lex	    "<Q>" translate to "" return;
lex	    "<NL>" keep 0 goto premature newline;
lex	    "\" match universal character
lex	        else error illegal character;
lex	    "<other>" accept
lex	    goto premature end of file;
lex	end U string literal lexeme table;
lex
lex
lex	begin L string literal lexeme table;
lex	    "<Q>" translate to "" return;
lex	    "<NL>" keep 0 goto premature newline;
lex	    "\" match universal character
lex	        else error illegal character;
lex	    "<other>" accept
lex	    goto premature end of file;
lex	end L string literal lexeme table;
lex
lex
lex	// This atom table is used when the next atom
lex	// begins with \ and is in a character or string
lex	// literal.
lex	//
lex	// We allow only a maximum of 8 hexadecimal
lex	// digits after \x; 9 digits is an error.  The
lex	// C++ standard permits any number of hexa-
lex	// decimal digits.
lex	//
lex	begin escaped character atom table;
lex	    "\n" translate to "<NL>";
lex	    "\t" translate to "<HT>";
lex	    "\v" translate to "<VT>";
lex	    "\b" translate to "<BS>";
lex	    "\r" translate to "<CR>";
lex	    "\f" translate to "<FF>";
lex	    "\a" translate to "<BEL>";
lex	    "\\" translate to "\";
lex	    "\?" translate to "?";
lex	    "\<Q>" translate to "<Q>";
lex	    "\'" translate to "'";
lex	    "\<oct-digit>"
lex	        translate oct 1 0;
lex	    "\<oct-digit><oct-digit>"
lex	        translate oct 1 0;
lex	    "\<oct-digit><oct-digit><oct-digit>"
lex	        translate oct 1 0;
lex	    "\x<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\x<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit>" fail;
lex	    "\u<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    "\U<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	      "<hex-digit><hex-digit>"
lex	        translate hex 2 0;
lex	    fail;
lex	end escaped character atom table;
lex
lex	end c++ lexical program;
