// Layered Languages Standard Lexical Analyzer
//
// File:	ll_lexeme_standard.lexcc
// Author:	Bob Walton (walton@acm.org)
// Date:	Mon Jun  1 21:20:16 EDT 2015
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.

// Lines beginning with `lex<HT>' and lines equal to
// `lex' are copied to ll_lexeme_standard.lex and then
// to the Standard Lexical Program appendix of ../doc/
// layered-introduction.tex.
//
// Lines beginning with `cc<HT>' and lines equal to `cc'
// are copied to ll_lexeme_standard.cc and compiled to
// produce code that can create a standard lexical
// program.

// Table of Contents
//
//	Usage and Setup
//	Program Construction

// Usage and Setup
// ----- --- -----

lex	// This file was automatically generated from
lex	// ll_lexeme_standard.lexcc.
lex
cc	// This file was automatically generated from
cc	// ll_lexeme_standard.lexcc.
cc
cc	# include <ll_lexeme_ndl.h>
cc	# include <ll_lexeme_standard.h>
cc	using namespace ll::lexeme::ndl;
cc	# define LEX ll::lexeme
cc	# define LEXSTD ll::lexeme::standard
cc	using namespace LEXSTD;
cc
cc	const min::Uchar UUC[1] =
cc	    { min::UNKNOWN_UCHAR };
cc

// Program Construction
// ------- ------------

cc	min::locatable_var<LEX::program>
cc	    LEXSTD::default_program;
cc
cc	const char * const
cc		LEXSTD::type_names[MAX_TYPE+1] = {
cc
cc	    NULL,
cc	    "WORD",
cc	    "NATURAL",
cc	    "NUMERIC",
cc	    "MARK",
cc	    "QUOTED_STRING",
cc	    "SEPARATOR",
cc	    "COMMENT",
cc	    "HORIZONTAL_SPACE",
cc	    "LINE_BREAK",
cc	    "END_OF_FILE",
cc	    "PREMATURE_END_OF_STRING",
cc	    "PREMATURE_END_OF_FILE",
cc	    "MISPLACED_VERTICAL",
cc	    "ILLEGAL_CONTROL",
cc	    "UNRECOGNIZED_CHARACTER",
cc	    "UNRECOGNIZED_ESCAPE",
cc	    "MISPLACED_HORIZONTAL" };
cc
cc	const char * LEXSTD::type_codes =
cc	    "?wn#mqschbeSFVCUEH";
cc
cc	void LEXSTD::init_standard_program
cc		( void )
cc	{
cc	    if ( LEXSTD::default_program != NULL_STUB )
cc	        return;
cc

lex
lex	begin standard lexical program;
lex
cc	    begin_program
cc		( type_names, type_codes, MAX_TYPE );
cc
cc	    uns32 main;
cc	    NDL::new_table ( main, MASTER );
cc
cc	    uns32 separator;
cc	    NDL::new_table ( separator, separator_t );
cc	    uns32 finish_separators;
cc	    NDL::new_table
cc		( finish_separators, MASTER );
cc	    uns32 finish_middle;
cc	    NDL::new_table ( finish_middle );
cc	    uns32 leading_zero;
cc	    NDL::new_table ( leading_zero );
cc	    uns32 natural;
cc	    NDL::new_table ( natural, natural_t );
cc	    uns32 mark;
cc	    NDL::new_table ( mark, mark_t );
cc
cc	    uns32 quoted_string;
cc	    NDL::new_table
cc		( quoted_string, quoted_string_t );
cc	    uns32 comment;
cc	    NDL::new_table ( comment, comment_t );
cc
cc	    uns32 line_break;
cc	    NDL::new_table ( line_break, line_break_t );
cc	    uns32 misplaced_vertical;
cc	    NDL::new_table ( misplaced_vertical,
cc			     misplaced_vertical_t );
cc
cc	    uns32 premature_end_of_string;
cc	    NDL::new_table
cc		( premature_end_of_string, MASTER );
cc	    uns32 end_of_file;
cc	    NDL::new_table
cc		( end_of_file, MASTER );
cc	    uns32 stop;
cc	    NDL::new_table
cc		( stop, MASTER );
cc
cc	    uns32 escaped;
cc	    NDL::new_table ( escaped, ATOM );
cc	    uns32 escaped_hex;
cc	    NDL::new_table ( escaped_hex, ATOM );
cc	    uns32 unrecognized_escape;
cc	    NDL::new_table
cc		( unrecognized_escape, ATOM );
cc

lex	"<horizontal>" = "<UNICODE-CATEGORY-Zs>"
lex		       | "<HT>";
lex

lex	"<misplaced-horizontal-space>" =
lex		  "<UNICODE-CATEGORY-Zs>"
lex		& ~ "<SP>";
lex

lex	"<vertical>" = "<CR>" | "<VT>" | "<FF>"
lex
cc	    const char * vertical = "\r\v\f";
cc

lex	"<graphic>" = "<UNICODE-CATEGORY-L>"
lex		    | "<UNICODE-CATEGORY-M>"
lex		    | "<UNICODE-CATEGORY-N>"
lex		    | "<UNICODE-CATEGORY-P>"
lex		    | "<UNICODE-CATEGORY-S>"
lex
cc	# define GRAPHIC \
cc	           NDL::add_category ( "L" ); \
cc	           NDL::add_category ( "M" ); \
cc	           NDL::add_category ( "N" ); \
cc	           NDL::add_category ( "P" ); \
cc	           NDL::add_category ( "S" )
cc

lex	"<control>" = "<UNICODE-CATEGORY-C>"
lex		    | "<UNICODE-CATEGORY-Z>"
lex

lex	"<illegal-control>" = "<control>"
lex			    & ~ "<horizontal>"
lex			    & ~ "<vertical>"
lex			    & ~ "<LF>"
lex
cc	# define ILLEGAL_CONTROL \
cc	           NDL::add_category ( "C" ); \
cc	           NDL::add_category ( "Z" ); \
cc	           NDL::sub_category ( "Zs" ); \
cc	           NDL::sub_chars ( vertical ); \
cc	           NDL::sub_chars ( "\t\n" )
cc

lex	"<isolated-separator>"
lex		= "<UNICODE-CATEGORY-Ps>"
lex	        | "<UNICODE-CATEGORY-Pi>"
lex	        | "<UNICODE-CATEGORY-Pe>"
lex	        | "<UNICODE-CATEGORY-Pf>"
lex
cc	# define ISOLATED_SEPARATOR \
cc	           NDL::add_category ( "Ps" ); \
cc	           NDL::add_category ( "Pi" ); \
cc	           NDL::add_category ( "Pe" ); \
cc	           NDL::add_category ( "Pf" )
cc	# define SUB_ISOLATED_SEPARATOR \
cc	           NDL::sub_category ( "Ps" ); \
cc	           NDL::sub_category ( "Pi" ); \
cc	           NDL::sub_category ( "Pe" ); \
cc	           NDL::sub_category ( "Pf" )
cc

lex	"<repeating-separator>" = "|"
lex

lex	"<separator>"
lex		= "<isolated-separator>"
lex		| "<repeating-separator>"
lex

lex	"<leading>"
lex		= "`" | "$"
lex	        | "<0A1>"  // Inverted !
lex	        | "<0BF>"  // Inverted ?
lex
cc	    // const char * leading = "`$\xA1\xBF";
cc	    //     // Unused
cc

lex	"<trailing>"
lex		= "'" | "!" | "?" | "." | "%"
lex		| "," | ";"
lex
cc	    const char * trailing = "'!?.%,;";
cc

lex	"<letter>" = "<UNICODE-CATEGORY-L>"
lex
cc	    const char * Letter = "L";
cc

lex	"<digit>" = "<UNICODE-CATEGORY-Nd>"
lex
cc	    const char * Digit = "Nd";
cc

lex	"<hex-digit>" = "0-9" | "A-F";
lex
cc	    const char * hex_digit =
cc		"0123456789ABCDEF";
cc

lex	"<non-ASCII-digit>" = "<digit> & ~ "0-9"
lex

lex	"<mark>" = (   "<UNICODE-CATEGORY-P>"
lex		     | "<UNICODE-CATEGORY-S>"
lex		     | "<UNICODE-CATEGORY-M>"
lex		     | "<UNICODE-CATEGORY-N>" )
lex		 & ~ "<digit>"
lex		 & ~ "<separator>"
lex		 & ~ "<Q>"
lex

lex	"<middle>" =   "<graphic>"
lex		   & ~ "<trailing>"
lex		   & ~ "<separator>"
lex		   & ~ "<Q>"
lex
cc	# define MIDDLE \
cc	           GRAPHIC; \
cc	           SUB_ISOLATED_SEPARATOR; \
cc	           NDL::sub_chars ( "|\"" ); \
cc	           NDL::sub_chars ( trailing )
cc

lex	"<mark-middle>" = "<mark>" & ~ "<trailing>"
lex
cc	# define MARK_MIDDLE \
cc	           NDL::add_category ( "P" ); \
cc	           NDL::add_category ( "S" ); \
cc	           NDL::add_category ( "M" ); \
cc	           NDL::add_category ( "N" ); \
cc	           NDL::sub_category ( Digit ); \
cc	           SUB_ISOLATED_SEPARATOR; \
cc	           NDL::sub_chars ( "|\"" ); \
cc	           NDL::sub_chars ( trailing )
cc

lex	"<directly-quotable>" = (     "<graphic>"
lex				  & ~ "<"
lex				  & ~ "<Q>" )
lex			      | "<SP>"
lex
cc	# define DIRECTLY_QUOTABLE \
cc	           GRAPHIC; \
cc	           NDL::sub_chars ( "<\"" ); \
cc	           NDL::add_chars ( " " )
cc

lex	"<escape>" = "A-Z" | "0-9"
lex
cc	    const char * escape =
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
cc

lex
lex	begin main master table;
lex
cc	    NDL::begin_table ( main );
cc

lex	   "//" goto comment;
lex	   "/"  goto mark;
lex
cc		   NDL::begin_dispatch ( "/" );
cc		      NDL::begin_dispatch ( "/" );
cc			 NDL::go ( comment );
cc		      NDL::end_dispatch();
cc
cc		      NDL::go ( mark );
cc		   NDL::end_dispatch();
cc

lex	   "<horizontal><repeat>"
lex	        output horizontal space;
lex
cc		   NDL::begin_dispatch ( "\t" );
cc		      NDL::add_category ( "Zs" );
cc		      NDL::REPEAT();
cc		      NDL::output
cc			    ( horizontal_space_t );
cc		   NDL::end_dispatch();
cc

lex	   "<LF>" goto line break
lex	   "<vertical>" goto misplaced vertical
lex
cc		   NDL::begin_dispatch ( "\n" );
cc		      NDL::go ( line_break );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( vertical );
cc		      NDL::go ( misplaced_vertical );
cc		   NDL::end_dispatch();
cc

lex	   "<illegal-control><repeat>"
lex	        output illegal control
lex
cc		   NDL::begin_dispatch(); 
cc		      ILLEGAL_CONTROL;
cc		      NDL::REPEAT();
cc		      NDL::output \
cc			  ( illegal_control_t ); \
cc		   NDL::end_dispatch();
cc

lex	   "<isolated-separator>" output separator;
lex	   "|<repeat>" output separator;
lex	   "`<repeat>" output separator;
lex	   "$<repeat>" output separator;
lex	   "<0A1><repeat>" output separator;
lex		// Inverted !
lex	   "<0BF><repeat>" output separator;
lex		// Inverted ?
lex
cc	    	   NDL::begin_dispatch();
cc		      ISOLATED_SEPARATOR;
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( "|" );
cc		      NDL::REPEAT();
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( "`" );
cc		      NDL::REPEAT();
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( "$" );
cc		      NDL::REPEAT();
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch();
cc		      NDL::add_char ( 0xA1 );
cc		      NDL::REPEAT();
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch();
cc		      NDL::add_char ( 0xBF );
cc		      NDL::REPEAT();
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc

lex	   "<trailing><repeat><letter>"
lex			output word
lex			goto finish middle;
lex	   "<trailing><repeat><digit>"
lex			output numeric
lex			goto finish middle;
lex	   "<trailing><repeat><mark-middle>"
lex			goto mark
lex	   "<trailing><repeat>"
lex			keep 0
lex			goto separator;
lex
cc	           NDL::begin_dispatch ( trailing );
cc	    	       NDL::REPEAT();
cc
cc	               NDL::begin_dispatch();
cc		           NDL::add_category ( Letter );
cc		           NDL::output ( word_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc
cc	               NDL::begin_dispatch();
cc		           NDL::add_category ( Digit );
cc		           NDL::output ( numeric_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc
cc	               NDL::begin_dispatch();
cc		           MARK_MIDDLE;
cc		           NDL::go ( mark );
cc		       NDL::end_dispatch();
cc
cc		       NDL::keep ( 0 );
cc		       NDL::go ( separator );
cc		   NDL::end_dispatch();
cc

lex	   "<letter>" output word goto finish middle;
lex
cc	    	   NDL::begin_dispatch ( );
cc		      NDL::add_category ( "L" );
cc		      NDL::output ( word_t );
cc		      NDL::go ( finish_middle );
cc	    	   NDL::end_dispatch();
cc

lex	   "0" goto leading zero;
lex
cc	    	   NDL::begin_dispatch ( "0" );
cc		      NDL::go ( leading_zero );
cc	    	   NDL::end_dispatch();
cc

lex	   "1-9" goto natural;
lex
cc	    	   NDL::begin_dispatch ( "123456789" );
cc		      NDL::go ( natural );
cc	    	   NDL::end_dispatch();
cc

lex	   "<non-ASCII-digit>" output numeric
lex			       goto finish middle;
lex
cc	    	   NDL::begin_dispatch();
cc		      NDL::add_category ( Digit );
cc		      NDL::sub_chars ( "0123456789" );
cc		      NDL::output ( numeric_t );
cc		      NDL::go ( finish_middle );
cc	    	   NDL::end_dispatch();
cc

lex	   "<mark-middle>" goto mark;
lex
cc	    	   NDL::begin_dispatch();
cc		      MARK_MIDDLE;
cc		      NDL::go ( mark );
cc	    	   NDL::end_dispatch();
cc

lex	   "<Q>" translate to "" goto quoted string;
lex
cc	    	   NDL::begin_dispatch ( "\"" );
cc		      NDL::translate_to ( "" );
cc		      NDL::go ( quoted_string );
cc	    	   NDL::end_dispatch();
cc

lex	   "<other><repeat>"
lex		error unrecognized character
lex
cc	    	   NDL::begin_dispatch ( OTHER );
cc		      NDL::REPEAT();
cc		      NDL::output
cc			( unrecognized_character_t );
cc	    	   NDL::end_dispatch();
cc

lex	   output premature end of file goto end of file
lex		// End of file not following a line
lex		// break
lex	end main master table;
lex
cc		   NDL::output
cc			( premature_end_of_file_t );
cc		   NDL::go ( end_of_file );
cc	    	NDL::end_table();
cc

lex
lex	// The below tables are entered from the master
lex	// table with the first atom scanned, unless
lex	// otherwise indicated.
lex
lex	begin comment lexeme table;
lex
cc	    NDL::begin_table ( comment );
cc

lex	   "<graphic>" accept
lex	   "<horizontal>" accept
lex
cc		   NDL::begin_dispatch ( "\t" );
cc		       GRAPHIC;
cc		       NDL::add_category ( "Zs" );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   goto main
lex	end comment lexeme table;
lex
cc	           NDL::go ( main );
cc	    NDL::end_table();
cc

lex
lex	begin misplaced vertical lexeme table;
lex
cc	    NDL::begin_table ( misplaced_vertical );
cc

lex	   "<LF>" goto line break;
lex	   "<vertical>" accept;
lex
cc	           NDL::begin_dispatch ( "\n" );
cc		       NDL::go ( line_break );
cc		   NDL::end_dispatch();
cc
cc	           NDL::begin_dispatch ( vertical );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   goto main;
lex	end misplaced vertical lexeme table;
lex
cc	    	   NDL::go ( main );
cc
cc	    NDL::end_table();
cc

lex
lex	begin line break lexeme table;
lex
cc	    NDL::begin_table ( line_break );
cc

lex	   "<LF>" accept;
lex	   "<vertical>" accept;
lex
cc	           NDL::begin_dispatch ( vertical );
cc		       NDL::add_char ( '\n' );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "<other>" keep 0 goto main
lex
cc	           NDL::begin_dispatch ( OTHER );
cc		       NDL::keep ( 0 );
cc	    	       NDL::go ( main );
cc		   NDL::end_dispatch();
cc

lex	    goto end of file
lex	end line break lexeme table;
lex
cc	        NDL::go ( end_of_file );
cc	    NDL::end_table();
cc

lex
lex	begin separator lexeme table;
lex	    // First atom is not scanned; next lexeme
lex	    // must be a trailing separator if it has
lex	    // the syntax of such.
lex
cc	    NDL::begin_table ( separator );
cc

lex	   "'<repeat>" goto finish separators
lex	   "!<repeat>" goto finish separators
lex	   "?<repeat>" goto finish separators
lex	   ".<repeat>" goto finish separators
lex	   ":<repeat>" goto finish separators
lex	   "%<repeat>" goto finish separators
lex	   "," goto finish separators
lex	   ";" goto finish separators
lex
cc	    	   NDL::begin_dispatch ( "'");
cc		      NDL::REPEAT();
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( "!");
cc		      NDL::REPEAT();
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( "?");
cc		      NDL::REPEAT();
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( ".");
cc		      NDL::REPEAT();
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( ":");
cc		      NDL::REPEAT();
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( "%");
cc		      NDL::REPEAT();
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( ",;");
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc

lex	   output NONE goto main;
lex	end separator lexeme table;
lex
cc	    	   NDL::output ( NONE );
cc	    	   NDL::go ( main );
cc	    NDL::end_table();
cc

lex
lex	begin finish separators master table;
lex	    // Come here to end lexeme when next lexeme
lex	    // must be a trailing separator if it has
lex	    // the syntax of such.
lex
cc	    NDL::begin_table ( finish_separators );
cc

lex	   goto separator;
lex	end finish separators master table;
lex
cc	    	   NDL::go ( separator );
cc	    NDL::end_table();
cc

lex
lex	begin finish middle sublexeme table;
lex	    // Come here when type of middle lexeme has
lex	    // been set by an `output' instruction.
lex
cc	    NDL::begin_table ( finish_middle );
cc

lex	   "<middle>" accept;
lex
cc	           NDL::begin_dispatch();
cc		       MIDDLE;
cc		   NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "<trailing><repeat><middle>" accept;
lex	   "<trailing><repeat>"
lex		keep 0 goto finish separators;
lex
cc	           NDL::begin_dispatch ( trailing );
cc	    	       NDL::REPEAT();
cc	               NDL::begin_dispatch();
cc		           MIDDLE;
cc
cc		           NDL::accept();
cc		       NDL::end_dispatch();
cc		       NDL::keep ( 0 );
cc		       NDL::go ( finish_separators );
cc		   NDL::end_dispatch();
cc

lex	   goto main;
lex	end finish middle sublexeme table;
lex
cc	    	   NDL::go ( main );
cc	    NDL::end_table();
cc

lex
lex	begin mark lexeme table;
lex	    // Middle lexeme with no letter or digit yet
lex	    // scanned.  Will be mark if none found.
lex
cc	    NDL::begin_table ( mark );
cc

lex	   "<letter>" output word goto finish middle;
lex
cc	           NDL::begin_dispatch();
cc		       NDL::add_category ( Letter );
cc		       NDL::output ( word_t );
cc		       NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc

lex	   "<digit>" output numeric goto finish middle;
lex
cc	           NDL::begin_dispatch();
cc		       NDL::add_category ( Digit );
cc		       NDL::output ( numeric_t );
cc		       NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc

lex	   "<mark-middle>" accept;
lex
cc	           NDL::begin_dispatch();
cc		       MARK_MIDDLE;
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "<trailing><repeat><letter>"
lex			output word goto
lex			finish middle;
lex	   "<trailing><repeat><digit>"
lex			output numeric
lex			goto finish middle;
lex	   "<trailing><repeat><mark-middle>" accept;
lex	   "<trailing><repeat>"
lex		keep 0 goto finish separators;
lex
cc	           NDL::begin_dispatch ( trailing );
cc	    	       NDL::REPEAT();
cc
cc	               NDL::begin_dispatch();
cc		           NDL::add_category ( Letter );
cc		           NDL::output ( word_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc
cc	               NDL::begin_dispatch();
cc		           NDL::add_category ( Digit );
cc		           NDL::output ( numeric_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc
cc	               NDL::begin_dispatch();
cc		           MARK_MIDDLE;
cc		           NDL::accept();
cc		       NDL::end_dispatch();
cc
cc		       NDL::keep ( 0 );
cc		       NDL::go ( finish_separators );
cc		   NDL::end_dispatch();
cc

lex	   goto main;
lex	end mark lexeme table;
lex
cc	    	   NDL::go ( main );
cc	    NDL::end_table();
cc

lex
lex	begin leading zero sublexeme table;
lex
cc	    NDL::begin_table ( leading_zero );
cc

lex	   "<middle>"
lex		output numeric goto finish middle
lex	   "<trailing><repeat><middle>"
lex		output numeric goto finish middle;
lex	   "<trailing><repeat>"
lex		output natural keep 0
lex		goto finish separators
lex
cc	    	   NDL::begin_dispatch();
cc		      MIDDLE;
cc		      NDL::output ( numeric_t );
cc		      NDL::go ( finish_middle );
cc	    	   NDL::end_dispatch();
cc
cc	           NDL::begin_dispatch ( trailing );
cc	    	       NDL::REPEAT();
cc	               NDL::begin_dispatch();
cc		           MIDDLE;
cc
cc		           NDL::output ( numeric_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc		       NDL::output ( natural_t );
cc		       NDL::keep ( 0 );
cc		       NDL::go ( finish_separators );
cc		   NDL::end_dispatch();
cc

lex	   output natural goto main;
lex	end leading zero sublexeme table;
lex
cc	    	   NDL::output ( natural_t );
cc	    	   NDL::go ( main );
cc	    NDL::end_table();
cc

lex
lex	begin natural lexeme table;
lex
cc	    NDL::begin_table ( natural );
cc

lex	   "0-9" accept;
lex
cc	           NDL::begin_dispatch ( "0123456789" );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "<non-ASCII-digit>" output numeric
lex			       goto finish middle;
lex	   "<letter>"          output numeric
lex			       goto finish middle;
lex	   "<mark-middle>"     output numeric
lex			       goto finish middle;
lex
cc	    	   NDL::begin_dispatch();
cc		      NDL::add_category ( Letter );
cc		      NDL::add_category ( Digit );
cc		      NDL::sub_chars ( "0123456789" );
cc		      MARK_MIDDLE;
cc		      NDL::output ( numeric_t );
cc		      NDL::go ( finish_middle );
cc	    	   NDL::end_dispatch();
cc

lex	   "<trailing><repeat><middle>"
lex		output numeric goto finish middle;
lex	   "<trailing><repeat>"
lex		keep 0 goto finish separators;
lex
cc	           NDL::begin_dispatch ( trailing );
cc	    	       NDL::REPEAT();
cc	               NDL::begin_dispatch();
cc		           MIDDLE;
cc		           NDL::output ( numeric_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc		       NDL::keep ( 0 );
cc		       NDL::go ( finish_separators );
cc		   NDL::end_dispatch();
cc

lex	   goto main;
lex	end natural lexeme table;
lex
cc	    	   NDL::go ( main );
cc	    NDL::end_table();
cc

lex
lex	begin quoted string lexeme table;
lex
cc	    NDL::begin_table ( quoted_string );
cc

lex	    "<Q>" translate to "" goto main;
lex	            // End quoted string.
lex
cc	           NDL::begin_dispatch ( "\"" );
cc		      NDL::translate_to ( "" );
cc		      NDL::go ( main );
cc		   NDL::end_dispatch();
cc

lex	    "<" match escaped char
lex	        else match unrecognized escape
lex	             error unrecognized escape
lex	             translate to "<UUC>"
lex	        else accept;
lex
cc		   NDL::begin_dispatch ( "<" );
cc			 NDL::match ( escaped );
cc		      NDL::ELSE();
cc			 NDL::match
cc			  ( unrecognized_escape );
cc			 NDL::erroneous_atom
cc			  ( unrecognized_escape_t );
cc			 NDL::translate_to ( 1, UUC );
cc		      NDL::ELSE();
cc			 NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	    "<HT>"
lex	        error misplaced horizontal
lex	    "<misplaced-horizontal-space>"
lex	        error misplaced horizontal
lex	        translate to " ";
lex
cc	           NDL::begin_dispatch ( "\t" );
cc		      NDL::erroneous_atom
cc			( misplaced_horizontal_t );
cc		   NDL::end_dispatch();
cc
cc	           NDL::begin_dispatch();
cc		      NDL::add_category ( "Zs" );
cc		      NDL::sub_char ( ' ' );
cc		      NDL::erroneous_atom
cc			( misplaced_horizontal_t );
cc		      NDL::translate_to ( " " );
cc		   NDL::end_dispatch();

lex	    "<directly-quotable>" accept;
lex
cc	           NDL::begin_dispatch();
cc		       DIRECTLY_QUOTABLE;
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	    goto premature end of string;
lex	end quoted string lexeme table;
lex
cc		    NDL::go ( premature_end_of_string );
cc	    NDL::end_table();
cc

lex
lex	begin escaped char atom table;
lex
cc	    NDL::begin_table ( escaped );
cc	       NDL::begin_dispatch ( "<" );
cc
cc	#      define BEG(x) NDL::begin_dispatch ( x )
cc	#      define TO(y)  NDL::begin_dispatch \
cc				( ">" ); \
cc				NDL::translate_to \
cc				    ( y ); \
cc			     NDL::end_dispatch()
cc	#      define END    NDL::end_dispatch()
cc

lex	    "<" "ACK" ">" translate to "<ACK>";
cc	          BEG ( "A" ); BEG ( "C" ); BEG ( "K" );
cc		     TO ( "\006" );
cc		  END; END; END;
cc

lex	    "<" "BEL" ">" translate to "<BEL>";
lex	    "<" "BS" ">" translate to "<BS>";
cc	    	  BEG ( "B" );
cc		     BEG ( "E" ); BEG ( "L" );
cc		           TO ( "\007" );
cc		     END; END;
cc		     BEG ( "S" );
cc		        TO ( "\b" );
cc		     END;
cc		  END;
cc

lex	    "<" "CAN" ">" translate to "<CAN>";
lex	    "<" "CR" ">" translate to "<CR>";
cc	          BEG ( "C" );
cc		     BEG ( "A" ); BEG ( "N" );
cc		           TO ( "\030" );
cc		     END; END;
cc		     BEG ( "R" );
cc		        TO ( "\r" );
cc		     END;
cc		  END;
cc

lex	    "<" "DC1" ">" translate to "<DC1>";
lex	    "<" "DC2" ">" translate to "<DC2>";
lex	    "<" "DC3" ">" translate to "<DC3>";
lex	    "<" "DC4" ">" translate to "<DC4>";
lex	    "<" "DEL" ">" translate to "<DEL>";
lex	    "<" "DLE" ">" translate to "<DLE>";
cc	          BEG ( "D" );
cc		     BEG ( "C" );
cc		         BEG ( "1" );
cc		             TO ( "\021" );
cc		         END;
cc		         BEG ( "2" );
cc		             TO ( "\022" );
cc		         END;
cc		         BEG ( "3" );
cc		             TO ( "\023" );
cc		         END;
cc		         BEG ( "4" );
cc		             TO ( "\024" );
cc		         END;
cc		     END;
cc		     BEG ( "E" ); BEG ( "L" );
cc		         TO ( "\177" );
cc		     END; END;
cc		     BEG ( "L" ); BEG ( "E" );
cc		         TO ( "\020" );
cc		     END; END;
cc		  END;
cc

lex	    "<" "EM" ">" translate to "<EM>";
lex	    "<" "ENQ" ">" translate to "<ENQ>";
lex	    "<" "EOT" ">" translate to "<EOT>";
lex	    "<" "ESC" ">" translate to "<ESC>";
lex	    "<" "ETB" ">" translate to "<ETB>";
lex	    "<" "ETX" ">" translate to "<ETX>";
cc	          BEG ( "E" );
cc		     BEG ( "M" );
cc		         TO ( "\031" );
cc		     END;
cc		     BEG ( "N" ); BEG ( "Q" );
cc		         TO ( "\005" );
cc		     END; END;
cc		     BEG ( "O" ); BEG ( "T" );
cc		         TO ( "\004" );
cc		     END; END;
cc		     BEG ( "S" ); BEG ( "C" );
cc		         TO ( "\033" );
cc		     END; END;
cc		     BEG ( "T" );
cc		         BEG ( "B" );
cc		             TO ( "\027" );
cc		         END;
cc		         BEG ( "X" );
cc		             TO ( "\003" );
cc		         END;
cc		     END;
cc		  END;
cc

lex	    "<" "FF" ">" translate to "<FF>";
lex	    "<" "FS" ">" translate to "<FS>";
cc	          BEG ( "F" );
cc		     BEG ( "F" );
cc		        TO ( "\f" );
cc		     END;
cc		     BEG ( "S" );
cc		        TO ( "\034" );
cc		     END;
cc		  END;
cc

lex	    "<" "GS" ">" translate to "<GS>";
cc	          BEG ( "G" ); BEG ( "S" );
cc		     TO ( "\035" );
cc		  END; END;
cc

lex	    "<" "HT" ">" translate to "<HT>";
cc	          BEG ( "H" ); BEG ( "T" );
cc		     TO ( "\t" );
cc		  END; END;
cc

lex	    "<" "LF" ">" translate to "<LF>";
cc	          BEG ( "L" ); BEG ( "F" );
cc		     TO ( "\n" );
cc		  END; END;
cc

lex	    "<" "NAK" ">" translate to "<NAK>";
lex	    "<" "NL" ">" translate to "<NL>";
lex	    "<" "NUL" ">" translate to "<NUL>";
cc	          BEG ( "N" );
cc		     BEG ( "A" ); BEG ( "K" );
cc		        TO ( "\025" );
cc		     END; END;
cc		     BEG ( "L" );
cc		        TO ( "\n" );
cc		     END;
cc		     BEG ( "U" ); BEG ( "L" );
cc		        begin_dispatch ( ">" );
cc		        {
cc			    static uns32 NUL = 0;
cc		            NDL::translate_to
cc				( 1, & NUL );
cc		        }
cc		        end_dispatch();
cc		     END; END;
cc		  END;
cc

lex	    "<" "Q" ">" translate to "<Q>";
cc	          BEG ( "Q" );
cc		     TO ( "\"" );
cc		  END;
cc

lex	    "<" "RS" ">" translate to "<RS>";
cc	          BEG ( "R" ); BEG ( "S" );
cc		     TO ( "\036" );
cc		  END; END;
cc

lex	    "<" "SI" ">" translate to "<SI>";
lex	    "<" "SO" ">" translate to "<SO>";
lex	    "<" "SOH" ">" translate to "<SOH>";
lex	    "<" "SP" ">" translate to "<SP>";
lex	    "<" "STX" ">" translate to "<STX>";
lex	    "<" "SUB" ">" translate to "<SUB>";
lex	    "<" "SYN" ">" translate to "<SYN>";
cc	          BEG ( "S" );
cc		     BEG ( "I" );
cc		         TO ( "\017" );
cc		     END;
cc		     BEG ( "O" );
cc			BEG ( "H" );
cc		            TO ( "\001" );
cc		        END;
cc			TO ( "\016" );
cc		     END;
cc		     BEG ( "P" );
cc		         TO ( " " );
cc		     END;
cc		     BEG ( "T" ); BEG ( "X" );
cc		         TO ( "\002" );
cc		     END; END;
cc		     BEG ( "U" ); BEG ( "B" );
cc		         TO ( "\032" );
cc		     END; END;
cc		     BEG ( "Y" ); BEG ( "N" );
cc		         TO ( "\026" );
cc		     END; END;
cc		  END;
cc

lex	    "<" "US" ">" translate to "<US>";
cc	          BEG ( "U" ); BEG ( "S" );
cc		     TO ( "\037" );
cc		  END; END;
cc

lex	    "<" "VT" ">" translate to "<VT>";
lex
cc	          BEG ( "V" ); BEG ( "T" );
cc		     TO ( "\v" );
cc		  END; END;
cc

cc	#	undef BEG
cc	#	undef TO
cc	#	undef END
cc

lex	    "<" "<0-9>" match escaped hex char
lex	            else fail;
lex
cc	    	    NDL::begin_dispatch();
cc		       NDL::add_chars ( "0123456789" );
cc		       NDL::match ( escaped_hex );
cc		    NDL::ELSE();
cc		       NDL::fail();
cc		    NDL::end_dispatch();
cc	       NDL::end_dispatch();
cc

lex	    fail;
lex	end escaped char atom table;
lex
cc	       NDL::fail();
cc	    NDL::end_table();
cc

lex
lex	begin escaped hex char atom table;
lex
cc	    NDL::begin_table ( escaped_hex );
cc

lex	    "<" "<0-9>" ">" translate hex 1 1;
lex	    "<" "<0-9><hex-digit><repeat>" ">"
lex	              translate hex 1 1;
lex
cc	       NDL::begin_dispatch ( "<" );
cc	    	    NDL::begin_dispatch();
cc		      NDL::add_chars ( "0123456789" );
cc
cc	    	      NDL::begin_dispatch ( ">" );
cc	                NDL::translate_hex ( 1, 1 );
cc	              NDL::end_dispatch();
cc
cc	    	      NDL::begin_dispatch ( hex_digit );
cc	    	        NDL::REPEAT();
cc	    	        NDL::begin_dispatch ( ">" );
cc	                  NDL::translate_hex ( 1, 1 );
cc	                NDL::end_dispatch();
cc
cc	              NDL::end_dispatch();
cc	            NDL::end_dispatch();
cc	       NDL::end_dispatch();
cc

lex	    fail;
lex	end escaped hex char atom table;
lex
cc	    	    NDL::fail();
cc	    NDL::end_table();
cc

lex
lex	begin unrecognized escape atom table;
lex
cc	    NDL::begin_table ( unrecognized_escape );
cc

lex	    "<" "<escape><repeat>" ">" accept
lex
cc	       NDL::begin_dispatch ( "<" );
cc	            NDL::begin_dispatch ( escape );
cc	    	        NDL::REPEAT();
cc	    	        NDL::begin_dispatch ( ">" );
cc	                  NDL::accept();
cc	                NDL::end_dispatch();
cc	            NDL::end_dispatch();
cc	       NDL::end_dispatch();
cc

lex	    fail;
lex	end unrecognized escape atom table;
lex
cc	    	    NDL::fail();
cc	    NDL::end_table();
cc

lex
lex	begin premature end of string master table;
lex
cc	    NDL::begin_table
cc		( premature_end_of_string );
cc

lex	    output premature end of string goto main;
lex	end premature end of string master table;
lex
cc	        NDL::output
cc		    ( premature_end_of_string_t );
cc		NDL::go ( main );
cc	    NDL::end_table();
cc

lex
lex	begin end of file master table;
lex	    output end of file goto stop
lex	end end of file master table;
lex
cc	    NDL::begin_table ( end_of_file );
cc	        NDL::output ( end_of_file_t );
cc	        NDL::go ( stop );
cc	    NDL::end_table();
cc

lex
lex	begin stop master table;
lex	end stop master table;
lex
cc	    NDL::begin_table ( stop );
cc	    NDL::end_table();
cc

lex
lex	end standard lexical program;
cc	    NDL::end_program();
cc
cc	    LEXSTD::default_program =
cc		LEX::default_program;
cc	}
