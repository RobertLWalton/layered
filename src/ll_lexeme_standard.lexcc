// Layered Languages Standard Lexical Analyzer
//
// File:	ll_lexeme_standard.lexcc
// Author:	Bob Walton (walton@acm.org)
// Date:	Sun Nov  6 21:05:57 EST 2016
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.

// Lines beginning with `lex<HT>' and lines equal to
// `lex' are copied to ll_lexeme_standard.lex and then
// to the Standard Lexical Program appendix of ../doc/
// layered-introduction.tex.
//
// Lines beginning with `cc<HT>' and lines equal to `cc'
// are copied to ll_lexeme_standard.cc and compiled to
// produce code that can create a standard lexical
// program.

// Table of Contents
//
//	Usage and Setup
//	Program Construction

// Usage and Setup
// ----- --- -----

lex	// This file was automatically generated from
lex	// ll_lexeme_standard.lexcc.
lex
cc	// This file was automatically generated from
cc	// ll_lexeme_standard.lexcc.
cc
cc	# include <ll_lexeme_ndl.h>
cc	# include <ll_lexeme_standard.h>
cc	using namespace ll::lexeme::ndl;
cc	# define LEX ll::lexeme
cc	# define LEXSTD ll::lexeme::standard
cc	using namespace LEXSTD;
cc
cc	const min::Uchar UUC[1] =
cc	    { min::UNKNOWN_UCHAR };
cc
cc	# define indent_bc_t indent_before_comment_t

// Program Construction
// ------- ------------

cc	min::locatable_var<LEX::program>
cc	    LEXSTD::default_program;
cc
cc	const char * const
cc		LEXSTD::master_names[1] = { "MAIN" };
cc
cc	const char * const
cc		LEXSTD::type_names[MAX_TYPE+1] = {
cc
cc	    NULL,
cc	    "WORD",
cc	    "NATURAL",
cc	    "NUMERIC",
cc	    "MARK",
cc	    "QUOTED_STRING",
cc	    "SEPARATOR",
cc	    "COMMENT",
cc	    "HORIZONTAL_SPACE",
cc	    "INDENT_BEFORE_COMMENT",
cc	    "INDENT",
cc	    "LINE_BREAK",
cc	    "END_OF_FILE",
cc	    "PREMATURE_END_OF_STRING",
cc	    "PREMATURE_END_OF_FILE",
cc	    "MISPLACED_VERTICAL",
cc	    "ILLEGAL_CONTROL",
cc	    "UNRECOGNIZED_CHARACTER",
cc	    "UNRECOGNIZED_ESCAPE",
cc	    "MISPLACED_HORIZONTAL" };
cc
cc	const char * LEXSTD::type_codes =
cc	    "?wn#mqschIibeSFVCUEH";
cc
cc	void LEXSTD::init_standard_program
cc		( void )
cc	{
cc	    if ( LEXSTD::default_program != NULL_STUB )
cc	        return;
cc

lex
lex	begin standard lexical program;
lex
cc	    begin_program
cc		( master_names, 0,
cc	          type_names, type_codes, MAX_TYPE );
cc
cc	    uns32 begin_line;
cc	    NDL::new_table ( begin_line, MASTER, 0 );
cc	    uns32 within_line;
cc	    NDL::new_table ( within_line, MASTER );
cc
cc	    uns32 horizontal_space;
cc	    NDL::new_table ( horizontal_space );
cc
cc	    uns32 separator;
cc	    NDL::new_table ( separator, separator_t );
cc	    uns32 finish_separators;
cc	    NDL::new_table
cc		( finish_separators, MASTER );
cc	    uns32 finish_middle;
cc	    NDL::new_table ( finish_middle );
cc	    uns32 leading_zero;
cc	    NDL::new_table ( leading_zero );
cc	    uns32 natural;
cc	    NDL::new_table ( natural, natural_t );
cc	    uns32 mark;
cc	    NDL::new_table ( mark, mark_t );
cc
cc	    uns32 quoted_string;
cc	    NDL::new_table
cc		( quoted_string, quoted_string_t );
cc	    uns32 comment;
cc	    NDL::new_table ( comment, comment_t );
cc
cc	    uns32 line_break;
cc	    NDL::new_table ( line_break, line_break_t );
cc
cc	    uns32 premature_end_of_string;
cc	    NDL::new_table
cc		( premature_end_of_string, MASTER );
cc	    uns32 end_of_file;
cc	    NDL::new_table
cc		( end_of_file, MASTER );
cc	    uns32 stop;
cc	    NDL::new_table
cc		( stop, MASTER );
cc

lex	"<horizontal>" = "<UNICODE-CATEGORY-Zs>"
lex		       | "<HT>";
lex
cc	# define HORIZONTAL \
cc	           NDL::add_category ( "Zs" ); \
cc	           NDL::add_char ( '\t' )
cc

lex	"<misplaced-horizontal>" =
lex		  "<horizontal>"
lex		& ~ "<SP>";
lex
cc	# define MISPLACED_HORIZONTAL \
cc	           NDL::add_category ( "Zs" ); \
cc	           NDL::add_char ( '\t' ); \
cc	           NDL::sub_char ( ' ' )
cc

lex	"<vertical>" = "<CR>" | "<VT>" | "<FF>"
lex
cc	    const char * vertical = "\r\v\f";
cc

lex	"<graphic>" = "<UNICODE-CATEGORY-L>"
lex		    | "<UNICODE-CATEGORY-M>"
lex		    | "<UNICODE-CATEGORY-N>"
lex		    | "<UNICODE-CATEGORY-P>"
lex		    | "<UNICODE-CATEGORY-S>"
lex
cc	# define GRAPHIC \
cc	           NDL::add_category ( "L" ); \
cc	           NDL::add_category ( "M" ); \
cc	           NDL::add_category ( "N" ); \
cc	           NDL::add_category ( "P" ); \
cc	           NDL::add_category ( "S" )
cc

lex	"<non-/-graphic>" = "<graphic> & ~ "/";
lex
cc	# define NON_SLASH_GRAPHIC \
cc	           GRAPHIC; \
cc	           NDL::sub_char ( '/' )
cc

lex	"<control>" = "<UNICODE-CATEGORY-C>"
lex		    | "<UNICODE-CATEGORY-Z>"
lex

lex	"<illegal-control>" = "<control>"
lex			    & ~ "<horizontal>"
lex			    & ~ "<vertical>"
lex			    & ~ "<LF>"
lex
cc	# define ILLEGAL_CONTROL \
cc	           NDL::add_category ( "C" ); \
cc	           NDL::add_category ( "Z" ); \
cc	           NDL::sub_category ( "Zs" ); \
cc	           NDL::sub_chars ( vertical ); \
cc	           NDL::sub_chars ( "\t\n" )
cc

lex	"<isolated-separator>"
lex		= "<UNICODE-CATEGORY-Ps>"
lex	        | "<UNICODE-CATEGORY-Pi>"
lex	        | "<UNICODE-CATEGORY-Pe>"
lex	        | "<UNICODE-CATEGORY-Pf>"
lex
cc	# define ISOLATED_SEPARATOR \
cc	           NDL::add_category ( "Ps" ); \
cc	           NDL::add_category ( "Pi" ); \
cc	           NDL::add_category ( "Pe" ); \
cc	           NDL::add_category ( "Pf" )
cc	# define SUB_ISOLATED_SEPARATOR \
cc	           NDL::sub_category ( "Ps" ); \
cc	           NDL::sub_category ( "Pi" ); \
cc	           NDL::sub_category ( "Pe" ); \
cc	           NDL::sub_category ( "Pf" )
cc

lex	"<repeating-separator>" = "|"
lex

lex	"<separator>"
lex		= "<isolated-separator>"
lex		| "<repeating-separator>"
lex

lex	"<leading>"
lex		= "`"
lex	        | "<0A1>"  // Inverted !
lex	        | "<0BF>"  // Inverted ?
lex
cc	    // const char * leading = "`\xA1\xBF";
cc	    //     // Unused
cc

lex	"<trailing>"
lex		= "'" | "!" | "?" | "." | ":"
lex		| "," | ";"
lex
cc	    const char * trailing = "'!?.:,;";
cc

lex	"<letter>" = "<UNICODE-CATEGORY-L>"
lex
cc	    const char * Letter = "L";
cc

lex	"<digit>" = "<UNICODE-CATEGORY-Nd>"
lex
cc	    const char * Digit = "Nd";
cc

lex	"<non-ASCII-digit>" = "<digit> & ~ "0-9"
lex

lex	"<mark>" = (   "<UNICODE-CATEGORY-P>"
lex		     | "<UNICODE-CATEGORY-S>"
lex		     | "<UNICODE-CATEGORY-M>"
lex		     | "<UNICODE-CATEGORY-N>" )
lex		 & ~ "<digit>"
lex		 & ~ "<separator>"
lex		 & ~ "<Q>"
lex

lex	"<middle>" =   "<graphic>"
lex		   & ~ "<trailing>"
lex		   & ~ "<separator>"
lex		   & ~ "<Q>"
lex
cc	# define MIDDLE \
cc	           GRAPHIC; \
cc	           SUB_ISOLATED_SEPARATOR; \
cc	           NDL::sub_chars ( "|\"" ); \
cc	           NDL::sub_chars ( trailing )
cc

lex	"<mark-middle>" = "<mark>" & ~ "<trailing>"
lex
cc	# define MARK_MIDDLE \
cc	           NDL::add_category ( "P" ); \
cc	           NDL::add_category ( "S" ); \
cc	           NDL::add_category ( "M" ); \
cc	           NDL::add_category ( "N" ); \
cc	           NDL::sub_category ( Digit ); \
cc	           SUB_ISOLATED_SEPARATOR; \
cc	           NDL::sub_chars ( "|\"" ); \
cc	           NDL::sub_chars ( trailing )
cc

lex	"<directly-quotable>" = (     "<graphic>"
lex				  & ~ "<"
lex				  & ~ "<Q>" )
lex			      | "<SP>"
lex
cc	# define DIRECTLY_QUOTABLE \
cc	           GRAPHIC; \
cc	           NDL::sub_chars ( "<\"" ); \
cc	           NDL::add_chars ( " " )
cc

lex	"<escape>" = "A-Z" | "0-9"
lex
cc	    const char * escape =
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
cc

lex
lex	begin begin line master table;
lex
cc	    NDL::begin_table ( begin_line );
cc

lex	   "<horizontal><repeat>//"
lex			keep 1
lex			output indent before comment
lex			goto horizontal space
lex	   "<horizontal><repeat>/"
lex			keep 1
lex			output indent
lex			goto horizontal space
lex	   "<horizontal><repeat><non-/-graphic>"
lex			keep 1
lex			output indent
lex			goto horizontal space
lex	   "<horizontal><repeat>"
lex			output horizontal space
lex
cc		   NDL::begin_dispatch();
cc		      HORIZONTAL;
cc		      NDL::REPEAT();
cc
cc		      NDL::begin_dispatch ( "/" );
cc		         NDL::begin_dispatch ( "/" );
cc		            NDL::keep ( 1 );
cc		            NDL::output ( indent_bc_t );
cc		            NDL::go
cc			       ( horizontal_space );
cc		         NDL::end_dispatch();
cc		         NDL::keep ( 1 );
cc		         NDL::output ( indent_t );
cc		         NDL::go ( horizontal_space );
cc		      NDL::end_dispatch();
cc
cc		      NDL::begin_dispatch();
cc		         NON_SLASH_GRAPHIC;
cc		         NDL::keep ( 1 );
cc		         NDL::output ( indent_t );
cc		         NDL::go ( horizontal_space );
cc		      NDL::end_dispatch();
cc
cc		      NDL::output
cc			    ( horizontal_space_t );
cc		   NDL::end_dispatch();
cc

lex	   "//" keep 0
lex		output indent before comment
lex		goto within line	
lex	   "/"  keep 0
lex		output indent
lex		goto within line	
lex	   "<non-/-graphic>"
lex		keep 0
lex		output indent
lex		goto within line
lex
cc		   NDL::begin_dispatch ( "/" );
cc		      NDL::begin_dispatch ( "/" );
cc		         NDL::keep ( 0 );
cc		         NDL::output ( indent_bc_t );
cc		         NDL::go ( within_line );
cc		      NDL::end_dispatch();
cc		      NDL::keep ( 0 );
cc		      NDL::output ( indent_t );
cc		      NDL::go ( within_line );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch();
cc		      NON_SLASH_GRAPHIC;
cc		      NDL::keep ( 0 );
cc		      NDL::output ( indent_t );
cc		      NDL::go ( within_line );
cc		   NDL::end_dispatch();
cc

lex	   "<LF>" goto line break
lex
cc		   NDL::begin_dispatch ( "\n" );
cc		      NDL::go ( line_break );
cc		   NDL::end_dispatch();
cc

lex	   "<vertical><repeat><LF>" goto line break
lex	   "<vertical><repeat>"
lex			output misplaced vertical
lex
cc		   NDL::begin_dispatch ( vertical );
cc		      NDL::REPEAT();
cc		      NDL::begin_dispatch ( "\n" );
cc		         NDL::go ( line_break );
cc		      NDL::end_dispatch();
cc		      NDL::output
cc		            ( misplaced_vertical_t );
cc		   NDL::end_dispatch();
cc

lex	   "<illegal-control><repeat>"
lex	        output illegal control
lex
cc		   NDL::begin_dispatch(); 
cc		      ILLEGAL_CONTROL;
cc		      NDL::REPEAT();
cc		      NDL::output
cc			  ( illegal_control_t );
cc		   NDL::end_dispatch();
cc

lex	   "<others><repeat>"
lex		error unrecognized character
lex
cc	    	   NDL::begin_dispatch ( OTHERS );
cc		      NDL::REPEAT();
cc		      NDL::output
cc			( unrecognized_character_t );
cc	    	   NDL::end_dispatch();
cc

lex	   output premature end of file goto end of file
lex		// End of file not following a line
lex		// break
lex	end begin line master table;
lex
cc		   NDL::output
cc			( premature_end_of_file_t );
cc		   NDL::go ( end_of_file );
cc
cc	    NDL::end_table();
cc

lex
lex	begin horizontal space sublexeme table;
lex
cc	    NDL::begin_table ( horizontal_space );
cc

lex	   "<horizontal>" accept;
lex
cc		   NDL::begin_dispatch();
cc		      HORIZONTAL;
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   goto within line;
lex	end horizontal space sublexeme table;
lex
cc	    	   NDL::go ( within_line );
cc
cc	    NDL::end_table();
cc

lex
lex	begin within line master table;
lex
cc	    NDL::begin_table ( within_line );
cc

lex	   "//" goto comment;
lex	   "/"  goto mark;
lex
cc		   NDL::begin_dispatch ( "/" );
cc		      NDL::begin_dispatch ( "/" );
cc			 NDL::go ( comment );
cc		      NDL::end_dispatch();
cc
cc		      NDL::go ( mark );
cc		   NDL::end_dispatch();
cc

lex	   "<horizontal><repeat>"
lex	        output horizontal space;
lex
cc		   NDL::begin_dispatch ( "\t" );
cc		      NDL::add_category ( "Zs" );
cc		      NDL::REPEAT();
cc		      NDL::output
cc			    ( horizontal_space_t );
cc		   NDL::end_dispatch();
cc

lex	   "<LF>" goto line break
lex
cc		   NDL::begin_dispatch ( "\n" );
cc		      NDL::go ( line_break );
cc		   NDL::end_dispatch();
cc

lex	   "<vertical><repeat><LF>" goto line break
lex	   "<vertical><repeat>"
lex			output misplaced vertical
lex
cc		   NDL::begin_dispatch ( vertical );
cc		      NDL::REPEAT();
cc		      NDL::begin_dispatch ( "\n" );
cc		         NDL::go ( line_break );
cc		      NDL::end_dispatch();
cc		      NDL::output
cc		            ( misplaced_vertical_t );
cc		   NDL::end_dispatch();
cc

lex	   "<illegal-control><repeat>"
lex	        output illegal control
lex
cc		   NDL::begin_dispatch(); 
cc		      ILLEGAL_CONTROL;
cc		      NDL::REPEAT();
cc		      NDL::output
cc			  ( illegal_control_t );
cc		   NDL::end_dispatch();
cc

lex	   "<isolated-separator>" output separator;
lex	   "`" output separator;
lex	   "|<repeat>" output separator;
lex	   "<0A1><repeat>" output separator;
lex		// Inverted !
lex	   "<0BF><repeat>" output separator;
lex		// Inverted ?
lex
cc	    	   NDL::begin_dispatch();
cc		      ISOLATED_SEPARATOR;
cc		      NDL::add_char ( '`' );
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( "|" );
cc		      NDL::REPEAT();
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch();
cc		      NDL::add_char ( 0xA1 );
cc		      NDL::REPEAT();
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch();
cc		      NDL::add_char ( 0xBF );
cc		      NDL::REPEAT();
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc

lex	   "<trailing><repeat><letter>"
lex			output word
lex			goto finish middle;
lex	   "<trailing><repeat><digit>"
lex			output numeric
lex			goto finish middle;
lex	   "<trailing><repeat><mark-middle>"
lex			goto mark
lex	   "<trailing><repeat>"
lex			keep 0
lex			goto separator;
lex
cc	           NDL::begin_dispatch ( trailing );
cc	    	       NDL::REPEAT();
cc
cc	               NDL::begin_dispatch();
cc		           NDL::add_category ( Letter );
cc		           NDL::output ( word_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc
cc	               NDL::begin_dispatch();
cc		           NDL::add_category ( Digit );
cc		           NDL::output ( numeric_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc
cc	               NDL::begin_dispatch();
cc		           MARK_MIDDLE;
cc		           NDL::go ( mark );
cc		       NDL::end_dispatch();
cc
cc		       NDL::keep ( 0 );
cc		       NDL::go ( separator );
cc		   NDL::end_dispatch();
cc

lex	   "<letter>" output word goto finish middle;
lex
cc	    	   NDL::begin_dispatch ( );
cc		      NDL::add_category ( "L" );
cc		      NDL::output ( word_t );
cc		      NDL::go ( finish_middle );
cc	    	   NDL::end_dispatch();
cc

lex	   "0" goto leading zero;
lex
cc	    	   NDL::begin_dispatch ( "0" );
cc		      NDL::go ( leading_zero );
cc	    	   NDL::end_dispatch();
cc

lex	   "1-9" goto natural;
lex
cc	    	   NDL::begin_dispatch ( "123456789" );
cc		      NDL::go ( natural );
cc	    	   NDL::end_dispatch();
cc

lex	   "<non-ASCII-digit>" output numeric
lex			       goto finish middle;
lex
cc	    	   NDL::begin_dispatch();
cc		      NDL::add_category ( Digit );
cc		      NDL::sub_chars ( "0123456789" );
cc		      NDL::output ( numeric_t );
cc		      NDL::go ( finish_middle );
cc	    	   NDL::end_dispatch();
cc

lex	   "<mark-middle>" goto mark;
lex
cc	    	   NDL::begin_dispatch();
cc		      MARK_MIDDLE;
cc		      NDL::go ( mark );
cc	    	   NDL::end_dispatch();
cc

lex	   "<Q>" translate to "" goto quoted string;
lex
cc	    	   NDL::begin_dispatch ( "\"" );
cc		      NDL::translate_to ( "" );
cc		      NDL::go ( quoted_string );
cc	    	   NDL::end_dispatch();
cc

lex	   "<others><repeat>"
lex		error unrecognized character
lex
cc	    	   NDL::begin_dispatch ( OTHERS );
cc		      NDL::REPEAT();
cc		      NDL::output
cc			( unrecognized_character_t );
cc	    	   NDL::end_dispatch();
cc

lex	   output premature end of file goto end of file
lex		// End of file not following a line
lex		// break
lex	end within line master table;
lex
cc		   NDL::output
cc			( premature_end_of_file_t );
cc		   NDL::go ( end_of_file );
cc
cc	    NDL::end_table();
cc

lex
lex	// The below tables are entered from the master
lex	// table with the first atom scanned, unless
lex	// otherwise indicated.
lex
lex	begin comment lexeme table;
lex
cc	    NDL::begin_table ( comment );
cc

lex	   "<graphic>" accept
lex	   "<horizontal>" accept
lex
cc		   NDL::begin_dispatch ( "\t" );
cc		       GRAPHIC;
cc		       NDL::add_category ( "Zs" );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "<LF>" keep 0 goto within line
lex	   "<vertical><repeat><LF>" keep 0
lex				    goto within line
lex	   "<vertical><repeat>"
lex		error mispaced vertical
lex	   "<illegal-control><repeat>"
lex		error illegal control
lex	   "<others><repeat>"
lex		error unrecognized character
cc		   NDL::begin_dispatch ( "\n" );
cc		       NDL::keep ( 0 );
cc		       NDL::go ( within_line );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( vertical );
cc		       NDL::REPEAT();
cc		       NDL::begin_dispatch ( "\n" );
cc		           NDL::keep ( 0 );
cc		           NDL::go ( within_line );
cc		       NDL::end_dispatch();
cc		       NDL::erroneous_atom
cc			   ( misplaced_vertical_t );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch();
cc		       ILLEGAL_CONTROL;
cc		       NDL::REPEAT();
cc		       NDL::erroneous_atom
cc			   ( illegal_control_t );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( OTHERS );
cc		       NDL::REPEAT();
cc		       NDL::erroneous_atom
cc			   ( unrecognized_character_t );
cc		   NDL::end_dispatch();
cc

lex	   goto within line
lex	      // which will output premature end of file
lex	end comment lexeme table;
lex
cc	           NDL::go ( within_line );
cc
cc	    NDL::end_table();
cc

lex
lex	begin line break lexeme table;
lex
cc	    NDL::begin_table ( line_break );
cc

lex	   "<vertical>" accept;
lex
cc	           NDL::begin_dispatch ( vertical );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "<others>" keep 0 goto begin line
lex
cc	           NDL::begin_dispatch ( OTHERS );
cc		       NDL::keep ( 0 );
cc	    	       NDL::go ( begin_line );
cc		   NDL::end_dispatch();
cc

lex	    goto end of file
lex	end line break lexeme table;
lex
cc	        NDL::go ( end_of_file );
cc
cc	    NDL::end_table();
cc

lex
lex	begin separator lexeme table;
lex	    // First atom is not scanned; next lexeme
lex	    // must be a trailing separator if it has
lex	    // the syntax of such.
lex
cc	    NDL::begin_table ( separator );
cc

lex	   "!<repeat>" goto finish separators
lex	   "?<repeat>" goto finish separators
lex	   ".<repeat>" goto finish separators
lex	   ":<repeat>" goto finish separators
lex	   "'" goto finish separators
lex	   "," goto finish separators
lex	   ";" goto finish separators
lex
cc	    	   NDL::begin_dispatch ( "!");
cc		      NDL::REPEAT();
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( "?");
cc		      NDL::REPEAT();
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( ".");
cc		      NDL::REPEAT();
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( ":");
cc		      NDL::REPEAT();
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( "',;");
cc		      NDL::go ( finish_separators );
cc	    	   NDL::end_dispatch();
cc

lex	   output NONE goto within line;
lex	end separator lexeme table;
lex
cc	    	   NDL::output ( NONE );
cc	    	   NDL::go ( within_line );
cc
cc	    NDL::end_table();
cc

lex
lex	begin finish separators master table;
lex	    // Come here to end lexeme when next lexeme
lex	    // must be a trailing separator if it has
lex	    // the syntax of such.
lex
cc	    NDL::begin_table ( finish_separators );
cc

lex	   goto separator;
lex	end finish separators master table;
lex
cc	    	   NDL::go ( separator );
cc
cc	    NDL::end_table();
cc

lex
lex	begin finish middle sublexeme table;
lex	    // Come here when type of middle lexeme has
lex	    // been set by an `output' instruction.
lex
cc	    NDL::begin_table ( finish_middle );
cc

lex	   "<middle>" accept;
lex
cc	           NDL::begin_dispatch();
cc		       MIDDLE;
cc		   NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "<trailing><repeat><middle>" accept;
lex	   "<trailing><repeat>"
lex		keep 0 goto finish separators;
lex
cc	           NDL::begin_dispatch ( trailing );
cc	    	       NDL::REPEAT();
cc	               NDL::begin_dispatch();
cc		           MIDDLE;
cc
cc		           NDL::accept();
cc		       NDL::end_dispatch();
cc		       NDL::keep ( 0 );
cc		       NDL::go ( finish_separators );
cc		   NDL::end_dispatch();
cc

lex	   goto within line;
lex	end finish middle sublexeme table;
lex
cc	    	   NDL::go ( within_line );
cc
cc	    NDL::end_table();
cc

lex
lex	begin mark lexeme table;
lex	    // Middle lexeme with no letter or digit yet
lex	    // scanned.  Will be mark if none found.
lex
cc	    NDL::begin_table ( mark );
cc

lex	   "<letter>" output word goto finish middle;
lex
cc	           NDL::begin_dispatch();
cc		       NDL::add_category ( Letter );
cc		       NDL::output ( word_t );
cc		       NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc

lex	   "<digit>" output numeric goto finish middle;
lex
cc	           NDL::begin_dispatch();
cc		       NDL::add_category ( Digit );
cc		       NDL::output ( numeric_t );
cc		       NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc

lex	   "<mark-middle>" accept;
lex
cc	           NDL::begin_dispatch();
cc		       MARK_MIDDLE;
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "<trailing><repeat><letter>"
lex			output word
lex			goto finish middle;
lex	   "<trailing><repeat><digit>"
lex			output numeric
lex			goto finish middle;
lex	   "<trailing><repeat><mark-middle>" accept;
lex	   "<trailing><repeat>"
lex		keep 0 goto finish separators;
lex
cc	           NDL::begin_dispatch ( trailing );
cc	    	       NDL::REPEAT();
cc
cc	               NDL::begin_dispatch();
cc		           NDL::add_category ( Letter );
cc		           NDL::output ( word_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc
cc	               NDL::begin_dispatch();
cc		           NDL::add_category ( Digit );
cc		           NDL::output ( numeric_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc
cc	               NDL::begin_dispatch();
cc		           MARK_MIDDLE;
cc		           NDL::accept();
cc		       NDL::end_dispatch();
cc
cc		       NDL::keep ( 0 );
cc		       NDL::go ( finish_separators );
cc		   NDL::end_dispatch();
cc

lex	   goto within line;
lex	end mark lexeme table;
lex
cc	    	   NDL::go ( within_line );
cc
cc	    NDL::end_table();
cc

lex
lex	begin leading zero sublexeme table;
lex
cc	    NDL::begin_table ( leading_zero );
cc

lex	   "<middle>"
lex		output numeric goto finish middle
lex	   "<trailing><repeat><middle>"
lex		output numeric goto finish middle;
lex	   "<trailing><repeat>"
lex		output natural keep 0
lex		goto finish separators
lex
cc	    	   NDL::begin_dispatch();
cc		      MIDDLE;
cc		      NDL::output ( numeric_t );
cc		      NDL::go ( finish_middle );
cc	    	   NDL::end_dispatch();
cc
cc	           NDL::begin_dispatch ( trailing );
cc	    	       NDL::REPEAT();
cc	               NDL::begin_dispatch();
cc		           MIDDLE;
cc
cc		           NDL::output ( numeric_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc		       NDL::output ( natural_t );
cc		       NDL::keep ( 0 );
cc		       NDL::go ( finish_separators );
cc		   NDL::end_dispatch();
cc

lex	   output natural goto within line;
lex	end leading zero sublexeme table;
lex
cc	    	   NDL::output ( natural_t );
cc	    	   NDL::go ( within_line );
cc
cc	    NDL::end_table();
cc

lex
lex	begin natural lexeme table;
lex
cc	    NDL::begin_table ( natural );
cc

lex	   "0-9" accept;
lex
cc	           NDL::begin_dispatch ( "0123456789" );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "<non-ASCII-digit>" output numeric
lex			       goto finish middle;
lex	   "<letter>"          output numeric
lex			       goto finish middle;
lex	   "<mark-middle>"     output numeric
lex			       goto finish middle;
lex
cc	    	   NDL::begin_dispatch();
cc		      NDL::add_category ( Letter );
cc		      NDL::add_category ( Digit );
cc		      NDL::sub_chars ( "0123456789" );
cc		      MARK_MIDDLE;
cc		      NDL::output ( numeric_t );
cc		      NDL::go ( finish_middle );
cc	    	   NDL::end_dispatch();
cc

lex	   "<trailing><repeat><middle>"
lex		output numeric goto finish middle;
lex	   "<trailing><repeat>"
lex		keep 0 goto finish separators;
lex
cc	           NDL::begin_dispatch ( trailing );
cc	    	       NDL::REPEAT();
cc	               NDL::begin_dispatch();
cc		           MIDDLE;
cc		           NDL::output ( numeric_t );
cc		           NDL::go ( finish_middle );
cc		       NDL::end_dispatch();
cc		       NDL::keep ( 0 );
cc		       NDL::go ( finish_separators );
cc		   NDL::end_dispatch();
cc

lex	   goto within line;
lex	end natural lexeme table;
lex
cc	    	   NDL::go ( within_line );
cc
cc	    NDL::end_table();
cc

lex
lex	begin quoted string lexeme table;
lex
cc	    NDL::begin_table ( quoted_string );
cc

lex	    "<Q>" translate to "" goto within line;
lex	            // End quoted string.
lex
cc	           NDL::begin_dispatch ( "\"" );
cc		      NDL::translate_to ( "" );
cc		      NDL::go ( within_line );
cc		   NDL::end_dispatch();
cc

lex	    "<" "<0-9>" ">"
lex		translate hex 1 1
lex	    "<" "<0-9><escape><repeat>" ">"
lex	        translate hex 1 1
lex	        else error unrecognized escape
lex	             translate to "<UUC>"
lex	    "<" "<A-Z>" ">"
lex		     translate name 1 1
lex	        else error unrecognized escape
lex	             translate to "<UUC>"
lex	    "<" "<A-Z><escape><repeat>" ">"
lex	           translate name 1 1
lex	        else error unrecognized escape
lex	             translate to "<UUC>"
lex	    "<"
lex	        accept;
lex
lex
cc	       NDL::begin_dispatch ( "<" );
cc	    	 NDL::begin_dispatch();
cc		   NDL::add_chars ( "0123456789" );
cc
cc	    	   NDL::begin_dispatch ( ">" );
cc	             NDL::translate_hex ( 1, 1 );
cc	           NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( escape );
cc	    	     NDL::REPEAT();
cc	    	     NDL::begin_dispatch ( ">" );
cc	                  NDL::translate_hex ( 1, 1 );
cc		       NDL::ELSE();
cc			  NDL::erroneous_atom
cc			   ( unrecognized_escape_t );
cc			  NDL::translate_to ( 1, UUC );
cc	             NDL::end_dispatch();
cc
cc	           NDL::end_dispatch();
cc	         NDL::end_dispatch();
cc
cc	    	 NDL::begin_dispatch();
cc		   NDL::add_chars
cc		     ( "ABCDEFGHIJKLMNOPQRSTUVWXYZ" );
cc
cc	    	   NDL::begin_dispatch ( ">" );
cc	                NDL::translate_name ( 1, 1 );
cc		     NDL::ELSE();
cc			NDL::erroneous_atom
cc			      ( unrecognized_escape_t );
cc			NDL::translate_to ( 1, UUC );
cc	           NDL::end_dispatch();
cc
cc	    	   NDL::begin_dispatch ( escape );
cc	    	     NDL::REPEAT();
cc	    	     NDL::begin_dispatch ( ">" );
cc	                  NDL::translate_name ( 1, 1 );
cc		       NDL::ELSE();
cc			  NDL::erroneous_atom
cc			      ( unrecognized_escape_t );
cc			  NDL::translate_to ( 1, UUC );
cc	             NDL::end_dispatch();
cc
cc	           NDL::end_dispatch();
cc	         NDL::end_dispatch();
cc
cc		 NDL::accept();
cc	       NDL::end_dispatch();
cc

lex	    "<directly-quotable>" accept;
lex
cc	           NDL::begin_dispatch();
cc		       DIRECTLY_QUOTABLE;
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "<LF>"
lex		keep 0 goto premature end of string
lex	   "<vertical><repeat><LF>"
lex		keep 0 goto premature end of string
lex	   "<vertical><repeat>"
lex		error mispaced vertical
lex	    "<misplaced-horizontal><repeat>"
lex	        error misplaced horizontal
lex	   "<illegal-control><repeat>"
lex		error illegal control
lex	   "<others><repeat>"
lex		error unrecognized character
lex
cc		   NDL::begin_dispatch ( "\n" );
cc		       NDL::keep ( 0 );
cc		       NDL::go
cc			   ( premature_end_of_string );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( vertical );
cc		       NDL::REPEAT();
cc		       NDL::begin_dispatch ( "\n" );
cc		           NDL::keep ( 0 );
cc		           NDL::go
cc			    ( premature_end_of_string );
cc		       NDL::end_dispatch();
cc		       NDL::erroneous_atom
cc			   ( misplaced_vertical_t );
cc		   NDL::end_dispatch();
cc
cc	           NDL::begin_dispatch();
cc		       MISPLACED_HORIZONTAL;
cc		       NDL::REPEAT();
cc		       NDL::erroneous_atom
cc			   ( misplaced_horizontal_t );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch();
cc		       ILLEGAL_CONTROL;
cc		       NDL::REPEAT();
cc		       NDL::erroneous_atom
cc			   ( illegal_control_t );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch ( OTHERS );
cc		       NDL::REPEAT();
cc		       NDL::erroneous_atom
cc			   ( unrecognized_character_t );
cc		   NDL::end_dispatch();
cc

lex	    goto premature end of string;
lex	end quoted string lexeme table;
lex
cc		    NDL::go ( premature_end_of_string );
cc
cc	    NDL::end_table();
cc

lex
lex	begin premature end of string master table;
lex
cc	    NDL::begin_table
cc		( premature_end_of_string );
cc

lex	    output premature end of string
lex	    goto within line;
lex	end premature end of string master table;
lex
cc	        NDL::output
cc		    ( premature_end_of_string_t );
cc		NDL::go ( within_line );
cc
cc	    NDL::end_table();
cc

lex
lex	begin end of file master table;
lex	    output end of file goto stop
lex	end end of file master table;
lex
cc	    NDL::begin_table ( end_of_file );
cc	        NDL::output ( end_of_file_t );
cc	        NDL::go ( stop );
cc
cc	    NDL::end_table();
cc

lex
lex	begin stop master table;
lex	end stop master table;
lex
cc	    NDL::begin_table ( stop );
cc	    NDL::end_table();
cc

lex
lex	end standard lexical program;
cc	    NDL::end_program();
cc
cc	    LEXSTD::default_program =
cc		LEX::default_program;
cc	}
