// Layered Languages Standard Lexical Analyzer
//
// File:	ll_lexeme_standard.lexcc
// Author:	Bob Walton (walton@acm.org)
// Date:	Tue Dec  7 18:24:40 EST 2021
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.

// Lines beginning with `lex<HT>' and lines equal to
// `lex' are copied to ll_lexeme_standard.lex and then
// to the Standard Lexical Program appendix of ../doc/
// layered-introduction.tex.
//
// Lines beginning with `cc<HT>' and lines equal to `cc'
// are copied to ll_lexeme_standard.cc and compiled to
// produce code that can create a standard lexical
// program.

// Table of Contents
//
//	Usage and Setup
//	Program Construction

// Usage and Setup
// ----- --- -----

lex	// This file was automatically generated from
lex	// ll_lexeme_standard.lexcc.
lex
cc	// This file was automatically generated from
cc	// ll_lexeme_standard.lexcc.
cc
cc	# include <ll_lexeme_ndl.h>
cc	# include <ll_lexeme_standard.h>
cc	using namespace ll::lexeme::ndl;
cc	# define LEX ll::lexeme
cc	# define LEXSTD ll::lexeme::standard
cc	using namespace LEXSTD;
cc
cc	const min::Uchar UUC[1] =
cc	    { min::UNKNOWN_UCHAR };
cc
cc	# define UNREC_ESC_T unrecognized_escape_t
cc	    // Needed to keep line length <= 56
cc

// Program Construction
// ------- ------------

cc	min::locatable_var<LEX::program>
cc	    LEXSTD::default_program;
cc
cc	const char * const
cc		LEXSTD::master_names[MAX_MASTER+1] =
cc		    { "START",
cc		      "DEFAULT",
cc		      "DATA-CHECK",
cc		      "TABLE-CHECK",
cc		      "PARAGRAPH-CHECK",
cc		      "ROW-CHECK" };
cc
cc	const char * const
cc		LEXSTD::type_names[MAX_TYPE+1] = {
cc
cc	    NULL,
cc	    "WORD",
cc	    "NUMERIC-WORD",
cc	    "NATURAL",
cc	    "NUMBER",
cc	    "NUMERIC",
cc	    "MARK",
cc	    "QUOTED-STRING",
cc	    "SEPARATOR",
cc	    "COMMENT",
cc	    "HORIZONTAL-SPACE",
cc	    "INDENT",
cc	    "LINE-BREAK",
cc	    "START-OF-FILE",
cc	    "END-OF-FILE",
cc	    "DATA",
cc	    "RAW-DATA",
cc	    "TABLE",
cc	    "ROW",
cc	    "PREMATURE-END-OF-STRING",
cc	    "PREMATURE-END-OF-FILE",
cc	    "MISPLACED-VERTICAL",
cc	    "ILLEGAL-CONTROL",
cc	    "UNRECOGNIZED-CHARACTER",
cc	    "UNRECOGNIZED-ESCAPE",
cc	    "MISPLACED-HORIZONTAL" };
cc
cc	const char * LEXSTD::type_codes =
cc	    "?wWnN#mqschibfeDRTOSFVCUEH";
cc
cc	void LEXSTD::init_standard_program
cc		( void )
cc	{
cc	    if ( LEXSTD::default_program != NULL_STUB )
cc	        return;
cc

lex
lex	begin standard lexical program;
lex
cc	    begin_program
cc		( master_names, MAX_MASTER,
cc	          type_names, type_codes, MAX_TYPE );
cc
cc	    uns32 start_file;
cc	    NDL::new_table ( start_file, MASTER, 0 );
cc	    uns32 begin_line;
cc	    NDL::new_table ( begin_line, MASTER );
cc	    uns32 within_line;
cc	    NDL::new_table ( within_line, MASTER, 1 );
cc	    uns32 test_trailing;
cc	    NDL::new_table ( test_trailing );
cc	    uns32 data_check;
cc	    NDL::new_table ( data_check, MASTER, 2 );
cc	    uns32 table_check;
cc	    NDL::new_table ( table_check, MASTER, 3 );
cc	    uns32 paragraph_check;
cc	    NDL::new_table
cc		( paragraph_check, MASTER, 4 );
cc	    uns32 row_check;
cc	    NDL::new_table ( row_check, MASTER, 5 );
cc
cc	    uns32 horizontal_space;
cc	    NDL::new_table ( horizontal_space );
cc
cc	    uns32 separator;
cc	    NDL::new_table ( separator, separator_t );
cc	    uns32 finish_separators;
cc	    NDL::new_table
cc		( finish_separators, MASTER );
cc	    uns32 finish_middle;
cc	    NDL::new_table ( finish_middle );
cc	    uns32 numeric_word;
cc	    NDL::new_table
cc	        ( numeric_word, numeric_word_t );
cc	    uns32 leading_zero;
cc	    NDL::new_table ( leading_zero );
cc	    uns32 natural;
cc	    NDL::new_table ( natural, natural_t );
cc	    uns32 integer_part;
cc	    NDL::new_table ( integer_part );
cc	    uns32 fraction_part;
cc	    NDL::new_table ( fraction_part );
cc	    uns32 exponent_part;
cc	    NDL::new_table ( exponent_part );
cc	    uns32 mark;
cc	    NDL::new_table ( mark, mark_t );
cc
cc	    uns32 quoted_string;
cc	    NDL::new_table
cc		( quoted_string, quoted_string_t );
cc	    uns32 comment;
cc	    NDL::new_table ( comment, comment_t );
cc
cc	    uns32 line_break;
cc	    NDL::new_table ( line_break, line_break_t );
cc
cc	    uns32 premature_end_of_string;
cc	    NDL::new_table
cc		( premature_end_of_string, MASTER );
cc	    uns32 end_of_file;
cc	    NDL::new_table
cc		( end_of_file, MASTER );
cc	    uns32 stop;
cc	    NDL::new_table
cc		( stop, MASTER );
cc

lex	"<horizontal>" = "<UNICODE-CATEGORY-Zs>"
lex	               | "<HT>";
lex
cc	# define HORIZONTAL \
cc	           NDL::add_category ( "Zs" ); \
cc	           NDL::add_char ( '\t' )
cc

lex	"<misplaced-horizontal>" =
lex	          "<horizontal>"
lex	        & ~ "<SP>";
lex
cc	# define MISPLACED_HORIZONTAL \
cc	           NDL::add_category ( "Zs" ); \
cc	           NDL::add_char ( '\t' ); \
cc	           NDL::sub_char ( ' ' )
cc

lex	"<vertical>" = "<CR>" | "<VT>" | "<FF>"
lex
cc	    const char * vertical = "\r\v\f";
cc

lex	"<graphic>" = "<UNICODE-CATEGORY-L>"
lex	            | "<UNICODE-CATEGORY-M>"
lex	            | "<UNICODE-CATEGORY-N>"
lex	            | "<UNICODE-CATEGORY-P>"
lex	            | "<UNICODE-CATEGORY-S>"
lex
cc	# define GRAPHIC \
cc	           NDL::add_category ( "L" ); \
cc	           NDL::add_category ( "M" ); \
cc	           NDL::add_category ( "N" ); \
cc	           NDL::add_category ( "P" ); \
cc	           NDL::add_category ( "S" )
cc

lex	"<control>" = "<UNICODE-CATEGORY-C>"
lex	            | "<UNICODE-CATEGORY-Z>"
lex

lex	"<illegal-control>" = "<control>"
lex	                    & ~ "<horizontal>"
lex	                    & ~ "<vertical>"
lex	                    & ~ "<LF>"
lex
cc	# define ILLEGAL_CONTROL \
cc	           NDL::add_category ( "C" ); \
cc	           NDL::add_category ( "Z" ); \
cc	           NDL::sub_category ( "Zs" ); \
cc	           NDL::sub_chars ( vertical ); \
cc	           NDL::sub_chars ( "\t\n" )
cc

lex	"<isolated-separator>"
lex	        = "<UNICODE-CATEGORY-Ps>"
lex	        | "<UNICODE-CATEGORY-Pi>"
lex	        | "<UNICODE-CATEGORY-Pe>"
lex	        | "<UNICODE-CATEGORY-Pf>"
lex
cc	# define ISOLATED_SEPARATOR \
cc	           NDL::add_category ( "Ps" ); \
cc	           NDL::add_category ( "Pi" ); \
cc	           NDL::add_category ( "Pe" ); \
cc	           NDL::add_category ( "Pf" )
cc	# define SUB_ISOLATED_SEPARATOR \
cc	           NDL::sub_category ( "Ps" ); \
cc	           NDL::sub_category ( "Pi" ); \
cc	           NDL::sub_category ( "Pe" ); \
cc	           NDL::sub_category ( "Pf" )
cc

lex	"<repeating-separator>" = "|"
lex

lex	"<separator>"
lex	        = "<isolated-separator>"
lex	        | "<repeating-separator>"
lex

lex	"<leading>"
lex	        = "`"
lex	        | "<0A1>"  // Inverted !
lex	        | "<0BF>"  // Inverted ?
lex
cc	    // const char * leading = "`\xA1\xBF";
cc	    //     // Unused
cc

lex	"<trailing>"
lex	        = "'" | "!" | "?" | "." | ":"
lex	        | "," | ";"
lex
cc	    const char * trailing = "'!?.:,;";
cc

lex	"<letter>" = "<UNICODE-CATEGORY-L>"
lex
cc	    const char * Letter = "L";
cc

lex	"<sign>" = "+" | "-"
lex

lex	"<exponent-indicator>" = "e" | "E"
lex

lex	"<digit>" = "<UNICODE-CATEGORY-Nd>"
lex
cc	    const char * Digit = "Nd";
cc

lex	"<mark>" = (   "<UNICODE-CATEGORY-P>"
lex	             | "<UNICODE-CATEGORY-S>"
lex	             | "<UNICODE-CATEGORY-M>"
lex	             | "<UNICODE-CATEGORY-N>" )
lex	         & ~ "<digit>"
lex	         & ~ "<separator>"
lex	         & ~ "<Q>"
lex

lex	"<middle>" =   "<graphic>"
lex	           & ~ "<trailing>"
lex	           & ~ "<separator>"
lex	           & ~ "<Q>"
lex
cc	# define MIDDLE \
cc	           GRAPHIC; \
cc	           SUB_ISOLATED_SEPARATOR; \
cc	           NDL::sub_chars ( "|\"" ); \
cc	           NDL::sub_chars ( trailing )
cc

lex	"<mark-middle>" = "<mark>" & ~ "<trailing>"
lex
cc	# define MARK_MIDDLE \
cc	           NDL::add_category ( "P" ); \
cc	           NDL::add_category ( "S" ); \
cc	           NDL::add_category ( "M" ); \
cc	           NDL::add_category ( "N" ); \
cc	           NDL::sub_category ( Digit ); \
cc	           SUB_ISOLATED_SEPARATOR; \
cc	           NDL::sub_chars ( "|\"" ); \
cc	           NDL::sub_chars ( trailing )
cc

lex	"<directly-quotable>" = (     "<graphic>"
lex	                          & ~ "<"
lex	                          & ~ "<Q>" )
lex	                      | "<SP>"
lex
cc	# define DIRECTLY_QUOTABLE \
cc	           GRAPHIC; \
cc	           NDL::sub_chars ( "<\"" ); \
cc	           NDL::add_chars ( " " )
cc

lex	"<escape>" = "[A-Z]" | "[0-9]"
lex
cc	    const char * escape =
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
cc

lex
lex	begin start file master table;
lex	   output start file goto begin line
lex	end start file master table;
lex
cc	    NDL::begin_table ( start_file );
cc
cc		   NDL::output ( start_of_file_t );
cc		   NDL::go ( begin_line );
cc
cc	    NDL::end_table();
cc

lex
lex	begin begin line master table;
lex
cc	    NDL::begin_table ( begin_line );
cc

lex	   "<horizontal><repeat><graphic>"
lex	                keep 1
lex	                output indent
lex	                goto horizontal space
lex	   "<horizontal><repeat>"
lex	                output horizontal space
lex
cc		   NDL::begin_dispatch();
cc		      HORIZONTAL;
cc		      NDL::REPEAT();
cc
cc		      NDL::begin_dispatch();
cc		         GRAPHIC;
cc		         NDL::keep ( 1 );
cc		         NDL::output ( indent_t );
cc		         NDL::go ( horizontal_space );
cc		      NDL::end_dispatch();
cc
cc		      NDL::output
cc			    ( horizontal_space_t );
cc		   NDL::end_dispatch();
cc

lex	   "<graphic>"
lex	        keep 0
lex	        output indent
lex	        goto within line
lex
cc		   NDL::begin_dispatch();
cc		      GRAPHIC;
cc		      NDL::keep ( 0 );
cc		      NDL::output ( indent_t );
cc		      NDL::go ( within_line );
cc		   NDL::end_dispatch();
cc

lex	   "<LF>" goto line break
lex
cc		   NDL::begin_dispatch ( "\n" );
cc		      NDL::go ( line_break );
cc		   NDL::end_dispatch();
cc

lex	   "<vertical><repeat><LF>" goto line break
lex	   "<vertical><repeat>"
lex	                output misplaced vertical
lex
cc		   NDL::begin_dispatch ( vertical );
cc		      NDL::REPEAT();
cc		      NDL::begin_dispatch ( "\n" );
cc		         NDL::go ( line_break );
cc		      NDL::end_dispatch();
cc		      NDL::output
cc		            ( misplaced_vertical_t );
cc		   NDL::end_dispatch();
cc

lex	   "<illegal-control><repeat>"
lex	        output illegal control
lex
cc		   NDL::begin_dispatch(); 
cc		      ILLEGAL_CONTROL;
cc		      NDL::REPEAT();
cc		      NDL::output
cc			  ( illegal_control_t );
cc		   NDL::end_dispatch();
cc

lex	   "<others><repeat>"
lex	        error unrecognized character
lex
cc	    	   NDL::begin_dispatch ( OTHERS );
cc		      NDL::REPEAT();
cc		      NDL::output
cc			( unrecognized_character_t );
cc	    	   NDL::end_dispatch();
cc

lex	   output premature end of file goto end of file
lex	        // End of file not following a line
lex	        // break
lex
cc		   NDL::output
cc			( premature_end_of_file_t );
cc		   NDL::go ( end_of_file );
cc

lex	end begin line master table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin horizontal space sublexeme table;
lex
cc	    NDL::begin_table ( horizontal_space );
cc

lex	   "<horizontal>" accept;
lex
cc		   NDL::begin_dispatch();
cc		      HORIZONTAL;
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   goto within line;
lex
cc	    	   NDL::go ( within_line );
cc

lex	end horizontal space sublexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin data check master table;
lex
cc	    NDL::begin_table ( data_check );
cc

lex	   "@[1-9]"     keep 0
lex	                output data
lex	                goto within line;
lex	   "@<"         keep 0
lex	                output data
lex	                goto within line;
lex	   "@@@@"       keep 0
lex	                output data
lex	                goto within line;
lex
cc	           NDL::begin_dispatch ( "@" );
cc	    	       NDL::begin_dispatch
cc	                       ( "123456789<" );
cc		           NDL::keep ( 0 );
cc		           NDL::output ( data_t );
cc		           NDL::go ( within_line );
cc		       NDL::end_dispatch();
cc		       NDL::begin_dispatch ( "@" );
cc		         NDL::begin_dispatch ( "@" );
cc		           NDL::begin_dispatch ( "@" );
cc		             NDL::keep ( 0 );
cc		             NDL::output ( data_t );
cc		             NDL::go ( within_line );
cc		           NDL::end_dispatch();
cc		         NDL::end_dispatch();
cc		       NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   "!@[1-9]"    keep 1
lex	                output raw data
lex	                goto within line;
lex	   "!@<"        keep 1
lex	                output raw data
lex	                goto within line;
lex
cc	           NDL::begin_dispatch ( "!" );
cc	             NDL::begin_dispatch ( "@" );
cc	               NDL::begin_dispatch
cc		              ( "123456789<" );
cc		         NDL::keep ( 1 );
cc		         NDL::output ( raw_data_t );
cc		         NDL::go ( within_line );
cc		       NDL::end_dispatch();
cc		     NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   goto within line;
lex
cc	    	   NDL::go ( within_line );
cc

lex	end data check master table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin table check master table;
lex
cc	    NDL::begin_table ( table_check );
cc

lex	   "====="      keep 0
lex	                output table
lex	                goto row check;
lex
cc	           NDL::begin_dispatch ( "=" );
cc	             NDL::begin_dispatch ( "=" );
cc	               NDL::begin_dispatch ( "=" );
cc	                 NDL::begin_dispatch ( "=" );
cc	                   NDL::begin_dispatch ( "=" );
cc		             NDL::keep ( 0 );
cc		             NDL::output ( table_t );
cc		             NDL::go ( row_check );
cc		           NDL::end_dispatch();
cc		         NDL::end_dispatch();
cc		       NDL::end_dispatch();
cc		     NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   "-----"      keep 0
lex	                output table
lex	                goto row check;
lex
cc	           NDL::begin_dispatch ( "-" );
cc	             NDL::begin_dispatch ( "-" );
cc	               NDL::begin_dispatch ( "-" );
cc	                 NDL::begin_dispatch ( "-" );
cc	                   NDL::begin_dispatch ( "-" );
cc		             NDL::keep ( 0 );
cc		             NDL::output ( table_t );
cc		             NDL::go ( row_check );
cc		           NDL::end_dispatch();
cc		         NDL::end_dispatch();
cc		       NDL::end_dispatch();
cc		     NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   goto within line;
lex
cc	    	   NDL::go ( within_line );
cc

lex	end table check master table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin paragraph check master table;
lex
cc	    NDL::begin_table ( paragraph_check );
cc

lex	   "@[1-9]"     keep 0
lex	                output data
lex	                goto within line;
lex	   "@<"         keep 0
lex	                output data
lex	                goto within line;
lex	   "@@@@"       keep 0
lex	                output data
lex	                goto within line;
lex
cc		   NDL::begin_dispatch ( "@" );
cc		       NDL::begin_dispatch
cc		               ( "123456789<" );
cc		           NDL::keep ( 0 );
cc		           NDL::output ( data_t );
cc		           NDL::go ( within_line );
cc		       NDL::end_dispatch();
cc		       NDL::begin_dispatch ( "@" );
cc		         NDL::begin_dispatch ( "@" );
cc		           NDL::begin_dispatch ( "@" );
cc		             NDL::keep ( 0 );
cc		             NDL::output ( data_t );
cc		             NDL::go ( within_line );
cc		           NDL::end_dispatch();
cc		         NDL::end_dispatch();
cc		       NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   "!@[1-9]"    keep 1
lex	                output raw data
lex	                goto within line;
lex	   "!@<"        keep 1
lex	                output raw data
lex	                goto within line;
lex
cc		   NDL::begin_dispatch ( "!" );
cc		     NDL::begin_dispatch ( "@" );
cc		       NDL::begin_dispatch
cc		              ( "123456789<" );
cc		         NDL::keep ( 1 );
cc		         NDL::output ( raw_data_t );
cc		         NDL::go ( within_line );
cc		       NDL::end_dispatch();
cc		     NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   "====="      keep 0
lex	                output table
lex	                goto row check;
lex
cc		   NDL::begin_dispatch ( "=" );
cc		     NDL::begin_dispatch ( "=" );
cc		       NDL::begin_dispatch ( "=" );
cc		         NDL::begin_dispatch ( "=" );
cc		           NDL::begin_dispatch ( "=" );
cc		             NDL::keep ( 0 );
cc		             NDL::output ( table_t );
cc		             NDL::go ( row_check );
cc		           NDL::end_dispatch();
cc		         NDL::end_dispatch();
cc		       NDL::end_dispatch();
cc		     NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   "-----"      keep 0
lex	                output table
lex	                goto row check;
lex
cc		   NDL::begin_dispatch ( "-" );
cc		     NDL::begin_dispatch ( "-" );
cc		       NDL::begin_dispatch ( "-" );
cc		         NDL::begin_dispatch ( "-" );
cc		           NDL::begin_dispatch ( "-" );
cc		             NDL::keep ( 0 );
cc		             NDL::output ( table_t );
cc		             NDL::go ( row_check );
cc		           NDL::end_dispatch();
cc		         NDL::end_dispatch();
cc		       NDL::end_dispatch();
cc		     NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   goto within line;
lex
cc		NDL::go ( within_line );
cc

lex	end paragraph check master table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin row check master table;
lex
cc	    NDL::begin_table ( row_check );
cc

lex	   "|"          keep 0
lex	                output row
lex	                goto within line;
lex
cc		NDL::begin_dispatch ( "|" );
cc		   NDL::keep ( 0 );
cc		   NDL::output ( row_t );
cc		   NDL::go ( within_line );
cc		NDL::end_dispatch();
cc

lex	   "="          keep 0
lex	                output row
lex	                goto within line;
lex
cc		NDL::begin_dispatch ( "=" );
cc		   NDL::keep ( 0 );
cc		   NDL::output ( row_t );
cc		   NDL::go ( within_line );
cc		NDL::end_dispatch();
cc

lex	   "-"          keep 0
lex	                output row
lex	                goto within line;
lex
cc		NDL::begin_dispatch ( "-" );
cc		   NDL::keep ( 0 );
cc		   NDL::output ( row_t );
cc		   NDL::go ( within_line );
cc		NDL::end_dispatch();
cc

lex	   goto within line;
lex
cc		NDL::go ( within_line );
cc

lex	end row check master table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin within line master table;
lex
cc	    NDL::begin_table ( within_line );
cc

lex	   "//" goto comment;
lex	   "/"  goto mark;
lex
cc		NDL::begin_dispatch ( "/" );
cc		   NDL::begin_dispatch ( "/" );
cc		      NDL::go ( comment );
cc		   NDL::end_dispatch();
cc
cc		   NDL::go ( mark );
cc		NDL::end_dispatch();
cc

lex	    "<horizontal><repeat>"
lex	        output horizontal space;
lex
cc		NDL::begin_dispatch ( "\t" );
cc		   NDL::add_category ( "Zs" );
cc		   NDL::REPEAT();
cc		   NDL::output ( horizontal_space_t );
cc		NDL::end_dispatch();
cc

lex	    "<LF>" goto line break
lex
cc		NDL::begin_dispatch ( "\n" );
cc		   NDL::go ( line_break );
cc		NDL::end_dispatch();
cc

lex	    "<vertical><repeat><LF>" goto line break
lex	    "<vertical><repeat>"
lex	                output misplaced vertical
lex
cc		NDL::begin_dispatch ( vertical );
cc		   NDL::REPEAT();
cc		   NDL::begin_dispatch ( "\n" );
cc		      NDL::go ( line_break );
cc		   NDL::end_dispatch();
cc		   NDL::output ( misplaced_vertical_t );
cc		NDL::end_dispatch();
cc

lex	    "<illegal-control><repeat>"
lex	        output illegal control
lex
cc		NDL::begin_dispatch(); 
cc		   ILLEGAL_CONTROL;
cc		   NDL::REPEAT();
cc		   NDL::output ( illegal_control_t );
cc		NDL::end_dispatch();
cc

lex	    "<isolated-separator>" output separator;
lex	    "|<repeat>" output separator;
lex	    "`<repeat>" output separator;
lex	    "<0A1><repeat>" output separator;
lex	        // Inverted !
lex	    "<0BF><repeat>" output separator;
lex	        // Inverted ?
lex
cc		NDL::begin_dispatch();
cc		   ISOLATED_SEPARATOR;
cc		   NDL::output ( separator_t );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( "|" );
cc		   NDL::REPEAT();
cc		   NDL::output ( separator_t );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( "`" );
cc		   NDL::REPEAT();
cc		   NDL::output ( separator_t );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch();
cc		   NDL::add_char ( 0xA1 );
cc		   NDL::REPEAT();
cc		   NDL::output ( separator_t );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch();
cc		   NDL::add_char ( 0xBF );
cc		   NDL::REPEAT();
cc		   NDL::output ( separator_t );
cc		NDL::end_dispatch();
cc

lex	    ".[0-9]" goto fraction part;
lex	    "." keep 0 goto test trailing;
lex	    "<trailing>" keep 0 goto test trailing;
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::begin_dispatch ( "0123456789" );
cc		      NDL::go ( fraction_part );
cc		   NDL::end_dispatch();
cc		   NDL::keep ( 0 );
cc		   NDL::go ( test_trailing );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch ( trailing );
cc		   NDL::keep ( 0 );
cc		   NDL::go ( test_trailing );
cc		NDL::end_dispatch();
cc

lex	    "NaN" goto numeric word;
lex	    "N" output word goto finish middle;
lex	    "Inf" goto numeric word;
lex	    "I" output word goto finish middle;
lex	    "<letter>" output word goto finish middle;
lex
cc		NDL::begin_dispatch ( "N" );
cc		   NDL::begin_dispatch ( "a" );
cc		      NDL::begin_dispatch ( "N" );
cc		         NDL::go ( numeric_word );
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		   NDL::output ( word_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch ( "I" );
cc		   NDL::begin_dispatch ( "n" );
cc		      NDL::begin_dispatch ( "f" );
cc		         NDL::go ( numeric_word );
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		   NDL::output ( word_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch ( );
cc		   NDL::add_category ( "L" );
cc		   NDL::output ( word_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc

lex	    "0" goto leading zero;
lex
cc		NDL::begin_dispatch ( "0" );
cc		   NDL::go ( leading_zero );
cc		NDL::end_dispatch();
cc

lex	    "[1-9]" goto natural;
lex
cc		NDL::begin_dispatch ( "123456789" );
cc		   NDL::go ( natural );
cc		NDL::end_dispatch();
cc

lex	    "<digit>" output numeric goto finish middle;
lex
cc		NDL::begin_dispatch();
cc		   NDL::add_category ( Digit );
cc		   NDL::output ( numeric_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc

lex	    "<sign>[0-9]" goto integer part;
lex	    "<sign>.[0-9]" goto fraction part;
lex	    "<sign>NaN" goto numeric word;
lex	    "<sign>Inf" goto numeric word;
lex	    "<sign>" goto mark;
lex	    "<mark-middle>" goto mark;
lex
cc		NDL::begin_dispatch ( "+-" );
cc		   NDL::begin_dispatch ( "0123456789" );
cc		      NDL::go ( integer_part );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch ( "." );
cc		      NDL::begin_dispatch
cc		            ( "0123456789" );
cc		         NDL::go ( fraction_part );
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch ( "N" );
cc		      NDL::begin_dispatch ( "a" );
cc		         NDL::begin_dispatch ( "N" );
cc		            NDL::go ( numeric_word );
cc		         NDL::end_dispatch();
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch ( "I" );
cc		      NDL::begin_dispatch ( "n" );
cc		         NDL::begin_dispatch ( "f" );
cc		            NDL::go ( numeric_word );
cc		         NDL::end_dispatch();
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		   NDL::go ( mark );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch();
cc		   MARK_MIDDLE;
cc		   NDL::go ( mark );
cc		NDL::end_dispatch();
cc

lex	    "<Q>" translate to "" goto quoted string;
lex
cc		NDL::begin_dispatch ( "\"" );
cc		   NDL::translate_to ( "" );
cc		   NDL::go ( quoted_string );
cc		NDL::end_dispatch();
cc

lex	    "<others><repeat>"
lex	        error unrecognized character
lex
cc		NDL::begin_dispatch ( OTHERS );
cc		   NDL::REPEAT();
cc		   NDL::output
cc		      ( unrecognized_character_t );
cc		NDL::end_dispatch();
cc

lex	    output premature end of file
lex	    goto end of file
lex	        // End of file not following a line
lex	        // break
lex
cc		NDL::output ( premature_end_of_file_t );
cc		NDL::go ( end_of_file );
cc

lex	end within line master table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin test trailing sublexeme table;
lex	    // First atom of the lexeme has not been
lex	    // scanned but is known to begin with a
lex	    // trailing character.
lex
cc	    NDL::begin_table ( test_trailing );
cc

lex	    "<trailing><repeat><letter>"
lex	                output word
lex	                goto goto finish middle;
lex	    "<trailing><repeat><digit>"
lex	                output numeric
lex	                goto finish middle;
lex	    "<trailing><repeat><mark-middle>"
lex	                goto mark
lex	    "<trailing><repeat>"
lex	                keep 0
lex	                goto separator;
lex
cc		NDL::begin_dispatch ( trailing );
cc		   // This dispatch always succeeds.
cc		   NDL::REPEAT();
cc
cc		   NDL::begin_dispatch();
cc		      NDL::add_category ( Letter );
cc		      NDL::output ( word_t );
cc		      NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch();
cc		      NDL::add_category ( Digit );
cc		      NDL::output ( numeric_t );
cc		      NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc
cc		   NDL::begin_dispatch();
cc		      MARK_MIDDLE;
cc		      NDL::go ( mark );
cc		   NDL::end_dispatch();
cc
cc		   NDL::keep ( 0 );
cc		   NDL::go ( separator );
cc		NDL::end_dispatch();
cc

lex	end test trailing sublexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	// The below tables are entered from the master
lex	// table with the first atom scanned, unless
lex	// otherwise indicated.
lex
lex	begin comment lexeme table;
lex
cc	    NDL::begin_table ( comment );
cc

lex	    "<graphic>" accept
lex	    "<horizontal>" accept
lex
cc		NDL::begin_dispatch ( "\t" );
cc		   GRAPHIC;
cc		   NDL::add_category ( "Zs" );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc

lex	    "<LF>" keep 0 goto within line
lex	    "<vertical><repeat><LF>" keep 0
lex	                             goto within line
lex	    "<vertical><repeat>"
lex	        error mispaced vertical
lex	    "<illegal-control><repeat>"
lex	        error illegal control
lex	    "<others><repeat>"
lex	        error unrecognized character
cc		NDL::begin_dispatch ( "\n" );
cc		   NDL::keep ( 0 );
cc		   NDL::go ( within_line );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( vertical );
cc		   NDL::REPEAT();
cc		   NDL::begin_dispatch ( "\n" );
cc		      NDL::keep ( 0 );
cc		      NDL::go ( within_line );
cc		   NDL::end_dispatch();
cc		   NDL::erroneous_atom
cc		      ( misplaced_vertical_t );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch();
cc		   ILLEGAL_CONTROL;
cc		   NDL::REPEAT();
cc		   NDL::erroneous_atom
cc		      ( illegal_control_t );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( OTHERS );
cc		   NDL::REPEAT();
cc		   NDL::erroneous_atom
cc		      ( unrecognized_character_t );
cc		NDL::end_dispatch();
cc

lex	    goto within line
lex	    // which will output premature end of file
lex
cc		NDL::go ( within_line );
cc

lex	end comment lexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin line break lexeme table;
lex
cc	    NDL::begin_table ( line_break );
cc

lex	    "<vertical>" accept;
lex
cc		NDL::begin_dispatch ( vertical );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc

lex	    "<others>" keep 0 goto begin line
lex
cc		NDL::begin_dispatch ( OTHERS );
cc		   NDL::keep ( 0 );
cc		   NDL::go ( begin_line );
cc		NDL::end_dispatch();
cc

lex	    goto end of file
lex
cc		NDL::go ( end_of_file );
cc

lex	end line break lexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin separator lexeme table;
lex	    // First atom is not scanned; next lexeme
lex	    // must be a trailing separator if it has
lex	    // the syntax of such.
lex
cc	    NDL::begin_table ( separator );
cc

lex	    "!<repeat>" goto finish separators
lex	    "?<repeat>" goto finish separators
lex	    ".<repeat>" goto finish separators
lex	    ":<repeat>" goto finish separators
lex	    "'<repeat>" goto finish separators
lex	    "," goto finish separators
lex	    ";" goto finish separators
lex
cc		NDL::begin_dispatch ( "!");
cc		   NDL::REPEAT();
cc		   NDL::go ( finish_separators );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( "?");
cc		   NDL::REPEAT();
cc		   NDL::go ( finish_separators );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( ".");
cc		   NDL::REPEAT();
cc		   NDL::go ( finish_separators );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( ":");
cc		   NDL::REPEAT();
cc		   NDL::go ( finish_separators );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( "'");
cc		   NDL::REPEAT();
cc		   NDL::go ( finish_separators );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( ",;");
cc		   NDL::go ( finish_separators );
cc		NDL::end_dispatch();
cc

lex	    output NONE goto within line;
lex
cc		NDL::output ( NONE );
cc		NDL::go ( within_line );
cc

lex	end separator lexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin finish separators master table;
lex	    // Come here to end lexeme when next lexeme
lex	    // must be a trailing separator if it has
lex	    // the syntax of such.
lex
cc	    NDL::begin_table ( finish_separators );
cc

lex	    goto separator;
lex
cc		NDL::go ( separator );
cc

lex	end finish separators master table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin finish middle sublexeme table;
lex	    // Come here when type of middle lexeme has
lex	    // been set by an `output' instruction.
lex
cc	    NDL::begin_table ( finish_middle );
cc

lex	    "<middle>" accept;
lex
cc		NDL::begin_dispatch();
cc		   MIDDLE;
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc

lex	    "<trailing><repeat><middle>" accept;
lex
cc		NDL::begin_dispatch ( trailing );
cc		   NDL::REPEAT();
cc		      NDL::begin_dispatch();
cc		         MIDDLE;
cc		         NDL::accept();
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc

lex	   goto within line;
lex
cc		NDL::go ( within_line );
cc

lex	end finish middle sublexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin numeric word lexeme table;
lex	    // One of sign? Nan or sign? Inf scanned.
lex
cc	    NDL::begin_table ( numeric_word );
cc

lex	    "<middle>" output word goto finish middle;
lex	    "<trailing><repeat><middle>"
lex	               output word
lex	               goto finish middle;
lex
cc		NDL::begin_dispatch();
cc		   MIDDLE;
cc		   NDL::output ( word_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( trailing );
cc		   NDL::REPEAT();
cc		   NDL::begin_dispatch();
cc		      MIDDLE;
cc		      NDL::output ( word_t );
cc		      NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc

lex	    goto within line;
lex
cc		NDL::go ( within_line );
cc

lex	end numeric word lexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin mark lexeme table;
lex	    // Middle lexeme with no letter or digit yet
lex	    // scanned.  Will be mark if none found.
lex
cc	    NDL::begin_table ( mark );
cc

lex	    "<letter>" output word goto finish middle;
lex
cc		NDL::begin_dispatch();
cc		   NDL::add_category ( Letter );
cc		   NDL::output ( word_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc

lex	    "<digit>" output numeric goto finish middle;
lex
cc		NDL::begin_dispatch();
cc		   NDL::add_category ( Digit );
cc		   NDL::output ( numeric_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc

lex	    "<mark-middle>" accept;
lex
cc		NDL::begin_dispatch();
cc		   MARK_MIDDLE;
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc

lex	    "<trailing><repeat><letter>"
lex	                output word
lex	                goto finish middle;
lex	    "<trailing><repeat><digit>"
lex	                output numeric
lex	                goto finish middle;
lex	    "<trailing><repeat><mark-middle>" accept;
lex
cc		NDL::begin_dispatch ( trailing );
cc		   NDL::REPEAT();
cc		   NDL::begin_dispatch();
cc		      NDL::add_category ( Letter );
cc		      NDL::output ( word_t );
cc		      NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch();
cc		      NDL::add_category ( Digit );
cc		      NDL::output ( numeric_t );
cc		      NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch();
cc		      MARK_MIDDLE;
cc		      NDL::accept();
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc

lex	    goto within line;
lex
cc		NDL::go ( within_line );
cc

lex	end mark lexeme table;
lex
cc	   NDL::end_table();
cc

lex
lex	begin leading zero sublexeme table;
lex
cc	    NDL::begin_table ( leading_zero );
cc

lex	    "<middle>"
lex	        keep 0 goto integer part
lex	        // Includes second digit.
lex	        // Includes exponent.
lex	    "<trailing><repeat><middle>"
lex	        keep 0 goto integer part
lex	        // Includes fraction.
lex
cc		NDL::begin_dispatch();
cc		   MIDDLE;
cc		   NDL::keep ( 0 );
cc		   NDL::go ( integer_part );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch ( trailing );
cc		   NDL::REPEAT();
cc		   NDL::begin_dispatch();
cc		      MIDDLE;
cc		      NDL::keep ( 0 );
cc		      NDL::go ( integer_part );
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc

lex	    output natural goto within line;
lex
cc		NDL::output ( natural_t );
cc		NDL::go ( within_line );
cc

lex	end leading zero sublexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin natural lexeme table;
lex
cc	    NDL::begin_table ( natural );
cc

lex	    "[0-9]" accept;
lex
cc		NDL::begin_dispatch ( "0123456789" );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc

lex	    ".[0-9]" goto fraction part;
lex	    ".<middle>"
lex	        output numeric goto finish middle;
lex	    ".<trailing><middle>"
lex	        output numeric goto finish middle;
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::begin_dispatch ( "0123456789" );
cc		      NDL::go ( fraction_part );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch();
cc		      MIDDLE;
cc		      NDL::output ( numeric_t );
cc		      NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch ( trailing );
cc		      NDL::REPEAT();
cc		      NDL::begin_dispatch();
cc		         MIDDLE;
cc		         NDL::output ( numeric_t );
cc		         NDL::go ( finish_middle );
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc

lex	    "<exponent-indicator>[0-9]"
lex	               goto exponent part;
lex	    "<exponent-indicator><sign>[0-9]"
lex	               goto exponent part;
lex	    "<exponent-indicator>"
lex	               output numeric
lex	               goto finish middle;
lex
cc		NDL::begin_dispatch ( "eE" );
cc		   NDL::begin_dispatch ( "0123456789" );
cc		      NDL::go ( exponent_part );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch ( "+-" );
cc		      NDL::begin_dispatch
cc		            ( "0123456789" );
cc		         NDL::go ( exponent_part );
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		   NDL::output ( numeric_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc

lex	    "<middle>" output numeric
lex	               goto finish middle;
lex	    "<trailing><repeat><middle>"
lex	               output numeric
lex	               goto finish middle;
lex
cc		NDL::begin_dispatch();
cc		   MIDDLE;
cc		   NDL::output ( numeric_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch ( trailing );
cc		    NDL::REPEAT();
cc		    NDL::begin_dispatch();
cc		       MIDDLE;
cc		       NDL::output ( numeric_t );
cc		       NDL::go ( finish_middle );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc

lex	    goto within line;
lex
cc		NDL::go ( within_line );
cc

lex	end natural lexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin integer part sublexeme table;
lex	    // sign digit or 0 plus middle lexeme
lex	    // continuation scanned
lex
cc	    NDL::begin_table ( integer_part );
cc

lex	    "[0-9]" accept;
lex
cc		NDL::begin_dispatch ( "0123456789" );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc

lex	    ".[0-9]" goto fraction part;
lex	    ".<middle>"
lex	        output numeric goto finish middle;
lex	    ".<trailing><middle>"
lex	        output numeric goto finish middle;
lex
cc		NDL::begin_dispatch ( "." );
cc		   NDL::begin_dispatch ( "0123456789" );
cc		      NDL::go ( fraction_part );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch();
cc		      MIDDLE;
cc		      NDL::output ( numeric_t );
cc		      NDL::go ( finish_middle );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch ( trailing );
cc		      NDL::REPEAT();
cc		      NDL::begin_dispatch();
cc		         MIDDLE;
cc		         NDL::output ( numeric_t );
cc		         NDL::go ( finish_middle );
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		NDL::end_dispatch();
cc

lex	    "<exponent-indicator>[0-9]"
lex	               goto exponent part;
lex	    "<exponent-indicator><sign>[0-9]"
lex	               goto exponent part;
lex	    "<exponent-indicator>"
lex	               output numeric
lex	               goto finish middle;
lex
cc		NDL::begin_dispatch ( "eE" );
cc		   NDL::begin_dispatch ( "0123456789" );
cc		      NDL::go ( exponent_part );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch ( "+-" );
cc		      NDL::begin_dispatch
cc		            ( "0123456789" );
cc		         NDL::go ( exponent_part );
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		   NDL::output ( numeric_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc

lex	    "<middle>" output numeric
lex	               goto finish middle;
lex	    "<trailing><repeat><middle>"
lex	               output numeric
lex	               goto finish middle;
lex
cc		NDL::begin_dispatch();
cc		   MIDDLE;
cc		   NDL::output ( numeric_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch ( trailing );
cc		    NDL::REPEAT();
cc		    NDL::begin_dispatch();
cc		       MIDDLE;
cc		       NDL::output ( numeric_t );
cc		       NDL::go ( finish_middle );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc

lex	    output number
lex	    goto within line;
lex
cc		NDL::output ( number_t );
cc		NDL::go ( within_line );
cc

lex	end integer part sublexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin fraction part sublexeme table;
lex	    // `. digit' scanned with prefix compatible
lex	    // with a number.
lex
cc	    NDL::begin_table ( fraction_part );
cc

lex	    "[0-9]" accept;
lex
cc		NDL::begin_dispatch ( "0123456789" );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc

lex	    "<exponent-indicator>[0-9]"
lex	               goto exponent part;
lex	    "<exponent-indicator><sign>[0-9]"
lex	               goto exponent part;
lex	    "<exponent-indicator>"
lex	               output numeric
lex	               goto finish middle;
lex
cc		NDL::begin_dispatch ( "eE" );
cc		   NDL::begin_dispatch ( "0123456789" );
cc		      NDL::go ( exponent_part );
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch ( "+-" );
cc		      NDL::begin_dispatch
cc		            ( "0123456789" );
cc		         NDL::go ( exponent_part );
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		   NDL::output ( numeric_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc

lex	    "<middle>" output numeric
lex	               goto finish middle;
lex	    "<trailing><repeat><middle>"
lex	               output numeric
lex	               goto finish middle;
lex
cc		NDL::begin_dispatch();
cc		   MIDDLE;
cc		   NDL::output ( numeric_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch ( trailing );
cc		    NDL::REPEAT();
cc		    NDL::begin_dispatch();
cc		       MIDDLE;
cc		       NDL::output ( numeric_t );
cc		       NDL::go ( finish_middle );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc

lex	   output number;
lex	   goto within line;
lex
cc		NDL::output ( number_t );
cc		NDL::go ( within_line );
cc

lex	end fraction part sublexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin exponent part sublexeme table;
lex	    // `{e|E} sign? digit' scanned after prefix
lex	    // compatible with a number.
lex
cc	    NDL::begin_table ( exponent_part );
cc

lex	    "[0-9]" accept;
lex
cc		NDL::begin_dispatch ( "0123456789" );
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc

lex	    "<middle>" output numeric
lex	               goto finish middle;
lex	    "<trailing><repeat><middle>"
lex	               output numeric
lex	               goto finish middle;
lex
cc		NDL::begin_dispatch();
cc		   MIDDLE;
cc		   NDL::output ( numeric_t );
cc		   NDL::go ( finish_middle );
cc		NDL::end_dispatch();
cc		NDL::begin_dispatch ( trailing );
cc		    NDL::REPEAT();
cc		    NDL::begin_dispatch();
cc		       MIDDLE;
cc		       NDL::output ( numeric_t );
cc		       NDL::go ( finish_middle );
cc		    NDL::end_dispatch();
cc		NDL::end_dispatch();
cc

lex	   output number;
lex	   goto within line;
lex
cc		NDL::output ( number_t );
cc		NDL::go ( within_line );
cc

lex	end exponent part sublexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin quoted string lexeme table;
lex
cc	    NDL::begin_table ( quoted_string );
cc

lex	    "<Q>" translate to "" goto within line;
lex	            // End quoted string.
lex
cc		NDL::begin_dispatch ( "\"" );
cc		   NDL::translate_to ( "" );
cc		   NDL::go ( within_line );
cc		NDL::end_dispatch();
cc

lex	    "<" "[0-9]" ">"
lex	        translate hex 1 1
lex	    "<" "[0-9]<escape><repeat>" ">"
lex	        translate hex 1 1
lex	        else error unrecognized escape
lex	             translate to "<UUC>"
lex	    "<" "[A-Z]" ">"
lex	             translate name 1 1
lex	        else error unrecognized escape
lex	             translate to "<UUC>"
lex	    "<" "[A-Z]<escape><repeat>" ">"
lex	           translate name 1 1
lex	        else error unrecognized escape
lex	             translate to "<UUC>"
lex	    "<"
lex	        accept;
lex
lex
cc		NDL::begin_dispatch ( "<" );
cc		   NDL::begin_dispatch();
cc		      NDL::add_chars ( "0123456789" );
cc		      NDL::begin_dispatch ( ">" );
cc		         NDL::translate_hex ( 1, 1 );
cc		      NDL::end_dispatch();
cc		      NDL::begin_dispatch ( escape );
cc		         NDL::REPEAT();
cc		         NDL::begin_dispatch ( ">" );
cc		            NDL::translate_hex ( 1, 1 );
cc		            NDL::ELSE();
cc		            NDL::erroneous_atom
cc		               ( UNREC_ESC_T );
cc		            NDL::translate_to
cc		               ( 1, UUC );
cc		         NDL::end_dispatch();
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		   NDL::begin_dispatch();
cc		      NDL::add_chars
cc		       ( "ABCDEFGHIJKLMNOPQRSTUVWXYZ" );
cc		      NDL::begin_dispatch ( ">" );
cc		           NDL::translate_name ( 1, 1 );
cc		           NDL::ELSE();
cc		           NDL::erroneous_atom
cc		              ( UNREC_ESC_T );
cc		           NDL::translate_to ( 1, UUC );
cc		      NDL::end_dispatch();
cc		      NDL::begin_dispatch ( escape );
cc		          NDL::REPEAT();
cc		          NDL::begin_dispatch ( ">" );
cc		             NDL::translate_name
cc		                ( 1, 1 );
cc		             NDL::ELSE();
cc		             NDL::erroneous_atom
cc		                 ( UNREC_ESC_T );
cc		             NDL::translate_to
cc		                ( 1, UUC );
cc		          NDL::end_dispatch();
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc		   NDL::accept();
cc		NDL::end_dispatch();
cc

lex	    "<directly-quotable>" accept;
lex
cc		NDL::begin_dispatch();
cc		    DIRECTLY_QUOTABLE;
cc		    NDL::accept();
cc		NDL::end_dispatch();
cc

lex	    "<LF>"
lex	        keep 0 goto premature end of string
lex	    "<vertical><repeat><LF>"
lex	        keep 0 goto premature end of string
lex	    "<vertical><repeat>"
lex	        error mispaced vertical
lex	    "<misplaced-horizontal><repeat>"
lex	        error misplaced horizontal
lex	    "<illegal-control><repeat>"
lex	        error illegal control
lex	    "<others><repeat>"
lex	        error unrecognized character
lex
cc		NDL::begin_dispatch ( "\n" );
cc		   NDL::keep ( 0 );
cc		   NDL::go ( premature_end_of_string );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( vertical );
cc		   NDL::REPEAT();
cc		   NDL::begin_dispatch ( "\n" );
cc		      NDL::keep ( 0 );
cc		      NDL::go
cc		         ( premature_end_of_string );
cc		   NDL::end_dispatch();
cc		   NDL::erroneous_atom
cc		      ( misplaced_vertical_t );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch();
cc		   MISPLACED_HORIZONTAL;
cc		   NDL::REPEAT();
cc		   NDL::erroneous_atom
cc		      ( misplaced_horizontal_t );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch();
cc		   ILLEGAL_CONTROL;
cc		   NDL::REPEAT();
cc		   NDL::erroneous_atom
cc		      ( illegal_control_t );
cc		NDL::end_dispatch();
cc
cc		NDL::begin_dispatch ( OTHERS );
cc		   NDL::REPEAT();
cc		   NDL::erroneous_atom
cc		      ( unrecognized_character_t );
cc		NDL::end_dispatch();
cc

lex	    goto premature end of string;
lex
cc		NDL::go ( premature_end_of_string );
cc

lex	end quoted string lexeme table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin premature end of string master table;
lex
cc	    NDL::begin_table
cc	       ( premature_end_of_string );
cc

lex	    output premature end of string
lex	    goto within line;
lex
cc		NDL::output
cc		   ( premature_end_of_string_t );
cc		NDL::go ( within_line );
cc

lex	end premature end of string master table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin end of file master table;
lex	    output end of file goto stop
lex	end end of file master table;
lex
cc	    NDL::begin_table ( end_of_file );
cc		NDL::output ( end_of_file_t );
cc		NDL::go ( stop );
cc
cc	    NDL::end_table();
cc

lex
lex	begin stop master table;
lex	end stop master table;
lex
cc	    NDL::begin_table ( stop );
cc	    NDL::end_table();
cc

lex
lex	end standard lexical program;
cc	    NDL::end_program();
cc
cc	    LEXSTD::default_program =
cc	        LEX::default_program;
cc	}
