// Layers Language Standard Lexical Analyzer
//
// File:	ll_lexeme_standard.lexcc
// Author:	Bob Walton (walton@acm.org)
// Date:	Thu May 26 03:20:58 EDT 2011
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.

// Lines beginning with `lex<HT>' and lines equal to
// `lex' are copied to ll_lexeme_standard.lex and then
// to the Standard Lexical Program appendix of ../doc/
// layered-introduction.tex.
//
// Lines beginning with `cc<HT>' and lines equal to `cc'
// are copied to ll_lexeme_standard.cc and compiled to
// produce code that can create a standard lexical
// program.

// Table of Contents
//
//	Usage and Setup
//	Program Construction

// Usage and Setup
// ----- --- -----

cc	// This file was automatically generated from
cc	// ll_lexeme_standard.lexcc.
cc
lex	// This file was automatically generated from
lex	// ll_lexeme_standard.lexcc.
lex
cc	# include <ll_lexeme_ndl.h>
cc	# include <ll_lexeme_standard.h>
cc	using namespace ll::lexeme::ndl;
cc	# define LEX ll::lexeme
cc	# define LEXSTD ll::lexeme::standard
cc	using namespace LEXSTD;
cc

// Program Construction
// ------- ------------

cc	min::locatable_var<LEX::program>
cc	    LEXSTD::default_program;
cc
cc	const char * const
cc		LEXSTD::type_name[MAX_TYPE+1] = {
cc
cc	    NULL,
cc	    "WORD",
cc	    "NATURAL_NUMBER",
cc	    "NUMBER",
cc	    "MARK",
cc	    "QUOTED_STRING",
cc	    "SEPARATOR",
cc	    "COMMENT",
cc	    "HORIZONTAL_SPACE",
cc	    "LINE_BREAK",
cc	    "END_OF_FILE",
cc	    "BAD_END_OF_LINE",
cc	    "BAD_END_OF_FILE",
cc	    "UNRECOGNIZED_CHARACTER",
cc	    "UNRECOGNIZED_ESCAPE_SEQUENCE",
cc	    "NON_LETTER_ESCAPE_SEQUENCE" };
cc
cc	const char * LEXSTD::type_code =
cc	    "Xwn#mqschbeLFCEN";
cc
cc	struct char_range { uns32 min, max; }
cc	    non_ascii_letters[] =
cc	{
cc		// { min,		max },
cc	#include <ll_lexeme_non_ascii_letters.h>
cc		   { 0,                0 }
cc	};
cc
cc	static void add_non_ascii_letters ( void )
cc	{
cc	    for ( char_range *p = non_ascii_letters;
cc		  p->min != 0 || p->max != 0; ++ p )
cc		NDL::add_characters ( p->min, p->max );
cc	}
cc
cc	void LEXSTD::init_standard_program
cc		( void )
cc	{
cc	    if ( LEXSTD::default_program != NULL_STUB )
cc	        return;
cc

lex	begin standard lexical program;
lex
cc	    begin_program ( type_name, MAX_TYPE );
cc
cc	    uns32 main;
cc	    NDL::new_table ( main, MASTER );
cc	    uns32 word;
cc	    NDL::new_table ( word, word_t );
cc	    uns32 natural_number;
cc	    NDL::new_table
cc		( natural_number, natural_number_t );
cc	    uns32 number;
cc	    NDL::new_table ( number, number_t );
cc	    uns32 mark;
cc	    NDL::new_table ( mark, mark_t );
cc	    uns32 quoted_string;
cc	    NDL::new_table
cc		( quoted_string, quoted_string_t );
cc	    uns32 separator;
cc	    NDL::new_table ( separator, separator_t );
cc	    uns32 comment;
cc	    NDL::new_table ( comment, comment_t );
cc	    uns32 horizontal_space;
cc	    NDL::new_table
cc		( horizontal_space,
cc		  horizontal_space_t );
cc	    uns32 line_break;
cc	    NDL::new_table ( line_break, line_break_t );
cc	    uns32 bad_end_of_line;
cc	    NDL::new_table ( bad_end_of_line, MASTER );
cc	    uns32 bad_end_of_file;
cc	    NDL::new_table ( bad_end_of_file, MASTER );
cc	    uns32 escaped_char;
cc	    NDL::new_table ( escaped_char, ATOM );
cc	    uns32 escaped_hex_char;
cc	    NDL::new_table ( escaped_hex_char, ATOM );
cc
cc	    uns32 non_letter_seq_t =
cc		non_letter_escape_sequence_t;
cc	    uns32 unrec_char_t =
cc		unrecognized_character_t;

lex	"<ascii-letter>" = "a-z" | "A-Z";
lex
cc	    const char * ascii_letter_char =
cc	        "abcdefghijklmnopqrstuvwxyz"
cc	        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
cc

lex	"<digit>" = "0-9";
lex
cc	    const char * digit_char = "0123456789";
cc

lex	"<oct-digit>" = "0-7";
lex
cc	    const char * oct_digit_char = "01234567";
cc

lex	"<hex-digit>" = "0-9" | "A-F";
lex
cc	    const char * hex_digit_char =
cc		"0123456789ABCDEF";
cc

lex	"<non-digit>" = ~ "<digit>";
lex
lex	"<letter>" = "<ascii-letter>"
lex	           | "<non-ascii-letter>"
lex
lex	// <non-ascii-letter> ::= UNICODE character in
lex	// one of the code ranges designated in
lex	// ../include/ll_lexeme_non_ascii_letters.h
lex
cc	    uns32 letter;
cc	    NDL::begin_atom_pattern ( letter );
cc	    	NDL::add_characters
cc		     ( ascii_letter_char );
cc		add_non_ascii_letters();
cc	    NDL::end_atom_pattern();
cc

lex	// Context sensitive character classifications,
lex	// e.g., classifying ' as a word character if it
lex	// is followed by a letter, cannot be included
lex	// in character pattern definitions, but are
lex	// noted in comments.  They are accounted for by
lex	// separate lexeme table entries below.
lex

lex	"<non-letter>" = ~ "<letter>";
lex

lex	"<mark-char>" = "+" | "-" | "*" | "~" | "@"
lex	              | "#" | "$" | "%" | "^" | "&"
lex	              | "=" | "|" | ">" | "_" | "!"
lex	              | "?" | ":";
lex	              //
lex	              // Also . not followed by a digit
lex	              //      / not surrounded by digits
lex	              //      < not beginning escaped
lex	              //        hex character
lex
cc	    const char * mark_char =
cc		"+-*~@#$%^&=|>_!?:";
cc

lex	"<non-slash-char>" = ~ "/";
lex

lex	"<separator-char>" = "(" | ")" | "[" | "]"
lex	                   | "{" | "}" | ";" | "`";
lex	              //
lex	              // Also , not surrounded by digits
lex	              //      ' not followed by a letter
lex
cc	    const char * separator_char = "()[]{};`";
cc

lex	"<line-break-char>" = "<LF>" | "<VT>" | "<FF>"
lex	                    | "<CR>";
lex
cc	    const char * line_break_char = "\n\v\f\r";
cc

lex	"<non-line-break-char>" =
lex	        ~ "<line-break-character>";
lex
lex	"<horizontal-space-char>" = " " | "<HT>";
lex
cc	    const char * horizontal_space_char = " \t";
cc

lex	begin main master table;
lex
cc	    NDL::begin_table ( main );
cc

lex	   // Whitespace is separated out into 3 types
lex	   // of lexemes:
lex	   //
lex	   //   `horizontal space'  spaces and horizon-
lex	   //                       tal tabs
lex	   //   `line break'        linefeeds, carriage
lex	   //                       returns, form feeds,
lex	   //                       and vertical tabs
lex	   //   `comments'          `//' up to just be-
lex	   //                       fore next line break
lex	   //
lex	   "//" call comment;
cc		   NDL::begin_dispatch ( "/" );
cc		      NDL::begin_dispatch ( "/" );
cc			 NDL::call ( comment );
cc		      NDL::end_dispatch();
cc
cc	    	      // See "/" call mark;  below.
cc		      //
cc		      NDL::begin_dispatch ( OTHER );
cc			 NDL::keep ( 1 );
cc			 NDL::call ( mark );
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   "<horizontal-space-char>"
lex	        call horizontal space;
cc		   NDL::begin_dispatch
cc			( horizontal_space_char );
cc		      NDL::call ( horizontal_space );
cc		   NDL::end_dispatch();
cc

lex	   "<line-break-char>" call line break;
lex
cc		   NDL::begin_dispatch
cc			( line_break_char );
cc		      NDL::call ( line_break );
cc		   NDL::end_dispatch();
cc

lex	   "<letter>" call word;
cc		   NDL::begin_dispatch
cc			( ascii_letter_char );
cc		      add_non_ascii_letters ();
cc		      NDL::call ( word );
cc		   NDL::end_dispatch();
cc

lex	   "'<letter>" call word;
cc		   NDL::begin_dispatch ( "'" );
cc		      NDL::begin_dispatch
cc			( ascii_letter_char );
cc			 add_non_ascii_letters ();
cc			 NDL::call ( word );
cc		      NDL::end_dispatch();
cc
cc	    	      // See "'" output separator below.
cc		      //
cc		      NDL::begin_dispatch ( OTHER );
cc			 NDL::keep ( 1 );
cc			 NDL::output ( separator_t );
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	  "<" "<digit>" match escaped hex character
lex	                   require "<letter>" call word
lex	                else match escaped hex character
lex	                     error non letter escape
lex	                           sequence
lex	                     translate to "?"
lex	                     call word
lex	                else keep 1 call mark;
cc	    	   NDL::begin_dispatch ( "<" );
cc	    	      NDL::begin_dispatch
cc				( digit_char );
cc			    NDL::match
cc				 ( escaped_hex_char );
cc			    NDL::require ( letter );
cc			    NDL::call ( word );
cc		      NDL::ELSE();
cc			    NDL::match
cc				 ( escaped_hex_char );
cc			    NDL::translate_to ( "?" );
cc			    NDL::erroneous_atom
cc			        ( non_letter_seq_t );
cc			    NDL::call ( word );
cc		      NDL::ELSE();
cc		         NDL::keep ( 1 );
cc		         NDL::call ( mark );
cc		      NDL::end_dispatch();
cc
cc		      // See "<" call mark; below.
cc		      //
cc		      NDL::call ( mark );
cc	    	   NDL::end_dispatch();
cc

lex	   "<mark-char>" call mark;
cc	    	   NDL::begin_dispatch ( mark_char );
cc		      NDL::call ( mark );
cc	    	   NDL::end_dispatch();
cc

lex	   "<" call mark;
cc	        // See "<" "<digit>" ...; above.

lex	   "." call mark;  // ".<non-digit>"
cc	        // See ".<digit>" keep 1 call number;
cc	        // below.

lex	   // We assume that the preceding text is not
lex	   // a digit.
lex	   //
lex	   "/" call mark;  // "/<non-slash-char>"
cc	        // See "//" call comment; above.

lex	   // We assume that the preceding text is not
lex	   // a digit or a / or , preceded by a digit.
lex	   //
lex	   "<digit>" keep 0 call natural number;
cc	    	   NDL::begin_dispatch ( digit_char );
cc		      NDL::keep ( 0 );
cc		      NDL::call ( natural_number );
cc	    	   NDL::end_dispatch();
cc

lex	   ".<digit>" keep 1 call number;
lex
cc	    	   NDL::begin_dispatch ( "." );
cc		      NDL::begin_dispatch
cc			   ( digit_char );
cc			 NDL::keep ( 1 );
cc			 NDL::call ( number );
cc		      NDL::end_dispatch();
cc
cc		      // See "." call mark;  above.
cc		      NDL::begin_dispatch ( OTHER );
cc			 NDL::keep ( 1 );
cc			 NDL::call ( mark );
cc		      NDL::end_dispatch();
cc	    	   NDL::end_dispatch();
cc

lex	   "<separator-char>" output separator;
cc	    	   NDL::begin_dispatch
cc			( separator_char );
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc

lex	   // We assume that the preceding text is not
lex	   // a digit.
lex	   //
lex	   "," output separator;
cc	    	   NDL::begin_dispatch ( "," );
cc		      NDL::output ( separator_t );
cc	    	   NDL::end_dispatch();
cc

lex	   "'" output separator;      // "'<non-letter>"
lex
cc	    //         See "'<letter>" call word; above.
cc

lex	   "<Q>" translate to "" call quoted string;
lex
cc	    	   NDL::begin_dispatch ( "\"" );
cc		      NDL::translate_to ( "" );
cc		      NDL::call ( quoted_string );
cc	    	   NDL::end_dispatch();
cc

lex	   "<other>" output unrecognized character;
cc	    	   NDL::begin_dispatch ( OTHER );
cc		      NDL::output ( unrec_char_t );
cc	    	   NDL::end_dispatch();
cc

lex	   output end of file;
lex
cc		   NDL::output ( end_of_file_t );
cc

lex	end main master table;
lex
lex
cc	    	NDL::end_table();
cc

lex	// The below tables are entered from the master
lex	// table with the first zero, one, or two
lex	// characters scanned.
lex
lex
lex	begin comment lexeme table;
cc	    NDL::begin_table ( comment );
cc	    	   

lex	   "<non-line-break-char>" accept;
lex	   return;
cc	           NDL::begin_dispatch
cc			( line_break_char );
cc		       NDL::keep ( 0 );
cc		       NDL::ret();
cc		   NDL::end_dispatch();
cc	           NDL::begin_dispatch ( OTHER );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	end comment lexeme table;
lex
lex
cc	    NDL::end_table();
cc

lex	begin horizontal space lexeme table;
cc	    NDL::begin_table ( horizontal_space );
cc

lex	   "<horizontal-space-char>" accept;
cc	           NDL::begin_dispatch
cc			( horizontal_space_char );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   return;
cc	    	   NDL::ret();
cc

lex	end horizontal space lexeme table;
lex
lex
cc	    NDL::end_table();
cc

lex	begin line break lexeme table;
cc	    NDL::begin_table ( line_break );
cc

lex	   "<line-break-char>" accept;
cc	           NDL::begin_dispatch
cc			( line_break_char );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   return;
cc	    	   NDL::ret();
cc

lex	end line break lexeme table;
lex
lex
cc	    NDL::end_table();
cc

lex	begin word lexeme table;
lex
cc	    NDL::begin_table ( word );
cc

lex	   "<letter>" accept;
cc	           NDL::begin_dispatch
cc			( ascii_letter_char );
cc		       add_non_ascii_letters ();
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   "'<letter>" accept;
cc		   NDL::begin_dispatch ( "'" );
cc		      NDL::begin_dispatch
cc			   ( ascii_letter_char );
cc			 add_non_ascii_letters ();
cc			 NDL::accept();
cc		      NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	    "<" "<digit>" match escaped hex character
lex	                        require "<letter>"
lex	         else match escaped hex character
lex	              error non letter escape sequence
lex	              translate to "?"
lex	         else keep 0 return;
lex	    "<" keep 0 return;
cc
cc		   NDL::begin_dispatch ( "<" );
cc		      NDL::begin_dispatch
cc				( digit_char );
cc			    NDL::match
cc				( escaped_hex_char );
cc			    NDL::require ( letter );
cc		         NDL::ELSE();
cc			    NDL::match
cc				( escaped_hex_char );
cc			    NDL::erroneous_atom
cc			       ( non_letter_seq_t );
cc			    NDL::translate_to ( "?" );
cc		         NDL::ELSE();
cc			    NDL::keep ( 0 );
cc			    NDL::ret();
cc		      NDL::end_dispatch();
cc		         NDL::keep ( 0 );
cc			 NDL::ret();
cc		   NDL::end_dispatch();
cc

lex	   return;
lex
cc	    	   NDL::ret();
cc

lex	end word lexeme table;
lex
cc	    NDL::end_table();
cc

lex	begin mark lexeme table;
cc	    NDL::begin_table ( mark );
cc

lex	   "<mark-char>" accept;
cc	           NDL::begin_dispatch ( mark_char );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   ".<non-digit>" keep 1;
cc	           NDL::begin_dispatch ( "." );
cc		       NDL::begin_dispatch
cc			    ( digit_char );
cc			   NDL::keep ( 0 );
cc			   NDL::ret();
cc		       NDL::end_dispatch();
cc		       NDL::begin_dispatch ( OTHER );
cc			   NDL::keep ( 1 );
cc		       NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   "/<non-slash-char>" keep 1;
cc	           NDL::begin_dispatch ( "/" );
cc		       NDL::begin_dispatch ( "/" );
cc			   NDL::keep ( 0 );
cc			   NDL::ret();
cc		       NDL::end_dispatch();
cc		       NDL::begin_dispatch ( OTHER );
cc			   NDL::keep ( 1 );
cc		       NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	    "<" "<digit>" match escaped hex character
lex	                        keep 0 return;
lex	                  else keep 1;
lex	    "<" accept;
cc		   NDL::begin_dispatch ( "<" );
cc		      NDL::begin_dispatch
cc				( digit_char );
cc		         NDL::match
cc			      ( escaped_hex_char );
cc		         NDL::keep ( 0 );
cc			 NDL::ret();
cc		      NDL::ELSE();
cc		         NDL::keep ( 1 );
cc		      NDL::end_dispatch();
cc			 NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   return;
cc	    	   NDL::ret();
cc

lex	end mark lexeme table;
lex
cc	    NDL::end_table();
cc

lex	begin natural number lexeme table;
cc	    NDL::begin_table ( natural_number );
cc
lex
lex	   // In order to recognize , and / surrounded
lex	   // by digits as number atoms, entries to this
lex	   // table upon recognizing "X<digit>" must do
lex	   // a `keep 1' so the digit will be left to be
lex	   // recognized by <digit>/<digit> or
lex	   // <digit>,<digit>.
lex
lex	   // Alternatively we could have a separate
lex	   // table for the state where the last atom
lex	   // ended with a digit.
lex
lex	   "<digit>" accept;
lex	   "<digit>/<digit>" keep 2 goto number;
lex	   "<digit>,<digit>" keep 2 goto number;
cc	           NDL::begin_dispatch ( digit_char );
cc
cc		       NDL::begin_dispatch ( "/," );
cc			   NDL::begin_dispatch
cc			        ( digit_char );
cc			       NDL::keep ( 2 );
cc			       NDL::go ( number );
cc			   NDL::end_dispatch();
cc		       NDL::end_dispatch();
cc
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   ".<digit>" keep 1 goto number;
cc	           NDL::begin_dispatch ( "." );
cc		       NDL::begin_dispatch
cc			    ( digit_char );
cc			   NDL::keep ( 1 );
cc			   NDL::go ( number );
cc		       NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   return;
cc	    	   NDL::ret();
cc

lex	end natural number lexeme table;
lex
cc	    NDL::end_table();
cc

lex	begin number lexeme table;
lex
cc	    NDL::begin_table ( number );
cc

lex	   // See note on , and / in `natural number'
lex	   // table above.
lex
lex	   "<digit>" accept;
lex	   "<digit>/<digit>" keep 2;
lex	   "<digit>,<digit>" keep 2;
cc	           NDL::begin_dispatch ( digit_char );
cc
cc		       NDL::begin_dispatch ( "/," );
cc			   NDL::begin_dispatch
cc				( digit_char );
cc			      NDL::keep ( 2 );
cc			   NDL::end_dispatch();
cc		       NDL::end_dispatch();
cc
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	   ".<digit>" keep 1;
cc	           NDL::begin_dispatch ( "." );
cc		       NDL::begin_dispatch
cc			    ( digit_char );
cc			  NDL::keep ( 1 );
cc		       NDL::end_dispatch();
cc		   NDL::end_dispatch();
cc

lex	   return;
lex
cc	    	   NDL::ret();
cc

lex	end number lexeme table;
lex
lex
cc	    NDL::end_table();
cc

lex	begin quoted string lexeme table;
lex
cc	    NDL::begin_table ( quoted_string );
cc

lex	    "<Q>" translate to "" return;
lex	            // End quoted string.
lex
cc	           NDL::begin_dispatch ( "\"" );
cc		      NDL::translate_to ( "" );
cc		      NDL::ret();
cc		   NDL::end_dispatch();
cc

lex	    "<" match escaped character
lex	         else accept;
lex
cc		   NDL::begin_dispatch ( "<" );
cc			 NDL::match ( escaped_char );
cc		      NDL::ELSE();
cc			 NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	    "<line-break-char>"
lex	        goto bad end of line;
lex
cc	           NDL::begin_dispatch
cc			( line_break_char );
cc		      NDL::go ( bad_end_of_line );
cc		   NDL::end_dispatch();
cc

lex	    "<other>" accept;
lex
cc	           NDL::begin_dispatch ( OTHER );
cc		       NDL::accept();
cc		   NDL::end_dispatch();
cc

lex	    goto bad end of file;
lex
cc		    NDL::go ( bad_end_of_file );
cc

lex	end quoted string lexeme table;
lex
cc	    NDL::end_table();
cc

lex	begin escaped character atom table;
lex
cc	    NDL::begin_table ( escaped_char );
cc	       NDL::begin_dispatch ( "<" );
cc
cc	#      define BEG(x) NDL::begin_dispatch ( x )
cc	#      define TO(y)  NDL::begin_dispatch \
cc				( ">" ); \
cc				NDL::translate_to \
cc				    ( y ); \
cc			     NDL::end_dispatch()
cc	#      define END    NDL::end_dispatch()

lex	    "<" "ACK" ">" translate to "<ACK>";
cc	          BEG ( "A" ); BEG ( "C" ); BEG ( "K" );
cc		     TO ( "\006" );
cc		  END; END; END;
cc

lex	    "<" "BEL" ">" translate to "<BEL>";
lex	    "<" "BS" ">" translate to "<BS>";
cc	    	  BEG ( "B" );
cc		     BEG ( "E" ); BEG ( "L" );
cc		           TO ( "\007" );
cc		     END; END;
cc		     BEG ( "S" );
cc		        TO ( "\b" );
cc		     END;
cc		  END;
cc

lex	    "<" "CAN" ">" translate to "<CAN>";
lex	    "<" "CR" ">" translate to "<CR>";
cc	          BEG ( "C" );
cc		     BEG ( "A" ); BEG ( "N" );
cc		           TO ( "\030" );
cc		     END; END;
cc		     BEG ( "R" );
cc		        TO ( "\r" );
cc		     END;
cc		  END;
cc

lex	    "<" "DC1" ">" translate to "<DC1>";
lex	    "<" "DC2" ">" translate to "<DC2>";
lex	    "<" "DC3" ">" translate to "<DC3>";
lex	    "<" "DC4" ">" translate to "<DC4>";
lex	    "<" "DEL" ">" translate to "<DEL>";
lex	    "<" "DLE" ">" translate to "<DLE>";
cc	          BEG ( "D" );
cc		     BEG ( "C" );
cc		         BEG ( "1" );
cc		             TO ( "\021" );
cc		         END;
cc		         BEG ( "2" );
cc		             TO ( "\022" );
cc		         END;
cc		         BEG ( "3" );
cc		             TO ( "\023" );
cc		         END;
cc		         BEG ( "4" );
cc		             TO ( "\024" );
cc		         END;
cc		     END;
cc		     BEG ( "E" ); BEG ( "L" );
cc		         TO ( "\177" );
cc		     END; END;
cc		     BEG ( "L" ); BEG ( "E" );
cc		         TO ( "\020" );
cc		     END; END;
cc		  END;

lex	    "<" "EM" ">" translate to "<EM>";
lex	    "<" "ENQ" ">" translate to "<ENQ>";
lex	    "<" "EOT" ">" translate to "<EOT>";
lex	    "<" "ESC" ">" translate to "<ESC>";
lex	    "<" "ETB" ">" translate to "<ETB>";
lex	    "<" "ETX" ">" translate to "<ETX>";
cc	          BEG ( "E" );
cc		     BEG ( "M" );
cc		         TO ( "\031" );
cc		     END;
cc		     BEG ( "N" ); BEG ( "Q" );
cc		         TO ( "\005" );
cc		     END; END;
cc		     BEG ( "O" ); BEG ( "T" );
cc		         TO ( "\004" );
cc		     END; END;
cc		     BEG ( "S" ); BEG ( "C" );
cc		         TO ( "\033" );
cc		     END; END;
cc		     BEG ( "T" );
cc		         BEG ( "B" );
cc		             TO ( "\027" );
cc		         END;
cc		         BEG ( "X" );
cc		             TO ( "\003" );
cc		         END;
cc		     END;
cc		  END;

lex	    "<" "FF" ">" translate to "<FF>";
lex	    "<" "FS" ">" translate to "<FS>";
cc	          BEG ( "F" );
cc		     BEG ( "F" );
cc		        TO ( "\f" );
cc		     END;
cc		     BEG ( "S" );
cc		        TO ( "\034" );
cc		     END;
cc		  END;
cc

lex	    "<" "GS" ">" translate to "<GS>";
cc	          BEG ( "G" ); BEG ( "S" );
cc		     TO ( "\035" );
cc		  END; END;
cc

lex	    "<" "HT" ">" translate to "<HT>";
cc	          BEG ( "H" ); BEG ( "T" );
cc		     TO ( "\t" );
cc		  END; END;
cc

lex	    "<" "LF" ">" translate to "<LF>";
cc	          BEG ( "L" ); BEG ( "F" );
cc		     TO ( "\n" );
cc		  END; END;
cc

lex	    "<" "NAK" ">" translate to "<NAK>";
lex	    "<" "NL" ">" translate to "<NL>";
lex	    "<" "NUL" ">" translate to "<NUL>";
cc	          BEG ( "N" );
cc		     BEG ( "A" ); BEG ( "K" );
cc		        TO ( "\025" );
cc		     END; END;
cc		     BEG ( "L" );
cc		        TO ( "\n" );
cc		     END;
cc		     BEG ( "U" ); BEG ( "L" );
cc		        begin_dispatch ( ">" );
cc		        {
cc			    static uns32 NUL = 0;
cc		            NDL::translate_to ( 1, & NUL );
cc		        }
cc		        end_dispatch();
cc		     END; END;
cc		  END;
cc

lex	    "<" "Q" ">" translate to "<Q>";
cc	          BEG ( "Q" );
cc		     TO ( "\"" );
cc		  END;
cc

lex	    "<" "RS" ">" translate to "<RS>";
cc	          BEG ( "R" ); BEG ( "S" );
cc		     TO ( "\036" );
cc		  END; END;
cc

lex	    "<" "SI" ">" translate to "<SI>";
lex	    "<" "SO" ">" translate to "<SO>";
lex	    "<" "SOH" ">" translate to "<SOH>";
lex	    "<" "SP" ">" translate to "<SP>";
lex	    "<" "STX" ">" translate to "<STX>";
lex	    "<" "SUB" ">" translate to "<SUB>";
lex	    "<" "SYN" ">" translate to "<SYN>";
cc	          BEG ( "S" );
cc		     BEG ( "I" );
cc		         TO ( "\017" );
cc		     END;
cc		     BEG ( "O" );
cc			BEG ( "H" );
cc		            TO ( "\001" );
cc		        END;
cc			TO ( "\016" );
cc		     END;
cc		     BEG ( "P" );
cc		         TO ( " " );
cc		     END;
cc		     BEG ( "T" ); BEG ( "X" );
cc		         TO ( "\002" );
cc		     END; END;
cc		     BEG ( "U" ); BEG ( "B" );
cc		         TO ( "\032" );
cc		     END; END;
cc		     BEG ( "Y" ); BEG ( "N" );
cc		         TO ( "\026" );
cc		     END; END;
cc		  END;

lex	    "<" "US" ">" translate to "<US>";
cc	          BEG ( "U" ); BEG ( "S" );
cc		     TO ( "\037" );
cc		  END; END;
cc

lex	    "<" "VT" ">" translate to "<VT>";
cc	          BEG ( "V" ); BEG ( "T" );
cc		     TO ( "\v" );
cc		  END; END;
cc

cc	#	undef BEG
cc	#	undef TO
cc	#	undef END

lex	    "<" "<digit>" match escaped hex character
lex	                  return
lex	            else fail;
cc	    	    NDL::begin_dispatch ( digit_char );
cc		       NDL::match ( escaped_hex_char );
cc		    NDL::ELSE();
cc		       NDL::fail();
cc		    NDL::end_dispatch();
cc	       NDL::end_dispatch();
cc

lex	    fail;
cc	       NDL::fail();
cc

lex	end escaped character atom table;
lex
cc	    NDL::end_table();
cc

lex	begin escaped hex character atom table;
lex
cc	    NDL::begin_table ( escaped_hex_char );
cc

lex	    "<" "<digit>" ">" translate hex 1 1;
lex	    "<" "<digit><hex-digit>" ">"
lex	              translate hex 1 1;
lex	    "<" "<digit><hex-digit><hex-digit>" ">"
lex	              translate hex 1 1;
lex	    "<" "<digit><hex-digit><hex-digit>"
lex            "<hex-digit>" ">"
lex	              translate hex 1 1;
lex	    "<" "<digit><hex-digit><hex-digit>"
lex            "<hex-digit><hex-digit>" ">"
lex	              translate hex 1 1;
lex	    "<" "<digit><hex-digit><hex-digit>"
lex	       "<hex-digit><hex-digit><hex-digit>" ">"
lex	              translate hex 1 1;
lex	    "<" "<digit><hex-digit><hex-digit>"
lex	       "<hex-digit><hex-digit><hex-digit>"
lex            "<hex-digit>" ">"
lex	              translate hex 1 1;
lex	    "<" "<digit><hex-digit><hex-digit>"
lex	       "<hex-digit><hex-digit><hex-digit>"
lex            "<hex-digit><hex-digit>" ">"
lex	              translate hex 1 1;
lex	    "<" "<digit><hex-digit><hex-digit>"
lex	       "<hex-digit><hex-digit><hex-digit>"
lex	       "<hex-digit><hex-digit><hex-digit>" ">"
lex	              translate hex 1 1;
cc	# define HEX begin_dispatch ( hex_digit_char )
cc	# define CLOSE begin_dispatch ( ">" )
cc	# define TRANS NDL::translate_hex ( 1, 1 )
cc	# define END end_dispatch()
cc
cc	       NDL::begin_dispatch ( "<" );
cc	    	    begin_dispatch ( digit_char );
cc		      HEX;
cc			HEX;
cc			  HEX;
cc			    HEX;
cc			      HEX;
cc			        HEX;
cc				  HEX;
cc				    HEX;
cc				      CLOSE;
cc				        TRANS;
cc				      END;
cc				    END;
cc				    CLOSE;
cc				      TRANS;
cc				    END;
cc				  END;
cc				  CLOSE;
cc				    TRANS;
cc				  END;
cc				END;
cc				CLOSE;
cc				  TRANS;
cc				END;
cc			      END;
cc			      CLOSE;
cc			        TRANS;
cc			      END;
cc			    END;
cc			    CLOSE;
cc			      TRANS;
cc			    END;
cc			  END;
cc			  CLOSE;
cc			    TRANS;
cc			  END;
cc			END;
cc			CLOSE;
cc			  TRANS;
cc			END;
cc		      END;
cc		      CLOSE;
cc			TRANS;
cc		      END;
cc		    NDL::end_dispatch();
cc	       NDL::end_dispatch();
cc
cc	# undef HEX
cc	# undef CLOSE
cc	# undef TRANS
cc	# undef END
cc

lex	    fail;
cc	    	    NDL::fail();
cc

lex	end escaped hex character atom table;
lex
cc	    NDL::end_table();
cc

lex	begin bad end of line master table;
cc	    NDL::begin_table ( bad_end_of_line );
cc

lex	    output bad end of line goto main;
cc	            NDL::output ( bad_end_of_line_t );
cc		    NDL::go ( main );
cc

lex	end bad end of line master table;
lex
cc	    NDL::end_table();
cc

lex
lex	begin bad end of file master table;
cc
cc	    NDL::begin_table ( bad_end_of_file );
cc

lex	    output bad end of file goto main;
cc	            NDL::output ( bad_end_of_file_t );
cc		    NDL::go ( main );
cc

lex	end bad end of file master table;
lex
cc	    NDL::end_table();
cc

lex
lex	end standard lexical program;
cc	    NDL::end_program();
cc
cc	    LEXSTD::default_program =
cc		LEX::default_program;
cc	}
