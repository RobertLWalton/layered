// Layered Languages Bracketed Subexpression Parse
// Function Outline
//
// File:	ll_parser_bracketed_parse.outline
// Author:	Bob Walton (walton@acm.org)
// Date:	Sun Dec 25 05:36:00 EST 2016
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.
//
//	vi:filetype=cpp
//
// Outline of parse_bracketed_subexpression executable
// code.
//
// This detailed code outline makes it easier to explain
// a complex function and verify its correctness.
//
// The outline omits tracing code, code to read more
// input, code to update typed_data->end_position, and
// code to set .position attributes.
//
// make_label(first,next):
//     Collect all the tokens from first through next->
//     previous into a single label token.  Print
//     error messages for tokens that cannot be part
//     of a label, and warning messages for separators
//     and marks that are not quoted.  If there are
//     no tokens, create a new token `first' and
//     give it the empty label.  If all tokens have
//     error messages, the label will be empty.
//
// make_type_label(typed_data,next):
//     Make a label as per make_label from the tokens
//     start = typed_data->start_previous->next through
//     next->previous.  If there are no such, just
//     output a `missing type' error message and return.
//     Otherwise, if typed_data->type is MISSING (there
//     was no previous TYPE token), set the new label
//     token type to TYPE, set typed_data->type to the
//     tokens value (the label), and move the token if
//     necessary so it is before typed_data->elements.
//     If on the other hand typed_data->type is not
//     MISSING, check that it equals the new label,
//     print an error message if not, and in any case
//     delete the new label token.
//
// make_attribute_label(typed_data,next):
//     Make a label as per make_label from the tokens
//     start = typed_data->start_previous->next through
//     next->previous.  If there are no such, just
//     output an error message and return.  If there
//     are 2 or more tokens and the last is a bracketed
//     subexpression with typed_data->typed_opening->
//     typed_attr_flags_initiator as its .initiator,
//     do NOT make it part of the label, but instead
//     give it the ATTR_FLAGS token type.  After making
//     the label token give it the ATTR_LABEL token
//     type.
//
// finish_attribute(typed_data,next):
//     Examine typed_data->subtype (the subtype of the
//     last key found).  If it is TYPED_OPENING, TYPED_
//     ATTR_SEP, TYPED_ATTR_NEGATOR, or TYPED_MIDDLE,
//     make_attribute_label(typed_data,next) and give
//     the resulting token the type ATTR_FALSE if the
//     subtype above was TYPED_ATTR_NEGATOR and ATTR_
//     TRUE otherwise.  However, do not do anything
//     if the subtype examined was TYPED_MIDDLE and
//     there are no tokens between the TYPED_MIDDLE
//     token and `next'.
//
//     If instead the subtype is TYPED_ATTR_EQUAL,
//     collect the tokens between start = typed_data->
//     start_previous->next and next->previous into a
//     label token as per make_label and give that token
//     the ATTR_VALUE type.  However, if there is only
//     one token to collect and it is a bracketed
//     subexpression with .initiator equal to typed_data
//     ->typed_opening->typed_attr_multivalue_initiator,
//     just give it the ATTR_MULTIVALUE token type.  And
//     if there is only one token to collect and it has
//     a value illegal in the sense of min::is_attr_
//     legal, print an error message and give the token
//     the value NONE (and token type ATTR_VALUE, the
//     attribute will be deleted later when its contain-
//     ing subexpression is compacted).
//
// parse_bracketed_subexpression(...)
//
// Arguments:
//
// 	parser
// 	    Current parser.
// 	selectors
// 	    Current parser selectors.
// 	current
// 	    Next token to parse.  Updated as parse
// 	    proceeds.
// 	indent
// 	    Current paragraph indent.
// 	line_sep
// 	    Line separator if enabled to be found.
// 	    NULL_STUB if disabled.
// 	typed_data
// 	    After reading a typed opening, the parse
// 	    bracketed subexpression function allocates a
// 	    typed_data structure to the stack, initial-
// 	    izes it, and calls itself recursively with
// 	    the typed_data structure as an argument.
// 	    Other calls to the parse bracketed subex-
// 	    pression function have a NULL typed_data
// 	    argument.
// 	line_variables
// 	    To parse an indented paragraph, the parse
// 	    bracketed subexpression function allocates
// 	    a line_variables structure to the stack,
// 	    initializes it, and then makes a series of
// 	    recursive calls to itself each parsing one
// 	    logical line.  The recursive calls update
// 	    the line_variables structure.  This argument
// 	    is non-NULL if and only if the parse
// 	    bracketed subexpression function is being
// 	    asked to parse a logical line.
// 	bracket_stack_p
// 	    Top bracket stack entry.  NULL if empty
// 	    stack.
//
// Return Value:
//
// 	position
// 	    The end position of any line separator that
// 	    ended the parsed subexpression, or
// 	    PARAGRAPH_END if the end of the last logical
// 	    line in a paragraph ended the parsed subex-
// 	    pression, or MISSING_POSITION otherwise.
//
// IMPORTANT: This code assumes EVERY comment is
// immediately followed by a line break or end of file.
// This must be guaranteed by the lexical analyzer.
//
// indentation_mark indentation_found = NULL_STUB
// start_previous = current->previous
//     // If current == start_previous->next, current
//     // is at the beginning of the subexpression
//     // begin parsed.  Tokens may be removed from or
//     // added to the beginning of the subexpression,
//     // so one cannot simply save the initial current
//     // value.
//
// loop to find next token:
//
// NEXT_TOKEN:
//
//     // Variables used by CREATED_PREFIX code block:
//
//	   prefix
//	       The prefix token at the head of the
//	       prefix-n-list that is to be created.  The
//	       prefix-n-list's elements have not yet
//	       been parsed.
//	   separator_found
//	       Result of parse_bracketed_subexpression
//	       that parsed the prefix token, or MISSING_
//	       POSITION if prefix token was copied from
//	       an implied subprefix or implied header.
//	   premature_closing
//	       True if parse_bracketed_subexpression
//	       parsed the prefix token and the prefix
//	       separator encoded in that token was
//	       terminated abnormally by an outer closing
//	       bracket or logical line end.
//
//     NOTE: If prefix was not terminated abnormally,
//           premature_closing is false and separator_
//           found is MISSING_POSITION.
//
//     if not first loop iteration, or if bracket stack
//            head does not exist or has a missing
//            implied prefix:
//         go to NO_IMPLIED_PREFIX
//
//     Insert IMPLIED_PREFIX token before current
//     token.  Value of new token is implied_prefix
//     of top bracket stack entry.
//
//     prefix = new IMPLIED_PREFIX token
//     separator_found = MISSING_SEPARATOR
//     premature_closing = false
//
// CREATED_PREFIX:
//
//     // For input variables see NEXT_TOKEN above.
//
//     prefix_entry = prefix token .type entry in
//          bracketed pass prefix table, or NULL_STUB
//          if none
//     group = prefix_entry->group or MISSING if
//             prefix_entry == NULL_STUB
//     search bracket stack for bracket stack entry with
//            bracket stack entry prefix_type
//               == prefix token .type
//            or non-MISSING bracket stack entry
//               prefix_entry->group == group;
//            stop search at first entry with MISSING
//                 prefix_type
//
//     if bracket stack entry found:
//
//         if prefix token type is IMPLIED_PREFIX:
//             announce error (implied prefix has same
//             type or group as previous prefix in
//             same subexpression)
//             delete prefix token
//             go to NEXT_TOKEN
//
//         close bracket stack entry and specify PREFIX
//               token as closing token
//         close all higher stack entries indicating
//               that prefixes with their type/group
//               were not found
//         return separator_found
//
//     if prefix not first token of subexpression:
//         announce PREFIX token is in error and delete
//         it
//
//     if premature_closing:
//         set PREFIX token type to BRACKETED if PREFIX
//             token was not deleted
//         return separator_found
//
//     if PREFIX token was not deleted:
//         // Start new subexpression beginning with
//         // the PREFIX token
//
//         create new bracket stack entry E with
//                E.prefix_type = PREFIX token .type
//                and E.prefix_entry = prefix_entry
//         push new entry into existing bracket stack
//              to create new bracket stack
//
//         prefix_selectors = selectors
//         if prefix_entry != NULL_STUB:
//             adjust prefix_selectors according to
//                    prefix_entry->new_selectors
//                    setting ALWAYS_SELECTOR on
//
//	   loop to find prefix-n-list subexpression
//	           headed by prefix:
//
//             parse_bracketed_subexpression
//                 with prefix_selectors,
//                 new bracket stack,
//                 indent argument,
//                 line_sep argument if prefix_selectors
//                                      & EALSEP,
//	           set separator_found = result
//
//	       compact_prefix_separator
//	         with prefix_selectors
//
//	       if bracket stack not closed by another
//	                  PREFIX token with same .type
//	                  or group as the current
//	                  PREFIX token:
//	           return separator_found
//
//	       prefix = PREFIX token that closed bracket
//	                stack
//
//	       if .type of prefix != .type of previous
//	                              prefix:
//	           find entry E for new .type in
//	           bracketed pass prefix table (entry
//	           must exist because .types have the
//	           same group), recompute prefix_selec-
//	           tors E, and set bracket stack top
//	           entry prefix_type = new .type and
//	           bracket stack top entry prefix_entry
//	           to E
//
//	       iterate loop to find prefix-n-list
//	               subexpression headed by prefix
//
//     iterate loop to find next token
//	    
// NO_IMPLIED_PREFIX:
//
//     skip line break, comment, and indent_before_
//          comment tokens; if a blank line is
//          skipped, set parser->at_head = true
//
//     if we skipped some tokens:
//
//         assert that current is indent or end of file
//
//         current_indent = indent of current token if
//             this is indent token or to 0 if current
//             token is end of file
//
//         delete what has been skipped, but print a
//             WARNING message if any comment deleted
//             had less indent than the current_indent,
//             using indent_before_comment tokens to
//             determine comment indent
//
//     if indentation_found != NULL_STUB:
//
//         // Indentation was found below, but we
//         // deferred processing it until we could skip
//         // stuff as above to discover paragraph
//         // indentation.
//
//         assert that current is indent or eof token
//             // This is first indent or eof following
//             // indentation mark.
//
//         compute new_selectors from current selectors
//                 and indentation_found->new_selectors
//
//         if paragraph has some lines (i.e., current is
//            an indent token whose indent is greater
//            than the indent argument):
//
//             paragraph_indent = current->indent
//             remove current (indent) token and set
//                    current to following token
//
//	       allocate and initialize line_variables:
//	           paragraph_master = 0
//	           line_master = 0
//	           paragraph_header = MISSING
//	           line_header = MISSING
//	           header_selectors = new_selectors
//	           line_selectors = new_selectors
//	           instructions = 0
//
//             loop to parse paragraph lines:
//
//                 // Move to end of paragraph line and
//                 // replace current token by result.
//                 //
//                 parse_bracketed_subexpression with
//                     new_selectors, paragraph_indent,
//                     indentation_found->line_sep
//                       if new_selectors & EALSEP,
//                     line_variables,
//                     bracket stack
//                     set separator_found = result
//
//                 if bracket stack top closed:
//                     require that there was no line
//                             ending separator and
//                             adjust end of line to
//                             just before closing
//                             tokens (bracket, indent,
//                             end of file, etc. )
//
//                 if line is not empty or line separa-
//                         tor ended line:
//                     compact line found
//                              with new_selectors,
//                             .initiator =
//                                 LOGICAL_LINE,
//                             .terminator =
//                                 line separator
//                                 if found, else <LF>,
//                             token type = BRACKETING,
//                             token value_type =
//                                 LOGICAL_LINE
//
//                 if separator found, continue loop to
//                    parse next paragraph line
//
//                 end loop if top of bracket stack
//                     closed, or current is end-of-file
//
//	           require that current is indent token
//
//                 end loop if current has has indent
//                     less than paragraph_indent
//
//	           remove current (indent) token and
//	                  set current to next token
//                 iterate loop to parse next paragraph
//                         line
//
//         // Compact paragraph lines into a
//         // paragraph.
//         //
//         if bracket stack top closed:
//              adjust end of paragraph to just before
//              closing tokens
//
//         remove indentation mark (from just before
//                paragraph lines)
//
//         compact paragraph lines
//             with new_selectors,
//             .initiator = indentation_found->label,
//             .terminator = INDENTED_PARAGRAPH,
//             token type = BRACKETING,
//             token value_type =
//                       indentation_found->label
//
//	   if bracket stack top closed
//	        return MISSING_POSITION
//	   indentation_found = NULL_STUB
// 	 
//     // Continuation after any indented paragraph,
//     // or if there was no indented paragraph.
//     // Current is NOT a line-break, comment, or
//     // indent-before-comment.
//
//     if current is end-of-file:
//
//         return PARAGRAPH_END
//		      if and selectors & EAPBREAK
//		  MISSING_POSITION
//		      otherwise
//
//     else if current is indent:
//
//         if ! at_start and parser->at_head:
//	       return PARAGRAPH_END
//
//         else if current->indent is at or before
//                 indent argument,
//                 and selectors & EALEINDENT:
//             return MISSING_POSITION
//
//         else if current->indent is before indent
//                 argument, and selectors & EALTINDENT:
//             return MISSING_POSITION
//
//         // next token is part of continuation line
//         //
//         delete current indent token
//
//     assert indentation_found == NULL_STUB
//     assert current token is NOT end of file, comment,
//           indent before comment, indent, or
//           line break
//
//     parser->at_head = false
//
//     if current is quoted string:
//         if ! at_start and current->previous is quoted
//                           string:
//             merge quoted strings
//         current = current->next
//         at_start = false
//         iterate loop to find next token
//    
//     lookup key in bracket pass bracket table
//
//     loop to refine key until it is selected:
//
//         if key == NONE:
//
//             if at_start and
//                         typed_data argument != NULL
//                         and current is mark:
//
//                 // Current is mark at beginning of
//                 // typed bracketed subexpression:
//                 // turn current into TYPE token.
//                 //
//                 selectors = saved selectors
//                 type = current->value
//                 has_mark_type = true
//                 current->type = TYPE
//                 ++ attr_count
//
//             // Move to next token.
//             //
//             current = current->next
//             at_start = false
//             iterate loop to find next token
//
//         if key is selected opening bracket or typed
//                opening:
//
//             compute new_selectors from existing
//                     selectors and key
//
//             create new bracket stack entry with
//                    opening bracket = key
//             push new entry into existing bracket
//                  stack to create new bracket stack
//
//	       allocate new typed data, tdata, to stack,
//		        for use only if key is typed
//		        opening
//
//	       is_mark_prefix = false
//
//	       if key is opening bracket:
//
//                 parse_bracketed_subexpression with
//                   new_selectors,
//                   new bracket stack
//                   indent argument,
//                   line_sep argument
//                       if new_selectors & EALSEP,
//	             set separator_found = result
//
//	       else if key is typed opening:
//
//                 initialize tdata typed_data
//                            structure:
//		       typed_opening = key
//		       saved_selectors = new_selectors
//		       middle_count = attr_count = 0
//		       start_previous =
//		           current->previous
//		       elements = attributes = NULL_STUB
//		       end_position = MISSING_POSITION
//		       subtype = TYPED_OPENING
//		       type = MISSING
//		       has_mark_type = false
//
//
//                 parse_bracketed_subexpression with
//                     selectors from key->attr_
//                         selectors plus ALWAYS_
//                         SELECTOR, and selector
//                         options from new_selectors
//                     new bracket stack,
//                     indent argument,
//                     line_sep argument
//                         if new_selectors & EALSEP,
//                     tdata contining typed opening
//	               set separator_found = result
//
//	           // We do typed bracketed subexpres-
//	           // sion finishing here that is logi-
//	           // cally done by TYPED_CLOSING, but
//	           // is instead done here because the
//	           // TYPED_CLOSING may be missing and
//	           // thus be inserted below to correct
//	           // its being missing.
//
//	           if tdata.has_mark_type:
//	               type_token = first token of
//	                            subexpression
//
//	               if subexpression has only one
//	                       token, its mark type:
//	                  is_mark_prefix = true
//
//	               else if subexpression does not
//	                       end with a mark:
//	                   print error message that
//	                   says typed_token->value has
//	                   been inserted at end of
//	                   subexpression (but do not
//	                   actually insert anything)
//
//	               else if subexpression ends with
//	                       a mark:
//	                   if the mark differs from
//	                          type_token->value:
//	                       reset type_token->value
//	                             to a label whose
//	                             components are the
//	                             marks at the
//	                             beginning and end
//	                             of the subexpres-
//	                             sion
//
//	                   delete the subexpression
//	                          ending mark (which
//	                          cannot be the
//	                          type_token)
//
//	               if the subexpression now has
//	                      more than one token:
//	                   tdata.elements =
//	                       type_token->next
//
//	           else if tdate.has_mark_type is false
//	                   and tdata.middle_count is
//	                   odd:
//	               print error message saying mis-
//	                     sing typed middle at end
//	                     of subexpression has been
//	                     inserted (but do not
//	                     actually insert anything),
//	                     and if there are subex-
//	                     pression elements after
//	                     the last typed middle and
//	                     tdata.elements is NULL_
//	                     STUB, set tdata.elements
//	                     to token after last middle
//
//	           else if tdate.has_mark_type is false
//	                   and tdata.middle_count is
//	                   even:
//
//	               // Note TYPED_ATTR_BEGIN can
//	               // only happen here if typed
//	               // attribute beginning was AFTER
//	               // an attribute, as if it is
//	               // after a beginning type,
//		       // tdata.subtype is set to
//		       // TYPED_ATTR_SEP instead.
//
//	               if tdata.subtype ==
//	                       TYPED_OPENING or
//	                       TYPED_MIDDLE, and there
//	                       are subexpression tokens
//	                       after the TYPED_OPENING
//	                       or TYPED_MIDDLE
//	               OR if tdata.subtype =
//	                       TYPED_ATTR_BEGIN:
//
//	                   if there are NO subexpres-
//	                            sion tokens after
//	                            TYPED_OPENING,
//	                            TYPED_MIDDLE,
//	                            or TYPED_ATTR_
//	                            BEGIN:
//	                       print an error message
//	                             indicating the
//	                             type is missing
//
//			   else:
//	                       collect these tokens
//	                           into a single token
//	                           with value being the
//	                           label made from the
//	                           tokens and type =
//	                           TYPE
//
//	                       if there is no beginning
//	                                type:
//	                           move end TYPE token
//	                                to before ele-
//	                                ments if any
//	                       else if end TYPE token
//	                               matches
//	                               beginning type:
//	                           delete end TYPE token
//	                       else announce type mis-
//	                            match error indica
//	                            ting end type
//	                            ignored and delete
//	                            end TYPE token
//
//		       else finish any unfinished
//		            attribute at end of subex-
//		            pression and move any
//		            attributes after elements
//		            to just before elements
//
//             if closing was found that did not match
//                        top of closing stack, or
//                        logical line end was found:
//                 print error message 
//                 if non-matching closing was found:
//                      adjust end of subexpression to
//                      just before that closing
//
//             else remove closing bracket, setting end
//                  of subexpression to end of closing
//                  bracket
//
//             remove opening bracket
//
//             if key is opening bracket:
//
//                 call opening bracket reformatter if
//                      any, and if none or if compac-
//                      tion requested by reformatter:
//                 compact subexpression with
//                     new_selectors,
//                     .initiator =
//                         key opening bracket,
//                     .terminator =
//                         key closing bracket,
//                     token type = BRACKETING,
//                     token value_type =
//                         key opening bracket
//
//             else if key is typed opening:
//              
//                 compact subexpression with attributes
//                         taken from tokens before
//                         tdata.elements (those with
//                         token types TYPE, ATTR_...)
//                         and elements taken from
//                         typed_data.element on;
//                         token type =
//                               PREFIX if
//                                  .type attribute is
//                                        present,
//                                  tdata.middle_count
//                                        == 0, and
//                                  tdata.has_mark_type
//                                        is false,
//                               else BRACKETING if
//                               .type is the only
//                               attribute or there are
//                               no attributes, else
//                               BRACKETED
//                         token value_type = .type
//                               attribute value if
//                               token type is PREFIX,
//                               else MISSING
//
//    		   delete tokens from which attributes
//    		          were taken
//
//    		   if token type == PREFIX:
//		       goto CREATED_PREFIX with
//		           prefix = the prefix token
//		           separator_found from parse
//		               of prefix token
//		           premature_closing = true
//		               iff bracket stack not
//		               closed by PREFIX token's
//		               typed opening's closing
//		               bracket
//
//             if closing bracket was found that did
//                        not match top of closing
//                        stack, or logical line end
//                        found:
//                 return separator_found
//             else:
//                 iterate loop to find next token
//
//         if key is closing bracket, and line_variables
//                is missing or selectors & EAOCLOSING,
//                and closing bracket matches the
//                closing bracket of the first entry of
//                the bracket stack, or of any entry if
//                selectors & EAOCLOSING:
//             close bracket stack entry that matches
//                   key
//             close all higher stack entries indicating
//                   that their closing brackets were
//                   not found and their subexpressions
//                   terminated just before the first
//                   token of key
//             return MISSING_POSITION
//
//         if key is selected indentation mark and
//                current is end of file or line break
//                or comment:
//             indentation_found = key
//             iterate loop to find next token
//             // See above for indented paragraph
//             // processing.
//
//         if key is line separator matching line_sep
//                argument and selectors & EALSEP:
//             remove line separator
//             return end position of removed separator
//
//         if key is typed middle or typed double middle
//                matching typed_middle or typed double
//                middle component of typed_opening
//                component of a non-NULL typed_data
//                argument and typed_data->has_mark_type
//                is false:
//
//             remove typed middle or double middle key
//
//             if typed_data->middle_count is even:
//                 if there is no previous typed key
//                          after the typed opening in
//                          the subexpression and there
//                          are tokens between the typed
//                          opening and the typed
//                          middle:
//                     make these tokens into a label
//                     and replace them with a TYPE
//                     token having the label as token
//                     value; if TYPE token is after
//                     elements, move it to before
//                     elements
//	           else if there is some key in the
//	                   subexpression after the typed
//	                   opening:
//	               finish any unfinished attribute
//	               just before the typed middle and
//	               move any attributes after ele-
//	               ments to just before elements
//
//              else if typed_data->middle_count is odd:
//                  if typed_data->elements == NULL and
//                           there are elements before
//                           typed middle:
//                      set typed_data->elements to
//                          point at the first of these
//                          elements
//
//	       typed_data->subtype = TYPED_MIDDLE
//
//             ++ typed_data->middle_count
//
//             if key was typed double middle:
//                 ++ typed_data->middle_count
//                 iterate loop to find next token
//
//	       if typed_data->middle_count is NOW even:
//	           selectors argument =
//	              typed_data->saved_selectors
//	       else if typed_data->middle_count is NOW
//	               odd:
//                 selectors argument non-options =
//                      typed_data->typed_opening
//                                ->attr_selectors
//                    | ALWAYS_SELECTOR
//
//             iterate loop to find next token
//
//         if key is typed attribute begin matching
//                typed_attr_begin component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is no previous typed key after
//                      the typed opening in the
//                      subexpression and there are
//                      tokens between the typed opening
//                      and the typed attribute begin:
//                 make these tokens into a label and
//                      replace them with a TYPE token
//                      having the label as token value
//                 remove the typed attribute begin key
//                 typed_data->subtype = TYPED_ATTR_SEP
//
//	       else if typed_data->middle_count > 0 and
//	               there are tokens between the
//	               previous typed middle and the
//	               typed attribute begin:
//	           remove the typed attribute begin key
//	           finish any unfinished attribute just
//	                  before the typed attribute
//	                  begin
//	           move any attributes after elements to
//	                just before elements
//
//	       else:
//	           announce typed attribute begin to be
//	               a punctuation error that is
//	               ignored
//	           remove it
//
//             iterate loop to find next token
//
//         if key is typed attribute equal matching
//                typed_attr_equal component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_
//                data->has_mark_type is false:
//
//             if there is a previous typed key in the
//                      subexpression that is a typed
//                      middle, typed attribute separa-
//                      tor, or typed attribute negator,
//                      and there are tokens between
//                      this previous typed key and the
//                      typed attribute equal:
//                 make these tokens into an attribute
//                      label and optional following
//                      flags
//                 replace these tokens with an ATTR_
//                         LABEL token optionally
//                         followed by an ATTR_FLAGS
//                         token
//                 remove the typed attribute equal key
//
//	       else:
//	           announce typed attribute equal to be
//	           a punctuation error that is ignored,
//	           and remove it
//
//             iterate loop to find next token
//
//         if key is typed attribute separator matching
//                typed_attr_sep component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is a previous typed key in the
//                      subexpression that is a typed
//                      middle, typed attribute separa-
//                      tor, or typed attribute equal,
//                      or typed attribute negator:
//                 finish any unfinished attribute just
//                        before the typed attribute
//                        separator
//                 remove the typed attribute separator
//                        key
//
//	       else announce typed attribute separator
//	            to be a a punctuation error that is
//	            ignored, and remove it
//
//             iterate loop to find next token
//
//         if key is typed attribute negator matching
//                typed_attr_negator component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is a previous typed key in the
//                      subexpression that is a typed
//                      middle or typed attribute
//                      separator, and there are NO
//                      tokens between this previous key
//                      and the typed attribute negator:
//                 remove the typed attribute negator
//                 typed_data->subtype =
//                     TYPED_ATTR_NEGATOR
//                 iterate loop to find next token
//
//	       else do nothing (key will be rejected)
//
//         // reject key
//         //
//         iterate loop to refine key by checking if
//                 there is a shorter key or accepting
//                 token as a non-key if no key found
//
//     iterate loop to find next token
