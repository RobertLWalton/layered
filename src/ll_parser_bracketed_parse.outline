// Layered Languages Bracketed Subexpression Parse
// Function Outline
//
// File:	ll_parser_bracketed_parse.outline
// Author:	Bob Walton (walton@acm.org)
// Date:	Sat Jun  1 11:02:33 EDT 2019
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.
//
//	vi:filetype=cpp
//
// Outline of parse_bracketed_subexpression executable
// code.
//
// This detailed code outline makes it easier to explain
// a complex function and verify its correctness.
//
// The outline omits tracing code, code to read more
// input, code to update typed_data->end_position, and
// code to set .position attributes.
//
// parse_paragraph_element
//         (parser,current,line_variables):
//
//     if line_variables->last_paragraph not null
//         // Special case where paragraph header
//         // ended previous paragraph.  Current ==
//         // line_variables->last_paragraph.
//         //
//         current = current->next
//         if line_variables->at_paragraph_end
//            or line_variable->at_paragraph_beginning
//               and CONTINUING_OPT is off in
//               line_variables->current.selectors:
//             // Paragraph header headed a 1-line
//             // headed paragraph that is now complete.
//             line_variables->last_paragraph = null
//             return false
//     else if line_variables->at_paragraph_end:
//         // Return with 0 tokens if indented
//         // paragraph has ended or we are at end of
//         // file.
//         return false
//
//     loop to get lines of headed paragraph or just
//             get the next line outside a headed
//             paragraph:
//
//         if parser->at_paragraph_beginning and
//                    CONTINUING_OPT is off in
//                    line_variables->current.selectors:
//             // We are in paragraph beginning position
//             // and NOT after a headed paragraph with
//             // CONTINUING option.
//             line_variables->current =
//                 line_variables->paragraph
//
//	   line_variables->at_paragraph_indent = false
//	   if current is indent token:
//
//	       // At this point current->next ==
//	       // parser->first, so we can reset lexical
//	       // master.
//	       if parser->at_paragraph_beginning:
//	           // If in paragraph beginning
//	           // position.
//	           lexical_master =
//	               line_variables->
//	                   current
//	                       .paragraph_lexical_master
//	       else:
//	           lexical_master =
//	               line_variables->
//	                   current.line_lexical_master
//
//	       line_variables->at_paragraph_indent =
//	       if    current->indent
//	          == line_variables->paragraph_indent:
//	           line_variables->
//	               at_paragraph_indent = true
//	           // Used by parse_bracketed_subexpres-
//	           // sion to detect erroneous comment
//	           // following `paragraph indent' on
//	           // a non-comment line.
//	       else if   current->indent
//	               > line_variables->
//	                     paragraph_indent:
//	           announce warning message that logical
//	                    line begins at an indent
//	                    that is greater than the
//	                    current paragraph indent
//
//	       move current to next token and delete
//	            indent token
//
//	   else:
//	       line_variables->at_paragraph_indent =
//	           false
//
//	   selectors = line_variables->current.selectors
//	       // Save selectors for compact_logical_
//	       // line.
//	   maybe_parser_command =
//	       current->value == *PARSER* and
//	       line_variables->last_paragraph is null
//	       // Parser commands are in logical lines
//	       // that contain nothing but a single
//	       // indented paragraph with intentation
//	       // mark *PARSER*, *PARSER* *TEST*, etc.
//	   separator_found =
//	       parse_bracketed_subexpression with
//	           selectors and line_variables
//
//	   if RESET option is on in line_variables->
//	            current.selectors:
//	        // Header token with + reset flag has
//	        // been deleted; current is next token.
//	        line_variables->paragraph =
//	            line_variables->
//	                indentation_paragraph
//	        line_variables->implied_paragraph =
//	            line_variables->
//	                indentation_implied_paragraph
//	        line_variables->current =
//	            line_variables->paragraph
//	        if line_variables->last_paragraph null:
//	            iterate loop to get next line
//	        else:
//	            compact_paragraph from
//	                line_variables.last_paragraph to
//	                    current
//	            line_variables->last_paragraph =
//	                null
//	            return false
//
//	   line_variables->at_paragraph_end =
//	       current is end of file token, or
//	       current is indent token and indent is
//	               less than line_variables->
//	               paragraph_indent
//
//	   if parse_bracketed_subexpression did not
//	            return any tokens:
//	       // Line scanned had nothing but comments.
//	       // This also happens after a line
//	       // separator ended line that could have
//	       // been ended by indentation.
//
//	       if not line_variables->at_paragraph_end:
//	           continue loop to get lines
//	       if line_variables->last_paragraph not
//	          null:
//	           compact_paragraph from
//	               line_variables->last_paragraph to
//	                   just before current
//	       line_variables->last_paragraph = null
//	       return false
//
//	   if parse_bracketed_subexpression returned
//	            more than one token, or returned a
//	            single token that is neither a
//	            headed paragraph or headed line:
//	       compact_logical_line
//               consisting of tokens returned by
//                   parse_bracketed_subexpression,
//               with pass after bracketed subexpression
//               pass, selectors, separator_found,
//               line_variables->line_sep
//             // Now result of parse_bracketed_sub-
//             // expression is a single token contain-
//             // ing the logical line.
//
//	   if parse_bracketed_subexpression returned
//	            a single headed paragraph token:
//
//	       if line_variables->last_paragraph not
//	          null:
//	           compact_paragraph from
//	               line_variables.last_paragraph to
//	                   just before returned token
//	           current = returned token
//	           line_variables->last_paragraph =
//	               returned token
//	           return false
//	           // Returned headed paragraph token
//	           // will be processed by next call
//	           // to this function.
//
//	       if parser->at_paragraph_beginning and
//                        CONTINUING_OPT is off in
//                        line_variables->current
//                                       .selectors,
//                        or if line_variables->
//                              at_paragraph_end:
//                 return false
//                 // Returned headed paragraph token
//                 // is 1-line paragraph.
//             else:
//                 line_variables->last_paragraph =
//                     returned token
//
//         else if line_variables->last_paragraph
//                                 is null:
//             return maybe_parser_command
//             // Return logical line or headed line
//             // token that is not in headed paragraph.
//
//         else if parser->at_paragraph_beginning and
//                        CONTINUING_OPT is off in
//                        line_variables->current
//                                       .selectors,
//                        or if line_variables->
//                              at_paragraph_end:
//	       compact_paragraph from
//	           line_variables.last_paragraph to
//	               just before first token AFTER
//	               tokens returned by parse_
//	               bracketed_subexpression or
//	               compact_logical_line above
//	       line_variables->last_paragraph = null
//	       return false
//	       // Return complete headed paragraph.
//
//	   iterate loop to find next line of headed
//	           paragraph (as line_variables->
//	           last_paragraph is now not null)
//	                  
//
// make_label(first,next):
//     Collect all the tokens from first through next->
//     previous into a single label token.  Print
//     error messages for tokens that cannot be part
//     of a label, and warning messages for separators
//     and marks that are not quoted.  If there are
//     no tokens, create a new token `first' and
//     give it the empty label.  If all tokens have
//     error messages, the label will be empty.
//
// make_type_label(typed_data,next):
//     Make a label as per make_label from the tokens
//     start = typed_data->start_previous->next through
//     next->previous. 
//
//     If there are no label, or label computes as empty
//     label, assume label is "" and print error message.
//
//     Then if typed_data->type is MISSING (there was no
//     previous TYPE token), set typed_data->type to the
//     new label, and if this is not "", set the new
//     label token type to TYPE, increment typed_data->
//     attr_count, and move the TYPE token if necessary
//     so it is before typed_data->elements.
//
//     Otherwise if typed_data->type is NOT MISSING,
//     check that it equals the new label, print an
//     error message if not, and whether equal or not
//     delete the new label token.
//
// make_attribute_label(typed_data,next):
//     Make a label as per make_label from the tokens
//     start = typed_data->start_previous->next through
//     next->previous.  If there are no such, just
//     output an error message and return.  If there
//     are 2 or more tokens and the last is a bracketed
//     subexpression with typed_data->typed_opening->
//     typed_attr_flags_initiator as its .initiator,
//     do NOT make it part of the label, but instead
//     give it the ATTR_FLAGS token type.  After making
//     the label token give it the ATTR_LABEL token
//     type, increment typed_data->attr_count, and set
//     typed_data->attributes to point at the token if
//     typed_data->attributes is null.
//
//     Note that attributes with empty labels will
//     cause an error message and be otherwise ignored
//     in code below.
//
// finish_attribute(typed_data,next):
//     Let start = typed_data->start_previous->next.
//
//     Examine typed_data->subtype (the subtype of the
//     last key found).  If it is TYPED_OPENING, TYPED_
//     ATTR_SEP, TYPED_ATTR_NEGATOR, or TYPED_MIDDLE,
//     make_attribute_label(typed_data,next) and give
//     the resulting token the type ATTR_FALSE if the
//     subtype above was TYPED_ATTR_NEGATOR and ATTR_
//     TRUE otherwise.  However, as an exception, do
//     not do anything if the subtype examined was
//     TYPED_MIDDLE and there are no tokens between
//     the TYPED_MIDDLE token and `next' (i.e., start
//     == next).
//
//     Note that attributes with empty labels will
//     cause an error message and be otherwise ignored
//     in code below.
//
//     If instead the subtype is TYPED_ATTR_EQUAL:
//         if start == next (there are no tokens to
//                           make into a value):
//             output error message that attribute
//                    value is missing and attribute
//                    is ignored
//             create a new token before next of
//                    token type ATTR_VALUE and
//                    value NONE (this will cause
//                    attribute to be ignored in code
//                    below)
//         else if start->next == next (there is just a
//                 single token in the value)
//                 and start-type is not a convertable
//                 type (string or numeric):
//            if the single token has .initiator ==
//                   typed_data->typed_opening
//                   ->typed_attr_multivalue_initiator:
//               token->type = ATTR_MULTIVALUE
//            else:
//               token->type = ATTR_VALUE
//               if is_attr_legal ( token value ) is
//                                false:
//                  output error message saying value
//                         is not legal and attribute
//                         is ignored
//                  token->value = NONE (this will cause
//                      attribute to be ignored in code
//                      below)
//         else:
//             make_label ( start, next )
//             start->type = ATTR_VALUE
//
// move_attributes(typed_data,next):
//     If there are attributes after the last typed
//     middle (typed_data->attributes not null and
//     typed_data->middle_count not 0) and there are
//     elements (typed_data->elements not null),
//     move the attributes to just before the elements.
//     The attributes to be moved are all the tokens
//     from typed_data->attributes through next->
//     previous.
//
//     Set typed_data->attributes = null.

// parse_bracketed_subexpression(...)
//
// Arguments:
//
// 	parser
// 	    Current parser.
// 	selectors
// 	    Current parser selectors.
// 	current
// 	    Next token to parse.  Updated as parse
// 	    proceeds.
// 	typed_data
// 	    After reading a typed opening, the parse
// 	    bracketed subexpression function allocates a
// 	    typed_data structure to the stack, initial-
// 	    izes it, and calls itself recursively with
// 	    the typed_data structure as an argument.
// 	    Other calls to the parse bracketed subex-
// 	    pression function have a null typed_data
// 	    argument.
// 	line_variables
// 	    This points at the line variables being used
// 	    to parse the current logical line.  These
// 	    variables are updated as the parse proceeds,
// 	    and the updated variables are used to parse
// 	    the next logical line.  Used to determine
// 	    when the current logical line ends.
// 	bracket_stack_p
// 	    Top bracket stack entry.  Null if empty
// 	    stack.  Null if and only if we are being
// 	    called to parse a logical line.
//
// Return Value:
//
// 	position
// 	    The end position of any line separator that
// 	    ended the parsed subexpression, or MISSING_
// 	    POSITION otherwise.
//
// IMPORTANT: This code assumes EVERY comment is
// immediately followed by a line break or end of file.
// This must be guaranteed by the lexical analyzer.
//
// bracketed_pass = parser->pass_stack
//     // Bracketed pass; always the first pass in the
//     // pass stack.
// indentation_found = null
//     // If not null, this is the indentation_mark
//     // parser table entry of an indentation that has
//     // been found, current token is the comment or
//     // line-break or-end-of file following the
//     // indentation mark, and current->previous is the
//     // last token of the indentation mark.
// start_previous = current->previous
//     // If current == start_previous->next, current
//     // is at the beginning of the subexpression
//     // begin parsed.  Tokens may be removed from or
//     // added to the beginning of the subexpression,
//     // so one cannot simply save the initial current
//     // value.  There is always a current->previous,
//     // as the start-of-file token is never removed
//     // from the input.
// parsing_logical_line =
//         bracket_stack_p is null
//     // True iff the parse_bracketed_subexpression
//     // was called to parse a logical line, and not
//     // a sub-subexpression of a logical line.
// bad_comment_position = { MISSING, MISSING }
//     // Begin is set non-MISSING if we are parsing a
//     // logical line beginning at paragraph indent
//     // that starts with a comment.  If it is set
//     // when we get to the first non-whitespace token
//     // on the logical line, a bad comment error will
//     // be announced (comment lines return to caller
//     // before they get to this point).  End is set
//     // to end of any comment or line break skipped.
//
// if parsing_logical_line:
//     line_variables->previous = current->previous
//     line_variables->at_paragraph_beginning =
//         parser->at_paragraph_beginning
//     if line_variables->at_paragraph_indent and
//        current token is a comment:
//          bad_comment_position.begin =
//              current->position.begin
//
// loop to find next token:
//
//     // Note: we come here only on the first time
//     // through the loop, and on subsequent times
//     // we go to NEXT_TOKEN or PREFIX_FOUND.
//
//     // Variables used by PREFIX_FOUND and PREFIX_
//     // PARSE code blocks:
//
//	   prefix
//	       The prefix token at the head of the
//	       prefix-n-list that is to be created.  The
//	       prefix-n-list's elements have not yet
//	       been parsed.
//
//     // Variables used by PREFIX_FOUND code block:
//
//	   separator_found
//	       Result of parse_bracketed_subexpression
//	       that parsed the prefix token, or MISSING_
//	       POSITION if prefix token was copied from
//	       an implied subprefix or implied header.
//
//	   premature_closing
//	       True iff parse_bracketed_subexpression
//	       parsed the prefix token and the prefix
//	       separator encoded in that token was
//	       terminated abnormally by an outer closing
//	       bracket or logical line end.
//
//     NOTE: If prefix was not terminated abnormally,
//           premature_closing is false and separator_
//           found is MISSING_POSITION.
//
//     // Variables used by PARSE_PREFIX_N_LIST code
//     // block:
//
//	   prefix_type
//	       Type of prefix.
//
//	   prefix_entry
//	       Prefix table entry for type of prefix,
//	       or null if none.
//
//	   prefix_group
//	       prefix_entry->group, or prefix_type if
//	       prefix_entry->group is MISSING or
//	       prefix_entry is null.
//
//	   prefix_selectors
//	       Selectors used in parsing the prefix-n-
//	       list headed by the prefix.
//
//     if parsing_logical_line:
//
//         if line_variables->current.implied_header
//                            is MISSING:
//              go to NEXT_TOKEN
//
//         // Insert implied prefix created by line_
//         // variables.
//
//         prefix_entry =
//             line_variables->current.header_entry;
//             // Required to be not null
//         prefix_selectors =
//             line_variables->current.header_selectors;
//         prefix_group =
//             prefix_entry->group
//             // Required to be `paragraph' or `line'.
//
//         if prefix_group == paragraph:
//             if ! line_variables->
//                       at_paragraph_beginning
//                 announce error: implied paragraph
//                     header at beginning of logical
//                     line not in paragraph beginning
//                     position; ignored
//                 go to NEXT_TOKEN
//             copy line_variables->implied_paragraph
//             to line_variables->current
//
//         create new token of type IMPLIED_HEADER,
//             value_type = prefix_entry, value =
//             line_variables->current.implied_header,
//             and insert it before current token.
//         prefix = new token
//         go to PARSE_PREFIX_N_LIST
//
//     else if bracket stack does not have a top entry
//             that has a prefix with a prefix table
//             entry in its value type that has an
//             implied_subprefix:
//         go to NEXT_TOKEN
//
//     else:
//
//         // Insert implied prefix NOT created by line_
//         // variables.
//
//	   p = prefix table entry from the value type of
//	       the top bracket stack entry prefix
//
//         create new token of type IMPLIED_PREFIX,
//             value_type = p->implied_subprefix_type,
//             value = p->implied_subprefix, and insert
//             it before current token.
//             // We will go to PREFIX_FOUND below and
//             // there value_type will be replaced by
//             // any prefix table entry that is found
//             // for the prefix .type.
//         prefix = new token
//
//         if p->group is paragraph:
//             if p->implied_subprefix type has a prefix
//                table entry with `line' group:
//                  prefix->type = IMPLIED_HEADER
//
//         separator_found = MISSING_SEPARATOR
//         premature_closing = false
//
// PREFIX_FOUND:
//
//     // Input variables (see above for definitions):
//     //
//     //	prefix
//     //	separator_found
//     // 	premature_closing
//
//     // At this point prefix->next == current OR
//     // premature_closing is true, current is beyond
//     // prefix, and prefix-n-list will be assumed to
//     // be empty (see FINISH_PREFIX).
//
//     prefix_type = .type of prefix
//     prefix_entry = prefix token .type PREFIX entry in
//          bracketed_pass prefix_table, or null
//          if none
//     prefix_group = prefix_entry->group or prefix_type
//                    if prefix_entry is null or
//                    prefix_entry->group is MISSING
//     search bracket stack for bracket stack entry
//            p with p->prefix_group == prefix_group
//        stop search at end of bracket stack or
//             just before first entry with null
//             prefix
//
//     if bracket stack entry p found by search:
//
//         if prefix token type is IMPLIED_PREFIX:
//             announce error: implied prefix has same
//                 group as previous active prefix in
//                 same subexpression; ignored
//             delete prefix token
//             go to FINISH_PREFIX
//         else if prefix_group is `paragraph' or
//                 `line' and prefix is not itself
//                 an IMPLIED_HEADER and preceeding
//                 tokens from p->prefix to the current
//                 token are NOT all IMPLIED_HEADERs or
//                 IMPLIED_PREFIXes:
//             announce error: explicit prefix has
//                 `paragraph' or `line' group and is
//                 not at the beginning of the logical
//                 line; ignored
//             delete prefix token
//             go to FINISH_PREFIX
//
//         close bracket stack entry p and specify
//               PREFIX token as closing token
//         close all higher stack entries indicating
//               that prefixes with their type/group
//               were not found and their subexpressions
//               ended just before prefix
//
//         return separator_found
//
//     if prefix_group == `paragraph'
//        and
//        line_variables->at_paragraph_beginning
//        and
//        prefix->type != IMPLIED_HEADER
//        and
//        prefix->type != IMPLIED_PREFIX
//        and
//        prefix->previous->type == IMPLIED_HEADER`
//        and
//        top bracket stack top entry is for prefix
//            with `line' group:
//         // Special case of explicit paragraph
//         // header after implied line header.
//         //
//         close top bracket stack entry and specify
//               PREFIX token as closing token
//         return separator_found
//             // Thus implied `line' prefix gets
//             // empty list and will be deleted.
//
//     if typed_data not null:
//         announce error: prefix is inside typed
//             bracketed subexpression; ignored
//         delete prefix token
//         go to FINISH_PREFIX
//
//     if prefix_group == `paragraph':
//         if prefix->type == IMPLIED_PREFIX:
//             announce error: prefix is implied
//                 `paragraph' prefix that is not
//                 an implied header; ignored
//             delete prefix token
//             go to FINISH_PREFIX
//         else if prefix is not first token of
//                 logical line or logical line is
//                 not in paragraph beginning position:
//             announce error: prefix is explicit
//                 `paragraph' prefix that is not at
//                 beginning of a logical line that is
//                 in paragraph beginning position;
//                 ignored
//             delete prefix token
//             go to FINISH_PREFIX
//
//     else if prefix_group == `line' and prefix is
//             NOT at beginning of current logical
//             line and top bracket stack entry is
//             NOT for a `paragraph' prefix:
//         announce error: prefix is `line' prefix that
//             is not at the beginning of a logical line
//             or immediately after a `paragraph'
//             prefix; ignored
//         delete prefix token
//         go to FINISH_PREFIX
//
//     else if prefix not at start of subexpression
//             being parsed by parse_bracketed_
//             subexpression:
//         announce error: prefix is not at beginning of
//             subexpression and does not continue sub-
//             expression started by another prefix of
//             the prefix type or group; ignored
//         delete prefix token
//         go to FINISH_PREFIX
//
// FINISH_PREFIX:
//
//     if premature_closing:
//         set prefix token type to BRACKETED if PREFIX
//             token was not deleted
//         return separator_found
//     else if prefix token was deleted:
//         go to NEXT_TOKEN
//
//     prefix_selectors = selectors
//     if prefix_entry not null:
//         adjust prefix_selectors according to
//                prefix_entry->new_selectors
//                setting ALWAYS_SELECTOR on
//
// PARSE_PREFIX_N_LIST:
//
//     // Parse prefix-n-list headed by prefix token.
//
//     // Input variables (see above for definitions):
//     //
//     //       prefix
//     //       prefix_type
//     //       prefix_entry
//     //       prefix_group
//     //       prefix_selectors
//     //
//     // current == prefix->next at this point
//
//     create new bracket stack entry E with
//            E.prefix = prefix token and
//            E.prefix_group = prefix_group
//     push new entry into existing bracket stack
//          to create new bracket stack
//
//     loop to find prefix-n-list subexpression
//             headed by prefix:
//
//         if prefix_group == `paragraph'
//                 and prefix->type != IMPLIED_HEADER:
//
//             // Implied line header may have been
//             // inserted and deleted before this
//             // explicit paragraph header.  Selectors
//             // may be incorrect because of CONTINUING
//             // flag.
//             //
//	       // At this point we are parsing logical
//	       // line and prefix is explicit.
//	       //
//	       selectors = line_variables->paragraph
//	                                   .selectors
//	       prefix_selectors = selectors
//		  modified by prefix_entry.new_selectors
//		  with ALWAYS_SELECTOR set
//	       line_variables->current
//		  .paragraph_lexical_master =
//		  prefix_entry->paragraph_lexical_master
//	       line_variables->current
//		  .line_lexical_master =
//		  prefix_entry->line_lexical_master
//	       line_variables->current.selectors =
//		  prefix_selectors
//	       line_variables->current.implied_header =
//	          MISSING
//	       line_variables->current.header_entry =
//	          null
//
//	       if RESET option on in prefix_selectors:
//	           require prefix->next == current
//	           free prefix
//	           return MISSING_POSITION
//
//	       implied_header =
//	           prefix_entry->implied_subprefix
//	       if implied_header != MISSING:
//		  header_type = prefix_entry->
//		                implied_subprefix_type
//		  header_entry = prefix_table
//		      PREFIX entry found by header_type
//		      and prefix_selectors
//		  if header_entry exists and has
//		          `line' group:
//		      header_selectors =
//		          prefix_selectors
//		          modified by
//		          header_entry->new_selectors
//		          with ALWAYS_SELECTOR set
//		      line_variables->current
//		          .implied_header =
//		              implied_header
//		      line_variables->current
//		          .header_entry =
//		              header_entry
//		      line_variables->current
//		          .header_selectors =
//		              header_selectors
//
//	       if line_variables->current.selectors
//		  has STICKY_OPT flag set:
//		  line_variables->
//		      implied_paragraph =
//		          line_variables->current
//		  line_variables->sticky_header =
//		      copy of prefix->value object
//		      with .position attribute deleted
//		      // to protect sticky header
//		      // object from garbage collection
//		  line_variables->paragraph
//		      .impiled_header =
//		          line_variables->sticky_header
//		  line_variables->paragraph
//		      .header_entry =
//		          prefix_entry
//		  line_variables->paragraph
//		      .header_selectors =
//		          prefix_selectors
//
//	       else (no STICKY_OPT):
//		  line_variables->paragraph =
//		      line_variables->
//		          indentation_paragraph
//		  line_variables->
//		      implied_paragraph =
//		          line_variables->
//		              indentation_implied_
//		                        paragraph
//
//	       // End of `if' that handles explicit
//	       // paragraph header.
//
//         top of bracket stack->closing_first =
//         top of bracket stack->closing_last = null
//         parse_bracketed_subexpression with
//             prefix_selectors, with new bracket stack,
//             line_variables argument;
//	       set separator_found = result
//
//	   next (token after subexpression) =
//	        top of stack closing first if not
//	        null or current token otherwise
//
//         old_prefix_value_type = prefix->value_type
//             // Save in case this changes or prefix
//             // is deleted; see below
//
//         if prefix-n-list is empty and prefix->type
//                  is IMPLIED_HEADER or IMPLIED_PREFIX
//                  and either prefix_group != `line'
//                  or ! separator_found:
//              remove prefix
//              goto CONTINUE_PREFIX_N_LIST
//
//         if prefix_group == `paragraph' and one of
//                  options EAINDENT, EALEINDENT,
//                  or EALSEP is on in prefix_selectors,
//                  and the prefix-n-list is not empty,
//                  and it is NOT true that the prefix-
//                  n-list consists of a single element
//                  made from a headed line (i.e., a
//                  single element with value_type ==
//                  `line' ):
//             compact_logical_line
//               starting at token after prefix and
//                        ending just before `next',
//               with prefix_separators,
//               separator_found,
//               line_variables->line_sep
//
//	   prefix->value_type = prefix_group if
//	       prefix_group == `paragraph' or `line'
//	       else MISSING;
//
//         if prefix_entry not null and has a non-null
//                         reformatter:
//            call reformatter with bracket_pass,
//                 prefix_selectors, tokens from prefix
//                 up to next, and either line_sep->
//                 label if separator_found or MISSING
//                 otherwise
//            if reformatter returns false:
//                goto CONTINUE_PREFIX_N_LIST
//
//	   compact_prefix_list with bracket_pass->
//	       next, prefix_selectors, tokens from
//	       prefix up to next, separator_found if
//	       prefix_group == `line', line_variables->
//	       line_sep->label if it exists
//
//    CONTINUE_PREFIX_N_LIST:
//
//	   if bracket stack not closed by another
//	              PREFIX token with same .type
//	              or group as the current
//	              PREFIX token:
//	       return separator_found
//
//	   prefix = PREFIX token that closed bracket
//	            stack (from bracket stack closing_
//	            first)
//	   current top bracket stack entry prefix =
//	           (new) prefix
//
//	   if prefix->value_type is not equal to
//	                         old_prefix_value_type:
//	       // We must fix up prefix related values
//	       prefix_entry = prefix->value_type if that
//	                      is a prefix table entry
//	                      else null
//	       prefix_type = prefix_entry->label if
//	                     prefix_entry not null else
//	                     prefix->value_type
//	       prefix_group = prefix_entry->group if
//	                      that exists else
//	                      prefix_type
//	       current top bracket stack entry
//	               prefix_group = prefix_group
//	       prefix_selectors = selectors modified by
//	           prefix_entry->new_selectors with
//	           ALWAYS_SELECTOR added if prefix_entry
//	           is not null
//
//	   iterate loop to find prefix-n-list
//	           subexpression headed by prefix
//
// NEXT_TOKEN:
//
//     // Come here with `current' set to next token
//     // to process.
//

//     // This main loop does the following:
//     //
//     // (1) Delete comments and line breaks.
//     // (2) Handle indentation_marks already found.
//     // (3) Return to caller on end-of-file or logical
//     //     line ending indent token.
//     // (4) Delete any continuation line indent token
//     //     and loop to NEXT_TOKEN.
//     // (5) Announce bad comments if any (comment
//     //     lines never come here).
//     // (6) Process non-indent, non-line-break, non-
//     //     end-of-file, non-comment token or multi-
//     //     token key.
//     // (7) Iterate loop to NEXT_TOKEN.
//
//     // Delete comments and line breaks and set
//     // parser->at_paragraph_beginning if appropriate.
//
//     skip line break and comment tokens, setting
//          bad_comment_position end to the end of any
//          token skipped, and setting parser->at_
//          paragraph_beginning = true if a blank line
//          is skipped
//
//     if indentation_found is not null
//
//         // Indentation was found below, but we
//         // deferred processing it until we could skip
//         // stuff as above to find indent token
//         // following paragraph indentation mark.
//
//         assert that current is indent or eof token
//             // This is first indent or eof following
//             // indentation mark.
//
//         new_selectors = selectors modified by
//                 indentation_found->new_selectors
//
//         mark_end = current->previous == last token of
//                    indentation mark
//
//         if paragraph has some lines (i.e., current is
//            an indent token whose indent is greater
//            than line_variables->paragraph_indent):
//
//             allocate line_variables for use in
//             		parsing paragraph
//
//	       initialize line_variables
//	                      .indentation_paragraph
//	                      and
//	                      .indentation_implied_
//	                          paragraph:
//	           paragraph_lexical_master =
//	               indentation_found->
//	                   paragraph_lexical_master
//	           line_lexical_master =
//	               indentation_found->
//	                   line_lexical_master
//	           selectors = new_selectors
//	           implied_header = MISSING
//	           header_entry = null
//
//             // If H = indentation_mark->
//             //            implied_header,
//             // we go through the following loop:
//             //     0 times if H is MISSING
//             //     1 times if H is paragraph header
//             //                with MISSING
//             //                implied_subprefix
//             //     1 times if H is line header
//             //     2 times if H is paragraph header
//             //                with non-MISSING
//             //                implied_subprefix
//             //                (should be a `line'
//             //                header)
//             //
//	       implied_header = indentation_found->
//	                        implied_header
//	       implied_header_type = indentation_found->
//	                             implied_header_type
//	       header_selectors = new_selectors
//
//	       first_time = true
//	       loop while implied_header != MISSING:
//
//	           header_entry =
//	               prefix table PREFIX entry for
//	               implied_header_type and header_
//	               selectors (may be null)
//	           group = header_entry->group if this
//	                   exists and is not MISSING,
//	                   or implied_header_type
//	                   otherwise
//	           modify header_selectors by
//	                  header_entry->new_selectors
//	                  if header_entry is not null
//
//	           if group == `paragraph'
//	                   and first_time:
//	               set line_variables
//	                   .indentation_paragraph
//	                       .implied_header =
//	                           implied_header
//	                       .header_entry =
//	                           header_entry
//	                       .header_selectors =
//	                           header_selectors
//	               set line_variables.indentation_
//	                                  implied_
//	                                  paragraph
//	                   .paragraph_lexical_master =
//	                     header_entry->
//	                       paragraph_lexical_master
//	                       if this is not MISSING
//	                   .line_lexical_master =
//	                     header_entry->
//	                       line_lexical_master
//	                       if this is not MISSING
//
//	               implied_header =
//	                   header_entry->
//	                       implied_subprefix
//	               implied_header_type =
//	                   header_entry->
//	                       implied_subprefix_type
//	               first_time =false
//	               iterate implied_header loop
//	                   
//	           else if group == `line':
//	               set line_variables
//	                  .indentation_implied_paragraph
//	                       .implied_header =
//	                           implied_header
//	                       .header_entry =
//	                           header_entry
//	                       .header_selectors =
//	                           header_selectors
//
//		       if first_time:
//	                   set line_variables
//	                       .indentation_paragraph
//	                           .implied_header =
//	                               implied_header
//	                           .header_entry =
//	                               header_entry
//	                           .header_selectors =
//	                               header_selectors
//	               break implied_header loop
//
//	           else if first_time:
//	               announce that indentation mark
//	                   implied header does not have
//	                   `paragraph' or `line' group;
//	                   cannot begin indented lines;
//	                   ignored
//	               break implied_header loop
//	           else:
//	               // Implied subprefix of paragraph
//	               // header is OK.
//	               //
//	               break implied_header loop
//
//             line_variables.paragraph =
//                 line_variables.indentation_paragraph
//             line_variables.implied_paragraph =
//                 line_variables
//                     .indentation_implied_paragraph
//
//             line_variables.paragraph_indent =
//                 current->indent
//             line_variables.line_sep =
//                 indentation_found->line_sep
//             line_variables.at_paragraph_end = false
//             line_variables.last_paragraph = null
//             clear CONTINUING_OPT from
//                 line_variables.current.selectors
//
//             parser->at_paragraph_beginning = true
//             loop to parse paragraph lines:
//
//                 parse_paragraph_element with
//                     current token and line_variables
//                 if no token returned end loop
//                 iterate loop
//
//         first = mark_end->next
//         // Now tokens from first to just before
//         // current are elements of indented
//         // paragraph.
//
//         remove indentation mark from just before
//                first
//
//         // Compact elements of indented paragraph
//         // into INDENTED_PARAGRAPH token value.
//
//         compact paragraph lines
//             with bracketed_pass->next,
//             new_selectors,
//             .initiator = indentation_found->label,
//             .terminator = INDENTED_PARAGRAPH,
//             token type = BRACKETING,
//             token value_type =
//                       indentation_found->label
//
//	   indentation_found = null
// 	 
//     // Continuation after any indented paragraph,
//     // or if there was no indented paragraph.
//     // Current is NOT a line-break or comment.
//
//     // Return if end of logical line.  Otherwise if
//     // indent, delete indent (its for continuation
//     // line) and loop to NEXT_TOKEN.  Otherwise fall
//     // through.
//
//     if current is end-of-file:
//         return MISSING_POSITION
//
//     else if current is indent:
//
//         if selectors & EAINDENT:
//             return MISSING_POSITION
//
//         if not at beginning of subexpression
//                   and parser->at_paragraph_beginning
//                   and selectors & EAPBREAK:
//	       return MISSING_POSTION
//
//         else if current->indent is at or before
//                 line_variables->paragraph_indent,
//                 and selectors & EALEINDENT:
//             return MISSING_POSITION
//
//         else if current->indent is before line_
//                 variables->paragraph_indent,
//                 and selectors & EALTINDENT:
//             return MISSING_POSITION
//
//         // next token is part of continuation line
//         //
//         remove current (indent) token and set
//                current to following token
//
//         go to NEXT_TOKEN
//
//     assert indentation_found is null
//     assert current token is NOT end-of-file, comment,
//           indent, or line break
//
//     parser->at_paragraph_beginning = false
//
//     if bad_comment_position.begin is non-MISSING:
//        announce comment after indent that begins
//                 non-comment logical line
//        set bad_comment_position.begin = MISSING
//
//     if current token is quoted string:
//
//	   // Check this quoted string is to be
//	   // concatenated to a PREVIOUS quoted
//	   // string and go to NEXT_TOKEN if not.
//
//	   concat = bracketed_pass->concatenator
//	   current = current->next
//
//	   if concat == DISABLED:
//	       go to NEXT_TOKEN
//	   if current->previous at beginning of
//	                           subexpression:
//	       go to NEXT_TOKEN
//
//	   if concat != ENABLED:
//	       check whether we are now just after a
//	             quoted string that is after one or
//	             two tokens equal to concat that are
//	             after a quoted string
//	       if no:
//	          go to NEXT_TOKEN
//	       if yes: 
//	          remove tokens equal to concat
//
//	   else if concat == ENABLED and we are NOT now
//	           after a quoted string that is itself
//	           after a quoted string:
//	       go to NEXT_TOKEN
//
//	   merge previous 2 tokens (both quoted strings)
//	   go to NEXT_TOKEN
//
//     if current token is the second part of a broken
//        middle lexeme (previous token exists, both
//        current and previous are middle lexemes,
//        middle break is not disabled, current begins
//        with middle break begin and has additional
//        characters, previous ends with middle break
//        end and has previous characters):
//
//        append current->value to previous->value
//               deleting middle begin and end
//        remove current (second middle) token and set
//                current to following token
//        go to NEXT_TOKEN
//
//     if current token is PREFIX token:
//
//        prefix = current
//        current = current->next
//        separator_found = MISSING_POSITION
//        premature_closing = false
//        go to PREFIX_FOUND
//
//     lookup key beginning with current token in
//            bracketed_pass bracket table using
//            selectors
//
//     loop to refine key until it is selected or not
//             found:
//
//         if key not found:
//
//             if at beginning of subexpression
//                   and typed_data argument is not null
//                   and current is mark:
//
//                 // Current is mark at beginning of
//                 // typed bracketed subexpression:
//                 // turn current into TYPE token.
//                 //
//                 typed_data->type = current->value
//                 typed_data->has_mark_type = true
//                 current->type = TYPE
//                 ++ typed_data->attr_count
//
//                 selectors =
//                     typed_data->element_selectors
//
//             // Move to next token.
//             //
//             current = current->next
//             go to NEXT_TOKEN
//
//         // In the following the type of the key is
//         // determined by checking the object subtype
//         // min::packed_subtype_of ( key ).
//
//         if key is opening bracket or typed opening:
//
//             // Note: typed opening is a subclass of
//             // opening bracket.
//
//             new_selectors = selectors modified by
//                 key->new_selectors
//
//             create new bracket stack entry with
//                    opening bracket = key
//             push new entry into existing bracket
//                  stack to create new bracket stack
//
//	       allocate new typed data, tdata, to stack,
//		        for use only if key is typed
//		        opening
//
//	       is_mark_prefix = false
//
//	       if key is opening bracket:
//
//                 parse_bracketed_subexpression with
//                   new_selectors,
//                   new bracket stack
//                   line_variables argument
//	             set separator_found = result
//
//	       else if key is typed opening:
//
//                 initialize tdata typed_data
//                            structure:
//		       typed_opening = key
//		       element_selectors = new_selectors
//		       attribute_selectors =
//		           key->attr_selectors plus
//		           ALWAYS_SELECTOR with options
//		           from new_selectors
//		       middle_count = attr_count = 0
//		       start_previous =
//		           current->previous
//		       elements = attributes = null
//		       end_position = MISSING_POSITION
//		       subtype = TYPED_OPENING
//		       type = MISSING
//		       has_mark_type = false
//
//                 parse_bracketed_subexpression with
//                     tdata.attribute_selectors,
//                     new bracket stack,
//                     line_variables argument,
//                     new tdata,
//	               set separator_found = result
//
//	           // We do typed bracketed subexpres-
//	           // sion finishing here that is logi-
//	           // cally done by TYPED_CLOSING, but
//	           // is instead done here because the
//	           // TYPED_CLOSING may be missing and
//	           // thus be inserted below to correct
//	           // its being missing.
//
//	           token after subexpression =
//	               top stack entry closing_first if
//	               not null, else current
//
//	           if tdata.has_mark_type:
//
//	               type_token = first token of
//	                            subexpression after
//	                            opening bracket
//
//	               if subexpression has only one
//	                       token (its mark type):
//	                  is_mark_prefix = true
//
//	               else if subexpression does not
//	                       end with a mark:
//	                   print error message that
//	                   says typed_token->value has
//	                   been inserted at end of
//	                   subexpression (but do not
//	                   actually insert anything)
//
//	               else if subexpression ends with
//	                       a mark:
//
//	                   if that mark differs from
//	                          tdata.type (== type_
//	                          token->value):
//	                       reset type_token->value
//	                             to a label whose
//	                             components are the
//	                             marks at the
//	                             beginning and end
//	                             of the subexpres-
//	                             sion
//
//	                   delete the subexpression
//	                          ending mark (which
//	                          cannot be the
//	                          type_token)
//
//	               if the subexpression now has
//	                      more than one token:
//	                   tdata.elements =
//	                       type_token->next
//
//	           else if tdata.has_mark_type is false
//	                   and tdata.middle_count is
//	                   odd:
//	               // Because middle_count is odd
//	               // the last recognized key is
//	               // a typed middle.
//
//	               print error message saying mis-
//	                     sing typed middle at end
//	                     of subexpression has been
//	                     inserted (but do not
//	                     actually insert anything)
//
//	               if there are subexpression ele-
//	                        ments after the last key
//	                        (the typed middle) and
//	                        there were no subexpres-
//	                        sion elements before
//	                        this typed middle
//	                        (tdata.elements is null)
//	                   tdata.elements =
//	                       token after last key (the
//	                       typed middle)
//
//	           else if tdata.has_mark_type is false
//	                   and tdata.middle_count is
//	                   even:
//
//	               // Note TYPED_ATTR_BEGIN can
//	               // only happen here if typed
//	               // attribute beginning was AFTER
//	               // an attribute, as if it is
//	               // after a beginning type,
//		       // tdata.subtype is set to
//		       // TYPED_ATTR_SEP instead.
//
//	               if tdata.subtype ==
//	                       TYPED_OPENING or
//	                       TYPED_MIDDLE, and there
//	                       are subexpression tokens
//	                       after the TYPED_OPENING
//	                       or TYPED_MIDDLE
//	                   or if tdata.subtype ==
//	                           TYPED_ATTR_BEGIN:
//
//			    make_type_label
//			        ( tdata,
//			          token after
//			                subexpression )
//
//		       else if tdata.subtype !=
//		                     TYPED_OPENING:
//		           finish_attribute
//			        ( tdata,
//			          token after
//			                subexpression )
//		           move_attributes
//			        ( tdata,
//			          token after
//			                subexpression )
//
// 	       require ! separator_found
// 	           // It must be impossible to find a
// 	           // separator inside brackets.
//
//             if closing was found that did not match
//                        our closing bracket:
//                 if non-matching closing bracket was
//                                 found:
//                      adjust end of subexpression to
//                             just before that closing
//                 print error message indicating our
//                       closing bracket was inserted
//                       just before other closing, but
//                       do not actually insert anything
//
//             else remove closing bracket
//
//             remove opening bracket
//
//             if key is opening bracket:
//
//                 call opening bracket reformatter if
//                              any with new_selectors
//                              and MISSING line sepa-
//                              rator
//                 if no reformatter or if compaction
//                       requested by reformatter:
//                     compact subexpression with
//                         new_selectors,
//                         .initiator =
//                             key opening bracket,
//                         .terminator =
//                             key closing bracket,
//                         token type = BRACKETING,
//                         token value_type =
//                             key opening bracket
//
//             else if key is typed opening:
//              
//                 // At this point the subexpression
//                 // consists of special attribute
//                 // tokens (with token types TYPE,
//                 // ATTR_{LABEL,VALUE,TRUE,FALSE,
//                 // FLAGS,MULTIVALUE}) followed by
//                 // subexpression elements (beginning
//                 // with typed_data.elements which is
//                 // null if there are no elements).
//
//                 // By an attribute label token we
//                 // mean a token of type TYPE or
//                 // ATTR_{LABEL,TRUE,FALSE}.
//
//		   loop through special attribute tokens
//		                making a list of attri-
//		                butes to be handed to
//		                the compact function:
//
//		       for TYPE token:
//		           add to the attribute
//		                list a .type attribute
//		                with value token->value
//		           skip to next attribute label
//		                   token
//
//		       for ATTR_LABEL token:
//		           if token->value is empty
//		                     label:
//		               print empty attribute
//		                     label error message
//		               skip to next attribute
//		                    label token
//		           else add to the attribute
//		                list an attribute with
//		                name = token->value and
//		                value yet unspecified
//
//		       for ATTR_TRUE token:
//		           if token->value is empty
//		                     label:
//		               print empty attribute
//		                     label error message
//		               skip to next attribute
//		                    label token
//		           else add to the attribute
//		                list an attribute with
//		                name = token->value and
//		                value = min::TRUE
//
//		       for ATTR_FALSE token:
//		           ditto but with value =
//		                 min::FALSE
//
//		       for ATTR_VALUE token:
//		           if token->value is NONE:
//		                delete last item of
//		                   attribute list
//		               skip to next attribute
//		                    label token
//		           else install token->value
//		                as value of last attri-
//		                bute in attribute list
//
//		       for ATTR_MULTIVALUE token:
//		           install token->value
//		                as multi-value of last
//		                attribute in attribute
//		                list
//
//		       for ATTR_FLAGS token:
//		           install token->value
//		                as flags of last attri-
//		                bute in attribute list
//
//                 compact subexpression with
//                         bracketed_pass->next,
//                         new_selectors,
//                         attributes taken attribute
//                         list formed above,
//                         elements taken from
//                         typed_data.elements to end
//                         of subexpression,
//                         token type =
//                               PREFIX if
//                                  .type attribute
//                                        value is
//                                        present,
//                                  tdata.middle_count
//                                        == 0, and
//                                  either tdata
//                                        .has_mark_type
//                                        is false or
//                                        or is_mark_
//                                           prefix
//                                  key has prefix_sep-
//                                      arators_allowed
//                                      true
//                               else BRACKETING if
//                                    .type is the only
//                                     attribute
//                                     or there are
//                                     no attributes
//                               else BRACKETED
//                         token value_type = .type
//                               attribute value if
//                               token type is PREFIX,
//                               else MISSING
//
//    		   delete special attribute tokens
//    		       // Delayed until after attribute
//    		       // list has been passed to
//    		       // compact function as attribute
//    		       // list members are not protected
//    		       // from GC.
//
//    		   if compacted token type == PREFIX:
//		       goto PREFIX_FOUND with
//		           prefix = the compacted token
//		           separator_found from parse
//		               of subexpression
//		           premature_closing = true
//		               iff bracket stack not
//		               closed by PREFIX token's
//		               typed opening's closing
//		               bracket
//
//             if closing bracket matching key's closing
//                        bracket NOT found:
//                 return separator_found
//             else:
//                 go to NEXT_TOKEN
//
//         if key is closing bracket:
//             search the bracket stack; if EAOCLOSING
//                    NOT in selectors search only the
//                    top entry, otherwise search ALL
//                    entries top to bottom
//             if entry found with matching closing
//                      bracket:
//                 close bracket stack entry that
//                       matches key, indicating that
//                       the key closed the entry
//                 close all higher stack entries
//                       indicating that their closing
//                       brackets were not found and
//                       their subexpressions terminated
//                       just before the first token of
//                       key
//                 return MISSING_POSITION
//
//         if key is indentation mark:
//             if selectors & EIPARAGRAPH and current is
//                     end of file or line break or
//                     comment:
//                 indentation_found = key
//                 go to NEXT_TOKEN
//                 // See above for indented paragraph
//                 // processing.
//
//         if key is line separator:
//             if key matches line_variables argument->
//                    line_sep and selectors & EALSEP:
//                 remove line separator
//                 return end position of removed
//                        separator
//
//         // Note: In the following the type of the
//         // previous key is determined by checking the
//         // value of typed_data->subtype.  If this is
//         // TYPED_OPENING no previous key in the
//         // subexpression has been (previously) found.
//
//         if key is typed middle matching typed_middle
//                component of typed_opening component
//                of a non-null typed_data argument,
//                or ditto for typed double middle,
//                and typed_data->has_mark_type
//                is false:
//
//             if typed_data->middle_count is even:
//
//                 if there is no previous typed key
//                          after the typed opening in
//                          the subexpression:
//                     if there are tokens between the
//                              typed opening and the
//                              key:
//                         make_type_label
//                             ( typed_data,
//			         first token of key )
//		       else:
//		           set typed_data->type = ""
//	           else if there is some other key in
//	                   the subexpression after the
//	                   typed opening:
//		       finish_attribute
//			   ( tdata,
//			     first token of key )
//		       move_attributes
//		           ( tdata,
//			     first token of key )
//
//              else if typed_data->middle_count is odd
//                      and typed_data->elements is null
//                      and there are elements between
//                          previous typed middle and
//                          current typed middle key:
//
//                  typed_data->elements = first token
//                      after previous typed middle
//
//             remove typed middle or double middle key
//	       typed_data->subtype = TYPED_MIDDLE
//	       typed_data->start_previous =
//	           current->previous
//             ++ typed_data->middle_count
//
//             if key was typed double middle:
//                 ++ typed_data->middle_count
//                 go to NEXT_TOKEN
//
//	       if typed_data->middle_count is NOW odd:
//	           selectors argument =
//	              typed_data->element_selectors
//	       else if typed_data->middle_count is NOW
//	               even:
//                 selectors argument =
//                      typed_data->attribute_selectors
//
//             go to NEXT_TOKEN
//
//         if key is typed attribute begin matching
//                typed_attr_begin component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is no previous typed key after
//                      the typed opening in the
//                      subexpression:
//                 make_type_label
//                     ( typed_data,
//			 first token of key )
//                 remove the typed attribute begin key
//                 typed_data->subtype = TYPED_ATTR_SEP
//	           typed_data->start_previous =
//	               current->previous
//
//	       else if typed_data->middle_count > 0 and
//	               there are tokens between the
//	               previous typed middle and the
//	               typed attribute begin key:
//		   finish_attribute
//		       ( typed_data,
//                       first token of key )
//		   move_attributes
//		       ( typed_data,
//                       first token of key )
//	           remove the typed attribute begin key
//                 typed_data->subtype =
//                     TYPED_ATTR_BEGIN
//	           typed_data->start_previous =
//	               current->previous
//
//	       else:
//	           announce typed attribute begin to be
//	               a punctuation error that is
//	               ignored
//	           remove it
//
//             go to NEXT_TOKEN
//
//         if key is typed attribute equal matching
//                typed_attr_equal component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_
//                data->has_mark_type is false:
//
//             if there is no previous typed key in the
//                      subexpression, or the previous
//                      typed key is a typed middle,
//                      typed attribute separator, or
//                      typed attribute negator:
//                 if previous typed key is typed
//                             attribute negator:
//                     announce that negator is being
//                              ignored
//                 make_attribute_label
//                     ( typed_data,
//                       first token of key )
//                 remove the typed attribute equal key
//                 typed_data->subtype =
//                     TYPED_ATTR_EQUAL
//	           typed_data->start_previous =
//	               current->previous
//
//	       else:
//	           announce typed attribute equal to be
//	           a punctuation error that is ignored,
//	           and remove it
//
//             go to NEXT_TOKEN
//
//         if key is typed attribute separator matching
//                typed_attr_sep component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is no previous typed key in the
//                      subexpression, or the previous
//                      typed key is a typed middle,
//                      typed attribute separator,
//                      typed attribute equal, or
//                      typed attribute negator:
//		   finish_attribute
//		       ( typed_data,
//		         first token of key )
//                 remove the typed attribute separator
//                        key
//                 typed_data->subtype = TYPED_ATTR_SEP
//	           typed_data->start_previous =
//	               current->previous
//
//	       else announce typed attribute separator
//	            to be a a punctuation error that is
//	            ignored, and remove it
//
//             go to NEXT_TOKEN
//
//         if key is typed attribute negator matching
//                typed_attr_negator component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is no previous typed key in the
//                      subexpression, or the previous
//                      typed key is a typed middle or
//                      typed attribute separator,
//                      and if the typed attribute
//                      negator immediately follows the
//                      subexpression beginning or
//                      previous typed key:
//                 remove the typed attribute negator
//                 typed_data->subtype =
//                     TYPED_ATTR_NEGATOR
//	           typed_data->start_previous =
//	               current->previous
//
//                 go to NEXT_TOKEN
//
//         // reject key
//         //
//         iterate loop to refine key (by trying to
//                 find next shorter key) until it is
//                 selected or not found
