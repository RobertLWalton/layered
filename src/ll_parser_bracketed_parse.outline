// Layered Languages Bracketed Subexpression Parse
// Function Outline
//
// File:	ll_parser_bracketed_parse.outline
// Author:	Bob Walton (walton@acm.org)
// Date:	Thu Nov 17 03:09:50 EST 2016
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.
//
//	vi:filetype=cpp
//
// Outline of parse_bracketed_subexpression executable
// code.
//
// This detailed code outline makes it easier to explain
// a complex function and verify its correctness.
//
// The outline omits tracing code, code to read more
// input, code to update typed_data->end_position, and
// code to set .position attributes.
//
// IMPORTANT: This code assumes EVERY comment is
// immediately followed by a line break or end of file.
//
// Arguments:
//
// 	parser
// 	    Current parser.
// 	selectors
// 	    Current parser selectors.
// 	current
// 	    Next token to parse.
// 	indent
// 	    Current paragraph indent.
// 	line_sep
// 	    Line separator if enabled to be found.
// 	    NULL_STUB if disabled.
// 	typed_data
// 	    After reading a typed opening, the parse
// 	    function allocates a typed_data structure
// 	    to the stack, initializes it, and calls
// 	    itself recursively with the typed_data
// 	    structure as an argument.  Other calls to
// 	    the parse function have a NULL typed_data
// 	    argument.
// 	line_variables
// 	    To parse a sequence of logical lines (e.g.,
// 	    an indented paragraph), the parse function
// 	    allocates a line_variables structure to the
// 	    stack, initializes it, and then makes a
// 	    series of recursive calls to itself each
// 	    parsing one logical line.  The recursive
// 	    calls update the line_variables structure.
// 	    This argument is non-NULL if and only if
// 	    the parse function is being asked to parse
// 	    a logical line.
// 	bracket_stack_p
// 	    Top bracket stack entry.  NULL if empty
// 	    stack.
//
// Return Value:
//
// 	position
//
//   indentation_mark indentation_found = NULL_STUB
//   at_start = true
//       // I.e., the current token has no predecessor
//       // input to or created by parse_bracketed_
//       // subexpression
//
//   loop:
//
//     skip line break, comment, and indent_before_
//          comment tokens; if a blank line is
//          skipped, set parser->at_head = true
//
//     if we skipped some tokens:
//
//	  assert that current is indent or end of file
//
//        current_indent = indent of current token if
//            this is indent token or to 0 if current
//            token is end of file
//
//        delete what has been skipped, but print a
//            WARNING message if any comment deleted had
//            less indent than the current_indent, using
//            indent_before_comment tokens to determine
//            comment indent
//
//     if indentation_found != NULL_STUB:
//        // Indentation was found below, but we
//        // deferred processing it until we could skip
//        // stuff as above to discover paragraph inden-
//        // tation.
//
//        assert that current is indent or eof token
//            // This is first indent or eof following
//            // indentation mark.
//
//        compute new_selectors from current selectors
//                and indentation_found->new_selectors
//
//        if paragraph has some lines (i.e., current is
//           an indent token whose indent is greater
//           than the indent argument):
//
//           paragraph_indent = current->indent
//	     remove current (indent) token
//
//	     allocate and initialize line_variables:
//	         paragraph_master = 0
//	         line_master = 0
//	         paragraph_header = MISSING
//	         line_header = MISSING
//	         header_selectors = new_selectors
//	         line_selectors = new_selectors
//	         instructions = 0
//
//           loop to parse paragraph lines:
//
//               // Move to end of paragraph line and
//               // replace current token by result.
//               //
//               parse_bracketed_subexpression with
//                   new_selectors, paragraph_indent,
//                   indentation_found->line_sep
//                     if new_selectors & EALSEP,
//                   line_variables,
//                   bracket stack
//                     if new_selectors & EAOCLOSING;
//                   remember if line ended by line
//                            separator
//
//               if bracket stack top closed:
//                   require that there was no line
//                           ending separator and
//                           adjust end of line to
//                           just before closing tokens
//                           (bracket, indent, end of
//                            file, etc )
//
//               if line is not empty or line separator
//                       ended line:
//                  compact line found
//                           with new_selectors,
//                          .initiator = LOGICAL_LINE,
//                          .terminator = line separator
//                             if found, else <LF>,
//                          token type = BRACKETING,
//                          token value_type =
//                              LOGICAL_LINE
//
//               if separator found, continue loop to
//                  next paragraph line
//
//               end loop if top of bracket stack
//                   closed, or current is end-of-file
//
//		 require that current is indent token
//
//               end loop if current has has indent less
//                   than paragraph_indent
//
//	         remove current (indent) token
//               loop to get next paragraph line
//
//           // Compact paragraph lines into a
//           // paragraph.
//           //
//           if bracket stack top closed:
//              adjust end of paragraph to just before
//              closing tokens
//
//           remove indentation mark (from just before
//                  paragraph lines)
//
//           compact paragraph lines with new_selectors,
//                   .initiator =
//                       indentation_found->label,
//                   .terminator = INDENTED_PARAGRAPH,
//                   token type = BRACKETING,
//                   token value_type =
//                       indentation_found->label,
//
//           at_start = false
//
//	     if bracket stack top closed
//	          return MISSING_POSITION
//	     indentation_found = NULL_STUB
// 	 
//     // Continuation after any indented paragraph,
//     // or if there was no indented paragraph.
//     // Current is NOT a line-break, comment, or
//     // indent-before-comment.
//
//     if current is end-of-file:
//
//        return PARAGRAPH_END
//		     if and selectors & EAPBREAK
//		 MISSING_POSITION
//		     otherwise
//
//     else if current is indent:
//
//        if ( ! at_start and parser->at_head )
//	     return PARAGRAPH_END
//
//        else if current->indent is at or before indent
//                argument, and selectors & EALEINDENT:
//              return MISSING_POSITION
//
//        else if current->indent is before indent
//                argument, and selectors & EALTINDENT:
//           return MISSING_POSITION
//
//        // next token is part of continuation line
//        //
//        delete current indent token
//
//     assert indentation_found == NULL_STUB
//     assert current token is NOT end of file, comment,
//            indent before comment, indent, or
//            line break
//
//     parser->at_head = false
//
//     if current is quoted string:
//        if ! at_start and current->previous is quoted
//                          string:
//           merge quoted strings
//        current = current->next
//        at_start = false
//        iterate top level loop
//    
//     lookup key in bracket pass bracket table
//
//     loop to refine key until it is selected:
//
//       if key == NONE:
//
//         if at_start and
//                     typed_data argument != NULL
//                     and current is mark:
//
//            // Current is mark at beginning of
//            // typed bracketed subexpression:
//            // turn current into TYPE token.
//            //
//            selectors = saved selectors
//            type = current->value
//            has_mark_type = true
//            current->type = TYPE
//            ++ attr_count
//
//         // Move to next token.
//         //
//         current = current->next
//         at_start = false
//         iterate top level loop
//
//       if key is selected opening bracket or typed
//              opening:
//
//          compute new_selectors from existing
//                  selectors and key
//
//          create new bracket stack entry with opening
//                 bracket = key
//          if new_selectors & EAOCLOSING
//             push new entry into existing bracket
//                  stack
//          else
//             create new bracket stack with new entry
//                    as its only entry
//
//	    allocate new typed data, tdata, to stack,
//		     for use only if key is typed
//		     opening
//
//	    if key is opening bracket:
//
//            parse_bracketed_subexpression with
//              new_selectors,
//              new or existing bracket stack
//                  as per EAOCLOSING above,
//              indent argument,
//              line_sep argument
//                  if new_selectors & EALSEP,
//	        set separator_found = result
//
//	    else if key is typed opening:
//
//            initialize tdata typed_data structure:
//		  typed_opening = key
//		  saved_selectors = new_selectors
//		  middle_count = attr_count = 0
//		  start_previous = current->previous
//		  elements = attributes = NULL_STUB
//		  end_position = MISSING_POSITION
//		  subtype = TYPED_OPENING
//		  type = MISSING
//		  has_mark_type = false
//
//	      is_mark_prefix = false
//
//            parse_bracketed_subexpression with
//              selectors from key->attr_selectors
//                  plus ALWAYS_SELECTOR, and selector
//                  options from new_selectors
//              new or existing bracket stack,
//              indent argument,
//              line_sep argument
//                  if new_selectors & EALSEP,
//              tdata contining typed opening
//	        set separator_found = result
//
//	      // We do typed bracketed subexpression
//	      // finishing here that is logically done
//	      // by TYPED_CLOSING, but is instead done
//	      // here because the TYPED_CLOSING may be
//	      // missing and thus be inserted below to
//	      // correct its being missing.
//
//	      if tdata.has_mark_type:
//
//	            type_token = first token of
//	                         subexpression
//
//	            if subexpression has only one token,
//	               its mark type, set is_mark_prefix
//	               to true
//
//	            else if subexpression does not end
//	               with a mark, print error message
//	               that says typed_token->value has
//	               been inserted at end of sub-
//	               expression (but do not actually
//	               insert anything)
//
//	            else if subexpression ends with
//	               a mark:
//
//	               if the mark differs from type_
//	                  token->value, reset type_
//	                  token->value to a label
//	                  whose whose components are the
//	                  marks at the beginning and end
//	                  of the subexpression
//
//	               delete the subexpression ending
//	                      mark (which cannot be the
//	                      type_token)
//
//	            if the subexpression now has more
//	               than one token, set
//	               tdata.elements = type_token->next
//
//	      else if tdata.middle_count is odd, print
//	              error message saying missing typed
//	              middle at end of subexpression has
//	              been inserted (but do not actually
//	              insert anything), and if there
//	              are subexpression elements after
//	              the last typed middle and
//	              tdata.elements is NULL_STUB, set
//	              tdata.elements to token after last
//	              middle
//
//	      else:
//
//	          // Note TYPED_ATTR_BEGIN can only
//	          // happen here if typed attribute
//	          // beginning was AFTER an attribute,
//	          // as if it is after a beginning type,
//		  // tdata.subtype is set to TYPED_
//		  // ATTR_SEP instead.
//
//	          if tdata.subtype == TYPED_OPENING or
//	             TYPED_MIDDLE, and there are sub-
//	             expression tokens after the TYPED_
//	             OPENING or TYPED_MIDDLE, collect
//	             these tokens into a single token
//	             with label value and token type =
//	             TYPE
//
//	          else if tdata.subtype =
//	                  TYPED_ATTR_BEGIN:
//
//	               if subexpression end type label
//	                  is empty, print error message
//	               else make end TYPE token from
//	                    label and:
//	                 if there is no beginning
//	                    type, move end TYPE token
//	                    to before elements if any
//	                 else if end TYPE token matches
//	                    beginning type, delete
//	                    end TYPE token
//	                 else announce type mismatch
//	                      error indicating end type
//	                      ignored and delete end
//	                      type
//
//		  else finish any unfinished attribute
//		       at end of subexpression and move
//		       any attributes after elements to
//		       just before elements
//
//          if closing was found that did not match
//             top of closing stack, or logical line
//             end was found:
//                 print error message 
//                 if non-matching closing was found,
//                    adjust end of subexpression to
//                    just before that closing
//                 if subexpression is typed bracketed,
//                    and end of subexpression found
//                    above was before tdata.end_
//                    position
//
//          else remove closing bracket, setting end
//               of subexpression to end of closing
//               bracket
//
//          remove opening bracket
//
//          if key is opening bracket:
//
//             call opening bracket reformatter if
//                  any, and if none or if compaction
//                  requested by reformatter:
//             compact subexpression with
//                     new_selectors,
//                     .initiator =
//                         key opening bracket,
//                     .terminator =
//                         key closing bracket,
//                     token type = BRACKETING,
//                     token value_type =
//                         key opening bracket
//
//          else if key is typed opening:
//              
//               compact subexpression with attributes
//                       taken from tokens before
//                       tdata.elements (those with
//                       token types TYPE, ATTR_...) and
//                       elements taken from typed_
//                       data.element on;
//                       token type =
//                             PREFIX if
//                                .type attribute is
//                                      present,
//                                tdata.middle_count
//                                      == 0, and
//                                tdata.has_mark_type
//                                      is false,
//                             else BRACKETING if .type
//                             is the only attribute or
//                             there are no attributes,
//                             else BRACKETED
//                       token value_type = .type
//                             attribute value if token
//                             type is PREFIX, else
//                             MISSING
//
//    		  delete tokens from which attributes
//    		         were taken
//
//    		  if token type == PREFIX:
//
//    		      find token .type entry in
//    		           bracketed pass prefix table
//    		      group = group of entry found or
//    		              MISSING if no entry or
//    		              entry group is MISSING
//    		      search bracket stack for entry
//                           with prefix_type == token
//                           .type or non-MISSING
//                           prefix_group == group;
//                           stop search at first
//                           entry with prefix_type
//                           MISSING
//                    if entry found:
//          		  close bracket stack entry
//          		        and specify PREFIX
//          		        token as closing
//          		        token
//                        close all higher stack entries
//                              indicating that prefixes
//                              with their type/group
//                              were not found
//                        return separator_found
//
//                    if not at_start:
//                        announce PREFIX token is in
//                            error and delete it
//
//                    else if bracket stack not closed
//                         by PREFIX token's typed
//                         opening closing bracket:
//                       set token type to BRACKETED
//                       return separator_found
//
//                    else:
//                        // Start new subexpression
//                        // beginning with the PREFIX
//                        // token
//
//                        pop bracket stack and push
//                            new entry with prefix_type
//                            = PREFIX .type and prefix_
//                            group = group
//                        prefix_selectors = selectors
//                        if PREFIX token .type entry
//                           found above in the
//    		             bracketed pass prefix table
//			     adjust prefix_selectors
//			     according to new_selectors
//			     in the entry setting
//			     ALWAYS_SELECTOR on
//			  loop:
//                            parse_bracketed_subexpr
//                              with prefix_selectors,
//                              bracket stack,
//                              indent argument,
//                              line_sep argument
//                                if prefix_selectors
//                                   & EALSEP,
//	                        set separator_found =
//	                          result
//
//	                      compact_prefix_separator
//	                        with prefix_separators
//
//	                      if bracket stack not
//	                         closed by another
//	                         PREFIX token with same
//	                         .type or group as the
//	                         current PREFIX token:
//	                           return
//	                             separator_found
//
//	                      make PREFIX token that
//	                           closed bracket stack
//	                           the current PREFIX
//	                           token
//
//	                      if .type of current PREFIX
//	                         token == .type of
//	                         previous current PREFIX
//	                         token, iterate loop
//
//	                      find entry for new .type
//	                        in bracketed pass prefix
//	                        table (entry must exist
//	                        because .types have the
//	                        same group), recompute
//	                        prefix_selectors from
//	                        the new entry
//
//			      iterate loop
//
//	    at_start = false
//
//          if closing bracket was found that did
//                     not match top of closing stack,
//                     or logical line end found:
//               return separator_found
//          else
//            iterate top level loop
//
//       if key is closing bracket in bracket stack
//          that matches the closing bracket of an
//          entry in the bracket stack:
//
//          close bracket stack entry that matches key
//          close all higher stack entries indicating
//            that their closing brackets were not found
//            and their subexpressions terminated just
//            before the first token of key
//          return MISSING_POSITION
//
//       if key is selected indentation mark and
//              current is end of file or line break
//              or comment:
//          indentation_found = key
//          iterate top level loop
//          // See above for indented paragraph
//          // processing.
//
//       if key is line separator matching line_sep
//              argument and selectors & EALSEP:
//          remove line separator
//          return end position of removed separator
//
//       if key is typed middle or typed double middle
//              matching typed_middle or typed double
//              middle component of typed_opening compo-
//              nent of a non-NULL typed_data argument
//              and typed_data->has_mark_type is false:
//
//          remove typed middle or double middle key
//
//          if typed_data->middle_count is even:
//             if there is no previous typed key after
//                the typed opening in the subexpression
//                and there are tokens between the typed
//                opening and the typed middle, make
//                these tokens into a label and replace
//                them with a TYPE token having the
//                label as token value; if TYPE token is
//                after elements, move it to before
//                elements
//	       else if there is some key in the subex-
//	            pression after the typed opening,
//	            finish any unfinished attribute just
//	            before the typed middle and move any
//	            attributes after elements to just
//	            before elements
//
//          else if typed_data->middle_count is odd:
//             if typed_data->elements == NULL and
//                there are elements before typed
//                middle, set typed_data->elements to
//                point at the first of these
//
//	    typed_data->subtype = TYPED_MIDDLE
//
//          ++ typed_data->middle_count
//
//          if key was typed double middle
//              ++ typed_data->middle_count
//              iterate top level loop
//
//	    if typed_data->middle_count is NOW even:
//	        selectors argument =
//	           typed_data->saved_selectors
//	    else if typed_data->middle_count is NOW odd:
//              selectors argument non-options =
//                   typed_data->typed_opening
//                             ->attr_selectors
//                 | ALWAYS_SELECTOR
//
//          iterate top level loop
//
//       if key is typed attribute begin matching typed_
//              attr_begin component of typed_opening
//              component of a non-missing typed_data
//              argument, and typed_data->middle_count
//              is even, and typed_data->has_mark_type
//              is false:
//
//          if there is no previous typed key after the
//             typed opening in the subexpression and
//             there are tokens between the typed
//             opening and the typed attribute begin,
//             make these tokens into a label and
//             replace them with a TYPE token having
//             the label as token value; then remove the
//             typed attribute begin key and set typed_
//             data->subtype = TYPED_ATTR_SEP; then
//             iterate top level loop
//
//	     else if typed_data->middle_count > 0 and
//	          there are tokens between the previous
//	          typed middle and the typed attribute
//	          begin, remove the typed attribute
//	          begin key, finish any unfinished
//	          attribute just before the typed attri-
//	          bute begin, and move any attributes
//	          after elements to just before ele-
//	          ments; then iterate to top level loop
//
//	     else announce typed attribute begin to be a
//	          a punctuation error that is ignored,
//	          and remove it
//
//       if key is typed attribute equal matching typed_
//              attr_equal component of typed_opening
//              component of a non-missing typed_data
//              argument, and typed_data->middle_count
//              is even, and typed_data->has_mark_type
//              is false:
//
//          if there is a previous typed key in the sub-
//             expression that is a typed middle, typed
//             attribute separator, or typed attribute
//             negator, and there are tokens between
//             this previous typed key and the typed
//             attribute equal, make these tokens into
//             an attribute label and optional following
//             flags, and replace them with an ATTR_
//             LABEL token optionally followed by an
//             ATTR_FLAGS token; then remove the typed
//             attribute equal key and iterate to top
//             level loop
//
//           else if there is no previous typed key in
//                the subexpression after the typed
//                opening, and there are tokens between
//                the typed opening and the typed attri-
//                bute equal, do ditto, but also issue a
//                warning that the type is missing
//
//	     else announce typed attribute equal to be a
//	          a punctuation error that is ignored,
//	          and remove it
//
//       if key is typed attribute separator matching
//              typed_attr_sep component of typed_
//              opening component of a non-missing
//              typed_data argument, and typed_data->
//              middle_count is even, and typed_data->
//              has_mark_type is false:
//
//          if there is a previous typed key in the sub-
//             expression that is a typed middle, typed
//             attribute separator, or typed attribute
//             equal, or typed attribute negator, finish
//	       any unfinished attribute just before the
//	       typed attribute separator, remove the
//	       typed attribute separator key, and
//	       iterate to top level loop
//
//           else if there is no previous typed key in
//                the subexpression after the typed
//                opening, and there are tokens between
//                the typed opening and the typed attri-
//                bute separator, do ditto, but also
//                issue a warning that the type is
//                missing
//
//	     else announce typed attribute separator to
//	          be a a punctuation error that is
//	          ignored, and remove it
//
//       if key is typed attribute negator matching
//              typed_attr_negator component of typed_
//              opening component of a non-missing
//              typed_data argument, and typed_data->
//              middle_count is even, and typed_data->
//              has_mark_type is false:
//
//          if there is a previous typed key in the sub-
//             expression that is a typed middle or
//             typed attribute separator, and there are
//             NO tokens between this previous key and
//             the typed attribute negator, remove the
//             typed attribute negator, set typed_data->
//             subtype = TYPED_ATTR_NEGATOR, and iterate
//             to top level loop
//
//           else if there is no previous typed key in
//                the subexpression after the typed
//                opening, and there are NO tokens
//                between the typed opening and the
//                typed attribute negator, do ditto,
//                but also issue a warning that the type
//                is missing
//
//	     else do nothing (key will be rejected)
//
//       // reject key
//       //
//       iterate loop to refine key by checking if there
//               is a shorter key or accepting token
//               as a non-key if no key found
