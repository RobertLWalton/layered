// Layered Languages Bracketed Subexpression Parse
// Function Outline
//
// File:	ll_parser_bracketed_parse.outline
// Author:	Bob Walton (walton@acm.org)
// Date:	Sat Apr  1 11:09:06 EDT 2017
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.
//
//	vi:filetype=cpp
//
// Outline of parse_bracketed_subexpression executable
// code.
//
// This detailed code outline makes it easier to explain
// a complex function and verify its correctness.
//
// The outline omits tracing code, code to read more
// input, code to update typed_data->end_position, and
// code to set .position attributes.
//
// make_label(first,next):
//     Collect all the tokens from first through next->
//     previous into a single label token.  Print
//     error messages for tokens that cannot be part
//     of a label, and warning messages for separators
//     and marks that are not quoted.  If there are
//     no tokens, create a new token `first' and
//     give it the empty label.  If all tokens have
//     error messages, the label will be empty.
//
// make_type_label(typed_data,next):
//     Make a label as per make_label from the tokens
//     start = typed_data->start_previous->next through
//     next->previous.  If there are no such, just
//     output a `missing type' error message and return.
//
//     Otherwise, if typed_data->type is MISSING (there
//     was no previous TYPE token), set the new label
//     token type to TYPE, set typed_data->type to the
//     tokens value (the label), increment typed_data->
//     attr_count, and move the token if necessary so it
//     is before typed_data->elements.
//
//     If on the other hand typed_data->type is not
//     MISSING, check that it equals the new label,
//     print an error message if not, and in any case
//     delete the new label token.
//
// make_attribute_label(typed_data,next):
//     Make a label as per make_label from the tokens
//     start = typed_data->start_previous->next through
//     next->previous.  If there are no such, just
//     output an error message and return.  If there
//     are 2 or more tokens and the last is a bracketed
//     subexpression with typed_data->typed_opening->
//     typed_attr_flags_initiator as its .initiator,
//     do NOT make it part of the label, but instead
//     give it the ATTR_FLAGS token type.  After making
//     the label token give it the ATTR_LABEL token
//     type, increment typed_data->attr_count, and set
//     typed_data->attributes to point at the token if
//     typed_data->attributes is NULL.
//
//     Note that attributes with empty labels will
//     cause an error message and be otherwise ignored
//     in code below.
//
// finish_attribute(typed_data,next):
//     Let start = typed_data->start_previous->next.
//
//     Examine typed_data->subtype (the subtype of the
//     last key found).  If it is TYPED_OPENING, TYPED_
//     ATTR_SEP, TYPED_ATTR_NEGATOR, or TYPED_MIDDLE,
//     make_attribute_label(typed_data,next) and give
//     the resulting token the type ATTR_FALSE if the
//     subtype above was TYPED_ATTR_NEGATOR and ATTR_
//     TRUE otherwise.  However, as an exception, do
//     not do anything if the subtype examined was
//     TYPED_MIDDLE and there are no tokens between
//     the TYPED_MIDDLE token and `next' (i.e., start
//     == next).
//
//     Note that attributes with empty labels will
//     cause an error message and be otherwise ignored
//     in code below.
//
//     If instead the subtype is TYPED_ATTR_EQUAL:
//         if start == next (there are no tokens to
//                           make into a value):
//             output error message that attribute
//                    value is missing and attribute
//                    is ignored
//             create a new token before next of
//                    token type ATTR_VALUE and
//                    value NONE (this will cause
//                    attribute to be ignored in code
//                    below)
//         else if start->next == next (there is just a
//                 single token in the value)
//                 and token->string == NULL_STUB
//                 (the token is not a quoted string
//                  or numeric):
//            if the single token has .initiator ==
//                   typed_data->typed_opening
//                   ->typed_attr_multivalue_initiator:
//               token->type = ATTR_MULTIVALUE
//            else:
//               token->type = ATTR_VALUE
//               if is_attr_legal ( token value ) is
//                                false:
//                  output error message saying value
//                         is not legal and attribute
//                         is ignored
//                  token->value = NONE (this will cause
//                      attribute to be ignored in code
//                      below)
//         else:
//             make_label ( start, next )
//             start->type = ATTR_VALUE
//
// move_attributes(typed_data,next):
//     If there are attributes after the last typed
//     middle (typed_data->attributes != NULL_STUB and
//     typed_data->middle_count != 0) and there are
//     elements (typed_data->elements != NULL_STUB),
//     move the attributes to just before the elements.
//     The attributes to be moved are all the tokens
//     from typed_data->attributes through next->
//     previous.

// parse_bracketed_subexpression(...)
//
// Arguments:
//
// 	parser
// 	    Current parser.
// 	selectors
// 	    Current parser selectors.
// 	current
// 	    Next token to parse.  Updated as parse
// 	    proceeds.
// 	indent
// 	    Current paragraph indent.
// 	typed_data
// 	    After reading a typed opening, the parse
// 	    bracketed subexpression function allocates a
// 	    typed_data structure to the stack, initial-
// 	    izes it, and calls itself recursively with
// 	    the typed_data structure as an argument.
// 	    Other calls to the parse bracketed subex-
// 	    pression function have a NULL typed_data
// 	    argument.
// 	line_variables
// 	    This points at the line variables being used
// 	    to parse the current logical line.  These
// 	    variables are updated as the parse proceeds,
// 	    and the updated variables are used to parse
// 	    the next logical line.
// 	bracket_stack_p
// 	    Top bracket stack entry.  NULL if empty
// 	    stack.
//
// Return Value:
//
// 	position
// 	    The end position of any line separator that
// 	    ended the parsed subexpression, or
// 	    PARAGRAPH_END if the end of the last logical
// 	    line in a paragraph ended the parsed subex-
// 	    pression, or MISSING_POSITION otherwise.
//
// IMPORTANT: This code assumes EVERY comment is
// immediately followed by a line break or end of file.
// This must be guaranteed by the lexical analyzer.
//
// bracketed_pass = parser->pass_stack
//     // Bracketed pass; always the first pass in the
//     // pass stack.
// indentation_mark indentation_found = NULL_STUB
//     // If not NULL_STUB, current token is an end-of-
//     // line and current->previous token is the last
//     // token of an indentation mark.
// start_previous = current->previous
//     // If current == start_previous->next, current
//     // is at the beginning of the subexpression
//     // begin parsed.  Tokens may be removed from or
//     // added to the beginning of the subexpression,
//     // so one cannot simply save the initial current
//     // value.  There always is a current->previous,
//     // as the start-of-file token is never removed
//     // from the input.
// parsing_logical_line =
//         line_variables->previous == start_previous
//     // True iff the parse_bracketed_subexpression()
//     // was called to parse a logical line, and not
//     // a subexpression of a logical line.
//
// loop to find next token:
//
//     // Note: we come here only on the first time
//     // through the loop, and on subsequent times
//     // we go to NEXT_TOKEN or PREFIX_FOUND.
//
//     // Variables used by PREFIX_FOUND and PREFIX_
//     // PARSE code blocks:
//
//	   prefix
//	       The prefix token at the head of the
//	       prefix-n-list that is to be created.  The
//	       prefix-n-list's elements have not yet
//	       been parsed.
//
//     // Variables used by PREFIX_FOUND code block:
//
//	   separator_found
//	       Result of parse_bracketed_subexpression
//	       that parsed the prefix token, or MISSING_
//	       POSITION if prefix token was copied from
//	       an implied subprefix or implied header.
//
//	   premature_closing
//	       True iff parse_bracketed_subexpression
//	       parsed the prefix token and the prefix
//	       separator encoded in that token was
//	       terminated abnormally by an outer closing
//	       bracket or logical line end.
//
//     NOTE: If prefix was not terminated abnormally,
//           premature_closing is false and separator_
//           found is MISSING_POSITION.
//
//     // Variables used by PREFIX_PARSE code block:
//
//	   prefix_type
//	       Type of prefix.
//
//	   prefix_entry
//	       Prefix table entry for type of prefix,
//	       or NULL_STUB if none.
//
//	   prefix_group
//	       prefix_entry->group, or MISSING if
//	       prefix_entry is NULL_STUB.
//
//	   prefix_selectors
//	       Selectors used in parsing the prefix-n-
//	       list headed by the prefix.
//
//
//     if parsing_logical_line:
//
//         if line_variables->current.implied_header
//                            is MISSING:
//              go to NEXT_TOKEN
//
//         // Insert implied prefix created by line_
//         // variables.
//
//         prefix_entry =
//             line_variables->current.header_entry;
//             // Required to be != NULL_STUB.
//         prefix_selectors =
//             line_variables->current.header_selectors;
//         prefix_group =
//             prefix_entry->group
//         create new token of type IMPLIED_PREFIX,
//             value_type prefix_entry->label, value
//             line_variables->current.implied_header,
//             and insert it before current token.
//         prefix = new token
//         if prefix_group == paragraph:
//             copy line_variables->implied_paragraph
//             to line_variables->current
//         go to PREFIX_PARSE
//
//     else if bracket stack does not have a top entry
//             that has a prefix_entry with an implied_
//             subprefix:
//         go to NEXT_TOKEN
//
//     else:
//
//         // Insert implied prefix NOT created by line_
//         // variables.
//
//	   implied_subprefix =
//	       top bracket stack entry
//	         ->prefix_entry->implied_subprefix
//	   implied_subprefix_type =
//	       top bracket stack entry
//	         ->prefix_entry->implied_subprefix_type
//         create new token of type IMPLIED_PREFIX,
//             value_type implied_subprefix_type, value
//             implied_subprefix, and insert it before
//             current token.
//         prefix = new token
//
//         separator_found = MISSING_SEPARATOR
//         premature_closing = false
//
// PREFIX_FOUND:
//
//     // Input variables (see above for definitions):
//     //
//     //	prefix
//     //	separator_found
//     // 	premature_closing
//
//     prefix_type = .type of prefix
//     prefix_entry = prefix token .type entry in
//          bracketed_pass prefix_table, or NULL_STUB
//          if none
//     prefix_group = prefix_entry->group or MISSING if
//                    prefix_entry == NULL_STUB
//     if prefix_group is not `line' or `paragraph',
//             OR token before prefix is IMPLIED_PREFIX:
//         search bracket stack for bracket stack entry
//                with entry->prefix_type == prefix_type
//                OR entry->prefix_entry->group ==
//                == non-MISSING prefix_group
//            stop search just befor first entry with
//                 either MISSING prefix_type or
//                 entyr line_variables different from
//                 line_variables argument
//
//     if bracket stack entry found:
//
//         if prefix token type is IMPLIED_PREFIX:
//             announce error: implied prefix has same
//                 type or group as previous active
//                 prefix in same subexpression
//             delete prefix token
//             go to NEXT_TOKEN
//
//         close bracket stack entry and specify PREFIX
//               token as closing token
//         close all higher stack entries indicating
//               that prefixes with their type/group
//               were not found
//         return separator_found
//
//     if paragraph_group == `paragraph'
//             AND
//             prefix->type != IMPLIED_PREFIX
//             AND
//             line_variables->at_paragraph_beginning
//             &&
//             top bracket stack entry is for prefix
//                 with `line' group:
//         // Special case of explicit paragraph
//         // header after implied line header.
//         //
//         close top bracket stack entry and specify
//               PREFIX token as closing token
//         return separator_found
//             // Thus implied `line' prefix gets
//             // empty list and will be deleted.
//
//     if prefix_group == `paragraph':
//         if prefix->type == IMPLIED_PREFIX:
//             announce that prefix is `paragraph'
//                      prefix implied by previous
//                      prefix and is thus in error
//                      and is ignored
//             remove prefix token
//         else if prefix is not first token of
//                 logical line OR logical line is
//                 not in paragraph beginning position:
//             announce that prefix is explicit
//                      `paragraph' prefix not in
//                      paragraph beginning position
//                      and is ignored
//             remove prefix token
//
//     else if prefix_group == `line' AND prefix is
//             NOT at beginning of current logical
//             line AND top bracket stack entry is
//             NOT for a `paragraph' prefix:
//         announce that prefix is `line' prefix that
//                  is not at the beginning of a logical
//                  line or immediately after a
//                  `paragraph' prefix and is ignored
//         remove prefix token
//
//     else if prefix not at start subexpression being
//             parsed by parse_bracketed_subexpression:
//         announce that prefix is not at beginning of
//                  subexpression and does not continue
//                  subexpression started by another
//                  prefix of the prefix type or group,
//                  and is ignored
//         remove prefix token
//
//     if premature_closing:
//         set prefix token type to BRACKETED if PREFIX
//             token was not deleted
//         return separator_found
//     else if prefix token was deleted:
//         go to NEXT_TOKEN
//
//     prefix_selectors = selectors
//     if prefix_entry != NULL_STUB:
//         adjust prefix_selectors according to
//                prefix_entry->new_selectors
//                setting ALWAYS_SELECTOR on
//
// PREFIX_PARSE:
//
//     // Parse prefix-n-list headed by prefix token.
//
//     // Input variables (see above for definitions):
//     //
//     //	prefix
//     //	prefix_type
//     //	prefix_entry
//     //	prefix_group
//     // 	prefix_selectors
//
//     create new bracket stack entry E with
//            E.prefix_type = PREFIX token .type
//            and E.prefix_entry = prefix_entry
//     push new entry into existing bracket stack
//          to create new bracket stack
//
//     loop to find prefix-n-list subexpression
//	       headed by prefix:
//
//	   if prefix_group == `paragraph'
//	           AND prefix->type != IMPLIED_PREFIX:
//
//	       // Implied line header may have been
//	       // inserted and deleted before this
//	       // explicit paragraph header.  Selectors
//	       // and prefix_entry may be incorrect.
//	       //
//	       selectors = line_variables->paragraph
//	                                   .selectors
//	       new_prefix_entry = prefix table entry
//	           found by prefix_type and selectors
//	       if new_prefix_entry exists and has
//	               group != `paragraph':
//	           announce that prefix had `paragraph'
//	               group relative to incorrect
//	               selectors provided by implied
//	               header that has been deleted,
//	               but does not have `paragraph'
//	               group with corrected selectors;
//	               continuing with prefix definition
//	               located by incorrect selectors
//
//	       else if new_prefix_entry != prefix_entry:
//	       
//		    // Fix things up.
//
//		    prefix_entry = new_prefix_entry
//		    cstack top->prefix_entry =
//		        new_prefix_entry
//		    prefix_selectors = selectors
//		        modified by prefix_entry
//		        .new_selectors
//		    line_variables->current
//		        .lexical_master =
//		        prefix_entry->lexical_master
//		    line_variables->current.selectors =
//		        prefix_selectors
//		    line_variables->current
//		        .implied_header = MISSING
//
//		    implied_header = prefix_entry->
//		                     implied_subprefix
//		    if implied_header != MISSING:
//		        header_type =
//		            prefix_entry->
//		                implied_subprefix_type
//		        header_entry = prefix_table
//		            entry found by header_type
//		            and prefix_selectors
//		        if header_entry exists and has
//		                `line' group:
//		            header_selectors =
//		                prefix_selectors
//		                modified by
//		                header_entry->
//		                    new_selectors
//		            line_variables->current
//		                .implied_header =
//		                    implied_header
//		            line_variables->current
//		                .header_entry =
//		                    header_entry
//		            line_variables->current
//		                .header_selectors =
//		                    header_selectors
//
//		    if line_variables->current.selectors
//		            has STICKY_OPT flag set:
//		        line_variables->
//		            implied_paragraph =
//		                line_variables->current
//		        line_variables->paragraph
//		            .prefix_header =
//		                prefix->value
//		        line_variables->paragraph
//		            .header_entry =
//		                prefix_entry
//		        line_variables->paragraph
//		            .header_selectors =
//		                prefix_selectors
//
//		        // The following causes compact
//		        // below to copy prefix->value
//		        // and is otherwise harmless.
//		        //
//		        REQUIRE start_previous->next ==
//		            prefix
//		        prefix->type = IMPLIED_PREFIX
//
//		    else:
//		        line_variables->paragraph =
//		            line_variables->
//		                indentation_paragraph
//		        line_variables->
//		            implied_paragraph =
//		                line_variables->
//		                    indentation_impled_
//		                              paragraph
//
//         top of bracket stack->closing_first =
//         top of bracket stack->closing_last =
//             NULL_STUB
//         parse_bracketed_subexpression with
//             prefix_selectors, with new bracket stack,
//             indent argument, line_variables argument;
//	       set separator_found = result
//
//	   next (token after subexpression) =
//	        top of stack closing first if not
//	        NULL_STUB or current token otherwise
//
//         if prefix_group == `paragraph' AND one of
//                  options EALBREAK, EALEINDENT,
//                  EALTINDENT, or EALSEP is on in
//                  prefix_selectors AND it is NOT
//                  true that the prefix-n-list consists
//                  of a single element made from a
//                  headed line (i.e., a single element
//                  with value_type == `line' ):
//             compact_logical_line
//               starting at token after prefix and
//                        ending just before `next',
//               with prefix_separators,
//               separator_found,
//               line_variables->line_sep
//
//	   compact_prefix_separator
//	     starting at prefix token and ending with
//	              token just before `next'
//	     with prefix_selectors, separator_found if
//	     prefix_group == `paragraph',
//	     line_variables->line_sep
//
//	   if compact_prefix_separators produced a
//	           MIN object stored as the prefix
//	           token value:
//	       prefix->value_type = prefix_group if
//	         prefix_group == `paragraph' OR `line'
//	         else MISSING;
//
//	   if bracket stack not closed by another
//	              PREFIX token with same .type
//	              or group as the current
//	              PREFIX token:
//	       return separator_found
//
//	   prefix = PREFIX token that closed bracket
//	            stack
//
//	   if .type of prefix (in prefix->value_type)
//	               != .type of previous prefix
//	                  (in prefix_type):
//	       prefix_entry = prefix_table entry for
//	                      .type of prefix
//	           // Must exist as prefix must have
//	           // a group.
//	       if prefix_entry->group != prefix_group:
//	           // Special case where line IMPLIED_
//	           // PREFIX is immediately followed
//	           // by an explicit paragraph prefix
//	           //
//	           prefix_group = `paragraph'
//	           selectors = line_variables->paragraph
//	                                      .selectors
//
//             top of stack->prefix_type = prefix_type =
//                 prefix->value_type (.type of prefix)
//             top of stack->prefix_entry = prefix_entry
//             prefix_selectors = selectors modified by
//                 prefix_entry->new_selectors
//
//	   iterate loop to find prefix-n-list
//	           subexpression headed by prefix
//
// NEXT_TOKEN:
//
//     skip line break, comment, and indent_before_
//          comment tokens; if a blank line is
//          skipped or end of file encountered, set
//          parser->at_paragraph_beginning = true
//
//     if we skipped some tokens:
//
//         assert that current is indent or end of file
//
//         current_indent = indent of current token if
//             this is indent token or to 0 if current
//             token is end of file
//
//         delete what has been skipped, but print a
//             WARNING message if any comment deleted
//             had less indent than current_indent,
//             using indent_before_comment tokens to
//             determine comment indent
//
//     if indentation_found != NULL_STUB:
//
//         // Indentation was found below, but we
//         // deferred processing it until we could skip
//         // stuff as above to find indent token
//         // following paragraph indentation mark.
//
//         assert that current is indent or eof token
//             // This is first indent or eof following
//             // indentation mark.
//
//         new_selectors = selectors modified by
//                 indentation_found->new_selectors
//
//         allocate line_variables for use in parsing
//                  paragraph and set line_variables
//                  .last_paragraph = NULL_STUB
//
//         if paragraph has some lines (i.e., current is
//            an indent token whose indent is greater
//            than the indent argument):
//
//             paragraph_indent = current->indent
//
//	       initialize line_variables
//	                      .indentation_paragraph
//	                      and
//	                      .indentation_implied_
//	                          paragraph:
//	           lexical_master =
//	               indentation_found->lexical_master
//	           selectors = new_selectors
//	           implied_header = MISSING
//	           header_entry = NULL_STUB
//
//	       // Loop to set implied headers in line_
//	       // variables data.  Go at most 2 times
//	       // through the loop for paragraph and
//	       // line implied headers.
//	       //
//	       implied_header = indentation_found->
//	                        implied_header
//	       implied_header_type = indentation_found->
//	                             implied_header_type
//	       header_selectors = new_selectors
//
//	       first_time = true
//	       loop while implied_header != MISSING:
//
//	           header_entry = prefix table entry for
//	                          implied_header_type
//	           group = header_entry->group
//	                   OR MISSING if no header_entry
//	           modify header_selectors by
//	                  header_entry->new_selectors
//	                  if there is a header_entry
//
//	           if group == `paragraph'
//	                   AND first_time:
//	               set line_variables
//	                   .indentation_paragraph
//	                       .implied_header =
//	                           implied_header
//	                       .header_entry =
//	                           header_entry
//	                       .header_selectors =
//	                           header_selectors
//	               set line_variables.indentation_
//	                   implied_paragraph.lexical_
//	                   master to header_entry->
//	                   lexical_master if the latter
//	                   is not MISSING
//
//	               implied_header =
//	                   header_entry->
//	                       implied_subprefix
//	               implied_header_type =
//	                   header_entry->
//	                       implied_subprefix_type
//	               first_time =false
//	               iterate implied_header loop
//	                   
//	           else if group == `line':
//	               set line_variables
//	                   .indentation_implied_paragraph
//	                       .implied_header =
//	                           implied_header
//	                       .header_entry =
//	                           header_entry
//	                       .header_selectors =
//	                           header_selectors
//
//		       if first_time:
//	                   set line_variables
//	                       .indentation_paragraph
//	                           .implied_header =
//	                               implied_header
//	                           .header_entry =
//	                               header_entry
//	                           .header_selectors =
//	                               header_selectors
//	               break implied_header loop
//	           else if first_time:
//	               announce that indetation mark
//	                   implied header does not have
//	                   `paragraph' or `line' group;
//	                   ignored
//	               break implied_header loop
//	           else:
//	               // Implied subprefix of paragraph
//	               // header is OK.
//	               //
//	               break implied_header loop
//
//             line_variables.paragraph =
//                 line_variables.indentation_paragraph
//             line_variables.implied_paragraph =
//                 line_variables
//                     .indentation_implied_paragraph
//
//             line_variables.line_sep =
//                 indentation_found->line_sep
//             parser->at_paragraph_beginning = true
//             clear CONTINUING_OPT from
//                 line_variables.current.selectors
//
//             loop to parse paragraph lines:
//
//                 if parser->at_paragraph_beginning
//                         AND 
//                         line_variables.current
//                                       .selectors
//                         does not have the
//                         CONTINUING_OPT flag:
//                     line_variables.current =
//                         line_variables.paragraph
//
//                 if current token is indent token:
//                     remove current token and set
//                         current to following token
//
//                 line_variables.previous =
//                     current->previous
//                 line_variables.at_paragraph_beginning
//                     = parser->at_paragraph_beginning
//                 parse_bracketed_subexpression with
//                     line_variables.current.selectors,
//                     paragraph_indent,
//                     line_variables, bracket stack
//                     set separator_found = result
//
//                 require ! bracket stack top closed
//
//                 if line is not empty and contains
//                         more than one element or
//                         has a single element that
//                         is not a prefix-0-list with
//                         a paragraph or line header:
//                     compact logical line with
//                         line_variables.current
//                                       .selectors,
//                         separator_found,
//                         indentation_found->line_sep
//
//		   if compacted token is prefix-0-list
//		            with paragraph header:
//
//		       // Token is first logical line of
//		       // a headed paragraph.
//
//		       if line_variables.last_paragraph
//		               != NULL_STUB:
//
//		           // Compact headed paragraph
//		           // that precedes compacted
//		           // token.
//
//		           compact paragraph from
//		               line_variables.
//		                   last_paragraph
//		               to just before compacted
//		               token
//
//		       if parser->at_paragraph_beginning
//		               AND
//		               line_variables.current
//		                             .selectors
//		               does NOT have
//		               CONTINUING_OPT:
//
//		           // compacted token is 1-line
//		           // paragraph
//		           //
//		           line_variables.last_paragraph
//		               = NULL_STUB
//		       else:
//		           line_variables.last_paragraph
//		               = compacted token
//
//		   else
//		   if parser->at_paragraph_beginning
//		           AND
//		           line_variables.last_paragraph
//		               != NULL_STUB
//		           AND line_variables.current
//		                             .selectors
//		               does NOT have
//		               CONTINUING_OPT:
//
//		       // Compacted token is first
//		       // logical line after a headed
//		       // paragraph, but does not itself
//		       // begin a headed paragraph.
//
//		       compact paragraph from
//		           line_variables.last_paragraph
//		           to just before compacted
//		           token
//		       line_variables.last_paragraph
//		           = NULL_STUB
//
//
//                 // Look for more lines in indented
//                 // paragraph.
//
//                 if separator found:
//                     continue loop to parse next
//                              paragraph line
//
//                 else if current is end-of-file:
//                     end loop that parses paragraph
//                         lines
//
//	           require that current is indent token
//
//                 if current has indent less than
//                                paragraph_indent:
//                     end loop that parses paragraph
//                         lines
//
//                 iterate loop to parse next paragraph
//                         line
//
//         if line_variables.last_paragraph
//                 != NULL_STUB:
//
//             // Compact headed paragraph at end of
//             // indented paragraph.
//
//	       compact paragraph from
//		   line_variables.last_paragraph
//		   to just before current token
//
//         remove indentation mark (from just before
//                paragraph lines)
//
//         // Compact elements of indented paragraph
//         // into INDENTED_PARAGRAPH token value.
//
//         compact paragraph lines
//             with new_selectors,
//             .initiator = indentation_found->label,
//             .terminator = INDENTED_PARAGRAPH,
//             token type = BRACKETING,
//             token value_type =
//                       indentation_found->label
//
//	   indentation_found = NULL_STUB
// 	 
//  TBD
//
//     // Continuation after any indented paragraph,
//     // or if there was no indented paragraph.
//     // Current is NOT a line-break, comment, or
//     // indent-before-comment.
//
//     if current is end-of-file:
//
//         return PARAGRAPH_END
//		      if and selectors & EAPBREAK
//		  MISSING_POSITION
//		      otherwise
//
//     else if current is indent:
//
//         if not at beginning of subexpression
//                   and parser->at_head
//                   and selectors & EAPBREAK:
//	       return PARAGRAPH_END
//
//         else if current->indent is at or before
//                 indent argument,
//                 and selectors & EALEINDENT:
//             return MISSING_POSITION
//
//         else if current->indent is before indent
//                 argument, and selectors & EALTINDENT:
//             return MISSING_POSITION
//
//         // next token is part of continuation line
//         //
//         remove current (indent) token and set
//                current to following token
//
//     assert indentation_found == NULL_STUB
//     assert current token is NOT end of file, comment,
//           indent before comment, indent, or
//           line break
//
//     parser->at_head = false
//
//     if current is quoted string:
//
//	   concat = bracketed_pass->concatenator
//	   current = current->next
//
//	   if concat == DISABLED:
//	       iterate loop to find next token
//	   if current->previous at beginning of
//	                           subexpression:
//	       iterate loop to find next token
//
//	   if concat == ENABLED and we are NOT after a
//	                quoted string that is itself
//	                after a quoted string:
//	       iterate loop to find next token
//
//	   else if concat != ENABLED:
//	       check whether we are now just after a
//	             quoted string that is after a
//	             token equal to concat that is
//	             after a quoted string
//	       if no:
//	          iterate loop to find next token
//	       if yes: 
//	          remove token equal to concat
//
//	   merge previous 2 tokens (both quoted strings)
//         iterate loop to find next token
//    
//     lookup key in bracketed_pass bracket table
//
//     loop to refine key until it is selected or not
//             found:
//
//         // Note: In the following the type of the
//         // key is determined by checking object
//         // subtype min::packed_subtype_of ( key ).
//
//         if key not found:
//
//             if at beginning of subexpression
//                   and typed_data argument != NULL
//                   and current is mark:
//
//                 // Current is mark at beginning of
//                 // typed bracketed subexpression:
//                 // turn current into TYPE token.
//                 //
//                 selectors =
//                     typed_data->saved selectors
//                 typed_data->type = current->value
//                 typed_data->has_mark_type = true
//                 current->type = TYPE
//                 ++ typed_data->attr_count
//
//             // Move to next token.
//             //
//             current = current->next
//             iterate loop to find next token
//
//         if key is selected opening bracket or typed
//                opening:
//
//             compute new_selectors from existing
//                     selectors and key
//
//             create new bracket stack entry with
//                    opening bracket = key
//             push new entry into existing bracket
//                  stack to create new bracket stack
//
//	       allocate new typed data, tdata, to stack,
//		        for use only if key is typed
//		        opening
//
//	       is_mark_prefix = false
//
//	       if key is opening bracket:
//
//                 parse_bracketed_subexpression with
//                   new_selectors,
//                   new bracket stack
//                   indent argument,
//                   line_sep argument
//                       if new_selectors & EALSEP,
//	             set separator_found = result
//
//	       else if key is typed opening:
//
//                 initialize tdata typed_data
//                            structure:
//		       typed_opening = key
//		       saved_selectors = new_selectors
//		       middle_count = attr_count = 0
//		       start_previous =
//		           current->previous
//		       elements = attributes = NULL_STUB
//		       end_position = MISSING_POSITION
//		       subtype = TYPED_OPENING
//		       type = MISSING
//		       has_mark_type = false
//
//                 parse_bracketed_subexpression with
//                     selectors from key->attr_
//                         selectors plus ALWAYS_
//                         SELECTOR, and selector
//                         options from new_selectors
//                     new bracket stack,
//                     indent argument,
//                     line_sep argument
//                         if new_selectors & EALSEP,
//                     tdata contining typed opening
//	               set separator_found = result
//
//	           // We do typed bracketed subexpres-
//	           // sion finishing here that is logi-
//	           // cally done by TYPED_CLOSING, but
//	           // is instead done here because the
//	           // TYPED_CLOSING may be missing and
//	           // thus be inserted below to correct
//	           // its being missing.
//
//	           if tdata.has_mark_type:
//
//	               type_token = first token of
//	                            subexpression after
//	                            opening bracket
//
//	               if subexpression has only one
//	                       token (its mark type):
//	                  is_mark_prefix = true
//
//	               else if subexpression does not
//	                       end with a mark:
//	                   print error message that
//	                   says typed_token->value has
//	                   been inserted at end of
//	                   subexpression (but do not
//	                   actually insert anything)
//
//	               else if subexpression ends with
//	                       a mark:
//	                   if that mark differs from
//	                          tdata.type (== type_
//	                          token->value):
//	                       reset type_token->value
//	                             to a label whose
//	                             components are the
//	                             marks at the
//	                             beginning and end
//	                             of the subexpres-
//	                             sion
//
//	                   delete the subexpression
//	                          ending mark (which
//	                          cannot be the
//	                          type_token)
//
//	               if the subexpression now has
//	                      more than one token:
//	                   tdata.elements =
//	                       type_token->next
//
//	           else if tdata.has_mark_type is false
//	                   and tdata.middle_count is
//	                   odd:
//	               // Because middle_count is odd
//	               // the last recognized key is
//	               // a typed middle.
//
//	               print error message saying mis-
//	                     sing typed middle at end
//	                     of subexpression has been
//	                     inserted (but do not
//	                     actually insert anything)
//
//	               if there are subexpression ele-
//	                        ments after the last key
//	                        (the typed middle) and
//	                        there were no subexpres-
//	                        sion elements before
//	                        this typed middle
//	                        (tdata.elements is NULL_
//	                        STUB)
//	                   tdata.elements =
//	                       token after last key (the
//	                       typed middle)
//
//	           else if tdata.has_mark_type is false
//	                   and tdata.middle_count is
//	                   even:
//
//	               // Note TYPED_ATTR_BEGIN can
//	               // only happen here if typed
//	               // attribute beginning was AFTER
//	               // an attribute, as if it is
//	               // after a beginning type,
//		       // tdata.subtype is set to
//		       // TYPED_ATTR_SEP instead.
//
//	               if tdata.subtype ==
//	                       TYPED_OPENING or
//	                       TYPED_MIDDLE, and there
//	                       are subexpression tokens
//	                       after the TYPED_OPENING
//	                       or TYPED_MIDDLE
//	               OR if tdata.subtype =
//	                           TYPED_ATTR_BEGIN:
//
//			    make_type_label
//			        ( tdata,
//			          token after
//			                subexpression )
//
//		       else if tdata.subtype !=
//		                     TYPED_OPENING:
//		           finish_attribute
//			        ( tdata,
//			          token after
//			                subexpression )
//		           move_attributes
//			        ( tdata,
//			          token after
//			                subexpression )
//
//             if closing was found that did not match
//                        our closing bracket:
//                 if non-matching closing bracket was
//                                 found:
//                      adjust end of subexpression to
//                             just before that closing
//                 print error message indicating our
//                       closing bracket was inserted
//
//             else remove closing bracket
//
//             remove opening bracket
//
//             if key is opening bracket:
//
//                 call opening bracket reformatter if
//                              any, and if none or if
//                              compaction requested by
//                              reformatter:
//                     compact subexpression with
//                         new_selectors,
//                         .initiator =
//                             key opening bracket,
//                         .terminator =
//                             key closing bracket,
//                         token type = BRACKETING,
//                         token value_type =
//                             key opening bracket
//
//             else if key is typed opening:
//              
//                 // At this point the subexpression
//                 // consists of special attribute
//                 // tokens (with token types TYPE,
//                 // ATTR_{LABEL,VALUE,TRUE,FALSE,
//                 // FLAGS,MULTIVALUE}) followed by
//                 // subexpression elements (beginning
//                 // with typed_data.elements which is
//                 // NULL_STUB if there are no
//                 // elements).
//
//                 // By an attribute label token we
//                 // mean a token of type TYPE or
//                 // ATTR_{LABEL,TRUE,FALSE}.
//
//		   loop through special attribute tokens
//		                making a list of attri-
//		                butes to be handed to
//		                the compact function:
//
//		       for TYPE token:
//		           if token->value is empty str:
//		               do nothing
//		           else if token->value is empty
//		                   label:
//		               print missing type error
//		                     message
//		               skip to next attribute
//		                    label token
//		           else add to the attribute
//		                list a .type attribute
//		                with value token->value
//
//		       for ATTR_LABEL token:
//		           if token->value is empty
//		                     label:
//		               print missing type error
//		                     message
//		               skip to next attribute
//		                    label token
//		           else add to the attribute
//		                list an attribute with
//		                name = token->value and
//		                value yet unspecified
//
//		       for ATTR_TRUE token:
//		           if token->value is empty
//		                     label:
//		               print missing type error
//		                     message
//		               skip to next attribute
//		                    label token
//		           else add to the attribute
//		                list an attribute with
//		                name = token->value and
//		                value = min::TRUE
//
//		       for ATTR_FALSE token:
//		           ditto but with value =
//		                 min::FALSE
//
//		       for ATTR_VALUE token:
//		           if token->value is NONE:
//		                delete last item of
//		                   attribute list
//		               skip to next attribute
//		                    label token
//		           else install token->value
//		                as value of last attri-
//		                bute in attribute list
//
//		       for ATTR_MULTIVALUE token:
//		           install token->value
//		                as value of last attri-
//		                bute in attribute list
//
//		       for ATTR_FLAGS token:
//		           install token->value
//		                as flags of last attri-
//		                bute in attribute list
//
//                 compact subexpression with attributes
//                         taken attribute list formed
//                         above and elements taken from
//                         typed_data.elements to end
//                         of subexpression;
//                         token type =
//                               PREFIX if
//                                  .type attribute
//                                        value is
//                                        present,
//                                  tdata.middle_count
//                                        == 0, and
//                                  either tdata
//                                        .has_mark_type
//                                        is false or
//                                        or is_mark_
//                                           prefix
//                                  key has prefix_sep-
//                                      arators_allowed
//                                      true
//                               else BRACKETING if
//                                    .type is the only
//                                     attribute
//                                     or there are
//                                     no attributes
//                               else BRACKETED
//                         token value_type = .type
//                               attribute value if
//                               token type is PREFIX,
//                               else MISSING
//
//    		   delete special attribute tokens
//    		       // Delayed until after attribute
//    		       // list has been passed to
//    		       // compact function as attribute
//    		       // list members are not protected
//    		       // from GC.
//
//    		   if compacted token type == PREFIX:
//		       goto PREFIX_FOUND with
//		           prefix = the compacted token
//		           separator_found from parse
//		               of subexpression
//		           premature_closing = true
//		               iff bracket stack not
//		               closed by PREFIX token's
//		               typed opening's closing
//		               bracket
//
//             if closing bracket matching key's closing
//                        bracket NOT found:
//                 return separator_found
//             else:
//                 iterate loop to find next token
//
//         if key is closing bracket, and line_variables
//                is NULL or selectors & EAOCLOSING,
//                and closing bracket matches the
//                closing bracket of the first entry of
//                the bracket stack, or of any entry if
//                selectors & EAOCLOSING:
//             close bracket stack entry that matches
//                   key, indicating key closed entry
//             close all higher stack entries indicating
//                   that their closing brackets were
//                   not found and their subexpressions
//                   terminated just before the first
//                   token of key
//             return MISSING_POSITION
//
//         if key is selected indentation mark and
//                current is end of file or line break
//                or comment:
//             indentation_found = key
//             iterate loop to find next token
//             // See above for indented paragraph
//             // processing.
//
//         if key is line separator matching line_sep
//                argument and selectors & EALSEP:
//             remove line separator
//             return end position of removed separator
//
//         // Note: In the following the type of the
//         // previous key is determined by checking the
//         // value of typed_data->subtype.  If this is
//         // TYPED_OPENING no previous key in the
//         // subexpression has been (previously) found.
//
//         if key is typed middle matching typed_middle
//                component of typed_opening component
//                of a non-NULL typed_data argument,
//                or ditto for typed double middle,
//                and typed_data->has_mark_type
//                is false:
//
//             if typed_data->middle_count is even:
//
//                 if there is no previous typed key
//                          after the typed opening in
//                          the subexpression and there
//                          are tokens between the typed
//                          opening and the key
//                     make_type_label
//                         ( typed_data,
//			     first token of key )
//	           else if there is some other key in
//	                   the subexpression after the
//	                   typed opening:
//		       finish_attribute
//			   ( tdata,
//			     first token of key )
//		       move_attributes
//		           ( tdata,
//			     first token of key )
//
//              else if typed_data->middle_count is odd
//                      and typed_data->elements == NULL
//                      and there are elements between
//                          previous typed middle and
//                          current typed middle key:
//
//                  typed_data->elements = first token
//                      after previous typed middle
//
//             remove typed middle or double middle key
//	       typed_data->subtype = TYPED_MIDDLE
//	       typed_data->start_previous =
//	           current->previous
//             ++ typed_data->middle_count
//
//             if key was typed double middle:
//                 ++ typed_data->middle_count
//                 iterate loop to find next token
//
//	       if typed_data->middle_count is NOW even:
//	           selectors argument =
//	              typed_data->saved_selectors
//	       else if typed_data->middle_count is NOW
//	               odd:
//                 selectors argument non-options =
//                      typed_data->typed_opening
//                                ->attr_selectors
//                    | ALWAYS_SELECTOR
//
//             iterate loop to find next token
//
//         if key is typed attribute begin matching
//                typed_attr_begin component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is no previous typed key after
//                      the typed opening in the
//                      subexpression:
//                 make_type_label
//                     ( typed_data,
//			 first token of key )
//                 remove the typed attribute begin key
//                 typed_data->subtype = TYPED_ATTR_SEP
//	           typed_data->start_previous =
//	               current->previous
//
//	       else if typed_data->middle_count > 0 and
//	               there are tokens between the
//	               previous typed middle and the
//	               typed attribute begin key:
//		   finish_attribute
//		       ( typed_data,
//                       first token of key )
//		   move_attributes
//		       ( typed_data,
//                       first token of key )
//	           remove the typed attribute begin key
//                 typed_data->subtype =
//                     TYPED_ATTR_BEGIN
//	           typed_data->start_previous =
//	               current->previous
//
//	       else:
//	           announce typed attribute begin to be
//	               a punctuation error that is
//	               ignored
//	           remove it
//
//             iterate loop to find next token
//
//         if key is typed attribute equal matching
//                typed_attr_equal component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_
//                data->has_mark_type is false:
//
//             if there is no previous typed key in the
//                      subexpression, or the previous
//                      typed key is a typed middle,
//                      typed attribute separator,
//                      typed attribute negator, or
//                      typed attribute begin that is
//                      before any typed middle:
//                 make_attribute_label
//                     ( typed_data,
//                       first token of key )
//                 remove the typed attribute equal key
//                 typed_data->subtype =
//                     TYPED_ATTR_EQUAL
//	           typed_data->start_previous =
//	               current->previous
//
//	       else:
//	           announce typed attribute equal to be
//	           a punctuation error that is ignored,
//	           and remove it
//
//             iterate loop to find next token
//
//         if key is typed attribute separator matching
//                typed_attr_sep component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is no previous typed key in the
//                      subexpression, or the previous
//                      typed key is a typed middle,
//                      typed attribute separator, typed
//                      attribute equal, typed attribute
//                      negator, or typed attribute
//                      begin that is before any typed
//                      middle:
//		   finish_attribute
//		       ( typed_data,
//		         first token of key )
//                 remove the typed attribute separator
//                        key
//                 typed_data->subtype = TYPED_ATTR_SEP
//	           typed_data->start_previous =
//	               current->previous
//
//	       else announce typed attribute separator
//	            to be a a punctuation error that is
//	            ignored, and remove it
//
//             iterate loop to find next token
//
//         if key is typed attribute negator matching
//                typed_attr_negator component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is no previous typed key in the
//                      subexpression, or the previous
//                      typed key is a typed middle,
//                      typed attribute separator, or
//                      typed attribute begin that is
//                      before any typed middle
//                      and if
//                      the typed attribute negator
//                      immediately follows the subex-
//                      pression beginning or previous
//                      typed key:
//                 remove the typed attribute negator
//                 typed_data->subtype =
//                     TYPED_ATTR_NEGATOR
//	           typed_data->start_previous =
//	               current->previous
//
//                 iterate loop to find next token
//
//	       else do nothing (key will be rejected)
//
//         // reject key
//         //
//         iterate loop to refine key (by trying to
//                 find next shorter key) until it is
//                 selected or not found
//
//     iterate loop to find next token
