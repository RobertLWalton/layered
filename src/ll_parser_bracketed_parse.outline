// Layered Languages Bracketed Subexpression Parse
// Function Outline
//
// File:	ll_parser_bracketed_parse.outline
// Author:	Bob Walton (walton@acm.org)
// Date:	Sat Mar 25 15:03:32 EDT 2017
//
// The authors have placed this program in the public
// domain; they make no warranty and accept no liability
// for this program.
//
//	vi:filetype=cpp
//
// Outline of parse_bracketed_subexpression executable
// code.
//
// This detailed code outline makes it easier to explain
// a complex function and verify its correctness.
//
// The outline omits tracing code, code to read more
// input, code to update typed_data->end_position, and
// code to set .position attributes.
//
// make_label(first,next):
//     Collect all the tokens from first through next->
//     previous into a single label token.  Print
//     error messages for tokens that cannot be part
//     of a label, and warning messages for separators
//     and marks that are not quoted.  If there are
//     no tokens, create a new token `first' and
//     give it the empty label.  If all tokens have
//     error messages, the label will be empty.
//
// make_type_label(typed_data,next):
//     Make a label as per make_label from the tokens
//     start = typed_data->start_previous->next through
//     next->previous.  If there are no such, just
//     output a `missing type' error message and return.
//
//     Otherwise, if typed_data->type is MISSING (there
//     was no previous TYPE token), set the new label
//     token type to TYPE, set typed_data->type to the
//     tokens value (the label), increment typed_data->
//     attr_count, and move the token if necessary so it
//     is before typed_data->elements.
//
//     If on the other hand typed_data->type is not
//     MISSING, check that it equals the new label,
//     print an error message if not, and in any case
//     delete the new label token.
//
// make_attribute_label(typed_data,next):
//     Make a label as per make_label from the tokens
//     start = typed_data->start_previous->next through
//     next->previous.  If there are no such, just
//     output an error message and return.  If there
//     are 2 or more tokens and the last is a bracketed
//     subexpression with typed_data->typed_opening->
//     typed_attr_flags_initiator as its .initiator,
//     do NOT make it part of the label, but instead
//     give it the ATTR_FLAGS token type.  After making
//     the label token give it the ATTR_LABEL token
//     type and increment typed_data->attr_count.
//
//     Note that attributes with empty labels will
//     cause an error message and be otherwise ignored
//     in code below.
//
// finish_attribute(typed_data,next):
//     Let start = typed_data->start_previous->next.
//
//     Examine typed_data->subtype (the subtype of the
//     last key found).  If it is TYPED_OPENING, TYPED_
//     ATTR_SEP, TYPED_ATTR_NEGATOR, or TYPED_MIDDLE,
//     make_attribute_label(typed_data,next) and give
//     the resulting token the type ATTR_FALSE if the
//     subtype above was TYPED_ATTR_NEGATOR and ATTR_
//     TRUE otherwise.  However, as an exception, do
//     not do anything if the subtype examined was
//     TYPED_MIDDLE and there are no tokens between
//     the TYPED_MIDDLE token and `next' (i.e., start
//     == next).
//
//     Note that attributes with empty labels will
//     cause an error message and be otherwise ignored
//     in code below.
//
//     If instead the subtype is TYPED_ATTR_EQUAL:
//         if start == next (there are no tokens to
//                           make into a value):
//             output error message that attribute
//                    value is missing and attribute
//                    is ignored
//             create a new token before next of
//                    token type ATTR_VALUE and
//                    value NONE (this will cause
//                    attribute to be ignored in code
//                    below)
//         else if start->next == next (there is just a
//                 single token in the value)
//                 and token->string == NULL_STUB
//                 (the token is not a quoted string
//                  or numeric):
//            if the single token has .initiator ==
//                   typed_data->typed_opening
//                   ->typed_attr_multivalue_initiator:
//               token->type = ATTR_MULTIVALUE
//            else:
//               token->type = ATTR_VALUE
//               if is_attr_legal ( token value ) is
//                                false:
//                  output error message saying value
//                         is not legal and attribute
//                         is ignored
//                  token->value = NONE (this will cause
//                      attribute to be ignored in code
//                      below)
//         else:
//             make_label ( start, next )
//             start->type = ATTR_VALUE
//
// move_attributes(typed_data,next):
//     If there are attributes after the last typed
//     middle (typed_data->attributes != NULL_STUB and
//     typed_data->middle_count != 0) and there are
//     elements (typed_data->elements != NULL_STUB),
//     move the attributes to just before the elements.
//     The attributes to be moved are all the tokens
//     from typed_data->attributes through next->
//     previous.
//
// parse_bracketed_subexpression(...)
//
// Arguments:
//
// 	parser
// 	    Current parser.
// 	selectors
// 	    Current parser selectors.
// 	current
// 	    Next token to parse.  Updated as parse
// 	    proceeds.
// 	indent
// 	    Current paragraph indent.
// 	line_sep
// 	    Line separator if enabled to be found.
// 	    NULL_STUB if disabled.
// 	typed_data
// 	    After reading a typed opening, the parse
// 	    bracketed subexpression function allocates a
// 	    typed_data structure to the stack, initial-
// 	    izes it, and calls itself recursively with
// 	    the typed_data structure as an argument.
// 	    Other calls to the parse bracketed subex-
// 	    pression function have a NULL typed_data
// 	    argument.
// 	line_variables
// 	    To parse an indented paragraph, the parse
// 	    bracketed subexpression function allocates
// 	    a line_variables structure to the stack,
// 	    initializes it, and then makes a series of
// 	    recursive calls to itself each parsing one
// 	    logical line.  The recursive calls update
// 	    the line_variables structure.  This argument
// 	    is non-NULL if and only if the parse
// 	    bracketed subexpression function is being
// 	    asked to parse a logical line.
// 	bracket_stack_p
// 	    Top bracket stack entry.  NULL if empty
// 	    stack.
//
// Return Value:
//
// 	position
// 	    The end position of any line separator that
// 	    ended the parsed subexpression, or
// 	    PARAGRAPH_END if the end of the last logical
// 	    line in a paragraph ended the parsed subex-
// 	    pression, or MISSING_POSITION otherwise.
//
// IMPORTANT: This code assumes EVERY comment is
// immediately followed by a line break or end of file.
// This must be guaranteed by the lexical analyzer.
//
// bracketed_pass = parser->pass_stack
//     // Bracketed pass; always the first pass in the
//     // pass stack.
// indentation_mark indentation_found = NULL_STUB
// start_previous = current->previous
//     // If current == start_previous->next, current
//     // is at the beginning of the subexpression
//     // begin parsed.  Tokens may be removed from or
//     // added to the beginning of the subexpression,
//     // so one cannot simply save the initial current
//     // value.  There always is a current->previous,
//     // as the start-of-file token is never removed
//     // from the input.
//
// loop to find next token:
//
//     // Note: we come here only on the first time
//     // through the loop, and on subsequent times
//     // we go to NEXT_TOKEN or PREFIX_FOUND.
//
//     // Variables used by PREFIX_FOUND code block:
//
//	   prefix
//	       The prefix token at the head of the
//	       prefix-n-list that is to be created.  The
//	       prefix-n-list's elements have not yet
//	       been parsed.
//	   separator_found
//	       Result of parse_bracketed_subexpression
//	       that parsed the prefix token, or MISSING_
//	       POSITION if prefix token was copied from
//	       an implied subprefix or implied header.
//	   premature_closing
//	       True iff parse_bracketed_subexpression
//	       parsed the prefix token and the prefix
//	       separator encoded in that token was
//	       terminated abnormally by an outer closing
//	       bracket or logical line end.
//
//     NOTE: If prefix was not terminated abnormally,
//           premature_closing is false and separator_
//           found is MISSING_POSITION.
//
//     if top bracket stack entry does not exist or its
//            prefix_entry does not exist or that has
//            a MISSING implied_subprefix:
//         go to NEXT_TOKEN
//
//     Insert IMPLIED_PREFIX token before current token.
//            Value of new token is implied_prefix of
//            prefix_entry of top bracket stack entry.
//
//     prefix = new IMPLIED_PREFIX token
//     separator_found = MISSING_SEPARATOR
//     premature_closing = false
//
// PREFIX_FOUND:
//
//     // For input variables beginning of find-next-
//     // token loop above.
//
//     prefix_entry = prefix token .type entry in
//          bracketed_pass prefix_table, or NULL_STUB
//          if none
//     group = prefix_entry->group or MISSING if
//             prefix_entry == NULL_STUB
//     search bracket stack for bracket stack entry with
//            bracket stack entry prefix_type
//               == prefix token .type
//            or non-MISSING bracket stack entry
//               prefix_entry->group == group;
//            stop search at first entry with MISSING
//                 prefix_type
//
//     if bracket stack entry found:
//
//         if prefix token type is IMPLIED_PREFIX:
//             announce error: implied prefix has same
//                 type or group as previous prefix in
//                 same subexpression
//             delete prefix token
//             go to NEXT_TOKEN
//
//         close bracket stack entry and specify PREFIX
//               token as closing token
//         close all higher stack entries indicating
//               that prefixes with their type/group
//               were not found
//         return separator_found
//
//     if prefix not first token of subexpression:
//         announce PREFIX token is in error and is
//                  being ignored
//         delete prefix token
//
//     if premature_closing:
//         set PREFIX token type to BRACKETED if PREFIX
//             token was not deleted
//         return separator_found
//
//     if PREFIX token was not deleted:
//         // Start new subexpression beginning with
//         // the PREFIX token.
//
//         create new bracket stack entry E with
//                E.prefix_type = PREFIX token .type
//                and E.prefix_entry = prefix_entry
//         push new entry into existing bracket stack
//              to create new bracket stack
//
//         prefix_selectors = selectors
//         if prefix_entry != NULL_STUB:
//             adjust prefix_selectors according to
//                    prefix_entry->new_selectors
//                    setting ALWAYS_SELECTOR on
//
//	   loop to find prefix-n-list subexpression
//	           headed by prefix:
//
//             parse_bracketed_subexpression
//                 with prefix_selectors,
//                 new bracket stack,
//                 indent argument,
//                 line_sep argument if prefix_selectors
//                                      & EALSEP,
//	           set separator_found = result
//
//	       compact_prefix_separator
//	         with prefix_selectors
//
//	       if bracket stack not closed by another
//	                  PREFIX token with same .type
//	                  or group as the current
//	                  PREFIX token:
//	           return separator_found
//
//	       prefix = PREFIX token that closed bracket
//	                stack
//
//	       if .type of prefix != .type of previous
//	                              prefix:
//	           find entry E for new .type in
//	           bracketed_pass prefix_table (entry
//	           must exist because .types have the
//	           same group), recompute prefix_selec-
//	           tors from selectors argument and E,
//	           and set bracket stack top entry
//	           prefix_type = new .type and bracket
//	           stack top entry prefix_entry to E
//
//	       iterate loop to find prefix-n-list
//	               subexpression headed by prefix
//
// NEXT_TOKEN:
//
//     skip line break, comment, and indent_before_
//          comment tokens; if a blank line is
//          skipped, set parser->at_head = true
//
//     if we skipped some tokens:
//
//         assert that current is indent or end of file
//
//         current_indent = indent of current token if
//             this is indent token or to 0 if current
//             token is end of file
//
//         delete what has been skipped, but print a
//             WARNING message if any comment deleted
//             had less indent than current_indent,
//             using indent_before_comment tokens to
//             determine comment indent
//
//     if indentation_found != NULL_STUB:
//
//         // Indentation was found below, but we
//         // deferred processing it until we could skip
//         // stuff as above to discover paragraph
//         // indentation.
//
//         assert that current is indent or eof token
//             // This is first indent or eof following
//             // indentation mark.
//
//         compute new_selectors from current selectors
//                 and indentation_found->new_selectors
//
//         if paragraph has some lines (i.e., current is
//            an indent token whose indent is greater
//            than the indent argument):
//
//             paragraph_indent = current->indent
//             remove current (indent) token and set
//                    current to following token
//
//	       allocate and initialize line_variables:
//	           paragraph_master = 0
//	           line_master = 0
//	           paragraph_header = MISSING
//	           line_header = MISSING
//	           header_selectors = new_selectors
//	           line_selectors = new_selectors
//	           instructions = 0
//
//             loop to parse paragraph lines:
//
//                 // Move to end of paragraph line.
//                 //
//                 parse_bracketed_subexpression with
//                     new_selectors, paragraph_indent,
//                     indentation_found->line_sep
//                       if new_selectors & EALSEP,
//                     line_variables,
//                     bracket stack
//                     set separator_found = result
//
//                 if bracket stack top closed:
//                     require that there was no line
//                             ending separator and
//                             adjust end of line to
//                             just before closing
//                             tokens (bracket, indent,
//                             end of file, etc. )
//
//                 if line is not empty or line separa-
//                         tor ended line:
//                     compact line found
//                              with new_selectors,
//                             .initiator =
//                                 LOGICAL_LINE,
//                             .terminator =
//                                 line separator
//                                 if found, else <LF>,
//                             token type = BRACKETING,
//                             token value_type =
//                                 LOGICAL_LINE
//
//                 if separator found:
//                     continue loop to parse next
//                              paragraph line
//
//                 else if top of bracket stack closed,
//                         or current is end-of-file:
//                     end loop that parses paragraph
//                         lines
//
//	           require that current is indent token
//
//                 if current has indent less than
//                                paragraph_indent:
//                     end loop that parses paragraph
//                         lines
//
//	           remove current (indent) token and
//	                  set current to next token
//                 iterate loop to parse next paragraph
//                         line
//
//         // Compact paragraph lines into a paragraph.
//         //
//         if bracket stack top closed:
//              adjust end of paragraph to just before
//              closing tokens
//
//         remove indentation mark (from just before
//                paragraph lines)
//
//         compact paragraph lines
//             with new_selectors,
//             .initiator = indentation_found->label,
//             .terminator = INDENTED_PARAGRAPH,
//             token type = BRACKETING,
//             token value_type =
//                       indentation_found->label
//
//	   if bracket stack top closed:
//	       return MISSING_POSITION
//	   indentation_found = NULL_STUB
// 	 
//     // Continuation after any indented paragraph,
//     // or if there was no indented paragraph.
//     // Current is NOT a line-break, comment, or
//     // indent-before-comment.
//
//     if current is end-of-file:
//
//         return PARAGRAPH_END
//		      if and selectors & EAPBREAK
//		  MISSING_POSITION
//		      otherwise
//
//     else if current is indent:
//
//         if not at beginning of subexpression
//                   and parser->at_head
//                   and selectors & EAPBREAK:
//	       return PARAGRAPH_END
//
//         else if current->indent is at or before
//                 indent argument,
//                 and selectors & EALEINDENT:
//             return MISSING_POSITION
//
//         else if current->indent is before indent
//                 argument, and selectors & EALTINDENT:
//             return MISSING_POSITION
//
//         // next token is part of continuation line
//         //
//         remove current (indent) token and set
//                current to following token
//
//     assert indentation_found == NULL_STUB
//     assert current token is NOT end of file, comment,
//           indent before comment, indent, or
//           line break
//
//     parser->at_head = false
//
//     if current is quoted string:
//
//	   concat = bracketed_pass->concatenator
//	   current = current->next
//
//	   if concat == DISABLED:
//	       iterate loop to find next token
//	   if current->previous at beginning of
//	                           subexpression:
//	       iterate loop to find next token
//
//	   if concat == ENABLED and we are NOT after a
//	                quoted string that is itself
//	                after a quoted string:
//	       iterate loop to find next token
//
//	   else if concat != ENABLED:
//	       check whether we are now just after a
//	             quoted string that is after a
//	             token equal to concat that is
//	             after a quoted string
//	       if no:
//	          iterate loop to find next token
//	       if yes: 
//	          remove token equal to concat
//
//	   merge previous 2 tokens (both quoted strings)
//         iterate loop to find next token
//    
//     lookup key in bracketed_pass bracket table
//
//     loop to refine key until it is selected or not
//             found:
//
//         // Note: In the following the type of the
//         // key is determined by checking object
//         // subtype min::packed_subtype_of ( key ).
//
//         if key not found:
//
//             if at beginning of subexpression
//                   and typed_data argument != NULL
//                   and current is mark:
//
//                 // Current is mark at beginning of
//                 // typed bracketed subexpression:
//                 // turn current into TYPE token.
//                 //
//                 selectors =
//                     typed_data->saved selectors
//                 typed_data->type = current->value
//                 typed_data->has_mark_type = true
//                 current->type = TYPE
//                 ++ typed_data->attr_count
//
//             // Move to next token.
//             //
//             current = current->next
//             iterate loop to find next token
//
//         if key is selected opening bracket or typed
//                opening:
//
//             compute new_selectors from existing
//                     selectors and key
//
//             create new bracket stack entry with
//                    opening bracket = key
//             push new entry into existing bracket
//                  stack to create new bracket stack
//
//	       allocate new typed data, tdata, to stack,
//		        for use only if key is typed
//		        opening
//
//	       is_mark_prefix = false
//
//	       if key is opening bracket:
//
//                 parse_bracketed_subexpression with
//                   new_selectors,
//                   new bracket stack
//                   indent argument,
//                   line_sep argument
//                       if new_selectors & EALSEP,
//	             set separator_found = result
//
//	       else if key is typed opening:
//
//                 initialize tdata typed_data
//                            structure:
//		       typed_opening = key
//		       saved_selectors = new_selectors
//		       middle_count = attr_count = 0
//		       start_previous =
//		           current->previous
//		       elements = attributes = NULL_STUB
//		       end_position = MISSING_POSITION
//		       subtype = TYPED_OPENING
//		       type = MISSING
//		       has_mark_type = false
//
//                 parse_bracketed_subexpression with
//                     selectors from key->attr_
//                         selectors plus ALWAYS_
//                         SELECTOR, and selector
//                         options from new_selectors
//                     new bracket stack,
//                     indent argument,
//                     line_sep argument
//                         if new_selectors & EALSEP,
//                     tdata contining typed opening
//	               set separator_found = result
//
//	           // We do typed bracketed subexpres-
//	           // sion finishing here that is logi-
//	           // cally done by TYPED_CLOSING, but
//	           // is instead done here because the
//	           // TYPED_CLOSING may be missing and
//	           // thus be inserted below to correct
//	           // its being missing.
//
//	           if tdata.has_mark_type:
//
//	               type_token = first token of
//	                            subexpression after
//	                            opening bracket
//
//	               if subexpression has only one
//	                       token (its mark type):
//	                  is_mark_prefix = true
//
//	               else if subexpression does not
//	                       end with a mark:
//	                   print error message that
//	                   says typed_token->value has
//	                   been inserted at end of
//	                   subexpression (but do not
//	                   actually insert anything)
//
//	               else if subexpression ends with
//	                       a mark:
//	                   if that mark differs from
//	                          tdata.type (== type_
//	                          token->value):
//	                       reset type_token->value
//	                             to a label whose
//	                             components are the
//	                             marks at the
//	                             beginning and end
//	                             of the subexpres-
//	                             sion
//
//	                   delete the subexpression
//	                          ending mark (which
//	                          cannot be the
//	                          type_token)
//
//	               if the subexpression now has
//	                      more than one token:
//	                   tdata.elements =
//	                       type_token->next
//
//	           else if tdata.has_mark_type is false
//	                   and tdata.middle_count is
//	                   odd:
//	               // Because middle_count is odd
//	               // the last recognized key is
//	               // a typed middle.
//
//	               print error message saying mis-
//	                     sing typed middle at end
//	                     of subexpression has been
//	                     inserted (but do not
//	                     actually insert anything)
//
//	               if there are subexpression ele-
//	                        ments after the last key
//	                        (the typed middle) and
//	                        there were no subexpres-
//	                        sion elements before
//	                        this typed middle
//	                        (tdata.elements is NULL_
//	                        STUB)
//	                   tdata.elements =
//	                       token after last key (the
//	                       typed middle)
//
//	           else if tdata.has_mark_type is false
//	                   and tdata.middle_count is
//	                   even:
//
//	               // Note TYPED_ATTR_BEGIN can
//	               // only happen here if typed
//	               // attribute beginning was AFTER
//	               // an attribute, as if it is
//	               // after a beginning type,
//		       // tdata.subtype is set to
//		       // TYPED_ATTR_SEP instead.
//
//	               if tdata.subtype ==
//	                       TYPED_OPENING or
//	                       TYPED_MIDDLE, and there
//	                       are subexpression tokens
//	                       after the TYPED_OPENING
//	                       or TYPED_MIDDLE
//	               OR if tdata.subtype =
//	                           TYPED_ATTR_BEGIN:
//
//			    make_type_label
//			        ( tdata,
//			          token after
//			                subexpression )
//
//		       else if tdata.subtype !=
//		                     TYPED_OPENING:
//		           finish_attribute
//			        ( tdata,
//			          token after
//			                subexpression )
//		           move_attributes
//			        ( tdata,
//			          token after
//			                subexpression )
//
//             if closing was found that did not match
//                        our closing bracket:
//                 if non-matching closing bracket was
//                                 found:
//                      adjust end of subexpression to
//                             just before that closing
//                 print error message indicating our
//                       closing bracket was inserted
//
//             else remove closing bracket
//
//             remove opening bracket
//
//             if key is opening bracket:
//
//                 call opening bracket reformatter if
//                              any, and if none or if
//                              compaction requested by
//                              reformatter:
//                     compact subexpression with
//                         new_selectors,
//                         .initiator =
//                             key opening bracket,
//                         .terminator =
//                             key closing bracket,
//                         token type = BRACKETING,
//                         token value_type =
//                             key opening bracket
//
//             else if key is typed opening:
//              
//                 // At this point the subexpression
//                 // consists of special attribute
//                 // tokens (with token types TYPE,
//                 // ATTR_{LABEL,VALUE,TRUE,FALSE,
//                 // FLAGS,MULTIVALUE}) followed by
//                 // subexpression elements (beginning
//                 // with typed_data.elements which is
//                 // NULL_STUB if there are no
//                 // elements).
//
//                 // By an attribute label token we
//                 // mean a token of type TYPE or
//                 // ATTR_{LABEL,TRUE,FALSE}.
//
//		   loop through special attribute tokens
//		                making a list of attri-
//		                butes to be handed to
//		                the compact function:
//
//		       for TYPE token:
//		           if token->value is empty str:
//		               do nothing
//		           else if token->value is empty
//		                   label:
//		               print missing type error
//		                     message
//		               skip to next attribute
//		                    label token
//		           else add to the attribute
//		                list a .type attribute
//		                with value token->value
//
//		       for ATTR_LABEL token:
//		           if token->value is empty
//		                     label:
//		               print missing type error
//		                     message
//		               skip to next attribute
//		                    label token
//		           else add to the attribute
//		                list an attribute with
//		                name = token->value and
//		                value yet unspecified
//
//		       for ATTR_TRUE token:
//		           if token->value is empty
//		                     label:
//		               print missing type error
//		                     message
//		               skip to next attribute
//		                    label token
//		           else add to the attribute
//		                list an attribute with
//		                name = token->value and
//		                value = min::TRUE
//
//		       for ATTR_FALSE token:
//		           ditto but with value =
//		                 min::FALSE
//
//		       for ATTR_VALUE token:
//		           if token->value is NONE:
//		                delete last item of
//		                   attribute list
//		               skip to next attribute
//		                    label token
//		           else install token->value
//		                as value of last attri-
//		                bute in attribute list
//
//		       for ATTR_MULTIVALUE token:
//		           install token->value
//		                as value of last attri-
//		                bute in attribute list
//
//		       for ATTR_FLAGS token:
//		           install token->value
//		                as flags of last attri-
//		                bute in attribute list
//
//                 compact subexpression with attributes
//                         taken attribute list formed
//                         above and elements taken from
//                         typed_data.elements to end
//                         of subexpression;
//                         token type =
//                               PREFIX if
//                                  .type attribute
//                                        value is
//                                        present,
//                                  tdata.middle_count
//                                        == 0, and
//                                  either tdata
//                                        .has_mark_type
//                                        is false or
//                                        or is_mark_
//                                           prefix
//                                  key has prefix_sep-
//                                      arators_allowed
//                                      true
//                               else BRACKETING if
//                                    .type is the only
//                                     attribute
//                                     or there are
//                                     no attributes
//                               else BRACKETED
//                         token value_type = .type
//                               attribute value if
//                               token type is PREFIX,
//                               else MISSING
//
//    		   delete special attribute tokens
//    		       // Delayed until after attribute
//    		       // list has been passed to
//    		       // compact function as attribute
//    		       // list members are not protected
//    		       // from GC.
//
//    		   if compacted token type == PREFIX:
//		       goto PREFIX_FOUND with
//		           prefix = the compacted token
//		           separator_found from parse
//		               of subexpression
//		           premature_closing = true
//		               iff bracket stack not
//		               closed by PREFIX token's
//		               typed opening's closing
//		               bracket
//
//             if closing bracket matching key's closing
//                        bracket NOT found:
//                 return separator_found
//             else:
//                 iterate loop to find next token
//
//         if key is closing bracket, and line_variables
//                is NULL or selectors & EAOCLOSING,
//                and closing bracket matches the
//                closing bracket of the first entry of
//                the bracket stack, or of any entry if
//                selectors & EAOCLOSING:
//             close bracket stack entry that matches
//                   key, indicating key closed entry
//             close all higher stack entries indicating
//                   that their closing brackets were
//                   not found and their subexpressions
//                   terminated just before the first
//                   token of key
//             return MISSING_POSITION
//
//         if key is selected indentation mark and
//                current is end of file or line break
//                or comment:
//             indentation_found = key
//             iterate loop to find next token
//             // See above for indented paragraph
//             // processing.
//
//         if key is line separator matching line_sep
//                argument and selectors & EALSEP:
//             remove line separator
//             return end position of removed separator
//
//         // Note: In the following the type of the
//         // previous key is determined by checking the
//         // value of typed_data->subtype.  If this is
//         // TYPED_OPENING no previous key in the
//         // subexpression has been (previously) found.
//
//         if key is typed middle matching typed_middle
//                component of typed_opening component
//                of a non-NULL typed_data argument,
//                or ditto for typed double middle,
//                and typed_data->has_mark_type
//                is false:
//
//             if typed_data->middle_count is even:
//
//                 if there is no previous typed key
//                          after the typed opening in
//                          the subexpression and there
//                          are tokens between the typed
//                          opening and the key
//                     make_type_label
//                         ( typed_data,
//			     first token of key )
//	           else if there is some other key in
//	                   the subexpression after the
//	                   typed opening:
//		       finish_attribute
//			   ( tdata,
//			     first token of key )
//		       move_attributes
//		           ( tdata,
//			     first token of key )
//
//              else if typed_data->middle_count is odd
//                      and typed_data->elements == NULL
//                      and there are elements between
//                          previous typed middle and
//                          current typed middle key:
//
//                  typed_data->elements = first token
//                      after previous typed middle
//
//             remove typed middle or double middle key
//	       typed_data->subtype = TYPED_MIDDLE
//	       typed_data->start_previous =
//	           current->previous
//             ++ typed_data->middle_count
//
//             if key was typed double middle:
//                 ++ typed_data->middle_count
//                 iterate loop to find next token
//
//	       if typed_data->middle_count is NOW even:
//	           selectors argument =
//	              typed_data->saved_selectors
//	       else if typed_data->middle_count is NOW
//	               odd:
//                 selectors argument non-options =
//                      typed_data->typed_opening
//                                ->attr_selectors
//                    | ALWAYS_SELECTOR
//
//             iterate loop to find next token
//
//         if key is typed attribute begin matching
//                typed_attr_begin component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is no previous typed key after
//                      the typed opening in the
//                      subexpression:
//                 make_type_label
//                     ( typed_data,
//			 first token of key )
//                 remove the typed attribute begin key
//                 typed_data->subtype = TYPED_ATTR_SEP
//	           typed_data->start_previous =
//	               current->previous
//
//	       else if typed_data->middle_count > 0 and
//	               there are tokens between the
//	               previous typed middle and the
//	               typed attribute begin key:
//		   finish_attribute
//		       ( typed_data,
//                       first token of key )
//		   move_attributes
//		       ( typed_data,
//                       first token of key )
//	           remove the typed attribute begin key
//                 typed_data->subtype =
//                     TYPED_ATTR_BEGIN
//	           typed_data->start_previous =
//	               current->previous
//
//	       else:
//	           announce typed attribute begin to be
//	               a punctuation error that is
//	               ignored
//	           remove it
//
//             iterate loop to find next token
//
//         if key is typed attribute equal matching
//                typed_attr_equal component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_
//                data->has_mark_type is false:
//
//             if there is no previous typed key in the
//                      subexpression, or the previous
//                      typed key is a typed middle,
//                      typed attribute separator,
//                      typed attribute negator, or
//                      typed attribute begin that is
//                      before any typed middle:
//                 make_attribute_label
//                     ( typed_data,
//                       first token of key )
//                 remove the typed attribute equal key
//                 typed_data->subtype =
//                     TYPED_ATTR_EQUAL
//	           typed_data->start_previous =
//	               current->previous
//
//	       else:
//	           announce typed attribute equal to be
//	           a punctuation error that is ignored,
//	           and remove it
//
//             iterate loop to find next token
//
//         if key is typed attribute separator matching
//                typed_attr_sep component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is no previous typed key in the
//                      subexpression, or the previous
//                      typed key is a typed middle,
//                      typed attribute separator, typed
//                      attribute equal, typed attribute
//                      negator, or typed attribute
//                      begin that is before any typed
//                      middle:
//		   finish_attribute
//		       ( typed_data,
//		         first token of key )
//                 remove the typed attribute separator
//                        key
//                 typed_data->subtype = TYPED_ATTR_SEP
//	           typed_data->start_previous =
//	               current->previous
//
//	       else announce typed attribute separator
//	            to be a a punctuation error that is
//	            ignored, and remove it
//
//             iterate loop to find next token
//
//         if key is typed attribute negator matching
//                typed_attr_negator component of typed_
//                opening component of a non-missing
//                typed_data argument, and typed_data->
//                middle_count is even, and typed_data->
//                has_mark_type is false:
//
//             if there is no previous typed key in the
//                      subexpression, or the previous
//                      typed key is a typed middle,
//                      typed attribute separator, or
//                      typed attribute begin that is
//                      before any typed middle
//                      and if
//                      the typed attribute negator
//                      immediately follows the subex-
//                      pression beginning or previous
//                      typed key:
//                 remove the typed attribute negator
//                 typed_data->subtype =
//                     TYPED_ATTR_NEGATOR
//	           typed_data->start_previous =
//	               current->previous
//
//                 iterate loop to find next token
//
//	       else do nothing (key will be rejected)
//
//         // reject key
//         //
//         iterate loop to refine key (by trying to
//                 find next shorter key) until it is
//                 selected or not found
//
//     iterate loop to find next token
