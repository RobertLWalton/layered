*PARSER*:
    print selector ""
        block standard: code
        block TOP LEVEL: data
        block TOP LEVEL: TOP LEVEL
    define selector my selector
ERROR: in line ##: extraneous stuff after:
    define selector operator 1 ++ extra stuff
                             ^
    print selector ""
        block standard: my selector
        block standard: code
        block TOP LEVEL: data
        block TOP LEVEL: TOP LEVEL
    print top level
        block standard:  selectors [TOP LEVEL, code]
                         options [end at le indent,
                                  end at line separator,
                                  end at outer closing]
        block TOP LEVEL:  selectors [TOP LEVEL]
                          options [end at le indent,
                                   end at line separator,
                                   end at outer closing]
    print trace
        [ + warnings, - parser input, - parser output,
          + parser commands, - subexpression elements,
          - subexpression details, - subexpression lines, - keys,
          - bracketed subexpressions ]
*PARSER*:
    trace [+ parser input]
WORD: "*PARSER*": line ##:
*PARSER*:
^^^^^^^^
SEPARATOR: ":": line ##:
*PARSER*:
        ^
LINE_BREAK: line ##:
*PARSER*:
         ^
INDENT: line ##:
    print trace
^^^^
WORD: "print": line ##:
    print trace
    ^^^^^
WORD: "trace": line ##:
    print trace
          ^^^^^
LINE_BREAK: line ##:
    print trace
               ^
INDENT: line ##:
*PARSER*:
^
*PARSER*:
    print trace
        [ + warnings, + parser input, - parser output,
          + parser commands, - subexpression elements,
          - subexpression details, - subexpression lines, - keys,
          - bracketed subexpressions ]
WORD: "*PARSER*": line ##:
*PARSER*:
^^^^^^^^
SEPARATOR: ":": line ##:
*PARSER*:
        ^
LINE_BREAK: line ##:
*PARSER*:
         ^
INDENT: line ##:
    trace [- parser input]
^^^^
WORD: "trace": line ##:
    trace [- parser input]
    ^^^^^
SEPARATOR: "[": line ##:
    trace [- parser input]
          ^
MARK: "-": line ##:
    trace [- parser input]
           ^
WORD: "parser": line ##:
    trace [- parser input]
             ^^^^^^
WORD: "input": line ##:
    trace [- parser input]
                    ^^^^^
SEPARATOR: "]": line ##:
    trace [- parser input]
                         ^
LINE_BREAK: line ##:
    trace [- parser input]
                          ^
INDENT: line ##:
    print trace
^^^^
WORD: "print": line ##:
    print trace
    ^^^^^
WORD: "trace": line ##:
    print trace
          ^^^^^
LINE_BREAK: line ##:
    print trace
               ^
LINE_BREAK: line ##:
<BLANK-LINE>
^
INDENT: line ##:
*PARSER*:
^
*PARSER*:
    trace [- parser input]
    print trace
        [ + warnings, - parser input, - parser output,
          + parser commands, - subexpression elements,
          - subexpression details, - subexpression lines, - keys,
          - bracketed subexpressions ]
*PARSER*:
    print top level
        block standard:  selectors [TOP LEVEL, code]
                         options [end at le indent,
                                  end at line separator,
                                  end at outer closing]
        block TOP LEVEL:  selectors [TOP LEVEL]
                          options [end at le indent,
                                   end at line separator,
                                   end at outer closing]
    define top level
        with parsing selectors [data, my selector]
        with parsing options [default options]
    print top level
        block standard:  selectors [TOP LEVEL, data, my selector]
                         options [end at le indent,
                                  end at line separator,
                                  end at outer closing]
        block TOP LEVEL:  selectors [TOP LEVEL]
                          options [end at le indent,
                                   end at line separator,
                                   end at outer closing]
    define top level
        with parsing selectors [TOP LEVEL, code]
        with parsing options [default options]
    print top level
        block standard:  selectors [TOP LEVEL, code]
                         options [end at le indent,
                                  end at line separator,
                                  end at outer closing]
        block TOP LEVEL:  selectors [TOP LEVEL]
                          options [end at le indent,
                                   end at line separator,
                                   end at outer closing]
    print bracket ""
        block TOP LEVEL: bracket [< "[" "<" >] ... [< ">" "]" >] [data]
                         with parsing selectors [- TOP LEVEL]
                         with label reformatter
        block TOP LEVEL: bracket [< "{" "*" >] ... [< "*" "}" >] [data]
                         with parsing selectors [- TOP LEVEL]
                         with multivalue reformatter ( "," )
        block TOP LEVEL: bracket "(" ... ")" [data]
                         with parsing selectors [- TOP LEVEL]
        block TOP LEVEL: bracket "[" ... "]" [data]
                         with parsing selectors [- TOP LEVEL]
        block TOP LEVEL: bracket "`" ... "'" [data]
                         with parsing selectors [- TOP LEVEL]
        block TOP LEVEL: bracket [< "{" "{" >] ... [< "}" "}" >] [data]
                         with parsing selectors [- TOP LEVEL]
        block TOP LEVEL: bracket [< "[" "$" >] ... [< "$" "]" >] [data]
                         with parsing selectors [- TOP LEVEL]
                         with special reformatter
    print typed bracket ""
        block TOP LEVEL: typed bracket "{" ... "|" ... "|" ... "}"
                         // "||" is also allowed.
                         [data]
                         with parsing selectors [- TOP LEVEL]
                         with attribute selectors [data]
                         with attributes ":" ... "=" ... ","
                         with attribute negator "no"
                         with attribute flags initiator "["
                         with attribute multivalue initiator [< "{" "*" >]
    print indentation mark ""
        block TOP LEVEL: indentation mark [< "*PARSER*" "*TEST*" ":" >] ... ";"
                         [TOP LEVEL]
                         with parsing selectors [- TOP LEVEL]
        block TOP LEVEL: indentation mark [< "*PARSER*" ":" >] ... ";"
                         [TOP LEVEL]
                         with parsing selectors [data]
        block TOP LEVEL: indentation mark [< "TOP" "LEVEL" >] []
                         with parsing selectors [- TOP LEVEL]
======= PARSER TEST: "[" x <+ y +> z "{" "|" 4 "|" w "}" m "(" n "(" p
                         ")" ")" "]"
======= END PARSER TEST(S)
*PARSER*:
    begin block X
    define top level
        with parsing selectors [+ data]
    print top level
        block X:  selectors [TOP LEVEL, data, code]
                  options [end at le indent, end at line separator,
                           end at outer closing]
        block standard:  selectors [TOP LEVEL, code]
                         options [end at le indent,
                                  end at line separator,
                                  end at outer closing]
        block TOP LEVEL:  selectors [TOP LEVEL]
                          options [end at le indent,
                                   end at line separator,
                                   end at outer closing]
======= PARSER TEST: [x <+ y +> z {w|4|w} m (n (p))]
======= END PARSER TEST(S)
*PARSER*:
    end block X
*PARSER*:
    trace [+ subexpression lines]
======= PARSER TEST:
======= line ##:
    [ x <+ y +> z {|4|w} m (n (p)) ]
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
======= END PARSER TEST(S)
*PARSER*:
    trace [- subexpression lines]
    trace [+ subexpression details]
======= PARSER TEST:
@@ = "[" x <+ y +> z "{" "|" 4 "|" w "}" m "(" n "(" p ")" ")" "]":
         .terminator = "<LF>"
         .position[H] = PACKED_VEC
         .initiator = [$ LOGICAL_LINE $]
======= END PARSER TEST(S)
*PARSER*:
    trace [+ subexpression elements]
======= PARSER TEST: "[" x <+ y +> z "{" "|" 4 "|" w "}" m "(" n "(" p
                         ")" ")" "]"
@@ = "[" x <+ y +> z "{" "|" 4 "|" w "}" m "(" n "(" p ")" ")" "]":
         .terminator = "<LF>"
         .position[H] = PACKED_VEC
         .initiator = [$ LOGICAL_LINE $]
======= END PARSER TEST(S)
*PARSER*:
    trace [- subexpression details]
======= PARSER TEST: "[" x <+ y +> z "{" "|" 4 "|" w "}" m "(" n "(" p
                         ")" ")" "]"
======= END PARSER TEST(S)
*PARSER*:
    trace [+ subexpression lines]
======= PARSER TEST: "[" x <+ y +> z "{" "|" 4 "|" w "}" m "(" n "(" p
                         ")" ")" "]"
======= line ##:
    [ x <+ y +> z {|4|w} m (n (p)) ]
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
======= END PARSER TEST(S)
*PARSER*:
    begin block X
    define top level
        with parsing selectors [+ data]
======= PARSER TEST: {x|{x||x} hi|x}
======= line ##:
    {x|{x} hi|}
    ^^^^^^^^^^^
------- line ##:
    {x|{x} hi|}
    ^^^^^^^^^^^
------- line ##:
    {x|{x} hi|}
       ^^^
======= END PARSER TEST(S)
*PARSER*:
    end block X
*PARSER*:
    begin block X
ERROR: in line ##: `"foo"' does not name a lexeme type:
    define mapped lexeme "foo" [data]
                         ^^^^^
    define mapped lexeme "PREMATURE_END_OF_FILE" [data]
        with token value {p}
    define mapped lexeme "PREMATURE_END_OF_FILE" [data]
    print mapped lexeme ""
        block X: mapped lexeme "PREMATURE_END_OF_FILE" [data]
        block X: mapped lexeme "PREMATURE_END_OF_FILE" [data]
                 with token value {p||p}
    end block X
    print mapped lexeme ""
        nothing found
*PARSER*:
    trace [+ parser output]
    begin block X
    define top level
        with lexical master DEFAULT
BRACKETED EXPRESSION:
    @hello there
    line ##:
@hello there
^^^^^^^^^^^^
*PARSER*:
    define top level
        with lexical master DATA-CHECK
    define mapped lexeme "DATA" [code, data]
        with token value {data}
BRACKETED EXPRESSION:
    {data|@hello there|data}
    line ###:
@hello there
^^^^^^^^^^^^
BRACKETED EXPRESSION:
    {data|@goodby there|data}
    line ###:
@goodby there
^^^^^^^^^^^^^
*PARSER*:
    end block X
BRACKETED EXPRESSION:
    @hello there
    line ###:
@hello there
^^^^^^^^^^^^
*PARSER*:
    begin block X
    define ID character "@"
    begin block Y
    define ID character disabled
    begin block Z
    define ID character "$"
    print ID character
        block Z: "$"
        block Y: disabled
        block X: "@"
        block standard: disabled
        block TOP LEVEL: disabled
    end block Z
    end block Y
    end block X
    print ID character
        block standard: disabled
        block TOP LEVEL: disabled
*PARSER*:
    begin block X
    define ID character "@"
    define top level
        with lexical master DATA-CHECK
    define mapped lexeme "DATA" [TOP LEVEL]
        with token value {data}
    define prefix "data" [TOP LEVEL]
        with parsing selectors [data]
        with data reformatter ( "=", "not", "[", "{*" )
ERROR: in line ###: previous uses of ID exist and will be dangling:
@@ = Jill
^^
BRACKETED EXPRESSION:
    ID 6 is {|PREALLOCATED(2*4) said `hello there Jack'|}
    line ###:
ID 6 is @@
^^^^^^^^^^
BRACKETED EXPRESSION:
    ID 4 is Jill
    line ###:
ID 4 is @@
^^^^^^^^^^
*PARSER*:
    print prefix ""
        block X: prefix "data" [TOP LEVEL]
                 with parsing selectors [data]
                 with data reformatter ( "=", "not", "[",
                 [< "{" "*" >] )
    print mapped lexeme ""
        block X: mapped lexeme "DATA" [TOP LEVEL]
                 with token value {data||data}
    end block X
