// Layers Language Parser Operator Command Test Data
//
// File:	ll_parser_oper_command_test.in
// Author:	Bob Walton (walton@acm.org)
// Date:	Fri Feb 14 21:38:15 EST 2014
//
// The authors have placed this data in the public
// domain; they make no warranty and accept no liability
// for this data.

parser print selector ""
parser print pass
parser print context ""
parser define pass operator [code, math] after top
parser print pass
parser trace [+ parser commands, + warnings ]
parser trace [+ subexpression elements,
              + subexpression lines ]
parser print selector ""
parser print operator ""

// Test define and undefine
//
parser begin block
parser test ( x / y ^ z w )
parser define operator "/" [code, math] infix
       with binary reformatter with precedence -100
parser print operator "/"
parser define operator "^" [code, math] infix
       with binary reformatter with precedence +100
parser test ( x / y ^ z w )
parser print operator ""
parser undefine operator "/" [code, math] infix
       with precedence -100
parser print operator "/"
parser test ( x / y ^ z w )
parser end block
parser print operator ""
parser test ( x / y ^ z w )

// Test erroneous defines and undefines
//
parser define operator "+" [code, math] infix
       with binary reformatter
parser define operator "+" [code, math]
       with precedence 3000
       with binary reformatter
parser define operator "+" [code, math] infix nofix
       with precedence 3000
       with binary reformatter
parser define operator "+" [code, math] nofix
       with precedence 3000
       with right associative reformatter
parser define operator "+" [code, math] nofix
       with precedence 3000
       with none such reformatter
parser undefine operator "+" [code, math] infix
parser undefine operator "+" [code, math] infix
       with precedence 3000
       with binary reformatter
parser undefine operator "+" [code, math]
       with precedence 3000
parser print operator ""

// Operators are introduced lowest precedence first

parser define operator "=" [code, math] infix
       with precedence 1000
       with right associative reformatter
parser define operator "+=" [code, math] infix
       with precedence 1000
       with right associative reformatter
parser define operator "-=" [code, math] infix
       with precedence 1000
       with right associative reformatter
parser define operator "*=" [code, math] infix
       with precedence 1000
       with right associative reformatter
parser define operator "/=" [code, math] infix
       with precedence 1000
       with right associative reformatter
parser test (x = y += z w *= p q r = t v)

parser define operator "," [code, math] nofix
       with precedence 2000
       with separator reformatter
parser test (x,y1,z w,,3,)

parser define operator "BUT NOT" [code, math] infix
       with precedence 3000
       with binary reformatter
parser define operator "AND" [code, math] infix
       with precedence 3100
       with infix reformatter
parser define operator "OR" [code, math] infix
       with precedence 3100
       with infix reformatter
parser define operator "NOT" [code, math] nofix
       with precedence 3100
       with unary reformatter
parser test (x OR y BUT NOT z AND w)
parser test (x OR y BUT NOT z AND w OR p)
parser test (NOT x y)
parser test (x NOT y)
parser test (NOT x AND y)
parser test (x AND NOT y)
parser test (x AND AND y)
parser test (NOT NOT x y)
parser test (NOT NOT)

parser define operator "==" [code, math] infix
       with precedence 4000
       with compare reformatter ( "AND" )
parser define operator "/=" [code, math] infix
       with precedence 4000
       with compare reformatter ( "AND" )
parser define operator "!=" [code, math] infix
       with precedence 4000
       with compare reformatter ( "AND" )
parser define operator "<" [code, math] infix
       with precedence 4000
       with compare reformatter ( "AND" )
parser define operator "<=" [code, math] infix
       with precedence 4000
       with compare reformatter ( "AND" )
parser define operator "=<" [code, math] infix
       with precedence 4000
       with compare reformatter ( "AND" )
parser define operator ">" [code, math] infix
       with precedence 4000
       with compare reformatter ( "AND" )
parser define operator ">=" [code, math] infix
       with precedence 4000
       with compare reformatter ( "AND" )
parser define operator "=>" [code, math] infix
       with precedence 4000
       with compare reformatter ( "AND" )
parser test ( x < y <= z > w != p q =< u v )

parser define operator "+" [code, math] infix
       with precedence 5000
       with sum reformatter ( "+", "-" )
parser define operator "-" [code, math] infix
       with precedence 5000
       with sum reformatter ( "+", "-" )
parser test ( x + y - z + w - v - u )
parser test ( - x + y - z )
parser test ( x < y + 5 <= z )

parser define operator "/" [code, math] infix
       with precedence 5100
       with binary reformatter
parser define operator "*" [code, math] infix
       with precedence 5200
       with infix reformatter
parser define operator "^" [code, math] infix
       with precedence 5300
       with binary reformatter
parser test ( x * y / z q * m p )
parser test ( x / y / z )
parser test ( x ^ 2 * y ^ 2 / y * z )

parser define operator "+" [code, math] prefix
       with precedence 10000
parser define operator "-" [code, math] prefix
       with precedence 10000
parser define operator "@" [code, math] prefix
       with precedence 10000
parser test ( - x + y - z )
parser test ( p * - x + y - z )
parser test ( @ x + y - @ z )
parser test ( + - + - x y )

parser define operator "++" [code, math] postfix
       with precedence 10001
parser define operator "--" [code, math] postfix
       with precedence 10001
parser test ( x ++ + y - z -- )
parser test ( x y ++ -- ++ -- )

parser define operator "<--" [code] nofix
       with precedence 0
       with declare reformatter
parser define operator bracket "{" ... "}" [code] afix
       with precedence 0
parser define operator indentation mark ":" [code] afix
       with precedence 0
parser test ( foo bar <-- boo bat { fee fie fo fum } )
parser test ( foo bar <-- { fee fie fo fum } )
parser test ( <-- boo bat { fee fie fo fum } )
parser test ( foo bar <-- )
parser test:
    foo bar <-- boo bat:
    	fee fie fo fum
	he ha ho hum

parser print operator ""

// Temporary tests
