parser print context "default":
    block standard: "default" [code]
    block TOP-LEVEL: "default" []
parser trace [+ parser commands, + warnings ]
parser trace [+ subexpression elements,
              + subexpression lines ]
parser print selector "":
    block standard: text
    block standard: math
    block TOP-LEVEL: code
    block TOP-LEVEL: parser
parser print operator "":
    not found
parser begin block
======= TEST: parser test (x / y ^ z w)
------- line 21:
parser test ( x / y ^ z w )
^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 21:
parser test ( x / y ^ z w )
            ^^^^^^^^^^^^^^^
======= END TEST
parser define operator "/" [code, math] infix
       with binary reformatter with precedence 5100
parser print operator "/":
    block block: operator "/" [code, math]
                 infix
                 with precedence 5100
                 with reformatter binary
parser define operator "^" [code, math] infix
       with binary reformatter with precedence 5300
======= TEST: parser test (/ x [. ^ y [. z w .] .])
------- line 27:
parser test ( x / y ^ z w )
^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 27:
parser test ( x / y ^ z w )
            ^^^^^^^^^^^^^^^
------- line 27:
parser test ( x / y ^ z w )
                  ^^^^^^^
------- line 27:
parser test ( x / y ^ z w )
                      ^^^
======= END TEST
parser undefine operator "/" [code, math] infix
       with precedence 5100
parser print operator "/":
    block block: operator "/" []
                 infix
                 with precedence 5100
                 with reformatter binary
======= TEST: parser test (^ [. x / y .] [. z w .])
------- line 31:
parser test ( x / y ^ z w )
^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 31:
parser test ( x / y ^ z w )
            ^^^^^^^^^^^^^^^
------- line 31:
parser test ( x / y ^ z w )
              ^^^^^
------- line 31:
parser test ( x / y ^ z w )
                      ^^^
======= END TEST
parser end block
parser print operator "/":
    not found
======= TEST: parser test (x / y ^ z w)
------- line 34:
parser test ( x / y ^ z w )
^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 34:
parser test ( x / y ^ z w )
            ^^^^^^^^^^^^^^^
======= END TEST
ERROR: in line 39: expected `with precedence ...' after:
       with binary reformatter
                   ^^^^^^^^^^^
ERROR: in line 40: expected operator flags after:
parser define operator "+" [code, math]
                           ^^^^^^^^^^^^
ERROR: in line 43: operator flags nofix and infix are incompatible:
parser define operator "+" [code, math] infix nofix
                                        ^^^^^^^^^^^
ERROR: in lines 46-48: `right associative' reformatter incompatible with
       nofix operator flag(s):
parser define operator "+" [code, math] nofix
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
       with precedence 3000
^^^^^^^^^^^^^^^^^^^^^^^^^^^
       with right associative reformatter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ERROR: in line 51: undefined reformatter name:
       with none such reformatter
            ^^^^^^^^^
ERROR: in line 52: expected `with precedence ...' after:
parser undefine operator "+" [code, math] infix
                                          ^^^^^
ERROR: in lines 53-55: did NOT expect `with ... reformatter':
parser undefine operator "+" [code, math] infix
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
       with precedence 3000
^^^^^^^^^^^^^^^^^^^^^^^^^^^
       with binary reformatter
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ERROR: in line 56: expected operator flags after:
parser undefine operator "+" [code, math]
                             ^^^^^^^^^^^^
parser print operator "":
    not found
parser define operator "=" [code, math] infix
       with precedence 1000
       with right associative reformatter
parser define operator "+=" [code, math] infix
       with precedence 1000
       with right associative reformatter
parser define operator "-=" [code, math] infix
       with precedence 1000
       with right associative reformatter
parser define operator "*=" [code, math] infix
       with precedence 1000
       with right associative reformatter
parser define operator "/=" [code, math] infix
       with precedence 1000
       with right associative reformatter
======= TEST: parser test
              (= x
               [. += y
                  [. *= [. z w .] [. = [. p q r .] [. t v .] .] .] .])
------- line 77:
parser test (x = y += z w *= p q r = t v)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 77:
parser test (x = y += z w *= p q r = t v)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 77:
parser test (x = y += z w *= p q r = t v)
                 ^^^^^^^^^^^^^^^^^^^^^^^
------- line 77:
parser test (x = y += z w *= p q r = t v)
                      ^^^^^^^^^^^^^^^^^^
------- line 77:
parser test (x = y += z w *= p q r = t v)
                      ^^^
------- line 77:
parser test (x = y += z w *= p q r = t v)
                             ^^^^^^^^^^^
------- line 77:
parser test (x = y += z w *= p q r = t v)
                             ^^^^^
------- line 77:
parser test (x = y += z w *= p q r = t v)
                                     ^^^
======= END TEST
parser define operator "," [code, math] nofix
       with precedence 2000
       with separator reformatter
======= TEST: parser test (x, [. y 1 .], [. z w .], [.  .], 3, [.  .])
------- line 82:
parser test (x,y1,z w,,3,)
^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 82:
parser test (x,y1,z w,,3,)
            ^^^^^^^^^^^^^^
------- line 82:
parser test (x,y1,z w,,3,)
               ^^
------- line 82:
parser test (x,y1,z w,,3,)
                  ^^^
------- line 82:
parser test (x,y1,z w,,3,)
                      ^
------- line 82:
parser test (x,y1,z w,,3,)
                         ^
======= END TEST
parser define operator "BUT NOT" [code, math] nofix
       with precedence 3000
       with binary reformatter
parser define operator "AND" [code, math] infix
       with precedence 3100
       with infix reformatter
parser define operator "OR" [code, math] infix
       with precedence 3100
       with infix reformatter
parser define operator "NOT" [code, math] nofix
       with precedence 3100
       with prefix reformatter
======= TEST: parser test (BUT NOT [. OR x y .] [. AND z w .])
------- line 96:
parser test (x OR y BUT NOT z AND w)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 96:
parser test (x OR y BUT NOT z AND w)
            ^^^^^^^^^^^^^^^^^^^^^^^^
------- line 96:
parser test (x OR y BUT NOT z AND w)
             ^^^^^^
------- line 96:
parser test (x OR y BUT NOT z AND w)
                            ^^^^^^^
======= END TEST
ERROR: operator `OR' is not the same as first operator `AND' in
       subexpression; all operators must be the same in this
       subexpression; line 97:
parser test (x OR y BUT NOT z AND w OR p)
                            ^^^^^^^^^^^^
======= TEST: parser test (BUT NOT [. OR x y .] [. AND z w p .])
------- line 97:
parser test (x OR y BUT NOT z AND w OR p)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 97:
parser test (x OR y BUT NOT z AND w OR p)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 97:
parser test (x OR y BUT NOT z AND w OR p)
             ^^^^^^
------- line 97:
parser test (x OR y BUT NOT z AND w OR p)
                            ^^^^^^^^^^^^
======= END TEST
======= TEST: parser test (NOT [. x y .])
------- line 98:
parser test (NOT x y)
^^^^^^^^^^^^^^^^^^^^^
------- line 98:
parser test (NOT x y)
            ^^^^^^^^^
------- line 98:
parser test (NOT x y)
                 ^^^
======= END TEST
ERROR: operator `NOT' NOT at beginning of subexpression; subexpression
       should be of form `operator operand'; line 99:
parser test (x NOT y)
             ^^^^^^^
ERROR: subexpression is too long; subexpression should be of form
       `operator operand'; line 99:
parser test (x NOT y)
             ^^^^^^^
======= TEST: parser test (x NOT y)
------- line 99:
parser test (x NOT y)
^^^^^^^^^^^^^^^^^^^^^
------- line 99:
parser test (x NOT y)
            ^^^^^^^^^
======= END TEST
ERROR: too many operators in subexpression; subexpression should be of
       form `operator operand'; line 100:
parser test (NOT x AND y)
             ^^^^^^^^^^^
ERROR: subexpression is too long; subexpression should be of form
       `operator operand'; line 100:
parser test (NOT x AND y)
             ^^^^^^^^^^^
======= TEST: parser test (NOT x AND y)
------- line 100:
parser test (NOT x AND y)
^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 100:
parser test (NOT x AND y)
            ^^^^^^^^^^^^^
======= END TEST
ERROR: missing operand inserted; line 101:
parser test (x AND NOT y)
                   ^
ERROR: operator `NOT' is not the same as first operator `AND' in
       subexpression; all operators must be the same in this
       subexpression; line 101:
parser test (x AND NOT y)
             ^^^^^^^^^^^
======= TEST: parser test (AND x ERROR'OPERAND y)
------- line 101:
parser test (x AND NOT y)
^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 101:
parser test (x AND NOT y)
            ^^^^^^^^^^^^^
======= END TEST
parser define operator "==" [code, math] infix
       with precedence 4000
       with compare reformatter
parser define operator "/=" [code, math] infix
       with precedence 4000
       with compare reformatter
parser define operator "!=" [code, math] infix
       with precedence 4000
       with compare reformatter
parser define operator "<" [code, math] infix
       with precedence 4000
       with compare reformatter
parser define operator "<=" [code, math] infix
       with precedence 4000
       with compare reformatter
parser define operator "=<" [code, math] infix
       with precedence 4000
       with compare reformatter
parser define operator ">" [code, math] infix
       with precedence 4000
       with compare reformatter
parser define operator ">=" [code, math] infix
       with precedence 4000
       with compare reformatter
parser define operator "=>" [code, math] infix
       with precedence 4000
       with compare reformatter
======= TEST: parser test
              (AND [. < x [. $ 0 y .] .] [. <= [. $ 0 .] [. $ 1 z .] .]
               [. > [. $ 1 .] [. $ 2 w .] .]
               [. != [. $ 2 .] [. $ 3 [. p q .] .] .]
               [. =< [. $ 3 .] [. u v .] .])
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
              ^^^^^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                  ^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                  ^^^^^^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                  ^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                       ^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                       ^^^^^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                       ^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                           ^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                           ^^^^^^^^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                           ^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                                ^^^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                                ^^^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                                ^^^^^^^^^^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                                ^^^
------- line 130:
parser test ( x < y <= z > w != p q =< u v )
                                       ^^^
======= END TEST
parser define operator "+" [code, math] infix
       with precedence 5000
       with sum reformatter
parser define operator "-" [code, math] infix
       with precedence 5000
       with sum reformatter
======= TEST: parser test (+ x y [. - z .] w [. - v .] [. - u .])
------- line 138:
parser test ( x + y - z + w - v - u )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 138:
parser test ( x + y - z + w - v - u )
            ^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 138:
parser test ( x + y - z + w - v - u )
                    ^^^
------- line 138:
parser test ( x + y - z + w - v - u )
                            ^^^
------- line 138:
parser test ( x + y - z + w - v - u )
                                ^^^
======= END TEST
======= TEST: parser test (+ [. - x .] y [. - z .])
------- line 139:
parser test ( - x + y - z )
^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 139:
parser test ( - x + y - z )
            ^^^^^^^^^^^^^^^
------- line 139:
parser test ( - x + y - z )
              ^^^
------- line 139:
parser test ( - x + y - z )
                      ^^^
======= END TEST
======= TEST: parser test
              (AND [. < x [. $ 4 [. + y 5 .] .] .] [. <= [. $ 4 .] z .])
------- line 140:
parser test ( x < y + 5 <= z )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 140:
parser test ( x < y + 5 <= z )
            ^^^^^^^^^^^^^^^^^^
------- line 140:
parser test ( x < y + 5 <= z )
              ^^^^^^^^^
------- line 140:
parser test ( x < y + 5 <= z )
                  ^^^^^
------- line 140:
parser test ( x < y + 5 <= z )
                  ^^^^^
------- line 140:
parser test ( x < y + 5 <= z )
                  ^^^^^^^^^^
------- line 140:
parser test ( x < y + 5 <= z )
                  ^^^^^
======= END TEST
parser define operator "/" [code, math] infix
       with precedence 5100
       with binary reformatter
parser define operator "*" [code, math] infix
       with precedence 5200
       with infix reformatter
parser define operator "^" [code, math] infix
       with precedence 5300
       with binary reformatter
======= TEST: parser test (/ [. * x y .] [. * [. z q .] [. m p .] .])
------- line 151:
parser test ( x * y / z q * m p )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 151:
parser test ( x * y / z q * m p )
            ^^^^^^^^^^^^^^^^^^^^^
------- line 151:
parser test ( x * y / z q * m p )
              ^^^^^
------- line 151:
parser test ( x * y / z q * m p )
                      ^^^^^^^^^
------- line 151:
parser test ( x * y / z q * m p )
                      ^^^
------- line 151:
parser test ( x * y / z q * m p )
                            ^^^
======= END TEST
ERROR: too many operators in subexpression; subexpression should be of
       form `operand operator operand'; line 152:
parser test ( x / y / z )
              ^^^^^^^^^
ERROR: subexpression is too long; subexpression should be of form
       `operand operator operand'; line 152:
parser test ( x / y / z )
              ^^^^^^^^^
======= TEST: parser test (x / y / z)
------- line 152:
parser test ( x / y / z )
^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 152:
parser test ( x / y / z )
            ^^^^^^^^^^^^^
======= END TEST
======= TEST: parser test
              (/ [. * [. ^ x 2 .] [. ^ y 2 .] .] [. * y z .])
------- line 153:
parser test ( x ^ 2 * y ^ 2 / y * z )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 153:
parser test ( x ^ 2 * y ^ 2 / y * z )
            ^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 153:
parser test ( x ^ 2 * y ^ 2 / y * z )
              ^^^^^^^^^^^^^
------- line 153:
parser test ( x ^ 2 * y ^ 2 / y * z )
              ^^^^^
------- line 153:
parser test ( x ^ 2 * y ^ 2 / y * z )
                      ^^^^^
------- line 153:
parser test ( x ^ 2 * y ^ 2 / y * z )
                              ^^^^^
======= END TEST
parser define operator "+" [code, math] prefix
       with precedence 10000
       with prefix reformatter
parser define operator "-" [code, math] prefix
       with precedence 10000
       with prefix reformatter
parser define operator "@" [code, math] prefix
       with precedence 10000
       with prefix reformatter
======= TEST: parser test (+ [. - x .] y [. - z .])
------- line 164:
parser test ( - x + y - z )
^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 164:
parser test ( - x + y - z )
            ^^^^^^^^^^^^^^^
------- line 164:
parser test ( - x + y - z )
              ^^^
------- line 164:
parser test ( - x + y - z )
                      ^^^
======= END TEST
======= TEST: parser test (+ [. * p [. - x .] .] y [. - z .])
------- line 165:
parser test ( p * - x + y - z )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 165:
parser test ( p * - x + y - z )
            ^^^^^^^^^^^^^^^^^^^
------- line 165:
parser test ( p * - x + y - z )
              ^^^^^^^
------- line 165:
parser test ( p * - x + y - z )
                  ^^^
------- line 165:
parser test ( p * - x + y - z )
                          ^^^
======= END TEST
======= TEST: parser test (+ [. @ x .] y [. - [. @ z .] .])
------- line 166:
parser test ( @ x + y - @ z )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 166:
parser test ( @ x + y - @ z )
            ^^^^^^^^^^^^^^^^^
------- line 166:
parser test ( @ x + y - @ z )
              ^^^
------- line 166:
parser test ( @ x + y - @ z )
                      ^^^^^
------- line 166:
parser test ( @ x + y - @ z )
                        ^^^
======= END TEST
======= TEST: parser test (+ [. - [. + [. - [. x y .] .] .] .])
------- line 167:
parser test ( + - + - x y )
^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 167:
parser test ( + - + - x y )
            ^^^^^^^^^^^^^^^
------- line 167:
parser test ( + - + - x y )
                ^^^^^^^^^
------- line 167:
parser test ( + - + - x y )
                  ^^^^^^^
------- line 167:
parser test ( + - + - x y )
                    ^^^^^
------- line 167:
parser test ( + - + - x y )
                      ^^^
======= END TEST
parser define operator "++" [code, math] postfix
       with precedence 10001
       with postfix reformatter
parser define operator "--" [code, math] postfix
       with precedence 10001
       with postfix reformatter
======= TEST: parser test (+ [. x ++ .] y [. - [. z -- .] .])
------- line 175:
parser test ( x ++ + y - z -- )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 175:
parser test ( x ++ + y - z -- )
            ^^^^^^^^^^^^^^^^^^^
------- line 175:
parser test ( x ++ + y - z -- )
              ^^^^
------- line 175:
parser test ( x ++ + y - z -- )
                       ^^^^^^
------- line 175:
parser test ( x ++ + y - z -- )
                         ^^^^
======= END TEST
======= TEST: parser test ([. [. [. [. x y .] ++ .] -- .] ++ .] --)
------- line 176:
parser test ( x y ++ -- ++ -- )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 176:
parser test ( x y ++ -- ++ -- )
            ^^^^^^^^^^^^^^^^^^^
------- line 176:
parser test ( x y ++ -- ++ -- )
              ^^^^^^^^^^^^
------- line 176:
parser test ( x y ++ -- ++ -- )
              ^^^^^^^^^
------- line 176:
parser test ( x y ++ -- ++ -- )
              ^^^^^^
------- line 176:
parser test ( x y ++ -- ++ -- )
              ^^^
======= END TEST
parser define operator "declare" [code] nofix
       with precedence 0
parser define operator "<--" [code] afix
       with precedence 0
parser define operator bracket "{" ... "}" [code] afix
       with precedence 0
======= TEST: parser test
              (we declare [. foo bar .] <-- [. boo bat .]
               {fee fie fo fum})
------- line 184:
parser test ( we declare foo bar <-- boo bat { fee fie fo fum } )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 184:
parser test ( we declare foo bar <-- boo bat { fee fie fo fum } )
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 184:
parser test ( we declare foo bar <-- boo bat { fee fie fo fum } )
                         ^^^^^^^
------- line 184:
parser test ( we declare foo bar <-- boo bat { fee fie fo fum } )
                                     ^^^^^^^
------- line 184:
parser test ( we declare foo bar <-- boo bat { fee fie fo fum } )
                                             ^^^^^^^^^^^^^^^^^^
======= END TEST
parser print operator "":
    block standard: operator "*" [code, math]
                    infix
                    with precedence 5200
                    with reformatter infix
    block standard: operator "+" [code, math]
                    prefix
                    with precedence 10000
                    with reformatter prefix
    block standard: operator "+" [code, math]
                    infix
                    with precedence 5000
                    with reformatter sum
    block standard: operator "," [code, math]
                    nofix
                    with precedence 2000
                    with reformatter separator
    block standard: operator "-" [code, math]
                    prefix
                    with precedence 10000
                    with reformatter prefix
    block standard: operator "-" [code, math]
                    infix
                    with precedence 5000
                    with reformatter sum
    block standard: operator "/" [code, math]
                    infix
                    with precedence 5100
                    with reformatter binary
    block standard: operator "<" [code, math]
                    infix
                    with precedence 4000
                    with reformatter compare
    block standard: operator "=" [code, math]
                    infix
                    with precedence 1000
                    with reformatter right associative
    block standard: operator ">" [code, math]
                    infix
                    with precedence 4000
                    with reformatter compare
    block standard: operator "@" [code, math]
                    prefix
                    with precedence 10000
                    with reformatter prefix
    block standard: operator "!=" [code, math]
                    infix
                    with precedence 4000
                    with reformatter compare
    block standard: operator "^" [code, math]
                    infix
                    with precedence 5300
                    with reformatter binary
    block standard: operator "NOT" [code, math]
                    nofix
                    with precedence 3100
                    with reformatter prefix
    block standard: operator "<--" [code]
                    afix
                    with precedence 0
    block standard: operator "BUT NOT" [code, math]
                    nofix
                    with precedence 3000
                    with reformatter binary
    block standard: operator "declare" [code]
                    nofix
                    with precedence 0
    block standard: operator "*=" [code, math]
                    infix
                    with precedence 1000
                    with reformatter right associative
    block standard: operator "++" [code, math]
                    postfix
                    with precedence 10001
                    with reformatter postfix
    block standard: operator "+=" [code, math]
                    infix
                    with precedence 1000
                    with reformatter right associative
    block standard: operator "<=" [code, math]
                    infix
                    with precedence 4000
                    with reformatter compare
    block standard: operator "AND" [code, math]
                    infix
                    with precedence 3100
                    with reformatter infix
    block standard: operator "=<" [code, math]
                    infix
                    with precedence 4000
                    with reformatter compare
    block standard: operator "==" [code, math]
                    infix
                    with precedence 4000
                    with reformatter compare
    block standard: operator "--" [code, math]
                    postfix
                    with precedence 10001
                    with reformatter postfix
    block standard: operator "=>" [code, math]
                    infix
                    with precedence 4000
                    with reformatter compare
    block standard: operator "-=" [code, math]
                    infix
                    with precedence 1000
                    with reformatter right associative
    block standard: operator ">=" [code, math]
                    infix
                    with precedence 4000
                    with reformatter compare
    block standard: operator "OR" [code, math]
                    infix
                    with precedence 3100
                    with reformatter infix
    block standard: operator "/=" [code, math]
                    infix
                    with precedence 4000
                    with reformatter compare
    block standard: operator "/=" [code, math]
                    infix
                    with precedence 1000
                    with reformatter right associative
    block standard: bracket "{" ... "}" [code]
                    afix
                    with precedence 0
parser define operator bracket "{" ... "}" [code] infix
        with precedence 1
======= TEST: parser test ([. x y .] {z w} [. m n .])
------- line 191:
parser test ( x y { z w } m n )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
------- line 191:
parser test ( x y { z w } m n )
            ^^^^^^^^^^^^^^^^^^^
------- line 191:
parser test ( x y { z w } m n )
              ^^^
------- line 191:
parser test ( x y { z w } m n )
                  ^^^^^^^
------- line 191:
parser test ( x y { z w } m n )
                          ^^^
======= END TEST
